--- vdr-2.3.2/config.c.orig	2017-03-16 19:07:06.037123593 +0100
+++ vdr-2.3.2/config.c	2017-03-16 19:10:02.846918131 +0100
@@ -395,6 +395,9 @@
   PositionerSpeed = 15;
   PositionerSwing = 650;
   PositionerLastLon = 0;
+  PowerdownEnabled = 1;
+  PowerdownTimeoutS = 15;
+  PowerdownWakeupH = 4;
   SetSystemTime = 0;
   TimeSource = 0;
   TimeTransponder = 0;
@@ -627,6 +630,9 @@
   else if (!strcasecmp(Name, "PositionerSpeed"))     PositionerSpeed    = atoi(Value);
   else if (!strcasecmp(Name, "PositionerSwing"))     PositionerSwing    = atoi(Value);
   else if (!strcasecmp(Name, "PositionerLastLon"))   PositionerLastLon  = atoi(Value);
+  else if (!strcasecmp(Name, "PowerdownEnabled"))    PowerdownEnabled   = atoi(Value);
+  else if (!strcasecmp(Name, "PowerdownTimeoutS"))   PowerdownTimeoutS  = atoi(Value);
+  else if (!strcasecmp(Name, "PowerdownWakeupH"))    PowerdownWakeupH   = atoi(Value);
   else if (!strcasecmp(Name, "SetSystemTime"))       SetSystemTime      = atoi(Value);
   else if (!strcasecmp(Name, "TimeSource"))          TimeSource         = cSource::FromString(Value);
   else if (!strcasecmp(Name, "TimeTransponder"))     TimeTransponder    = atoi(Value);
@@ -763,6 +769,9 @@
   Store("PositionerSpeed",    PositionerSpeed);
   Store("PositionerSwing",    PositionerSwing);
   Store("PositionerLastLon",  PositionerLastLon);
+  Store("PowerdownEnabled",   PowerdownEnabled);
+  Store("PowerdownTimeoutS",  PowerdownTimeoutS);
+  Store("PowerdownWakeupH",   PowerdownWakeupH);
   Store("SetSystemTime",      SetSystemTime);
   Store("TimeSource",         cSource::ToString(TimeSource));
   Store("TimeTransponder",    TimeTransponder);
--- vdr-2.3.2/config.h.orig	2017-03-16 19:07:06.037123593 +0100
+++ vdr-2.3.2/config.h	2017-03-16 19:10:02.846918131 +0100
@@ -277,6 +277,9 @@
   int PositionerSpeed;
   int PositionerSwing;
   int PositionerLastLon;
+  int PowerdownEnabled;
+  int PowerdownTimeoutS;
+  int PowerdownWakeupH;
   int SetSystemTime;
   int TimeSource;
   int TimeTransponder;
--- vdr-2.3.2/device.c.orig	2016-12-23 15:43:44.000000000 +0100
+++ vdr-2.3.2/device.c	2017-03-16 19:18:45.856373219 +0100
@@ -103,6 +103,9 @@
   dvbSubtitleConverter = NULL;
   autoSelectPreferredSubtitleLanguage = true;
 
+  idleTimerExpires = time(NULL) + Setup.PowerdownTimeoutS;
+  wakeupTimerExpires = 0;
+
   for (int i = 0; i < MAXRECEIVERS; i++)
       receiver[i] = NULL;
 
@@ -832,6 +835,10 @@
      }
   return result;
 }
+// While switching to a channel, the device will be kept powered up
+// for at least this number of seconds before a receiver is attached.
+// Must be less than cEITScanner::ScanTimeout.
+#define CHANNEL_SWITCH_POWERUP_TIMEOUT  10
 
 eSetChannelResult cDevice::SetChannel(const cChannel *Channel, bool LiveView)
 {
@@ -873,6 +880,7 @@
         Result = scrNotAvailable;
      }
   else {
+	PowerUp(CHANNEL_SWITCH_POWERUP_TIMEOUT);
      // Stop section handling:
      if (sectionHandler) {
         sectionHandler->SetStatus(false);
@@ -938,8 +946,11 @@
 
 void cDevice::SetOccupied(int Seconds)
 {
-  if (Seconds >= 0)
+  if (Seconds >= 0) {
      occupiedTimeout = time(NULL) + min(Seconds, MAXOCCUPIEDTIMEOUT);
+     // avoid short power-down/power-up cycles
+     SetIdleTimer(true, Seconds + 30);
+     }
 }
 
 bool cDevice::SetChannelDevice(const cChannel *Channel, bool LiveView)
@@ -1796,6 +1807,7 @@
                }
             }
          Start();
+	  SetIdleTimer(false);
          return true;
          }
       }
@@ -1829,8 +1841,10 @@
            camSlot->Assign(NULL);
         }
      }
-  if (!receiversLeft)
+  if (!receiversLeft) {
      Cancel(-1);
+     SetIdleTimer(true);
+  }
 }
 
 void cDevice::DetachAll(int Pid)
@@ -1894,6 +1908,81 @@
            }
      }
 }
+void cDevice::CheckIdle(void)
+{
+  if (!SupportsPowerDown() || !Setup.PowerdownEnabled)
+     return;
+  cMutexLock MutexLock(&mutexPowerSaving);
+  if (idleTimerExpires != 0 && time(NULL) > idleTimerExpires) {
+     // idle, powered up
+     dsyslog("power saving: device %d idle timer expired", CardIndex() + 1);
+     SetIdleTimer(false);
+     if (Setup.PowerdownWakeupH != 0)
+        wakeupTimerExpires = time(NULL) + Setup.PowerdownWakeupH * 3600;
+     else
+        dsyslog("power saving: waking up is disabled");
+     if (!IsPoweredDown()) {
+        dsyslog("power saving: powering device %d down", CardIndex() + 1);
+        if (sectionHandler) {
+           sectionHandler->SetStatus(false);
+           sectionHandler->SetChannel(NULL);
+           }
+        PowerDown(true);
+        }
+     }
+  if (wakeupTimerExpires != 0 && time(NULL) > wakeupTimerExpires) {
+     // idle, powered down
+     dsyslog("power saving: device %d wakeup timer expired", CardIndex() + 1);
+     SetIdleTimer(true);
+     if (IsPoweredDown()) {
+        dsyslog("power saving: waking up device %d", CardIndex() + 1);
+        PowerDown(false);
+        }
+     }
+}
+
+void cDevice::SetIdleTimer(bool On, int ExtraTimeoutS)
+{
+  if (!SupportsPowerDown())
+     return;
+  cMutexLock MutexLock(&mutexPowerSaving);
+  if (On) {
+     int Tout = Setup.PowerdownTimeoutS;
+     time_t Now = time(NULL);
+     if (ExtraTimeoutS > 0) {
+        if (idleTimerExpires >= Now + ExtraTimeoutS)
+           return;
+        Tout = ExtraTimeoutS;
+        }
+     idleTimerExpires = Now + Tout;
+     if (Setup.PowerdownEnabled)
+        dsyslog("power saving: set device %d idle timer to %d sec", CardIndex() + 1, Tout);
+     }
+  else {
+     idleTimerExpires = 0;
+     if (Setup.PowerdownEnabled)
+        dsyslog("power saving: disable device %d idle timer", CardIndex() + 1);
+     }
+  wakeupTimerExpires = 0;
+}
+
+bool cDevice::PoweredDown(void)
+{
+  if (SupportsPowerDown() && Setup.PowerdownEnabled) {
+     cMutexLock MutexLock(&mutexPowerSaving);
+     return IsPoweredDown();
+     }
+  else
+     return false;
+}
+
+void cDevice::PowerUp(int ExtraTimeoutS)
+{
+  cMutexLock MutexLock(&mutexPowerSaving);
+  SetIdleTimer(true, ExtraTimeoutS);
+  if (SupportsPowerDown() && IsPoweredDown())
+     PowerDown(false);
+}
 
 uchar *cTSBuffer::Get(int *Available, bool CheckAvailable)
 {
--- vdr-2.3.2/device.h.orig	2017-03-16 19:07:06.113122646 +0100
+++ vdr-2.3.2/device.h	2017-03-16 19:10:02.846918131 +0100
@@ -859,6 +859,35 @@
        ///< Detaches all receivers from this device for this pid.
   virtual void DetachAllReceivers(void);
        ///< Detaches all receivers from this device.
+
+// Power saving facilities
+
+private:
+  cMutex mutexPowerSaving;
+  time_t idleTimerExpires, wakeupTimerExpires;
+  void PowerUp(int ExtraTimeoutS);
+       ///< If the device is powered down, powers it up and keeps it
+       ///< powered up for at least ExtraTimeoutS seconds (see
+       ///< cDevice::SetIdleTimer()).
+public:
+  void CheckIdle(void);
+       ///< Should be called periodically in the main loop.
+  bool PoweredDown(void);
+       ///< Returns true if the device is powered down "logically", that is,
+       ///< idle tasks like EPG scanning are disabled.
+  void SetIdleTimer(bool On, int ExtraTimeoutS = 0);
+       ///< Starts/disables the idle timer. This timer must be started when
+       ///< a device gets idle and must be disabled when it is receiving.
+       ///< If ExtraTimeoutS is greater than zero and On is true, a new timer
+       ///< won't be set, but the device will be kept powered up for at least
+       ///< ExtraTimeoutS seconds.
+protected:
+  virtual bool IsPoweredDown(void) {return false;}
+       ///< Returns true if the device is powered down "physically".
+  virtual void PowerDown(bool On) {};
+       ///< Actually powers the device down/up.
+  virtual bool SupportsPowerDown() {return false;}
+       ///< Returns true if a derived device supports power saving.
   };
 
 /// Derived cDevice classes that can receive channels will have to provide
--- vdr-2.3.2/dvbdevice.c.orig	2016-11-07 14:55:58.000000000 +0100
+++ vdr-2.3.2/dvbdevice.c	2017-03-16 19:20:10.499312232 +0100
@@ -352,6 +352,8 @@
   bool GetSignalStats(int &Valid, double *Strength = NULL, double *Cnr = NULL, double *BerPre = NULL, double *BerPost = NULL, double *Per = NULL, int *Status = NULL) const;
   int GetSignalStrength(void) const;
   int GetSignalQuality(void) const;
+  bool IsPoweredDown(void) {return fd_frontend < 0;}
+  void PowerDown(bool On);
   };
 
 cMutex cDvbTuner::bondMutex;
@@ -551,6 +553,8 @@
 
 bool cDvbTuner::GetFrontendStatus(fe_status_t &Status) const
 {
+  if (fd_frontend < 0)
+     return false;
   ClearEventQueue();
   while (1) {
         if (ioctl(fd_frontend, FE_READ_STATUS, &Status) != -1)
@@ -576,6 +580,8 @@
 
 bool cDvbTuner::GetSignalStats(int &Valid, double *Strength, double *Cnr, double *BerPre, double *BerPost, double *Per, int *Status) const
 {
+  if (fd_frontend < 0)
+     return -1;
   ClearEventQueue();
   fe_status_t FeStatus;
   dtv_property Props[MAXFRONTENDCMDS];
@@ -1225,6 +1231,26 @@
         }
 }
 
+void cDvbTuner::PowerDown(bool On)
+{
+  cMutexLock MutexLock(&mutex);
+  if (On && fd_frontend >= 0) {
+     isyslog("dvb tuner: power-down - closing frontend %d/%d", adapter, frontend);
+     tunerStatus = tsIdle;
+     close(fd_frontend);
+     fd_frontend = -1;
+     }
+  if (!On && fd_frontend < 0) {
+     cString Filename = cString::sprintf("%s/%s%d/%s%d",
+        DEV_DVB_BASE, DEV_DVB_ADAPTER, adapter, DEV_DVB_FRONTEND, frontend);
+     isyslog("dvb tuner: power-up - opening frontend %d/%d", adapter, frontend);
+     fd_frontend = open(Filename, O_RDWR | O_NONBLOCK);
+     if (fd_frontend < 0)
+        esyslog("ERROR: can't open DVB device frontend %d/%d", adapter, frontend);
+     tunerStatus = tsIdle;
+     }
+}
+
 // --- cDvbSourceParam -------------------------------------------------------
 
 class cDvbSourceParam : public cSourceParam {
@@ -1954,6 +1980,19 @@
   needsDetachBondedReceivers = false;
 }
 
+bool cDvbDevice::IsPoweredDown(void)
+{
+  if (dvbTuner)
+     return dvbTuner->IsPoweredDown();
+  return false;
+}
+
+void cDvbDevice::PowerDown(bool On)
+{
+  if (dvbTuner)
+     dvbTuner->PowerDown(On);
+}
+
 // --- cDvbDeviceProbe -------------------------------------------------------
 
 cList<cDvbDeviceProbe> DvbDeviceProbes;
--- vdr-2.3.2/dvbdevice.h.orig	2015-04-18 15:57:27.000000000 +0200
+++ vdr-2.3.2/dvbdevice.h	2017-03-16 19:10:02.850918081 +0100
@@ -292,6 +292,13 @@
   virtual void CloseDvr(void);
   virtual bool GetTSPacket(uchar *&Data);
   virtual void DetachAllReceivers(void);
+
+// Power saving facilities
+
+protected:
+  virtual bool IsPoweredDown(void);
+  virtual void PowerDown(bool On);
+  virtual bool SupportsPowerDown() {return true;}
   };
 
 // A plugin that implements a DVB device derived from cDvbDevice needs to create
--- vdr-2.3.2/eitscan.c.orig	2015-09-10 13:05:03.000000000 +0200
+++ vdr-2.3.2/eitscan.c	2017-03-16 19:10:02.850918081 +0100
@@ -144,7 +144,8 @@
            bool AnyDeviceSwitched = false;
            for (int i = 0; i < cDevice::NumDevices(); i++) {
                cDevice *Device = cDevice::GetDevice(i);
-               if (Device && Device->ProvidesEIT()) {
+               if (Device && Device->ProvidesEIT()
+                     && (!Device->PoweredDown() || lastActivity == 0)) { // powered up or forced scan
                   for (cScanData *ScanData = scanList->First(); ScanData; ScanData = scanList->Next(ScanData)) {
                       const cChannel *Channel = ScanData->GetChannel();
                       if (Channel) {
@@ -165,6 +166,10 @@
                                            }
                                         }
                                      //dsyslog("EIT scan: device %d  source  %-8s tp %5d", Device->DeviceNumber() + 1, *cSource::ToString(Channel->Source()), Channel->Transponder());
+                                     if (lastActivity == 0)
+                                        // forced scan - set idle timer for each channel switch;
+                                        // this prevents powering down while scanning a transponder
+                                        Device->SetIdleTimer(true, ScanTimeout + 5);
                                      Device->SwitchChannel(Channel, false);
                                      scanList->Del(ScanData);
                                      AnyDeviceSwitched = true;
--- vdr-2.3.2/menu.c.orig	2017-03-16 19:07:06.109122696 +0100
+++ vdr-2.3.2/menu.c	2017-03-16 19:10:02.850918081 +0100
@@ -3788,6 +3788,12 @@
      Add(new cMenuEditIntxItem(tr("Setup.LNB$Positioner speed (degrees/s)"), &data.PositionerSpeed, 1, 1800, 10));
      }
 
+  Add(new cMenuEditBoolItem(tr("Setup.LNB$Enable power saving"), &data.PowerdownEnabled));
+  if (data.PowerdownEnabled) {
+     Add(new cMenuEditIntItem(tr("Setup.LNB$Power down an idle device after (min)"), &data.PowerdownTimeoutS));
+     Add(new cMenuEditIntItem(tr("Setup.LNB$Wake up from power-down after (h)"), &data.PowerdownWakeupH));
+     }
+
   SetCurrent(Get(current));
   Display();
 }
@@ -3796,6 +3802,7 @@
 {
   int oldDiSEqC = data.DiSEqC;
   int oldUsePositioner = data.UsePositioner;
+  int oldPowerdownEnabled = data.PowerdownEnabled;
   bool DeviceBondingsChanged = false;
   if (Key == kOk) {
      cString NewDeviceBondings = satCableNumbers.ToString();
@@ -3804,7 +3811,7 @@
      }
   eOSState state = cMenuSetupBase::ProcessKey(Key);
 
-  if (Key != kNone && (data.DiSEqC != oldDiSEqC || data.UsePositioner != oldUsePositioner))
+  if (Key != kNone && (data.DiSEqC != oldDiSEqC || data.UsePositioner != oldUsePositioner || data.PowerdownEnabled != oldPowerdownEnabled))
      Setup();
   else if (DeviceBondingsChanged)
      cDvbDevice::BondDevices(data.DeviceBondings);
--- vdr-2.3.2/vdr.c.orig	2017-03-16 19:07:06.097122845 +0100
+++ vdr-2.3.2/vdr.c	2017-03-16 19:10:02.850918081 +0100
@@ -1555,6 +1555,12 @@
 
         ReportEpgBugFixStats();
 
+        for (int i = 0; i < cDevice::NumDevices(); i++) {
+           cDevice *d = cDevice::GetDevice(i);
+           if (d)
+              d->CheckIdle();
+           }
+
         // Main thread hooks of plugins:
         PluginManager.MainThreadHook();
         }
