diff --git a/drivers/amlogic/amports/Kconfig b/drivers/amlogic/amports/Kconfig
index ab81b0e..9b2cdf0 100644
--- a/drivers/amlogic/amports/Kconfig
+++ b/drivers/amlogic/amports/Kconfig
@@ -79,6 +79,16 @@ config AM_VDEC_MPEG4
 	  need more...
 	  more...
 
+config AM_VDEC_MMPEG4
+	tristate "Amlogic MMPEG4 Video Decoder"
+	default n
+	---help---
+	  Driver for Mmpeg4 video decoder.
+	  need write more details...
+	  write need more.....
+	  need more...
+	  more...
+
 config AM_VDEC_VC1
 	tristate "Amlogic VC1 Video Decoder"
 	default y
@@ -101,6 +111,17 @@ config AM_VDEC_H264
 	  need more...
 	  more...
 
+config AM_VDEC_MH264
+	tristate "Amlogic MH264 Video Decoder"
+	default n
+	select AM_PTSSERVER
+	---help---
+	  Driver for Mh264 video decoder.
+	  need write more details...
+	  write need more.....
+	  need more...
+	  more...
+
 config AM_VDEC_H264MVC
 	tristate "Amlogic H264MVC Video Decoder"
 	default y
diff --git a/drivers/amlogic/amports/Makefile b/drivers/amlogic/amports/Makefile
index 8bc3ea6..da90d25 100644
--- a/drivers/amlogic/amports/Makefile
+++ b/drivers/amlogic/amports/Makefile
@@ -8,7 +8,13 @@
 
 obj-$(CONFIG_AM_STREAMING) += amports.o
 
-AMPORTS_OBJS = amstream.o streambuf.o vdec.o adec.o tsdemux.o psparser.o esparser.o rmparser.o amvdec.o amstream_profile.o tsync_pcr.o amports_gate.o gp_pll.o thread_rw.o
+AMPORTS_OBJS = amstream.o streambuf.o vdec.o adec.o tsdemux.o psparser.o esparser.o amvdec.o amstream_profile.o tsync_pcr.o amports_gate.o gp_pll.o thread_rw.o vdec_input.o
+
+ifeq ($(CONFIG_MULTI_DEC),y)
+AMPORTS_OBJS += vdec_profile.o
+endif
+
+AMPORTS_OBJS += config_parser.o
 
 amports-objs := $(AMPORTS_OBJS)
 amports-y    := $(AMPORTS_OBJS)
@@ -18,10 +24,18 @@ obj-$(CONFIG_AM_VDEC_MPEG12) += amvdec_mpeg12.o
 amvdec_mpeg12-objs := vmpeg12.o
 amvdec_mpeg12-y    := vmpeg12.o
 
+#obj-$(CONFIG_AM_VDEC_MMPEG12) += amvdec_mmpeg12.o
+#amvdec_mmpeg12-objs := vmmpeg12.o
+#amvdec_mmpeg12-y    := vmmpeg12.o
+
 obj-$(CONFIG_AM_VDEC_MPEG4) += amvdec_mpeg4.o
 amvdec_mpeg4-objs := vmpeg4.o
 amvdec_mpeg4-y    := vmpeg4.o
 
+obj-$(CONFIG_AM_VDEC_MMPEG4) += amvdec_mmpeg4.o
+amvdec_mmpeg4-objs := vmmpeg4.o
+amvdec_mmpeg4-y    := vmmpeg4.o
+
 obj-$(CONFIG_AM_VDEC_VC1) += amvdec_vc1.o
 amvdec_vc1-objs := vvc1.o
 amvdec_vc1-y    := vvc1.o
@@ -30,6 +44,10 @@ obj-$(CONFIG_AM_VDEC_H264) += amvdec_h264.o
 amvdec_h264-objs := vh264.o
 amvdec_h264-y    := vh264.o
 
+obj-$(CONFIG_AM_VDEC_MH264) += amvdec_mh264.o
+amvdec_mh264-objs := vmh264.o h264_dpb.o
+amvdec_mh264-y    := vmh264.o h264_dpb.o
+
 obj-$(CONFIG_AM_VDEC_H264MVC) += amvdec_h264mvc.o
 amvdec_h264mvc-objs := vh264mvc.o
 amvdec_h264mvc-y    := vh264mvc.o
@@ -43,16 +61,20 @@ amvdec_h265-objs := vh265.o
 amvdec_h265-y    := vh265.o
 
 obj-$(CONFIG_AM_VDEC_VP9) += amvdec_vp9.o
-amvdec_vp9-objs := vvp9.o vp9_mm.o
-amvdec_vp9-y    := vvp9.o vp9_mm.o
+amvdec_vp9-objs := vvp9.o
+amvdec_vp9-y    := vvp9.o
 
 obj-$(CONFIG_AM_VDEC_MJPEG) += amvdec_mjpeg.o
 amvdec_mjpeg-objs := vmjpeg.o
 amvdec_mjpeg-y    := vmjpeg.o
 
+obj-$(CONFIG_AM_VDEC_MMJPEG) += amvdec_mmjpeg.o
+amvdec_mmjpeg-objs := vmmjpeg.o
+amvdec_mmjpeg-y    := vmmjpeg.o
+
 obj-$(CONFIG_AM_VDEC_REAL) += amvdec_real.o
-amvdec_real-objs := vreal.o
-amvdec_real-y    := vreal.o
+amvdec_real-objs := vreal.o rmparser.o
+amvdec_real-y    := vreal.o rmparser.o
 
 obj-$(CONFIG_AM_VDEC_AVS) += amvdec_avs.o
 amvdec_avs-objs := vavs.o avsp_trans.o
@@ -71,8 +93,8 @@ amvenc_jpeg-y    := jpegenc.o
 obj-$(CONFIG_AM_PIC_DEC) += picdec.o
 obj-$(CONFIG_AM_VIDEO) += amvideo.o
 
-amvideo-objs := video.o vpp.o
-amvideo-y    := video.o vpp.o
+amvideo-objs := video.o vpp.o video_keeper.o
+amvideo-y    := video.o vpp.o video_keeper.o
 
 #amvideo-objs := video_prot.o
 #amvideo-y    := video_prot.o
@@ -100,8 +122,10 @@ obj-$(CONFIG_VSYNC_RDMA) += rdma.o
 
 obj-y += arch/
 obj-y += cnm/
+obj-y += decoder/
 
 ifneq ($(CONFIG_AM_DVB),)
 ##EXTRA_CFLAGS = -DENABLE_DEMUX_DRIVER -DMODIFY_TIMESTAMP_INC_WITH_PLL -DCALC_CACHED_TIME #-DUSE_VMASTER_MODE
 ccflags-y = -DENABLE_DEMUX_DRIVER -DMODIFY_TIMESTAMP_INC_WITH_PLL -DCALC_CACHED_TIME #-DUSE_VMASTER_MODE
 endif
+
diff --git a/drivers/amlogic/amports/amports_priv.h b/drivers/amlogic/amports/amports_priv.h
index 233751c..b8c6a82 100644
--- a/drivers/amlogic/amports/amports_priv.h
+++ b/drivers/amlogic/amports/amports_priv.h
@@ -25,6 +25,11 @@
 #include "arch/log.h"
 
 
+struct port_priv_s {
+	struct vdec_s *vdec;
+	struct stream_port_s *port;
+};
+
 struct stream_buf_s *get_buf_by_type(u32 type);
 
 extern void amvenc_dos_top_reg_fix(void);
diff --git a/drivers/amlogic/amports/amstream.c b/drivers/amlogic/amports/amstream.c
index 985549c..4097c5b 100644
--- a/drivers/amlogic/amports/amstream.c
+++ b/drivers/amlogic/amports/amstream.c
@@ -21,6 +21,7 @@
 #include <linux/fs.h>
 #include <linux/init.h>
 #include <linux/device.h>
+#include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/mm.h>
 #include <linux/amlogic/major.h>
@@ -98,6 +99,26 @@ u32 amstream_buf_num;
 
 
 static int debugflags;
+
+#define DEFAULT_VIDEO_BUFFER_SIZE       (1024 * 1024 * 3)
+#define DEFAULT_VIDEO_BUFFER_SIZE_4K       (1024 * 1024 * 6)
+#define DEFAULT_VIDEO_BUFFER_SIZE_TVP       (1024 * 1024 * 10)
+#define DEFAULT_VIDEO_BUFFER_SIZE_4K_TVP       (1024 * 1024 * 15)
+
+
+#define DEFAULT_AUDIO_BUFFER_SIZE       (1024*768*2)
+#define DEFAULT_SUBTITLE_BUFFER_SIZE     (1024*256)
+
+static int def_4k_vstreambuf_sizeM =
+	(DEFAULT_VIDEO_BUFFER_SIZE_4K >> 20);
+static int def_vstreambuf_sizeM =
+	(DEFAULT_VIDEO_BUFFER_SIZE >> 20);
+static int debugflags;
+static int slow_input;
+
+
+
+
 /* #define DATA_DEBUG */
 static int use_bufferlevelx10000 = 10000;
 static int reset_canuse_buferlevel(int level);
@@ -117,7 +138,8 @@ int amports_get_debug_flags(void)
 
 #ifdef DATA_DEBUG
 #include <linux/fs.h>
-#define DEBUG_FILE_NAME     "/tmp/debug.tmp"
+
+#define DEBUG_FILE_NAME     "/sdcard/debug.tmp"
 static struct file *debug_filp;
 static loff_t debug_file_pos;
 
@@ -140,11 +162,7 @@ void debug_file_write(const char __user *buf, size_t count)
 }
 #endif
 
-#define DEFAULT_VIDEO_BUFFER_SIZE       (1024*1024*15)
-#define DEFAULT_VIDEO_BUFFER_SIZE_4K       (1024*1024*15)
 
-#define DEFAULT_AUDIO_BUFFER_SIZE       (1024*768*2)
-#define DEFAULT_SUBTITLE_BUFFER_SIZE     (1024*256)
 
 static int amstream_open(struct inode *inode, struct file *file);
 static int amstream_release(struct inode *inode, struct file *file);
@@ -155,6 +173,8 @@ static long amstream_compat_ioctl
 #endif
 static ssize_t amstream_vbuf_write
 (struct file *file, const char *buf, size_t count, loff_t *ppos);
+static ssize_t amstream_vframe_write
+(struct file *file, const char *buf, size_t count, loff_t *ppos);
 static ssize_t amstream_abuf_write
 (struct file *file, const char *buf, size_t count, loff_t *ppos);
 static ssize_t amstream_mpts_write
@@ -171,14 +191,12 @@ static unsigned int amstream_userdata_poll
 (struct file *file, poll_table *wait_table);
 static ssize_t amstream_userdata_read
 (struct file *file, char *buf, size_t count, loff_t *ppos);
-static int (*amstream_vdec_status)
-(struct vdec_status *vstatus);
 static int (*amstream_adec_status)
 (struct adec_status *astatus);
-static int (*amstream_vdec_trickmode)
-(unsigned long trickmode);
+#ifdef CONFIG_AM_VDEC_REAL
 static ssize_t amstream_mprm_write
 (struct file *file, const char *buf, size_t count, loff_t *ppos);
+#endif
 
 static const struct file_operations vbuf_fops = {
 	.owner = THIS_MODULE,
@@ -191,6 +209,17 @@ static const struct file_operations vbuf_fops = {
 #endif
 };
 
+static const struct file_operations vframe_fops = {
+	.owner = THIS_MODULE,
+	.open = amstream_open,
+	.release = amstream_release,
+	.write = amstream_vframe_write,
+	.unlocked_ioctl = amstream_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = amstream_compat_ioctl,
+#endif
+};
+
 static const struct file_operations abuf_fops = {
 	.owner = THIS_MODULE,
 	.open = amstream_open,
@@ -228,7 +257,9 @@ static const struct file_operations mprm_fops = {
 	.owner = THIS_MODULE,
 	.open = amstream_open,
 	.release = amstream_release,
+#ifdef CONFIG_AM_VDEC_REAL
 	.write = amstream_mprm_write,
+#endif
 	.unlocked_ioctl = amstream_ioctl,
 #ifdef CONFIG_COMPAT
 	.compat_ioctl = amstream_compat_ioctl,
@@ -282,7 +313,6 @@ static const struct file_operations amstream_fops = {
 
 /**************************************************/
 static struct audio_info audio_dec_info;
-struct dec_sysinfo amstream_dec_info;
 static struct class *amstream_dev_class;
 static DEFINE_MUTEX(amstream_mutex);
 
@@ -299,26 +329,62 @@ static struct userdata_poc_info_t userdata_poc_info[USERDATA_FIFO_NUM];
 static int userdata_poc_ri = 0, userdata_poc_wi;
 
 static struct stream_port_s ports[] = {
+#ifdef CONFIG_MULTI_DEC
+	{
+		.name = "amstream_vbuf",
+		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO,
+		.fops = &vbuf_fops,
+	},
+	{
+		.name = "amstream_vbuf_sched",
+		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO |
+			PORT_TYPE_DECODER_SCHED,
+		.fops = &vbuf_fops,
+	},
+	{
+		.name = "amstream_vframe",
+		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO |
+			PORT_TYPE_FRAME | PORT_TYPE_DECODER_SCHED,
+		.fops = &vframe_fops,
+	},
+#else
 	{
 		.name = "amstream_vbuf",
 		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO,
 		.fops = &vbuf_fops,
 	},
+#endif
 	{
 		.name = "amstream_abuf",
 		.type = PORT_TYPE_ES | PORT_TYPE_AUDIO,
 		.fops = &abuf_fops,
 	},
+#ifdef CONFIG_MULTI_DEC
 	{
 		.name = "amstream_mpts",
-		.type = PORT_TYPE_MPTS |
-		PORT_TYPE_VIDEO | PORT_TYPE_AUDIO | PORT_TYPE_SUB,
+		.type = PORT_TYPE_MPTS | PORT_TYPE_VIDEO |
+			PORT_TYPE_AUDIO | PORT_TYPE_SUB,
 		.fops = &mpts_fops,
 	},
 	{
+		.name = "amstream_mpts_sched",
+		.type = PORT_TYPE_MPTS | PORT_TYPE_VIDEO |
+			PORT_TYPE_AUDIO | PORT_TYPE_SUB |
+			PORT_TYPE_DECODER_SCHED,
+		.fops = &mpts_fops,
+	},
+#else
+	{
+		.name = "amstream_mpts",
+		.type = PORT_TYPE_MPTS | PORT_TYPE_VIDEO |
+			PORT_TYPE_AUDIO | PORT_TYPE_SUB,
+		.fops = &mpts_fops,
+	},
+#endif
+	{
 		.name = "amstream_mpps",
-		.type = PORT_TYPE_MPPS |
-		PORT_TYPE_VIDEO | PORT_TYPE_AUDIO | PORT_TYPE_SUB,
+		.type = PORT_TYPE_MPPS | PORT_TYPE_VIDEO |
+			PORT_TYPE_AUDIO | PORT_TYPE_SUB,
 		.fops = &mpps_fops,
 	},
 	{
@@ -341,12 +407,59 @@ static struct stream_port_s ports[] = {
 		.type = PORT_TYPE_USERDATA,
 		.fops = &userdata_fops,
 	},
+#ifdef CONFIG_MULTI_DEC
 	{
 		.name = "amstream_hevc",
+#ifdef CONFIG_AM_VDEC_DV
+/*test dobly vision, remove later*/
+		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO | PORT_TYPE_HEVC |
+			PORT_TYPE_DECODER_SCHED | PORT_TYPE_DUALDEC,
+		.fops = &vbuf_fops,
+		.vformat = VFORMAT_HEVC,
+#else
 		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO | PORT_TYPE_HEVC,
 		.fops = &vbuf_fops,
 		.vformat = VFORMAT_HEVC,
+#endif
+	},
+	{
+		.name = "amstream_hevc_frame",
+		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO | PORT_TYPE_HEVC |
+			PORT_TYPE_FRAME | PORT_TYPE_DECODER_SCHED,
+		.fops = &vframe_fops,
+		.vformat = VFORMAT_HEVC,
+	},
+	{
+		.name = "amstream_hevc_sched",
+		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO | PORT_TYPE_HEVC |
+			PORT_TYPE_DECODER_SCHED,
+		.fops = &vbuf_fops,
+		.vformat = VFORMAT_HEVC,
+	}
+#ifdef CONFIG_AM_VDEC_DV
+	,
+	{
+		.name = "amstream_dves_avc",
+		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO |
+			PORT_TYPE_DECODER_SCHED | PORT_TYPE_DUALDEC,
+		.fops = &vbuf_fops,
 	},
+	{
+		.name = "amstream_dves_hevc",
+		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO | PORT_TYPE_HEVC |
+			PORT_TYPE_DECODER_SCHED | PORT_TYPE_DUALDEC,
+		.fops = &vbuf_fops,
+		.vformat = VFORMAT_HEVC,
+	}
+#endif
+#else
+	{
+		.name = "amstream_hevc",
+		.type = PORT_TYPE_ES | PORT_TYPE_VIDEO | PORT_TYPE_HEVC,
+		.fops = &vbuf_fops,
+		.vformat = VFORMAT_HEVC,
+	}
+#endif
 };
 
 static struct stream_buf_s bufs[BUF_MAX_NUM] = {
@@ -422,47 +535,82 @@ struct audio_info *get_audio_info(void)
 }
 EXPORT_SYMBOL(get_audio_info);
 
-static void amstream_change_vbufsize(struct stream_port_s *port,
+static void amstream_change_vbufsize(struct port_priv_s *priv,
 	struct stream_buf_s *pvbuf)
 {
-
 	if (pvbuf->buf_start != 0) {
 		pr_info("streambuf is alloced before\n");
 		return;
 	}
 	if (pvbuf->for_4k) {
-		pvbuf->buf_size = DEFAULT_VIDEO_BUFFER_SIZE_4K;
+		pvbuf->buf_size = def_4k_vstreambuf_sizeM * SZ_1M;
+		if (codec_mm_video_tvp_enabled())
+			pvbuf->buf_size = DEFAULT_VIDEO_BUFFER_SIZE_4K_TVP;
 		if ((pvbuf->buf_size > 30 * SZ_1M) &&
 		(codec_mm_get_total_size() < 220 * SZ_1M)) {
 			/*if less than 250M, used 20M for 4K & 265*/
 			pvbuf->buf_size = pvbuf->buf_size >> 1;
 		}
-	} else if (pvbuf->buf_size > DEFAULT_VIDEO_BUFFER_SIZE) {
-		pvbuf->buf_size = DEFAULT_VIDEO_BUFFER_SIZE;
+	} else if (pvbuf->buf_size > def_vstreambuf_sizeM * SZ_1M) {
+		if (codec_mm_video_tvp_enabled())
+			pvbuf->buf_size = DEFAULT_VIDEO_BUFFER_SIZE_TVP;
 	} else {
-		pvbuf->buf_size = DEFAULT_VIDEO_BUFFER_SIZE;
+		pvbuf->buf_size = def_vstreambuf_sizeM * SZ_1M;
+		if (codec_mm_video_tvp_enabled())
+			pvbuf->buf_size = DEFAULT_VIDEO_BUFFER_SIZE_TVP;
 	}
 	reset_canuse_buferlevel(10000);
 
 	return;
 }
 
-static void video_port_release(struct stream_port_s *port,
+static bool port_get_inited(struct port_priv_s *priv)
+{
+	struct stream_port_s *port = priv->port;
+
+	if (port->type & PORT_TYPE_VIDEO) {
+		struct vdec_s *vdec = priv->vdec;
+		return vdec->port_flag & PORT_FLAG_INITED;
+	}
+
+	return port->flag & PORT_FLAG_INITED;
+}
+
+static void port_set_inited(struct port_priv_s *priv)
+{
+	struct stream_port_s *port = priv->port;
+
+	if (port->type & PORT_TYPE_VIDEO) {
+		struct vdec_s *vdec = priv->vdec;
+		vdec->port_flag |= PORT_FLAG_INITED;
+	} else
+		port->flag |= PORT_FLAG_INITED;
+}
+
+static void video_port_release(struct port_priv_s *priv,
 	  struct stream_buf_s *pbuf, int release_num)
 {
+	struct stream_port_s *port = priv->port;
+	struct vdec_s *vdec = priv->vdec;
+
 	switch (release_num) {
 	default:
 	/*fallthrough*/
 	case 0:		/*release all */
 	/*fallthrough*/
 	case 4:
-		esparser_release(pbuf);
+		if ((port->type & PORT_TYPE_FRAME) == 0)
+			esparser_release(pbuf);
 	/*fallthrough*/
 	case 3:
-		vdec_release(port->vformat);
+		if (vdec->slave)
+			vdec_release(vdec->slave);
+		vdec_release(vdec);
+		priv->vdec = NULL;
 	/*fallthrough*/
 	case 2:
-		stbuf_release(pbuf);
+		if ((port->type & PORT_TYPE_FRAME) == 0)
+			stbuf_release(pbuf);
 	/*fallthrough*/
 	case 1:
 		;
@@ -470,23 +618,41 @@ static void video_port_release(struct stream_port_s *port,
 	return;
 }
 
-static int video_port_init(struct stream_port_s *port,
+static int video_port_init(struct port_priv_s *priv,
 			  struct stream_buf_s *pbuf)
 {
 	int r;
+	struct stream_port_s *port = priv->port;
+	struct vdec_s *vdec = priv->vdec;
+
 	if ((port->flag & PORT_FLAG_VFORMAT) == 0) {
 		pr_err("vformat not set\n");
 		return -EPERM;
 	}
 
 	if (port->vformat == VFORMAT_H264_4K2K ||
-		(amstream_dec_info.height *
-			amstream_dec_info.width) > 1920*1088) {
+		(priv->vdec->sys_info->height *
+			priv->vdec->sys_info->width) > 1920*1088) {
 		pbuf->for_4k = 1;
+	} else {
+		pbuf->for_4k = 0;
 	}
 
+	if (port->type & PORT_TYPE_FRAME) {
+		r = vdec_init(vdec,
+			(priv->vdec->sys_info->height *
+			priv->vdec->sys_info->width) > 1920*1088);
+		if (r < 0) {
+			pr_err("video_port_init %d, vdec_init failed\n",
+				__LINE__);
+			video_port_release(priv, pbuf, 2);
+			return r;
+		}
+
+		return 0;
+	}
 
-	amstream_change_vbufsize(port, pbuf);
+	amstream_change_vbufsize(priv, pbuf);
 
 	if (has_hevc_vdec()) {
 		if (port->type & PORT_TYPE_MPTS) {
@@ -496,26 +662,40 @@ static int video_port_init(struct stream_port_s *port,
 				vdec_poweroff(VDEC_HEVC);
 		}
 	}
-	r = stbuf_init(pbuf);
+
+	r = stbuf_init(pbuf, vdec);
 	if (r < 0) {
 		pr_err("video_port_init %d, stbuf_init failed\n", __LINE__);
 		return r;
 	}
 
-	r = vdec_init(port->vformat,
-		(amstream_dec_info.height *
-		 amstream_dec_info.width) > 1920*1088);
+	/* todo: set path based on port flag */
+	r = vdec_init(vdec,
+		(priv->vdec->sys_info->height *
+		 priv->vdec->sys_info->width) > 1920*1088);
 
 	if (r < 0) {
 		pr_err("video_port_init %d, vdec_init failed\n", __LINE__);
-		video_port_release(port, pbuf, 2);
+		video_port_release(priv, pbuf, 2);
 		return r;
 	}
 
+	if (vdec_dual(vdec)) {
+		r = vdec_init(vdec->slave,
+			(priv->vdec->sys_info->height *
+			priv->vdec->sys_info->width) > 1920*1088);
+		if (r < 0) {
+			pr_err("video_port_init %d, vdec_init failed\n",
+				__LINE__);
+			video_port_release(priv, pbuf, 2);
+			return r;
+		}
+	}
+
 	if (port->type & PORT_TYPE_ES) {
-		r = esparser_init(pbuf);
+		r = esparser_init(pbuf, vdec);
 		if (r < 0) {
-			video_port_release(port, pbuf, 3);
+			video_port_release(priv, pbuf, 3);
 			pr_err("esparser_init() failed\n");
 			return r;
 		}
@@ -523,6 +703,8 @@ static int video_port_init(struct stream_port_s *port,
 
 	pbuf->flag |= BUF_FLAG_IN_USE;
 
+	vdec_connect(priv->vdec);
+
 	return 0;
 }
 
@@ -563,7 +745,7 @@ static int audio_port_reset(struct stream_port_s *port,
 
 	stbuf_release(pbuf);
 
-	r = stbuf_init(pbuf);
+	r = stbuf_init(pbuf, NULL);
 	if (r < 0)
 		return r;
 
@@ -582,8 +764,10 @@ static int audio_port_reset(struct stream_port_s *port,
 	if (port->type & PORT_TYPE_MPPS)
 		psparser_audio_reset();
 
+#ifdef CONFIG_AM_VDEC_REAL
 	if (port->type & PORT_TYPE_RM)
 		rm_audio_reset();
+#endif
 
 	pbuf->flag |= BUF_FLAG_IN_USE;
 
@@ -601,7 +785,7 @@ static int sub_port_reset(struct stream_port_s *port,
 
 	stbuf_release(pbuf);
 
-	r = stbuf_init(pbuf);
+	r = stbuf_init(pbuf, NULL);
 	if (r < 0)
 		return r;
 
@@ -633,7 +817,7 @@ static int audio_port_init(struct stream_port_s *port,
 		return 0;
 	}
 
-	r = stbuf_init(pbuf);
+	r = stbuf_init(pbuf, NULL);
 	if (r < 0)
 		return r;
 	r = adec_init(port);
@@ -642,7 +826,7 @@ static int audio_port_init(struct stream_port_s *port,
 		return r;
 	}
 	if (port->type & PORT_TYPE_ES) {
-		r = esparser_init(pbuf);
+		r = esparser_init(pbuf, NULL);
 		if (r < 0) {
 			audio_port_release(port, pbuf, 3);
 			return r;
@@ -673,14 +857,14 @@ static int sub_port_init(struct stream_port_s *port, struct stream_buf_s *pbuf)
 		return 0;
 	}
 
-	r = stbuf_init(pbuf);
+	r = stbuf_init(pbuf, NULL);
 	if (r < 0)
 		return r;
 
 	if ((port->sid == 0xffff) &&
 		((port->type & (PORT_TYPE_MPPS | PORT_TYPE_MPTS)) == 0)) {
 		/* es sub */
-		r = esparser_init(pbuf);
+		r = esparser_init(pbuf, NULL);
 		if (r < 0) {
 			sub_port_release(port, pbuf);
 			return r;
@@ -691,19 +875,25 @@ static int sub_port_init(struct stream_port_s *port, struct stream_buf_s *pbuf)
 	return 0;
 }
 
-static int amstream_port_init(struct stream_port_s *port)
+static int amstream_port_init(struct port_priv_s *priv)
 {
 	int r;
 	struct stream_buf_s *pvbuf = &bufs[BUF_TYPE_VIDEO];
 	struct stream_buf_s *pabuf = &bufs[BUF_TYPE_AUDIO];
 	struct stream_buf_s *psbuf = &bufs[BUF_TYPE_SUBTITLE];
 	struct stream_buf_s *pubuf = &bufs[BUF_TYPE_USERDATA];
+	struct stream_port_s *port = priv->port;
+	struct vdec_s *vdec = priv->vdec;
+
 	mutex_lock(&amstream_mutex);
+
 	stbuf_fetch_init();
-	if (port->flag & PORT_FLAG_INITED) {
+
+	if (port_get_inited(priv)) {
 		mutex_unlock(&amstream_mutex);
 		return 0;
 	}
+
 	if ((port->type & PORT_TYPE_AUDIO) &&
 		(port->flag & PORT_FLAG_AFORMAT)) {
 		r = audio_port_init(port, pabuf);
@@ -719,13 +909,13 @@ static int amstream_port_init(struct stream_port_s *port)
 		pubuf->buf_start = 0;
 		pubuf->buf_wp = 0;
 		pubuf->buf_rp = 0;
-		pubuf->for_4k = 0;
+		pvbuf->for_4k = 0;
 		if (has_hevc_vdec()) {
 			if (port->vformat == VFORMAT_HEVC ||
 				port->vformat == VFORMAT_VP9)
 				pvbuf = &bufs[BUF_TYPE_HEVC];
 		}
-		r = video_port_init(port, pvbuf);
+		r = video_port_init(priv, pvbuf);
 		if (r < 0) {
 			pr_err("video_port_init  failed\n");
 			goto error2;
@@ -748,13 +938,16 @@ static int amstream_port_init(struct stream_port_s *port)
 			(port->flag & PORT_FLAG_SID) ? port->sid : 0xffff,
 			(port->pcr_inited == 1) ? port->pcrid : 0xffff,
 			(port->vformat == VFORMAT_HEVC) ||
-			(port->vformat == VFORMAT_VP9));
+			(port->vformat == VFORMAT_VP9),
+			vdec);
 		} else {
 			r = tsdemux_init(
 			(port->flag & PORT_FLAG_VID) ? port->vid : 0xffff,
 			(port->flag & PORT_FLAG_AID) ? port->aid : 0xffff,
 			(port->flag & PORT_FLAG_SID) ? port->sid : 0xffff,
-			(port->pcr_inited == 1) ? port->pcrid : 0xffff, 0);
+			(port->pcr_inited == 1) ? port->pcrid : 0xffff,
+			0,
+			vdec);
 		}
 
 		if (r < 0) {
@@ -767,17 +960,20 @@ static int amstream_port_init(struct stream_port_s *port)
 		r = psparser_init(
 			(port->flag & PORT_FLAG_VID) ? port->vid : 0xffff,
 			(port->flag & PORT_FLAG_AID) ? port->aid : 0xffff,
-			(port->flag & PORT_FLAG_SID) ? port->sid : 0xffff);
+			(port->flag & PORT_FLAG_SID) ? port->sid : 0xffff,
+			priv->vdec);
 		if (r < 0) {
 			pr_err("psparser_init  failed\n");
 			goto error5;
 		}
 	}
+#ifdef CONFIG_AM_VDEC_REAL
 	if (port->type & PORT_TYPE_RM) {
 		rm_set_vasid(
 			(port->flag & PORT_FLAG_VID) ? port->vid : 0xffff,
 			(port->flag & PORT_FLAG_AID) ? port->aid : 0xffff);
 	}
+#endif
 #if 1	/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TVD */
 	if (!NO_VDEC2_INIT) {
 		if ((port->type & PORT_TYPE_VIDEO)
@@ -786,10 +982,16 @@ static int amstream_port_init(struct stream_port_s *port)
 	}
 #endif
 
+	if ((port->type & PORT_TYPE_VIDEO) &&
+		(port->flag & PORT_FLAG_VFORMAT))
+		/* connect vdec at the end after all HW initialization */
+		vdec_connect(vdec);
+
 	tsync_audio_break(0);	/* clear audio break */
 	set_vsync_pts_inc_mode(0);	/* clear video inc */
 
-	port->flag |= PORT_FLAG_INITED;
+	port_set_inited(priv);
+
 	mutex_unlock(&amstream_mutex);
 	return 0;
 	/*errors follow here */
@@ -798,7 +1000,7 @@ static int amstream_port_init(struct stream_port_s *port)
 error4:
 	sub_port_release(port, psbuf);
 error3:
-	video_port_release(port, pvbuf, 0);
+	video_port_release(priv, pvbuf, 0);
 error2:
 	audio_port_release(port, pabuf, 0);
 error1:
@@ -806,8 +1008,9 @@ static int amstream_port_init(struct stream_port_s *port)
 	return r;
 }
 
-static int amstream_port_release(struct stream_port_s *port)
+static int amstream_port_release(struct port_priv_s *priv)
 {
+	struct stream_port_s *port = priv->port;
 	struct stream_buf_s *pvbuf = &bufs[BUF_TYPE_VIDEO];
 	struct stream_buf_s *pabuf = &bufs[BUF_TYPE_AUDIO];
 	struct stream_buf_s *psbuf = &bufs[BUF_TYPE_SUBTITLE];
@@ -827,7 +1030,7 @@ static int amstream_port_release(struct stream_port_s *port)
 		psparser_release();
 
 	if (port->type & PORT_TYPE_VIDEO)
-		video_port_release(port, pvbuf, 0);
+		video_port_release(priv, pvbuf, 0);
 
 	if (port->type & PORT_TYPE_AUDIO)
 		audio_port_release(port, pabuf, 0);
@@ -854,12 +1057,13 @@ static void amstream_change_avid(struct stream_port_s *port)
 		(port->flag & PORT_FLAG_AID) ? port->aid : 0xffff);
 	}
 
+#ifdef CONFIG_AM_VDEC_REAL
 	if (port->type & PORT_TYPE_RM) {
 		rm_set_vasid(
 		(port->flag & PORT_FLAG_VID) ? port->vid : 0xffff,
 		(port->flag & PORT_FLAG_AID) ? port->aid : 0xffff);
 	}
-
+#endif
 	return;
 }
 
@@ -882,19 +1086,19 @@ static void amstream_change_sid(struct stream_port_s *port)
 static ssize_t amstream_vbuf_write(struct file *file, const char *buf,
 					size_t count, loff_t *ppos)
 {
-	struct stream_port_s *port = (struct stream_port_s *)file->private_data;
+	struct port_priv_s *priv = (struct port_priv_s *)file->private_data;
+	struct stream_port_s *port = priv->port;
 	struct stream_buf_s *pbuf = NULL;
 	int r;
 
-
 	if (has_hevc_vdec()) {
 		pbuf = (port->type & PORT_TYPE_HEVC) ? &bufs[BUF_TYPE_HEVC] :
 			&bufs[BUF_TYPE_VIDEO];
 	} else
 		pbuf = &bufs[BUF_TYPE_VIDEO];
 
-	if (!(port->flag & PORT_FLAG_INITED)) {
-		r = amstream_port_init(port);
+	if (!(port_get_inited(priv))) {
+		r = amstream_port_init(priv);
 		if (r < 0)
 			return r;
 	}
@@ -903,6 +1107,10 @@ static ssize_t amstream_vbuf_write(struct file *file, const char *buf,
 		r = drm_write(file, pbuf, buf, count);
 	else
 		r = esparser_write(file, pbuf, buf, count);
+	if (slow_input) {
+		pr_info("slow_input: es codec write size %x\n", r);
+		msleep(3000);
+	}
 #ifdef DATA_DEBUG
 	debug_file_write(buf, r);
 #endif
@@ -910,15 +1118,26 @@ static ssize_t amstream_vbuf_write(struct file *file, const char *buf,
 	return r;
 }
 
+static ssize_t amstream_vframe_write(struct file *file, const char *buf,
+					   size_t count, loff_t *ppos)
+{
+	struct port_priv_s *priv = (struct port_priv_s *)file->private_data;
+#ifdef DATA_DEBUG
+	debug_file_write(buf, count);
+#endif
+	return vdec_write_vframe(priv->vdec, buf, count);
+}
+
 static ssize_t amstream_abuf_write(struct file *file, const char *buf,
 					size_t count, loff_t *ppos)
 {
-	struct stream_port_s *port = (struct stream_port_s *)file->private_data;
+	struct port_priv_s *priv = (struct port_priv_s *)file->private_data;
+	struct stream_port_s *port = priv->port;
 	struct stream_buf_s *pbuf = &bufs[BUF_TYPE_AUDIO];
 	int r;
 
-	if (!(port->flag & PORT_FLAG_INITED)) {
-		r = amstream_port_init(port);
+	if (!(port_get_inited(priv))) {
+		r = amstream_port_init(priv);
 		if (r < 0)
 			return r;
 	}
@@ -934,7 +1153,8 @@ static ssize_t amstream_abuf_write(struct file *file, const char *buf,
 static ssize_t amstream_mpts_write(struct file *file, const char *buf,
 		size_t count, loff_t *ppos)
 {
-	struct stream_port_s *port = (struct stream_port_s *)file->private_data;
+	struct port_priv_s *priv = (struct port_priv_s *)file->private_data;
+	struct stream_port_s *port = priv->port;
 	struct stream_buf_s *pabuf = &bufs[BUF_TYPE_AUDIO];
 	struct stream_buf_s *pvbuf = NULL;
 	int r = 0;
@@ -946,8 +1166,8 @@ static ssize_t amstream_mpts_write(struct file *file, const char *buf,
 	} else
 		pvbuf = &bufs[BUF_TYPE_VIDEO];
 
-	if (!(port->flag & PORT_FLAG_INITED)) {
-		r = amstream_port_init(port);
+	if (!(port_get_inited(priv))) {
+		r = amstream_port_init(priv);
 		if (r < 0)
 			return r;
 	}
@@ -958,40 +1178,46 @@ static ssize_t amstream_mpts_write(struct file *file, const char *buf,
 		r = drm_tswrite(file, pvbuf, pabuf, buf, count);
 	else
 		r = tsdemux_write(file, pvbuf, pabuf, buf, count);
+	if (slow_input) {
+		pr_info("slow_input: ts codec write size %x\n", r);
+		msleep(3000);
+	}
 	return r;
 }
 
 static ssize_t amstream_mpps_write(struct file *file, const char *buf,
 					size_t count, loff_t *ppos)
 {
-	struct stream_port_s *port = (struct stream_port_s *)file->private_data;
+	struct port_priv_s *priv = (struct port_priv_s *)file->private_data;
 	struct stream_buf_s *pvbuf = &bufs[BUF_TYPE_VIDEO];
 	struct stream_buf_s *pabuf = &bufs[BUF_TYPE_AUDIO];
 	int r;
 
-	if (!(port->flag & PORT_FLAG_INITED)) {
-		r = amstream_port_init(port);
+	if (!(port_get_inited(priv))) {
+		r = amstream_port_init(priv);
 		if (r < 0)
 			return r;
 	}
 	return psparser_write(file, pvbuf, pabuf, buf, count);
 }
 
+#ifdef CONFIG_AM_VDEC_REAL
 static ssize_t amstream_mprm_write(struct file *file, const char *buf,
 					size_t count, loff_t *ppos)
 {
-	struct stream_port_s *port = (struct stream_port_s *)file->private_data;
+	struct port_priv_s *priv = (struct port_priv_s *)file->private_data;
 	struct stream_buf_s *pvbuf = &bufs[BUF_TYPE_VIDEO];
 	struct stream_buf_s *pabuf = &bufs[BUF_TYPE_AUDIO];
 	int r;
 
-	if (!(port->flag & PORT_FLAG_INITED)) {
-		r = amstream_port_init(port);
+	if (!(port_get_inited(priv))) {
+		r = amstream_port_init(priv);
 		if (r < 0)
 			return r;
 	}
 	return rmparser_write(file, pvbuf, pabuf, buf, count);
 }
+#endif
 
 static ssize_t amstream_sub_read(struct file *file, char __user *buf,
 					size_t count, loff_t *ppos)
@@ -1068,13 +1294,12 @@ static ssize_t amstream_sub_read(struct file *file, char __user *buf,
 static ssize_t amstream_sub_write(struct file *file, const char *buf,
 			size_t count, loff_t *ppos)
 {
-	struct stream_port_s *port =
-			(struct stream_port_s *)file->private_data;
+	struct port_priv_s *priv = (struct port_priv_s *)file->private_data;
 	struct stream_buf_s *pbuf = &bufs[BUF_TYPE_SUBTITLE];
 	int r;
 
-	if (!(port->flag & PORT_FLAG_INITED)) {
-		r = amstream_port_init(port);
+	if (!(port_get_inited(priv))) {
+		r = amstream_port_init(priv);
 		if (r < 0)
 			return r;
 	}
@@ -1195,30 +1420,50 @@ static ssize_t amstream_userdata_read(struct file *file, char __user *buf,
 	return retVal;
 }
 
-
 static int amstream_open(struct inode *inode, struct file *file)
 {
 	s32 i;
 	struct stream_port_s *s;
-	struct stream_port_s *this = &ports[iminor(inode)];
+	struct stream_port_s *port = &ports[iminor(inode)];
+	struct port_priv_s *priv;
+
 	if (iminor(inode) >= amstream_port_num)
 		return -ENODEV;
+
 	mutex_lock(&amstream_mutex);
-	if (this->flag & PORT_FLAG_IN_USE) {
+
+	if (port->type & PORT_TYPE_VIDEO) {
+		for (s = &ports[0], i = 0; i < amstream_port_num; i++, s++) {
+			if (((s->type & PORT_TYPE_DECODER_SCHED) == 0) &&
+				(s->type & PORT_TYPE_VIDEO) &&
+				(s->flag & PORT_FLAG_IN_USE)) {
+				mutex_unlock(&amstream_mutex);
+				return -EBUSY;
+			}
+		}
+	}
+
+	if ((port->flag & PORT_FLAG_IN_USE) &&
+		((port->type & PORT_TYPE_FRAME) == 0)) {
 		mutex_unlock(&amstream_mutex);
 		return -EBUSY;
 	}
 
-	/* check other ports conflict */
+	/* check other ports conflicts for audio */
 	for (s = &ports[0], i = 0; i < amstream_port_num; i++, s++) {
 		if ((s->flag & PORT_FLAG_IN_USE) &&
-			((this->type) & (s->type) &
-				(PORT_TYPE_VIDEO | PORT_TYPE_AUDIO))) {
+			((port->type) & (s->type) & PORT_TYPE_AUDIO)) {
 			mutex_unlock(&amstream_mutex);
 			return -EBUSY;
 		}
 	}
 
+	priv = kzalloc(sizeof(struct port_priv_s), GFP_KERNEL);
+	if (priv == NULL)
+		return -ENOMEM;
+
+	priv->port = port;
+
 	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M6) {
 		/* TODO: mod gate */
 		/* switch_mod_gate_by_name("demux", 1); */
@@ -1236,42 +1481,38 @@ static int amstream_open(struct inode *inode, struct file *file)
 			amports_switch_gate("vpu_intr", 1);
 		}
 
-		if (this->type & PORT_TYPE_VIDEO) {
+		if (port->type & PORT_TYPE_VIDEO) {
 			/* TODO: mod gate */
 			/* switch_mod_gate_by_name("vdec", 1); */
 			amports_switch_gate("vdec", 1);
 			if (has_hevc_vdec()) {
-				if (this->type &
+				if (port->type &
 					(PORT_TYPE_MPTS | PORT_TYPE_HEVC))
 					vdec_poweron(VDEC_HEVC);
 
-				if ((this->type & PORT_TYPE_HEVC) == 0)
+				if ((port->type & PORT_TYPE_HEVC) == 0)
 					vdec_poweron(VDEC_1);
 			} else {
 				if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8)
 					vdec_poweron(VDEC_1);
 			}
-
-			memset(&amstream_dec_info, 0,
-				   sizeof(amstream_dec_info));
 		}
 
-		if (this->type & PORT_TYPE_AUDIO) {
+		if (port->type & PORT_TYPE_AUDIO) {
 			/* TODO: mod gate */
 			/* switch_mod_gate_by_name("audio", 1); */
 			amports_switch_gate("audio", 1);
 		}
 	}
 
-	this->vid = 0;
-	this->aid = 0;
-	this->sid = 0;
-	this->pcrid = 0xffff;
-	file->f_op = this->fops;
-	file->private_data = this;
-
-	this->flag = PORT_FLAG_IN_USE;
-	this->pcr_inited = 0;
+	port->vid = 0;
+	port->aid = 0;
+	port->sid = 0;
+	port->pcrid = 0xffff;
+	file->f_op = port->fops;
+	file->private_data = priv;
+	port->flag = PORT_FLAG_IN_USE;
+	port->pcr_inited = 0;
 #ifdef DATA_DEBUG
 	debug_filp = filp_open(DEBUG_FILE_NAME, O_WRONLY, 0);
 	if (IS_ERR(debug_filp)) {
@@ -1280,18 +1521,55 @@ static int amstream_open(struct inode *inode, struct file *file)
 	}
 #endif
 	mutex_unlock(&amstream_mutex);
+
+	if (port->type & PORT_TYPE_VIDEO) {
+		priv->vdec = vdec_create(port, NULL);
+
+		if (priv->vdec == NULL) {
+			port->flag = 0;
+			kfree(priv);
+			pr_err("amstream: vdec creation failed\n");
+			return -ENOMEM;
+		}
+
+		if (port->type & PORT_TYPE_DUALDEC) {
+			priv->vdec->slave = vdec_create(port, priv->vdec);
+
+			if (priv->vdec->slave == NULL) {
+				vdec_release(priv->vdec);
+				port->flag = 0;
+				kfree(priv);
+				pr_err("amstream: sub vdec creation failed\n");
+				return -ENOMEM;
+			}
+		}
+	}
 	return 0;
 }
 
 static int amstream_release(struct inode *inode, struct file *file)
 {
-	struct stream_port_s *this = &ports[iminor(inode)];
+	struct port_priv_s *priv = file->private_data;
+	struct stream_port_s *port = priv->port;
+
 	if (iminor(inode) >= amstream_port_num)
 		return -ENODEV;
+
 	mutex_lock(&amstream_mutex);
-	if (this->flag & PORT_FLAG_INITED)
-		amstream_port_release(this);
-	if ((this->type & (PORT_TYPE_AUDIO | PORT_TYPE_VIDEO)) ==
+
+	if (port_get_inited(priv))
+		amstream_port_release(priv);
+
+	if (priv->vdec) {
+		if (priv->vdec->slave)
+			vdec_release(priv->vdec->slave);
+
+		vdec_release(priv->vdec);
+
+		priv->vdec = NULL;
+	}
+
+	if ((port->type & (PORT_TYPE_AUDIO | PORT_TYPE_VIDEO)) ==
 		PORT_TYPE_AUDIO) {
 		s32 i;
 		struct stream_port_s *s;
@@ -1303,7 +1581,7 @@ static int amstream_release(struct inode *inode, struct file *file)
 		if (i == amstream_port_num)
 			timestamp_firstvpts_set(0);
 	}
-	this->flag = 0;
+	port->flag = 0;
 
 	/* /timestamp_pcrscr_set(0); */
 
@@ -1314,25 +1592,34 @@ static int amstream_release(struct inode *inode, struct file *file)
 		debug_file_pos = 0;
 	}
 #endif
-	if (this->type & PORT_TYPE_VIDEO) {
-		amstream_vdec_status = NULL;
-		amstream_vdec_trickmode = NULL;
-	}
 
 	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M6) {
-		if (this->type & PORT_TYPE_VIDEO) {
+		if (port->type & PORT_TYPE_VIDEO) {
 			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8) {
+#ifndef CONFIG_MULTI_DEC
 				if (has_hevc_vdec())
 					vdec_poweroff(VDEC_HEVC);
 
 				vdec_poweroff(VDEC_1);
+#else
+				if ((port->type & PORT_TYPE_MPTS) &&
+				((port->flag & PORT_FLAG_VFORMAT) == 0)) {
+					vdec_poweroff(VDEC_1);
+					vdec_poweroff(VDEC_HEVC);
+				} else if ((port->vformat == VFORMAT_HEVC
+					|| port->vformat == VFORMAT_VP9)) {
+					vdec_poweroff(VDEC_HEVC);
+				} else {
+					vdec_poweroff(VDEC_1);
+				}
+#endif
 			}
 			/* TODO: mod gate */
 			/* switch_mod_gate_by_name("vdec", 0); */
 			amports_switch_gate("vdec", 0);
 		}
 
-		if (this->type & PORT_TYPE_AUDIO) {
+		if (port->type & PORT_TYPE_AUDIO) {
 			/* TODO: mod gate */
 			/* switch_mod_gate_by_name("audio", 0); */
 			/* amports_switch_gate("audio", 0); */
@@ -1354,11 +1641,14 @@ static int amstream_release(struct inode *inode, struct file *file)
 		/* switch_mod_gate_by_name("demux", 0); */
 		amports_switch_gate("demux", 0);
 	}
+
+	kfree(priv);
+
 	mutex_unlock(&amstream_mutex);
 	return 0;
 }
 
-static long amstream_ioctl_get_version(struct stream_port_s *this,
+static long amstream_ioctl_get_version(struct port_priv_s *priv,
 	ulong arg)
 {
 	int version = (AMSTREAM_IOC_VERSION_FIRST & 0xffff) << 16
@@ -1367,8 +1657,9 @@ static long amstream_ioctl_get_version(struct stream_port_s *this,
 
 	return 0;
 }
-static long amstream_ioctl_get(struct stream_port_s *this, ulong arg)
+static long amstream_ioctl_get(struct port_priv_s *priv, ulong arg)
 {
+	struct stream_port_s *this = priv->port;
 	long r = 0;
 
 	struct am_ioctl_parm parm;
@@ -1492,6 +1783,9 @@ static long amstream_ioctl_get(struct stream_port_s *this, ulong arg)
 				parm.data_32 = 0;
 		}
 		break;
+	case AMSTREAM_GET_ION_ID:
+		parm.data_32 = priv->vdec->vf_receiver_inst;
+		break;
 	default:
 		r = -ENOIOCTLCMD;
 		break;
@@ -1505,8 +1799,9 @@ static long amstream_ioctl_get(struct stream_port_s *this, ulong arg)
 	return r;
 
 }
-static long amstream_ioctl_set(struct stream_port_s *this, ulong arg)
+static long amstream_ioctl_set(struct port_priv_s *priv, ulong arg)
 {
+	struct  stream_port_s *this = priv->port;
 	struct am_ioctl_parm parm;
 	long r = 0;
 
@@ -1539,6 +1834,9 @@ static long amstream_ioctl_set(struct stream_port_s *this, ulong arg)
 						&bufs[BUF_TYPE_VIDEO],
 						parm.data_32);
 			}
+		} else if (this->type & PORT_TYPE_FRAME) {
+			/* todo: frame based set max buffer size */
+			r = 0;
 		} else
 			r = -EINVAL;
 		break;
@@ -1564,6 +1862,8 @@ static long amstream_ioctl_set(struct stream_port_s *this, ulong arg)
 			(parm.data_vformat < VFORMAT_MAX)) {
 			this->vformat = parm.data_vformat;
 			this->flag |= PORT_FLAG_VFORMAT;
+
+			vdec_set_format(priv->vdec, this->vformat);
 		} else
 			r = -EINVAL;
 		break;
@@ -1591,7 +1891,7 @@ static long amstream_ioctl_set(struct stream_port_s *this, ulong arg)
 			this->aid = parm.data_32;
 			this->flag |= PORT_FLAG_AID;
 
-			if (this->flag & PORT_FLAG_INITED) {
+			if (port_get_inited(priv)) {
 				tsync_audio_break(1);
 				amstream_change_avid(this);
 			}
@@ -1603,7 +1903,7 @@ static long amstream_ioctl_set(struct stream_port_s *this, ulong arg)
 			this->sid = parm.data_32;
 			this->flag |= PORT_FLAG_SID;
 
-			if (this->flag & PORT_FLAG_INITED)
+			if (port_get_inited(priv))
 				amstream_change_sid(this);
 		} else
 			r = -EINVAL;
@@ -1638,6 +1938,8 @@ static long amstream_ioctl_set(struct stream_port_s *this, ulong arg)
 		if ((this->type & (PORT_TYPE_AUDIO | PORT_TYPE_VIDEO)) ==
 			((PORT_TYPE_AUDIO | PORT_TYPE_VIDEO)))
 			r = -EINVAL;
+		else if (this->type & PORT_TYPE_FRAME)
+			r = vdec_set_pts(priv->vdec, parm.data_32);
 		else if (has_hevc_vdec() && this->type & PORT_TYPE_HEVC)
 			r = es_vpts_checkin(&bufs[BUF_TYPE_HEVC],
 				parm.data_32);
@@ -1654,7 +1956,12 @@ static long amstream_ioctl_set(struct stream_port_s *this, ulong arg)
 			r = -EINVAL;
 		else {
 			u64 pts = parm.data_64;
-			if (has_hevc_vdec()) {
+			if (this->type & PORT_TYPE_FRAME) {
+				/* todo: check upper layer for decoder handler
+				 * life sequence or multi-tasking management
+				 */
+				r = vdec_set_pts64(priv->vdec, pts);
+			} else if (has_hevc_vdec()) {
 				if (this->type & PORT_TYPE_HEVC) {
 					r = es_vpts_checkin_us64(
 					&bufs[BUF_TYPE_HEVC], pts);
@@ -1677,15 +1984,14 @@ static long amstream_ioctl_set(struct stream_port_s *this, ulong arg)
 		}
 		break;
 	case AMSTREAM_PORT_INIT:
-		r = amstream_port_init(this);
+		r = amstream_port_init(priv);
 		break;
 	case AMSTREAM_SET_TRICKMODE:
 		if ((this->type & PORT_TYPE_VIDEO) == 0)
 			return -EINVAL;
-		if (amstream_vdec_trickmode == NULL)
+		r = vdec_set_trickmode(priv->vdec, parm.data_32);
+		if (r == -1)
 			return -ENODEV;
-		else
-			amstream_vdec_trickmode(parm.data_32);
 		break;
 
 	case AMSTREAM_AUDIO_RESET:
@@ -1749,15 +2055,22 @@ static long amstream_ioctl_set(struct stream_port_s *this, ulong arg)
 			tsync_set_apts(pts);
 		break;
 	}
+	case AMSTREAM_SET_FRAME_BASE_PATH:
+		if ((this->type & PORT_TYPE_DECODER_SCHED) &&
+			(parm.frame_base_video_path < FRAME_BASE_PATH_MAX)) {
+			vdec_set_video_path(priv->vdec, parm.data_32);
+		} else
+			r = -EINVAL;
+		break;
 	default:
 		r = -ENOIOCTLCMD;
 		break;
 	}
 	return r;
 }
-static long amstream_ioctl_get_ex(struct stream_port_s *this, ulong arg)
+static long amstream_ioctl_get_ex(struct port_priv_s *priv, ulong arg)
 {
-
+	struct stream_port_s *this = priv->port;
 	long r = 0;
 	struct am_ioctl_parm_ex parm;
 	if (copy_from_user
@@ -1776,8 +2089,34 @@ static long amstream_ioctl_get_ex(struct stream_port_s *this, ulong arg)
 				&bufs[BUF_TYPE_HEVC] :
 				&bufs[BUF_TYPE_VIDEO];
 
-			if (p == NULL)
+			if (p == NULL) {
 				r = -EINVAL;
+				break;
+			}
+
+			if (this->type & PORT_TYPE_FRAME) {
+				struct vdec_input_status_s status;
+
+				/* todo: check upper layer for decoder
+				 * handler lifecycle
+				 */
+				if (priv->vdec == NULL) {
+					r = -EINVAL;
+					break;
+				}
+
+				r = vdec_input_get_status(&priv->vdec->input,
+							&status);
+				if (r == 0) {
+					p->status.size = status.size;
+					p->status.data_len = status.data_len;
+					p->status.free_len = status.free_len;
+					p->status.read_pointer =
+							status.read_pointer;
+				}
+				break;
+			}
+
 			p->status.size = stbuf_canusesize(buf);
 			p->status.data_len = stbuf_level(buf);
 			p->status.free_len = stbuf_space(buf);
@@ -1805,17 +2144,13 @@ static long amstream_ioctl_get_ex(struct stream_port_s *this, ulong arg)
 		if ((this->type & PORT_TYPE_VIDEO) == 0) {
 			pr_err("no video\n");
 			return -EINVAL;
-		}
-		if (amstream_vdec_status == NULL) {
-			pr_err("no amstream_vdec_status\n");
-			return -ENODEV;
-		}
-		else {
+		} else {
 			struct vdec_status vstatus;
 			struct am_ioctl_parm_ex *p = &parm;
 			if (p == NULL)
 				return -EINVAL;
-			amstream_vdec_status(&vstatus);
+			if (vdec_status(priv->vdec, &vstatus) == -1)
+				return -ENODEV;
 			p->vstatus.width = vstatus.width;
 			p->vstatus.height = vstatus.height;
 			p->vstatus.fps = vstatus.fps;
@@ -1876,14 +2211,13 @@ static long amstream_ioctl_get_ex(struct stream_port_s *this, ulong arg)
 	return r;
 
 }
-static long amstream_ioctl_set_ex(struct stream_port_s *this, ulong arg)
+static long amstream_ioctl_set_ex(struct port_priv_s *priv, ulong arg)
 {
 	long r = 0;
 	return r;
 }
-static long amstream_ioctl_get_ptr(struct stream_port_s *this, ulong arg)
+static long amstream_ioctl_get_ptr(struct port_priv_s *priv, ulong arg)
 {
-
 	long r = 0;
 
 	struct am_ioctl_parm_ptr parm;
@@ -1925,8 +2259,9 @@ static long amstream_ioctl_get_ptr(struct stream_port_s *this, ulong arg)
 	return r;
 
 }
-static long amstream_ioctl_set_ptr(struct stream_port_s *this, ulong arg)
+static long amstream_ioctl_set_ptr(struct port_priv_s *priv, ulong arg)
 {
+	struct stream_port_s *this = priv->port;
 	struct am_ioctl_parm_ptr parm;
 	long r = 0;
 
@@ -1947,6 +2282,22 @@ static long amstream_ioctl_set_ptr(struct stream_port_s *this, ulong arg)
 		} else
 			r = -EINVAL;
 		break;
+	case AMSTREAM_SET_PTR_CONFIGS:
+		if (this->type & PORT_TYPE_VIDEO) {
+			if (!parm.pointer || (parm.len <= 0) ||
+				(parm.len > PAGE_SIZE)) {
+				r = -EINVAL;
+			} else {
+				r = copy_from_user(priv->vdec->config,
+						parm.pointer, parm.len);
+				if (r)
+					r = -EINVAL;
+				else
+					priv->vdec->config_len = parm.len;
+			}
+		} else
+			r = -EINVAL;
+		break;
 	default:
 		r = -ENOIOCTLCMD;
 		break;
@@ -1954,40 +2305,38 @@ static long amstream_ioctl_set_ptr(struct stream_port_s *this, ulong arg)
 	return r;
 }
 
-static long amstream_do_ioctl_new(struct stream_port_s *this,
+static long amstream_do_ioctl_new(struct port_priv_s *priv,
 	unsigned int cmd, ulong arg)
 {
 	long r = 0;
+	struct stream_port_s *this = priv->port;
 
 	switch (cmd) {
 	case AMSTREAM_IOC_GET_VERSION:
-		r = amstream_ioctl_get_version(this, arg);
+		r = amstream_ioctl_get_version(priv, arg);
 		break;
 	case AMSTREAM_IOC_GET:
-		r = amstream_ioctl_get(this, arg);
+		r = amstream_ioctl_get(priv, arg);
 		break;
 	case AMSTREAM_IOC_SET:
-		r = amstream_ioctl_set(this, arg);
+		r = amstream_ioctl_set(priv, arg);
 		break;
 	case AMSTREAM_IOC_GET_EX:
-		r = amstream_ioctl_get_ex(this, arg);
+		r = amstream_ioctl_get_ex(priv, arg);
 		break;
 	case AMSTREAM_IOC_SET_EX:
-		r = amstream_ioctl_set_ex(this, arg);
+		r = amstream_ioctl_set_ex(priv, arg);
 		break;
 	case AMSTREAM_IOC_GET_PTR:
-		r = amstream_ioctl_get_ptr(this, arg);
+		r = amstream_ioctl_get_ptr(priv, arg);
 		break;
 	case AMSTREAM_IOC_SET_PTR:
-		r = amstream_ioctl_set_ptr(this, arg);
+		r = amstream_ioctl_set_ptr(priv, arg);
 		break;
 	case AMSTREAM_IOC_SYSINFO:
-		if (this->type & PORT_TYPE_VIDEO) {
-			if (copy_from_user
-				((void *)&amstream_dec_info, (void *)arg,
-				 sizeof(amstream_dec_info)))
-				r = -EFAULT;
-		} else
+		if (this->type & PORT_TYPE_VIDEO)
+			r = vdec_set_decinfo(priv->vdec, (void *)arg);
+		else
 			r = -EINVAL;
 		break;
 	default:
@@ -1998,9 +2347,10 @@ static long amstream_do_ioctl_new(struct stream_port_s *this,
 	return r;
 }
 
-static long amstream_do_ioctl_old(struct stream_port_s *this,
+static long amstream_do_ioctl_old(struct port_priv_s *priv,
 	unsigned int cmd, ulong arg)
 {
+	struct stream_port_s *this = priv->port;
 	long r = 0;
 	switch (cmd) {
 
@@ -2052,6 +2402,8 @@ static long amstream_do_ioctl_old(struct stream_port_s *this,
 		if ((this->type & PORT_TYPE_VIDEO) && (arg < VFORMAT_MAX)) {
 			this->vformat = (enum vformat_e)arg;
 			this->flag |= PORT_FLAG_VFORMAT;
+
+			vdec_set_format(priv->vdec, this->vformat);
 		} else
 			r = -EINVAL;
 		break;
@@ -2081,7 +2433,7 @@ static long amstream_do_ioctl_old(struct stream_port_s *this,
 			this->aid = (u32) arg;
 			this->flag |= PORT_FLAG_AID;
 
-			if (this->flag & PORT_FLAG_INITED) {
+			if (port_get_inited(priv)) {
 				tsync_audio_break(1);
 				amstream_change_avid(this);
 			}
@@ -2094,7 +2446,7 @@ static long amstream_do_ioctl_old(struct stream_port_s *this,
 			this->sid = (u32) arg;
 			this->flag |= PORT_FLAG_SID;
 
-			if (this->flag & PORT_FLAG_INITED)
+			if (port_get_inited(priv))
 				amstream_change_sid(this);
 		} else
 			r = -EINVAL;
@@ -2118,8 +2470,37 @@ static long amstream_do_ioctl_old(struct stream_port_s *this,
 				&bufs[BUF_TYPE_HEVC] :
 				&bufs[BUF_TYPE_VIDEO];
 
-			if (p == NULL)
+			if (p == NULL) {
 				r = -EINVAL;
+				break;
+			}
+
+			if (this->type & PORT_TYPE_FRAME) {
+				struct vdec_input_status_s status;
+
+				/* todo: check upper layer for decoder
+				 * handler lifecycle
+				 */
+				if (priv->vdec == NULL) {
+					r = -EINVAL;
+					break;
+				}
+
+				r = vdec_input_get_status(&priv->vdec->input,
+							&status);
+				if (r == 0) {
+					p->status.size = status.size;
+					p->status.data_len = status.data_len;
+					p->status.free_len = status.free_len;
+					p->status.read_pointer =
+							status.read_pointer;
+					if (copy_to_user((void *)arg, p,
+						sizeof(para)))
+						r = -EFAULT;
+				}
+				break;
+			}
+
 			p->status.size = stbuf_canusesize(buf);
 			p->status.data_len = stbuf_level(buf);
 			p->status.free_len = stbuf_space(buf);
@@ -2152,12 +2533,9 @@ static long amstream_do_ioctl_old(struct stream_port_s *this,
 		break;
 
 	case AMSTREAM_IOC_SYSINFO:
-		if (this->type & PORT_TYPE_VIDEO) {
-			if (copy_from_user
-				((void *)&amstream_dec_info, (void *)arg,
-				 sizeof(amstream_dec_info)))
-				r = -EFAULT;
-		} else
+		if (this->type & PORT_TYPE_VIDEO)
+			r = vdec_set_decinfo(priv->vdec, (void *)arg);
+		else
 			r = -EINVAL;
 		break;
 
@@ -2188,6 +2566,8 @@ static long amstream_do_ioctl_old(struct stream_port_s *this,
 		if ((this->type & (PORT_TYPE_AUDIO | PORT_TYPE_VIDEO)) ==
 			((PORT_TYPE_AUDIO | PORT_TYPE_VIDEO)))
 			r = -EINVAL;
+		else if (this->type & PORT_TYPE_FRAME)
+			r = vdec_set_pts(priv->vdec, arg);
 		else if (has_hevc_vdec() && this->type & PORT_TYPE_HEVC)
 			r = es_vpts_checkin(&bufs[BUF_TYPE_HEVC], arg);
 		else if (this->type & PORT_TYPE_VIDEO)
@@ -2205,7 +2585,13 @@ static long amstream_do_ioctl_old(struct stream_port_s *this,
 			if (copy_from_user
 				((void *)&pts, (void *)arg, sizeof(u64)))
 				return -EFAULT;
-			if (has_hevc_vdec()) {
+			if (this->type & PORT_TYPE_FRAME) {
+				/* todo: check upper layer for decoder handler
+				 * life sequence or multi-tasking management
+				 */
+				if (priv->vdec)
+					r = vdec_set_pts64(priv->vdec, pts);
+			} else if (has_hevc_vdec()) {
 				if (this->type & PORT_TYPE_HEVC) {
 					r = es_vpts_checkin_us64(
 					&bufs[BUF_TYPE_HEVC], pts);
@@ -2231,15 +2617,14 @@ static long amstream_do_ioctl_old(struct stream_port_s *this,
 	case AMSTREAM_IOC_VDECSTAT:
 		if ((this->type & PORT_TYPE_VIDEO) == 0)
 			return -EINVAL;
-		if (amstream_vdec_status == NULL)
-			return -ENODEV;
-		else {
+		{
 			struct vdec_status vstatus;
 			struct am_io_param para;
 			struct am_io_param *p = &para;
 			if (p == NULL)
 				return -EINVAL;
-			amstream_vdec_status(&vstatus);
+			if (vdec_status(priv->vdec, &vstatus) == -1)
+				return -ENODEV;
 			p->vstatus.width = vstatus.width;
 			p->vstatus.height = vstatus.height;
 			p->vstatus.fps = vstatus.fps;
@@ -2274,16 +2659,25 @@ static long amstream_do_ioctl_old(struct stream_port_s *this,
 		}
 
 	case AMSTREAM_IOC_PORT_INIT:
-		r = amstream_port_init(this);
+		r = amstream_port_init(priv);
+		break;
+
+	case AMSTREAM_IOC_VDEC_RESET:
+		if ((this->type & PORT_TYPE_VIDEO) == 0)
+			return -EINVAL;
+
+		if (priv->vdec == NULL)
+			return -ENODEV;
+
+		r = vdec_reset(priv->vdec);
 		break;
 
 	case AMSTREAM_IOC_TRICKMODE:
 		if ((this->type & PORT_TYPE_VIDEO) == 0)
 			return -EINVAL;
-		if (amstream_vdec_trickmode == NULL)
+		r = vdec_set_trickmode(priv->vdec, arg);
+		if (r == -1)
 			return -ENODEV;
-		else
-			amstream_vdec_trickmode(arg);
 		break;
 
 	case AMSTREAM_IOC_AUDIO_INFO:
@@ -2386,26 +2780,26 @@ static long amstream_do_ioctl_old(struct stream_port_s *this,
 			u32 pts = 0, offset;
 			get_user(offset, (unsigned long __user *)arg);
 			pts_lookup_offset(PTS_TYPE_AUDIO, offset, &pts, 300);
-			put_user(pts, (unsigned long __user *)arg);
+			put_user(pts, (int __user *)arg);
 		}
 		return 0;
 	case GET_FIRST_APTS_FLAG:
 		if (this->type & PORT_TYPE_AUDIO) {
 			put_user(first_pts_checkin_complete(PTS_TYPE_AUDIO),
-					 (unsigned long __user *)arg);
+					 (int __user *)arg);
 		}
 		break;
 
 	case AMSTREAM_IOC_APTS:
-		put_user(timestamp_apts_get(), (unsigned long __user *)arg);
+		put_user(timestamp_apts_get(), (int __user *)arg);
 		break;
 
 	case AMSTREAM_IOC_VPTS:
-		put_user(timestamp_vpts_get(), (unsigned long __user *)arg);
+		put_user(timestamp_vpts_get(), (int __user *)arg);
 		break;
 
 	case AMSTREAM_IOC_PCRSCR:
-		put_user(timestamp_pcrscr_get(), (unsigned long __user *)arg);
+		put_user(timestamp_pcrscr_get(), (int __user *)arg);
 		break;
 
 	case AMSTREAM_IOC_SET_PCRSCR:
@@ -2535,7 +2929,7 @@ static long amstream_do_ioctl_old(struct stream_port_s *this,
 	return r;
 }
 
-static long amstream_do_ioctl(struct stream_port_s *this,
+static long amstream_do_ioctl(struct port_priv_s *priv,
 	unsigned int cmd, ulong arg)
 {
 	long r = 0;
@@ -2548,10 +2942,10 @@ static long amstream_do_ioctl(struct stream_port_s *this,
 	case AMSTREAM_IOC_GET_PTR:
 	case AMSTREAM_IOC_SET_PTR:
 	case AMSTREAM_IOC_SYSINFO:
-		r = amstream_do_ioctl_new(this, cmd, arg);
+		r = amstream_do_ioctl_new(priv, cmd, arg);
 		break;
 	default:
-		r = amstream_do_ioctl_old(this, cmd, arg);
+		r = amstream_do_ioctl_old(priv, cmd, arg);
 		break;
 	}
 	if (r != 0)
@@ -2561,13 +2955,13 @@ static long amstream_do_ioctl(struct stream_port_s *this,
 }
 static long amstream_ioctl(struct file *file, unsigned int cmd, ulong arg)
 {
-	struct inode *inode = file->f_dentry->d_inode;
-	struct stream_port_s *this = &ports[iminor(inode)];
+	struct port_priv_s *priv = (struct port_priv_s *)file->private_data;
+	struct stream_port_s *this = priv->port;
 
 	if (!this)
 		return -ENODEV;
 
-	return amstream_do_ioctl(this, cmd, arg);
+	return amstream_do_ioctl(priv, cmd, arg);
 }
 
 #ifdef CONFIG_COMPAT
@@ -2600,10 +2994,10 @@ struct am_ioctl_parm_ptr32 {
 		char data[8];
 	};
 	u32 cmd;
-	char reserved[4];
+	u32 len;
 };
 
-static long amstream_ioc_setget_ptr(struct stream_port_s *this,
+static long amstream_ioc_setget_ptr(struct port_priv_s *priv,
 		unsigned int cmd, struct am_ioctl_parm_ptr32 __user *arg)
 {
 	struct am_ioctl_parm_ptr __user *data;
@@ -2614,18 +3008,19 @@ static long amstream_ioc_setget_ptr(struct stream_port_s *this,
 		return -EFAULT;
 
 	if (put_user(data32->cmd, &data->cmd) ||
-		put_user(compat_ptr(data32->pointer), &data->pointer))
+		put_user(compat_ptr(data32->pointer), &data->pointer) ||
+		put_user(data32->len, &data->len))
 		return -EFAULT;
 
 
-	ret = amstream_do_ioctl(this, cmd, (unsigned long)data);
+	ret = amstream_do_ioctl(priv, cmd, (unsigned long)data);
 	if (ret < 0)
 		return ret;
 	return 0;
 
 }
 
-static long amstream_set_sysinfo(struct stream_port_s *this,
+static long amstream_set_sysinfo(struct port_priv_s *priv,
 		struct dec_sysinfo32 __user *arg)
 {
 	struct dec_sysinfo __user *data;
@@ -2642,7 +3037,7 @@ static long amstream_set_sysinfo(struct stream_port_s *this,
 					sizeof(data->ratio64)))
 		return -EFAULT;
 
-	ret = amstream_do_ioctl(this, AMSTREAM_IOC_SYSINFO,
+	ret = amstream_do_ioctl(priv, AMSTREAM_IOC_SYSINFO,
 			(unsigned long)data);
 	if (ret < 0)
 		return ret;
@@ -2658,8 +3053,7 @@ static long amstream_compat_ioctl(struct file *file,
 		unsigned int cmd, ulong arg)
 {
 	s32 r = 0;
-	struct inode *inode = file->f_dentry->d_inode;
-	struct stream_port_s *this = &ports[iminor(inode)];
+	struct port_priv_s *priv = (struct port_priv_s *)file->private_data;
 
 	switch (cmd) {
 	case AMSTREAM_IOC_GET_VERSION:
@@ -2667,14 +3061,14 @@ static long amstream_compat_ioctl(struct file *file,
 	case AMSTREAM_IOC_SET:
 	case AMSTREAM_IOC_GET_EX:
 	case AMSTREAM_IOC_SET_EX:
-		return amstream_do_ioctl(this, cmd, (ulong)compat_ptr(arg));
+		return amstream_do_ioctl(priv, cmd, (ulong)compat_ptr(arg));
 	case AMSTREAM_IOC_GET_PTR:
 	case AMSTREAM_IOC_SET_PTR:
-		return amstream_ioc_setget_ptr(this, cmd, compat_ptr(arg));
+		return amstream_ioc_setget_ptr(priv, cmd, compat_ptr(arg));
 	case AMSTREAM_IOC_SYSINFO:
-		return amstream_set_sysinfo(this, compat_ptr(arg));
+		return amstream_set_sysinfo(priv, compat_ptr(arg));
 	default:
-		return amstream_do_ioctl(this, cmd, (ulong)compat_ptr(arg));
+		return amstream_do_ioctl(priv, cmd, (ulong)compat_ptr(arg));
 	}
 
 	return r;
@@ -2718,10 +3112,12 @@ static ssize_t ports_show(struct class *class, struct class_attribute *attr,
 			pbuf += sprintf(pbuf, "%s ", "Used");
 		else
 			pbuf += sprintf(pbuf, "%s ", "Unused");
-		if (p->flag & PORT_FLAG_INITED)
-			pbuf += sprintf(pbuf, "%s ", "inited");
-		else
-			pbuf += sprintf(pbuf, "%s ", "uninited");
+		if ((p->type & PORT_TYPE_VIDEO) == 0) {
+			if (p->flag & PORT_FLAG_INITED)
+				pbuf += sprintf(pbuf, "%s ", "inited");
+			else
+				pbuf += sprintf(pbuf, "%s ", "uninited");
+		}
 		pbuf += sprintf(pbuf, ")\n");
 		/*others */
 		pbuf += sprintf(pbuf, "\tVformat:%d\n",
@@ -3051,13 +3447,8 @@ static int amstream_probe(struct platform_device *pdev)
 
 	pr_err("Amlogic A/V streaming port init\n");
 
-	if (has_hevc_vdec()) {
-		amstream_port_num = MAX_AMSTREAM_PORT_NUM;
-		amstream_buf_num = BUF_MAX_NUM;
-	} else {
-		amstream_port_num = MAX_AMSTREAM_PORT_NUM - 1;
-		amstream_buf_num = BUF_MAX_NUM - 1;
-	}
+	amstream_port_num = MAX_AMSTREAM_PORT_NUM;
+	amstream_buf_num = BUF_MAX_NUM;
 /*
 	r = of_reserved_mem_device_init(&pdev->dev);
 	if (r == 0)
@@ -3084,8 +3475,6 @@ static int amstream_probe(struct platform_device *pdev)
 		goto error2;
 	}
 
-	vdec_set_decinfo(&amstream_dec_info);
-
 	amstream_dev_class = class_create(THIS_MODULE, DEVICE_NAME);
 
 	for (st = &ports[0], i = 0; i < amstream_port_num; i++, st++) {
@@ -3094,7 +3483,6 @@ static int amstream_probe(struct platform_device *pdev)
 				ports[i].name);
 	}
 
-	amstream_vdec_status = NULL;
 	amstream_adec_status = NULL;
 	if (tsdemux_class_register() != 0) {
 		r = (-EIO);
@@ -3145,33 +3533,19 @@ static int amstream_remove(struct platform_device *pdev)
 
 	astream_dev_unregister();
 
-	amstream_vdec_status = NULL;
 	amstream_adec_status = NULL;
-	amstream_vdec_trickmode = NULL;
 
 	pr_err("Amlogic A/V streaming port release\n");
 
 	return 0;
 }
 
-void set_vdec_func(int (*vdec_func)(struct vdec_status *))
-{
-	amstream_vdec_status = vdec_func;
-	return;
-}
-
 void set_adec_func(int (*adec_func)(struct adec_status *))
 {
 	amstream_adec_status = adec_func;
 	return;
 }
 
-void set_trickmode_func(int (*trickmode_func)(unsigned long trickmode))
-{
-	amstream_vdec_trickmode = trickmode_func;
-	return;
-}
-
 void wakeup_sub_poll(void)
 {
 	atomic_inc(&subdata_ready);
@@ -3225,111 +3599,24 @@ static void __exit amstream_module_exit(void)
 	platform_driver_unregister(&amstream_driver);
 	return;
 }
-#if 0
-static int amstream_mem_device_init(struct reserved_mem *rmem,
-					struct device *dev)
-{
-	struct resource *res;
-	int r;
-	res = &memobj;
-
-	res->start = (phys_addr_t) rmem->base;
-	res->end = res->start + (phys_addr_t) rmem->size - 1;
-	if (!res) {
-		pr_err(
-		"Can not get I/O memory, and will allocate stream buffer!\n");
-
-		if (stbuf_change_size(&bufs[BUF_TYPE_VIDEO],
-				DEFAULT_VIDEO_BUFFER_SIZE) != 0) {
-			r = (-ENOMEM);
-			goto error4;
-		}
-		if (stbuf_change_size
-			(&bufs[BUF_TYPE_AUDIO],
-				DEFAULT_AUDIO_BUFFER_SIZE) != 0) {
-			r = (-ENOMEM);
-			goto error5;
-		}
-		if (stbuf_change_size
-			(&bufs[BUF_TYPE_SUBTITLE],
-			 DEFAULT_SUBTITLE_BUFFER_SIZE) != 0) {
-			r = (-ENOMEM);
-			goto error6;
-		}
-	} else {
-		bufs[BUF_TYPE_VIDEO].buf_start = res->start;
-		bufs[BUF_TYPE_VIDEO].buf_size =
-			resource_size(res) - DEFAULT_AUDIO_BUFFER_SIZE -
-			DEFAULT_SUBTITLE_BUFFER_SIZE;
-		bufs[BUF_TYPE_VIDEO].flag |= BUF_FLAG_IOMEM;
-		bufs[BUF_TYPE_VIDEO].default_buf_size =
-			bufs[BUF_TYPE_VIDEO].buf_size;
-
-		bufs[BUF_TYPE_AUDIO].buf_start =
-			res->start + bufs[BUF_TYPE_VIDEO].buf_size;
-		bufs[BUF_TYPE_AUDIO].buf_size = DEFAULT_AUDIO_BUFFER_SIZE;
-		bufs[BUF_TYPE_AUDIO].flag |= BUF_FLAG_IOMEM;
-
-		if (stbuf_change_size
-			(&bufs[BUF_TYPE_SUBTITLE],
-			 DEFAULT_SUBTITLE_BUFFER_SIZE) != 0) {
-			r = (-ENOMEM);
-			goto error4;
-		}
-	}
-
-	if (has_hevc_vdec()) {
-		bufs[BUF_TYPE_HEVC].buf_start = bufs[BUF_TYPE_VIDEO].buf_start;
-		bufs[BUF_TYPE_HEVC].buf_size = bufs[BUF_TYPE_VIDEO].buf_size;
-
-		if (bufs[BUF_TYPE_VIDEO].flag & BUF_FLAG_IOMEM)
-			bufs[BUF_TYPE_HEVC].flag |= BUF_FLAG_IOMEM;
-
-		bufs[BUF_TYPE_HEVC].default_buf_size =
-			bufs[BUF_TYPE_VIDEO].default_buf_size;
-	}
-
-	if (stbuf_fetch_init() != 0) {
-		r = (-ENOMEM);
-		goto error7;
-	}
-
-	return 0;
-
-error7:
-	if (bufs[BUF_TYPE_SUBTITLE].flag & BUF_FLAG_ALLOC)
-		stbuf_change_size(&bufs[BUF_TYPE_SUBTITLE], 0);
-error6:
-	if (bufs[BUF_TYPE_AUDIO].flag & BUF_FLAG_ALLOC)
-		stbuf_change_size(&bufs[BUF_TYPE_AUDIO], 0);
-error5:
-	if (bufs[BUF_TYPE_VIDEO].flag & BUF_FLAG_ALLOC)
-		stbuf_change_size(&bufs[BUF_TYPE_VIDEO], 0);
-error4:
-	return 0;
-}
-
-static const struct reserved_mem_ops rmem_amstream_ops = {
-	.device_init = amstream_mem_device_init,
-};
-
-static int __init amstream_mem_setup(struct reserved_mem *rmem)
-{
-	rmem->ops = &rmem_amstream_ops;
-	pr_err("share mem setup\n");
-
-	return 0;
-}
-RESERVEDMEM_OF_DECLARE(mesonstream,
-		"amlogic, stream-memory", amstream_mem_setup);
 
-#endif
 module_init(amstream_module_init);
 module_exit(amstream_module_exit);
 
 module_param(debugflags, uint, 0664);
 MODULE_PARM_DESC(debugflags, "\n amstream debugflags\n");
 
+module_param(def_4k_vstreambuf_sizeM, uint, 0664);
+MODULE_PARM_DESC(def_4k_vstreambuf_sizeM,
+	"\nDefault video Stream buf size for 4K MByptes\n");
+
+module_param(def_vstreambuf_sizeM, uint, 0664);
+MODULE_PARM_DESC(def_vstreambuf_sizeM,
+	"\nDefault video Stream buf size for < 1080p MByptes\n");
+
+module_param(slow_input, uint, 0664);
+MODULE_PARM_DESC(slow_input, "\n amstream slow_input\n");
+
 
 MODULE_DESCRIPTION("AMLOGIC streaming port driver");
 MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/amports/amvdec.c b/drivers/amlogic/amports/amvdec.c
index 8ec2ce7..bc512f9 100644
--- a/drivers/amlogic/amports/amvdec.c
+++ b/drivers/amlogic/amports/amvdec.c
@@ -44,7 +44,7 @@
 #include "amports_config.h"
 #include "arch/firmware.h"
 
-#define MC_SIZE (4096 * 4)
+#define MC_SIZE (4096 * 16)
 
 #ifdef CONFIG_WAKELOCK
 static struct wake_lock amvdec_lock;
@@ -63,7 +63,6 @@ static int video_stated_changed = 1;
 static void amvdec_pg_enable(bool enable)
 {
 	ulong timeout;
-
 	if (enable) {
 		AMVDEC_CLK_GATE_ON(MDEC_CLK_PIC_DC);
 		AMVDEC_CLK_GATE_ON(MDEC_CLK_DBLK);
@@ -240,17 +239,41 @@ int amvdec_wake_unlock(void)
 #define amvdec_wake_unlock()
 #endif
 
+static s32 am_vdec_loadmc_ex(struct vdec_s *vdec,
+		const char *name, s32(*load)(const u32 *))
+{
+	int err;
+
+	if (!vdec->mc_loaded) {
+		int loaded;
+		loaded = get_decoder_firmware_data(vdec->format,
+					name, (u8 *)(vdec->mc), (4096 * 4 * 4));
+		if (loaded <= 0)
+			return -1;
+
+		vdec->mc_loaded = true;
+	}
+
+	err = (*load)(vdec->mc);
+	if (err < 0) {
+		pr_err("loading firmware %s to vdec ram  failed!\n", name);
+		return err;
+	}
+	pr_debug("loading firmware %s to vdec ram  ok!\n", name);
+	return err;
+}
+
 static s32 am_loadmc_ex(enum vformat_e type,
 		const char *name, char *def, s32(*load)(const u32 *))
 {
-	char *mc_addr = vmalloc(4096 * 4);
+	char *mc_addr = vmalloc(4096 * 16);
 	char *pmc_addr = def;
 	int err;
 
 	if (!def && mc_addr) {
 		int loaded;
 		loaded = get_decoder_firmware_data(type,
-					name, mc_addr, (4096 * 4));
+					name, mc_addr, (4096 * 16));
 		if (loaded > 0)
 			pmc_addr = mc_addr;
 	}
@@ -328,6 +351,11 @@ s32 amvdec_loadmc_ex(enum vformat_e type, const char *name, char *def)
 	return am_loadmc_ex(type, name, def, &amvdec_loadmc);
 }
 
+s32 amvdec_vdec_loadmc_ex(struct vdec_s *vdec, const char *name)
+{
+	return am_vdec_loadmc_ex(vdec, name, &amvdec_loadmc);
+}
+
 static s32 amvdec2_loadmc(const u32 *p)
 {
 	if (has_vdec2()) {
@@ -500,6 +528,14 @@ s32 amhevc_loadmc_ex(enum vformat_e type, const char *name, char *def)
 		return 0;
 }
 
+s32 amhevc_vdec_loadmc_ex(struct vdec_s *vdec, const char *name)
+{
+	if (has_hevc_vdec())
+		return am_vdec_loadmc_ex(vdec, name, &amhevc_loadmc);
+	else
+		return 0;
+}
+
 void amvdec_start(void)
 {
 #ifdef CONFIG_WAKELOCK
@@ -566,6 +602,7 @@ void amhcodec_start(void)
 
 void amhevc_start(void)
 {
+
 	if (has_hevc_vdec()) {
 #ifdef CONFIG_WAKELOCK
 		amvdec_wake_lock();
@@ -744,6 +781,22 @@ int amvdec_resume(struct platform_device *dev)
 
 	return 0;
 }
+
+int amhevc_suspend(struct platform_device *dev, pm_message_t event)
+{
+	if (has_hevc_vdec())
+		amhevc_pg_enable(false);
+	return 0;
+}
+
+int amhevc_resume(struct platform_device *dev)
+{
+	if (has_hevc_vdec())
+		amhevc_pg_enable(true);
+	return 0;
+}
+
+
 #endif
 
 #ifdef CONFIG_WAKELOCK
diff --git a/drivers/amlogic/amports/amvdec.h b/drivers/amlogic/amports/amvdec.h
index 44598e2..57628c6 100644
--- a/drivers/amlogic/amports/amvdec.h
+++ b/drivers/amlogic/amports/amvdec.h
@@ -30,13 +30,14 @@ struct amvdec_dec_reg_s {
 	struct dec_sysinfo *dec_sysinfo;
 };				/*amvdec_dec_reg_t */
 
+struct vdec_s;
 
 extern void amvdec_start(void);
 extern void amvdec_stop(void);
 extern void amvdec_enable(void);
 extern void amvdec_disable(void);
 s32 amvdec_loadmc_ex(enum vformat_e type, const char *name, char *def);
-
+s32 amvdec_vdec_loadmc_ex(struct vdec_s *vdec, const char *name);
 
 extern void amvdec2_start(void);
 extern void amvdec2_stop(void);
@@ -51,7 +52,7 @@ extern void amhevc_stop(void);
 extern void amhevc_enable(void);
 extern void amhevc_disable(void);
 s32 amhevc_loadmc_ex(enum vformat_e type, const char *name, char *def);
-
+s32 amhevc_vdec_loadmc_ex(struct vdec_s *vdec, const char *name);
 
 
 extern void amhcodec_start(void);
@@ -66,6 +67,9 @@ extern int amvdev_resume(void);
 #ifdef CONFIG_PM
 extern int amvdec_suspend(struct platform_device *dev, pm_message_t event);
 extern int amvdec_resume(struct platform_device *dec);
+extern int amhevc_suspend(struct platform_device *dev, pm_message_t event);
+extern int amhevc_resume(struct platform_device *dec);
+
 #endif
 
 #if 1				/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
diff --git a/drivers/amlogic/amports/amvideocap.c b/drivers/amlogic/amports/amvideocap.c
index 5ac6c7c..274dcbb 100644
--- a/drivers/amlogic/amports/amvideocap.c
+++ b/drivers/amlogic/amports/amvideocap.c
@@ -291,7 +291,8 @@ static ssize_t amvideocap_YUV_to_RGB(
 	intfmt = amvideocap_get_input_format(vf);
 
 	if (((vf->bitdepth & BITDEPTH_Y10)) &&
-		(intfmt == GE2D_FORMAT_S16_YUV422)) {
+		(intfmt == GE2D_FORMAT_S16_YUV422) &&
+		(get_cpu_type() < MESON_CPU_MAJOR_ID_TXL)) {
 		temp_canvas_idx =
 			canvas_pool_map_alloc_canvas(amvideocap_owner);
 		if (temp_canvas_idx < 0) {
@@ -352,7 +353,9 @@ static ssize_t amvideocap_YUV_to_RGB(
 
 	height_after_di = vf->height;
 	if (((vf->bitdepth & BITDEPTH_Y10)) &&
-		(intfmt == GE2D_FORMAT_S16_YUV422)) {
+		((intfmt == GE2D_FORMAT_S16_YUV422) ||
+		((intfmt == GE2D_FORMAT_S24_YUV444) &&
+		(get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL)))) {
 		pr_info("input_height = %d , vf->type_original = %x\n" ,
 			input_height, vf->type_original);
 		if ((vf->source_type == VFRAME_SOURCE_TYPE_HDMI) ||
@@ -393,7 +396,8 @@ static ssize_t amvideocap_YUV_to_RGB(
 	canvas_read(v_index, &cs2);
 
 	if (((vf->bitdepth & BITDEPTH_Y10)) &&
-		(intfmt == GE2D_FORMAT_S16_YUV422)) {
+		(intfmt == GE2D_FORMAT_S16_YUV422) &&
+		(get_cpu_type() < MESON_CPU_MAJOR_ID_TXL)) {
 		pr_info("vf->width = %d , vf->height = %d , vf->bitdepth = %d\n",
 		vf->width, vf->height, vf->bitdepth);
 		do_gettimeofday(&start);
@@ -501,7 +505,8 @@ static ssize_t amvideocap_YUV_to_RGB(
 			u_index, cur_index);
 
 	if (((vf->bitdepth & BITDEPTH_Y10)) &&
-		(intfmt == GE2D_FORMAT_S16_YUV422)) {
+		(intfmt == GE2D_FORMAT_S16_YUV422) &&
+		(get_cpu_type() < MESON_CPU_MAJOR_ID_TXL)) {
 		ge2d_config.src_planes[0].addr = temp_cs0.addr;
 		ge2d_config.src_planes[0].w = temp_cs0.width;
 		ge2d_config.src_planes[0].h = temp_cs0.height;
@@ -533,13 +538,41 @@ static ssize_t amvideocap_YUV_to_RGB(
 	ge2d_config.src_key.key_color = 0;
 
 	if (((vf->bitdepth & BITDEPTH_Y10)) &&
-		(intfmt == GE2D_FORMAT_S16_YUV422))
+		(intfmt == GE2D_FORMAT_S16_YUV422) &&
+		(get_cpu_type() < MESON_CPU_MAJOR_ID_TXL))
 		ge2d_config.src_para.canvas_index = temp_canvas_idx;
 	else
 		ge2d_config.src_para.canvas_index = cur_index;
 
 	ge2d_config.src_para.mem_type = CANVAS_TYPE_INVALID;
-	ge2d_config.src_para.format = intfmt;
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+		if (intfmt == GE2D_FORMAT_S16_YUV422) {
+			if ((vf->bitdepth & BITDEPTH_Y10) &&
+				(vf->bitdepth & FULL_PACK_422_MODE)) {
+				pr_info("format is yuv422 10bit .\n");
+				ge2d_config.src_para.format =
+					GE2D_FORMAT_S16_10BIT_YUV422;
+			} else if (vf->bitdepth & BITDEPTH_Y10) {
+				pr_info("format is yuv422 12bit .\n");
+				ge2d_config.src_para.format =
+					GE2D_FORMAT_S16_12BIT_YUV422;
+			} else {
+				ge2d_config.src_para.format = intfmt;
+			}
+		} else if (intfmt == GE2D_FORMAT_S24_YUV444) {
+			if (vf->bitdepth & BITDEPTH_Y10) {
+				pr_info("format is yuv444 10bit .\n");
+				ge2d_config.src_para.format =
+					GE2D_FORMAT_S24_10BIT_YUV444;
+			} else {
+				ge2d_config.src_para.format = intfmt;
+			}
+		} else {
+			ge2d_config.src_para.format = intfmt;
+		}
+	} else {
+		ge2d_config.src_para.format = intfmt;
+	}
 	ge2d_config.src_para.fill_color_en = 0;
 	ge2d_config.src_para.fill_mode = 0;
 	ge2d_config.src_para.x_rev = 0;
@@ -588,7 +621,8 @@ static ssize_t amvideocap_YUV_to_RGB(
 		canvas_pool_map_free_canvas(canvas_idx);
 
 	if (((vf->bitdepth & BITDEPTH_Y10)) &&
-		(intfmt == GE2D_FORMAT_S16_YUV422)) {
+		(intfmt == GE2D_FORMAT_S16_YUV422) &&
+		(get_cpu_type() < MESON_CPU_MAJOR_ID_TXL)) {
 		if (phybufaddr_8bit) {
 			ret = codec_mm_free_for_dma(CMA_NAME, phybufaddr_8bit);
 			if (ret != 0)
diff --git a/drivers/amlogic/amports/arch/regs/viu_regs.h b/drivers/amlogic/amports/arch/regs/viu_regs.h
index 214c728..df5c875 100644
--- a/drivers/amlogic/amports/arch/regs/viu_regs.h
+++ b/drivers/amlogic/amports/arch/regs/viu_regs.h
@@ -193,6 +193,7 @@
 #define VD2_AFBC_LBUF_DEPTH 0x3185
 #define VD2_AFBC_HEAD_BADDR 0x3186
 #define VD2_AFBC_BODY_BADDR 0x3187
+#define VD2_AFBC_SIZE_OUT   0x3188
 #define VD2_AFBC_OUT_XSCOPE 0x3188
 #define VD2_AFBC_OUT_YSCOPE 0x3189
 #define VD2_AFBC_STAT 0x318a
diff --git a/drivers/amlogic/amports/arch/ucode/avs/avs_linux.h b/drivers/amlogic/amports/arch/ucode/avs/avs_linux.h
index 75becf8..988604a 100644
--- a/drivers/amlogic/amports/arch/ucode/avs/avs_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/avs/avs_linux.h
@@ -15,6 +15,7 @@
  *
 */
 
+/* ucode commit id: 1c4f555b8e1 */
 static const u32 MicroCode[] __initconst = {
 	0x06807801, 0x06800000, 0x0d000001, 0x07400040, 0x0c018200,
 	0x00000000, 0x00000000, 0x00000000, 0x080c0002, 0x06932000,
@@ -274,7 +275,7 @@ static const u32 MicroCode[] __initconst = {
 	0x040012ca, 0x0950828b, 0x0c780080, 0x0960828b, 0x07801607,
 	0x090041c7, 0x0a8051c8, 0x0aa2001a, 0x07801607, 0x090841c7,
 	0x0a4051c8, 0x06800047, 0x03407207, 0x0c7ff8c0, 0x02c091c9,
-	0x078008c7, 0x040c0248, 0x07400247, 0x07800907, 0x04004249,
+	0x078008c7, 0x040c0248, 0x07400247, 0x07800907, 0x04010249,
 	0x07400247, 0x07804187, 0x054031c7, 0x02c07687, 0x04090248,
 	0x07400247, 0x040801c8, 0x07801049, 0x074001c9, 0x040a01c8,
 	0x07801009, 0x0a60c05a, 0x074001c9, 0x040006c8, 0x0a62009a,
diff --git a/drivers/amlogic/amports/arch/ucode/avs/avs_linux_debug.h b/drivers/amlogic/amports/arch/ucode/avs/avs_linux_debug.h
index 06993a3..1432471 100644
--- a/drivers/amlogic/amports/arch/ucode/avs/avs_linux_debug.h
+++ b/drivers/amlogic/amports/arch/ucode/avs/avs_linux_debug.h
@@ -15,6 +15,7 @@
  *
 */
 
+/* ucode commit id: 1c4f555b8e1 */
 static const u32 MicroCode[] __initconst = {
 	0x06807801, 0x06800000, 0x0d000001, 0x07400040, 0x0c018740,
 	0x00000000, 0x00000000, 0x00000000, 0x080c0002, 0x06932000,
@@ -277,7 +278,7 @@ static const u32 MicroCode[] __initconst = {
 	0x0960828b, 0x07801607, 0x090041c7, 0x0a8051c8, 0x0aa2001a,
 	0x07801607, 0x090841c7, 0x0a4051c8, 0x06800047, 0x03407207,
 	0x0c7ff8c0, 0x02c091c9, 0x078008c7, 0x040c0248, 0x07400247,
-	0x07800907, 0x04004249, 0x07400247, 0x07804187, 0x054031c7,
+	0x07800907, 0x04010249, 0x07400247, 0x07804187, 0x054031c7,
 	0x02c07687, 0x04090248, 0x07400247, 0x040801c8, 0x07801049,
 	0x074001c9, 0x040a01c8, 0x07801009, 0x0a60c05a, 0x074001c9,
 	0x040006c8, 0x0a62009a, 0x040b01c8, 0x074001d9, 0x07000709,
diff --git a/drivers/amlogic/amports/arch/ucode/avs/avs_linux_old.h b/drivers/amlogic/amports/arch/ucode/avs/avs_linux_old.h
index af61b2b..3976669 100644
--- a/drivers/amlogic/amports/arch/ucode/avs/avs_linux_old.h
+++ b/drivers/amlogic/amports/arch/ucode/avs/avs_linux_old.h
@@ -15,29 +15,30 @@
  *
 */
 
+/* ucode commit id: 1c4f555b8e1 */
 static const u32 MicroCode[] __initconst = {
-	0x06807801, 0x06800000, 0x0d000001, 0x07400040, 0x0c0145c0,
+	0x06807801, 0x06800000, 0x0d000001, 0x07400040, 0x0c014640,
 	0x00000000, 0x00000000, 0x00000000, 0x080c0002, 0x06932000,
 	0x09800580, 0x060c1e00, 0x06bfdac0, 0x07c017c0, 0x06030400,
-	0x00400000, 0x0c015800, 0x00000000, 0x00000000, 0x00000000,
+	0x00400000, 0x0c015880, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x0c7ffec0, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
-	0x00400000, 0x0c780540, 0x064c0007, 0x0c796080, 0x00000000,
-	0x0c796a80, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
-	0x00400000, 0x0c796900, 0x00000000, 0x0cc00000, 0x00400000,
+	0x00400000, 0x0c780540, 0x064c0007, 0x0c796100, 0x00000000,
+	0x0c796b00, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c796980, 0x00000000, 0x0cc00000, 0x00400000,
 	0x06800009, 0x07c01fc9, 0x07c00409, 0x00800000, 0x078017c9,
 	0x0c7ffe40, 0x06030409, 0x06bfd9c9, 0x06030409, 0x00400000,
-	0x0a2d8047, 0x07801509, 0x0aa14009, 0x0a608049, 0x0c78f700,
-	0x0a608089, 0x0c78ebc0, 0x0a23c807, 0x0c786200, 0x00000000,
-	0x0649d008, 0x0aa0c008, 0x0809c701, 0x0c780000, 0x0c01a380,
-	0x080c0a00, 0x0c01a6c0, 0x00000000, 0x0c01b980, 0x00000000,
-	0x0c792ec0, 0x00000000, 0x0becd007, 0x078043c8, 0x0aa0c008,
-	0x0a208207, 0x0c792d40, 0x078003c7, 0x0a6fc007, 0x078043c7,
+	0x0a2d8047, 0x07801509, 0x0aa14009, 0x0a608049, 0x0c78f780,
+	0x0a608089, 0x0c78ec40, 0x0a23c807, 0x0c786200, 0x00000000,
+	0x0649d008, 0x0aa0c008, 0x0809c701, 0x0c780000, 0x0c01a400,
+	0x080c0a00, 0x0c01a740, 0x00000000, 0x0c01ba00, 0x00000000,
+	0x0c792f40, 0x00000000, 0x0becd007, 0x078043c8, 0x0aa0c008,
+	0x0a208207, 0x0c792dc0, 0x078003c7, 0x0a6fc007, 0x078043c7,
 	0x0a63c007, 0x064c2907, 0x0be2c407, 0x07800007, 0x0a62c007,
 	0x00000000, 0x064c2907, 0x091c11c7, 0x0a61c047, 0x00000000,
-	0x064c0607, 0x0900f1c7, 0x0ae0c047, 0x0c792900, 0x00000000,
-	0x0cb8002c, 0x00000000, 0x068fdfca, 0x064e0408, 0x02808288,
+	0x064c0607, 0x0900f1c7, 0x0ae0c047, 0x0c792980, 0x00000000,
+	0x0cb8002d, 0x00000000, 0x068fdfca, 0x064e0408, 0x02808288,
 	0x02c08748, 0x060e0408, 0x060c071e, 0x064c0324, 0x064c0325,
 	0x064c2728, 0x09210268, 0x07800007, 0x0a618007, 0x07801c08,
 	0x06c00008, 0x060c0208, 0x080c0200, 0x06bfffc9, 0x060c0320,
@@ -65,7 +66,7 @@ static const u32 MicroCode[] __initconst = {
 	0x0680070a, 0x07c01c8a, 0x0b013bc8, 0x0aa0800a, 0x0a64470a,
 	0x07801cca, 0x0a20c04a, 0x06a0800b, 0x06a0c00b, 0x06b80009,
 	0x07801d0c, 0x0540928c, 0x0200a24a, 0x06c0748a, 0x0200ac0a,
-	0x0603510a, 0x06803f0a, 0x0603520a, 0x0603500b, 0x0c01b400,
+	0x0603510a, 0x06803f0a, 0x0603520a, 0x0603500b, 0x0c01b480,
 	0x00000000, 0x07800007, 0x040011c7, 0x07c00007, 0x09c1d39d,
 	0x07800988, 0x0b405207, 0x040011c7, 0x0b833207, 0x0c780c80,
 	0x0981d1dd, 0x06800007, 0x07c00007, 0x0981d39d, 0x09c1d3dd,
@@ -74,9 +75,9 @@ static const u32 MicroCode[] __initconst = {
 	0x0a2f0107, 0x06a00007, 0x060c3d07, 0x07800147, 0x0aa24007,
 	0x06803fcb, 0x07801a88, 0x064e0c09, 0x09010249, 0x0b804248,
 	0x0aa0c00b, 0x0c7ffec0, 0x044012cb, 0x07804147, 0x0aa280c7,
-	0x07800347, 0x07801dc8, 0x0b407207, 0x0c01c600, 0x07c00348,
-	0x06800048, 0x07c00308, 0x0c789640, 0x07c00388, 0x06800008,
-	0x07c00308, 0x07c00388, 0x0c78f740, 0x064c0007, 0x0b60c709,
+	0x07800347, 0x07801dc8, 0x0b407207, 0x0c01c680, 0x07c00348,
+	0x06800048, 0x07c00308, 0x0c7896c0, 0x07c00388, 0x06800008,
+	0x07c00308, 0x07c00388, 0x0c78f7c0, 0x064c0007, 0x0b60c709,
 	0x06808008, 0x0680c008, 0x0c780400, 0x06800007, 0x07800007,
 	0x09508787, 0x078016c9, 0x09408789, 0x07800989, 0x0b009bc9,
 	0x06808008, 0x0aad0007, 0x07801c89, 0x040011c9, 0x0ba10707,
@@ -108,432 +109,432 @@ static const u32 MicroCode[] __initconst = {
 	0x09010249, 0x0b804248, 0x0aa0c00b, 0x0c7ffec0, 0x044012cb,
 	0x06800088, 0x068000c9, 0x0680180b, 0x060c210b, 0x0780184b,
 	0x0a6fc00b, 0x00000000, 0x07c01b08, 0x0c7fb040, 0x07c01ac9,
-	0x0a279007, 0x00000000, 0x0649d00a, 0x0aa0c00a, 0x0809c701,
-	0x0c780000, 0x0c014180, 0x080c0a00, 0x0c0144c0, 0x00000000,
-	0x0c0152c0, 0x00000000, 0x064c000a, 0x09c0a18a, 0x0980a20a,
-	0x0980a00a, 0x060c000a, 0x080c2300, 0x064c1e08, 0x09c081c8,
-	0x09808008, 0x060c1e08, 0x098081c8, 0x09c08008, 0x060c1e08,
-	0x064c080a, 0x0980a34a, 0x060c080a, 0x0c014680, 0x00000000,
-	0x064c1a07, 0x0aa10007, 0x06800008, 0x0c78c780, 0x00000000,
-	0x064c1e0a, 0x0980a60a, 0x060c1e0a, 0x06809009, 0x060c0809,
-	0x0fc08280, 0x0aa3ec0a, 0x0649c108, 0x0aa2c008, 0x0aa12cca,
-	0x0aa1ad8a, 0x0ae22bca, 0x0c78a5c0, 0x06800007, 0x0c780980,
-	0x07c00387, 0x06800007, 0x0c781ec0, 0x07c00387, 0x0c78c240,
-	0x00000000, 0x0fc08280, 0x07c0400a, 0x0609c40a, 0x0fc08280,
-	0x0fc01280, 0x0500128a, 0x07c0404a, 0x0fc0e1c0, 0x07c04087,
-	0x0609c107, 0x0fc0e1c0, 0x07c040c7, 0x0609c207, 0x0fc021c0,
-	0x0fc031c0, 0x0fc041c0, 0x0609c007, 0x0fc041c0, 0x0609c307,
-	0x0fc091c0, 0x0fc091c0, 0x0fc011c0, 0x0fc0c1c0, 0x0fc011c0,
-	0x07c04107, 0x0fc011c0, 0x0fc091c0, 0x0fc091c0, 0x0fc031c0,
-	0x0c78ba80, 0x00000000, 0x06800007, 0x07c01f87, 0x07804007,
-	0x0a611207, 0x0fc101c0, 0x0fc011c0, 0x0fc071c0, 0x0fc011c0,
-	0x0aa10007, 0x00000000, 0x0fc0c1c0, 0x0fc0c1c0, 0x0fc011c0,
-	0x07802047, 0x07c02007, 0x07802087, 0x07c02047, 0x0fc081c0,
-	0x07c02087, 0x07804107, 0x0aa10007, 0x0c016a40, 0x080c2301,
-	0x07c01f47, 0x0fc011c0, 0x07802088, 0x095c1207, 0x07c02088,
-	0x050011c7, 0x07c01807, 0x0aa30007, 0x068000c8, 0x0fc011c0,
-	0x0a624007, 0x068000c8, 0x0fc011c0, 0x07c04187, 0x0a60c007,
-	0x06800048, 0x06800088, 0x0c780140, 0x07c04148, 0x07c04148,
-	0x0fc011c0, 0x07c04187, 0x0fc011c0, 0x07c041c7, 0x0fc011c0,
-	0x07c04207, 0x0fc061c0, 0x07c04247, 0x06800087, 0x07c00087,
-	0x06800808, 0x060c2108, 0x07801807, 0x0aa18007, 0x06800008,
-	0x07804147, 0x0aa0c0c7, 0x00000000, 0x0fc01200, 0x07c04288,
-	0x0fc041c0, 0x0fc011c0, 0x07c042c7, 0x0a648007, 0x06800008,
-	0x0fc011c0, 0x0aa34007, 0x06800009, 0x0c015dc0, 0x080c2301,
-	0x0c015e40, 0x00000000, 0x07c04307, 0x0c015c80, 0x080c2301,
-	0x0c015d00, 0x00000000, 0x0c780100, 0x07c04347, 0x07c04308,
-	0x07c04349, 0x06800007, 0x07c00107, 0x0c782a00, 0x0680001a,
-	0x07804007, 0x0a611207, 0x0fc101c0, 0x0fc011c0, 0x0fc071c0,
-	0x0fc021c0, 0x0a60c047, 0x0c780180, 0x0680005a, 0x0fc081c0,
-	0x07c020c7, 0x0c780240, 0x0680009a, 0x07802047, 0x07c02007,
-	0x07802087, 0x07c02047, 0x0fc081c0, 0x07c02087, 0x07c020c7,
-	0x07804107, 0x0aa10007, 0x0c015400, 0x080c2301, 0x07c01f47,
-	0x0fc011c0, 0x078020c8, 0x095c1207, 0x0aa0c09a, 0x07c020c8,
-	0x07c02088, 0x050011c7, 0x07c01807, 0x0aa34007, 0x068000c8,
-	0x0fc011c0, 0x0a628007, 0x068000c8, 0x0fc011c0, 0x0fc011c0,
+	0x0be0d007, 0x0c7807c0, 0x00000000, 0x00000000, 0x0649d00a,
+	0x0aa0c00a, 0x0809c701, 0x0c780000, 0x0c014180, 0x080c0a00,
+	0x0c0144c0, 0x00000000, 0x0c0152c0, 0x00000000, 0x064c000a,
+	0x09c0a18a, 0x0980a20a, 0x0980a00a, 0x060c000a, 0x080c2300,
+	0x064c1e08, 0x09c081c8, 0x09808008, 0x060c1e08, 0x098081c8,
+	0x09c08008, 0x060c1e08, 0x064c080a, 0x0980a34a, 0x060c080a,
+	0x0c014680, 0x00000000, 0x064c1a07, 0x0aa10007, 0x06800008,
+	0x0c78c780, 0x00000000, 0x064c1e0a, 0x0980a60a, 0x060c1e0a,
+	0x06809009, 0x060c0809, 0x0fc08280, 0x0aa3ec0a, 0x0649c108,
+	0x0aa2c008, 0x0aa12cca, 0x0aa1ad8a, 0x0ae22bca, 0x0c78a5c0,
+	0x06800007, 0x0c780980, 0x07c00387, 0x06800007, 0x0c781ec0,
+	0x07c00387, 0x0c78c240, 0x00000000, 0x0fc08280, 0x07c0400a,
+	0x0609c40a, 0x0fc08280, 0x0fc01280, 0x0500128a, 0x07c0404a,
+	0x0fc0e1c0, 0x07c04087, 0x0609c107, 0x0fc0e1c0, 0x07c040c7,
+	0x0609c207, 0x0fc021c0, 0x0fc031c0, 0x0fc041c0, 0x0609c007,
+	0x0fc041c0, 0x0609c307, 0x0fc091c0, 0x0fc091c0, 0x0fc011c0,
+	0x0fc0c1c0, 0x0fc011c0, 0x07c04107, 0x0fc011c0, 0x0fc091c0,
+	0x0fc091c0, 0x0fc031c0, 0x0c78ba80, 0x00000000, 0x06800007,
+	0x07c01f87, 0x07804007, 0x0a611207, 0x0fc101c0, 0x0fc011c0,
+	0x0fc071c0, 0x0fc011c0, 0x0aa10007, 0x00000000, 0x0fc0c1c0,
+	0x0fc0c1c0, 0x0fc011c0, 0x07800a47, 0x07c00a07, 0x07800a87,
+	0x07c00a47, 0x0fc081c0, 0x07c00a87, 0x07804107, 0x0aa10007,
+	0x0c016a40, 0x080c2301, 0x07c01f47, 0x0fc011c0, 0x07800a88,
+	0x095c1207, 0x07c00a88, 0x050011c7, 0x07c01807, 0x0aa30007,
+	0x068000c8, 0x0fc011c0, 0x0a624007, 0x068000c8, 0x0fc011c0,
 	0x07c04187, 0x0a60c007, 0x06800048, 0x06800088, 0x0c780140,
 	0x07c04148, 0x07c04148, 0x0fc011c0, 0x07c04187, 0x0fc011c0,
 	0x07c041c7, 0x0fc011c0, 0x07c04207, 0x0fc061c0, 0x07c04247,
-	0x078020c7, 0x048ff207, 0x07c01f08, 0x091c11c7, 0x0aa5c007,
-	0x07802007, 0x091c1207, 0x0a610008, 0x048ff1c7, 0x054011c7,
-	0x048ff1c7, 0x07c01e47, 0x07802047, 0x091c1207, 0x0a610008,
-	0x048ff1c7, 0x054011c7, 0x048ff1c7, 0x07c01e87, 0x07802087,
+	0x06800087, 0x07c00087, 0x06800808, 0x060c2108, 0x07801807,
+	0x0aa18007, 0x06800008, 0x07804147, 0x0aa0c0c7, 0x00000000,
+	0x0fc01200, 0x07c04288, 0x0fc041c0, 0x0fc011c0, 0x07c042c7,
+	0x0a648007, 0x06800008, 0x0fc011c0, 0x0aa34007, 0x06800009,
+	0x0c015dc0, 0x080c2301, 0x0c015e40, 0x00000000, 0x07c04307,
+	0x0c015c80, 0x080c2301, 0x0c015d00, 0x00000000, 0x0c780100,
+	0x07c04347, 0x07c04308, 0x07c04349, 0x06800007, 0x07c00107,
+	0x0c782a00, 0x0680001a, 0x07804007, 0x0a611207, 0x0fc101c0,
+	0x0fc011c0, 0x0fc071c0, 0x0fc021c0, 0x0a60c047, 0x0c780180,
+	0x0680005a, 0x0fc081c0, 0x07c00ac7, 0x0c780240, 0x0680009a,
+	0x07800a47, 0x07c00a07, 0x07800a87, 0x07c00a47, 0x0fc081c0,
+	0x07c00a87, 0x07c00ac7, 0x07804107, 0x0aa10007, 0x0c015400,
+	0x080c2301, 0x07c01f47, 0x0fc011c0, 0x07800ac8, 0x095c1207,
+	0x0aa0c09a, 0x07c00ac8, 0x07c00a88, 0x050011c7, 0x07c01807,
+	0x0aa34007, 0x068000c8, 0x0fc011c0, 0x0a628007, 0x068000c8,
+	0x0fc011c0, 0x0fc011c0, 0x07c04187, 0x0a60c007, 0x06800048,
+	0x06800088, 0x0c780140, 0x07c04148, 0x07c04148, 0x0fc011c0,
+	0x07c04187, 0x0fc011c0, 0x07c041c7, 0x0fc011c0, 0x07c04207,
+	0x0fc061c0, 0x07c04247, 0x07800ac7, 0x048ff207, 0x07c01f08,
+	0x091c11c7, 0x0aa5c007, 0x07800a07, 0x091c1207, 0x0a610008,
+	0x048ff1c7, 0x054011c7, 0x048ff1c7, 0x07c01e47, 0x07800a47,
 	0x091c1207, 0x0a610008, 0x048ff1c7, 0x054011c7, 0x048ff1c7,
-	0x0c780b40, 0x07c01ec7, 0x07802007, 0x091c1207, 0x0aa2c008,
-	0x048ff1c7, 0x058011c7, 0x07801f08, 0x0b4031c8, 0x06804009,
-	0x02008248, 0x024091c8, 0x0ba0e009, 0x0c7fff80, 0x040801c7,
-	0x07c01e47, 0x07802047, 0x091c1207, 0x0aa2c008, 0x048ff1c7,
-	0x058011c7, 0x07801f08, 0x0b4031c8, 0x06804009, 0x02008248,
-	0x024091c8, 0x0ba0e009, 0x0c7fff80, 0x040801c7, 0x07c01e87,
-	0x07802087, 0x091c1207, 0x0aa2c008, 0x048ff1c7, 0x058011c7,
-	0x07801f08, 0x0b0031c8, 0x06804009, 0x02408248, 0x02409207,
-	0x0ba0e009, 0x0c7fff80, 0x044801c7, 0x048ff1c7, 0x07c01ec7,
-	0x0a61409a, 0x07804147, 0x0a60c0c7, 0x0c780240, 0x06800808,
-	0x0fc011c0, 0x07c00087, 0x0a6f0007, 0x06800808, 0x06800047,
-	0x09505207, 0x09605207, 0x060c2108, 0x0fc011c0, 0x0fc011c0,
-	0x07c01f87, 0x0fc021c0, 0x0fc011c0, 0x07c04287, 0x0fc011c0,
-	0x07c042c7, 0x0a648007, 0x06800008, 0x0fc011c0, 0x0aa34007,
-	0x06800009, 0x0c0133c0, 0x080c2301, 0x0c013440, 0x00000000,
-	0x07c04307, 0x0c013280, 0x080c2301, 0x0c013300, 0x00000000,
-	0x0c780100, 0x07c04347, 0x07c04308, 0x07c04349, 0x06800007,
-	0x07c00107, 0x07804007, 0x0aa25207, 0x00000000, 0x06802007,
-	0x06c02007, 0x060e1907, 0x060e1a07, 0x060e1b07, 0x0c781640,
-	0x00000000, 0x0fc011c0, 0x064e1c09, 0x097e1247, 0x0aa20047,
-	0x060e1c09, 0x06802007, 0x06c02007, 0x060e1907, 0x060e1a07,
-	0x0c781200, 0x060e1b07, 0x0fc011c0, 0x0fc011c0, 0x06800009,
-	0x07c01009, 0x0a630007, 0x07c01049, 0x0c012940, 0x080c2301,
-	0x0c0129c0, 0x00000000, 0x07c01007, 0x0c012800, 0x080c2301,
-	0x0c012880, 0x00000000, 0x07c01047, 0x0fc021c0, 0x0fc02200,
-	0x064e1c09, 0x09602248, 0x07801008, 0x09405248, 0x07801048,
-	0x09505248, 0x060e1c09, 0x0aa30047, 0x06802008, 0x07c01088,
-	0x06801888, 0x07c010c8, 0x06801a88, 0x07c01108, 0x06801d08,
-	0x07c01148, 0x07c01188, 0x0c7802c0, 0x06802008, 0x068021c8,
-	0x07c01088, 0x068023c8, 0x07c010c8, 0x07c01108, 0x06802808,
-	0x07c01148, 0x07c01188, 0x06803548, 0x07c011c8, 0x0aa2c007,
-	0x06801089, 0x0c011e80, 0x080c2301, 0x0c011f00, 0x00000000,
-	0x07000248, 0x020081c8, 0x07400248, 0x0bae51c9, 0x04001249,
-	0x07801088, 0x078010c9, 0x09609209, 0x060e1908, 0x07801108,
-	0x07801149, 0x09609209, 0x060e1a08, 0x07801188, 0x078011c9,
-	0x09609209, 0x060e1b08, 0x0fc011c0, 0x07c043c7, 0x0aa0c007,
-	0x06800007, 0x0687ffc7, 0x07c01c07, 0x064c510a, 0x064c4607,
-	0x07801308, 0x05410208, 0x078012c9, 0x02008248, 0x05802208,
-	0x0e000288, 0x00000000, 0x00000000, 0x00000000, 0x0f000200,
-	0x0f010280, 0x0970820a, 0x05402208, 0x020081c8, 0x064c430a,
-	0x02408288, 0x064c400a, 0x02408288, 0x07c01348, 0x05810208,
-	0x07c01388, 0x0c013040, 0x00000000, 0x0680001e, 0x07c0001e,
-	0x07c016de, 0x0981d39e, 0x0981d3dd, 0x09c1d1dd, 0x07804087,
-	0x0400f1c7, 0x058041c7, 0x060c0907, 0x07c00987, 0x04401247,
-	0x07c00609, 0x09708789, 0x05404287, 0x078040c8, 0x0400f208,
-	0x05804208, 0x05404248, 0x04401249, 0x05402249, 0x07c009c8,
-	0x07804149, 0x0aa0c0c9, 0x04000248, 0x05801249, 0x07c01dc9,
-	0x04401248, 0x09608789, 0x04000248, 0x09610247, 0x06095209,
-	0x05404208, 0x0780408a, 0x0400f28a, 0x0580428a, 0x0540428a,
-	0x078040c8, 0x0400f208, 0x05804208, 0x05404208, 0x0961020a,
-	0x06090808, 0x0c005b00, 0x07c013da, 0x06a00007, 0x060c3d07,
-	0x064c3d08, 0x09161208, 0x0a6f8008, 0x06800008, 0x06c06c08,
-	0x0aa1009a, 0x02008c08, 0x0c780400, 0x060c3808, 0x05803208,
-	0x07804147, 0x0aa200c7, 0x06800109, 0x0aa18047, 0x06800009,
-	0x07801f87, 0x0aa0c007, 0x068000c9, 0x06800009, 0x097a3209,
-	0x060c3908, 0x06bfffc8, 0x060c3808, 0x0c00bdc0, 0x00000000,
-	0x0c00c100, 0x00000000, 0x0c00cf00, 0x00000000, 0x069898c8,
-	0x06d81848, 0x06800707, 0x0d000007, 0x060c2208, 0x07800387,
-	0x0aa10007, 0x06800007, 0x0c7f10c0, 0x07c00387, 0x0649c909,
-	0x0aa10009, 0x06800087, 0x0c7f0f80, 0x07c01507, 0x07801487,
-	0x0a608007, 0x0c780900, 0x044011c7, 0x0aa0c087, 0x07801549,
-	0x078015c9, 0x0ae7c0c9, 0x040301c9, 0x070001c7, 0x054101c7,
-	0x04034209, 0x07000208, 0x094101c8, 0x0609cb07, 0x040381c9,
-	0x070001c7, 0x07800fc8, 0x020081c8, 0x0609ca08, 0x07c00fd9,
-	0x040941c9, 0x070001c7, 0x054101c7, 0x04090209, 0x07000208,
-	0x094101c8, 0x0609cc07, 0x04029209, 0x04001249, 0x07000208,
-	0x09464248, 0x07801808, 0x094e1248, 0x0609c909, 0x08007401,
-	0x06800009, 0x07c01489, 0x06800009, 0x07c01509, 0x078014c7,
-	0x02c07247, 0x04000295, 0x0a238047, 0x06800008, 0x04000296,
-	0x0a22c087, 0x06800048, 0x04000297, 0x0a220107, 0x06800088,
-	0x04000298, 0x0a214207, 0x068000c8, 0x06800047, 0x0c7f0140,
-	0x07c01507, 0x07801607, 0x090041c7, 0x0a8051c8, 0x0aa2001a,
-	0x07801607, 0x090841c7, 0x0a4051c8, 0x06800047, 0x03407207,
-	0x0c7ff980, 0x02c091c9, 0x07801347, 0x04090248, 0x07400247,
-	0x07801387, 0x04004249, 0x07400247, 0x07804187, 0x054031c7,
-	0x02c07687, 0x04029248, 0x07400247, 0x040301c8, 0x07800f49,
-	0x074001c9, 0x040341c8, 0x07800f09, 0x0a60c05a, 0x074001c9,
-	0x040006c8, 0x0a62009a, 0x040381c8, 0x074001d9, 0x07000709,
-	0x0aa1c009, 0x04401249, 0x0c780140, 0x07400709, 0x07800f89,
-	0x074001c9, 0x04000707, 0x07c00f99, 0x06800047, 0x03407207,
-	0x078014c9, 0x02c091c9, 0x07c014c9, 0x0609b20a, 0x0609b00a,
-	0x0609b10a, 0x068000c9, 0x0400125a, 0x07c01489, 0x0a60809a,
-	0x0c780340, 0x07801587, 0x07c015c7, 0x07c01588, 0x04000185,
-	0x04000144, 0x07801609, 0x05404249, 0x09404248, 0x07c01609,
-	0x0400010a, 0x0c7800c0, 0x00000000, 0x07c01548, 0x0649c108,
-	0x0aa2c008, 0x07800187, 0x0b61c087, 0x06800048, 0x0aa1c09a,
-	0x0aa0801a, 0x0aa14007, 0x040011c7, 0x07c00187, 0x0c780180,
-	0x07c001c8, 0x06800008, 0x07c001c8, 0x0c782280, 0x00000000,
-	0x0aa0c01a, 0x06801aec, 0x068057ac, 0x0c0049c0, 0x00000000,
-	0x0c008ac0, 0x00000000, 0x0c015b80, 0x00000000, 0x0c004e00,
-	0x00000000, 0x0c781f40, 0x00000000, 0x0c781ec0, 0x00000000,
-	0x078001c7, 0x0aaf4007, 0x00000000, 0x0400024a, 0x07800107,
-	0x0b4031c9, 0x0c781cc0, 0x00000000, 0x07c00109, 0x078040c7,
-	0x0682bc08, 0x0b004207, 0x00000000, 0x0fc031c0, 0x094e3247,
-	0x07c00349, 0x07804148, 0x0aa200c8, 0x07801dc8, 0x0b806209,
-	0x00000000, 0x07800307, 0x0a608007, 0x0c781880, 0x02409209,
-	0x078016c8, 0x0a805209, 0x07c016c9, 0x0680001e, 0x07c0001e,
-	0x09408789, 0x0981d39d, 0x0981d3dd, 0x09c1d1dd, 0x0c003e40,
-	0x00000000, 0x0c007f40, 0x00000000, 0x0c015000, 0x00000000,
-	0x0c004280, 0x00000000, 0x07804208, 0x0a610008, 0x07804247,
-	0x0fc01200, 0x0fc061c0, 0x07c00207, 0x094e11c8, 0x060c0a07,
-	0x0a61001a, 0x06800007, 0x0c7808c0, 0x07c01e07, 0x0fc011c0,
-	0x07c01e07, 0x08094200, 0x0a60c007, 0x0c780740, 0x00000000,
-	0x06815448, 0x06094208, 0x0680c008, 0x06094008, 0x07800087,
-	0x0aa18087, 0x06800047, 0x07804147, 0x0aa0c0c7, 0x06800087,
-	0x06800107, 0x0fc08200, 0x0fc08240, 0x09509248, 0x06094109,
-	0x0fc01200, 0x0fc08200, 0x0fc08240, 0x09509248, 0x06094109,
-	0x06094109, 0x0fc01200, 0x0aed4047, 0x044011c7, 0x0fc01200,
-	0x07c00048, 0x08094000, 0x078043c7, 0x0a60c007, 0x0c780540,
-	0x00000000, 0x0fc071c0, 0x080c2940, 0x07800207, 0x07804208,
-	0x094e11c8, 0x09807187, 0x098073c7, 0x060c0a07, 0x09c073c7,
-	0x09807387, 0x060c0a07, 0x0c009700, 0x080c0600, 0x064c0a07,
-	0x091c21c7, 0x0a6f8007, 0x00000000, 0x0c780100, 0x00000000,
-	0x0c009500, 0x080c0600, 0x07801e07, 0x0aa14007, 0x07800048,
-	0x094211c8, 0x05001208, 0x094411c8, 0x060c1807, 0x0cb8002c,
-	0x00000000, 0x064c0007, 0x0a2fc047, 0x00000000, 0x064c3a07,
-	0x090061c7, 0x0aaec647, 0x00000000, 0x080c0a00, 0x080c2300,
-	0x064c1e07, 0x09807547, 0x060c1e07, 0x080c2800, 0x080c0002,
-	0x0c7ec640, 0x00000000, 0x0649c015, 0x0649c116, 0x0649c217,
-	0x0649c318, 0x0809c000, 0x0809c100, 0x0809c200, 0x0809c300,
-	0x06804004, 0x06814105, 0x06824206, 0x0c000a40, 0x00000000,
-	0x08002501, 0x08002605, 0x08002708, 0x0800290d, 0x08002815,
-	0x08002c14, 0x06800000, 0x07c01c00, 0x0cc00000, 0x00000000,
-	0x06800007, 0x07c01907, 0x07c01987, 0x07c019c7, 0x07800607,
-	0x040011c7, 0x07c01887, 0x06800047, 0x060e0c07, 0x07c01a87,
-	0x07c018c7, 0x068003c7, 0x07c00147, 0x06805c07, 0x060c2107,
-	0x080c2170, 0x06800087, 0x07c01ac7, 0x0680001f, 0x07804148,
-	0x05406208, 0x0940321a, 0x07800387, 0x09461207, 0x060c0408,
-	0x06868008, 0x07c01a48, 0x0cc00000, 0x00000000, 0x0649cf30,
-	0x064c4002, 0x064c4203, 0x02403083, 0x040080c3, 0x07c012c3,
-	0x058100c3, 0x07c01303, 0x06800019, 0x07c01499, 0x07c014d9,
-	0x07c01519, 0x064c0919, 0x0680001a, 0x07c0019a, 0x07c001da,
-	0x068000c2, 0x07c04142, 0x06803fc2, 0x07c01542, 0x07c01582,
-	0x07c015c2, 0x07c01602, 0x060c0919, 0x060c1a19, 0x06932002,
-	0x060c1e02, 0x06800002, 0x060c0c02, 0x06c04042, 0x060c0d02,
-	0x0cc00000, 0x00000000, 0x0649c803, 0x0aa14003, 0x078014c2,
-	0x028020c2, 0x07c014c2, 0x0809c800, 0x07801502, 0x0aa0c002,
-	0x06800102, 0x06030502, 0x064c0003, 0x0a2100c3, 0x06800002,
-	0x0c7809c0, 0x00000000, 0x064c3a03, 0x090060c3, 0x0a60cac3,
-	0x0c780880, 0x00000000, 0x07804143, 0x0aa080c3, 0x0c780780,
-	0x064c4403, 0x091210c3, 0x0aa6c003, 0x068fffc3, 0x07801fc2,
-	0x04001082, 0x0b8190c2, 0x07c01fc2, 0x06800002, 0x07c01fc2,
-	0x07800402, 0x04001082, 0x0b8130c2, 0x07c00402, 0x064c0003,
-	0x09803203, 0x09803183, 0x09803003, 0x060c0003, 0x06800002,
-	0x064c1803, 0x095860c2, 0x09803483, 0x060c1803, 0x09c03483,
-	0x060c1803, 0x06800103, 0x06030503, 0x06800002, 0x07c01fc2,
-	0x07c00402, 0x0cc00000, 0x00000000, 0x064c442e, 0x09121bae,
-	0x0aaf802e, 0x0c7ea140, 0x00000000, 0x0c004ac0, 0x00000000,
-	0x06818109, 0x06c34749, 0x06090709, 0x06490b09, 0x09809009,
-	0x098090c9, 0x06090b09, 0x09c09009, 0x09c090c9, 0x0962225a,
-	0x06090b09, 0x06800009, 0x06c07489, 0x02009c09, 0x06094409,
-	0x06880009, 0x06c07489, 0x02009c09, 0x06094509, 0x0cc00000,
-	0x00000000, 0x07804149, 0x0a60c0c9, 0x0cc00000, 0x00000000,
-	0x06490707, 0x09807087, 0x098070c7, 0x06090707, 0x06495107,
-	0x098073c7, 0x0cc00000, 0x06095107, 0x0cc00000, 0x00400000,
-	0x064e1210, 0x091e1410, 0x0bef0050, 0x00000000, 0x0649d910,
-	0x0900c410, 0x0aef8190, 0x07801850, 0x0aa3c090, 0x0c7821c0,
-	0x06800011, 0x06c04011, 0x060e1211, 0x078016d1, 0x0a20c051,
-	0x0680001f, 0x0688001f, 0x06c0749f, 0x0201fc1f, 0x06800010,
-	0x07c01b10, 0x0c7813c0, 0x06800110, 0x07801b11, 0x0aa08091,
-	0x0c780f00, 0x07801892, 0x0aebc092, 0x0aa3c72f, 0x07801b50,
-	0x05406410, 0x078016d1, 0x05801451, 0x0be0c051, 0x06800011,
-	0x06880011, 0x06c07491, 0x02011c11, 0x02010450, 0x04440410,
-	0x060e1310, 0x0c780340, 0x040c07d0, 0x05405410, 0x078016d1,
+	0x07c01e87, 0x07800a87, 0x091c1207, 0x0a610008, 0x048ff1c7,
+	0x054011c7, 0x048ff1c7, 0x0c780b40, 0x07c01ec7, 0x07800a07,
+	0x091c1207, 0x0aa2c008, 0x048ff1c7, 0x058011c7, 0x07801f08,
+	0x0b4031c8, 0x06804009, 0x02008248, 0x024091c8, 0x0ba0e009,
+	0x0c7fff80, 0x040801c7, 0x07c01e47, 0x07800a47, 0x091c1207,
+	0x0aa2c008, 0x048ff1c7, 0x058011c7, 0x07801f08, 0x0b4031c8,
+	0x06804009, 0x02008248, 0x024091c8, 0x0ba0e009, 0x0c7fff80,
+	0x040801c7, 0x07c01e87, 0x07800a87, 0x091c1207, 0x0aa2c008,
+	0x048ff1c7, 0x058011c7, 0x07801f08, 0x0b0031c8, 0x06804009,
+	0x02408248, 0x02409207, 0x0ba0e009, 0x0c7fff80, 0x044801c7,
+	0x048ff1c7, 0x07c01ec7, 0x0a61409a, 0x07804147, 0x0a60c0c7,
+	0x0c780240, 0x06800808, 0x0fc011c0, 0x07c00087, 0x0a6f0007,
+	0x06800808, 0x06800047, 0x09505207, 0x09605207, 0x060c2108,
+	0x0fc011c0, 0x0fc011c0, 0x07c01f87, 0x0fc021c0, 0x0fc011c0,
+	0x07c04287, 0x0fc011c0, 0x07c042c7, 0x0a648007, 0x06800008,
+	0x0fc011c0, 0x0aa34007, 0x06800009, 0x0c0133c0, 0x080c2301,
+	0x0c013440, 0x00000000, 0x07c04307, 0x0c013280, 0x080c2301,
+	0x0c013300, 0x00000000, 0x0c780100, 0x07c04347, 0x07c04308,
+	0x07c04349, 0x06800007, 0x07c00107, 0x07804007, 0x0aa25207,
+	0x00000000, 0x06802007, 0x06c02007, 0x060e1907, 0x060e1a07,
+	0x060e1b07, 0x0c781640, 0x00000000, 0x0fc011c0, 0x064e1c09,
+	0x097e1247, 0x0aa20047, 0x060e1c09, 0x06802007, 0x06c02007,
+	0x060e1907, 0x060e1a07, 0x0c781200, 0x060e1b07, 0x0fc011c0,
+	0x0fc011c0, 0x06800009, 0x07c01109, 0x0a630007, 0x07c01149,
+	0x0c012940, 0x080c2301, 0x0c0129c0, 0x00000000, 0x07c01107,
+	0x0c012800, 0x080c2301, 0x0c012880, 0x00000000, 0x07c01147,
+	0x0fc021c0, 0x0fc02200, 0x064e1c09, 0x09602248, 0x07801108,
+	0x09405248, 0x07801148, 0x09505248, 0x060e1c09, 0x0aa30047,
+	0x06802008, 0x07c01188, 0x06801888, 0x07c011c8, 0x06801a88,
+	0x07c01208, 0x06801d08, 0x07c01248, 0x07c01288, 0x0c7802c0,
+	0x06802008, 0x068021c8, 0x07c01188, 0x068023c8, 0x07c011c8,
+	0x07c01208, 0x06802808, 0x07c01248, 0x07c01288, 0x06803548,
+	0x07c012c8, 0x0aa2c007, 0x06801189, 0x0c011e80, 0x080c2301,
+	0x0c011f00, 0x00000000, 0x07000248, 0x020081c8, 0x07400248,
+	0x0bae52c9, 0x04001249, 0x07801188, 0x078011c9, 0x09609209,
+	0x060e1908, 0x07801208, 0x07801249, 0x09609209, 0x060e1a08,
+	0x07801288, 0x078012c9, 0x09609209, 0x060e1b08, 0x0fc011c0,
+	0x07c043c7, 0x0aa0c007, 0x06800007, 0x0687ffc7, 0x07c01c07,
+	0x064c510a, 0x064c4607, 0x07800888, 0x05410208, 0x07800849,
+	0x02008248, 0x05802208, 0x0e000288, 0x00000000, 0x00000000,
+	0x00000000, 0x0f000200, 0x0f010280, 0x0970820a, 0x05402208,
+	0x020081c8, 0x064c430a, 0x02408288, 0x064c400a, 0x02408288,
+	0x07c008c8, 0x05810208, 0x07c00908, 0x0c013040, 0x00000000,
+	0x0680001e, 0x07c0001e, 0x07c016de, 0x0981d39e, 0x0981d3dd,
+	0x09c1d1dd, 0x07804087, 0x0400f1c7, 0x058041c7, 0x060c0907,
+	0x07c00987, 0x04401247, 0x07c00609, 0x09708789, 0x05404287,
+	0x078040c8, 0x0400f208, 0x05804208, 0x05404248, 0x04401249,
+	0x05402249, 0x07c009c8, 0x07804149, 0x0aa0c0c9, 0x04000248,
+	0x05801249, 0x07c01dc9, 0x04401248, 0x09608789, 0x04000248,
+	0x09610247, 0x06095209, 0x05404208, 0x0780408a, 0x0400f28a,
+	0x0580428a, 0x0540428a, 0x078040c8, 0x0400f208, 0x05804208,
+	0x05404208, 0x0961020a, 0x06090808, 0x0c005b00, 0x07c0095a,
+	0x06a00007, 0x060c3d07, 0x064c3d08, 0x09161208, 0x0a6f8008,
+	0x06800008, 0x06c06c08, 0x0aa1009a, 0x02008c08, 0x0c780400,
+	0x060c3808, 0x05803208, 0x07804147, 0x0aa200c7, 0x06800109,
+	0x0aa18047, 0x06800009, 0x07801f87, 0x0aa0c007, 0x068000c9,
+	0x06800009, 0x097a3209, 0x060c3908, 0x06bfffc8, 0x060c3808,
+	0x0c00bdc0, 0x00000000, 0x0c00c100, 0x00000000, 0x0c00cf00,
+	0x00000000, 0x069898c8, 0x06d81848, 0x06800707, 0x0d000007,
+	0x060c2208, 0x07800387, 0x0aa10007, 0x06800007, 0x0c7f1040,
+	0x07c00387, 0x0649c909, 0x0aa10009, 0x06800087, 0x0c7f0f00,
+	0x07c01507, 0x07801487, 0x0a608007, 0x0c780900, 0x044011c7,
+	0x0aa0c087, 0x07801549, 0x078015c9, 0x0ae7c0c9, 0x040801c9,
+	0x070001c7, 0x054101c7, 0x040a0209, 0x07000208, 0x094101c8,
+	0x0609cb07, 0x040b01c9, 0x070001c7, 0x078010c8, 0x020081c8,
+	0x0609ca08, 0x07c010d9, 0x040d01c9, 0x070001c7, 0x054101c7,
+	0x040c0209, 0x07000208, 0x094101c8, 0x0609cc07, 0x04090209,
+	0x04001249, 0x07000208, 0x09464248, 0x07801808, 0x094e1248,
+	0x0609c909, 0x08007401, 0x06800009, 0x07c01489, 0x06800009,
+	0x07c01509, 0x078014c7, 0x02c07247, 0x04000295, 0x0a238047,
+	0x06800008, 0x04000296, 0x0a22c087, 0x06800048, 0x04000297,
+	0x0a220107, 0x06800088, 0x04000298, 0x0a214207, 0x068000c8,
+	0x06800047, 0x0c7f00c0, 0x07c01507, 0x07801607, 0x090041c7,
+	0x0a8051c8, 0x0aa2001a, 0x07801607, 0x090841c7, 0x0a4051c8,
+	0x06800047, 0x03407207, 0x0c7ff980, 0x02c091c9, 0x078008c7,
+	0x040c0248, 0x07400247, 0x07800907, 0x04010249, 0x07400247,
+	0x07804187, 0x054031c7, 0x02c07687, 0x04090248, 0x07400247,
+	0x040801c8, 0x07801049, 0x074001c9, 0x040a01c8, 0x07801009,
+	0x0a60c05a, 0x074001c9, 0x040006c8, 0x0a62009a, 0x040b01c8,
+	0x074001d9, 0x07000709, 0x0aa1c009, 0x04401249, 0x0c780140,
+	0x07400709, 0x07801089, 0x074001c9, 0x04000707, 0x07c01099,
+	0x06800047, 0x03407207, 0x078014c9, 0x02c091c9, 0x07c014c9,
+	0x0609b20a, 0x0609b00a, 0x0609b10a, 0x068000c9, 0x0400125a,
+	0x07c01489, 0x0a60809a, 0x0c780340, 0x07801587, 0x07c015c7,
+	0x07c01588, 0x04000185, 0x04000144, 0x07801609, 0x05404249,
+	0x09404248, 0x07c01609, 0x0400010a, 0x0c7800c0, 0x00000000,
+	0x07c01548, 0x0649c108, 0x0aa2c008, 0x07800187, 0x0b61c087,
+	0x06800048, 0x0aa1c09a, 0x0aa0801a, 0x0aa14007, 0x040011c7,
+	0x07c00187, 0x0c780180, 0x07c001c8, 0x06800008, 0x07c001c8,
+	0x0c782280, 0x00000000, 0x0aa0c01a, 0x06801aed, 0x068057ad,
+	0x0c0049c0, 0x00000000, 0x0c008ac0, 0x00000000, 0x0c015b80,
+	0x00000000, 0x0c004e00, 0x00000000, 0x0c781f40, 0x00000000,
+	0x0c781ec0, 0x00000000, 0x078001c7, 0x0a608007, 0x0c7fff00,
+	0x0400024a, 0x07800107, 0x0b4031c9, 0x0c781cc0, 0x00000000,
+	0x07c00109, 0x078040c7, 0x0682bc08, 0x0b004207, 0x00000000,
+	0x0fc031c0, 0x094e3247, 0x07c00349, 0x07804148, 0x0aa200c8,
+	0x07801dc8, 0x0b806209, 0x00000000, 0x07800307, 0x0a608007,
+	0x0c781880, 0x02409209, 0x078016c8, 0x0a805209, 0x07c016c9,
+	0x0680001e, 0x07c0001e, 0x09408789, 0x0981d39d, 0x0981d3dd,
+	0x09c1d1dd, 0x0c003e40, 0x00000000, 0x0c007f40, 0x00000000,
+	0x0c015000, 0x00000000, 0x0c004280, 0x00000000, 0x07804208,
+	0x0a610008, 0x07804247, 0x0fc01200, 0x0fc061c0, 0x07c00207,
+	0x094e11c8, 0x060c0a07, 0x0a61001a, 0x06800007, 0x0c7808c0,
+	0x07c01e07, 0x0fc011c0, 0x07c01e07, 0x08094200, 0x0a60c007,
+	0x0c780740, 0x00000000, 0x06815448, 0x06094208, 0x0680c008,
+	0x06094008, 0x07800087, 0x0aa18087, 0x06800047, 0x07804147,
+	0x0aa0c0c7, 0x06800087, 0x06800107, 0x0fc08200, 0x0fc08240,
+	0x09509248, 0x06094109, 0x0fc01200, 0x0fc08200, 0x0fc08240,
+	0x09509248, 0x06094109, 0x06094109, 0x0fc01200, 0x0aed4047,
+	0x044011c7, 0x0fc01200, 0x07c00048, 0x08094000, 0x078043c7,
+	0x0a60c007, 0x0c780540, 0x00000000, 0x0fc071c0, 0x080c2940,
+	0x07800207, 0x07804208, 0x094e11c8, 0x09807187, 0x098073c7,
+	0x060c0a07, 0x09c073c7, 0x09807387, 0x060c0a07, 0x0c009700,
+	0x080c0600, 0x064c0a07, 0x091c21c7, 0x0a6f8007, 0x00000000,
+	0x0c780100, 0x00000000, 0x0c009500, 0x080c0600, 0x07801e07,
+	0x0aa14007, 0x07800048, 0x094211c8, 0x05001208, 0x094411c8,
+	0x060c1807, 0x0cb8002d, 0x00000000, 0x064c0007, 0x0a2fc047,
+	0x00000000, 0x064c3a07, 0x090061c7, 0x0aaec647, 0x00000000,
+	0x080c0a00, 0x080c2300, 0x064c1e07, 0x09807547, 0x060c1e07,
+	0x080c2800, 0x080c0002, 0x0c7ec5c0, 0x00000000, 0x0649c015,
+	0x0649c116, 0x0649c217, 0x0649c318, 0x0809c000, 0x0809c100,
+	0x0809c200, 0x0809c300, 0x06804004, 0x0680c085, 0x06814106,
+	0x0c000a40, 0x00000000, 0x08002501, 0x08002605, 0x08002708,
+	0x0800290d, 0x08002815, 0x08002c14, 0x06800000, 0x07c01c00,
+	0x0cc00000, 0x00000000, 0x06800007, 0x07c01907, 0x07c01987,
+	0x07c019c7, 0x07800607, 0x040011c7, 0x07c01887, 0x06800047,
+	0x060e0c07, 0x07c01a87, 0x07c018c7, 0x068003c7, 0x07c00147,
+	0x06805c07, 0x060c2107, 0x080c2170, 0x06800087, 0x07c01ac7,
+	0x0680001f, 0x07804148, 0x05406208, 0x0940321a, 0x07800387,
+	0x09461207, 0x060c0408, 0x06868008, 0x07c01a48, 0x0cc00000,
+	0x00000000, 0x0649cf30, 0x064c4002, 0x064c4203, 0x02403083,
+	0x040080c3, 0x07c00843, 0x058100c3, 0x07c00883, 0x06800019,
+	0x07c01499, 0x07c014d9, 0x07c01519, 0x064c0919, 0x0680001a,
+	0x07c0019a, 0x07c001da, 0x068000c2, 0x07c04142, 0x06803fc2,
+	0x07c01542, 0x07c01582, 0x07c015c2, 0x07c01602, 0x060c0919,
+	0x060c1a19, 0x06932002, 0x060c1e02, 0x06800002, 0x060c0c02,
+	0x06c04042, 0x060c0d02, 0x0cc00000, 0x00000000, 0x0649c803,
+	0x0aa14003, 0x078014c2, 0x028020c2, 0x07c014c2, 0x0809c800,
+	0x07801502, 0x0aa0c002, 0x06800102, 0x06030502, 0x064c0003,
+	0x0a2100c3, 0x06800002, 0x0c7809c0, 0x00000000, 0x064c3a03,
+	0x090060c3, 0x0a60cac3, 0x0c780880, 0x00000000, 0x07804143,
+	0x0aa080c3, 0x0c780780, 0x064c4403, 0x091210c3, 0x0aa6c003,
+	0x068fffc3, 0x07801fc2, 0x04001082, 0x0b8190c2, 0x07c01fc2,
+	0x06800002, 0x07c01fc2, 0x07800402, 0x04001082, 0x0b8130c2,
+	0x07c00402, 0x064c0003, 0x09803203, 0x09803183, 0x09803003,
+	0x060c0003, 0x06800002, 0x064c1803, 0x095860c2, 0x09803483,
+	0x060c1803, 0x09c03483, 0x060c1803, 0x06800103, 0x06030503,
+	0x06800002, 0x07c01fc2, 0x07c00402, 0x0cc00000, 0x00000000,
+	0x064c442e, 0x09121bae, 0x0aaf802e, 0x0c7ea0c0, 0x00000000,
+	0x0c004ac0, 0x00000000, 0x06818109, 0x06c34749, 0x06090709,
+	0x06490b09, 0x09809009, 0x098090c9, 0x06090b09, 0x09c09009,
+	0x09c090c9, 0x0962225a, 0x06090b09, 0x06800009, 0x06c07489,
+	0x02009c09, 0x06094409, 0x06880009, 0x06c07489, 0x02009c09,
+	0x06094509, 0x0cc00000, 0x00000000, 0x07804149, 0x0a60c0c9,
+	0x0cc00000, 0x00000000, 0x06490707, 0x09807087, 0x098070c7,
+	0x06090707, 0x06495107, 0x098073c7, 0x0cc00000, 0x06095107,
+	0x0cc00000, 0x00400000, 0x064e1210, 0x091e1410, 0x0bef0050,
+	0x00000000, 0x0649d910, 0x0900c410, 0x0aef8190, 0x07801850,
+	0x0aa3c090, 0x0c7821c0, 0x06800011, 0x06c04011, 0x060e1211,
+	0x078016d1, 0x0a20c051, 0x0680001f, 0x0688001f, 0x06c0749f,
+	0x0201fc1f, 0x06800010, 0x07c01b10, 0x0c7813c0, 0x06800110,
+	0x07801b11, 0x0aa08091, 0x0c780f00, 0x07801892, 0x0aebc092,
+	0x0aa3c72f, 0x07801b50, 0x05406410, 0x078016d1, 0x05801451,
 	0x0be0c051, 0x06800011, 0x06880011, 0x06c07491, 0x02011c11,
-	0x02010450, 0x04420410, 0x060e1310, 0x040607d0, 0x07801952,
-	0x0aa14012, 0x06a2c211, 0x0aa0c052, 0x06a2c011, 0x06a2c111,
-	0x06c04011, 0x060e1211, 0x06800010, 0x07c01b10, 0x06800110,
-	0x0c7816c0, 0x07c01850, 0x07801991, 0x06800192, 0x02411491,
-	0x02411491, 0x02411491, 0x07801a50, 0x05409410, 0x02010450,
-	0x05403450, 0x02011c11, 0x060e1311, 0x07801952, 0x0aa34012,
-	0x06a44211, 0x0aa2c052, 0x06a44011, 0x0c780240, 0x06a44111,
-	0x0a63c0d1, 0x07801a90, 0x064e0c12, 0x09010492, 0x0b8ea490,
-	0x0cc00000, 0x00400000, 0x06c0c011, 0x060e1211, 0x0680001f,
-	0x06800010, 0x07c01b10, 0x06800150, 0x0c780e80, 0x07c01850,
-	0x078018d1, 0x0aa1c011, 0x04401451, 0x07c018d1, 0x07801891,
-	0x04401451, 0x0c780b00, 0x07c01891, 0x078019d1, 0x07c01a11,
+	0x02010450, 0x04440410, 0x060e1310, 0x0c780340, 0x040c07d0,
+	0x05405410, 0x078016d1, 0x0be0c051, 0x06800011, 0x06880011,
+	0x06c07491, 0x02011c11, 0x02010450, 0x04420410, 0x060e1310,
+	0x040607d0, 0x07801952, 0x0aa14012, 0x06a2c211, 0x0aa0c052,
+	0x06a2c011, 0x06a2c111, 0x06c04011, 0x060e1211, 0x06800010,
+	0x07c01b10, 0x06800110, 0x0c7816c0, 0x07c01850, 0x07801991,
+	0x06800192, 0x02411491, 0x02411491, 0x02411491, 0x07801a50,
+	0x05409410, 0x02010450, 0x05403450, 0x02011c11, 0x060e1311,
+	0x07801952, 0x0aa34012, 0x06a44211, 0x0aa2c052, 0x06a44011,
+	0x0c780240, 0x06a44111, 0x0a63c0d1, 0x07801a90, 0x064e0c12,
+	0x09010492, 0x0b8ea490, 0x0cc00000, 0x00400000, 0x06c0c011,
+	0x060e1211, 0x0680001f, 0x06800010, 0x07c01b10, 0x06800150,
+	0x0c780e80, 0x07c01850, 0x078018d1, 0x0aa1c011, 0x04401451,
+	0x07c018d1, 0x07801891, 0x04401451, 0x0c780b00, 0x07c01891,
+	0x078019d1, 0x07c01a11, 0x07801a50, 0x05409410, 0x02010450,
+	0x06800192, 0x02011491, 0x07c019d1, 0x05403450, 0x02011c11,
+	0x060e1311, 0x07801952, 0x0aa14012, 0x06a16211, 0x0aa0c052,
+	0x06a16011, 0x06a16111, 0x07801bd2, 0x0aa28012, 0x07801a90,
+	0x064e0c12, 0x09010492, 0x0b804490, 0x07801a12, 0x0c7fde80,
+	0x07c019d2, 0x04001410, 0x07c01a90, 0x07c01d91, 0x06c00011,
+	0x060e1211, 0x06800050, 0x0c780400, 0x07c01850, 0x0ba30110,
+	0x0c7ff540, 0x0a6f8050, 0x07801891, 0x0aa74011, 0x04401451,
+	0x0b26c051, 0x07c01891, 0x07801ad0, 0x0aa0c0d0, 0x00000000,
+	0x080c2170, 0x06800010, 0x07c01850, 0x0cc00000, 0x00400000,
+	0x0aa0c010, 0x0688001f, 0x0680001f, 0x06c0749f, 0x0c780a40,
+	0x0201fc1f, 0x0aa0c72f, 0x090a841f, 0x090c741f, 0x07800992,
+	0x0b823490, 0x0a8f5490, 0x091a141f, 0x0aa20010, 0x0688001f,
+	0x0c780180, 0x0680001f, 0x0aa7001f, 0x07801991, 0x0c7ffcc0,
+	0x00000000, 0x06c0749f, 0x0201fc1f, 0x07801a50, 0x05409410,
+	0x06800192, 0x02411491, 0x02010450, 0x05403450, 0x02011c11,
+	0x060e1311, 0x07801d90, 0x09004450, 0x0aa14011, 0x06a14210,
+	0x0aa0c111, 0x06a14010, 0x06a14110, 0x06c08010, 0x060e0d1f,
+	0x0aa0c72f, 0x040207df, 0x040207df, 0x0c7ff4c0, 0x060e1210,
 	0x07801a50, 0x05409410, 0x02010450, 0x06800192, 0x02011491,
-	0x07c019d1, 0x05403450, 0x02011c11, 0x060e1311, 0x07801952,
-	0x0aa14012, 0x06a16211, 0x0aa0c052, 0x06a16011, 0x06a16111,
-	0x07801bd2, 0x0aa28012, 0x07801a90, 0x064e0c12, 0x09010492,
-	0x0b804490, 0x07801a12, 0x0c7fde80, 0x07c019d2, 0x04001410,
-	0x07c01a90, 0x07c01d91, 0x06c00011, 0x060e1211, 0x06800050,
-	0x0c780400, 0x07c01850, 0x0ba30110, 0x0c7ff540, 0x0a6f8050,
-	0x07801891, 0x0aa74011, 0x04401451, 0x0b26c051, 0x07c01891,
-	0x07801ad0, 0x0aa0c0d0, 0x00000000, 0x080c2170, 0x06800010,
-	0x07c01850, 0x0cc00000, 0x00400000, 0x0aa0c010, 0x0688001f,
-	0x0680001f, 0x06c0749f, 0x0c780a40, 0x0201fc1f, 0x0aa0c72f,
-	0x090a841f, 0x090c741f, 0x07800992, 0x0b823490, 0x0a8f5490,
-	0x091a141f, 0x0aa20010, 0x0688001f, 0x0c780180, 0x0680001f,
-	0x0aa7001f, 0x07801991, 0x0c7ffcc0, 0x00000000, 0x06c0749f,
-	0x0201fc1f, 0x07801a50, 0x05409410, 0x06800192, 0x02411491,
-	0x02010450, 0x05403450, 0x02011c11, 0x060e1311, 0x07801d90,
-	0x09004450, 0x0aa14011, 0x06a14210, 0x0aa0c111, 0x06a14010,
-	0x06a14110, 0x06c08010, 0x060e0d1f, 0x0aa0c72f, 0x040207df,
-	0x040207df, 0x0c7ff4c0, 0x060e1210, 0x07801a50, 0x05409410,
-	0x02010450, 0x06800192, 0x02011491, 0x07c01991, 0x05403450,
-	0x02011c11, 0x060e1311, 0x07801d90, 0x0a61801f, 0x09c101d0,
-	0x060e1210, 0x068000d0, 0x0c7ff0c0, 0x07c01850, 0x06c08010,
-	0x060e0d1f, 0x0aae872f, 0x040207df, 0x0c7ffe00, 0x040207df,
-	0x0c000d00, 0x00000000, 0x08095007, 0x08095000, 0x07804347,
-	0x07804308, 0x094a51c8, 0x078042c8, 0x095411c8, 0x06096e07,
-	0x0aa0c008, 0x06800088, 0x06800048, 0x060c3108, 0x06800048,
-	0x0780098a, 0x068002c9, 0x0b00324a, 0x00000000, 0x06800008,
-	0x06498e0a, 0x097c1288, 0x06098e0a, 0x06497f08, 0x068000ca,
-	0x0970220a, 0x06097f08, 0x06820988, 0x06c00208, 0x0968221a,
-	0x0780098a, 0x0b20c2ca, 0x068004ca, 0x06800c0a, 0x0970620a,
-	0x0cc00000, 0x06095108, 0x0683ffc8, 0x06490909, 0x0a210049,
-	0x0aa0c008, 0x0c7fff40, 0x04401208, 0x06490b09, 0x09809009,
-	0x098090c9, 0x06090b09, 0x09c09009, 0x09c090c9, 0x06090b09,
-	0x0cc00000, 0x00000000, 0x0683ffc9, 0x0649bb08, 0x0920c208,
-	0x0649530a, 0x0900128a, 0x02008288, 0x0aa10008, 0x0aa0c009,
-	0x0c7ffe40, 0x04401249, 0x0cc00000, 0x00000000, 0x064e1209,
-	0x091e1249, 0x0bef8049, 0x064e0009, 0x064e0e0b, 0x064e0c0c,
-	0x083f0040, 0x083f0000, 0x0680020d, 0x0d00000d, 0x00000000,
-	0x060e0009, 0x060e0e0b, 0x0cc00000, 0x060e0c0c, 0x0c07fc40,
-	0x00000000, 0x06490b09, 0x09809009, 0x09809089, 0x06090b09,
-	0x09c09009, 0x09c09089, 0x06090b09, 0x08095007, 0x08095000,
-	0x0c000500, 0x00000000, 0x06800007, 0x07c00307, 0x06800007,
-	0x07c01907, 0x07c01987, 0x07c019c7, 0x07800607, 0x040011c7,
-	0x07c01887, 0x06800047, 0x060e0c07, 0x07c01a87, 0x07c018c7,
-	0x068003c7, 0x07c00147, 0x06800007, 0x0cc00000, 0x07c01847,
-	0x0683ffc9, 0x06498f0a, 0x0aa0c009, 0x0a6f800a, 0x04401249,
-	0x064c3d0a, 0x0580a28a, 0x0bef80ca, 0x00000000, 0x06498e0a,
-	0x0980a00a, 0x06800fc9, 0x09706289, 0x06098e0a, 0x06800009,
-	0x09706289, 0x09c0a00a, 0x0cc00000, 0x06098e0a, 0x064c3a08,
-	0x09006208, 0x064c0809, 0x064c090a, 0x064c1e0b, 0x064c380c,
-	0x06800407, 0x063f0007, 0x06800007, 0x063f0007, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x060c0809, 0x060c090a,
-	0x060c1e0b, 0x060c380c, 0x0c07ef00, 0x00000000, 0x06800009,
-	0x060c0c09, 0x06c04049, 0x060c0d09, 0x064c1809, 0x09586248,
-	0x09809489, 0x060c1809, 0x09c09489, 0x060c1809, 0x0cc00000,
-	0x080c0a01, 0x0680072f, 0x06bfffcb, 0x06800024, 0x07801c20,
-	0x06800021, 0x06800025, 0x06800022, 0x06800026, 0x06800023,
-	0x06800027, 0x0680800a, 0x0680070e, 0x0740028b, 0x0400128a,
-	0x074002a4, 0x0400128a, 0x074002a0, 0x0400128a, 0x074002a1,
-	0x0400128a, 0x074002a5, 0x0400128a, 0x074002a2, 0x0400128a,
-	0x074002a6, 0x0400128a, 0x074002a3, 0x0400128a, 0x074002a7,
-	0x0d07fbce, 0x0400128a, 0x07c01c4b, 0x096102cb, 0x080c0700,
-	0x060c270b, 0x09610824, 0x060c0220, 0x09610865, 0x0aa1801a,
-	0x060c0221, 0x096108a6, 0x060c0222, 0x096108e7, 0x060c0223,
-	0x0780098e, 0x0b009bce, 0x06b80007, 0x06c07487, 0x02007c07,
-	0x06035107, 0x06803f07, 0x06035207, 0x06a08007, 0x06035007,
-	0x07800007, 0x0a60c007, 0x06803fc7, 0x07c01c87, 0x06800007,
-	0x07c01d47, 0x0ac0bbce, 0x07801c87, 0x0b613fc7, 0x0ba0c707,
-	0x0441c1c7, 0x07c01c87, 0x06435007, 0x0580f1c7, 0x0bef8047,
-	0x0cc00000, 0x00000000, 0x06435007, 0x0580f1c7, 0x0bef8047,
-	0x00000000, 0x06435307, 0x0900c1c7, 0x0a6f8007, 0x00000000,
-	0x06b80007, 0x06c07487, 0x02007c07, 0x06035107, 0x06803f07,
-	0x06035207, 0x06b0c007, 0x06035007, 0x054011ef, 0x0ac051ce,
-	0x06800087, 0x07c01cc7, 0x0c7ff880, 0x07c01d07, 0x06b90008,
-	0x06c07488, 0x02008c08, 0x0540126f, 0x02009bc9, 0x0680008a,
-	0x07c01cca, 0x068000ca, 0x06435007, 0x0580f1c7, 0x0bef8047,
-	0x06803f07, 0x06035108, 0x06035207, 0x06a08007, 0x06035007,
-	0x0ac0324e, 0x0c7ff3c0, 0x07c01d0a, 0x06808007, 0x020081c8,
-	0x02009bc9, 0x0c7ffc80, 0x0400128a, 0x0400130c, 0x0480f30c,
-	0x07c01d0c, 0x0980b38b, 0x07801ccc, 0x0540928c, 0x0200a24a,
-	0x0400130c, 0x0480f30c, 0x07c01ccc, 0x0643500c, 0x0580f30c,
-	0x06c0748a, 0x0bef404c, 0x0200ac0a, 0x0643530c, 0x0900c30c,
-	0x0a6f800c, 0x00000000, 0x0603510a, 0x06803f0a, 0x0603520a,
-	0x0c7fedc0, 0x0603500b, 0x064c2307, 0x0befc047, 0x0cc00000,
-	0x064c2007, 0x040011c7, 0x06800008, 0x0a20c047, 0x058011c7,
-	0x024071c8, 0x0cc00000, 0x00000000, 0x02409247, 0x048ff249,
-	0x05401249, 0x02407207, 0x048ff1c7, 0x054011c7, 0x0680000a,
-	0x0680000b, 0x06800048, 0x0b8041c8, 0x054012cb, 0x0980b04b,
-	0x024081c8, 0x05401208, 0x0b2ec20a, 0x0400128a, 0x058012cb,
-	0x0e0002c9, 0x00000000, 0x00000000, 0x0cc00000, 0x0f000240,
-	0x02409247, 0x06807fca, 0x02809289, 0x02407207, 0x06807fca,
-	0x02807287, 0x0680000a, 0x0680000b, 0x06800048, 0x0b8041c8,
+	0x07c01991, 0x05403450, 0x02011c11, 0x060e1311, 0x07801d90,
+	0x0a61801f, 0x09c101d0, 0x060e1210, 0x068000d0, 0x0c7ff0c0,
+	0x07c01850, 0x06c08010, 0x060e0d1f, 0x0aae872f, 0x040207df,
+	0x0c7ffe00, 0x040207df, 0x0c000d00, 0x00000000, 0x08095007,
+	0x08095000, 0x07804347, 0x07804308, 0x094a51c8, 0x078042c8,
+	0x095411c8, 0x06096e07, 0x0aa0c008, 0x06800088, 0x06800048,
+	0x060c3108, 0x06800048, 0x0780098a, 0x068002c9, 0x0b00324a,
+	0x00000000, 0x06800008, 0x06498e0a, 0x097c1288, 0x06098e0a,
+	0x06497f08, 0x068000ca, 0x0970220a, 0x06097f08, 0x06820988,
+	0x06c00208, 0x0968221a, 0x0780098a, 0x0b20c2ca, 0x068004ca,
+	0x06800c0a, 0x0970620a, 0x0cc00000, 0x06095108, 0x0683ffc8,
+	0x06490909, 0x0a210049, 0x0aa0c008, 0x0c7fff40, 0x04401208,
+	0x06490b09, 0x09809009, 0x098090c9, 0x06090b09, 0x09c09009,
+	0x09c090c9, 0x06090b09, 0x0cc00000, 0x00000000, 0x0683ffc9,
+	0x0649bb08, 0x0920c208, 0x0649530a, 0x0900128a, 0x02008288,
+	0x0aa10008, 0x0aa0c009, 0x0c7ffe40, 0x04401249, 0x0cc00000,
+	0x00000000, 0x064e1209, 0x091e1249, 0x0bef8049, 0x064e0009,
+	0x064e0e0b, 0x064e0c0c, 0x083f0040, 0x083f0000, 0x0680020d,
+	0x0d00000d, 0x00000000, 0x060e0009, 0x060e0e0b, 0x0cc00000,
+	0x060e0c0c, 0x0c07fc40, 0x00000000, 0x06490b09, 0x09809009,
+	0x09809089, 0x06090b09, 0x09c09009, 0x09c09089, 0x06090b09,
+	0x08095007, 0x08095000, 0x0c000500, 0x00000000, 0x06800007,
+	0x07c00307, 0x06800007, 0x07c01907, 0x07c01987, 0x07c019c7,
+	0x07800607, 0x040011c7, 0x07c01887, 0x06800047, 0x060e0c07,
+	0x07c01a87, 0x07c018c7, 0x068003c7, 0x07c00147, 0x06800007,
+	0x0cc00000, 0x07c01847, 0x0683ffc9, 0x06498f0a, 0x0aa0c009,
+	0x0a6f800a, 0x04401249, 0x064c3d0a, 0x0580a28a, 0x0bef80ca,
+	0x00000000, 0x06498e0a, 0x0980a00a, 0x06800fc9, 0x09706289,
+	0x06098e0a, 0x06800009, 0x09706289, 0x09c0a00a, 0x0cc00000,
+	0x06098e0a, 0x064c3a08, 0x09006208, 0x064c0809, 0x064c090a,
+	0x064c1e0b, 0x064c380c, 0x06800407, 0x063f0007, 0x06800007,
+	0x063f0007, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x060c0809, 0x060c090a, 0x060c1e0b, 0x060c380c, 0x0c07ef00,
+	0x00000000, 0x06800009, 0x060c0c09, 0x06c04049, 0x060c0d09,
+	0x064c1809, 0x09586248, 0x09809489, 0x060c1809, 0x09c09489,
+	0x060c1809, 0x0cc00000, 0x080c0a01, 0x0680072f, 0x06bfffcb,
+	0x06800024, 0x07801c20, 0x06800021, 0x06800025, 0x06800022,
+	0x06800026, 0x06800023, 0x06800027, 0x0680800a, 0x0680070e,
+	0x0740028b, 0x0400128a, 0x074002a4, 0x0400128a, 0x074002a0,
+	0x0400128a, 0x074002a1, 0x0400128a, 0x074002a5, 0x0400128a,
+	0x074002a2, 0x0400128a, 0x074002a6, 0x0400128a, 0x074002a3,
+	0x0400128a, 0x074002a7, 0x0d07fbce, 0x0400128a, 0x07c01c4b,
+	0x096102cb, 0x080c0700, 0x060c270b, 0x09610824, 0x060c0220,
+	0x09610865, 0x0aa1801a, 0x060c0221, 0x096108a6, 0x060c0222,
+	0x096108e7, 0x060c0223, 0x0780098e, 0x0b009bce, 0x06b80007,
+	0x06c07487, 0x02007c07, 0x06035107, 0x06803f07, 0x06035207,
+	0x06a08007, 0x06035007, 0x07800007, 0x0a60c007, 0x06803fc7,
+	0x07c01c87, 0x06800007, 0x07c01d47, 0x0ac0bbce, 0x07801c87,
+	0x0b613fc7, 0x0ba0c707, 0x0441c1c7, 0x07c01c87, 0x06435007,
+	0x0580f1c7, 0x0bef8047, 0x0cc00000, 0x00000000, 0x06435007,
+	0x0580f1c7, 0x0bef8047, 0x00000000, 0x06435307, 0x0900c1c7,
+	0x0a6f8007, 0x00000000, 0x06b80007, 0x06c07487, 0x02007c07,
+	0x06035107, 0x06803f07, 0x06035207, 0x06b0c007, 0x06035007,
+	0x054011ef, 0x0ac051ce, 0x06800087, 0x07c01cc7, 0x0c7ff880,
+	0x07c01d07, 0x06b90008, 0x06c07488, 0x02008c08, 0x0540126f,
+	0x02009bc9, 0x0680008a, 0x07c01cca, 0x068000ca, 0x06435007,
+	0x0580f1c7, 0x0bef8047, 0x06803f07, 0x06035108, 0x06035207,
+	0x06a08007, 0x06035007, 0x0ac0324e, 0x0c7ff3c0, 0x07c01d0a,
+	0x06808007, 0x020081c8, 0x02009bc9, 0x0c7ffc80, 0x0400128a,
+	0x0400130c, 0x0480f30c, 0x07c01d0c, 0x0980b38b, 0x07801ccc,
+	0x0540928c, 0x0200a24a, 0x0400130c, 0x0480f30c, 0x07c01ccc,
+	0x0643500c, 0x0580f30c, 0x06c0748a, 0x0bef404c, 0x0200ac0a,
+	0x0643530c, 0x0900c30c, 0x0a6f800c, 0x00000000, 0x0603510a,
+	0x06803f0a, 0x0603520a, 0x0c7fedc0, 0x0603500b, 0x064c2307,
+	0x0befc047, 0x0cc00000, 0x064c2007, 0x040011c7, 0x06800008,
+	0x0a20c047, 0x058011c7, 0x024071c8, 0x0cc00000, 0x00000000,
+	0x02409247, 0x048ff249, 0x05401249, 0x02407207, 0x048ff1c7,
+	0x054011c7, 0x0680000a, 0x0680000b, 0x06800048, 0x0b8041c8,
 	0x054012cb, 0x0980b04b, 0x024081c8, 0x05401208, 0x0b2ec20a,
 	0x0400128a, 0x058012cb, 0x0e0002c9, 0x00000000, 0x00000000,
-	0x0cc00000, 0x0f000240, 0x024091c9, 0x06807fca, 0x02809289,
-	0x024071c8, 0x06807fca, 0x02807287, 0x0680000a, 0x0680000b,
+	0x0cc00000, 0x0f000240, 0x02409247, 0x06807fca, 0x02809289,
+	0x02407207, 0x06807fca, 0x02807287, 0x0680000a, 0x0680000b,
 	0x06800048, 0x0b8041c8, 0x054012cb, 0x0980b04b, 0x024081c8,
 	0x05401208, 0x0b2ec20a, 0x0400128a, 0x058012cb, 0x0e0002c9,
-	0x00000000, 0x00000000, 0x0cc00000, 0x0f000240, 0x02407207,
-	0x06807fca, 0x02807287, 0x0680000a, 0x0680000b, 0x06800048,
-	0x0b8041c8, 0x054012cb, 0x0980b04b, 0x024081c8, 0x05401208,
-	0x0b2ec34a, 0x0400128a, 0x0cc00000, 0x0580124b, 0x07804187,
-	0x0a60c007, 0x06800088, 0x06800048, 0x07c04148, 0x0a60c01a,
-	0x068057ac, 0x0680005a, 0x0cc00000, 0x00000000, 0x024091c9,
-	0x06807fc8, 0x02809209, 0x0680000a, 0x0680000b, 0x06800048,
-	0x0b8041c8, 0x054012cb, 0x0980b04b, 0x024081c8, 0x05401208,
-	0x0b2ec20a, 0x0400128a, 0x058012cb, 0x0e0002c9, 0x00000000,
-	0x00000000, 0x0cc00000, 0x0f000240, 0x0aa1409a, 0x0aa0801a,
-	0x0c784cc0, 0x0cc00000, 0x00000000, 0x07801ec7, 0x07801e88,
-	0x02407207, 0x048ff1c7, 0x054011c7, 0x07c00447, 0x07801f07,
-	0x07801e88, 0x02407207, 0x048ff1c7, 0x054011c7, 0x07c00487,
-	0x07804149, 0x0aa140c9, 0x07800389, 0x0a60c009, 0x00000000,
-	0x044011c7, 0x0c07f580, 0x07800449, 0x06800f88, 0x09646248,
-	0x060c3009, 0x07800487, 0x07804149, 0x0aa280c9, 0x07800389,
-	0x0aa0c009, 0x00000000, 0x040011c7, 0x0c07f280, 0x07800449,
-	0x06800fc8, 0x09646248, 0x060c3009, 0x07804147, 0x0aa080c7,
-	0x0c780bc0, 0x07801e88, 0x05401208, 0x07801ec7, 0x0c07e980,
-	0x054011c7, 0x06800c08, 0x09646248, 0x060c3009, 0x07801e48,
-	0x05401208, 0x07801ec7, 0x0c07e780, 0x054011c7, 0x06800c48,
-	0x09646248, 0x060c3009, 0x07801f07, 0x07801e88, 0x02407207,
-	0x048ff1c7, 0x05401247, 0x07801ec7, 0x07801f08, 0x02407207,
-	0x048ff1c7, 0x054011c7, 0x09529247, 0x06800d08, 0x09646248,
-	0x060c3009, 0x07801f07, 0x07801e88, 0x0c07d1c0, 0x07801e89,
-	0x06800808, 0x09646248, 0x060c3009, 0x07801ec7, 0x07801f08,
-	0x0c07d000, 0x07801f09, 0x06800888, 0x09646248, 0x060c3009,
-	0x0cc00000, 0x00000000, 0x07801f8c, 0x0aa0c00c, 0x0780038c,
-	0x0680000c, 0x0a61c00c, 0x07801ec7, 0x054011c7, 0x07801e88,
-	0x05401208, 0x0c780180, 0x04001208, 0x07801ec7, 0x054011c7,
-	0x040011c7, 0x04401207, 0x0c07db00, 0x00000000, 0x06800c08,
-	0x09646248, 0x0a60c00c, 0x00000000, 0x098093c9, 0x060c3009,
-	0x0a61800c, 0x07801ec7, 0x054011c7, 0x07801e88, 0x0c780200,
-	0x05401208, 0x07801ec7, 0x054011c7, 0x040011c7, 0x07801e88,
-	0x05401208, 0x04001208, 0x0c07d600, 0x00000000, 0x06800c48,
-	0x09646248, 0x0aa0c00c, 0x00000000, 0x098093c9, 0x060c3009,
-	0x0a61c00c, 0x07801ec7, 0x054011c7, 0x07801e48, 0x05401208,
-	0x0c7801c0, 0x04001208, 0x07801ec7, 0x054011c7, 0x040011c7,
-	0x07801e88, 0x05401208, 0x0c07d100, 0x00000000, 0x06800c88,
-	0x09646248, 0x060c3009, 0x0a61800c, 0x07801ec7, 0x054011c7,
-	0x07801e48, 0x0c780200, 0x05401208, 0x07801ec7, 0x054011c7,
-	0x040011c7, 0x07801e48, 0x05401208, 0x04001208, 0x0c07ccc0,
-	0x00000000, 0x06800cc8, 0x09646248, 0x060c3009, 0x0780038c,
-	0x07801f07, 0x0aa0c00c, 0x054011c7, 0x040011c7, 0x07801e88,
-	0x05401208, 0x02407207, 0x06807fca, 0x02809287, 0x07801ec7,
-	0x0aa1800c, 0x054011c7, 0x07801f88, 0x0a60c008, 0x00000000,
-	0x040011c7, 0x07801f08, 0x0aa0c00c, 0x05401208, 0x04001208,
-	0x02407207, 0x02807287, 0x09529247, 0x06800d08, 0x09646248,
-	0x060c3009, 0x07801f07, 0x0aa0c00c, 0x054011c7, 0x040011c7,
-	0x07801e88, 0x05401208, 0x04001208, 0x02407207, 0x06807fca,
+	0x00000000, 0x00000000, 0x0cc00000, 0x0f000240, 0x024091c9,
+	0x06807fca, 0x02809289, 0x024071c8, 0x06807fca, 0x02807287,
+	0x0680000a, 0x0680000b, 0x06800048, 0x0b8041c8, 0x054012cb,
+	0x0980b04b, 0x024081c8, 0x05401208, 0x0b2ec20a, 0x0400128a,
+	0x058012cb, 0x0e0002c9, 0x00000000, 0x00000000, 0x0cc00000,
+	0x0f000240, 0x02407207, 0x06807fca, 0x02807287, 0x0680000a,
+	0x0680000b, 0x06800048, 0x0b8041c8, 0x054012cb, 0x0980b04b,
+	0x024081c8, 0x05401208, 0x0b2ec34a, 0x0400128a, 0x0cc00000,
+	0x0580124b, 0x07804187, 0x0a60c007, 0x06800088, 0x06800048,
+	0x07c04148, 0x0a60c01a, 0x068057ad, 0x0680005a, 0x0cc00000,
+	0x00000000, 0x024091c9, 0x06807fc8, 0x02809209, 0x0680000a,
+	0x0680000b, 0x06800048, 0x0b8041c8, 0x054012cb, 0x0980b04b,
+	0x024081c8, 0x05401208, 0x0b2ec20a, 0x0400128a, 0x058012cb,
+	0x0e0002c9, 0x00000000, 0x00000000, 0x0cc00000, 0x0f000240,
+	0x0aa1409a, 0x0aa0801a, 0x0c784cc0, 0x0cc00000, 0x00000000,
+	0x07801ec7, 0x07801e88, 0x02407207, 0x048ff1c7, 0x054011c7,
+	0x07c00447, 0x07801f07, 0x07801e88, 0x02407207, 0x048ff1c7,
+	0x054011c7, 0x07c00487, 0x07804149, 0x0aa140c9, 0x07800389,
+	0x0a60c009, 0x00000000, 0x044011c7, 0x0c07f580, 0x07800449,
+	0x06800f88, 0x09646248, 0x060c3009, 0x07800487, 0x07804149,
+	0x0aa280c9, 0x07800389, 0x0aa0c009, 0x00000000, 0x040011c7,
+	0x0c07f280, 0x07800449, 0x06800fc8, 0x09646248, 0x060c3009,
+	0x07804147, 0x0aa080c7, 0x0c780bc0, 0x07801e88, 0x05401208,
+	0x07801ec7, 0x0c07e980, 0x054011c7, 0x06800c08, 0x09646248,
+	0x060c3009, 0x07801e48, 0x05401208, 0x07801ec7, 0x0c07e780,
+	0x054011c7, 0x06800c48, 0x09646248, 0x060c3009, 0x07801f07,
+	0x07801e88, 0x02407207, 0x048ff1c7, 0x05401247, 0x07801ec7,
+	0x07801f08, 0x02407207, 0x048ff1c7, 0x054011c7, 0x09529247,
+	0x06800d08, 0x09646248, 0x060c3009, 0x07801f07, 0x07801e88,
+	0x0c07d1c0, 0x07801e89, 0x06800808, 0x09646248, 0x060c3009,
+	0x07801ec7, 0x07801f08, 0x0c07d000, 0x07801f09, 0x06800888,
+	0x09646248, 0x060c3009, 0x0cc00000, 0x00000000, 0x07801f8c,
+	0x0aa0c00c, 0x0780038c, 0x0680000c, 0x0a61c00c, 0x07801ec7,
+	0x054011c7, 0x07801e88, 0x05401208, 0x0c780180, 0x04001208,
+	0x07801ec7, 0x054011c7, 0x040011c7, 0x04401207, 0x0c07db00,
+	0x00000000, 0x06800c08, 0x09646248, 0x0a60c00c, 0x00000000,
+	0x098093c9, 0x060c3009, 0x0a61800c, 0x07801ec7, 0x054011c7,
+	0x07801e88, 0x0c780200, 0x05401208, 0x07801ec7, 0x054011c7,
+	0x040011c7, 0x07801e88, 0x05401208, 0x04001208, 0x0c07d600,
+	0x00000000, 0x06800c48, 0x09646248, 0x0aa0c00c, 0x00000000,
+	0x098093c9, 0x060c3009, 0x0a61c00c, 0x07801ec7, 0x054011c7,
+	0x07801e48, 0x05401208, 0x0c7801c0, 0x04001208, 0x07801ec7,
+	0x054011c7, 0x040011c7, 0x07801e88, 0x05401208, 0x0c07d100,
+	0x00000000, 0x06800c88, 0x09646248, 0x060c3009, 0x0a61800c,
+	0x07801ec7, 0x054011c7, 0x07801e48, 0x0c780200, 0x05401208,
+	0x07801ec7, 0x054011c7, 0x040011c7, 0x07801e48, 0x05401208,
+	0x04001208, 0x0c07ccc0, 0x00000000, 0x06800cc8, 0x09646248,
+	0x060c3009, 0x0780038c, 0x07801f07, 0x0aa0c00c, 0x054011c7,
+	0x040011c7, 0x07801e88, 0x05401208, 0x02407207, 0x06807fca,
 	0x02809287, 0x07801ec7, 0x0aa1800c, 0x054011c7, 0x07801f88,
 	0x0a60c008, 0x00000000, 0x040011c7, 0x07801f08, 0x0aa0c00c,
 	0x05401208, 0x04001208, 0x02407207, 0x02807287, 0x09529247,
-	0x06800d48, 0x09646248, 0x060c3009, 0x0aa0c00c, 0x0680000c,
-	0x0680004c, 0x07801f07, 0x054011c7, 0x02007307, 0x07801e88,
-	0x05401208, 0x04001208, 0x0c07b0c0, 0x04000248, 0x06800808,
-	0x09646248, 0x060c3009, 0x07801f07, 0x054011c7, 0x02007307,
-	0x07801e88, 0x05401208, 0x0c07ae40, 0x04001248, 0x06800848,
-	0x09646248, 0x060c3009, 0x07801f07, 0x054011c7, 0x02007307,
-	0x07801ec8, 0x05401208, 0x0c07b140, 0x04000248, 0x06800888,
-	0x09646248, 0x060c3009, 0x07801f07, 0x054011c7, 0x02007307,
-	0x07801ec8, 0x05401208, 0x04001208, 0x0c07ae80, 0x04401248,
-	0x068008c8, 0x09646248, 0x060c3009, 0x07801f07, 0x054011c7,
-	0x02007307, 0x07801e88, 0x05401208, 0x04001208, 0x0c07a640,
-	0x04401248, 0x06800908, 0x09646248, 0x060c3009, 0x07801f07,
-	0x054011c7, 0x02007307, 0x07801e88, 0x05401208, 0x0c07a3c0,
-	0x04000248, 0x06800948, 0x09646248, 0x060c3009, 0x07801f07,
-	0x054011c7, 0x02007307, 0x07801ec8, 0x05401208, 0x0c07a6c0,
-	0x04001248, 0x06800988, 0x09646248, 0x060c3009, 0x07801f07,
+	0x06800d08, 0x09646248, 0x060c3009, 0x07801f07, 0x0aa0c00c,
+	0x054011c7, 0x040011c7, 0x07801e88, 0x05401208, 0x04001208,
+	0x02407207, 0x06807fca, 0x02809287, 0x07801ec7, 0x0aa1800c,
+	0x054011c7, 0x07801f88, 0x0a60c008, 0x00000000, 0x040011c7,
+	0x07801f08, 0x0aa0c00c, 0x05401208, 0x04001208, 0x02407207,
+	0x02807287, 0x09529247, 0x06800d48, 0x09646248, 0x060c3009,
+	0x0aa0c00c, 0x0680000c, 0x0680004c, 0x07801f07, 0x054011c7,
+	0x02007307, 0x07801e88, 0x05401208, 0x04001208, 0x0c07b0c0,
+	0x04000248, 0x06800808, 0x09646248, 0x060c3009, 0x07801f07,
+	0x054011c7, 0x02007307, 0x07801e88, 0x05401208, 0x0c07ae40,
+	0x04001248, 0x06800848, 0x09646248, 0x060c3009, 0x07801f07,
+	0x054011c7, 0x02007307, 0x07801ec8, 0x05401208, 0x0c07b140,
+	0x04000248, 0x06800888, 0x09646248, 0x060c3009, 0x07801f07,
 	0x054011c7, 0x02007307, 0x07801ec8, 0x05401208, 0x04001208,
-	0x0c07a400, 0x04400248, 0x068009c8, 0x09646248, 0x060c3009,
-	0x0cc00000, 0x00000000, 0x07804147, 0x0aa080c7, 0x0c7807c0,
-	0x07801f07, 0x07801e88, 0x0c079600, 0x07801e89, 0x06800808,
-	0x09646248, 0x060c3009, 0x07801ec7, 0x07801e48, 0x0c079440,
-	0x07801e89, 0x06800848, 0x09646248, 0x060c3009, 0x07801ec7,
-	0x07801e88, 0x0c079280, 0x07801e49, 0x06800908, 0x09646248,
-	0x060c3009, 0x07801ec7, 0x07801e48, 0x0c0790c0, 0x07801e49,
-	0x06800948, 0x09646248, 0x060c3009, 0x0cc00000, 0x00000000,
-	0x0780038c, 0x0aa0800c, 0x0c780880, 0x0680080d, 0x07801f07,
-	0x054011c7, 0x0900230d, 0x07801e88, 0x05401208, 0x0aa2004c,
-	0x0aa1c00c, 0x04001208, 0x07801e48, 0x05401208, 0x0aa0c0cc,
-	0x00000000, 0x04001208, 0x0904230d, 0x07801e89, 0x05401249,
-	0x0aa2004c, 0x0aa1c00c, 0x04001249, 0x07801e49, 0x05401249,
-	0x0aa0c0cc, 0x00000000, 0x04001249, 0x0c078d80, 0x00000000,
-	0x0964624d, 0x060c3009, 0x0ba90bcd, 0x0400134d, 0x0cc00000,
-	0x00000000, 0x0680080d, 0x07801f07, 0x054011c7, 0x040011c7,
-	0x0900230d, 0x07801f08, 0x0aa2800c, 0x05401208, 0x07801e88,
-	0x05401208, 0x0aa1808c, 0x0aa1404c, 0x04001208, 0x07801e48,
-	0x05401208, 0x04001208, 0x0904230d, 0x07801f09, 0x0aa2800c,
-	0x05401249, 0x07801e89, 0x05401249, 0x0aa1808c, 0x0aa1404c,
-	0x04001249, 0x07801e49, 0x05401249, 0x04001249, 0x0c078480,
-	0x00000000, 0x0964624d, 0x060c3009, 0x0ba84bcd, 0x0400134d,
-	0x0cc00000, 0x00000000, 0x07804147, 0x0a6140c7, 0x06099004,
-	0x06099105, 0x0c780240, 0x06099206, 0x06099004, 0x06099104,
-	0x06099205, 0x06099305, 0x06099406, 0x0c780080, 0x06099506,
-	0x0aa3c09a, 0x0aa0805a, 0x0cc00000, 0x07804147, 0x0698d908,
-	0x0aa1c0c7, 0x06d85888, 0x0688d108, 0x0aa10087, 0x06c85088,
-	0x06910948, 0x06d088c8, 0x080c2400, 0x0cc00000, 0x060c2208,
-	0x07804147, 0x0698d908, 0x0aa100c7, 0x06d85888, 0x06800008,
-	0x06d088c8, 0x080c2400, 0x060c2208, 0x07804147, 0x069898c8,
-	0x0aa100c7, 0x06d81848, 0x06800008, 0x06c85008, 0x080c2408,
-	0x0cc00000, 0x060c2208
+	0x0c07ae80, 0x04401248, 0x068008c8, 0x09646248, 0x060c3009,
+	0x07801f07, 0x054011c7, 0x02007307, 0x07801e88, 0x05401208,
+	0x04001208, 0x0c07a640, 0x04401248, 0x06800908, 0x09646248,
+	0x060c3009, 0x07801f07, 0x054011c7, 0x02007307, 0x07801e88,
+	0x05401208, 0x0c07a3c0, 0x04000248, 0x06800948, 0x09646248,
+	0x060c3009, 0x07801f07, 0x054011c7, 0x02007307, 0x07801ec8,
+	0x05401208, 0x0c07a6c0, 0x04001248, 0x06800988, 0x09646248,
+	0x060c3009, 0x07801f07, 0x054011c7, 0x02007307, 0x07801ec8,
+	0x05401208, 0x04001208, 0x0c07a400, 0x04400248, 0x068009c8,
+	0x09646248, 0x060c3009, 0x0cc00000, 0x00000000, 0x07804147,
+	0x0aa080c7, 0x0c7807c0, 0x07801f07, 0x07801e88, 0x0c079600,
+	0x07801e89, 0x06800808, 0x09646248, 0x060c3009, 0x07801ec7,
+	0x07801e48, 0x0c079440, 0x07801e89, 0x06800848, 0x09646248,
+	0x060c3009, 0x07801ec7, 0x07801e88, 0x0c079280, 0x07801e49,
+	0x06800908, 0x09646248, 0x060c3009, 0x07801ec7, 0x07801e48,
+	0x0c0790c0, 0x07801e49, 0x06800948, 0x09646248, 0x060c3009,
+	0x0cc00000, 0x00000000, 0x0780038c, 0x0aa0800c, 0x0c780880,
+	0x0680080d, 0x07801f07, 0x054011c7, 0x0900230d, 0x07801e88,
+	0x05401208, 0x0aa2004c, 0x0aa1c00c, 0x04001208, 0x07801e48,
+	0x05401208, 0x0aa0c0cc, 0x00000000, 0x04001208, 0x0904230d,
+	0x07801e89, 0x05401249, 0x0aa2004c, 0x0aa1c00c, 0x04001249,
+	0x07801e49, 0x05401249, 0x0aa0c0cc, 0x00000000, 0x04001249,
+	0x0c078d80, 0x00000000, 0x0964624d, 0x060c3009, 0x0ba90bcd,
+	0x0400134d, 0x0cc00000, 0x00000000, 0x0680080d, 0x07801f07,
+	0x054011c7, 0x040011c7, 0x0900230d, 0x07801f08, 0x0aa2800c,
+	0x05401208, 0x07801e88, 0x05401208, 0x0aa1808c, 0x0aa1404c,
+	0x04001208, 0x07801e48, 0x05401208, 0x04001208, 0x0904230d,
+	0x07801f09, 0x0aa2800c, 0x05401249, 0x07801e89, 0x05401249,
+	0x0aa1808c, 0x0aa1404c, 0x04001249, 0x07801e49, 0x05401249,
+	0x04001249, 0x0c078480, 0x00000000, 0x0964624d, 0x060c3009,
+	0x0ba84bcd, 0x0400134d, 0x0cc00000, 0x00000000, 0x07804147,
+	0x0a6140c7, 0x06099004, 0x06099105, 0x0c780240, 0x06099206,
+	0x06099004, 0x06099104, 0x06099205, 0x06099305, 0x06099406,
+	0x0c780080, 0x06099506, 0x0aa3c09a, 0x0aa0805a, 0x0cc00000,
+	0x07804147, 0x0698d908, 0x0aa1c0c7, 0x06d85888, 0x0688d108,
+	0x0aa10087, 0x06c85088, 0x06910948, 0x06d088c8, 0x080c2400,
+	0x0cc00000, 0x060c2208, 0x07804147, 0x0698d908, 0x0aa100c7,
+	0x06d85888, 0x06800008, 0x06d088c8, 0x080c2400, 0x060c2208,
+	0x07804147, 0x069898c8, 0x0aa100c7, 0x06d81848, 0x06800008,
+	0x06c85008, 0x080c2408, 0x0cc00000, 0x060c2208
 };
diff --git a/drivers/amlogic/amports/arch/ucode/avs/gxm_avs_linux.h b/drivers/amlogic/amports/arch/ucode/avs/gxm_avs_linux.h
new file mode 100644
index 0000000..55eaf4e
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/avs/gxm_avs_linux.h
@@ -0,0 +1,543 @@
+/*
+ * drivers/amlogic/amports/arch/ucode/avs/gxm_avs_linux.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+/* ucode commit id: 1c4f555b8e1 */
+static const u32 MicroCode[] __initconst = {
+	0x06807801, 0x06800000, 0x0d000001, 0x07400040, 0x0c014980,
+	0x00000000, 0x00000000, 0x00000000, 0x080c0002, 0x06932000,
+	0x09800580, 0x060c1e00, 0x06bfdac0, 0x07c017c0, 0x06030400,
+	0x00400000, 0x0c015bc0, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x0c7ffec0, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c780540, 0x064c0007, 0x0c796440, 0x00000000,
+	0x0c796e40, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c796cc0, 0x00000000, 0x0cc00000, 0x00400000,
+	0x06800009, 0x07c01fc9, 0x07c00409, 0x00800000, 0x078017c9,
+	0x0c7ffe40, 0x06030409, 0x06bfd9c9, 0x06030409, 0x00400000,
+	0x0a2d8047, 0x07801509, 0x0aa14009, 0x0a608049, 0x0c78f980,
+	0x0a608089, 0x0c78ee40, 0x0a23c807, 0x0c786200, 0x00000000,
+	0x0649d008, 0x0aa0c008, 0x0809c701, 0x0c780000, 0x0c01a740,
+	0x080c0a00, 0x0c01aa80, 0x00000000, 0x0c01bd40, 0x00000000,
+	0x0c793140, 0x00000000, 0x0becd007, 0x078043c8, 0x0aa0c008,
+	0x0a208207, 0x0c792fc0, 0x078003c7, 0x0a6fc007, 0x078043c7,
+	0x0a63c007, 0x064c2907, 0x0be2c407, 0x07800007, 0x0a62c007,
+	0x00000000, 0x064c2907, 0x091c11c7, 0x0a61c047, 0x00000000,
+	0x064c0607, 0x0900f1c7, 0x0ae0c047, 0x0c792b80, 0x00000000,
+	0x0cb8002d, 0x00000000, 0x068fdfca, 0x064e0408, 0x02808288,
+	0x02c08748, 0x060e0408, 0x060c071e, 0x064c0324, 0x064c0325,
+	0x064c2728, 0x09210268, 0x07800007, 0x0a618007, 0x07801c08,
+	0x06c00008, 0x060c0208, 0x080c0200, 0x06bfffc9, 0x060c0320,
+	0x060c0321, 0x07801c48, 0x09610209, 0x060c2708, 0x07801847,
+	0x0a6fc007, 0x07800147, 0x07c01b87, 0x06800347, 0x07c00147,
+	0x060c2507, 0x080c2602, 0x080c260f, 0x080c2603, 0x04c001c7,
+	0x09807207, 0x060c2107, 0x07801907, 0x0aa14007, 0x06a01008,
+	0x0aa0c047, 0x06a22008, 0x06a40008, 0x06c00108, 0x060e0508,
+	0x07801b08, 0x06801809, 0x09502248, 0x060c2109, 0x080c260e,
+	0x06800088, 0x07c01947, 0x0ba0c087, 0x040011c7, 0x06800007,
+	0x07c01907, 0x07800007, 0x07c01b47, 0x07801b87, 0x07c01bc7,
+	0x07c01848, 0x08030580, 0x07801d47, 0x0aa1472f, 0x040011c7,
+	0x078016c8, 0x0a20c048, 0x00000000, 0x07c01d47, 0x0683ffc8,
+	0x064c2307, 0x093041c7, 0x0aa0c008, 0x0a6f4007, 0x04401208,
+	0x07801c8d, 0x0ba13fcd, 0x06800008, 0x0c781100, 0x07c01c88,
+	0x06808008, 0x0ba1070d, 0x0400024d, 0x0441c249, 0x0680c008,
+	0x05403289, 0x0200a24a, 0x02008288, 0x07400228, 0x04001208,
+	0x092102e4, 0x0740020b, 0x04001208, 0x07400224, 0x04001208,
+	0x07400225, 0x04001208, 0x092102e5, 0x0740020b, 0x04001208,
+	0x07400226, 0x04001208, 0x092102e6, 0x0740020b, 0x04001208,
+	0x07400227, 0x04001208, 0x092102e7, 0x0740020b, 0x07800988,
+	0x0ac07bc8, 0x0780000a, 0x0aa3872f, 0x040002ca, 0x078016ca,
+	0x0c7802c0, 0x0942f28b, 0x0a61000a, 0x0aa1472f, 0x078016ca,
+	0x0a20c04a, 0x0a6146c9, 0x0400128d, 0x0b60c70d, 0x0680000a,
+	0x0680070a, 0x07c01c8a, 0x0b013bc8, 0x0aa0800a, 0x0a64470a,
+	0x07801cca, 0x0a20c04a, 0x06a0800b, 0x06a0c00b, 0x06b80009,
+	0x07801d0c, 0x0540928c, 0x0200a24a, 0x06c0748a, 0x0200ac0a,
+	0x0603510a, 0x06803f0a, 0x0603520a, 0x0603500b, 0x0c01b7c0,
+	0x00000000, 0x07800007, 0x040011c7, 0x07c00007, 0x09c1d39d,
+	0x07800988, 0x0b405207, 0x040011c7, 0x0b833207, 0x0c780c80,
+	0x0981d1dd, 0x06800007, 0x07c00007, 0x0981d39d, 0x09c1d3dd,
+	0x09c1d1dd, 0x078016c8, 0x04001208, 0x07801dc9, 0x0b828248,
+	0x07c016c8, 0x07801847, 0x0a6fc007, 0x00000000, 0x06430507,
+	0x0a2f0107, 0x06a00007, 0x060c3d07, 0x07800147, 0x0aa24007,
+	0x06803fcb, 0x07801a88, 0x064e0c09, 0x09010249, 0x0b804248,
+	0x0aa0c00b, 0x0c7ffec0, 0x044012cb, 0x07804147, 0x0aa280c7,
+	0x07800347, 0x07801dc8, 0x0b407207, 0x0c01c9c0, 0x07c00348,
+	0x06800048, 0x07c00308, 0x0c7898c0, 0x07c00388, 0x06800008,
+	0x07c00308, 0x07c00388, 0x0c78f9c0, 0x064c0007, 0x0b60c709,
+	0x06808008, 0x0680c008, 0x0c780400, 0x06800007, 0x07800007,
+	0x09508787, 0x078016c9, 0x09408789, 0x07800989, 0x0b009bc9,
+	0x06808008, 0x0aad0007, 0x07801c89, 0x040011c9, 0x0ba10707,
+	0x0b6c0e07, 0x0680c008, 0x0441c1c7, 0x05403247, 0x020091c9,
+	0x02008248, 0x07000209, 0x07c01c49, 0x04001208, 0x07000209,
+	0x04001208, 0x07000220, 0x09610809, 0x04001208, 0x07000221,
+	0x04001208, 0x07000209, 0x09610849, 0x04001208, 0x07000222,
+	0x04001208, 0x07000209, 0x09610889, 0x04001208, 0x07000223,
+	0x04001208, 0x07000209, 0x096108c9, 0x0c7fb580, 0x00000000,
+	0x068fdfca, 0x064e0408, 0x02808288, 0x02c08748, 0x060e0408,
+	0x060c071e, 0x064c0324, 0x064c0325, 0x064c0326, 0x064c0327,
+	0x064c2728, 0x060c071e, 0x09210268, 0x07800007, 0x0a638007,
+	0x07801c08, 0x06c00008, 0x060c0208, 0x06800008, 0x06c00008,
+	0x060c0208, 0x06800008, 0x06c00008, 0x060c0208, 0x06800008,
+	0x06c00008, 0x060c0208, 0x06bfffc9, 0x060c0320, 0x060c0321,
+	0x060c0322, 0x060c0323, 0x07801c48, 0x09610209, 0x060c2708,
+	0x07804287, 0x054031c7, 0x04c301c7, 0x07801f8a, 0x095011ca,
+	0x060c2507, 0x0780184a, 0x0a6fc00a, 0x07800147, 0x07c01b87,
+	0x064c2307, 0x09304207, 0x0a6f8008, 0x090a1207, 0x090241c7,
+	0x095211c8, 0x064c0609, 0x09010249, 0x0aa10009, 0x00000000,
+	0x06800007, 0x06800008, 0x07c00147, 0x0aa60347, 0x060c2507,
+	0x0aa60287, 0x0aa18048, 0x0a60c007, 0x0c780200, 0x00000000,
+	0x080c2605, 0x080c2606, 0x080c2607, 0x080c2602, 0x080c260f,
+	0x080c2603, 0x07801ac8, 0x0aa100c8, 0x06800089, 0x0c7fb8c0,
+	0x07c01ac9, 0x0780184b, 0x0a6fc00b, 0x00000000, 0x07c01b08,
+	0x0c7fb740, 0x07c01ac9, 0x080c2602, 0x080c260f, 0x080c2603,
+	0x07801ac8, 0x0aa48088, 0x068000c9, 0x07800008, 0x0aa0c008,
+	0x0c7fb4c0, 0x07c01ac9, 0x06803fcb, 0x07801a88, 0x064e0c09,
+	0x09010249, 0x0b804248, 0x0aa0c00b, 0x0c7ffec0, 0x044012cb,
+	0x06800088, 0x068000c9, 0x0680180b, 0x060c210b, 0x0780184b,
+	0x0a6fc00b, 0x00000000, 0x07c01b08, 0x0c7fb040, 0x07c01ac9,
+	0x0be0d007, 0x0c7807c0, 0x00000000, 0x00000000, 0x0649d00a,
+	0x0aa0c00a, 0x0809c701, 0x0c780000, 0x0c0144c0, 0x080c0a00,
+	0x0c014800, 0x00000000, 0x0c015600, 0x00000000, 0x064c000a,
+	0x09c0a18a, 0x0980a20a, 0x0980a00a, 0x060c000a, 0x080c2300,
+	0x064c1e08, 0x09c081c8, 0x09808008, 0x060c1e08, 0x098081c8,
+	0x09c08008, 0x060c1e08, 0x064c080a, 0x0980a34a, 0x060c080a,
+	0x0c0149c0, 0x00000000, 0x064c1a07, 0x0aa10007, 0x06800008,
+	0x0c78c980, 0x00000000, 0x064c1e0a, 0x0980a60a, 0x060c1e0a,
+	0x06809009, 0x060c0809, 0x064c1c0a, 0x0a213fca, 0x064c1e0a,
+	0x09c0a74a, 0x060c1e0a, 0x0980a74a, 0x0980a7ca, 0x060c1e0a,
+	0x0fc08280, 0x0aa3ec0a, 0x0649c108, 0x0aa2c008, 0x0aa12cca,
+	0x0aa1ad8a, 0x0ae22bca, 0x0c78a5c0, 0x06800007, 0x0c780980,
+	0x07c00387, 0x06800007, 0x0c781ec0, 0x07c00387, 0x0c78c240,
+	0x00000000, 0x0fc08280, 0x07c0400a, 0x0609c40a, 0x0fc08280,
+	0x0fc01280, 0x0500128a, 0x07c0404a, 0x0fc0e1c0, 0x07c04087,
+	0x0609c107, 0x0fc0e1c0, 0x07c040c7, 0x0609c207, 0x0fc021c0,
+	0x0fc031c0, 0x0fc041c0, 0x0609c007, 0x0fc041c0, 0x0609c307,
+	0x0fc091c0, 0x0fc091c0, 0x0fc011c0, 0x0fc0c1c0, 0x0fc011c0,
+	0x07c04107, 0x0fc011c0, 0x0fc091c0, 0x0fc091c0, 0x0fc031c0,
+	0x0c78ba80, 0x00000000, 0x06800007, 0x07c01f87, 0x07804007,
+	0x0a611207, 0x0fc101c0, 0x0fc011c0, 0x0fc071c0, 0x0fc011c0,
+	0x0aa10007, 0x00000000, 0x0fc0c1c0, 0x0fc0c1c0, 0x0fc011c0,
+	0x07800a47, 0x07c00a07, 0x07800a87, 0x07c00a47, 0x0fc081c0,
+	0x07c00a87, 0x07804107, 0x0aa10007, 0x0c016b80, 0x080c2301,
+	0x07c01f47, 0x0fc011c0, 0x07800a88, 0x095c1207, 0x07c00a88,
+	0x050011c7, 0x07c01807, 0x0aa30007, 0x068000c8, 0x0fc011c0,
+	0x0a624007, 0x068000c8, 0x0fc011c0, 0x07c04187, 0x0a60c007,
+	0x06800048, 0x06800088, 0x0c780140, 0x07c04148, 0x07c04148,
+	0x0fc011c0, 0x07c04187, 0x0fc011c0, 0x07c041c7, 0x0fc011c0,
+	0x07c04207, 0x0fc061c0, 0x07c04247, 0x06800087, 0x07c00087,
+	0x06800808, 0x060c2108, 0x07801807, 0x0aa18007, 0x06800008,
+	0x07804147, 0x0aa0c0c7, 0x00000000, 0x0fc01200, 0x07c04288,
+	0x0fc041c0, 0x0fc011c0, 0x07c042c7, 0x0a648007, 0x06800008,
+	0x0fc011c0, 0x0aa34007, 0x06800009, 0x0c015f00, 0x080c2301,
+	0x0c015f80, 0x00000000, 0x07c04307, 0x0c015dc0, 0x080c2301,
+	0x0c015e40, 0x00000000, 0x0c780100, 0x07c04347, 0x07c04308,
+	0x07c04349, 0x06800007, 0x07c00107, 0x0c782a00, 0x0680001a,
+	0x07804007, 0x0a611207, 0x0fc101c0, 0x0fc011c0, 0x0fc071c0,
+	0x0fc021c0, 0x0a60c047, 0x0c780180, 0x0680005a, 0x0fc081c0,
+	0x07c00ac7, 0x0c780240, 0x0680009a, 0x07800a47, 0x07c00a07,
+	0x07800a87, 0x07c00a47, 0x0fc081c0, 0x07c00a87, 0x07c00ac7,
+	0x07804107, 0x0aa10007, 0x0c015540, 0x080c2301, 0x07c01f47,
+	0x0fc011c0, 0x07800ac8, 0x095c1207, 0x0aa0c09a, 0x07c00ac8,
+	0x07c00a88, 0x050011c7, 0x07c01807, 0x0aa34007, 0x068000c8,
+	0x0fc011c0, 0x0a628007, 0x068000c8, 0x0fc011c0, 0x0fc011c0,
+	0x07c04187, 0x0a60c007, 0x06800048, 0x06800088, 0x0c780140,
+	0x07c04148, 0x07c04148, 0x0fc011c0, 0x07c04187, 0x0fc011c0,
+	0x07c041c7, 0x0fc011c0, 0x07c04207, 0x0fc061c0, 0x07c04247,
+	0x07800ac7, 0x048ff207, 0x07c01f08, 0x091c11c7, 0x0aa5c007,
+	0x07800a07, 0x091c1207, 0x0a610008, 0x048ff1c7, 0x054011c7,
+	0x048ff1c7, 0x07c01e47, 0x07800a47, 0x091c1207, 0x0a610008,
+	0x048ff1c7, 0x054011c7, 0x048ff1c7, 0x07c01e87, 0x07800a87,
+	0x091c1207, 0x0a610008, 0x048ff1c7, 0x054011c7, 0x048ff1c7,
+	0x0c780b40, 0x07c01ec7, 0x07800a07, 0x091c1207, 0x0aa2c008,
+	0x048ff1c7, 0x058011c7, 0x07801f08, 0x0b4031c8, 0x06804009,
+	0x02008248, 0x024091c8, 0x0ba0e009, 0x0c7fff80, 0x040801c7,
+	0x07c01e47, 0x07800a47, 0x091c1207, 0x0aa2c008, 0x048ff1c7,
+	0x058011c7, 0x07801f08, 0x0b4031c8, 0x06804009, 0x02008248,
+	0x024091c8, 0x0ba0e009, 0x0c7fff80, 0x040801c7, 0x07c01e87,
+	0x07800a87, 0x091c1207, 0x0aa2c008, 0x048ff1c7, 0x058011c7,
+	0x07801f08, 0x0b0031c8, 0x06804009, 0x02408248, 0x02409207,
+	0x0ba0e009, 0x0c7fff80, 0x044801c7, 0x048ff1c7, 0x07c01ec7,
+	0x0a61409a, 0x07804147, 0x0a60c0c7, 0x0c780240, 0x06800808,
+	0x0fc011c0, 0x07c00087, 0x0a6f0007, 0x06800808, 0x06800047,
+	0x09505207, 0x09605207, 0x060c2108, 0x0fc011c0, 0x0fc011c0,
+	0x07c01f87, 0x0fc021c0, 0x0fc011c0, 0x07c04287, 0x0fc011c0,
+	0x07c042c7, 0x0a648007, 0x06800008, 0x0fc011c0, 0x0aa34007,
+	0x06800009, 0x0c013500, 0x080c2301, 0x0c013580, 0x00000000,
+	0x07c04307, 0x0c0133c0, 0x080c2301, 0x0c013440, 0x00000000,
+	0x0c780100, 0x07c04347, 0x07c04308, 0x07c04349, 0x06800007,
+	0x07c00107, 0x07804007, 0x0aa25207, 0x00000000, 0x06802007,
+	0x06c02007, 0x060e1907, 0x060e1a07, 0x060e1b07, 0x0c781640,
+	0x00000000, 0x0fc011c0, 0x064e1c09, 0x097e1247, 0x0aa20047,
+	0x060e1c09, 0x06802007, 0x06c02007, 0x060e1907, 0x060e1a07,
+	0x0c781200, 0x060e1b07, 0x0fc011c0, 0x0fc011c0, 0x06800009,
+	0x07c01109, 0x0a630007, 0x07c01149, 0x0c012a80, 0x080c2301,
+	0x0c012b00, 0x00000000, 0x07c01107, 0x0c012940, 0x080c2301,
+	0x0c0129c0, 0x00000000, 0x07c01147, 0x0fc021c0, 0x0fc02200,
+	0x064e1c09, 0x09602248, 0x07801108, 0x09405248, 0x07801148,
+	0x09505248, 0x060e1c09, 0x0aa30047, 0x06802008, 0x07c01188,
+	0x06801888, 0x07c011c8, 0x06801a88, 0x07c01208, 0x06801d08,
+	0x07c01248, 0x07c01288, 0x0c7802c0, 0x06802008, 0x068021c8,
+	0x07c01188, 0x068023c8, 0x07c011c8, 0x07c01208, 0x06802808,
+	0x07c01248, 0x07c01288, 0x06803548, 0x07c012c8, 0x0aa2c007,
+	0x06801189, 0x0c011fc0, 0x080c2301, 0x0c012040, 0x00000000,
+	0x07000248, 0x020081c8, 0x07400248, 0x0bae52c9, 0x04001249,
+	0x07801188, 0x078011c9, 0x09609209, 0x060e1908, 0x07801208,
+	0x07801249, 0x09609209, 0x060e1a08, 0x07801288, 0x078012c9,
+	0x09609209, 0x060e1b08, 0x0fc011c0, 0x07c043c7, 0x0aa0c007,
+	0x06800007, 0x0687ffc7, 0x07c01c07, 0x064c510a, 0x064c4607,
+	0x07800888, 0x05410208, 0x07800849, 0x02008248, 0x05802208,
+	0x0e000288, 0x00000000, 0x00000000, 0x00000000, 0x0f000200,
+	0x0f010280, 0x0970820a, 0x05402208, 0x020081c8, 0x064c430a,
+	0x02408288, 0x064c400a, 0x02408288, 0x07c008c8, 0x05810208,
+	0x07c00908, 0x0c013180, 0x00000000, 0x0680001e, 0x07c0001e,
+	0x07c016de, 0x0981d39e, 0x0981d3dd, 0x09c1d1dd, 0x07804087,
+	0x0400f1c7, 0x058041c7, 0x060c0907, 0x07c00987, 0x04401247,
+	0x07c00609, 0x09708789, 0x05404287, 0x078040c8, 0x0400f208,
+	0x05804208, 0x05404248, 0x04401249, 0x05402249, 0x07c009c8,
+	0x07804149, 0x0aa0c0c9, 0x04000248, 0x05801249, 0x07c01dc9,
+	0x04401248, 0x09608789, 0x04000248, 0x09610247, 0x06095209,
+	0x05404208, 0x0780408a, 0x0400f28a, 0x0580428a, 0x0540428a,
+	0x078040c8, 0x0400f208, 0x05804208, 0x05404208, 0x0961020a,
+	0x06090808, 0x0c005c40, 0x07c0095a, 0x06a00007, 0x060c3d07,
+	0x064c3d08, 0x09161208, 0x0a6f8008, 0x06800008, 0x06c06c08,
+	0x0aa1009a, 0x02008c08, 0x0c780400, 0x060c3808, 0x05803208,
+	0x07804147, 0x0aa200c7, 0x06800109, 0x0aa18047, 0x06800009,
+	0x07801f87, 0x0aa0c007, 0x068000c9, 0x06800009, 0x097a3209,
+	0x060c3908, 0x06bfffc8, 0x060c3808, 0x0c00bf00, 0x00000000,
+	0x0c00c240, 0x00000000, 0x0c00d040, 0x00000000, 0x069898c8,
+	0x06d81848, 0x06800707, 0x0d000007, 0x060c2208, 0x07800387,
+	0x0aa10007, 0x06800007, 0x0c7f0e40, 0x07c00387, 0x0649c909,
+	0x0aa10009, 0x06800087, 0x0c7f0d00, 0x07c01507, 0x07801487,
+	0x0a608007, 0x0c780900, 0x044011c7, 0x0aa0c087, 0x07801549,
+	0x078015c9, 0x0ae7c0c9, 0x040801c9, 0x070001c7, 0x054101c7,
+	0x040a0209, 0x07000208, 0x094101c8, 0x0609cb07, 0x040b01c9,
+	0x070001c7, 0x078010c8, 0x020081c8, 0x0609ca08, 0x07c010d9,
+	0x040d01c9, 0x070001c7, 0x054101c7, 0x040c0209, 0x07000208,
+	0x094101c8, 0x0609cc07, 0x04090209, 0x04001249, 0x07000208,
+	0x09464248, 0x07801808, 0x094e1248, 0x0609c909, 0x08007401,
+	0x06800009, 0x07c01489, 0x06800009, 0x07c01509, 0x078014c7,
+	0x02c07247, 0x04000295, 0x0a238047, 0x06800008, 0x04000296,
+	0x0a22c087, 0x06800048, 0x04000297, 0x0a220107, 0x06800088,
+	0x04000298, 0x0a214207, 0x068000c8, 0x06800047, 0x0c7efec0,
+	0x07c01507, 0x07801607, 0x090041c7, 0x0a8051c8, 0x0aa2001a,
+	0x07801607, 0x090841c7, 0x0a4051c8, 0x06800047, 0x03407207,
+	0x0c7ff980, 0x02c091c9, 0x078008c7, 0x040c0248, 0x07400247,
+	0x07800907, 0x04010249, 0x07400247, 0x07804187, 0x054031c7,
+	0x02c07687, 0x04090248, 0x07400247, 0x040801c8, 0x07801049,
+	0x074001c9, 0x040a01c8, 0x07801009, 0x0a60c05a, 0x074001c9,
+	0x040006c8, 0x0a62009a, 0x040b01c8, 0x074001d9, 0x07000709,
+	0x0aa1c009, 0x04401249, 0x0c780140, 0x07400709, 0x07801089,
+	0x074001c9, 0x04000707, 0x07c01099, 0x06800047, 0x03407207,
+	0x078014c9, 0x02c091c9, 0x07c014c9, 0x0609b20a, 0x0609b00a,
+	0x0609b10a, 0x068000c9, 0x0400125a, 0x07c01489, 0x0a60809a,
+	0x0c780340, 0x07801587, 0x07c015c7, 0x07c01588, 0x04000185,
+	0x04000144, 0x07801609, 0x05404249, 0x09404248, 0x07c01609,
+	0x0400010a, 0x0c7800c0, 0x00000000, 0x07c01548, 0x0649c108,
+	0x0aa2c008, 0x07800187, 0x0b61c087, 0x06800048, 0x0aa1c09a,
+	0x0aa0801a, 0x0aa14007, 0x040011c7, 0x07c00187, 0x0c780180,
+	0x07c001c8, 0x06800008, 0x07c001c8, 0x0c782280, 0x00000000,
+	0x0aa0c01a, 0x06801aed, 0x068057ad, 0x0c004b00, 0x00000000,
+	0x0c008c00, 0x00000000, 0x0c015cc0, 0x00000000, 0x0c004f40,
+	0x00000000, 0x0c781f40, 0x00000000, 0x0c781ec0, 0x00000000,
+	0x078001c7, 0x0a608007, 0x0c7fff00, 0x0400024a, 0x07800107,
+	0x0b4031c9, 0x0c781cc0, 0x00000000, 0x07c00109, 0x078040c7,
+	0x0682bc08, 0x0b004207, 0x00000000, 0x0fc031c0, 0x094e3247,
+	0x07c00349, 0x07804148, 0x0aa200c8, 0x07801dc8, 0x0b806209,
+	0x00000000, 0x07800307, 0x0a608007, 0x0c781880, 0x02409209,
+	0x078016c8, 0x0a805209, 0x07c016c9, 0x0680001e, 0x07c0001e,
+	0x09408789, 0x0981d39d, 0x0981d3dd, 0x09c1d1dd, 0x0c003f80,
+	0x00000000, 0x0c008080, 0x00000000, 0x0c015140, 0x00000000,
+	0x0c0043c0, 0x00000000, 0x07804208, 0x0a610008, 0x07804247,
+	0x0fc01200, 0x0fc061c0, 0x07c00207, 0x094e11c8, 0x060c0a07,
+	0x0a61001a, 0x06800007, 0x0c7808c0, 0x07c01e07, 0x0fc011c0,
+	0x07c01e07, 0x08094200, 0x0a60c007, 0x0c780740, 0x00000000,
+	0x06815448, 0x06094208, 0x0680c008, 0x06094008, 0x07800087,
+	0x0aa18087, 0x06800047, 0x07804147, 0x0aa0c0c7, 0x06800087,
+	0x06800107, 0x0fc08200, 0x0fc08240, 0x09509248, 0x06094109,
+	0x0fc01200, 0x0fc08200, 0x0fc08240, 0x09509248, 0x06094109,
+	0x06094109, 0x0fc01200, 0x0aed4047, 0x044011c7, 0x0fc01200,
+	0x07c00048, 0x08094000, 0x078043c7, 0x0a60c007, 0x0c780540,
+	0x00000000, 0x0fc071c0, 0x080c2940, 0x07800207, 0x07804208,
+	0x094e11c8, 0x09807187, 0x098073c7, 0x060c0a07, 0x09c073c7,
+	0x09807387, 0x060c0a07, 0x0c009840, 0x080c0600, 0x064c0a07,
+	0x091c21c7, 0x0a6f8007, 0x00000000, 0x0c780100, 0x00000000,
+	0x0c009640, 0x080c0600, 0x07801e07, 0x0aa14007, 0x07800048,
+	0x094211c8, 0x05001208, 0x094411c8, 0x060c1807, 0x0cb8002d,
+	0x00000000, 0x064c0007, 0x0a2fc047, 0x00000000, 0x064c3a07,
+	0x090061c7, 0x0aaec647, 0x00000000, 0x080c0a00, 0x080c2300,
+	0x064c1e07, 0x09807547, 0x060c1e07, 0x080c2800, 0x064c1e07,
+	0x09c07747, 0x060c1e07, 0x09807747, 0x060c1e07, 0x080c0002,
+	0x0c7ec280, 0x00000000, 0x0649c015, 0x0649c116, 0x0649c217,
+	0x0649c318, 0x0809c000, 0x0809c100, 0x0809c200, 0x0809c300,
+	0x06804004, 0x0680c085, 0x06814106, 0x0c000a40, 0x00000000,
+	0x08002501, 0x08002605, 0x08002708, 0x0800290d, 0x08002815,
+	0x08002c14, 0x06800000, 0x07c01c00, 0x0cc00000, 0x00000000,
+	0x06800007, 0x07c01907, 0x07c01987, 0x07c019c7, 0x07800607,
+	0x040011c7, 0x07c01887, 0x06800047, 0x060e0c07, 0x07c01a87,
+	0x07c018c7, 0x068003c7, 0x07c00147, 0x06805c07, 0x060c2107,
+	0x080c2170, 0x06800087, 0x07c01ac7, 0x0680001f, 0x07804148,
+	0x05406208, 0x0940321a, 0x07800387, 0x09461207, 0x060c0408,
+	0x06868008, 0x07c01a48, 0x0cc00000, 0x00000000, 0x0649cf30,
+	0x064c4002, 0x064c4203, 0x02403083, 0x040080c3, 0x07c00843,
+	0x058100c3, 0x07c00883, 0x06800019, 0x07c01499, 0x07c014d9,
+	0x07c01519, 0x064c0919, 0x0680001a, 0x07c0019a, 0x07c001da,
+	0x068000c2, 0x07c04142, 0x06803fc2, 0x07c01542, 0x07c01582,
+	0x07c015c2, 0x07c01602, 0x060c0919, 0x060c1a19, 0x06932002,
+	0x060c1e02, 0x06800002, 0x060c0c02, 0x06c04042, 0x060c0d02,
+	0x0cc00000, 0x00000000, 0x0649c803, 0x0aa14003, 0x078014c2,
+	0x028020c2, 0x07c014c2, 0x0809c800, 0x07801502, 0x0aa0c002,
+	0x06800102, 0x06030502, 0x064c0003, 0x0a2100c3, 0x06800002,
+	0x0c7809c0, 0x00000000, 0x064c3a03, 0x090060c3, 0x0a60cac3,
+	0x0c780880, 0x00000000, 0x07804143, 0x0aa080c3, 0x0c780780,
+	0x064c4403, 0x091210c3, 0x0aa6c003, 0x068fffc3, 0x07801fc2,
+	0x04001082, 0x0b8190c2, 0x07c01fc2, 0x06800002, 0x07c01fc2,
+	0x07800402, 0x04001082, 0x0b8130c2, 0x07c00402, 0x064c0003,
+	0x09803203, 0x09803183, 0x09803003, 0x060c0003, 0x06800002,
+	0x064c1803, 0x095860c2, 0x09803483, 0x060c1803, 0x09c03483,
+	0x060c1803, 0x06800103, 0x06030503, 0x06800002, 0x07c01fc2,
+	0x07c00402, 0x0cc00000, 0x00000000, 0x064c442e, 0x09121bae,
+	0x0aaf802e, 0x0c7e9d80, 0x00000000, 0x0c004ac0, 0x00000000,
+	0x06818109, 0x06c34749, 0x06090709, 0x06490b09, 0x09809009,
+	0x098090c9, 0x06090b09, 0x09c09009, 0x09c090c9, 0x0962225a,
+	0x06090b09, 0x06800009, 0x06c07489, 0x02009c09, 0x06094409,
+	0x06880009, 0x06c07489, 0x02009c09, 0x06094509, 0x0cc00000,
+	0x00000000, 0x07804149, 0x0a60c0c9, 0x0cc00000, 0x00000000,
+	0x06490707, 0x09807087, 0x098070c7, 0x06090707, 0x06495107,
+	0x098073c7, 0x0cc00000, 0x06095107, 0x0cc00000, 0x00400000,
+	0x064e1210, 0x091e1410, 0x0bef0050, 0x00000000, 0x0649d910,
+	0x0900c410, 0x0aef8190, 0x07801850, 0x0aa3c090, 0x0c7821c0,
+	0x06800011, 0x06c04011, 0x060e1211, 0x078016d1, 0x0a20c051,
+	0x0680001f, 0x0688001f, 0x06c0749f, 0x0201fc1f, 0x06800010,
+	0x07c01b10, 0x0c7813c0, 0x06800110, 0x07801b11, 0x0aa08091,
+	0x0c780f00, 0x07801892, 0x0aebc092, 0x0aa3c72f, 0x07801b50,
+	0x05406410, 0x078016d1, 0x05801451, 0x0be0c051, 0x06800011,
+	0x06880011, 0x06c07491, 0x02011c11, 0x02010450, 0x04440410,
+	0x060e1310, 0x0c780340, 0x040c07d0, 0x05405410, 0x078016d1,
+	0x0be0c051, 0x06800011, 0x06880011, 0x06c07491, 0x02011c11,
+	0x02010450, 0x04420410, 0x060e1310, 0x040607d0, 0x07801952,
+	0x0aa14012, 0x06a2c211, 0x0aa0c052, 0x06a2c011, 0x06a2c111,
+	0x06c04011, 0x060e1211, 0x06800010, 0x07c01b10, 0x06800110,
+	0x0c7816c0, 0x07c01850, 0x07801991, 0x06800192, 0x02411491,
+	0x02411491, 0x02411491, 0x07801a50, 0x05409410, 0x02010450,
+	0x05403450, 0x02011c11, 0x060e1311, 0x07801952, 0x0aa34012,
+	0x06a44211, 0x0aa2c052, 0x06a44011, 0x0c780240, 0x06a44111,
+	0x0a63c0d1, 0x07801a90, 0x064e0c12, 0x09010492, 0x0b8ea490,
+	0x0cc00000, 0x00400000, 0x06c0c011, 0x060e1211, 0x0680001f,
+	0x06800010, 0x07c01b10, 0x06800150, 0x0c780e80, 0x07c01850,
+	0x078018d1, 0x0aa1c011, 0x04401451, 0x07c018d1, 0x07801891,
+	0x04401451, 0x0c780b00, 0x07c01891, 0x078019d1, 0x07c01a11,
+	0x07801a50, 0x05409410, 0x02010450, 0x06800192, 0x02011491,
+	0x07c019d1, 0x05403450, 0x02011c11, 0x060e1311, 0x07801952,
+	0x0aa14012, 0x06a16211, 0x0aa0c052, 0x06a16011, 0x06a16111,
+	0x07801bd2, 0x0aa28012, 0x07801a90, 0x064e0c12, 0x09010492,
+	0x0b804490, 0x07801a12, 0x0c7fde80, 0x07c019d2, 0x04001410,
+	0x07c01a90, 0x07c01d91, 0x06c00011, 0x060e1211, 0x06800050,
+	0x0c780400, 0x07c01850, 0x0ba30110, 0x0c7ff540, 0x0a6f8050,
+	0x07801891, 0x0aa74011, 0x04401451, 0x0b26c051, 0x07c01891,
+	0x07801ad0, 0x0aa0c0d0, 0x00000000, 0x080c2170, 0x06800010,
+	0x07c01850, 0x0cc00000, 0x00400000, 0x0aa0c010, 0x0688001f,
+	0x0680001f, 0x06c0749f, 0x0c780a40, 0x0201fc1f, 0x0aa0c72f,
+	0x090a841f, 0x090c741f, 0x07800992, 0x0b823490, 0x0a8f5490,
+	0x091a141f, 0x0aa20010, 0x0688001f, 0x0c780180, 0x0680001f,
+	0x0aa7001f, 0x07801991, 0x0c7ffcc0, 0x00000000, 0x06c0749f,
+	0x0201fc1f, 0x07801a50, 0x05409410, 0x06800192, 0x02411491,
+	0x02010450, 0x05403450, 0x02011c11, 0x060e1311, 0x07801d90,
+	0x09004450, 0x0aa14011, 0x06a14210, 0x0aa0c111, 0x06a14010,
+	0x06a14110, 0x06c08010, 0x060e0d1f, 0x0aa0c72f, 0x040207df,
+	0x040207df, 0x0c7ff4c0, 0x060e1210, 0x07801a50, 0x05409410,
+	0x02010450, 0x06800192, 0x02011491, 0x07c01991, 0x05403450,
+	0x02011c11, 0x060e1311, 0x07801d90, 0x0a61801f, 0x09c101d0,
+	0x060e1210, 0x068000d0, 0x0c7ff0c0, 0x07c01850, 0x06c08010,
+	0x060e0d1f, 0x0aae872f, 0x040207df, 0x0c7ffe00, 0x040207df,
+	0x0c000d00, 0x00000000, 0x08095007, 0x08095000, 0x07804347,
+	0x07804308, 0x094a51c8, 0x078042c8, 0x095411c8, 0x06096e07,
+	0x0aa0c008, 0x06800088, 0x06800048, 0x060c3108, 0x06800048,
+	0x0780098a, 0x068002c9, 0x0b00324a, 0x00000000, 0x06800008,
+	0x06498e0a, 0x097c1288, 0x06098e0a, 0x06497f08, 0x068000ca,
+	0x0970220a, 0x06097f08, 0x06820988, 0x06c00208, 0x0968221a,
+	0x0780098a, 0x0b20c2ca, 0x068004ca, 0x06800c0a, 0x0970620a,
+	0x0cc00000, 0x06095108, 0x0683ffc8, 0x06490909, 0x0a210049,
+	0x0aa0c008, 0x0c7fff40, 0x04401208, 0x06490b09, 0x09809009,
+	0x098090c9, 0x06090b09, 0x09c09009, 0x09c090c9, 0x06090b09,
+	0x0cc00000, 0x00000000, 0x0683ffc9, 0x0649bb08, 0x0920c208,
+	0x0649530a, 0x0900128a, 0x02008288, 0x0aa10008, 0x0aa0c009,
+	0x0c7ffe40, 0x04401249, 0x0cc00000, 0x00000000, 0x064e1209,
+	0x091e1249, 0x0bef8049, 0x064e0009, 0x064e0e0b, 0x064e0c0c,
+	0x083f0040, 0x083f0000, 0x0680020d, 0x0d00000d, 0x00000000,
+	0x060e0009, 0x060e0e0b, 0x0cc00000, 0x060e0c0c, 0x0c07fc40,
+	0x00000000, 0x06490b09, 0x09809009, 0x09809089, 0x06090b09,
+	0x09c09009, 0x09c09089, 0x06090b09, 0x08095007, 0x08095000,
+	0x0c000500, 0x00000000, 0x06800007, 0x07c00307, 0x06800007,
+	0x07c01907, 0x07c01987, 0x07c019c7, 0x07800607, 0x040011c7,
+	0x07c01887, 0x06800047, 0x060e0c07, 0x07c01a87, 0x07c018c7,
+	0x068003c7, 0x07c00147, 0x06800007, 0x0cc00000, 0x07c01847,
+	0x0683ffc9, 0x06498f0a, 0x0aa0c009, 0x0a6f800a, 0x04401249,
+	0x064c3d0a, 0x0580a28a, 0x0bef80ca, 0x00000000, 0x06498e0a,
+	0x0980a00a, 0x06800fc9, 0x09706289, 0x06098e0a, 0x06800009,
+	0x09706289, 0x09c0a00a, 0x0cc00000, 0x06098e0a, 0x064c3a08,
+	0x09006208, 0x064c0809, 0x064c090a, 0x064c1e0b, 0x064c380c,
+	0x06800407, 0x063f0007, 0x06800007, 0x063f0007, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x060c0809, 0x060c090a,
+	0x060c1e0b, 0x060c380c, 0x0c07ef00, 0x00000000, 0x06800009,
+	0x060c0c09, 0x06c04049, 0x060c0d09, 0x064c1809, 0x09586248,
+	0x09809489, 0x060c1809, 0x09c09489, 0x060c1809, 0x0cc00000,
+	0x080c0a01, 0x0680072f, 0x06bfffcb, 0x06800024, 0x07801c20,
+	0x06800021, 0x06800025, 0x06800022, 0x06800026, 0x06800023,
+	0x06800027, 0x0680800a, 0x0680070e, 0x0740028b, 0x0400128a,
+	0x074002a4, 0x0400128a, 0x074002a0, 0x0400128a, 0x074002a1,
+	0x0400128a, 0x074002a5, 0x0400128a, 0x074002a2, 0x0400128a,
+	0x074002a6, 0x0400128a, 0x074002a3, 0x0400128a, 0x074002a7,
+	0x0d07fbce, 0x0400128a, 0x07c01c4b, 0x096102cb, 0x080c0700,
+	0x060c270b, 0x09610824, 0x060c0220, 0x09610865, 0x0aa1801a,
+	0x060c0221, 0x096108a6, 0x060c0222, 0x096108e7, 0x060c0223,
+	0x0780098e, 0x0b009bce, 0x06b80007, 0x06c07487, 0x02007c07,
+	0x06035107, 0x06803f07, 0x06035207, 0x06a08007, 0x06035007,
+	0x07800007, 0x0a60c007, 0x06803fc7, 0x07c01c87, 0x06800007,
+	0x07c01d47, 0x0ac0bbce, 0x07801c87, 0x0b613fc7, 0x0ba0c707,
+	0x0441c1c7, 0x07c01c87, 0x06435007, 0x0580f1c7, 0x0bef8047,
+	0x0cc00000, 0x00000000, 0x06435007, 0x0580f1c7, 0x0bef8047,
+	0x00000000, 0x06435307, 0x0900c1c7, 0x0a6f8007, 0x00000000,
+	0x06b80007, 0x06c07487, 0x02007c07, 0x06035107, 0x06803f07,
+	0x06035207, 0x06b0c007, 0x06035007, 0x054011ef, 0x0ac051ce,
+	0x06800087, 0x07c01cc7, 0x0c7ff880, 0x07c01d07, 0x06b90008,
+	0x06c07488, 0x02008c08, 0x0540126f, 0x02009bc9, 0x0680008a,
+	0x07c01cca, 0x068000ca, 0x06435007, 0x0580f1c7, 0x0bef8047,
+	0x06803f07, 0x06035108, 0x06035207, 0x06a08007, 0x06035007,
+	0x0ac0324e, 0x0c7ff3c0, 0x07c01d0a, 0x06808007, 0x020081c8,
+	0x02009bc9, 0x0c7ffc80, 0x0400128a, 0x0400130c, 0x0480f30c,
+	0x07c01d0c, 0x0980b38b, 0x07801ccc, 0x0540928c, 0x0200a24a,
+	0x0400130c, 0x0480f30c, 0x07c01ccc, 0x0643500c, 0x0580f30c,
+	0x06c0748a, 0x0bef404c, 0x0200ac0a, 0x0643530c, 0x0900c30c,
+	0x0a6f800c, 0x00000000, 0x0603510a, 0x06803f0a, 0x0603520a,
+	0x0c7fedc0, 0x0603500b, 0x064c2307, 0x0befc047, 0x0cc00000,
+	0x064c2007, 0x040011c7, 0x06800008, 0x0a20c047, 0x058011c7,
+	0x024071c8, 0x0cc00000, 0x00000000, 0x02409247, 0x048ff249,
+	0x05401249, 0x02407207, 0x048ff1c7, 0x054011c7, 0x0680000a,
+	0x0680000b, 0x06800048, 0x0b8041c8, 0x054012cb, 0x0980b04b,
+	0x024081c8, 0x05401208, 0x0b2ec20a, 0x0400128a, 0x058012cb,
+	0x0e0002c9, 0x00000000, 0x00000000, 0x0cc00000, 0x0f000240,
+	0x02409247, 0x06807fca, 0x02809289, 0x02407207, 0x06807fca,
+	0x02807287, 0x0680000a, 0x0680000b, 0x06800048, 0x0b8041c8,
+	0x054012cb, 0x0980b04b, 0x024081c8, 0x05401208, 0x0b2ec20a,
+	0x0400128a, 0x058012cb, 0x0e0002c9, 0x00000000, 0x00000000,
+	0x0cc00000, 0x0f000240, 0x024091c9, 0x06807fca, 0x02809289,
+	0x024071c8, 0x06807fca, 0x02807287, 0x0680000a, 0x0680000b,
+	0x06800048, 0x0b8041c8, 0x054012cb, 0x0980b04b, 0x024081c8,
+	0x05401208, 0x0b2ec20a, 0x0400128a, 0x058012cb, 0x0e0002c9,
+	0x00000000, 0x00000000, 0x0cc00000, 0x0f000240, 0x02407207,
+	0x06807fca, 0x02807287, 0x0680000a, 0x0680000b, 0x06800048,
+	0x0b8041c8, 0x054012cb, 0x0980b04b, 0x024081c8, 0x05401208,
+	0x0b2ec34a, 0x0400128a, 0x0cc00000, 0x0580124b, 0x07804187,
+	0x0a60c007, 0x06800088, 0x06800048, 0x07c04148, 0x0a60c01a,
+	0x068057ad, 0x0680005a, 0x0cc00000, 0x00000000, 0x024091c9,
+	0x06807fc8, 0x02809209, 0x0680000a, 0x0680000b, 0x06800048,
+	0x0b8041c8, 0x054012cb, 0x0980b04b, 0x024081c8, 0x05401208,
+	0x0b2ec20a, 0x0400128a, 0x058012cb, 0x0e0002c9, 0x00000000,
+	0x00000000, 0x0cc00000, 0x0f000240, 0x0aa1409a, 0x0aa0801a,
+	0x0c784cc0, 0x0cc00000, 0x00000000, 0x07801ec7, 0x07801e88,
+	0x02407207, 0x048ff1c7, 0x054011c7, 0x07c00447, 0x07801f07,
+	0x07801e88, 0x02407207, 0x048ff1c7, 0x054011c7, 0x07c00487,
+	0x07804149, 0x0aa140c9, 0x07800389, 0x0a60c009, 0x00000000,
+	0x044011c7, 0x0c07f580, 0x07800449, 0x06800f88, 0x09646248,
+	0x060c3009, 0x07800487, 0x07804149, 0x0aa280c9, 0x07800389,
+	0x0aa0c009, 0x00000000, 0x040011c7, 0x0c07f280, 0x07800449,
+	0x06800fc8, 0x09646248, 0x060c3009, 0x07804147, 0x0aa080c7,
+	0x0c780bc0, 0x07801e88, 0x05401208, 0x07801ec7, 0x0c07e980,
+	0x054011c7, 0x06800c08, 0x09646248, 0x060c3009, 0x07801e48,
+	0x05401208, 0x07801ec7, 0x0c07e780, 0x054011c7, 0x06800c48,
+	0x09646248, 0x060c3009, 0x07801f07, 0x07801e88, 0x02407207,
+	0x048ff1c7, 0x05401247, 0x07801ec7, 0x07801f08, 0x02407207,
+	0x048ff1c7, 0x054011c7, 0x09529247, 0x06800d08, 0x09646248,
+	0x060c3009, 0x07801f07, 0x07801e88, 0x0c07d1c0, 0x07801e89,
+	0x06800808, 0x09646248, 0x060c3009, 0x07801ec7, 0x07801f08,
+	0x0c07d000, 0x07801f09, 0x06800888, 0x09646248, 0x060c3009,
+	0x0cc00000, 0x00000000, 0x07801f8c, 0x0aa0c00c, 0x0780038c,
+	0x0680000c, 0x0a61c00c, 0x07801ec7, 0x054011c7, 0x07801e88,
+	0x05401208, 0x0c780180, 0x04001208, 0x07801ec7, 0x054011c7,
+	0x040011c7, 0x04401207, 0x0c07db00, 0x00000000, 0x06800c08,
+	0x09646248, 0x0a60c00c, 0x00000000, 0x098093c9, 0x060c3009,
+	0x0a61800c, 0x07801ec7, 0x054011c7, 0x07801e88, 0x0c780200,
+	0x05401208, 0x07801ec7, 0x054011c7, 0x040011c7, 0x07801e88,
+	0x05401208, 0x04001208, 0x0c07d600, 0x00000000, 0x06800c48,
+	0x09646248, 0x0aa0c00c, 0x00000000, 0x098093c9, 0x060c3009,
+	0x0a61c00c, 0x07801ec7, 0x054011c7, 0x07801e48, 0x05401208,
+	0x0c7801c0, 0x04001208, 0x07801ec7, 0x054011c7, 0x040011c7,
+	0x07801e88, 0x05401208, 0x0c07d100, 0x00000000, 0x06800c88,
+	0x09646248, 0x060c3009, 0x0a61800c, 0x07801ec7, 0x054011c7,
+	0x07801e48, 0x0c780200, 0x05401208, 0x07801ec7, 0x054011c7,
+	0x040011c7, 0x07801e48, 0x05401208, 0x04001208, 0x0c07ccc0,
+	0x00000000, 0x06800cc8, 0x09646248, 0x060c3009, 0x0780038c,
+	0x07801f07, 0x0aa0c00c, 0x054011c7, 0x040011c7, 0x07801e88,
+	0x05401208, 0x02407207, 0x06807fca, 0x02809287, 0x07801ec7,
+	0x0aa1800c, 0x054011c7, 0x07801f88, 0x0a60c008, 0x00000000,
+	0x040011c7, 0x07801f08, 0x0aa0c00c, 0x05401208, 0x04001208,
+	0x02407207, 0x02807287, 0x09529247, 0x06800d08, 0x09646248,
+	0x060c3009, 0x07801f07, 0x0aa0c00c, 0x054011c7, 0x040011c7,
+	0x07801e88, 0x05401208, 0x04001208, 0x02407207, 0x06807fca,
+	0x02809287, 0x07801ec7, 0x0aa1800c, 0x054011c7, 0x07801f88,
+	0x0a60c008, 0x00000000, 0x040011c7, 0x07801f08, 0x0aa0c00c,
+	0x05401208, 0x04001208, 0x02407207, 0x02807287, 0x09529247,
+	0x06800d48, 0x09646248, 0x060c3009, 0x0aa0c00c, 0x0680000c,
+	0x0680004c, 0x07801f07, 0x054011c7, 0x02007307, 0x07801e88,
+	0x05401208, 0x04001208, 0x0c07b0c0, 0x04000248, 0x06800808,
+	0x09646248, 0x060c3009, 0x07801f07, 0x054011c7, 0x02007307,
+	0x07801e88, 0x05401208, 0x0c07ae40, 0x04001248, 0x06800848,
+	0x09646248, 0x060c3009, 0x07801f07, 0x054011c7, 0x02007307,
+	0x07801ec8, 0x05401208, 0x0c07b140, 0x04000248, 0x06800888,
+	0x09646248, 0x060c3009, 0x07801f07, 0x054011c7, 0x02007307,
+	0x07801ec8, 0x05401208, 0x04001208, 0x0c07ae80, 0x04401248,
+	0x068008c8, 0x09646248, 0x060c3009, 0x07801f07, 0x054011c7,
+	0x02007307, 0x07801e88, 0x05401208, 0x04001208, 0x0c07a640,
+	0x04401248, 0x06800908, 0x09646248, 0x060c3009, 0x07801f07,
+	0x054011c7, 0x02007307, 0x07801e88, 0x05401208, 0x0c07a3c0,
+	0x04000248, 0x06800948, 0x09646248, 0x060c3009, 0x07801f07,
+	0x054011c7, 0x02007307, 0x07801ec8, 0x05401208, 0x0c07a6c0,
+	0x04001248, 0x06800988, 0x09646248, 0x060c3009, 0x07801f07,
+	0x054011c7, 0x02007307, 0x07801ec8, 0x05401208, 0x04001208,
+	0x0c07a400, 0x04400248, 0x068009c8, 0x09646248, 0x060c3009,
+	0x0cc00000, 0x00000000, 0x07804147, 0x0aa080c7, 0x0c7807c0,
+	0x07801f07, 0x07801e88, 0x0c079600, 0x07801e89, 0x06800808,
+	0x09646248, 0x060c3009, 0x07801ec7, 0x07801e48, 0x0c079440,
+	0x07801e89, 0x06800848, 0x09646248, 0x060c3009, 0x07801ec7,
+	0x07801e88, 0x0c079280, 0x07801e49, 0x06800908, 0x09646248,
+	0x060c3009, 0x07801ec7, 0x07801e48, 0x0c0790c0, 0x07801e49,
+	0x06800948, 0x09646248, 0x060c3009, 0x0cc00000, 0x00000000,
+	0x0780038c, 0x0aa0800c, 0x0c780880, 0x0680080d, 0x07801f07,
+	0x054011c7, 0x0900230d, 0x07801e88, 0x05401208, 0x0aa2004c,
+	0x0aa1c00c, 0x04001208, 0x07801e48, 0x05401208, 0x0aa0c0cc,
+	0x00000000, 0x04001208, 0x0904230d, 0x07801e89, 0x05401249,
+	0x0aa2004c, 0x0aa1c00c, 0x04001249, 0x07801e49, 0x05401249,
+	0x0aa0c0cc, 0x00000000, 0x04001249, 0x0c078d80, 0x00000000,
+	0x0964624d, 0x060c3009, 0x0ba90bcd, 0x0400134d, 0x0cc00000,
+	0x00000000, 0x0680080d, 0x07801f07, 0x054011c7, 0x040011c7,
+	0x0900230d, 0x07801f08, 0x0aa2800c, 0x05401208, 0x07801e88,
+	0x05401208, 0x0aa1808c, 0x0aa1404c, 0x04001208, 0x07801e48,
+	0x05401208, 0x04001208, 0x0904230d, 0x07801f09, 0x0aa2800c,
+	0x05401249, 0x07801e89, 0x05401249, 0x0aa1808c, 0x0aa1404c,
+	0x04001249, 0x07801e49, 0x05401249, 0x04001249, 0x0c078480,
+	0x00000000, 0x0964624d, 0x060c3009, 0x0ba84bcd, 0x0400134d,
+	0x0cc00000, 0x00000000, 0x07804147, 0x0a6140c7, 0x06099004,
+	0x06099105, 0x0c780240, 0x06099206, 0x06099004, 0x06099104,
+	0x06099205, 0x06099305, 0x06099406, 0x0c780080, 0x06099506,
+	0x0aa3c09a, 0x0aa0805a, 0x0cc00000, 0x07804147, 0x0698d908,
+	0x0aa1c0c7, 0x06d85888, 0x0688d108, 0x0aa10087, 0x06c85088,
+	0x06910948, 0x06d088c8, 0x080c2400, 0x0cc00000, 0x060c2208,
+	0x07804147, 0x0698d908, 0x0aa100c7, 0x06d85888, 0x06800008,
+	0x06d088c8, 0x080c2400, 0x060c2208, 0x07804147, 0x069898c8,
+	0x0aa100c7, 0x06d81848, 0x06800008, 0x06c85008, 0x080c2408,
+	0x0cc00000, 0x060c2208
+};
diff --git a/drivers/amlogic/amports/arch/ucode/avs/gxm_avs_linux_debug.h b/drivers/amlogic/amports/arch/ucode/avs/gxm_avs_linux_debug.h
new file mode 100644
index 0000000..fbd61d6
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/avs/gxm_avs_linux_debug.h
@@ -0,0 +1,549 @@
+/*
+ * drivers/amlogic/amports/arch/ucode/avs/gxm_avs_linux_debug.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+/* ucode commit id: 1c4f555b8e1 */
+static const u32 MicroCode[] __initconst = {
+	0x06807801, 0x06800000, 0x0d000001, 0x07400040, 0x0c014e00,
+	0x00000000, 0x00000000, 0x00000000, 0x080c0002, 0x06932000,
+	0x09800580, 0x060c1e00, 0x06bfdac0, 0x07c017c0, 0x06030400,
+	0x00400000, 0x0c016040, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x0c7ffec0, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c780540, 0x064c0007, 0x0c796980, 0x00000000,
+	0x0c797380, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c797200, 0x00000000, 0x0cc00000, 0x00400000,
+	0x06800009, 0x07c01fc9, 0x07c00409, 0x00800000, 0x078017c9,
+	0x0c7ffe40, 0x06030409, 0x06bfd9c9, 0x06030409, 0x00400000,
+	0x0a2d8047, 0x07801509, 0x0aa14009, 0x0a608049, 0x0c78fc80,
+	0x0a608089, 0x0c78f140, 0x0a23c807, 0x0c786380, 0x00000000,
+	0x0649d008, 0x0aa0c008, 0x0809c701, 0x0c780000, 0x0c01ac80,
+	0x080c0a00, 0x0c01afc0, 0x00000000, 0x0c01c280, 0x00000000,
+	0x0c7935c0, 0x00000000, 0x0becd007, 0x078043c8, 0x0aa0c008,
+	0x0a208207, 0x0c793440, 0x078003c7, 0x0a6fc007, 0x078043c7,
+	0x0a648007, 0x064c2907, 0x0be2c407, 0x07800007, 0x0a638007,
+	0x00000000, 0x064c2907, 0x091c11c7, 0x0a628047, 0x00000000,
+	0x064c0607, 0x0900f1c7, 0x0ae18047, 0x068025f1, 0x0c027840,
+	0x078025f2, 0x0c792f40, 0x00000000, 0x0cb8002d, 0x00000000,
+	0x068fdfca, 0x064e0408, 0x02808288, 0x02c08748, 0x060e0408,
+	0x060c071e, 0x064c0324, 0x064c0325, 0x064c2728, 0x09210268,
+	0x07800007, 0x0a618007, 0x07801c08, 0x06c00008, 0x060c0208,
+	0x080c0200, 0x06bfffc9, 0x060c0320, 0x060c0321, 0x07801c48,
+	0x09610209, 0x060c2708, 0x07801847, 0x0a6fc007, 0x07800147,
+	0x07c01b87, 0x06800347, 0x07c00147, 0x060c2507, 0x080c2602,
+	0x080c260f, 0x080c2603, 0x04c001c7, 0x09807207, 0x060c2107,
+	0x07801907, 0x0aa14007, 0x06a01008, 0x0aa0c047, 0x06a22008,
+	0x06a40008, 0x06c00108, 0x060e0508, 0x07801b08, 0x06801809,
+	0x09502248, 0x060c2109, 0x080c260e, 0x06800088, 0x07c01947,
+	0x0ba0c087, 0x040011c7, 0x06800007, 0x07c01907, 0x07800007,
+	0x07c01b47, 0x07801b87, 0x07c01bc7, 0x07c01848, 0x08030580,
+	0x07801d47, 0x0aa1472f, 0x040011c7, 0x078016c8, 0x0a20c048,
+	0x00000000, 0x07c01d47, 0x0683ffc8, 0x064c2307, 0x093041c7,
+	0x0aa0c008, 0x0a6f4007, 0x04401208, 0x07801c8d, 0x0ba13fcd,
+	0x06800008, 0x0c781100, 0x07c01c88, 0x06808008, 0x0ba1070d,
+	0x0400024d, 0x0441c249, 0x0680c008, 0x05403289, 0x0200a24a,
+	0x02008288, 0x07400228, 0x04001208, 0x092102e4, 0x0740020b,
+	0x04001208, 0x07400224, 0x04001208, 0x07400225, 0x04001208,
+	0x092102e5, 0x0740020b, 0x04001208, 0x07400226, 0x04001208,
+	0x092102e6, 0x0740020b, 0x04001208, 0x07400227, 0x04001208,
+	0x092102e7, 0x0740020b, 0x07800988, 0x0ac07bc8, 0x0780000a,
+	0x0aa3872f, 0x040002ca, 0x078016ca, 0x0c7802c0, 0x0942f28b,
+	0x0a61000a, 0x0aa1472f, 0x078016ca, 0x0a20c04a, 0x0a6146c9,
+	0x0400128d, 0x0b60c70d, 0x0680000a, 0x0680070a, 0x07c01c8a,
+	0x0b013bc8, 0x0aa0800a, 0x0a64470a, 0x07801cca, 0x0a20c04a,
+	0x06a0800b, 0x06a0c00b, 0x06b80009, 0x07801d0c, 0x0540928c,
+	0x0200a24a, 0x06c0748a, 0x0200ac0a, 0x0603510a, 0x06803f0a,
+	0x0603520a, 0x0603500b, 0x0c01bc40, 0x00000000, 0x07800007,
+	0x040011c7, 0x07c00007, 0x09c1d39d, 0x07800988, 0x0b405207,
+	0x040011c7, 0x0b836207, 0x0c780d40, 0x0981d1dd, 0x06800007,
+	0x07c00007, 0x0981d39d, 0x09c1d3dd, 0x09c1d1dd, 0x078016c8,
+	0x04001208, 0x068000b1, 0x0c024e40, 0x04000c88, 0x07801dc9,
+	0x0b828248, 0x07c016c8, 0x07801847, 0x0a6fc007, 0x00000000,
+	0x06430507, 0x0a2f0107, 0x06a00007, 0x060c3d07, 0x07800147,
+	0x0aa24007, 0x06803fcb, 0x07801a88, 0x064e0c09, 0x09010249,
+	0x0b804248, 0x0aa0c00b, 0x0c7ffec0, 0x044012cb, 0x07804147,
+	0x0aa280c7, 0x07800347, 0x07801dc8, 0x0b407207, 0x0c01cd80,
+	0x07c00348, 0x06800048, 0x07c00308, 0x0c789a40, 0x07c00388,
+	0x06800008, 0x07c00308, 0x07c00388, 0x0c78fcc0, 0x064c0007,
+	0x0b60c709, 0x06808008, 0x0680c008, 0x0c780400, 0x06800007,
+	0x07800007, 0x09508787, 0x078016c9, 0x09408789, 0x07800989,
+	0x0b009bc9, 0x06808008, 0x0aad0007, 0x07801c89, 0x040011c9,
+	0x0ba10707, 0x0b6c0e07, 0x0680c008, 0x0441c1c7, 0x05403247,
+	0x020091c9, 0x02008248, 0x07000209, 0x07c01c49, 0x04001208,
+	0x07000209, 0x04001208, 0x07000220, 0x09610809, 0x04001208,
+	0x07000221, 0x04001208, 0x07000209, 0x09610849, 0x04001208,
+	0x07000222, 0x04001208, 0x07000209, 0x09610889, 0x04001208,
+	0x07000223, 0x04001208, 0x07000209, 0x096108c9, 0x0c7fb400,
+	0x00000000, 0x068fdfca, 0x064e0408, 0x02808288, 0x02c08748,
+	0x060e0408, 0x060c071e, 0x064c0324, 0x064c0325, 0x064c0326,
+	0x064c0327, 0x064c2728, 0x060c071e, 0x09210268, 0x07800007,
+	0x0a638007, 0x07801c08, 0x06c00008, 0x060c0208, 0x06800008,
+	0x06c00008, 0x060c0208, 0x06800008, 0x06c00008, 0x060c0208,
+	0x06800008, 0x06c00008, 0x060c0208, 0x06bfffc9, 0x060c0320,
+	0x060c0321, 0x060c0322, 0x060c0323, 0x07801c48, 0x09610209,
+	0x060c2708, 0x07804287, 0x054031c7, 0x04c301c7, 0x07801f8a,
+	0x095011ca, 0x060c2507, 0x0780184a, 0x0a6fc00a, 0x07800147,
+	0x07c01b87, 0x064c2307, 0x09304207, 0x0a6f8008, 0x090a1207,
+	0x090241c7, 0x095211c8, 0x064c0609, 0x09010249, 0x0aa10009,
+	0x00000000, 0x06800007, 0x06800008, 0x07c00147, 0x0aa60347,
+	0x060c2507, 0x0aa60287, 0x0aa18048, 0x0a60c007, 0x0c780200,
+	0x00000000, 0x080c2605, 0x080c2606, 0x080c2607, 0x080c2602,
+	0x080c260f, 0x080c2603, 0x07801ac8, 0x0aa100c8, 0x06800089,
+	0x0c7fb800, 0x07c01ac9, 0x0780184b, 0x0a6fc00b, 0x00000000,
+	0x07c01b08, 0x0c7fb680, 0x07c01ac9, 0x080c2602, 0x080c260f,
+	0x080c2603, 0x07801ac8, 0x0aa48088, 0x068000c9, 0x07800008,
+	0x0aa0c008, 0x0c7fb400, 0x07c01ac9, 0x06803fcb, 0x07801a88,
+	0x064e0c09, 0x09010249, 0x0b804248, 0x0aa0c00b, 0x0c7ffec0,
+	0x044012cb, 0x06800088, 0x068000c9, 0x0680180b, 0x060c210b,
+	0x0780184b, 0x0a6fc00b, 0x00000000, 0x07c01b08, 0x0c7faf80,
+	0x07c01ac9, 0x0be0d007, 0x0c7807c0, 0x00000000, 0x00000000,
+	0x0649d00a, 0x0aa0c00a, 0x0809c701, 0x0c780000, 0x0c014880,
+	0x080c0a00, 0x0c014bc0, 0x00000000, 0x0c0159c0, 0x00000000,
+	0x064c000a, 0x09c0a18a, 0x0980a20a, 0x0980a00a, 0x060c000a,
+	0x080c2300, 0x064c1e08, 0x09c081c8, 0x09808008, 0x060c1e08,
+	0x098081c8, 0x09c08008, 0x060c1e08, 0x064c080a, 0x0980a34a,
+	0x060c080a, 0x0c014d80, 0x00000000, 0x064c1a07, 0x0aa10007,
+	0x06800008, 0x0c78cc80, 0x00000000, 0x064c1e0a, 0x0980a60a,
+	0x060c1e0a, 0x06809009, 0x060c0809, 0x064c1c0a, 0x0a213fca,
+	0x064c1e0a, 0x09c0a74a, 0x060c1e0a, 0x0980a74a, 0x0980a7ca,
+	0x060c1e0a, 0x0fc08280, 0x06800071, 0x0c0210c0, 0x04000c8a,
+	0x0aa3ec0a, 0x0649c108, 0x0aa2c008, 0x0aa12cca, 0x0aa1ad8a,
+	0x0ae22bca, 0x0c78a800, 0x06800007, 0x0c780980, 0x07c00387,
+	0x06800007, 0x0c781ec0, 0x07c00387, 0x0c78c480, 0x00000000,
+	0x0fc08280, 0x07c0400a, 0x0609c40a, 0x0fc08280, 0x0fc01280,
+	0x0500128a, 0x07c0404a, 0x0fc0e1c0, 0x07c04087, 0x0609c107,
+	0x0fc0e1c0, 0x07c040c7, 0x0609c207, 0x0fc021c0, 0x0fc031c0,
+	0x0fc041c0, 0x0609c007, 0x0fc041c0, 0x0609c307, 0x0fc091c0,
+	0x0fc091c0, 0x0fc011c0, 0x0fc0c1c0, 0x0fc011c0, 0x07c04107,
+	0x0fc011c0, 0x0fc091c0, 0x0fc091c0, 0x0fc031c0, 0x0c78bcc0,
+	0x00000000, 0x06800007, 0x07c01f87, 0x07804007, 0x0a611207,
+	0x0fc101c0, 0x0fc011c0, 0x0fc071c0, 0x0fc011c0, 0x0aa10007,
+	0x00000000, 0x0fc0c1c0, 0x0fc0c1c0, 0x0fc011c0, 0x07800a47,
+	0x07c00a07, 0x07800a87, 0x07c00a47, 0x0fc081c0, 0x07c00a87,
+	0x07804107, 0x0aa10007, 0x0c016e80, 0x080c2301, 0x07c01f47,
+	0x0fc011c0, 0x07800a88, 0x095c1207, 0x07c00a88, 0x050011c7,
+	0x07c01807, 0x0aa30007, 0x068000c8, 0x0fc011c0, 0x0a624007,
+	0x068000c8, 0x0fc011c0, 0x07c04187, 0x0a60c007, 0x06800048,
+	0x06800088, 0x0c780140, 0x07c04148, 0x07c04148, 0x0fc011c0,
+	0x07c04187, 0x0fc011c0, 0x07c041c7, 0x0fc011c0, 0x07c04207,
+	0x0fc061c0, 0x07c04247, 0x06800087, 0x07c00087, 0x06800808,
+	0x060c2108, 0x07801807, 0x0aa18007, 0x06800008, 0x07804147,
+	0x0aa0c0c7, 0x00000000, 0x0fc01200, 0x07c04288, 0x0fc041c0,
+	0x0fc011c0, 0x07c042c7, 0x0a648007, 0x06800008, 0x0fc011c0,
+	0x0aa34007, 0x06800009, 0x0c016200, 0x080c2301, 0x0c016280,
+	0x00000000, 0x07c04307, 0x0c0160c0, 0x080c2301, 0x0c016140,
+	0x00000000, 0x0c780100, 0x07c04347, 0x07c04308, 0x07c04349,
+	0x06800007, 0x07c00107, 0x0c782ac0, 0x0680001a, 0x07804007,
+	0x0a611207, 0x0fc101c0, 0x0fc011c0, 0x0fc071c0, 0x0fc021c0,
+	0x0a60c047, 0x0c780180, 0x0680005a, 0x0fc081c0, 0x07c00ac7,
+	0x0c780240, 0x0680009a, 0x07800a47, 0x07c00a07, 0x07800a87,
+	0x07c00a47, 0x0fc081c0, 0x07c00a87, 0x07c00ac7, 0x06800271,
+	0x0c01e980, 0x04000c9a, 0x07804107, 0x0aa10007, 0x0c015780,
+	0x080c2301, 0x07c01f47, 0x0fc011c0, 0x07800ac8, 0x095c1207,
+	0x0aa0c09a, 0x07c00ac8, 0x07c00a88, 0x050011c7, 0x07c01807,
+	0x0aa34007, 0x068000c8, 0x0fc011c0, 0x0a628007, 0x068000c8,
+	0x0fc011c0, 0x0fc011c0, 0x07c04187, 0x0a60c007, 0x06800048,
+	0x06800088, 0x0c780140, 0x07c04148, 0x07c04148, 0x0fc011c0,
+	0x07c04187, 0x0fc011c0, 0x07c041c7, 0x0fc011c0, 0x07c04207,
+	0x0fc061c0, 0x07c04247, 0x07800ac7, 0x048ff207, 0x07c01f08,
+	0x091c11c7, 0x0aa5c007, 0x07800a07, 0x091c1207, 0x0a610008,
+	0x048ff1c7, 0x054011c7, 0x048ff1c7, 0x07c01e47, 0x07800a47,
+	0x091c1207, 0x0a610008, 0x048ff1c7, 0x054011c7, 0x048ff1c7,
+	0x07c01e87, 0x07800a87, 0x091c1207, 0x0a610008, 0x048ff1c7,
+	0x054011c7, 0x048ff1c7, 0x0c780b40, 0x07c01ec7, 0x07800a07,
+	0x091c1207, 0x0aa2c008, 0x048ff1c7, 0x058011c7, 0x07801f08,
+	0x0b4031c8, 0x06804009, 0x02008248, 0x024091c8, 0x0ba0e009,
+	0x0c7fff80, 0x040801c7, 0x07c01e47, 0x07800a47, 0x091c1207,
+	0x0aa2c008, 0x048ff1c7, 0x058011c7, 0x07801f08, 0x0b4031c8,
+	0x06804009, 0x02008248, 0x024091c8, 0x0ba0e009, 0x0c7fff80,
+	0x040801c7, 0x07c01e87, 0x07800a87, 0x091c1207, 0x0aa2c008,
+	0x048ff1c7, 0x058011c7, 0x07801f08, 0x0b0031c8, 0x06804009,
+	0x02408248, 0x02409207, 0x0ba0e009, 0x0c7fff80, 0x044801c7,
+	0x048ff1c7, 0x07c01ec7, 0x0a61409a, 0x07804147, 0x0a60c0c7,
+	0x0c780240, 0x06800808, 0x0fc011c0, 0x07c00087, 0x0a6f0007,
+	0x06800808, 0x06800047, 0x09505207, 0x09605207, 0x060c2108,
+	0x0fc011c0, 0x0fc011c0, 0x07c01f87, 0x0fc021c0, 0x0fc011c0,
+	0x07c04287, 0x0fc011c0, 0x07c042c7, 0x0a648007, 0x06800008,
+	0x0fc011c0, 0x0aa34007, 0x06800009, 0x0c013740, 0x080c2301,
+	0x0c0137c0, 0x00000000, 0x07c04307, 0x0c013600, 0x080c2301,
+	0x0c013680, 0x00000000, 0x0c780100, 0x07c04347, 0x07c04308,
+	0x07c04349, 0x06800007, 0x07c00107, 0x07804007, 0x0aa25207,
+	0x00000000, 0x06802007, 0x06c02007, 0x060e1907, 0x060e1a07,
+	0x060e1b07, 0x0c781640, 0x00000000, 0x0fc011c0, 0x064e1c09,
+	0x097e1247, 0x0aa20047, 0x060e1c09, 0x06802007, 0x06c02007,
+	0x060e1907, 0x060e1a07, 0x0c781200, 0x060e1b07, 0x0fc011c0,
+	0x0fc011c0, 0x06800009, 0x07c01109, 0x0a630007, 0x07c01149,
+	0x0c012cc0, 0x080c2301, 0x0c012d40, 0x00000000, 0x07c01107,
+	0x0c012b80, 0x080c2301, 0x0c012c00, 0x00000000, 0x07c01147,
+	0x0fc021c0, 0x0fc02200, 0x064e1c09, 0x09602248, 0x07801108,
+	0x09405248, 0x07801148, 0x09505248, 0x060e1c09, 0x0aa30047,
+	0x06802008, 0x07c01188, 0x06801888, 0x07c011c8, 0x06801a88,
+	0x07c01208, 0x06801d08, 0x07c01248, 0x07c01288, 0x0c7802c0,
+	0x06802008, 0x068021c8, 0x07c01188, 0x068023c8, 0x07c011c8,
+	0x07c01208, 0x06802808, 0x07c01248, 0x07c01288, 0x06803548,
+	0x07c012c8, 0x0aa2c007, 0x06801189, 0x0c012200, 0x080c2301,
+	0x0c012280, 0x00000000, 0x07000248, 0x020081c8, 0x07400248,
+	0x0bae52c9, 0x04001249, 0x07801188, 0x078011c9, 0x09609209,
+	0x060e1908, 0x07801208, 0x07801249, 0x09609209, 0x060e1a08,
+	0x07801288, 0x078012c9, 0x09609209, 0x060e1b08, 0x0fc011c0,
+	0x07c043c7, 0x0aa0c007, 0x06800007, 0x0687ffc7, 0x07c01c07,
+	0x064c510a, 0x064c4607, 0x07800888, 0x05410208, 0x07800849,
+	0x02008248, 0x05802208, 0x0e000288, 0x00000000, 0x00000000,
+	0x00000000, 0x0f000200, 0x0f010280, 0x0970820a, 0x05402208,
+	0x020081c8, 0x064c430a, 0x02408288, 0x064c400a, 0x02408288,
+	0x07c008c8, 0x05810208, 0x07c00908, 0x0c0133c0, 0x00000000,
+	0x0680001e, 0x07c0001e, 0x07c016de, 0x0981d39e, 0x0981d3dd,
+	0x09c1d1dd, 0x07804087, 0x0400f1c7, 0x058041c7, 0x060c0907,
+	0x07c00987, 0x04401247, 0x07c00609, 0x09708789, 0x05404287,
+	0x078040c8, 0x0400f208, 0x05804208, 0x05404248, 0x04401249,
+	0x05402249, 0x07c009c8, 0x07804149, 0x0aa0c0c9, 0x04000248,
+	0x05801249, 0x07c01dc9, 0x04401248, 0x09608789, 0x04000248,
+	0x09610247, 0x06095209, 0x05404208, 0x0780408a, 0x0400f28a,
+	0x0580428a, 0x0540428a, 0x078040c8, 0x0400f208, 0x05804208,
+	0x05404208, 0x0961020a, 0x06090808, 0x0c005dc0, 0x07c0095a,
+	0x06a00007, 0x060c3d07, 0x064c3d08, 0x09161208, 0x0a6f8008,
+	0x06800008, 0x06c06c08, 0x0aa1009a, 0x02008c08, 0x0c780400,
+	0x060c3808, 0x05803208, 0x07804147, 0x0aa200c7, 0x06800109,
+	0x0aa18047, 0x06800009, 0x07801f87, 0x0aa0c007, 0x068000c9,
+	0x06800009, 0x097a3209, 0x060c3908, 0x06bfffc8, 0x060c3808,
+	0x0c00c140, 0x00000000, 0x0c00c480, 0x00000000, 0x0c00d280,
+	0x00000000, 0x069898c8, 0x06d81848, 0x06800707, 0x0d000007,
+	0x060c2208, 0x07800387, 0x0aa10007, 0x06800007, 0x0c7f0b40,
+	0x07c00387, 0x0649c909, 0x0aa10009, 0x06800087, 0x0c7f0a00,
+	0x07c01507, 0x07801487, 0x0a608007, 0x0c780900, 0x044011c7,
+	0x0aa0c087, 0x07801549, 0x078015c9, 0x0ae7c0c9, 0x040801c9,
+	0x070001c7, 0x054101c7, 0x040a0209, 0x07000208, 0x094101c8,
+	0x0609cb07, 0x040b01c9, 0x070001c7, 0x078010c8, 0x020081c8,
+	0x0609ca08, 0x07c010d9, 0x040d01c9, 0x070001c7, 0x054101c7,
+	0x040c0209, 0x07000208, 0x094101c8, 0x0609cc07, 0x04090209,
+	0x04001249, 0x07000208, 0x09464248, 0x07801808, 0x094e1248,
+	0x0609c909, 0x08007401, 0x06800009, 0x07c01489, 0x06800009,
+	0x07c01509, 0x078014c7, 0x02c07247, 0x04000295, 0x0a238047,
+	0x06800008, 0x04000296, 0x0a22c087, 0x06800048, 0x04000297,
+	0x0a220107, 0x06800088, 0x04000298, 0x0a214207, 0x068000c8,
+	0x06800047, 0x0c7efbc0, 0x07c01507, 0x07801607, 0x090041c7,
+	0x0a8051c8, 0x0aa2001a, 0x07801607, 0x090841c7, 0x0a4051c8,
+	0x06800047, 0x03407207, 0x0c7ff980, 0x02c091c9, 0x078008c7,
+	0x040c0248, 0x07400247, 0x07800907, 0x04010249, 0x07400247,
+	0x07804187, 0x054031c7, 0x02c07687, 0x04090248, 0x07400247,
+	0x040801c8, 0x07801049, 0x074001c9, 0x040a01c8, 0x07801009,
+	0x0a60c05a, 0x074001c9, 0x040006c8, 0x0a62009a, 0x040b01c8,
+	0x074001d9, 0x07000709, 0x0aa1c009, 0x04401249, 0x0c780140,
+	0x07400709, 0x07801089, 0x074001c9, 0x04000707, 0x07c01099,
+	0x06800231, 0x0c017640, 0x04000c88, 0x06800047, 0x03407207,
+	0x078014c9, 0x02c091c9, 0x07c014c9, 0x0609b20a, 0x0609b00a,
+	0x0609b10a, 0x068000c9, 0x0400125a, 0x07c01489, 0x0a60809a,
+	0x0c780340, 0x07801587, 0x07c015c7, 0x07c01588, 0x04000185,
+	0x04000144, 0x07801609, 0x05404249, 0x09404248, 0x07c01609,
+	0x0400010a, 0x0c7800c0, 0x00000000, 0x07c01548, 0x0649c108,
+	0x0aa2c008, 0x07800187, 0x0b61c087, 0x06800048, 0x0aa1c09a,
+	0x0aa0801a, 0x0aa14007, 0x040011c7, 0x07c00187, 0x0c780180,
+	0x07c001c8, 0x06800008, 0x07c001c8, 0x0c782340, 0x00000000,
+	0x06800131, 0x0c016b00, 0x04000c9a, 0x0aa0c01a, 0x06801bad,
+	0x0680592d, 0x0c004bc0, 0x00000000, 0x0c008cc0, 0x00000000,
+	0x0c015d80, 0x00000000, 0x0c005000, 0x00000000, 0x0c781f40,
+	0x00000000, 0x0c781ec0, 0x00000000, 0x078001c7, 0x0a608007,
+	0x0c7fff00, 0x0400024a, 0x07800107, 0x0b4031c9, 0x0c781cc0,
+	0x00000000, 0x07c00109, 0x078040c7, 0x0682bc08, 0x0b004207,
+	0x00000000, 0x0fc031c0, 0x094e3247, 0x07c00349, 0x07804148,
+	0x0aa200c8, 0x07801dc8, 0x0b806209, 0x00000000, 0x07800307,
+	0x0a608007, 0x0c781880, 0x02409209, 0x078016c8, 0x0a805209,
+	0x07c016c9, 0x0680001e, 0x07c0001e, 0x09408789, 0x0981d39d,
+	0x0981d3dd, 0x09c1d1dd, 0x0c004040, 0x00000000, 0x0c008140,
+	0x00000000, 0x0c015200, 0x00000000, 0x0c004480, 0x00000000,
+	0x07804208, 0x0a610008, 0x07804247, 0x0fc01200, 0x0fc061c0,
+	0x07c00207, 0x094e11c8, 0x060c0a07, 0x0a61001a, 0x06800007,
+	0x0c7808c0, 0x07c01e07, 0x0fc011c0, 0x07c01e07, 0x08094200,
+	0x0a60c007, 0x0c780740, 0x00000000, 0x06815448, 0x06094208,
+	0x0680c008, 0x06094008, 0x07800087, 0x0aa18087, 0x06800047,
+	0x07804147, 0x0aa0c0c7, 0x06800087, 0x06800107, 0x0fc08200,
+	0x0fc08240, 0x09509248, 0x06094109, 0x0fc01200, 0x0fc08200,
+	0x0fc08240, 0x09509248, 0x06094109, 0x06094109, 0x0fc01200,
+	0x0aed4047, 0x044011c7, 0x0fc01200, 0x07c00048, 0x08094000,
+	0x078043c7, 0x0a60c007, 0x0c780540, 0x00000000, 0x0fc071c0,
+	0x080c2940, 0x07800207, 0x07804208, 0x094e11c8, 0x09807187,
+	0x098073c7, 0x060c0a07, 0x09c073c7, 0x09807387, 0x060c0a07,
+	0x0c009900, 0x080c0600, 0x064c0a07, 0x091c21c7, 0x0a6f8007,
+	0x00000000, 0x0c780100, 0x00000000, 0x0c009700, 0x080c0600,
+	0x07801e07, 0x0aa14007, 0x07800048, 0x094211c8, 0x05001208,
+	0x094411c8, 0x060c1807, 0x0cb8002d, 0x00000000, 0x064c0007,
+	0x0a2fc047, 0x00000000, 0x064c3a07, 0x090061c7, 0x0aaec647,
+	0x00000000, 0x080c0a00, 0x080c2300, 0x064c1e07, 0x09807547,
+	0x060c1e07, 0x080c2800, 0x064c1e07, 0x09c07747, 0x060c1e07,
+	0x09807747, 0x060c1e07, 0x080c0002, 0x0c7ebe00, 0x00000000,
+	0x0649c015, 0x0649c116, 0x0649c217, 0x0649c318, 0x0809c000,
+	0x0809c100, 0x0809c200, 0x0809c300, 0x06804004, 0x0680c085,
+	0x06814106, 0x0c000a40, 0x00000000, 0x08002501, 0x08002605,
+	0x08002708, 0x0800290d, 0x08002815, 0x08002c14, 0x06800000,
+	0x07c01c00, 0x0cc00000, 0x00000000, 0x06800007, 0x07c01907,
+	0x07c01987, 0x07c019c7, 0x07800607, 0x040011c7, 0x07c01887,
+	0x06800047, 0x060e0c07, 0x07c01a87, 0x07c018c7, 0x068003c7,
+	0x07c00147, 0x06805c07, 0x060c2107, 0x080c2170, 0x06800087,
+	0x07c01ac7, 0x0680001f, 0x07804148, 0x05406208, 0x0940321a,
+	0x07800387, 0x09461207, 0x060c0408, 0x06868008, 0x07c01a48,
+	0x0cc00000, 0x00000000, 0x0649cf30, 0x064c4002, 0x064c4203,
+	0x02403083, 0x040080c3, 0x07c00843, 0x058100c3, 0x07c00883,
+	0x06800019, 0x07c01499, 0x07c014d9, 0x07c01519, 0x064c0919,
+	0x0680001a, 0x07c0019a, 0x07c001da, 0x068000c2, 0x07c04142,
+	0x06803fc2, 0x07c01542, 0x07c01582, 0x07c015c2, 0x07c01602,
+	0x060c0919, 0x060c1a19, 0x06932002, 0x060c1e02, 0x06800002,
+	0x060c0c02, 0x06c04042, 0x060c0d02, 0x0cc00000, 0x00000000,
+	0x0649c803, 0x0aa14003, 0x078014c2, 0x028020c2, 0x07c014c2,
+	0x0809c800, 0x07801502, 0x0aa0c002, 0x06800102, 0x06030502,
+	0x064c0003, 0x0a2100c3, 0x06800002, 0x0c780a80, 0x00000000,
+	0x064c3a03, 0x090060c3, 0x0a60cac3, 0x0c780940, 0x00000000,
+	0x07804143, 0x0aa080c3, 0x0c780840, 0x064c4403, 0x091210c3,
+	0x0aa78003, 0x068fffc3, 0x07801fc2, 0x04001082, 0x0b81c0c2,
+	0x07c01fc2, 0x06800002, 0x07c01fc2, 0x07800402, 0x04001082,
+	0x0b8160c2, 0x07c00402, 0x064c0003, 0x09803203, 0x09803183,
+	0x09803003, 0x060c0003, 0x06802671, 0x0c012340, 0x07802672,
+	0x06800002, 0x064c1803, 0x095860c2, 0x09803483, 0x060c1803,
+	0x09c03483, 0x060c1803, 0x06800103, 0x06030503, 0x06800002,
+	0x07c01fc2, 0x07c00402, 0x0cc00000, 0x00000000, 0x064c442e,
+	0x09121bae, 0x0aaf802e, 0x0c7e9840, 0x00000000, 0x0c004ac0,
+	0x00000000, 0x06818109, 0x06c34749, 0x06090709, 0x06490b09,
+	0x09809009, 0x098090c9, 0x06090b09, 0x09c09009, 0x09c090c9,
+	0x0962225a, 0x06090b09, 0x06800009, 0x06c07489, 0x02009c09,
+	0x06094409, 0x06880009, 0x06c07489, 0x02009c09, 0x06094509,
+	0x0cc00000, 0x00000000, 0x07804149, 0x0a60c0c9, 0x0cc00000,
+	0x00000000, 0x06490707, 0x09807087, 0x098070c7, 0x06090707,
+	0x06495107, 0x098073c7, 0x0cc00000, 0x06095107, 0x0cc00000,
+	0x00400000, 0x064e1210, 0x091e1410, 0x0bef0050, 0x00000000,
+	0x0649d910, 0x0900c410, 0x0aef8190, 0x07801850, 0x0aa3c090,
+	0x0c7821c0, 0x06800011, 0x06c04011, 0x060e1211, 0x078016d1,
+	0x0a20c051, 0x0680001f, 0x0688001f, 0x06c0749f, 0x0201fc1f,
+	0x06800010, 0x07c01b10, 0x0c7813c0, 0x06800110, 0x07801b11,
+	0x0aa08091, 0x0c780f00, 0x07801892, 0x0aebc092, 0x0aa3c72f,
+	0x07801b50, 0x05406410, 0x078016d1, 0x05801451, 0x0be0c051,
+	0x06800011, 0x06880011, 0x06c07491, 0x02011c11, 0x02010450,
+	0x04440410, 0x060e1310, 0x0c780340, 0x040c07d0, 0x05405410,
+	0x078016d1, 0x0be0c051, 0x06800011, 0x06880011, 0x06c07491,
+	0x02011c11, 0x02010450, 0x04420410, 0x060e1310, 0x040607d0,
+	0x07801952, 0x0aa14012, 0x06a2c211, 0x0aa0c052, 0x06a2c011,
+	0x06a2c111, 0x06c04011, 0x060e1211, 0x06800010, 0x07c01b10,
+	0x06800110, 0x0c7816c0, 0x07c01850, 0x07801991, 0x06800192,
+	0x02411491, 0x02411491, 0x02411491, 0x07801a50, 0x05409410,
+	0x02010450, 0x05403450, 0x02011c11, 0x060e1311, 0x07801952,
+	0x0aa34012, 0x06a44211, 0x0aa2c052, 0x06a44011, 0x0c780240,
+	0x06a44111, 0x0a63c0d1, 0x07801a90, 0x064e0c12, 0x09010492,
+	0x0b8ea490, 0x0cc00000, 0x00400000, 0x06c0c011, 0x060e1211,
+	0x0680001f, 0x06800010, 0x07c01b10, 0x06800150, 0x0c780e80,
+	0x07c01850, 0x078018d1, 0x0aa1c011, 0x04401451, 0x07c018d1,
+	0x07801891, 0x04401451, 0x0c780b00, 0x07c01891, 0x078019d1,
+	0x07c01a11, 0x07801a50, 0x05409410, 0x02010450, 0x06800192,
+	0x02011491, 0x07c019d1, 0x05403450, 0x02011c11, 0x060e1311,
+	0x07801952, 0x0aa14012, 0x06a16211, 0x0aa0c052, 0x06a16011,
+	0x06a16111, 0x07801bd2, 0x0aa28012, 0x07801a90, 0x064e0c12,
+	0x09010492, 0x0b804490, 0x07801a12, 0x0c7fde80, 0x07c019d2,
+	0x04001410, 0x07c01a90, 0x07c01d91, 0x06c00011, 0x060e1211,
+	0x06800050, 0x0c780400, 0x07c01850, 0x0ba30110, 0x0c7ff540,
+	0x0a6f8050, 0x07801891, 0x0aa74011, 0x04401451, 0x0b26c051,
+	0x07c01891, 0x07801ad0, 0x0aa0c0d0, 0x00000000, 0x080c2170,
+	0x06800010, 0x07c01850, 0x0cc00000, 0x00400000, 0x0aa0c010,
+	0x0688001f, 0x0680001f, 0x06c0749f, 0x0c780a40, 0x0201fc1f,
+	0x0aa0c72f, 0x090a841f, 0x090c741f, 0x07800992, 0x0b823490,
+	0x0a8f5490, 0x091a141f, 0x0aa20010, 0x0688001f, 0x0c780180,
+	0x0680001f, 0x0aa7001f, 0x07801991, 0x0c7ffcc0, 0x00000000,
+	0x06c0749f, 0x0201fc1f, 0x07801a50, 0x05409410, 0x06800192,
+	0x02411491, 0x02010450, 0x05403450, 0x02011c11, 0x060e1311,
+	0x07801d90, 0x09004450, 0x0aa14011, 0x06a14210, 0x0aa0c111,
+	0x06a14010, 0x06a14110, 0x06c08010, 0x060e0d1f, 0x0aa0c72f,
+	0x040207df, 0x040207df, 0x0c7ff4c0, 0x060e1210, 0x07801a50,
+	0x05409410, 0x02010450, 0x06800192, 0x02011491, 0x07c01991,
+	0x05403450, 0x02011c11, 0x060e1311, 0x07801d90, 0x0a61801f,
+	0x09c101d0, 0x060e1210, 0x068000d0, 0x0c7ff0c0, 0x07c01850,
+	0x06c08010, 0x060e0d1f, 0x0aae872f, 0x040207df, 0x0c7ffe00,
+	0x040207df, 0x0c000d00, 0x00000000, 0x08095007, 0x08095000,
+	0x07804347, 0x07804308, 0x094a51c8, 0x078042c8, 0x095411c8,
+	0x06096e07, 0x0aa0c008, 0x06800088, 0x06800048, 0x060c3108,
+	0x06800048, 0x0780098a, 0x068002c9, 0x0b00324a, 0x00000000,
+	0x06800008, 0x06498e0a, 0x097c1288, 0x06098e0a, 0x06497f08,
+	0x068000ca, 0x0970220a, 0x06097f08, 0x06820988, 0x06c00208,
+	0x0968221a, 0x0780098a, 0x0b20c2ca, 0x068004ca, 0x06800c0a,
+	0x0970620a, 0x0cc00000, 0x06095108, 0x0683ffc8, 0x06490909,
+	0x0a210049, 0x0aa0c008, 0x0c7fff40, 0x04401208, 0x06490b09,
+	0x09809009, 0x098090c9, 0x06090b09, 0x09c09009, 0x09c090c9,
+	0x06090b09, 0x0cc00000, 0x00000000, 0x0683ffc9, 0x0649bb08,
+	0x0920c208, 0x0649530a, 0x0900128a, 0x02008288, 0x0aa10008,
+	0x0aa0c009, 0x0c7ffe40, 0x04401249, 0x0cc00000, 0x00000000,
+	0x064e1209, 0x091e1249, 0x0bef8049, 0x064e0009, 0x064e0e0b,
+	0x064e0c0c, 0x083f0040, 0x083f0000, 0x0680020d, 0x0d00000d,
+	0x00000000, 0x060e0009, 0x060e0e0b, 0x0cc00000, 0x060e0c0c,
+	0x0c07fc40, 0x00000000, 0x06490b09, 0x09809009, 0x09809089,
+	0x06090b09, 0x09c09009, 0x09c09089, 0x06090b09, 0x08095007,
+	0x08095000, 0x0c000500, 0x00000000, 0x06800007, 0x07c00307,
+	0x06800007, 0x07c01907, 0x07c01987, 0x07c019c7, 0x07800607,
+	0x040011c7, 0x07c01887, 0x06800047, 0x060e0c07, 0x07c01a87,
+	0x07c018c7, 0x068003c7, 0x07c00147, 0x06800007, 0x0cc00000,
+	0x07c01847, 0x0683ffc9, 0x06498f0a, 0x0aa0c009, 0x0a6f800a,
+	0x04401249, 0x064c3d0a, 0x0580a28a, 0x0bef80ca, 0x00000000,
+	0x06498e0a, 0x0980a00a, 0x06800fc9, 0x09706289, 0x06098e0a,
+	0x06800009, 0x09706289, 0x09c0a00a, 0x0cc00000, 0x06098e0a,
+	0x064c3a08, 0x09006208, 0x064c0809, 0x064c090a, 0x064c1e0b,
+	0x064c380c, 0x06800407, 0x063f0007, 0x06800007, 0x063f0007,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x060c0809,
+	0x060c090a, 0x060c1e0b, 0x060c380c, 0x0c07ef00, 0x00000000,
+	0x06800009, 0x060c0c09, 0x06c04049, 0x060c0d09, 0x064c1809,
+	0x09586248, 0x09809489, 0x060c1809, 0x09c09489, 0x060c1809,
+	0x0cc00000, 0x080c0a01, 0x0680072f, 0x06bfffcb, 0x06800024,
+	0x07801c20, 0x06800021, 0x06800025, 0x06800022, 0x06800026,
+	0x06800023, 0x06800027, 0x0680800a, 0x0680070e, 0x0740028b,
+	0x0400128a, 0x074002a4, 0x0400128a, 0x074002a0, 0x0400128a,
+	0x074002a1, 0x0400128a, 0x074002a5, 0x0400128a, 0x074002a2,
+	0x0400128a, 0x074002a6, 0x0400128a, 0x074002a3, 0x0400128a,
+	0x074002a7, 0x0d07fbce, 0x0400128a, 0x07c01c4b, 0x096102cb,
+	0x080c0700, 0x060c270b, 0x09610824, 0x060c0220, 0x09610865,
+	0x0aa1801a, 0x060c0221, 0x096108a6, 0x060c0222, 0x096108e7,
+	0x060c0223, 0x0780098e, 0x0b009bce, 0x06b80007, 0x06c07487,
+	0x02007c07, 0x06035107, 0x06803f07, 0x06035207, 0x06a08007,
+	0x06035007, 0x07800007, 0x0a60c007, 0x06803fc7, 0x07c01c87,
+	0x06800007, 0x07c01d47, 0x0ac0bbce, 0x07801c87, 0x0b613fc7,
+	0x0ba0c707, 0x0441c1c7, 0x07c01c87, 0x06435007, 0x0580f1c7,
+	0x0bef8047, 0x0cc00000, 0x00000000, 0x06435007, 0x0580f1c7,
+	0x0bef8047, 0x00000000, 0x06435307, 0x0900c1c7, 0x0a6f8007,
+	0x00000000, 0x06b80007, 0x06c07487, 0x02007c07, 0x06035107,
+	0x06803f07, 0x06035207, 0x06b0c007, 0x06035007, 0x054011ef,
+	0x0ac051ce, 0x06800087, 0x07c01cc7, 0x0c7ff880, 0x07c01d07,
+	0x06b90008, 0x06c07488, 0x02008c08, 0x0540126f, 0x02009bc9,
+	0x0680008a, 0x07c01cca, 0x068000ca, 0x06435007, 0x0580f1c7,
+	0x0bef8047, 0x06803f07, 0x06035108, 0x06035207, 0x06a08007,
+	0x06035007, 0x0ac0324e, 0x0c7ff3c0, 0x07c01d0a, 0x06808007,
+	0x020081c8, 0x02009bc9, 0x0c7ffc80, 0x0400128a, 0x0400130c,
+	0x0480f30c, 0x07c01d0c, 0x0980b38b, 0x07801ccc, 0x0540928c,
+	0x0200a24a, 0x0400130c, 0x0480f30c, 0x07c01ccc, 0x0643500c,
+	0x0580f30c, 0x06c0748a, 0x0bef404c, 0x0200ac0a, 0x0643530c,
+	0x0900c30c, 0x0a6f800c, 0x00000000, 0x0603510a, 0x06803f0a,
+	0x0603520a, 0x0c7fedc0, 0x0603500b, 0x064c2307, 0x0befc047,
+	0x0cc00000, 0x064c2007, 0x040011c7, 0x06800008, 0x0a20c047,
+	0x058011c7, 0x024071c8, 0x0cc00000, 0x00000000, 0x02409247,
+	0x048ff249, 0x05401249, 0x02407207, 0x048ff1c7, 0x054011c7,
+	0x0680000a, 0x0680000b, 0x06800048, 0x0b8041c8, 0x054012cb,
+	0x0980b04b, 0x024081c8, 0x05401208, 0x0b2ec20a, 0x0400128a,
+	0x058012cb, 0x0e0002c9, 0x00000000, 0x00000000, 0x0cc00000,
+	0x0f000240, 0x02409247, 0x06807fca, 0x02809289, 0x02407207,
+	0x06807fca, 0x02807287, 0x0680000a, 0x0680000b, 0x06800048,
+	0x0b8041c8, 0x054012cb, 0x0980b04b, 0x024081c8, 0x05401208,
+	0x0b2ec20a, 0x0400128a, 0x058012cb, 0x0e0002c9, 0x00000000,
+	0x00000000, 0x0cc00000, 0x0f000240, 0x024091c9, 0x06807fca,
+	0x02809289, 0x024071c8, 0x06807fca, 0x02807287, 0x0680000a,
+	0x0680000b, 0x06800048, 0x0b8041c8, 0x054012cb, 0x0980b04b,
+	0x024081c8, 0x05401208, 0x0b2ec20a, 0x0400128a, 0x058012cb,
+	0x0e0002c9, 0x00000000, 0x00000000, 0x0cc00000, 0x0f000240,
+	0x02407207, 0x06807fca, 0x02807287, 0x0680000a, 0x0680000b,
+	0x06800048, 0x0b8041c8, 0x054012cb, 0x0980b04b, 0x024081c8,
+	0x05401208, 0x0b2ec34a, 0x0400128a, 0x0cc00000, 0x0580124b,
+	0x07804187, 0x0a60c007, 0x06800088, 0x06800048, 0x07c04148,
+	0x0a60c01a, 0x0680592d, 0x0680005a, 0x0cc00000, 0x00000000,
+	0x024091c9, 0x06807fc8, 0x02809209, 0x0680000a, 0x0680000b,
+	0x06800048, 0x0b8041c8, 0x054012cb, 0x0980b04b, 0x024081c8,
+	0x05401208, 0x0b2ec20a, 0x0400128a, 0x058012cb, 0x0e0002c9,
+	0x00000000, 0x00000000, 0x0cc00000, 0x0f000240, 0x0aa1409a,
+	0x0aa0801a, 0x0c784cc0, 0x0cc00000, 0x00000000, 0x07801ec7,
+	0x07801e88, 0x02407207, 0x048ff1c7, 0x054011c7, 0x07c00447,
+	0x07801f07, 0x07801e88, 0x02407207, 0x048ff1c7, 0x054011c7,
+	0x07c00487, 0x07804149, 0x0aa140c9, 0x07800389, 0x0a60c009,
+	0x00000000, 0x044011c7, 0x0c07f580, 0x07800449, 0x06800f88,
+	0x09646248, 0x060c3009, 0x07800487, 0x07804149, 0x0aa280c9,
+	0x07800389, 0x0aa0c009, 0x00000000, 0x040011c7, 0x0c07f280,
+	0x07800449, 0x06800fc8, 0x09646248, 0x060c3009, 0x07804147,
+	0x0aa080c7, 0x0c780bc0, 0x07801e88, 0x05401208, 0x07801ec7,
+	0x0c07e980, 0x054011c7, 0x06800c08, 0x09646248, 0x060c3009,
+	0x07801e48, 0x05401208, 0x07801ec7, 0x0c07e780, 0x054011c7,
+	0x06800c48, 0x09646248, 0x060c3009, 0x07801f07, 0x07801e88,
+	0x02407207, 0x048ff1c7, 0x05401247, 0x07801ec7, 0x07801f08,
+	0x02407207, 0x048ff1c7, 0x054011c7, 0x09529247, 0x06800d08,
+	0x09646248, 0x060c3009, 0x07801f07, 0x07801e88, 0x0c07d1c0,
+	0x07801e89, 0x06800808, 0x09646248, 0x060c3009, 0x07801ec7,
+	0x07801f08, 0x0c07d000, 0x07801f09, 0x06800888, 0x09646248,
+	0x060c3009, 0x0cc00000, 0x00000000, 0x07801f8c, 0x0aa0c00c,
+	0x0780038c, 0x0680000c, 0x0a61c00c, 0x07801ec7, 0x054011c7,
+	0x07801e88, 0x05401208, 0x0c780180, 0x04001208, 0x07801ec7,
+	0x054011c7, 0x040011c7, 0x04401207, 0x0c07db00, 0x00000000,
+	0x06800c08, 0x09646248, 0x0a60c00c, 0x00000000, 0x098093c9,
+	0x060c3009, 0x0a61800c, 0x07801ec7, 0x054011c7, 0x07801e88,
+	0x0c780200, 0x05401208, 0x07801ec7, 0x054011c7, 0x040011c7,
+	0x07801e88, 0x05401208, 0x04001208, 0x0c07d600, 0x00000000,
+	0x06800c48, 0x09646248, 0x0aa0c00c, 0x00000000, 0x098093c9,
+	0x060c3009, 0x0a61c00c, 0x07801ec7, 0x054011c7, 0x07801e48,
+	0x05401208, 0x0c7801c0, 0x04001208, 0x07801ec7, 0x054011c7,
+	0x040011c7, 0x07801e88, 0x05401208, 0x0c07d100, 0x00000000,
+	0x06800c88, 0x09646248, 0x060c3009, 0x0a61800c, 0x07801ec7,
+	0x054011c7, 0x07801e48, 0x0c780200, 0x05401208, 0x07801ec7,
+	0x054011c7, 0x040011c7, 0x07801e48, 0x05401208, 0x04001208,
+	0x0c07ccc0, 0x00000000, 0x06800cc8, 0x09646248, 0x060c3009,
+	0x0780038c, 0x07801f07, 0x0aa0c00c, 0x054011c7, 0x040011c7,
+	0x07801e88, 0x05401208, 0x02407207, 0x06807fca, 0x02809287,
+	0x07801ec7, 0x0aa1800c, 0x054011c7, 0x07801f88, 0x0a60c008,
+	0x00000000, 0x040011c7, 0x07801f08, 0x0aa0c00c, 0x05401208,
+	0x04001208, 0x02407207, 0x02807287, 0x09529247, 0x06800d08,
+	0x09646248, 0x060c3009, 0x07801f07, 0x0aa0c00c, 0x054011c7,
+	0x040011c7, 0x07801e88, 0x05401208, 0x04001208, 0x02407207,
+	0x06807fca, 0x02809287, 0x07801ec7, 0x0aa1800c, 0x054011c7,
+	0x07801f88, 0x0a60c008, 0x00000000, 0x040011c7, 0x07801f08,
+	0x0aa0c00c, 0x05401208, 0x04001208, 0x02407207, 0x02807287,
+	0x09529247, 0x06800d48, 0x09646248, 0x060c3009, 0x0aa0c00c,
+	0x0680000c, 0x0680004c, 0x07801f07, 0x054011c7, 0x02007307,
+	0x07801e88, 0x05401208, 0x04001208, 0x0c07b0c0, 0x04000248,
+	0x06800808, 0x09646248, 0x060c3009, 0x07801f07, 0x054011c7,
+	0x02007307, 0x07801e88, 0x05401208, 0x0c07ae40, 0x04001248,
+	0x06800848, 0x09646248, 0x060c3009, 0x07801f07, 0x054011c7,
+	0x02007307, 0x07801ec8, 0x05401208, 0x0c07b140, 0x04000248,
+	0x06800888, 0x09646248, 0x060c3009, 0x07801f07, 0x054011c7,
+	0x02007307, 0x07801ec8, 0x05401208, 0x04001208, 0x0c07ae80,
+	0x04401248, 0x068008c8, 0x09646248, 0x060c3009, 0x07801f07,
+	0x054011c7, 0x02007307, 0x07801e88, 0x05401208, 0x04001208,
+	0x0c07a640, 0x04401248, 0x06800908, 0x09646248, 0x060c3009,
+	0x07801f07, 0x054011c7, 0x02007307, 0x07801e88, 0x05401208,
+	0x0c07a3c0, 0x04000248, 0x06800948, 0x09646248, 0x060c3009,
+	0x07801f07, 0x054011c7, 0x02007307, 0x07801ec8, 0x05401208,
+	0x0c07a6c0, 0x04001248, 0x06800988, 0x09646248, 0x060c3009,
+	0x07801f07, 0x054011c7, 0x02007307, 0x07801ec8, 0x05401208,
+	0x04001208, 0x0c07a400, 0x04400248, 0x068009c8, 0x09646248,
+	0x060c3009, 0x0cc00000, 0x00000000, 0x07804147, 0x0aa080c7,
+	0x0c7807c0, 0x07801f07, 0x07801e88, 0x0c079600, 0x07801e89,
+	0x06800808, 0x09646248, 0x060c3009, 0x07801ec7, 0x07801e48,
+	0x0c079440, 0x07801e89, 0x06800848, 0x09646248, 0x060c3009,
+	0x07801ec7, 0x07801e88, 0x0c079280, 0x07801e49, 0x06800908,
+	0x09646248, 0x060c3009, 0x07801ec7, 0x07801e48, 0x0c0790c0,
+	0x07801e49, 0x06800948, 0x09646248, 0x060c3009, 0x0cc00000,
+	0x00000000, 0x0780038c, 0x0aa0800c, 0x0c780880, 0x0680080d,
+	0x07801f07, 0x054011c7, 0x0900230d, 0x07801e88, 0x05401208,
+	0x0aa2004c, 0x0aa1c00c, 0x04001208, 0x07801e48, 0x05401208,
+	0x0aa0c0cc, 0x00000000, 0x04001208, 0x0904230d, 0x07801e89,
+	0x05401249, 0x0aa2004c, 0x0aa1c00c, 0x04001249, 0x07801e49,
+	0x05401249, 0x0aa0c0cc, 0x00000000, 0x04001249, 0x0c078d80,
+	0x00000000, 0x0964624d, 0x060c3009, 0x0ba90bcd, 0x0400134d,
+	0x0cc00000, 0x00000000, 0x0680080d, 0x07801f07, 0x054011c7,
+	0x040011c7, 0x0900230d, 0x07801f08, 0x0aa2800c, 0x05401208,
+	0x07801e88, 0x05401208, 0x0aa1808c, 0x0aa1404c, 0x04001208,
+	0x07801e48, 0x05401208, 0x04001208, 0x0904230d, 0x07801f09,
+	0x0aa2800c, 0x05401249, 0x07801e89, 0x05401249, 0x0aa1808c,
+	0x0aa1404c, 0x04001249, 0x07801e49, 0x05401249, 0x04001249,
+	0x0c078480, 0x00000000, 0x0964624d, 0x060c3009, 0x0ba84bcd,
+	0x0400134d, 0x0cc00000, 0x00000000, 0x07804147, 0x0a6140c7,
+	0x06099004, 0x06099105, 0x0c780240, 0x06099206, 0x06099004,
+	0x06099104, 0x06099205, 0x06099305, 0x06099406, 0x0c780080,
+	0x06099506, 0x0aa3c09a, 0x0aa0805a, 0x0cc00000, 0x07804147,
+	0x0698d908, 0x0aa1c0c7, 0x06d85888, 0x0688d108, 0x0aa10087,
+	0x06c85088, 0x06910948, 0x06d088c8, 0x080c2400, 0x0cc00000,
+	0x060c2208, 0x07804147, 0x0698d908, 0x0aa100c7, 0x06d85888,
+	0x06800008, 0x06d088c8, 0x080c2400, 0x060c2208, 0x07804147,
+	0x069898c8, 0x0aa100c7, 0x06d81848, 0x06800008, 0x06c85008,
+	0x080c2408, 0x0cc00000, 0x060c2208, 0x0609cd32, 0x0609ce31,
+	0x08007401, 0x0649ce31, 0x0a6fc031, 0x00000000, 0x0cc00000,
+	0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/avs/vavs_mc.c b/drivers/amlogic/amports/arch/ucode/avs/vavs_mc.c
index 46a0fc9..9bcf9da 100644
--- a/drivers/amlogic/amports/arch/ucode/avs/vavs_mc.c
+++ b/drivers/amlogic/amports/arch/ucode/avs/vavs_mc.c
@@ -28,11 +28,11 @@
 #include "avs_linux_old.h"
 
 #undef MicroCode
-#define MicroCode txl_vavs_mc
-#include "txl_avs_linux.h"
+#define MicroCode gxm_vavs_mc
+#include "gxm_avs_linux.h"
 #undef MicroCode
-#define MicroCode txl_vavs_mc_debug
-#include "txl_avs_linux_debug.h"
+#define MicroCode gxm_vavs_mc_debug
+#include "gxm_avs_linux_debug.h"
 
 
 #define FOR_VFORMAT VFORMAT_AVS
@@ -42,8 +42,8 @@
 		DEF_FIRMWARE(vavs_mc);\
 		DEF_FIRMWARE(vavs_mc_debug);\
 		DEF_FIRMWARE(vavs_mc_old);\
-		DEF_FIRMWARE(txl_vavs_mc);\
-		DEF_FIRMWARE(txl_vavs_mc_debug);\
+		DEF_FIRMWARE(gxm_vavs_mc);\
+		DEF_FIRMWARE(gxm_vavs_mc_debug);\
 	} while (0)
 
 INIT_DEF_FIRMWARE();
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264c_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264c_linux.h
index cf44e22..216f012 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264c_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264c_linux.h
@@ -1,14 +1,14 @@
 static const u32 MicroCode[] __initconst = {
 	0x06810001, 0x06800000, 0x0d000001, 0x07400040, 0x064c0800,
-	0x09800300, 0x00000000, 0x060c0800, 0x0649d019, 0x0c006140,
+	0x09800300, 0x00000000, 0x060c0800, 0x0649d019, 0x0c0060c0,
 	0x0649c134, 0x06880000, 0x060c2900, 0x080c0002, 0x06bfda80,
-	0x07c02d40, 0x06030400, 0x00400000, 0x0c007d00, 0x00000000,
+	0x07c02d40, 0x06030400, 0x00400000, 0x0c007c00, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0c7ffe80,
-	0x00000000, 0x06431e35, 0x0befc075, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x0c780500, 0x00000000, 0x0cc00000,
 	0x00400000, 0x0c780d40, 0x064c0007, 0x0cc00000, 0x00400000,
-	0x0c787d40, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
-	0x00400000, 0x0c787bc0, 0x00000000, 0x0c787980, 0x00000000,
+	0x0c787c40, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c787ac0, 0x00000000, 0x0c787880, 0x00000000,
 	0x0cc00000, 0x00400000, 0x0aa44133, 0x0aa0c033, 0x0c7fff00,
 	0x0680001b, 0x0649cf1c, 0x0bee405c, 0x064c431c, 0x0ae0ffdc,
 	0x0c7ffd80, 0x0680001b, 0x064c411c, 0x0968c71c, 0x0a40bc9c,
@@ -19,19 +19,19 @@ static const u32 MicroCode[] __initconst = {
 	0x00800000, 0x07802d49, 0x0c7ff6c0, 0x06030409, 0x06bf9b89,
 	0x06030409, 0x00400000, 0x064c4309, 0x05801249, 0x0baf9809,
 	0x00000000, 0x0a2c0047, 0x07802bc9, 0x0aa14009, 0x0a608049,
-	0x0c7a08c0, 0x0a6080c9, 0x0c79f700, 0x0a208807, 0x0c782680,
-	0x0be15007, 0x0a208207, 0x0c7845c0, 0x0cb8001a, 0x00000000,
+	0x0c7a08c0, 0x0a6080c9, 0x0c79f700, 0x0a208807, 0x0c782600,
+	0x0be15007, 0x0a208207, 0x0c784540, 0x0cb8001a, 0x00000000,
 	0x0c000280, 0x00000000, 0x06bfffca, 0x07903c08, 0x0a402288,
-	0x0c784580, 0x0be08207, 0x0c7ffdc0, 0x0c784300, 0x00000000,
+	0x0c784500, 0x0be08207, 0x0c7ffdc0, 0x0c784280, 0x00000000,
 	0x0649cd09, 0x04001249, 0x0609cd09, 0x0c000780, 0x064c380e,
 	0x064c0809, 0x064c090b, 0x0680040a, 0x063f000a, 0x0680000a,
 	0x063f000a, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x060c0809, 0x060c090b, 0x0688000a, 0x060c290a, 0x0c0005c0,
 	0x00000000, 0x0680000a, 0x060c0c0a, 0x06c0404a, 0x060c0d0a,
-	0x080c0101, 0x0684044a, 0x060c2e0a, 0x060c380e, 0x0c001780,
+	0x080c0101, 0x0684044a, 0x060c2e0a, 0x060c380e, 0x0c001700,
 	0x00000000, 0x0cc00000, 0x00000000, 0x0683ffc9, 0x0aa18009,
 	0x0649470a, 0x0910828a, 0x07802cc8, 0x0a4fc20a, 0x04401249,
-	0x0cc00000, 0x00000000, 0x0c00a580, 0x00000000, 0x06490b09,
+	0x0cc00000, 0x00000000, 0x0c00a480, 0x00000000, 0x06490b09,
 	0x09809009, 0x09809089, 0x06090b09, 0x09c09009, 0x09c09089,
 	0x06090b09, 0x08095007, 0x08095000, 0x0683ffc9, 0x06498f0a,
 	0x0aa0c009, 0x0a6f800a, 0x04401249, 0x064c3d0a, 0x0580a28a,
@@ -46,357 +46,357 @@ static const u32 MicroCode[] __initconst = {
 	0x0603410a, 0x06810009, 0x06034209, 0x06a3000b, 0x06c001cb,
 	0x0603400b, 0x0643400c, 0x0580f30c, 0x0bef804c, 0x06840008,
 	0x063f0008, 0x06800008, 0x063f0008, 0x08002a09, 0x08002b17,
-	0x06830008, 0x06032608, 0x08032261, 0x06800048, 0x06c00088,
-	0x06032108, 0x0cc00000, 0x00000000, 0x0680004a, 0x060e0c0a,
-	0x07c026ca, 0x07c0250a, 0x068003ca, 0x07c0280a, 0x06805c0a,
-	0x060c210a, 0x080c2170, 0x0680008a, 0x07c02a4a, 0x06800018,
-	0x0680000a, 0x0cc00000, 0x07c0248a, 0x0a25d007, 0x0680004a,
-	0x0c07e540, 0x07c01e4a, 0x064c000a, 0x09c0a18a, 0x0980a20a,
-	0x0980a00a, 0x060c000a, 0x064c2908, 0x09c08348, 0x09808208,
-	0x060c2908, 0x09808348, 0x09c08208, 0x060c2908, 0x064c080a,
-	0x0980a34a, 0x060c080a, 0x0c07e340, 0x00000000, 0x0c07f700,
-	0x00000000, 0x080c0600, 0x0fc081c0, 0x0649cf0a, 0x0a21500a,
-	0x0a611e47, 0x0be0c40a, 0x0c780dc0, 0x00000000, 0x090a2207,
-	0x07c02048, 0x0481f1c7, 0x07c02007, 0x0aa38147, 0x0aa34047,
-	0x0a60c187, 0x0c781040, 0x0681d88d, 0x0a60c1c7, 0x0c780f80,
-	0x0682000d, 0x0a60c207, 0x0c780ec0, 0x0682744d, 0x0a608247,
-	0x0c780740, 0x0c781400, 0x0c78f240, 0x00000000, 0x064c4408,
-	0x09101208, 0x0aaf8048, 0x064c5109, 0x064c460a, 0x07801a48,
-	0x05410208, 0x07801a0b, 0x020082c8, 0x0580a208, 0x06031f08,
-	0x06033f09, 0x0c07b640, 0x08031e15, 0x06431f08, 0x06433f09,
-	0x09708209, 0x0540a208, 0x02008288, 0x064c4309, 0x02408248,
-	0x064c4009, 0x02408248, 0x0cc00000, 0x0440a208, 0x0c07f9c0,
-	0x00000000, 0x07c00bc8, 0x05810208, 0x07c00c08, 0x06800048,
-	0x0c780b80, 0x07c00c48, 0x0c07f7c0, 0x00000000, 0x07800909,
-	0x0780094a, 0x0961024a, 0x0609c209, 0x0680a149, 0x02008248,
-	0x07c00908, 0x05810208, 0x07c00948, 0x07807188, 0x0609c108,
-	0x0809c00a, 0x08007401, 0x0649c008, 0x0a6fc008, 0x0c7806c0,
-	0x00000000, 0x07803bc8, 0x090821c8, 0x0aa18047, 0x06800047,
-	0x09482207, 0x0680000a, 0x0c07d7c0, 0x06c0000a, 0x0cb8000d,
-	0x07c03bc8, 0x064c2907, 0x0be14407, 0x064c2307, 0x0bef4047,
-	0x0cc00000, 0x064c2007, 0x0cc00000, 0x06800007, 0x040011c7,
-	0x06800008, 0x0a20c047, 0x058011c7, 0x024071c8, 0x0cc00000,
-	0x00000000, 0x064c0007, 0x0a2fc047, 0x00000000, 0x064c3a07,
-	0x090061c7, 0x0aaec647, 0x00000000, 0x080c0a01, 0x080c2800,
-	0x080c0002, 0x0c7fb100, 0x00000000, 0x0684000a, 0x0c07cfc0,
-	0x06c0000a, 0x069fffc2, 0x07c03b42, 0x07c03b82, 0x07c03c42,
-	0x07c00a02, 0x07c00a42, 0x07c00a82, 0x07c03c82, 0x07c01742,
-	0x07c017c2, 0x068003c2, 0x07c02fc2, 0x064c1e02, 0x098025c2,
-	0x060c1e02, 0x064c1e02, 0x09802702, 0x060c1e02, 0x0680c002,
-	0x06094002, 0x06803003, 0x06804002, 0x0d000003, 0x06094102,
-	0x06800002, 0x06094002, 0x0c000680, 0x00000000, 0x064c1e02,
-	0x098025c2, 0x060c1e02, 0x08002501, 0x08002609, 0x08002708,
-	0x0800290d, 0x08002d15, 0x08002c14, 0x0649b802, 0x06800fc3,
-	0x09508083, 0x0609b802, 0x08002609, 0x08002b17, 0x06830002,
-	0x06032602, 0x08032261, 0x06800042, 0x06c00082, 0x06032102,
-	0x06800032, 0x0cc00000, 0x0680001b, 0x06800203, 0x07c03bc3,
-	0x06800712, 0x06800033, 0x07c02bf3, 0x07c01933, 0x07c01973,
-	0x07c01df3, 0x07c01e33, 0x0649c203, 0x0a654003, 0x06800803,
-	0x068f000a, 0x06c0470a, 0x06810002, 0x06800049, 0x06a02bcb,
-	0x0c07ba80, 0x00000000, 0x0d07ff83, 0x0200a08a, 0x06804003,
-	0x06af000a, 0x06c0470a, 0x06808002, 0x06800049, 0x06a02bcb,
-	0x0c07b800, 0x00000000, 0x0d07ff83, 0x0200a08a, 0x064e1203,
-	0x091e10c3, 0x0bef8043, 0x064c0903, 0x06803002, 0x063f0002,
-	0x06800002, 0x063f0002, 0x06803fc2, 0x060c0903, 0x06800002,
-	0x060c0c02, 0x06c04042, 0x060c0d02, 0x080c0101, 0x06840442,
-	0x060c2e02, 0x06bfffc2, 0x07c00ac2, 0x064c4010, 0x064c4211,
-	0x02411411, 0x04008451, 0x07c01a11, 0x05810451, 0x07c01a51,
-	0x064c1e02, 0x09802702, 0x060c1e02, 0x064e0e02, 0x09802242,
-	0x060e0e02, 0x0cc00000, 0x00000000, 0x07802bc2, 0x0aa0c002,
-	0x06800102, 0x06030502, 0x0b60c11b, 0x0cc00000, 0x00000000,
-	0x00800000, 0x00000000, 0x0c079a40, 0x00000000, 0x080c0a01,
-	0x080c2800, 0x080c0002, 0x0cc00000, 0x00400000, 0x064c441c,
-	0x0910171c, 0x0a6f801c, 0x0c7f8640, 0x00000000, 0x0cc00000,
-	0x00400000, 0x064e1214, 0x091e1514, 0x0bef0054, 0x078029d5,
-	0x0649d914, 0x0900c514, 0x0acfe554, 0x07802494, 0x0aa50094,
-	0x0aa08194, 0x0c782d00, 0x0c7824c0, 0x07802715, 0x06800015,
-	0x06c04015, 0x07802857, 0x097c1557, 0x060e1215, 0x07802d15,
-	0x0a20c055, 0x06800018, 0x06900018, 0x06c046d8, 0x02018d18,
-	0x06800014, 0x07c02a94, 0x0c782540, 0x06800114, 0x07802a95,
-	0x0aa08095, 0x0c781340, 0x078024d6, 0x0aeb4096, 0x07802857,
-	0x0aa4c712, 0x07802ad4, 0x05406514, 0x07802d15, 0x05801555,
-	0x0be0c055, 0x06800015, 0x06900015, 0x06c046d5, 0x02015d15,
-	0x02014554, 0x04440514, 0x060e1314, 0x0aa44017, 0x040c0614,
-	0x06805c16, 0x060c2116, 0x0c780340, 0x04040618, 0x05405514,
-	0x07802d15, 0x0be0c055, 0x06800015, 0x06900015, 0x06c046d5,
-	0x02015d15, 0x02014554, 0x04420514, 0x060e1314, 0x04060614,
-	0x07802596, 0x0aa14016, 0x06a2c215, 0x0aa0c056, 0x06a2c015,
-	0x06a2c115, 0x0aa10017, 0x06c04015, 0x068003d4, 0x09506554,
+	0x06830008, 0x06032608, 0x08032261, 0x08032101, 0x0cc00000,
+	0x00000000, 0x0680004a, 0x060e0c0a, 0x07c026ca, 0x07c0250a,
+	0x068003ca, 0x07c0280a, 0x06805c0a, 0x060c210a, 0x080c2170,
+	0x0680008a, 0x07c02a4a, 0x06800018, 0x0680000a, 0x0cc00000,
+	0x07c0248a, 0x0a25d007, 0x0680004a, 0x0c07e5c0, 0x07c01e4a,
+	0x064c000a, 0x09c0a18a, 0x0980a20a, 0x0980a00a, 0x060c000a,
+	0x064c2908, 0x09c08348, 0x09808208, 0x060c2908, 0x09808348,
+	0x09c08208, 0x060c2908, 0x064c080a, 0x0980a34a, 0x060c080a,
+	0x0c07e3c0, 0x00000000, 0x0c07f700, 0x00000000, 0x080c0600,
+	0x0fc081c0, 0x0649cf0a, 0x0a21500a, 0x0a611e47, 0x0be0c40a,
+	0x0c780dc0, 0x00000000, 0x090a2207, 0x07c02048, 0x0481f1c7,
+	0x07c02007, 0x0aa38147, 0x0aa34047, 0x0a60c187, 0x0c781040,
+	0x0681d78d, 0x0a60c1c7, 0x0c780f80, 0x0682000d, 0x0a60c207,
+	0x0c780ec0, 0x0682724d, 0x0a608247, 0x0c780740, 0x0c781400,
+	0x0c78f1c0, 0x00000000, 0x064c4408, 0x09101208, 0x0aaf8048,
+	0x064c5109, 0x064c460a, 0x07801a48, 0x05410208, 0x07801a0b,
+	0x020082c8, 0x0580a208, 0x0e000248, 0x00000000, 0x00000000,
+	0x00000000, 0x0f000200, 0x0f010240, 0x09708209, 0x0540a208,
+	0x02008288, 0x064c4309, 0x02408248, 0x064c4009, 0x02408248,
+	0x0cc00000, 0x0440a208, 0x0c07f9c0, 0x00000000, 0x07c00bc8,
+	0x05810208, 0x07c00c08, 0x06800048, 0x0c780b80, 0x07c00c48,
+	0x0c07f7c0, 0x00000000, 0x07800909, 0x0780094a, 0x0961024a,
+	0x0609c209, 0x0680a149, 0x02008248, 0x07c00908, 0x05810208,
+	0x07c00948, 0x07807188, 0x0609c108, 0x0809c00a, 0x08007401,
+	0x0649c008, 0x0a6fc008, 0x0c7806c0, 0x00000000, 0x07803bc8,
+	0x090821c8, 0x0aa18047, 0x06800047, 0x09482207, 0x0680000a,
+	0x0c07d840, 0x06c0000a, 0x0cb8000d, 0x07c03bc8, 0x064c2907,
+	0x0be14407, 0x064c2307, 0x0bef4047, 0x0cc00000, 0x064c2007,
+	0x0cc00000, 0x06800007, 0x040011c7, 0x06800008, 0x0a20c047,
+	0x058011c7, 0x024071c8, 0x0cc00000, 0x00000000, 0x064c0007,
+	0x0a2fc047, 0x00000000, 0x064c3a07, 0x090061c7, 0x0aaec647,
+	0x00000000, 0x080c0a01, 0x080c2800, 0x080c0002, 0x0c7fb180,
+	0x00000000, 0x0684000a, 0x0c07d040, 0x06c0000a, 0x069fffc2,
+	0x07c03b42, 0x07c03b82, 0x07c03c42, 0x07c00a02, 0x07c00a42,
+	0x07c00a82, 0x07c03c82, 0x07c01742, 0x07c017c2, 0x068003c2,
+	0x07c02fc2, 0x064c1e02, 0x098025c2, 0x060c1e02, 0x064c1e02,
+	0x09802702, 0x060c1e02, 0x0680c002, 0x06094002, 0x06803003,
+	0x06804002, 0x0d000003, 0x06094102, 0x06800002, 0x06094002,
+	0x0c000600, 0x00000000, 0x064c1e02, 0x098025c2, 0x060c1e02,
+	0x08002501, 0x08002609, 0x08002708, 0x0800290d, 0x08002d15,
+	0x08002c14, 0x0649b802, 0x06800fc3, 0x09508083, 0x0609b802,
+	0x08002609, 0x08002b17, 0x06830002, 0x06032602, 0x08032261,
+	0x08032101, 0x06800032, 0x0cc00000, 0x0680001b, 0x06800203,
+	0x07c03bc3, 0x06800712, 0x06800033, 0x07c02bf3, 0x07c01933,
+	0x07c01973, 0x07c01df3, 0x07c01e33, 0x0649c203, 0x0a654003,
+	0x06800803, 0x068f000a, 0x06c0470a, 0x06810002, 0x06800049,
+	0x06a02bcb, 0x0c07bb80, 0x00000000, 0x0d07ff83, 0x0200a08a,
+	0x06804003, 0x06af000a, 0x06c0470a, 0x06808002, 0x06800049,
+	0x06a02bcb, 0x0c07b900, 0x00000000, 0x0d07ff83, 0x0200a08a,
+	0x064e1203, 0x091e10c3, 0x0bef8043, 0x064c0903, 0x06803002,
+	0x063f0002, 0x06800002, 0x063f0002, 0x06803fc2, 0x060c0903,
+	0x06800002, 0x060c0c02, 0x06c04042, 0x060c0d02, 0x080c0101,
+	0x06840442, 0x060c2e02, 0x06bfffc2, 0x07c00ac2, 0x064c4010,
+	0x064c4211, 0x02411411, 0x04008451, 0x07c01a11, 0x05810451,
+	0x07c01a51, 0x064c1e02, 0x09802702, 0x060c1e02, 0x064e0e02,
+	0x09802242, 0x060e0e02, 0x0cc00000, 0x00000000, 0x07802bc2,
+	0x0aa0c002, 0x06800102, 0x06030502, 0x0b60c11b, 0x0cc00000,
+	0x00000000, 0x00800000, 0x00000000, 0x0c079b40, 0x00000000,
+	0x080c0a01, 0x080c2800, 0x080c0002, 0x0cc00000, 0x00400000,
+	0x064c441c, 0x0910171c, 0x0a6f801c, 0x0c7f8740, 0x00000000,
+	0x0cc00000, 0x00400000, 0x064e1214, 0x091e1514, 0x0bef0054,
+	0x078029d5, 0x0649d914, 0x0900c514, 0x0acfe554, 0x07802494,
+	0x0aa50094, 0x0aa08194, 0x0c782d00, 0x0c7824c0, 0x07802715,
+	0x06800015, 0x06c04015, 0x07802857, 0x097c1557, 0x060e1215,
+	0x07802d15, 0x0a20c055, 0x06800018, 0x06900018, 0x06c046d8,
+	0x02018d18, 0x06800014, 0x07c02a94, 0x0c782540, 0x06800114,
+	0x07802a95, 0x0aa08095, 0x0c781340, 0x078024d6, 0x0aeb4096,
+	0x07802857, 0x0aa4c712, 0x07802ad4, 0x05406514, 0x07802d15,
+	0x05801555, 0x0be0c055, 0x06800015, 0x06900015, 0x06c046d5,
+	0x02015d15, 0x02014554, 0x04440514, 0x060e1314, 0x0aa44017,
+	0x040c0614, 0x06805c16, 0x060c2116, 0x0c780340, 0x04040618,
+	0x05405514, 0x07802d15, 0x0be0c055, 0x06800015, 0x06900015,
+	0x06c046d5, 0x02015d15, 0x02014554, 0x04420514, 0x060e1314,
+	0x04060614, 0x07802596, 0x0aa14016, 0x06a2c215, 0x0aa0c056,
+	0x06a2c015, 0x06a2c115, 0x0aa10017, 0x06c04015, 0x068003d4,
+	0x09506554, 0x097c1557, 0x060e1215, 0x064e0e14, 0x098142d4,
+	0x060e0e14, 0x06800014, 0x07c02a94, 0x06800114, 0x0c781ec0,
+	0x07c02494, 0x078025d5, 0x078029d6, 0x0e000595, 0x05401516,
+	0x07802857, 0x0aa0c017, 0x02014594, 0x02014594, 0x0f000540,
+	0x02415515, 0x07802694, 0x05409514, 0x02014554, 0x05403554,
+	0x02015d15, 0x060e1315, 0x07802596, 0x0aa34016, 0x06a44215,
+	0x0aa2c056, 0x06a44015, 0x0c780240, 0x06a44115, 0x0a6580d5,
+	0x078026d4, 0x064e0c16, 0x09010596, 0x0b8e5594, 0x0cc00000,
+	0x00400000, 0x0aa10017, 0x06c0c015, 0x068005d4, 0x09506554,
 	0x097c1557, 0x060e1215, 0x064e0e14, 0x098142d4, 0x060e0e14,
-	0x06800014, 0x07c02a94, 0x06800114, 0x0c781ec0, 0x07c02494,
-	0x078025d5, 0x078029d6, 0x0e000595, 0x05401516, 0x07802857,
-	0x0aa0c017, 0x02014594, 0x02014594, 0x0f000540, 0x02415515,
-	0x07802694, 0x05409514, 0x02014554, 0x05403554, 0x02015d15,
-	0x060e1315, 0x07802596, 0x0aa34016, 0x06a44215, 0x0aa2c056,
-	0x06a44015, 0x0c780240, 0x06a44115, 0x0a6580d5, 0x078026d4,
-	0x064e0c16, 0x09010596, 0x0b8e5594, 0x0cc00000, 0x00400000,
-	0x0aa10017, 0x06c0c015, 0x068005d4, 0x09506554, 0x097c1557,
-	0x060e1215, 0x064e0e14, 0x098142d4, 0x060e0e14, 0x06800018,
-	0x06800014, 0x07c02a94, 0x06800154, 0x0c781380, 0x07c02494,
-	0x07802515, 0x0aa1c015, 0x04401555, 0x07c02515, 0x078024d5,
-	0x04401555, 0x0c780f80, 0x07c024d5, 0x07802615, 0x078029d6,
-	0x0e000595, 0x07c02655, 0x04001515, 0x07c02614, 0x0f000540,
-	0x07802694, 0x05409514, 0x02014554, 0x05403554, 0x02015d15,
-	0x060e1315, 0x07802596, 0x0aa14016, 0x06b16215, 0x0aa0c056,
-	0x06b16015, 0x06b16115, 0x07803056, 0x0aa2c016, 0x078026d4,
-	0x064e0c16, 0x09010596, 0x0b805594, 0x07c02715, 0x06800194,
-	0x0c7fd680, 0x07c02494, 0x04001514, 0x07c026d4, 0x07c02715,
-	0x06c00015, 0x060e1215, 0x06800054, 0x0c780840, 0x07c02494,
-	0x0ba74114, 0x07802855, 0x0a608015, 0x0c7ff400, 0x078026d5,
-	0x04001555, 0x07c026d5, 0x0aa0c114, 0x06800015, 0x080c2170,
-	0x0c7804c0, 0x07c02855, 0x064e0e14, 0x09814314, 0x0cc00000,
-	0x060e0e14, 0x0a6c0054, 0x078024d5, 0x0a608015, 0x0c780900,
-	0x04401555, 0x0b2f8055, 0x07c024d5, 0x0c07fd40, 0x00000000,
-	0x07802a54, 0x0aa0c0d4, 0x00000000, 0x080c2170, 0x06800014,
-	0x07c02494, 0x0cc00000, 0x00400000, 0x091c1518, 0x0aa0c014,
-	0x06900018, 0x06800018, 0x06c046d8, 0x0c780bc0, 0x02018d18,
-	0x0aa0c712, 0x090a8518, 0x090c7518, 0x07802c56, 0x0b829594,
-	0x0a8f4594, 0x0f000540, 0x064e0e14, 0x098142d4, 0x060e0e14,
-	0x091c1518, 0x0aa28014, 0x06900018, 0x0c780200, 0x06800018,
-	0x078025d5, 0x078029d6, 0x0aa70018, 0x0e000595, 0x0c7ffb40,
-	0x00000000, 0x06c046d8, 0x02018d18, 0x07802694, 0x05409514,
-	0x078029d6, 0x02415595, 0x02014554, 0x05403554, 0x02015d15,
-	0x060e1315, 0x07802714, 0x09004554, 0x0aa14015, 0x06a14214,
-	0x0aa0c115, 0x06a14014, 0x06a14114, 0x06c08014, 0x060e0d18,
-	0x0aa0c712, 0x04020618, 0x04020618, 0x0c7ff300, 0x060e1214,
-	0x07802694, 0x05409514, 0x0f000540, 0x02014554, 0x078025d5,
-	0x04001555, 0x07c025d5, 0x05403554, 0x02015d15, 0x060e1315,
-	0x07802714, 0x0a618018, 0x09c141d4, 0x060e1214, 0x068000d4,
-	0x0c7feec0, 0x07c02494, 0x06c08014, 0x09c14394, 0x060e0d18,
-	0x0aae4712, 0x04020618, 0x0c7ffdc0, 0x04020618, 0x0683ffca,
-	0x0a61000a, 0x0440128a, 0x0c780140, 0x080e1200, 0x064e1209,
-	0x091e1249, 0x0bee8049, 0x064e0009, 0x064e030a, 0x064e0e0b,
-	0x064e0c0c, 0x083f0040, 0x083f0000, 0x064c180d, 0x0980d20d,
-	0x060c180d, 0x09c0d20d, 0x060c180d, 0x0680020d, 0x0d00000d,
-	0x00000000, 0x060e0009, 0x060e030a, 0x060e0e0b, 0x0cc00000,
-	0x060e0c0c, 0x0c000cc0, 0x00000000, 0x06810109, 0x06c34749,
-	0x06090709, 0x06490b09, 0x09809009, 0x09809089, 0x06090b09,
-	0x09c09009, 0x09c09089, 0x06090b09, 0x06800009, 0x06c046c9,
-	0x02009d09, 0x06094409, 0x06900009, 0x06c046c9, 0x02009d09,
-	0x06094509, 0x0cc00000, 0x00000000, 0x0c000e00, 0x00000000,
-	0x06497f08, 0x068000c7, 0x09702207, 0x09808688, 0x06097f08,
-	0x06498e08, 0x09c080c8, 0x06098e08, 0x07802c47, 0x0b20c187,
-	0x00000000, 0x098080c8, 0x09c08788, 0x06098e08, 0x06820888,
-	0x06c00208, 0x068001c9, 0x07802c47, 0x0b20c407, 0x06800447,
-	0x06800c07, 0x09706207, 0x09808648, 0x06095108, 0x06095009,
-	0x0cc00000, 0x08095000, 0x0683ffc8, 0x06490909, 0x0a210049,
-	0x0aa0c008, 0x0c7fff40, 0x04401208, 0x0683ffc8, 0x06490909,
-	0x09343249, 0x0a2241c9, 0x0aa20008, 0x06490b09, 0x098090c9,
-	0x06090b09, 0x09c090c9, 0x06090b09, 0x0c7ffdc0, 0x04401208,
-	0x06490b09, 0x09809009, 0x09809089, 0x06090b09, 0x09c09009,
-	0x09c09089, 0x06090b09, 0x0cc00000, 0x00000000, 0x0683ffc9,
-	0x0649bb08, 0x0920c208, 0x06495307, 0x090011c7, 0x020081c8,
-	0x0aa10008, 0x0aa0c009, 0x0c7ffe40, 0x04401249, 0x0cc00000,
-	0x00000000, 0x04000289, 0x02408289, 0x0b64a008, 0x00000000,
-	0x0c077080, 0x080c2301, 0x02408289, 0x0b60d008, 0x00000000,
-	0x07400247, 0x0aa280c7, 0x04001249, 0x0c076e80, 0x080c2301,
-	0x02408289, 0x0b60d008, 0x00000000, 0x07400247, 0x0c7ffbc0,
-	0x04001249, 0x068000c7, 0x0404028a, 0x07400287, 0x0cc00000,
-	0x00000000, 0x0680000a, 0x04001249, 0x0fc011c0, 0x0aa20047,
-	0x0680004b, 0x06494207, 0x090841c7, 0x0340b1cb, 0x054082cb,
-	0x0c780340, 0x0609410b, 0x0c076880, 0x080c2301, 0x0c076a00,
-	0x00000000, 0x040002c7, 0x0c076740, 0x080c2301, 0x0c0768c0,
-	0x00000000, 0x095091cb, 0x06094107, 0x0fc011c0, 0x0aa24047,
-	0x0680004b, 0x06494207, 0x091041c7, 0x0340b1cb, 0x054082cb,
-	0x0609410b, 0x0c780600, 0x0609410b, 0x0c076340, 0x080c2301,
-	0x0c0764c0, 0x00000000, 0x040002c7, 0x0c076200, 0x080c2301,
-	0x0c076380, 0x00000000, 0x095091cb, 0x06094107, 0x0c076080,
-	0x080c2301, 0x0c076200, 0x00000000, 0x040002c7, 0x0c075f40,
-	0x080c2301, 0x0c0760c0, 0x00000000, 0x095091cb, 0x06094107,
-	0x0400128a, 0x0b8cb24a, 0x0cc00000, 0x00000000, 0x0649c707,
-	0x0aa28007, 0x044011c7, 0x0809c700, 0x06804008, 0x054031c7,
-	0x02007207, 0x040011c7, 0x070001c8, 0x09c082c8, 0x074001c8,
-	0x0649c807, 0x0aa28007, 0x044011c7, 0x0809c800, 0x06804008,
+	0x06800018, 0x06800014, 0x07c02a94, 0x06800154, 0x0c781380,
+	0x07c02494, 0x07802515, 0x0aa1c015, 0x04401555, 0x07c02515,
+	0x078024d5, 0x04401555, 0x0c780f80, 0x07c024d5, 0x07802615,
+	0x078029d6, 0x0e000595, 0x07c02655, 0x04001515, 0x07c02614,
+	0x0f000540, 0x07802694, 0x05409514, 0x02014554, 0x05403554,
+	0x02015d15, 0x060e1315, 0x07802596, 0x0aa14016, 0x06b16215,
+	0x0aa0c056, 0x06b16015, 0x06b16115, 0x07803056, 0x0aa2c016,
+	0x078026d4, 0x064e0c16, 0x09010596, 0x0b805594, 0x07c02715,
+	0x06800194, 0x0c7fd680, 0x07c02494, 0x04001514, 0x07c026d4,
+	0x07c02715, 0x06c00015, 0x060e1215, 0x06800054, 0x0c780840,
+	0x07c02494, 0x0ba74114, 0x07802855, 0x0a608015, 0x0c7ff400,
+	0x078026d5, 0x04001555, 0x07c026d5, 0x0aa0c114, 0x06800015,
+	0x080c2170, 0x0c7804c0, 0x07c02855, 0x064e0e14, 0x09814314,
+	0x0cc00000, 0x060e0e14, 0x0a6c0054, 0x078024d5, 0x0a608015,
+	0x0c780900, 0x04401555, 0x0b2f8055, 0x07c024d5, 0x0c07fd40,
+	0x00000000, 0x07802a54, 0x0aa0c0d4, 0x00000000, 0x080c2170,
+	0x06800014, 0x07c02494, 0x0cc00000, 0x00400000, 0x091c1518,
+	0x0aa0c014, 0x06900018, 0x06800018, 0x06c046d8, 0x0c780bc0,
+	0x02018d18, 0x0aa0c712, 0x090a8518, 0x090c7518, 0x07802c56,
+	0x0b829594, 0x0a8f4594, 0x0f000540, 0x064e0e14, 0x098142d4,
+	0x060e0e14, 0x091c1518, 0x0aa28014, 0x06900018, 0x0c780200,
+	0x06800018, 0x078025d5, 0x078029d6, 0x0aa70018, 0x0e000595,
+	0x0c7ffb40, 0x00000000, 0x06c046d8, 0x02018d18, 0x07802694,
+	0x05409514, 0x078029d6, 0x02415595, 0x02014554, 0x05403554,
+	0x02015d15, 0x060e1315, 0x07802714, 0x09004554, 0x0aa14015,
+	0x06a14214, 0x0aa0c115, 0x06a14014, 0x06a14114, 0x06c08014,
+	0x060e0d18, 0x0aa0c712, 0x04020618, 0x04020618, 0x0c7ff300,
+	0x060e1214, 0x07802694, 0x05409514, 0x0f000540, 0x02014554,
+	0x078025d5, 0x04001555, 0x07c025d5, 0x05403554, 0x02015d15,
+	0x060e1315, 0x07802714, 0x0a618018, 0x09c141d4, 0x060e1214,
+	0x068000d4, 0x0c7feec0, 0x07c02494, 0x06c08014, 0x09c14394,
+	0x060e0d18, 0x0aae4712, 0x04020618, 0x0c7ffdc0, 0x04020618,
+	0x0683ffca, 0x0a61000a, 0x0440128a, 0x0c780140, 0x080e1200,
+	0x064e1209, 0x091e1249, 0x0bee8049, 0x064e0009, 0x064e030a,
+	0x064e0e0b, 0x064e0c0c, 0x083f0040, 0x083f0000, 0x064c180d,
+	0x0980d20d, 0x060c180d, 0x09c0d20d, 0x060c180d, 0x0680020d,
+	0x0d00000d, 0x00000000, 0x060e0009, 0x060e030a, 0x060e0e0b,
+	0x0cc00000, 0x060e0c0c, 0x0c000cc0, 0x00000000, 0x06810109,
+	0x06c34749, 0x06090709, 0x06490b09, 0x09809009, 0x09809089,
+	0x06090b09, 0x09c09009, 0x09c09089, 0x06090b09, 0x06800009,
+	0x06c046c9, 0x02009d09, 0x06094409, 0x06900009, 0x06c046c9,
+	0x02009d09, 0x06094509, 0x0cc00000, 0x00000000, 0x0c000e00,
+	0x00000000, 0x06497f08, 0x068000c7, 0x09702207, 0x09808688,
+	0x06097f08, 0x06498e08, 0x09c080c8, 0x06098e08, 0x07802c47,
+	0x0b20c187, 0x00000000, 0x098080c8, 0x09c08788, 0x06098e08,
+	0x06820888, 0x06c00208, 0x068001c9, 0x07802c47, 0x0b20c407,
+	0x06800447, 0x06800c07, 0x09706207, 0x09808648, 0x06095108,
+	0x06095009, 0x0cc00000, 0x08095000, 0x0683ffc8, 0x06490909,
+	0x0a210049, 0x0aa0c008, 0x0c7fff40, 0x04401208, 0x0683ffc8,
+	0x06490909, 0x09343249, 0x0a2241c9, 0x0aa20008, 0x06490b09,
+	0x098090c9, 0x06090b09, 0x09c090c9, 0x06090b09, 0x0c7ffdc0,
+	0x04401208, 0x06490b09, 0x09809009, 0x09809089, 0x06090b09,
+	0x09c09009, 0x09c09089, 0x06090b09, 0x0cc00000, 0x00000000,
+	0x0683ffc9, 0x0649bb08, 0x0920c208, 0x06495307, 0x090011c7,
+	0x020081c8, 0x0aa10008, 0x0aa0c009, 0x0c7ffe40, 0x04401249,
+	0x0cc00000, 0x00000000, 0x04000289, 0x02408289, 0x0b64a008,
+	0x00000000, 0x0c077100, 0x080c2301, 0x02408289, 0x0b60d008,
+	0x00000000, 0x07400247, 0x0aa280c7, 0x04001249, 0x0c076f00,
+	0x080c2301, 0x02408289, 0x0b60d008, 0x00000000, 0x07400247,
+	0x0c7ffbc0, 0x04001249, 0x068000c7, 0x0404028a, 0x07400287,
+	0x0cc00000, 0x00000000, 0x0680000a, 0x04001249, 0x0fc011c0,
+	0x0aa20047, 0x0680004b, 0x06494207, 0x090841c7, 0x0340b1cb,
+	0x054082cb, 0x0c780340, 0x0609410b, 0x0c076900, 0x080c2301,
+	0x0c076a80, 0x00000000, 0x040002c7, 0x0c0767c0, 0x080c2301,
+	0x0c076940, 0x00000000, 0x095091cb, 0x06094107, 0x0fc011c0,
+	0x0aa24047, 0x0680004b, 0x06494207, 0x091041c7, 0x0340b1cb,
+	0x054082cb, 0x0609410b, 0x0c780600, 0x0609410b, 0x0c0763c0,
+	0x080c2301, 0x0c076540, 0x00000000, 0x040002c7, 0x0c076280,
+	0x080c2301, 0x0c076400, 0x00000000, 0x095091cb, 0x06094107,
+	0x0c076100, 0x080c2301, 0x0c076280, 0x00000000, 0x040002c7,
+	0x0c075fc0, 0x080c2301, 0x0c076140, 0x00000000, 0x095091cb,
+	0x06094107, 0x0400128a, 0x0b8cb24a, 0x0cc00000, 0x00000000,
+	0x0649c707, 0x0aa28007, 0x044011c7, 0x0809c700, 0x06804008,
 	0x054031c7, 0x02007207, 0x040011c7, 0x070001c8, 0x09c082c8,
-	0x074001c8, 0x0cc00000, 0x00000000, 0x0200d308, 0x0440134d,
-	0x0700034d, 0x0540234d, 0x0200d349, 0x0700034e, 0x0400040e,
-	0x0400134d, 0x0700034d, 0x0900234d, 0x094a240d, 0x09408390,
-	0x09508390, 0x09608390, 0x09708390, 0x06800210, 0x0d000010,
-	0x060c220e, 0x0cc00000, 0x00000000, 0x0649cd09, 0x06800047,
-	0x054101c7, 0x020091c9, 0x0609cd09, 0x069fffc7, 0x07c03b47,
-	0x07c03b87, 0x07c03c47, 0x07c00a07, 0x07c00a47, 0x07c00a87,
-	0x07c03c87, 0x07c01747, 0x06800207, 0x0c7f51c0, 0x07c03bc7,
-	0x07803c0a, 0x0a60c00a, 0x0c780c80, 0x0680004a, 0x07802dca,
-	0x0aa0800a, 0x0c780b80, 0x0649cf07, 0x0a2180c7, 0x07803c07,
-	0x0aa0c007, 0x0680004a, 0x0680000a, 0x0c7809c0, 0x07807347,
-	0x07801f48, 0x0a803207, 0x0c7808c0, 0x0680004a, 0x07802407,
-	0x07801f08, 0x0a803207, 0x0c780780, 0x0680004a, 0x07802047,
-	0x07802e08, 0x02009207, 0x0aa18009, 0x0a803247, 0x0a802248,
-	0x0c7800c0, 0x0c780540, 0x0680004a, 0x07802007, 0x07802e48,
-	0x0a803207, 0x0c780400, 0x0680004a, 0x0a618147, 0x07801f87,
-	0x07801fc8, 0x0a803207, 0x0c780280, 0x0680004a, 0x07802147,
-	0x0aa1c087, 0x07801807, 0x0a4033c7, 0x07801847, 0x0a803407,
-	0x0c780080, 0x0680004a, 0x0cc00000, 0x07c02dca, 0x06490908,
-	0x0581f208, 0x0a6f8008, 0x00000000, 0x06490708, 0x09808648,
-	0x09c08488, 0x06090708, 0x068400c8, 0x096e820b, 0x097e120a,
-	0x07802407, 0x040011c7, 0x048031c7, 0x09542207, 0x0580124a,
-	0x06094809, 0x06094908, 0x06800008, 0x098092c8, 0x07801987,
-	0x09405247, 0x058051c7, 0x040011c7, 0x097c2207, 0x06094809,
-	0x06094908, 0x0c07be00, 0x00000000, 0x06490708, 0x09c08648,
-	0x09808488, 0x06090708, 0x0cc00000, 0x00000000, 0x0649cf07,
-	0x06800048, 0x0a2100c7, 0x07c01e48, 0x0cc00000, 0x00000000,
-	0x07801988, 0x0aa0c008, 0x0a210807, 0x00000000, 0x0cc00000,
-	0x00000000, 0x0c07b900, 0x00000000, 0x0c07b140, 0x00000000,
-	0x0680001b, 0x0780294e, 0x0a61038e, 0x07802c4e, 0x0c780380,
-	0x0980b00b, 0x0ae6011b, 0x0c07f180, 0x00000000, 0x0400128a,
-	0x0b80438a, 0x00000000, 0x0680000a, 0x040012cb, 0x0b8f834b,
-	0x0b8f730a, 0x0c780380, 0x00000000, 0x0ae3011b, 0x0c07ee80,
-	0x044012cb, 0x0c07ee00, 0x040012cb, 0x0400128a, 0x0b80438a,
-	0x00000000, 0x0680000a, 0x040022cb, 0x0b8f634b, 0x0b8f530a,
-	0x0cc00000, 0x0680001b, 0x07803c07, 0x07802e88, 0x0a402207,
-	0x0c7809c0, 0x07c02e87, 0x07802c49, 0x0780294a, 0x0a60c30a,
-	0x07802c8a, 0x0540128a, 0x06800008, 0x0b80a247, 0x095084c7,
-	0x02407247, 0x0b8fd288, 0x04001208, 0x0649cd07, 0x040011c7,
-	0x0609cd07, 0x0cc00000, 0x06800047, 0x0aa0c007, 0x06800049,
-	0x07c02d89, 0x0aa0c712, 0x07c02cc7, 0x05401208, 0x094084c8,
-	0x07c02d08, 0x0780188a, 0x078018cb, 0x07802ccc, 0x07802d0d,
-	0x0c07ebc0, 0x06800009, 0x07802cc7, 0x0aa18007, 0x044011c7,
-	0x0ba0c707, 0x0c7fffc0, 0x0441c1c7, 0x07c02b07, 0x07802cc7,
-	0x07c01887, 0x07802d07, 0x07c018c7, 0x0cc00000, 0x06800007,
-	0x0c780380, 0x06800087, 0x0c780300, 0x06800147, 0x0c780280,
-	0x06800187, 0x0c071dc0, 0x080c2301, 0x07c03c07, 0x0c071d00,
-	0x080c2301, 0x0aad41c7, 0x0aad8007, 0x0aadc047, 0x07c01ec7,
-	0x07803bc8, 0x09061248, 0x07c02dc9, 0x0a250208, 0x07803c08,
-	0x0aa08008, 0x0c7f1dc0, 0x0649cf09, 0x0a20c0c9, 0x0aa2c087,
-	0x0c7f1cc0, 0x07802008, 0x0aa20148, 0x07801c48, 0x0a614008,
-	0x0aa08087, 0x0c7f1b40, 0x06800048, 0x07c01c48, 0x07c01c08,
-	0x0649c909, 0x04001249, 0x0609c909, 0x06800009, 0x07c01d89,
-	0x0c079a00, 0x00000000, 0x0c07a040, 0x00000000, 0x0c071440,
-	0x080c2301, 0x07803b8d, 0x0a806347, 0x07803bc8, 0x06800049,
-	0x07c02dc9, 0x0c780080, 0x07c03b87, 0x09082248, 0x0aa1c049,
-	0x0680000a, 0x0c06e800, 0x06c0000a, 0x06800049, 0x09482209,
-	0x07c03bc8, 0x06af000a, 0x06c0470a, 0x054091c7, 0x0200a1ca,
-	0x06804009, 0x06b0c00b, 0x0c06e1c0, 0x00000000, 0x0780c007,
-	0x06905348, 0x0a803207, 0x0c7f1100, 0x07c03b8d, 0x0780c047,
-	0x09105207, 0x07803b4e, 0x0a803388, 0x0c7802c0, 0x07c03b48,
-	0x07803bc7, 0x0be20047, 0x068c000a, 0x06c0470a, 0x06808009,
-	0x06b0400b, 0x0c06dd00, 0x00000000, 0x0c780900, 0x068f000a,
-	0x06c0470a, 0x07803b48, 0x0540a1c8, 0x0200a1ca, 0x06806009,
-	0x06b0400b, 0x0c06da80, 0x00000000, 0x07804007, 0x06905348,
-	0x0a805207, 0x00000000, 0x07c03b8d, 0x0c7f0940, 0x07c03b4e,
-	0x0680000a, 0x0c00f000, 0x00000000, 0x0c016900, 0x00000000,
-	0x07803bc7, 0x0be34107, 0x068c000a, 0x06c0470a, 0x06804009,
-	0x06b0400b, 0x0c06d580, 0x00000000, 0x068cc00a, 0x06c0470a,
-	0x06802009, 0x06b0a00b, 0x0c06d400, 0x00000000, 0x0c012f40,
-	0x00000000, 0x07803bc7, 0x0be34107, 0x068d000a, 0x06c0470a,
-	0x06804009, 0x06b0c00b, 0x0c06d180, 0x00000000, 0x0c780180,
-	0x068c000a, 0x06c0470a, 0x0680c009, 0x0c06d000, 0x06b0400b,
-	0x078020c8, 0x0f8001c8, 0x0649cf0a, 0x0be5808a, 0x07803bca,
-	0x0be5020a, 0x0780200a, 0x0aa4814a, 0x07801f4a, 0x0a810287,
-	0x0400128a, 0x06800049, 0x03409209, 0x04401249, 0x0280a289,
-	0x0a80a287, 0x0780394a, 0x0a62000a, 0x07801eca, 0x0a61008a,
-	0x0680004a, 0x0c780100, 0x07c00b8a, 0x0680004a, 0x07c00b4a,
-	0x07c01f47, 0x07802107, 0x0a61c007, 0x068000c9, 0x0fc011c0,
-	0x0aa10007, 0x00000000, 0x0fc011c0, 0x04001247, 0x07c01f09,
-	0x07802007, 0x0a614147, 0x00000000, 0x0c06f2c0, 0x080c2301,
-	0x07c01f87, 0x07802147, 0x0a65c007, 0x07802187, 0x0f8001c7,
-	0x07807388, 0x07c01808, 0x07c07387, 0x078074c7, 0x07c01847,
-	0x06800007, 0x07c074c7, 0x07c07507, 0x078021c7, 0x0aa2c007,
-	0x07801f07, 0x0a6240c7, 0x00000000, 0x0c06edc0, 0x080c2301,
-	0x0c06ef40, 0x00000000, 0x07c074c7, 0x058101c7, 0x07c07507,
-	0x0780738f, 0x078074d0, 0x07802147, 0x06800048, 0x0a422207,
-	0x07807547, 0x07c01807, 0x078075c7, 0x07c01847, 0x06800007,
-	0x07c07547, 0x07c07587, 0x07c075c7, 0x07c07607, 0x07803a87,
-	0x0aa54047, 0x00000000, 0x0c06e7c0, 0x080c2301, 0x0c06e940,
-	0x00000000, 0x07c07547, 0x058101c7, 0x07c07587, 0x078021c7,
-	0x0aa2c007, 0x07801f07, 0x0a6240c7, 0x00000000, 0x0c06e4c0,
-	0x080c2301, 0x0c06e640, 0x00000000, 0x07c075c7, 0x058101c7,
-	0x07c07607, 0x0780754f, 0x078075d0, 0x0c079500, 0x00000000,
-	0x07802dc7, 0x0a608007, 0x0c782180, 0x07801e87, 0x069fffc8,
-	0x0b803207, 0x040011c7, 0x06800147, 0x07c01e87, 0x07802d07,
-	0x078023c8, 0x0b802207, 0x0c780200, 0x0780188a, 0x078018cb,
-	0x0680000c, 0x078023cd, 0x06800049, 0x0c07a640, 0x07c01e49,
-	0x07801d08, 0x0649cf09, 0x0aa28008, 0x07803c0a, 0x0aa0800a,
-	0x0c781bc0, 0x04401208, 0x07c01d08, 0x0aa08008, 0x0c781ac0,
-	0x09c09089, 0x0609cf09, 0x0a22c309, 0x0780204a, 0x0a62400a,
-	0x07802e0a, 0x0aa1c00a, 0x07801f0a, 0x0aa0c0ca, 0x0680004a,
-	0x0680008a, 0x0c7817c0, 0x07c01d0a, 0x0680000a, 0x07c01d0a,
-	0x0688000a, 0x0c06b040, 0x06c0000a, 0x07803bc7, 0x0be54107,
-	0x068001ca, 0x06031e0a, 0x0680001b, 0x0649ce09, 0x0aa10009,
-	0x00000000, 0x0809ce00, 0x08007401, 0x06431e09, 0x0bee4049,
-	0x00000000, 0x0649cf07, 0x0a2200c7, 0x07801d87, 0x0aa18007,
-	0x07801ec7, 0x0aa10087, 0x06800207, 0x0c7ed4c0, 0x07c03bc7,
-	0x06800013, 0x07c02cd3, 0x07c02d13, 0x07c02e93, 0x07c01893,
-	0x07c018d3, 0x06803fc7, 0x07c02b07, 0x06800007, 0x07c02547,
-	0x07c025c7, 0x07c02607, 0x07802c07, 0x040011c7, 0x07c024c7,
-	0x06800047, 0x060e0c07, 0x07c026c7, 0x07c02507, 0x068003c7,
-	0x07c02807, 0x06805c07, 0x060c2107, 0x080c2170, 0x06800087,
-	0x07c02a47, 0x06800018, 0x07801ec7, 0x0a61c087, 0x06800007,
-	0x07800b48, 0x0aa1c008, 0x06800088, 0x0c780140, 0x07c00b48,
-	0x07800b47, 0x07801e48, 0x02c07207, 0x07c01e47, 0x068003c7,
-	0x07c02fc7, 0x06800407, 0x060c2407, 0x06800007, 0x07807048,
-	0x06804009, 0x05403287, 0x0200a289, 0x0400128a, 0x0700028b,
-	0x060c220b, 0x0400128a, 0x0700028b, 0x0400128a, 0x0700028c,
-	0x096102cc, 0x060c220b, 0x0400128a, 0x0700028b, 0x0400128a,
-	0x0700028c, 0x096102cc, 0x060c220b, 0x040011c7, 0x0b8ee207,
-	0x00000000, 0x07801d07, 0x0aa08007, 0x0c7ec340, 0x06800007,
-	0x07c01947, 0x06a00007, 0x060c3d07, 0x07802dc7, 0x0a618007,
-	0x00000000, 0x0c079240, 0x00000000, 0x0aa08007, 0x0c7ec080,
-	0x07802047, 0x07c02e07, 0x07802007, 0x07c02e47, 0x07801ec7,
-	0x07c02087, 0x07801f47, 0x07c07347, 0x07801f07, 0x07c02407,
-	0x07801f87, 0x07c01fc7, 0x0780248a, 0x0a6fc00a, 0x00000000,
-	0x0c0730c0, 0x00000000, 0x07802dc7, 0x0aa10007, 0x00000000,
-	0x0c0728c0, 0x00000000, 0x0c073480, 0x00000000, 0x07802087,
-	0x06840009, 0x0682629a, 0x0aa1c087, 0x06800008, 0x0682305a,
-	0x0aa10147, 0x06800048, 0x06800088, 0x06840009, 0x07c02788,
-	0x07c02689, 0x06800007, 0x07c02a87, 0x07802c8a, 0x07802107,
-	0x0a630007, 0x07802409, 0x0aa280c9, 0x0540128a, 0x0580128a,
-	0x06490707, 0x09807087, 0x098070c7, 0x06090707, 0x06495107,
-	0x098073c7, 0x06095107, 0x07c023ca, 0x07802947, 0x094421c9,
-	0x07c02947, 0x0a648387, 0x068000c9, 0x06495107, 0x094041c9,
-	0x06800009, 0x097821c9, 0x06095107, 0x06490707, 0x09807447,
-	0x06090707, 0x06498e07, 0x09807787, 0x09c070c7, 0x06098e07,
-	0x07802087, 0x0aa0c087, 0x0682519a, 0x068214da, 0x07803bc8,
-	0x090821c8, 0x0aa18087, 0x06800087, 0x09482207, 0x0690000a,
-	0x0c067f40, 0x06c0000a, 0x0c784b40, 0x07c03bc8, 0x07802dc7,
-	0x0aa18007, 0x00000000, 0x0c077b80, 0x00000000, 0x0aa08007,
-	0x0c7ea9c0, 0x06800007, 0x07803bc8, 0x09082208, 0x0aa10008,
-	0x0684000a, 0x0c067b40, 0x06c0000a, 0x07c03bc7, 0x07802d87,
-	0x0aa34007, 0x07802c47, 0x0b22c2c7, 0x07802cc7, 0x0a614007,
-	0x06495108, 0x09c08608, 0x0c7800c0, 0x07c02d87, 0x09808608,
-	0x06095108, 0x08095017, 0x08095000, 0x0c784380, 0x00000000,
-	0x0540928c, 0x0200a24a, 0x06c046ca, 0x0200ad0a, 0x0400130c,
-	0x0481f30c, 0x07c02b4c, 0x0643500c, 0x0580f30c, 0x0bef804c,
-	0x00000000, 0x0643530c, 0x0900c30c, 0x0a6f800c, 0x00000000,
-	0x0603510a, 0x06803f0a, 0x0603520a, 0x0c792a40, 0x0603500b,
-	0x0cc00000, 0x00000000, 0x07802cc9, 0x07c02ac9, 0x07802889,
-	0x07c03049, 0x07802809, 0x0aa08009, 0x0cc00000, 0x064e0e09,
-	0x09809309, 0x098092c9, 0x0cc00000, 0x060e0e09, 0x06435007,
-	0x0580f1c7, 0x0bef8047, 0x0aa14712, 0x06800007, 0x07802d07,
-	0x050011c7, 0x048011c7, 0x0b60c709, 0x06808008, 0x0680c008,
-	0x0c78eb80, 0x00000000, 0x0c7806c0, 0x07802807, 0x0aaf8387,
-	0x00000000, 0x07802947, 0x0aaec387, 0x064e0407, 0x091c2207,
-	0x0a24c0c8, 0x080c3e07, 0x064c3f07, 0x064c3f09, 0x09004249,
-	0x0581b1c7, 0x0a234047, 0x090241c7, 0x0a210088, 0x0aa20289,
-	0x0aa1c309, 0x0be18087, 0x0a21c048, 0x0aa102c9, 0x0aa0c309,
-	0x0be08047, 0x0c7800c0, 0x06800049, 0x07c01e49, 0x0cc00000,
-	0x00000000, 0x07800dc8, 0x0aa0c048, 0x0c780780, 0x00000000,
-	0x06800008, 0x07c00dc8, 0x07800d89, 0x07801f08, 0x09610248,
-	0x0609d509, 0x0aa18048, 0x0aa20088, 0x00000000, 0x0680774a,
-	0x0c780180, 0x00000000, 0x068077ca, 0x0c7800c0, 0x00000000,
-	0x0680784a, 0x07000288, 0x0400128a, 0x07000289, 0x09610209,
-	0x0609d608, 0x0649d308, 0x098083c8, 0x0609d308, 0x08007401,
-	0x0649d308, 0x0a6fc008, 0x00000000, 0x0cc00000, 0x00000000,
-	0x0680000c, 0x0680002a, 0x064c2907, 0x0a20c407, 0x0c7e8700,
-	0x00000000, 0x0fc081c0, 0x0aaeffc7, 0x0200c1cc, 0x064c2907,
-	0x0a20c407, 0x0c7e8540, 0x00000000, 0x0fc081c0, 0x0aaeffc7,
-	0x0202a1ea, 0x0aa5400c, 0x0aa1418c, 0x0462d1cc, 0x0c500880,
-	0x0a61004c, 0x0c780e80, 0x06800047, 0x07c01c47, 0x064c0007,
-	0x0be14207, 0x064c2907, 0x0be0c407, 0x0d07ff2a, 0x0fc081c0,
-	0x064c0007, 0x0be10207, 0x064c2907, 0x0be08407, 0x0c7ff780,
-	0x0c7e7f40, 0x00000000, 0x0c067b00, 0x080c2301, 0x064c232b,
-	0x05810aeb, 0x048ffaeb, 0x068f000a, 0x06c0470a, 0x0540a1c7,
-	0x0200a1ca, 0x06804009, 0x0c064bc0, 0x06b0400b, 0x07804007,
-	0x06905348, 0x0a80f207, 0x0c7e7b00, 0x0c067700, 0x080c2301,
-	0x064c232b, 0x05810aeb, 0x048ffaeb, 0x0fc011c0, 0x0aa14047,
-	0x04001aeb, 0x0fc071c0, 0x04007aeb, 0x07c017c7, 0x0c780140,
-	0x00000000, 0x0680004a, 0x0c005ec0, 0x00000000, 0x048071eb,
-	0x0580322b, 0x0aa14007, 0x06800209, 0x04001208, 0x024071c9,
-	0x0f8001c7, 0x0262a22a, 0x0c57f440, 0x0c7ff280, 0x0680002b,
-	0x07803d0d, 0x0a22830d, 0x07802f87, 0x09005207, 0x04001208,
-	0x0c00cf00, 0x0202b22b, 0x090a5207, 0x04001208, 0x0c00ce00,
-	0x0202b22b, 0x0a21440d, 0x00000000, 0x0fc041c0, 0x07c02fc7,
-	0x04004aeb, 0x0c7ff940, 0x00000000, 0x00000000, 0x00000000,
+	0x074001c8, 0x0649c807, 0x0aa28007, 0x044011c7, 0x0809c800,
+	0x06804008, 0x054031c7, 0x02007207, 0x040011c7, 0x070001c8,
+	0x09c082c8, 0x074001c8, 0x0cc00000, 0x00000000, 0x0200d308,
+	0x0440134d, 0x0700034d, 0x0540234d, 0x0200d349, 0x0700034e,
+	0x0400040e, 0x0400134d, 0x0700034d, 0x0900234d, 0x094a240d,
+	0x09408390, 0x09508390, 0x09608390, 0x09708390, 0x06800210,
+	0x0d000010, 0x060c220e, 0x0cc00000, 0x00000000, 0x0649cd09,
+	0x06800047, 0x054101c7, 0x020091c9, 0x0609cd09, 0x069fffc7,
+	0x07c03b47, 0x07c03b87, 0x07c03c47, 0x07c00a07, 0x07c00a47,
+	0x07c00a87, 0x07c03c87, 0x07c01747, 0x06800207, 0x0c7f5240,
+	0x07c03bc7, 0x07803c0a, 0x0a60c00a, 0x0c780c80, 0x0680004a,
+	0x07802dca, 0x0aa0800a, 0x0c780b80, 0x0649cf07, 0x0a2180c7,
+	0x07803c07, 0x0aa0c007, 0x0680004a, 0x0680000a, 0x0c7809c0,
+	0x07807347, 0x07801f48, 0x0a803207, 0x0c7808c0, 0x0680004a,
+	0x07802407, 0x07801f08, 0x0a803207, 0x0c780780, 0x0680004a,
+	0x07802047, 0x07802e08, 0x02009207, 0x0aa18009, 0x0a803247,
+	0x0a802248, 0x0c7800c0, 0x0c780540, 0x0680004a, 0x07802007,
+	0x07802e48, 0x0a803207, 0x0c780400, 0x0680004a, 0x0a618147,
+	0x07801f87, 0x07801fc8, 0x0a803207, 0x0c780280, 0x0680004a,
+	0x07802147, 0x0aa1c087, 0x07801807, 0x0a4033c7, 0x07801847,
+	0x0a803407, 0x0c780080, 0x0680004a, 0x0cc00000, 0x07c02dca,
+	0x06490908, 0x0581f208, 0x0a6f8008, 0x00000000, 0x06490708,
+	0x09808648, 0x09c08488, 0x06090708, 0x068400c8, 0x096e820b,
+	0x097e120a, 0x07802407, 0x040011c7, 0x048031c7, 0x09542207,
+	0x0580124a, 0x06094809, 0x06094908, 0x06800008, 0x098092c8,
+	0x07801987, 0x09405247, 0x058051c7, 0x040011c7, 0x097c2207,
+	0x06094809, 0x06094908, 0x0c07be00, 0x00000000, 0x06490708,
+	0x09c08648, 0x09808488, 0x06090708, 0x0cc00000, 0x00000000,
+	0x0649cf07, 0x06800048, 0x0a2100c7, 0x07c01e48, 0x0cc00000,
+	0x00000000, 0x07801988, 0x0aa0c008, 0x0a210807, 0x00000000,
+	0x0cc00000, 0x00000000, 0x0c07b900, 0x00000000, 0x0c07b140,
+	0x00000000, 0x0680001b, 0x0780294e, 0x0a61038e, 0x07802c4e,
+	0x0c780380, 0x0980b00b, 0x0ae6011b, 0x0c07f180, 0x00000000,
+	0x0400128a, 0x0b80438a, 0x00000000, 0x0680000a, 0x040012cb,
+	0x0b8f834b, 0x0b8f730a, 0x0c780380, 0x00000000, 0x0ae3011b,
+	0x0c07ee80, 0x044012cb, 0x0c07ee00, 0x040012cb, 0x0400128a,
+	0x0b80438a, 0x00000000, 0x0680000a, 0x040022cb, 0x0b8f634b,
+	0x0b8f530a, 0x0cc00000, 0x0680001b, 0x07803c07, 0x07802e88,
+	0x0a402207, 0x0c7809c0, 0x07c02e87, 0x07802c49, 0x0780294a,
+	0x0a60c30a, 0x07802c8a, 0x0540128a, 0x06800008, 0x0b80a247,
+	0x095084c7, 0x02407247, 0x0b8fd288, 0x04001208, 0x0649cd07,
+	0x040011c7, 0x0609cd07, 0x0cc00000, 0x06800047, 0x0aa0c007,
+	0x06800049, 0x07c02d89, 0x0aa0c712, 0x07c02cc7, 0x05401208,
+	0x094084c8, 0x07c02d08, 0x0780188a, 0x078018cb, 0x07802ccc,
+	0x07802d0d, 0x0c07ebc0, 0x06800009, 0x07802cc7, 0x0aa18007,
+	0x044011c7, 0x0ba0c707, 0x0c7fffc0, 0x0441c1c7, 0x07c02b07,
+	0x07802cc7, 0x07c01887, 0x07802d07, 0x07c018c7, 0x0cc00000,
+	0x06800007, 0x0c780380, 0x06800087, 0x0c780300, 0x06800147,
+	0x0c780280, 0x06800187, 0x0c071e40, 0x080c2301, 0x07c03c07,
+	0x0c071d80, 0x080c2301, 0x0aad41c7, 0x0aad8007, 0x0aadc047,
+	0x07c01ec7, 0x07803bc8, 0x09061248, 0x07c02dc9, 0x0a250208,
+	0x07803c08, 0x0aa08008, 0x0c7f1e40, 0x0649cf09, 0x0a20c0c9,
+	0x0aa2c087, 0x0c7f1d40, 0x07802008, 0x0aa20148, 0x07801c48,
+	0x0a614008, 0x0aa08087, 0x0c7f1bc0, 0x06800048, 0x07c01c48,
+	0x07c01c08, 0x0649c909, 0x04001249, 0x0609c909, 0x06800009,
+	0x07c01d89, 0x0c079a00, 0x00000000, 0x0c07a040, 0x00000000,
+	0x0c0714c0, 0x080c2301, 0x07803b8d, 0x0a806347, 0x07803bc8,
+	0x06800049, 0x07c02dc9, 0x0c780080, 0x07c03b87, 0x09082248,
+	0x0aa1c049, 0x0680000a, 0x0c06e900, 0x06c0000a, 0x06800049,
+	0x09482209, 0x07c03bc8, 0x06af000a, 0x06c0470a, 0x054091c7,
+	0x0200a1ca, 0x06804009, 0x06b0c00b, 0x0c06e2c0, 0x00000000,
+	0x0780c007, 0x06905348, 0x0a803207, 0x0c7f1180, 0x07c03b8d,
+	0x0780c047, 0x09105207, 0x07803b4e, 0x0a803388, 0x0c7802c0,
+	0x07c03b48, 0x07803bc7, 0x0be20047, 0x068c000a, 0x06c0470a,
+	0x06808009, 0x06b0400b, 0x0c06de00, 0x00000000, 0x0c780900,
+	0x068f000a, 0x06c0470a, 0x07803b48, 0x0540a1c8, 0x0200a1ca,
+	0x06806009, 0x06b0400b, 0x0c06db80, 0x00000000, 0x07804007,
+	0x06905348, 0x0a805207, 0x00000000, 0x07c03b8d, 0x0c7f09c0,
+	0x07c03b4e, 0x0680000a, 0x0c00ef40, 0x00000000, 0x0c016800,
+	0x00000000, 0x07803bc7, 0x0be34107, 0x068c000a, 0x06c0470a,
+	0x06804009, 0x06b0400b, 0x0c06d680, 0x00000000, 0x068cc00a,
+	0x06c0470a, 0x06802009, 0x06b0a00b, 0x0c06d500, 0x00000000,
+	0x0c012e40, 0x00000000, 0x07803bc7, 0x0be34107, 0x068d000a,
+	0x06c0470a, 0x06804009, 0x06b0c00b, 0x0c06d280, 0x00000000,
+	0x0c780180, 0x068c000a, 0x06c0470a, 0x0680c009, 0x0c06d100,
+	0x06b0400b, 0x078020c8, 0x0f8001c8, 0x0649cf0a, 0x0be5808a,
+	0x07803bca, 0x0be5020a, 0x0780200a, 0x0aa4814a, 0x07801f4a,
+	0x0a810287, 0x0400128a, 0x06800049, 0x03409209, 0x04401249,
+	0x0280a289, 0x0a80a287, 0x0780394a, 0x0a62000a, 0x07801eca,
+	0x0a61008a, 0x0680004a, 0x0c780100, 0x07c00b8a, 0x0680004a,
+	0x07c00b4a, 0x07c01f47, 0x07802107, 0x0a61c007, 0x068000c9,
+	0x0fc011c0, 0x0aa10007, 0x00000000, 0x0fc011c0, 0x04001247,
+	0x07c01f09, 0x07802007, 0x0a614147, 0x00000000, 0x0c06f340,
+	0x080c2301, 0x07c01f87, 0x07802147, 0x0a65c007, 0x07802187,
+	0x0f8001c7, 0x07807388, 0x07c01808, 0x07c07387, 0x078074c7,
+	0x07c01847, 0x06800007, 0x07c074c7, 0x07c07507, 0x078021c7,
+	0x0aa2c007, 0x07801f07, 0x0a6240c7, 0x00000000, 0x0c06ee40,
+	0x080c2301, 0x0c06efc0, 0x00000000, 0x07c074c7, 0x058101c7,
+	0x07c07507, 0x0780738f, 0x078074d0, 0x07802147, 0x06800048,
+	0x0a422207, 0x07807547, 0x07c01807, 0x078075c7, 0x07c01847,
+	0x06800007, 0x07c07547, 0x07c07587, 0x07c075c7, 0x07c07607,
+	0x07803a87, 0x0aa54047, 0x00000000, 0x0c06e840, 0x080c2301,
+	0x0c06e9c0, 0x00000000, 0x07c07547, 0x058101c7, 0x07c07587,
+	0x078021c7, 0x0aa2c007, 0x07801f07, 0x0a6240c7, 0x00000000,
+	0x0c06e540, 0x080c2301, 0x0c06e6c0, 0x00000000, 0x07c075c7,
+	0x058101c7, 0x07c07607, 0x0780754f, 0x078075d0, 0x0c079500,
+	0x00000000, 0x07802dc7, 0x0a608007, 0x0c782180, 0x07801e87,
+	0x069fffc8, 0x0b803207, 0x040011c7, 0x06800147, 0x07c01e87,
+	0x07802d07, 0x078023c8, 0x0b802207, 0x0c780200, 0x0780188a,
+	0x078018cb, 0x0680000c, 0x078023cd, 0x06800049, 0x0c07a640,
+	0x07c01e49, 0x07801d08, 0x0649cf09, 0x0aa28008, 0x07803c0a,
+	0x0aa0800a, 0x0c781bc0, 0x04401208, 0x07c01d08, 0x0aa08008,
+	0x0c781ac0, 0x09c09089, 0x0609cf09, 0x0a22c309, 0x0780204a,
+	0x0a62400a, 0x07802e0a, 0x0aa1c00a, 0x07801f0a, 0x0aa0c0ca,
+	0x0680004a, 0x0680008a, 0x0c7817c0, 0x07c01d0a, 0x0680000a,
+	0x07c01d0a, 0x0688000a, 0x0c06b140, 0x06c0000a, 0x07803bc7,
+	0x0be54107, 0x068001ca, 0x06031e0a, 0x0680001b, 0x0649ce09,
+	0x0aa10009, 0x00000000, 0x0809ce00, 0x08007401, 0x06431e09,
+	0x0bee4049, 0x00000000, 0x0649cf07, 0x0a2200c7, 0x07801d87,
+	0x0aa18007, 0x07801ec7, 0x0aa10087, 0x06800207, 0x0c7ed540,
+	0x07c03bc7, 0x06800013, 0x07c02cd3, 0x07c02d13, 0x07c02e93,
+	0x07c01893, 0x07c018d3, 0x06803fc7, 0x07c02b07, 0x06800007,
+	0x07c02547, 0x07c025c7, 0x07c02607, 0x07802c07, 0x040011c7,
+	0x07c024c7, 0x06800047, 0x060e0c07, 0x07c026c7, 0x07c02507,
+	0x068003c7, 0x07c02807, 0x06805c07, 0x060c2107, 0x080c2170,
+	0x06800087, 0x07c02a47, 0x06800018, 0x07801ec7, 0x0a61c087,
+	0x06800007, 0x07800b48, 0x0aa1c008, 0x06800088, 0x0c780140,
+	0x07c00b48, 0x07800b47, 0x07801e48, 0x02c07207, 0x07c01e47,
+	0x068003c7, 0x07c02fc7, 0x06800407, 0x060c2407, 0x06800007,
+	0x07807048, 0x06804009, 0x05403287, 0x0200a289, 0x0400128a,
+	0x0700028b, 0x060c220b, 0x0400128a, 0x0700028b, 0x0400128a,
+	0x0700028c, 0x096102cc, 0x060c220b, 0x0400128a, 0x0700028b,
+	0x0400128a, 0x0700028c, 0x096102cc, 0x060c220b, 0x040011c7,
+	0x0b8ee207, 0x00000000, 0x07801d07, 0x0aa08007, 0x0c7ec3c0,
+	0x06800007, 0x07c01947, 0x06a00007, 0x060c3d07, 0x07802dc7,
+	0x0a618007, 0x00000000, 0x0c079240, 0x00000000, 0x0aa08007,
+	0x0c7ec100, 0x07802047, 0x07c02e07, 0x07802007, 0x07c02e47,
+	0x07801ec7, 0x07c02087, 0x07801f47, 0x07c07347, 0x07801f07,
+	0x07c02407, 0x07801f87, 0x07c01fc7, 0x0780248a, 0x0a6fc00a,
+	0x00000000, 0x0c0730c0, 0x00000000, 0x07802dc7, 0x0aa10007,
+	0x00000000, 0x0c0728c0, 0x00000000, 0x0c073480, 0x00000000,
+	0x07802087, 0x06840009, 0x0682629a, 0x0aa1c087, 0x06800008,
+	0x0682305a, 0x0aa10147, 0x06800048, 0x06800088, 0x06840009,
+	0x07c02788, 0x07c02689, 0x06800007, 0x07c02a87, 0x07802c8a,
+	0x07802107, 0x0a630007, 0x07802409, 0x0aa280c9, 0x0540128a,
+	0x0580128a, 0x06490707, 0x09807087, 0x098070c7, 0x06090707,
+	0x06495107, 0x098073c7, 0x06095107, 0x07c023ca, 0x07802947,
+	0x094421c9, 0x07c02947, 0x0a648387, 0x068000c9, 0x06495107,
+	0x094041c9, 0x06800009, 0x097821c9, 0x06095107, 0x06490707,
+	0x09807447, 0x06090707, 0x06498e07, 0x09807787, 0x09c070c7,
+	0x06098e07, 0x07802087, 0x0aa0c087, 0x0682519a, 0x068214da,
+	0x07803bc8, 0x090821c8, 0x0aa18087, 0x06800087, 0x09482207,
+	0x0690000a, 0x0c068040, 0x06c0000a, 0x0c784c40, 0x07c03bc8,
+	0x07802dc7, 0x0aa18007, 0x00000000, 0x0c077b80, 0x00000000,
+	0x0aa08007, 0x0c7eaa40, 0x06800007, 0x07803bc8, 0x09082208,
+	0x0aa10008, 0x0684000a, 0x0c067c40, 0x06c0000a, 0x07c03bc7,
+	0x07802d87, 0x0aa34007, 0x07802c47, 0x0b22c2c7, 0x07802cc7,
+	0x0a614007, 0x06495108, 0x09c08608, 0x0c7800c0, 0x07c02d87,
+	0x09808608, 0x06095108, 0x08095017, 0x08095000, 0x0c784480,
+	0x00000000, 0x0540928c, 0x0200a24a, 0x06c046ca, 0x0200ad0a,
+	0x0400130c, 0x0481f30c, 0x07c02b4c, 0x0643500c, 0x0580f30c,
+	0x0bef804c, 0x00000000, 0x0643530c, 0x0900c30c, 0x0a6f800c,
+	0x00000000, 0x0603510a, 0x06803f0a, 0x0603520a, 0x0c792b40,
+	0x0603500b, 0x0cc00000, 0x00000000, 0x07802cc9, 0x07c02ac9,
+	0x07802889, 0x07c03049, 0x07802809, 0x0aa08009, 0x0cc00000,
+	0x064e0e09, 0x09809309, 0x098092c9, 0x0cc00000, 0x060e0e09,
+	0x06435007, 0x0580f1c7, 0x0bef8047, 0x0aa14712, 0x06800007,
+	0x07802d07, 0x050011c7, 0x048011c7, 0x0b60c709, 0x06808008,
+	0x0680c008, 0x0c78ec80, 0x00000000, 0x0c7806c0, 0x07802807,
+	0x0aaf8387, 0x00000000, 0x07802947, 0x0aaec387, 0x064e0407,
+	0x091c2207, 0x0a24c0c8, 0x080c3e07, 0x064c3f07, 0x064c3f09,
+	0x09004249, 0x0581b1c7, 0x0a234047, 0x090241c7, 0x0a210088,
+	0x0aa20289, 0x0aa1c309, 0x0be18087, 0x0a21c048, 0x0aa102c9,
+	0x0aa0c309, 0x0be08047, 0x0c7800c0, 0x06800049, 0x07c01e49,
+	0x0cc00000, 0x00000000, 0x07800dc8, 0x0aa0c048, 0x0c780780,
+	0x00000000, 0x06800008, 0x07c00dc8, 0x07800d89, 0x07801f08,
+	0x09610248, 0x0609d509, 0x0aa18048, 0x0aa20088, 0x00000000,
+	0x0680774a, 0x0c780180, 0x00000000, 0x068077ca, 0x0c7800c0,
+	0x00000000, 0x0680784a, 0x07000288, 0x0400128a, 0x07000289,
+	0x09610209, 0x0609d608, 0x0649d308, 0x098083c8, 0x0609d308,
+	0x08007401, 0x0649d308, 0x0a6fc008, 0x00000000, 0x0cc00000,
+	0x00000000, 0x0680000c, 0x0680002a, 0x064c2907, 0x0a20c407,
+	0x0c7e8780, 0x00000000, 0x0fc081c0, 0x0aaeffc7, 0x0200c1cc,
+	0x064c2907, 0x0a20c407, 0x0c7e85c0, 0x00000000, 0x0fc081c0,
+	0x0aaeffc7, 0x0202a1ea, 0x0aa5400c, 0x0aa1418c, 0x0462d1cc,
+	0x0c500880, 0x0a61004c, 0x0c780e80, 0x06800047, 0x07c01c47,
+	0x064c0007, 0x0be14207, 0x064c2907, 0x0be0c407, 0x0d07ff2a,
+	0x0fc081c0, 0x064c0007, 0x0be10207, 0x064c2907, 0x0be08407,
+	0x0c7ff780, 0x0c7e7fc0, 0x00000000, 0x0c067b80, 0x080c2301,
+	0x064c232b, 0x05810aeb, 0x048ffaeb, 0x068f000a, 0x06c0470a,
+	0x0540a1c7, 0x0200a1ca, 0x06804009, 0x0c064cc0, 0x06b0400b,
+	0x07804007, 0x06905348, 0x0a80f207, 0x0c7e7b80, 0x0c067780,
+	0x080c2301, 0x064c232b, 0x05810aeb, 0x048ffaeb, 0x0fc011c0,
+	0x0aa14047, 0x04001aeb, 0x0fc071c0, 0x04007aeb, 0x07c017c7,
+	0x0c780140, 0x00000000, 0x0680004a, 0x0c005e00, 0x00000000,
+	0x048071eb, 0x0580322b, 0x0aa14007, 0x06800209, 0x04001208,
+	0x024071c9, 0x0f8001c7, 0x0262a22a, 0x0c57f440, 0x0c7ff280,
+	0x0680002b, 0x07803d0d, 0x0a22830d, 0x07802f87, 0x09005207,
+	0x04001208, 0x0c00ce00, 0x0202b22b, 0x090a5207, 0x04001208,
+	0x0c00cd00, 0x0202b22b, 0x0a21440d, 0x00000000, 0x0fc041c0,
+	0x07c02fc7, 0x04004aeb, 0x0c7ff940, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -500,15 +500,15 @@ static const u32 MicroCode[] __initconst = {
 	0x04c001c7, 0x09807207, 0x060c2107, 0x07802547, 0x0aa14007,
 	0x06a01008, 0x0aa0c047, 0x06a22008, 0x06a40008, 0x06431e09,
 	0x0befc049, 0x06c00108, 0x07802949, 0x0a670389, 0x0a26c053,
-	0x0c075140, 0x00000000, 0x0780288a, 0x0aa1c00a, 0x07802a8a,
+	0x0c075040, 0x00000000, 0x0780288a, 0x0aa1c00a, 0x07802a8a,
 	0x00800000, 0x078026c9, 0x04001249, 0x07c026c9, 0x00400000,
 	0x0b61408a, 0x00000000, 0x080c2170, 0x0c780700, 0x080c260e,
 	0x0683ffca, 0x0440128a, 0x0aa0c00a, 0x07802489, 0x0a6f4009,
 	0x078026c9, 0x04401249, 0x0c008080, 0x07c026c9, 0x0c780440,
 	0x08030580, 0x060e0508, 0x07802a88, 0x06801809, 0x09502248,
 	0x060c2109, 0x080c260e, 0x07c02587, 0x0ba0c087, 0x040011c7,
-	0x06800007, 0x0c074740, 0x07c02547, 0x06800088, 0x07c02488,
-	0x08030580, 0x0c074c80, 0x00000000, 0x07802747, 0x0aa14712,
+	0x06800007, 0x0c074640, 0x07c02547, 0x06800088, 0x07c02488,
+	0x08030580, 0x0c074b80, 0x00000000, 0x07802747, 0x0aa14712,
 	0x040011c7, 0x07802d08, 0x0a20c048, 0x00000000, 0x07c02747,
 	0x0c07ae80, 0x07802b0d, 0x0b608008, 0x0c7fed00, 0x0ba13fcd,
 	0x06800008, 0x0c781780, 0x07c02b08, 0x06808008, 0x0ba1070d,
@@ -529,12 +529,12 @@ static const u32 MicroCode[] __initconst = {
 	0x07802c47, 0x07802ccb, 0x024072c7, 0x0b20c0c7, 0x00000000,
 	0x068000c7, 0x095c2307, 0x07c02b4c, 0x07802b4c, 0x091c22cc,
 	0x0aa2800b, 0x044012cb, 0x095c230b, 0x0a61c00b, 0x07c02b4c,
-	0x0a20c04c, 0x06b0800b, 0x06b0c00b, 0x0c0725c0, 0x06b00009,
+	0x0a20c04c, 0x06b0800b, 0x06b0c00b, 0x0c0724c0, 0x06b00009,
 	0x0680001b, 0x07802947, 0x0aa5c387, 0x07802cc7, 0x040011c7,
 	0x07c02cc7, 0x07802e88, 0x04001208, 0x07c02e88, 0x07802c48,
 	0x0b828207, 0x06800007, 0x07c02cc7, 0x07802d08, 0x04001208,
 	0x078023c9, 0x0b822248, 0x07c02d08, 0x07802487, 0x0a6fc007,
-	0x00000000, 0x06430507, 0x0a2f0107, 0x0c7dc300, 0x064c0007,
+	0x00000000, 0x06430507, 0x0a2f0107, 0x0c7dc280, 0x064c0007,
 	0x07802d08, 0x0be10048, 0x040011c8, 0x0c780580, 0x07c02d07,
 	0x044011c8, 0x07c02d07, 0x07802cc7, 0x040011c7, 0x07c02cc7,
 	0x07802e88, 0x04001208, 0x07c02e88, 0x07802c48, 0x0b80b207,
@@ -543,14 +543,14 @@ static const u32 MicroCode[] __initconst = {
 	0x064c3b07, 0x0920c1c7, 0x0b218a07, 0x0680004a, 0x07c01e4a,
 	0x07c01d8a, 0x0680204a, 0x07c0194a, 0x07802cc7, 0x095084c7,
 	0x07802d09, 0x094084c9, 0x07801909, 0x0aa14009, 0x04401249,
-	0x0a60c009, 0x07c01909, 0x0c7ef500, 0x07802c49, 0x0b014489,
+	0x0a60c009, 0x07c01909, 0x0c7ef400, 0x07802c49, 0x0b014489,
 	0x06808008, 0x0a628712, 0x0c780840, 0x00000000, 0x07802d0a,
 	0x0a20c04a, 0x0500128a, 0x040011c7, 0x054011c7, 0x0c780840,
 	0x094011ca, 0x040011c7, 0x0a410247, 0x07802b09, 0x07802d07,
-	0x0a25c047, 0x040021c9, 0x0c7f1a00, 0x06800007, 0x0aa5c712,
+	0x0a25c047, 0x040021c9, 0x0c7f1900, 0x06800007, 0x0aa5c712,
 	0x07802d0a, 0x0a2bc04a, 0x04001287, 0x0a4ed24a, 0x0c780480,
-	0x06800007, 0x0c7f15c0, 0x00000000, 0x0a628047, 0x040021c9,
-	0x07802d07, 0x0be1c047, 0x040021c9, 0x0c7f1600, 0x06800047,
+	0x06800007, 0x0c7f14c0, 0x00000000, 0x0a628047, 0x040021c9,
+	0x07802d07, 0x0be1c047, 0x040021c9, 0x0c7f1500, 0x06800047,
 	0x0aadc007, 0x07802b09, 0x040011c9, 0x0ba10707, 0x0b6cce07,
 	0x0680c008, 0x0441c1c7, 0x05403247, 0x020091c9, 0x02008248,
 	0x07000209, 0x07c02449, 0x04001208, 0x07000209, 0x04001208,
@@ -625,142 +625,142 @@ static const u32 MicroCode[] __initconst = {
 	0x064c0909, 0x0ac0924a, 0x0b80324a, 0x0c7801c0, 0x09808688,
 	0x0400128a, 0x098083c8, 0x0a40324a, 0x0440128a, 0x098086c8,
 	0x0aa1000a, 0x09308287, 0x0a60c00a, 0x0400128a, 0x09808388,
-	0x0b80324a, 0x00000000, 0x098081c8, 0x0c780500, 0x060e0408,
-	0x0a614248, 0x00000000, 0x0c009240, 0x00000000, 0x0c780380,
-	0x0a62c288, 0x06431f20, 0x06433f21, 0x0e000860, 0x00000000,
-	0x00000000, 0x0f000800, 0x06031f20, 0x0f010840, 0x0c780100,
-	0x06033f21, 0x0c780080, 0x00000000, 0x08031e00, 0x0cc00000,
-	0x00400000, 0x0680400f, 0x0680a00e, 0x0680ec0d, 0x0680f60c,
-	0x0780704b, 0x0680000a, 0x06800009, 0x06800008, 0x0780776f,
-	0x07807780, 0x09610bc0, 0x0780736e, 0x078020c0, 0x06800041,
-	0x0342d001, 0x07807300, 0x06800081, 0x0b831040, 0x05403c4a,
-	0x02031c4f, 0x04001c71, 0x07000c44, 0x06800c00, 0x0bc25004,
-	0x09042004, 0x068000c1, 0x0a422040, 0x09101004, 0x04001c31,
-	0x02030030, 0x02030030, 0x07000c2c, 0x04001c30, 0x07000c00,
-	0x09610b00, 0x04005c71, 0x07000c6b, 0x0b003bab, 0x00000000,
-	0x0242bb6b, 0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a,
-	0x068000c0, 0x04001c30, 0x07400c00, 0x04001c30, 0x07400c2b,
-	0x0581002b, 0x04001c30, 0x07400c00, 0x0ac05bec, 0x0203024d,
-	0x07400c2a, 0x04001249, 0x0c780100, 0x0203020c, 0x07400c2a,
-	0x04001208, 0x0400128a, 0x0b8d52ca, 0x02000209, 0x07c070c9,
-	0x0cc00000, 0x07c07100, 0x0aa14040, 0x06800047, 0x06800006,
-	0x0c780100, 0x00000000, 0x06800007, 0x06800046, 0x05403c4a,
-	0x02031c4f, 0x04001c71, 0x07000c44, 0x09101004, 0x04001c31,
-	0x02030030, 0x02030030, 0x07000c2c, 0x04001c30, 0x07000c00,
-	0x09610b00, 0x04005c71, 0x07000c6b, 0x0b003bab, 0x00000000,
-	0x0242bb6b, 0x0be60404, 0x0a25c104, 0x0202a209, 0x05402c2a,
-	0x02030c0e, 0x07400c0a, 0x06800040, 0x04001c30, 0x07400c00,
-	0x0540102b, 0x020001c0, 0x04001c30, 0x07400c00, 0x05810000,
+	0x0b80324a, 0x00000000, 0x098081c8, 0x0c780240, 0x060e0408,
+	0x0a614248, 0x00000000, 0x0c008f80, 0x00000000, 0x0c7800c0,
+	0x0c780080, 0x00000000, 0x08031e00, 0x0cc00000, 0x00400000,
+	0x0680400f, 0x0680a00e, 0x0680ec0d, 0x0680f60c, 0x0780704b,
+	0x0680000a, 0x06800009, 0x06800008, 0x0780776f, 0x07807780,
+	0x09610bc0, 0x0780736e, 0x078020c0, 0x06800041, 0x0342d001,
+	0x07807300, 0x06800081, 0x0b831040, 0x05403c4a, 0x02031c4f,
+	0x04001c71, 0x07000c44, 0x06800c00, 0x0bc25004, 0x09042004,
+	0x068000c1, 0x0a422040, 0x09101004, 0x04001c31, 0x02030030,
+	0x02030030, 0x07000c2c, 0x04001c30, 0x07000c00, 0x09610b00,
+	0x04005c71, 0x07000c6b, 0x0b003bab, 0x00000000, 0x0242bb6b,
+	0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a, 0x068000c0,
+	0x04001c30, 0x07400c00, 0x04001c30, 0x07400c2b, 0x0581002b,
 	0x04001c30, 0x07400c00, 0x0ac05bec, 0x0203024d, 0x07400c2a,
 	0x04001249, 0x0c780100, 0x0203020c, 0x07400c2a, 0x04001208,
-	0x0be60804, 0x0a25c204, 0x0202a209, 0x05402c2a, 0x02030c0e,
-	0x07400c0a, 0x06800080, 0x04001c30, 0x07400c00, 0x0540102b,
-	0x02000180, 0x04001c30, 0x07400c00, 0x05810000, 0x04001c30,
+	0x0400128a, 0x0b8d52ca, 0x02000209, 0x07c070c9, 0x0cc00000,
+	0x07c07100, 0x0aa14040, 0x06800047, 0x06800006, 0x0c780100,
+	0x00000000, 0x06800007, 0x06800046, 0x05403c4a, 0x02031c4f,
+	0x04001c71, 0x07000c44, 0x09101004, 0x04001c31, 0x02030030,
+	0x02030030, 0x07000c2c, 0x04001c30, 0x07000c00, 0x09610b00,
+	0x04005c71, 0x07000c6b, 0x0b003bab, 0x00000000, 0x0242bb6b,
+	0x0be60404, 0x0a25c104, 0x0202a209, 0x05402c2a, 0x02030c0e,
+	0x07400c0a, 0x06800040, 0x04001c30, 0x07400c00, 0x0540102b,
+	0x020001c0, 0x04001c30, 0x07400c00, 0x05810000, 0x04001c30,
 	0x07400c00, 0x0ac05bec, 0x0203024d, 0x07400c2a, 0x04001249,
-	0x0c780100, 0x0203020c, 0x07400c2a, 0x04001208, 0x0400128a,
-	0x0b8be2ca, 0x02000209, 0x07c070c9, 0x0cc00000, 0x07c07100,
-	0x0680400f, 0x0680a00e, 0x0680ec0d, 0x0780704b, 0x0680000a,
-	0x07807109, 0x07807300, 0x0ba6c080, 0x05403c4a, 0x02031c4f,
-	0x04001c71, 0x07000c44, 0x09082004, 0x0a6440c0, 0x04006c71,
-	0x07000c6b, 0x05402c09, 0x02030c0e, 0x07400c0a, 0x068001c0,
-	0x04001c30, 0x07400c00, 0x04001c30, 0x07400c2b, 0x0581002b,
+	0x0c780100, 0x0203020c, 0x07400c2a, 0x04001208, 0x0be60804,
+	0x0a25c204, 0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a,
+	0x06800080, 0x04001c30, 0x07400c00, 0x0540102b, 0x02000180,
+	0x04001c30, 0x07400c00, 0x05810000, 0x04001c30, 0x07400c00,
+	0x0ac05bec, 0x0203024d, 0x07400c2a, 0x04001249, 0x0c780100,
+	0x0203020c, 0x07400c2a, 0x04001208, 0x0400128a, 0x0b8be2ca,
+	0x02000209, 0x07c070c9, 0x0cc00000, 0x07c07100, 0x0680400f,
+	0x0680a00e, 0x0680ec0d, 0x0780704b, 0x0680000a, 0x07807109,
+	0x07807300, 0x0ba6c080, 0x05403c4a, 0x02031c4f, 0x04001c71,
+	0x07000c44, 0x09082004, 0x0a6440c0, 0x04006c71, 0x07000c6b,
+	0x05402c09, 0x02030c0e, 0x07400c0a, 0x068001c0, 0x04001c30,
+	0x07400c00, 0x04001c30, 0x07400c2b, 0x0581002b, 0x04001c30,
+	0x07400c00, 0x0203024d, 0x07400c09, 0x04001249, 0x0400128a,
+	0x0b8e92ca, 0x0cc00000, 0x07c07149, 0x0aa14040, 0x06800047,
+	0x06800006, 0x0c780100, 0x00000000, 0x06800007, 0x06800046,
+	0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44, 0x04006c71,
+	0x07000c6b, 0x0a244404, 0x05402c09, 0x02030c0e, 0x07400c0a,
+	0x06800140, 0x04001c30, 0x07400c00, 0x0540102b, 0x020001c0,
+	0x04001c30, 0x07400c00, 0x05810000, 0x04001c30, 0x07400c00,
+	0x0203024d, 0x07400c09, 0x04001249, 0x0a244804, 0x05402c09,
+	0x02030c0e, 0x07400c0a, 0x06800180, 0x04001c30, 0x07400c00,
+	0x0540102b, 0x02000180, 0x04001c30, 0x07400c00, 0x05810000,
 	0x04001c30, 0x07400c00, 0x0203024d, 0x07400c09, 0x04001249,
-	0x0400128a, 0x0b8e92ca, 0x0cc00000, 0x07c07149, 0x0aa14040,
-	0x06800047, 0x06800006, 0x0c780100, 0x00000000, 0x06800007,
-	0x06800046, 0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44,
-	0x04006c71, 0x07000c6b, 0x0a244404, 0x05402c09, 0x02030c0e,
-	0x07400c0a, 0x06800140, 0x04001c30, 0x07400c00, 0x0540102b,
-	0x020001c0, 0x04001c30, 0x07400c00, 0x05810000, 0x04001c30,
-	0x07400c00, 0x0203024d, 0x07400c09, 0x04001249, 0x0a244804,
-	0x05402c09, 0x02030c0e, 0x07400c0a, 0x06800180, 0x04001c30,
-	0x07400c00, 0x0540102b, 0x02000180, 0x04001c30, 0x07400c00,
-	0x05810000, 0x04001c30, 0x07400c00, 0x0203024d, 0x07400c09,
-	0x04001249, 0x0400128a, 0x0b8d72ca, 0x0cc00000, 0x07c07149,
-	0x0680ec0f, 0x0680f60e, 0x0780710a, 0x078070c9, 0x06800008,
-	0x0240a24a, 0x0200e28e, 0x0a60c009, 0x0cc00000, 0x00000000,
-	0x070003c0, 0x07400380, 0x040013cf, 0x0400138e, 0x04001208,
-	0x0b8fb248, 0x0cc00000, 0x00000000, 0x0680ec0f, 0x0680f60e,
-	0x0780710a, 0x078070c9, 0x06800008, 0x0240a24a, 0x0200f24f,
-	0x0a60c00a, 0x0cc00000, 0x00000000, 0x07000380, 0x074003c0,
-	0x040013cf, 0x0400138e, 0x04001208, 0x0b8fb288, 0x0cc00000,
-	0x00000000, 0x0680ec0f, 0x0680f60e, 0x0780710a, 0x07807149,
-	0x0200f28f, 0x0200e28e, 0x0a40324a, 0x0cc00000, 0x00000000,
-	0x070003c0, 0x07400380, 0x040013cf, 0x0400138e, 0x0400128a,
-	0x0b8fb24a, 0x0cc00000, 0x00000000, 0x0b60808e, 0x0c780e00,
-	0x0680a00c, 0x0680400b, 0x0680000a, 0x0a83438a, 0x0400124a,
-	0x0202f28f, 0x07000bee, 0x0540222e, 0x0200820c, 0x04002208,
-	0x0700022d, 0x04001208, 0x07000200, 0x09610b40, 0x0a814389,
-	0x0202c24f, 0x07000b2b, 0x0540222b, 0x0200820c, 0x04002208,
-	0x0700022a, 0x04001208, 0x07000200, 0x09610a80, 0x0a60c00d,
-	0x0b807aad, 0x0c7800c0, 0x0ac05aad, 0x00000000, 0x07400b2e,
-	0x04000bab, 0x04000b6a, 0x04001249, 0x0c7ffb40, 0x07807300,
-	0x0b644080, 0x0a24004a, 0x0540222e, 0x0200820c, 0x04002208,
-	0x07000207, 0x0a22c047, 0x04401b6f, 0x07000b6c, 0x0540222c,
-	0x0200820c, 0x04002208, 0x07000207, 0x0be10047, 0x00000000,
-	0x07400b6e, 0x04000bac, 0x07400bee, 0x0400128a, 0x0c7ff340,
-	0x0cc00000, 0x00000000, 0x0b60808e, 0x0c781680, 0x0680a00c,
-	0x0680400b, 0x0680000a, 0x0a85638a, 0x0400124a, 0x0202f28f,
-	0x07000bee, 0x0540222e, 0x0200820c, 0x07000207, 0x04001208,
-	0x07000206, 0x054031c7, 0x020071cb, 0x09002146, 0x0a6280c5,
-	0x00000000, 0x040011c7, 0x070001c4, 0x09101c44, 0x040011c7,
-	0x02007c47, 0x02007c47, 0x0c780100, 0x00000000, 0x02007147,
-	0x02007147, 0x070001ed, 0x040011c7, 0x070001c0, 0x09610b40,
-	0x0a825389, 0x0202c24f, 0x07000b2b, 0x0540222b, 0x0200820c,
-	0x07000207, 0x04001208, 0x07000206, 0x054031c7, 0x020071cb,
-	0x09002146, 0x0a6280c5, 0x00000000, 0x040011c7, 0x070001c4,
-	0x09101c44, 0x040011c7, 0x02007c47, 0x02007c47, 0x0c780100,
-	0x00000000, 0x02007147, 0x02007147, 0x070001ea, 0x040011c7,
-	0x070001c0, 0x09610a80, 0x0a60c00d, 0x0b807aad, 0x0c7800c0,
-	0x0ac05aad, 0x00000000, 0x07400b2e, 0x04000bab, 0x04000b6a,
-	0x04001249, 0x0c7ff700, 0x07807300, 0x0b644080, 0x0a24004a,
-	0x0540222e, 0x0200820c, 0x04002208, 0x07000207, 0x0a22c047,
-	0x04401b6f, 0x07000b6c, 0x0540222c, 0x0200820c, 0x04002208,
-	0x07000207, 0x0be10047, 0x00000000, 0x07400b6e, 0x04000bac,
-	0x07400bee, 0x0400128a, 0x0c7feac0, 0x0cc00000, 0x00000000,
-	0x0400120a, 0x0200720f, 0x070001c9, 0x05402189, 0x0200618c,
-	0x04002186, 0x07000185, 0x09001005, 0x0a4092c0, 0x04401c47,
-	0x07000c40, 0x074001c0, 0x04401208, 0x0acfc288, 0x040001f1,
-	0x0cc00000, 0x074001c9, 0x04001208, 0x0b8ef388, 0x0cc00000,
-	0x00000000, 0x0780710e, 0x0440134e, 0x0680a00c, 0x0680000a,
-	0x0b60808e, 0x0c7804c0, 0x0200928f, 0x07000248, 0x054021c8,
-	0x020071cc, 0x040021c7, 0x070001c6, 0x0be1804a, 0x0be24046,
-	0x00000000, 0x0c07f700, 0x0680004b, 0x0c780140, 0x0a210046,
-	0x00000000, 0x0c07f5c0, 0x0680000b, 0x0400128a, 0x0b8ef34a,
-	0x0cc00000, 0x00000000, 0x06800008, 0x0700040a, 0x0200720f,
-	0x070001c9, 0x05402189, 0x020061af, 0x04001186, 0x07000185,
-	0x09041005, 0x0a418a80, 0x04001186, 0x07000185, 0x04001186,
-	0x07000180, 0x09610140, 0x0a412305, 0x0a80e348, 0x0ac07348,
-	0x00000000, 0x0200734f, 0x0a80a34a, 0x0400128a, 0x0440120a,
-	0x0200720f, 0x04401c47, 0x07000c40, 0x074001c0, 0x04401208,
-	0x0acfc348, 0x040001f1, 0x074001c9, 0x0cc00000, 0x0740040a,
-	0x04001208, 0x0b8e0288, 0x0cc00000, 0x00000000, 0x0680a02f,
-	0x078020c0, 0x06800041, 0x0342e001, 0x0780736d, 0x07807300,
-	0x0b614080, 0x00000000, 0x05401bae, 0x05401b6d, 0x04001b6d,
-	0x0242cbad, 0x04000aed, 0x0680000d, 0x0680002a, 0x07000380,
-	0x0400138e, 0x0aa10000, 0x0aa30040, 0x0aa50080, 0x0c780680,
-	0x07000380, 0x0400138e, 0x04001000, 0x0242b02b, 0x0b411b2b,
-	0x0400032b, 0x0202bbab, 0x0c780380, 0x0400032b, 0x07000380,
-	0x0400138e, 0x04001000, 0x0202b02b, 0x0b808b6b, 0x0400032b,
-	0x0242bbab, 0x0c780140, 0x0400032b, 0x0680006a, 0x0700038c,
-	0x0400138e, 0x0c07ec40, 0x00000000, 0x0c7ff880, 0x0400134d,
-	0x0cc00000, 0x00000000, 0x0c077280, 0x00000000, 0x0c079600,
-	0x00000000, 0x07802080, 0x0aa64180, 0x00000000, 0x0c07ae80,
-	0x00000000, 0x07807140, 0x07c07240, 0x0680ec0f, 0x0780710e,
-	0x0680004d, 0x0c07b580, 0x00000000, 0x0680ec0f, 0x0780714e,
-	0x07807100, 0x0200f00f, 0x0240e00e, 0x0680000d, 0x0c07b380,
-	0x00000000, 0x0680ec0f, 0x0680c00e, 0x0c07ed80, 0x06807250,
-	0x0cc00000, 0x00000000, 0x0680ec0f, 0x078070ce, 0x0680004d,
-	0x0c07bf80, 0x00000000, 0x0680f60f, 0x0780710e, 0x078070c0,
-	0x0240e00e, 0x0680000d, 0x0c07bdc0, 0x00000000, 0x0680ec0f,
-	0x0780714e, 0x07807100, 0x0200f00f, 0x0240e00e, 0x0680000d,
-	0x0c07ad00, 0x00000000, 0x0c07a3c0, 0x00000000, 0x0c079ec0,
-	0x00000000, 0x0c07a740, 0x00000000, 0x07807140, 0x07c07240,
-	0x07c07280, 0x07807300, 0x0b618080, 0x00000000, 0x0c07d4c0,
-	0x0680ec0f, 0x0c07d440, 0x0680f60f, 0x078070c0, 0x07807101,
-	0x07807170, 0x0ba280b0, 0x0aa0c000, 0x0a802040, 0x0c7801c0,
-	0x0680f60f, 0x0400138f, 0x070003c0, 0x07000381, 0x07400380,
-	0x074003c1, 0x0680ec0f, 0x0680c00e, 0x0c07dfc0, 0x06807250,
-	0x0680f60f, 0x0680d08e, 0x0c07dec0, 0x06807290, 0x0cc00000,
+	0x0400128a, 0x0b8d72ca, 0x0cc00000, 0x07c07149, 0x0680ec0f,
+	0x0680f60e, 0x0780710a, 0x078070c9, 0x06800008, 0x0240a24a,
+	0x0200e28e, 0x0a60c009, 0x0cc00000, 0x00000000, 0x070003c0,
+	0x07400380, 0x040013cf, 0x0400138e, 0x04001208, 0x0b8fb248,
+	0x0cc00000, 0x00000000, 0x0680ec0f, 0x0680f60e, 0x0780710a,
+	0x078070c9, 0x06800008, 0x0240a24a, 0x0200f24f, 0x0a60c00a,
+	0x0cc00000, 0x00000000, 0x07000380, 0x074003c0, 0x040013cf,
+	0x0400138e, 0x04001208, 0x0b8fb288, 0x0cc00000, 0x00000000,
+	0x0680ec0f, 0x0680f60e, 0x0780710a, 0x07807149, 0x0200f28f,
+	0x0200e28e, 0x0a40324a, 0x0cc00000, 0x00000000, 0x070003c0,
+	0x07400380, 0x040013cf, 0x0400138e, 0x0400128a, 0x0b8fb24a,
+	0x0cc00000, 0x00000000, 0x0b60808e, 0x0c780e00, 0x0680a00c,
+	0x0680400b, 0x0680000a, 0x0a83438a, 0x0400124a, 0x0202f28f,
+	0x07000bee, 0x0540222e, 0x0200820c, 0x04002208, 0x0700022d,
+	0x04001208, 0x07000200, 0x09610b40, 0x0a814389, 0x0202c24f,
+	0x07000b2b, 0x0540222b, 0x0200820c, 0x04002208, 0x0700022a,
+	0x04001208, 0x07000200, 0x09610a80, 0x0a60c00d, 0x0b807aad,
+	0x0c7800c0, 0x0ac05aad, 0x00000000, 0x07400b2e, 0x04000bab,
+	0x04000b6a, 0x04001249, 0x0c7ffb40, 0x07807300, 0x0b644080,
+	0x0a24004a, 0x0540222e, 0x0200820c, 0x04002208, 0x07000207,
+	0x0a22c047, 0x04401b6f, 0x07000b6c, 0x0540222c, 0x0200820c,
+	0x04002208, 0x07000207, 0x0be10047, 0x00000000, 0x07400b6e,
+	0x04000bac, 0x07400bee, 0x0400128a, 0x0c7ff340, 0x0cc00000,
+	0x00000000, 0x0b60808e, 0x0c781680, 0x0680a00c, 0x0680400b,
+	0x0680000a, 0x0a85638a, 0x0400124a, 0x0202f28f, 0x07000bee,
+	0x0540222e, 0x0200820c, 0x07000207, 0x04001208, 0x07000206,
+	0x054031c7, 0x020071cb, 0x09002146, 0x0a6280c5, 0x00000000,
+	0x040011c7, 0x070001c4, 0x09101c44, 0x040011c7, 0x02007c47,
+	0x02007c47, 0x0c780100, 0x00000000, 0x02007147, 0x02007147,
+	0x070001ed, 0x040011c7, 0x070001c0, 0x09610b40, 0x0a825389,
+	0x0202c24f, 0x07000b2b, 0x0540222b, 0x0200820c, 0x07000207,
+	0x04001208, 0x07000206, 0x054031c7, 0x020071cb, 0x09002146,
+	0x0a6280c5, 0x00000000, 0x040011c7, 0x070001c4, 0x09101c44,
+	0x040011c7, 0x02007c47, 0x02007c47, 0x0c780100, 0x00000000,
+	0x02007147, 0x02007147, 0x070001ea, 0x040011c7, 0x070001c0,
+	0x09610a80, 0x0a60c00d, 0x0b807aad, 0x0c7800c0, 0x0ac05aad,
+	0x00000000, 0x07400b2e, 0x04000bab, 0x04000b6a, 0x04001249,
+	0x0c7ff700, 0x07807300, 0x0b644080, 0x0a24004a, 0x0540222e,
+	0x0200820c, 0x04002208, 0x07000207, 0x0a22c047, 0x04401b6f,
+	0x07000b6c, 0x0540222c, 0x0200820c, 0x04002208, 0x07000207,
+	0x0be10047, 0x00000000, 0x07400b6e, 0x04000bac, 0x07400bee,
+	0x0400128a, 0x0c7feac0, 0x0cc00000, 0x00000000, 0x0400120a,
+	0x0200720f, 0x070001c9, 0x05402189, 0x0200618c, 0x04002186,
+	0x07000185, 0x09001005, 0x0a4092c0, 0x04401c47, 0x07000c40,
+	0x074001c0, 0x04401208, 0x0acfc288, 0x040001f1, 0x0cc00000,
+	0x074001c9, 0x04001208, 0x0b8ef388, 0x0cc00000, 0x00000000,
+	0x0780710e, 0x0440134e, 0x0680a00c, 0x0680000a, 0x0b60808e,
+	0x0c7804c0, 0x0200928f, 0x07000248, 0x054021c8, 0x020071cc,
+	0x040021c7, 0x070001c6, 0x0be1804a, 0x0be24046, 0x00000000,
+	0x0c07f700, 0x0680004b, 0x0c780140, 0x0a210046, 0x00000000,
+	0x0c07f5c0, 0x0680000b, 0x0400128a, 0x0b8ef34a, 0x0cc00000,
+	0x00000000, 0x06800008, 0x0700040a, 0x0200720f, 0x070001c9,
+	0x05402189, 0x020061af, 0x04001186, 0x07000185, 0x09041005,
+	0x0a418a80, 0x04001186, 0x07000185, 0x04001186, 0x07000180,
+	0x09610140, 0x0a412305, 0x0a80e348, 0x0ac07348, 0x00000000,
+	0x0200734f, 0x0a80a34a, 0x0400128a, 0x0440120a, 0x0200720f,
+	0x04401c47, 0x07000c40, 0x074001c0, 0x04401208, 0x0acfc348,
+	0x040001f1, 0x074001c9, 0x0cc00000, 0x0740040a, 0x04001208,
+	0x0b8e0288, 0x0cc00000, 0x00000000, 0x0680a02f, 0x078020c0,
+	0x06800041, 0x0342e001, 0x0780736d, 0x07807300, 0x0b614080,
+	0x00000000, 0x05401bae, 0x05401b6d, 0x04001b6d, 0x0242cbad,
+	0x04000aed, 0x0680000d, 0x0680002a, 0x07000380, 0x0400138e,
+	0x0aa10000, 0x0aa30040, 0x0aa50080, 0x0c780680, 0x07000380,
+	0x0400138e, 0x04001000, 0x0242b02b, 0x0b411b2b, 0x0400032b,
+	0x0202bbab, 0x0c780380, 0x0400032b, 0x07000380, 0x0400138e,
+	0x04001000, 0x0202b02b, 0x0b808b6b, 0x0400032b, 0x0242bbab,
+	0x0c780140, 0x0400032b, 0x0680006a, 0x0700038c, 0x0400138e,
+	0x0c07ec40, 0x00000000, 0x0c7ff880, 0x0400134d, 0x0cc00000,
+	0x00000000, 0x0c077280, 0x00000000, 0x0c079600, 0x00000000,
+	0x07802080, 0x0aa64180, 0x00000000, 0x0c07ae80, 0x00000000,
+	0x07807140, 0x07c07240, 0x0680ec0f, 0x0780710e, 0x0680004d,
+	0x0c07b580, 0x00000000, 0x0680ec0f, 0x0780714e, 0x07807100,
+	0x0200f00f, 0x0240e00e, 0x0680000d, 0x0c07b380, 0x00000000,
+	0x0680ec0f, 0x0680c00e, 0x0c07ed80, 0x06807250, 0x0cc00000,
+	0x00000000, 0x0680ec0f, 0x078070ce, 0x0680004d, 0x0c07bf80,
+	0x00000000, 0x0680f60f, 0x0780710e, 0x078070c0, 0x0240e00e,
+	0x0680000d, 0x0c07bdc0, 0x00000000, 0x0680ec0f, 0x0780714e,
+	0x07807100, 0x0200f00f, 0x0240e00e, 0x0680000d, 0x0c07ad00,
+	0x00000000, 0x0c07a3c0, 0x00000000, 0x0c079ec0, 0x00000000,
+	0x0c07a740, 0x00000000, 0x07807140, 0x07c07240, 0x07c07280,
+	0x07807300, 0x0b618080, 0x00000000, 0x0c07d4c0, 0x0680ec0f,
+	0x0c07d440, 0x0680f60f, 0x078070c0, 0x07807101, 0x07807170,
+	0x0ba280b0, 0x0aa0c000, 0x0a802040, 0x0c7801c0, 0x0680f60f,
+	0x0400138f, 0x070003c0, 0x07000381, 0x07400380, 0x074003c1,
+	0x0680ec0f, 0x0680c00e, 0x0c07dfc0, 0x06807250, 0x0680f60f,
+	0x0680d08e, 0x0c07dec0, 0x06807290, 0x0cc00000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264data_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264data_linux.h
index 8512490..7f45685 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264data_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264data_linux.h
@@ -90,15 +90,15 @@ static const u32 MicroCode[] __initconst = {
 	0x080c260f, 0x080c2603, 0x04c001c7, 0x09807207, 0x060c2107,
 	0x07802547, 0x0aa14007, 0x06a01008, 0x0aa0c047, 0x06a22008,
 	0x06a40008, 0x06431e09, 0x0befc049, 0x06c00108, 0x07802949,
-	0x0a670389, 0x0a26c053, 0x0c075140, 0x00000000, 0x0780288a,
+	0x0a670389, 0x0a26c053, 0x0c075040, 0x00000000, 0x0780288a,
 	0x0aa1c00a, 0x07802a8a, 0x00800000, 0x078026c9, 0x04001249,
 	0x07c026c9, 0x00400000, 0x0b61408a, 0x00000000, 0x080c2170,
 	0x0c780700, 0x080c260e, 0x0683ffca, 0x0440128a, 0x0aa0c00a,
 	0x07802489, 0x0a6f4009, 0x078026c9, 0x04401249, 0x0c008080,
 	0x07c026c9, 0x0c780440, 0x08030580, 0x060e0508, 0x07802a88,
 	0x06801809, 0x09502248, 0x060c2109, 0x080c260e, 0x07c02587,
-	0x0ba0c087, 0x040011c7, 0x06800007, 0x0c074740, 0x07c02547,
-	0x06800088, 0x07c02488, 0x08030580, 0x0c074c80, 0x00000000,
+	0x0ba0c087, 0x040011c7, 0x06800007, 0x0c074640, 0x07c02547,
+	0x06800088, 0x07c02488, 0x08030580, 0x0c074b80, 0x00000000,
 	0x07802747, 0x0aa14712, 0x040011c7, 0x07802d08, 0x0a20c048,
 	0x00000000, 0x07c02747, 0x0c07ae80, 0x07802b0d, 0x0b608008,
 	0x0c7fed00, 0x0ba13fcd, 0x06800008, 0x0c781780, 0x07c02b08,
@@ -120,12 +120,12 @@ static const u32 MicroCode[] __initconst = {
 	0x0b20c0c7, 0x00000000, 0x068000c7, 0x095c2307, 0x07c02b4c,
 	0x07802b4c, 0x091c22cc, 0x0aa2800b, 0x044012cb, 0x095c230b,
 	0x0a61c00b, 0x07c02b4c, 0x0a20c04c, 0x06b0800b, 0x06b0c00b,
-	0x0c0725c0, 0x06b00009, 0x0680001b, 0x07802947, 0x0aa5c387,
+	0x0c0724c0, 0x06b00009, 0x0680001b, 0x07802947, 0x0aa5c387,
 	0x07802cc7, 0x040011c7, 0x07c02cc7, 0x07802e88, 0x04001208,
 	0x07c02e88, 0x07802c48, 0x0b828207, 0x06800007, 0x07c02cc7,
 	0x07802d08, 0x04001208, 0x078023c9, 0x0b822248, 0x07c02d08,
 	0x07802487, 0x0a6fc007, 0x00000000, 0x06430507, 0x0a2f0107,
-	0x0c7dc300, 0x064c0007, 0x07802d08, 0x0be10048, 0x040011c8,
+	0x0c7dc280, 0x064c0007, 0x07802d08, 0x0be10048, 0x040011c8,
 	0x0c780580, 0x07c02d07, 0x044011c8, 0x07c02d07, 0x07802cc7,
 	0x040011c7, 0x07c02cc7, 0x07802e88, 0x04001208, 0x07c02e88,
 	0x07802c48, 0x0b80b207, 0x06800007, 0x07c02cc7, 0x07802d08,
@@ -133,15 +133,15 @@ static const u32 MicroCode[] __initconst = {
 	0x0c7ff880, 0x07c02e87, 0x064c3b07, 0x0920c1c7, 0x0b218a07,
 	0x0680004a, 0x07c01e4a, 0x07c01d8a, 0x0680204a, 0x07c0194a,
 	0x07802cc7, 0x095084c7, 0x07802d09, 0x094084c9, 0x07801909,
-	0x0aa14009, 0x04401249, 0x0a60c009, 0x07c01909, 0x0c7ef500,
+	0x0aa14009, 0x04401249, 0x0a60c009, 0x07c01909, 0x0c7ef400,
 	0x07802c49, 0x0b014489, 0x06808008, 0x0a628712, 0x0c780840,
 	0x00000000, 0x07802d0a, 0x0a20c04a, 0x0500128a, 0x040011c7,
 	0x054011c7, 0x0c780840, 0x094011ca, 0x040011c7, 0x0a410247,
-	0x07802b09, 0x07802d07, 0x0a25c047, 0x040021c9, 0x0c7f1a00,
+	0x07802b09, 0x07802d07, 0x0a25c047, 0x040021c9, 0x0c7f1900,
 	0x06800007, 0x0aa5c712, 0x07802d0a, 0x0a2bc04a, 0x04001287,
-	0x0a4ed24a, 0x0c780480, 0x06800007, 0x0c7f15c0, 0x00000000,
+	0x0a4ed24a, 0x0c780480, 0x06800007, 0x0c7f14c0, 0x00000000,
 	0x0a628047, 0x040021c9, 0x07802d07, 0x0be1c047, 0x040021c9,
-	0x0c7f1600, 0x06800047, 0x0aadc007, 0x07802b09, 0x040011c9,
+	0x0c7f1500, 0x06800047, 0x0aadc007, 0x07802b09, 0x040011c9,
 	0x0ba10707, 0x0b6cce07, 0x0680c008, 0x0441c1c7, 0x05403247,
 	0x020091c9, 0x02008248, 0x07000209, 0x07c02449, 0x04001208,
 	0x07000209, 0x04001208, 0x0700021d, 0x09610749, 0x04001208,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264header_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264header_linux.h
index 33051d5..a96f2fe 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264header_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264header_linux.h
@@ -1,196 +1,196 @@
 static const u32 MicroCode[] __initconst = {
 	0x06804011, 0x06905347, 0x07400447, 0x04002451, 0x0fc101c0,
-	0x09108247, 0x0a60e509, 0x0c7e5ec0, 0x00000000, 0x07400447,
-	0x04001451, 0x0fc08280, 0x07c00d0a, 0x0c065980, 0x080c2301,
-	0x0b2087c7, 0x0c7e5c80, 0x04000407, 0x09505287, 0x0740044a,
-	0x04001451, 0x0ba59909, 0x0c065740, 0x080c2301, 0x05001387,
-	0x07803ccd, 0x09502347, 0x07c03ccd, 0x0c0655c0, 0x080c2301,
-	0x0c065540, 0x080c2301, 0x0fc011c0, 0x0fc01340, 0x0942134e,
+	0x09108247, 0x0a60e509, 0x0c7e5e40, 0x00000000, 0x07400447,
+	0x04001451, 0x0fc08280, 0x07c00d0a, 0x0c065900, 0x080c2301,
+	0x0b2087c7, 0x0c7e5c00, 0x04000407, 0x09505287, 0x0740044a,
+	0x04001451, 0x0ba59909, 0x0c0656c0, 0x080c2301, 0x05001387,
+	0x07803ccd, 0x09502347, 0x07c03ccd, 0x0c065540, 0x080c2301,
+	0x0c0654c0, 0x080c2301, 0x0fc011c0, 0x0fc01340, 0x0942134e,
 	0x0740044d, 0x04001451, 0x0aa1800d, 0x0680000e, 0x068001c7,
-	0x07c01d47, 0x0c009bc0, 0x06800009, 0x0c065200, 0x080c2301,
-	0x04004247, 0x07400449, 0x04001451, 0x0c0650c0, 0x080c2301,
+	0x07c01d47, 0x0c0099c0, 0x06800009, 0x0c065180, 0x080c2301,
+	0x04004247, 0x07400449, 0x04001451, 0x0c065040, 0x080c2301,
 	0x07400447, 0x04001451, 0x06800088, 0x0a835207, 0x06800008,
 	0x0a82e207, 0x00000000, 0x0fc011c0, 0x07400447, 0x04001451,
-	0x0c064dc0, 0x080c2301, 0x0c064f40, 0x00000000, 0x07400447,
-	0x04001451, 0x058101c7, 0x07400447, 0x04001451, 0x0c064b80,
-	0x080c2301, 0x0c064d00, 0x00000000, 0x07400447, 0x04001451,
-	0x058101c7, 0x07400447, 0x04001451, 0x0c064940, 0x080c2301,
-	0x0aa68007, 0x0aa12007, 0x05807207, 0x0aa08008, 0x0c7e4b80,
-	0x07400447, 0x04001451, 0x04000287, 0x06808009, 0x0c064680,
-	0x080c2301, 0x0c064800, 0x00000000, 0x07400247, 0x04001249,
+	0x0c064d40, 0x080c2301, 0x0c064ec0, 0x00000000, 0x07400447,
+	0x04001451, 0x058101c7, 0x07400447, 0x04001451, 0x0c064b00,
+	0x080c2301, 0x0c064c80, 0x00000000, 0x07400447, 0x04001451,
+	0x058101c7, 0x07400447, 0x04001451, 0x0c0648c0, 0x080c2301,
+	0x0aa68007, 0x0aa12007, 0x05807207, 0x0aa08008, 0x0c7e4b00,
+	0x07400447, 0x04001451, 0x04000287, 0x06808009, 0x0c064600,
+	0x080c2301, 0x0c064780, 0x00000000, 0x07400247, 0x04001249,
 	0x058101c7, 0x07400247, 0x0d07fe0a, 0x04001249, 0x0c7801c0,
-	0x00000000, 0x0c064380, 0x080c2301, 0x040041c7, 0x07400447,
-	0x04001451, 0x0c064240, 0x080c2301, 0x04000247, 0x0fc011c0,
-	0x09501247, 0x07400449, 0x04001451, 0x0c064080, 0x080c2301,
-	0x04000347, 0x0c063fc0, 0x080c2301, 0x04000387, 0x0c780700,
-	0x00000000, 0x06031f0d, 0x06033f0e, 0x0c05e7c0, 0x08031e15,
-	0x06431f07, 0x06a40008, 0x0b014207, 0x06804009, 0x0b00b24d,
-	0x00000000, 0x0649cf09, 0x0a208089, 0x0c7e3f40, 0x00000000,
-	0x0809c007, 0x0609c10d, 0x08007401, 0x0c780000, 0x00800000,
-	0x0400034e, 0x0b21a40d, 0x0649cf09, 0x0a208089, 0x0c7e3c80,
-	0x0c7ffdc0, 0x0809c008, 0x0400124d, 0x07400449, 0x04001451,
-	0x0400124e, 0x07400449, 0x04001451, 0x0fc011c0, 0x0a610007,
-	0x00000000, 0x0fc01200, 0x094211c8, 0x0fc01200, 0x094411c8,
-	0x07400447, 0x04001451, 0x0fc011c0, 0x0aa20007, 0x06800108,
-	0x0c063380, 0x080c2301, 0x07400447, 0x0d07ff48, 0x04001451,
-	0x0c780140, 0x06800007, 0x07400447, 0x0d07ffc8, 0x04001451,
-	0x06804048, 0x07400211, 0x0fc01200, 0x0a60c008, 0x0c7817c0,
-	0x07400448, 0x0fc011c0, 0x09421207, 0x07400448, 0x0aa30007,
-	0x04001451, 0x0fc081c0, 0x07400447, 0x0a623fc7, 0x04001451,
-	0x0fc101c0, 0x07400447, 0x04001451, 0x0fc101c0, 0x07400447,
-	0x04001451, 0x0fc011c0, 0x0aa0c007, 0x00000000, 0x0fc011c0,
-	0x0fc011c0, 0x0aa38007, 0x00000000, 0x0680000e, 0x0fc051c0,
-	0x09405387, 0x0540838e, 0x0980e34e, 0x0a21c047, 0x00000000,
-	0x0fc101c0, 0x07c00987, 0x0fc081c0, 0x09408387, 0x07c009ce,
-	0x0fc011c0, 0x0aa14007, 0x0c062680, 0x080c2301, 0x0c062600,
-	0x080c2301, 0x0fc011c0, 0x07400447, 0x04001451, 0x0aa40007,
-	0x07c00687, 0x0fc101c0, 0x07400447, 0x04001451, 0x0fc101c0,
+	0x00000000, 0x0c064300, 0x080c2301, 0x040041c7, 0x07400447,
+	0x04001451, 0x0c0641c0, 0x080c2301, 0x04000247, 0x0fc011c0,
+	0x09501247, 0x07400449, 0x04001451, 0x0c064000, 0x080c2301,
+	0x04000347, 0x0c063f40, 0x080c2301, 0x04000387, 0x0c780540,
+	0x00000000, 0x06804009, 0x0b00b24d, 0x00000000, 0x0649cf09,
+	0x0a208089, 0x0c7e4080, 0x00000000, 0x0809c007, 0x0609c10d,
+	0x08007401, 0x0c780000, 0x00800000, 0x0400034e, 0x0b21a40d,
+	0x0649cf09, 0x0a208089, 0x0c7e3dc0, 0x0c7ffdc0, 0x0809c008,
+	0x0400124d, 0x07400449, 0x04001451, 0x0400124e, 0x07400449,
+	0x04001451, 0x0fc011c0, 0x0a610007, 0x00000000, 0x0fc01200,
+	0x094211c8, 0x0fc01200, 0x094411c8, 0x07400447, 0x04001451,
+	0x0fc011c0, 0x0aa20007, 0x06800108, 0x0c0634c0, 0x080c2301,
+	0x07400447, 0x0d07ff48, 0x04001451, 0x0c780140, 0x06800007,
+	0x07400447, 0x0d07ffc8, 0x04001451, 0x06804048, 0x07400211,
+	0x0fc01200, 0x0a60c008, 0x0c7817c0, 0x07400448, 0x0fc011c0,
+	0x09421207, 0x07400448, 0x0aa30007, 0x04001451, 0x0fc081c0,
+	0x07400447, 0x0a623fc7, 0x04001451, 0x0fc101c0, 0x07400447,
+	0x04001451, 0x0fc101c0, 0x07400447, 0x04001451, 0x0fc011c0,
+	0x0aa0c007, 0x00000000, 0x0fc011c0, 0x0fc011c0, 0x0aa38007,
+	0x00000000, 0x0680000e, 0x0fc051c0, 0x09405387, 0x0540838e,
+	0x0980e34e, 0x0a21c047, 0x00000000, 0x0fc101c0, 0x07c00987,
+	0x0fc081c0, 0x09408387, 0x07c009ce, 0x0fc011c0, 0x0aa14007,
+	0x0c0627c0, 0x080c2301, 0x0c062740, 0x080c2301, 0x0fc011c0,
+	0x07400447, 0x04001451, 0x0aa40007, 0x07c00687, 0x0fc101c0,
 	0x07400447, 0x04001451, 0x0fc101c0, 0x07400447, 0x04001451,
-	0x0fc101c0, 0x07400447, 0x04001451, 0x0fc011c0, 0x07c00687,
-	0x0680000e, 0x0fc011c0, 0x0aa18007, 0x09401387, 0x0c008140,
-	0x00000000, 0x090aa207, 0x07c02f88, 0x0fc011c0, 0x0aa1c007,
-	0x09421387, 0x0c007f80, 0x00000000, 0x0be0c04e, 0x090aa207,
-	0x07c02f88, 0x0a20c0ce, 0x00000000, 0x0fc011c0, 0x0fc011c0,
-	0x09441387, 0x0fc011c0, 0x09461387, 0x0740044e, 0x04001451,
-	0x0aa24007, 0x06800188, 0x0fc011c0, 0x0c0619c0, 0x080c2301,
-	0x0d07ff88, 0x00000000, 0x07400447, 0x04001451, 0x07803b47,
-	0x0a404407, 0x07803bc7, 0x09807007, 0x07c03bc7, 0x068f000a,
-	0x06c0470a, 0x0540a1d0, 0x0200a1ca, 0x06806009, 0x0c05e900,
-	0x06a0400b, 0x0c7e1900, 0x00000000, 0x0aa1000a, 0x06804047,
-	0x0c782180, 0x070001d1, 0x06804091, 0x07000447, 0x04001451,
-	0x07c039c7, 0x09108247, 0x07000448, 0x04001451, 0x090081c8,
-	0x07c03a07, 0x064c2908, 0x09c080c8, 0x060c2908, 0x0b60d909,
-	0x0c780680, 0x080e0000, 0x0700044d, 0x04001451, 0x064c2908,
-	0x090211cd, 0x09461207, 0x060c2908, 0x0aa3000d, 0x0680000e,
-	0x06800009, 0x06c00049, 0x060e0209, 0x068001c7, 0x07c01d47,
-	0x0c006300, 0x06800009, 0x06800009, 0x06c00049, 0x060e0209,
-	0x064e0007, 0x096e91cd, 0x060e0007, 0x064e0307, 0x095081ce,
-	0x060e0307, 0x07000449, 0x04001451, 0x07c020c9, 0x07000447,
-	0x04001451, 0x07c02147, 0x06800088, 0x0a819207, 0x06800008,
-	0x0a814207, 0x07000447, 0x04001451, 0x07c03a87, 0x07000447,
-	0x04001451, 0x07c03807, 0x07000447, 0x04001451, 0x07c03847,
-	0x07000447, 0x04001451, 0x07c03887, 0x07000447, 0x04001451,
-	0x07c038c7, 0x07000447, 0x04001451, 0x07c03987, 0x0c780100,
-	0x07000447, 0x04001451, 0x07c02187, 0x07000449, 0x04001451,
-	0x090081c9, 0x07c03907, 0x091011c9, 0x07c03947, 0x07000447,
-	0x04001451, 0x060c0907, 0x07c02c47, 0x04401247, 0x07c02c09,
-	0x07000449, 0x04001451, 0x07c02c89, 0x0700044d, 0x04001451,
-	0x090011cd, 0x0a60c007, 0x07c02107, 0x05401249, 0x04000289,
-	0x07802c48, 0x09610288, 0x0609520a, 0x05404289, 0x0968c288,
-	0x0609080a, 0x06031f08, 0x06033f09, 0x0c05a440, 0x08031e15,
-	0x06431f08, 0x0a610007, 0x07c03a48, 0x0902120d, 0x094211c8,
-	0x07c02947, 0x090411cd, 0x0aa10007, 0x054011c7, 0x07802108,
-	0x094411c8, 0x07c02307, 0x06800087, 0x07802108, 0x02408207,
-	0x07000447, 0x04001451, 0x07000449, 0x04001451, 0x09508247,
-	0x05401249, 0x07c01a89, 0x07000447, 0x04001451, 0x07000449,
-	0x04001451, 0x09508247, 0x03409209, 0x07c01ac9, 0x07000447,
-	0x04001451, 0x0be0c047, 0x0c780900, 0x05801347, 0x05801347,
-	0x0a22c04d, 0x07000447, 0x04001451, 0x07c03d47, 0x0a61ffc7,
-	0x07000447, 0x04001451, 0x07c03d87, 0x07000447, 0x04001451,
-	0x07c03dc7, 0x07000447, 0x04001451, 0x0a238047, 0x09421347,
-	0x07000447, 0x04001451, 0x07c03e47, 0x07000447, 0x04001451,
-	0x07c03e07, 0x07000447, 0x04001451, 0x07c03ec7, 0x07000447,
-	0x04001451, 0x07c03e87, 0x07000447, 0x04001451, 0x09444347,
-	0x0a20c207, 0x07000447, 0x07c01b87, 0x0cc00000, 0x07c03d0d,
-	0x0680c011, 0x06905347, 0x07400447, 0x04001451, 0x0c05e780,
-	0x080c2301, 0x0b20bfc7, 0x0c7dea80, 0x04000407, 0x04000247,
-	0x0c05e600, 0x080c2301, 0x09505247, 0x0fc011c0, 0x095a1247,
-	0x0fc011c0, 0x095c1247, 0x07400449, 0x04001451, 0x0c05e3c0,
-	0x080c2301, 0x0aa0c007, 0x0c7de6c0, 0x00000000, 0x0c05e280,
-	0x080c2301, 0x04000207, 0x0c05e1c0, 0x080c2301, 0x094a5207,
-	0x0fc011c0, 0x09541207, 0x0fc021c0, 0x09562207, 0x07400448,
-	0x04001451, 0x0c05df80, 0x080c2301, 0x04000247, 0x0c05dec0,
-	0x080c2301, 0x09508247, 0x07400449, 0x04001451, 0x0c05dd80,
-	0x080c2301, 0x04000247, 0x0fc011c0, 0x09501247, 0x0fc011c0,
-	0x09521247, 0x0fc011c0, 0x09541247, 0x07400449, 0x064c2907,
-	0x091c21c7, 0x0a60c0c7, 0x0c780580, 0x04001451, 0x098092c9,
-	0x07400449, 0x04001451, 0x0fc011c0, 0x06800149, 0x05401347,
-	0x02009349, 0x07c01d49, 0x0fc01340, 0x094211cd, 0x07400447,
-	0x04001451, 0x0aa1000d, 0x0680000e, 0x0c001f80, 0x06800009,
-	0x0c05d5c0, 0x080c2301, 0x07400447, 0x04001451, 0x07803b87,
-	0x0a404407, 0x07803bc7, 0x09807047, 0x07c03bc7, 0x06af000a,
-	0x06c0470a, 0x054091d0, 0x0200a1ca, 0x06804009, 0x06a0c00b,
-	0x0c05a540, 0x00000000, 0x0c7dd540, 0x00000000, 0x0680c051,
-	0x07000449, 0x04001451, 0x091a11c9, 0x07c02347, 0x0aa0c007,
-	0x06800007, 0x0687ffc7, 0x07c02a07, 0x091c11c9, 0x07c021c7,
-	0x06800808, 0x07000449, 0x04001451, 0x090051c9, 0x07c03ac7,
-	0x09505207, 0x090a51c9, 0x07c03b07, 0x09605207, 0x07802947,
-	0x096a2207, 0x060c2108, 0x091411c9, 0x07c028c7, 0x091621c9,
-	0x07c02907, 0x07000449, 0x04001451, 0x090081c9, 0x0c05cb80,
-	0x00000000, 0x07c02247, 0x091081c9, 0x0c05ca80, 0x00000000,
-	0x07000449, 0x04001451, 0x090081c9, 0x0c05c940, 0x00000000,
-	0x06801008, 0x09505207, 0x060c2108, 0x06801408, 0x09505207,
-	0x060c2108, 0x091011c9, 0x07c02287, 0x091211c9, 0x064e0e08,
-	0x09401207, 0x060e0e08, 0x091411c9, 0x07c02207, 0x0580b1c9,
-	0x0be18047, 0x06800007, 0x07802308, 0x09c08008, 0x0cc00000,
-	0x07c02308, 0x07000449, 0x04001451, 0x090011c9, 0x0680014d,
-	0x05401387, 0x0200d38d, 0x07c01d4d, 0x07802308, 0x09401207,
-	0x07c02308, 0x09021349, 0x0aa2800d, 0x0680000e, 0x06801c09,
-	0x06c00049, 0x060e0209, 0x0c0013c0, 0x06800009, 0x06800009,
-	0x06c00049, 0x060e0209, 0x064e0007, 0x095c91cd, 0x060e0007,
-	0x064e0307, 0x094081ce, 0x060e0307, 0x07000447, 0x04001451,
-	0x0c05bc40, 0x00000000, 0x06801408, 0x09505207, 0x0cc00000,
-	0x060c2108, 0x0ba0c189, 0x0680020c, 0x0680080c, 0x07801d47,
-	0x0b8041c9, 0x04001249, 0x0cc00000, 0x00000000, 0x0540134d,
-	0x0540138e, 0x0fc01200, 0x07400448, 0x04001451, 0x09401348,
-	0x0aac8008, 0x0680020a, 0x0680020b, 0x0ba0c189, 0x068003cc,
-	0x06800fcc, 0x0aa4400b, 0x00000000, 0x0c05b340, 0x080c2301,
-	0x07400447, 0x04001451, 0x0c05b440, 0x00000000, 0x02007287,
-	0x048ff2c7, 0x0a61800b, 0x0aa0cfcc, 0x0b614189, 0x0a6103cc,
-	0x0c7ff780, 0x0980e00e, 0x0400028b, 0x054083cf, 0x0be0c04c,
-	0x094083ca, 0x06c0000f, 0x0aeac00c, 0x0440130c, 0x07801d47,
-	0x0b8031c9, 0x0cc00000, 0x00000000, 0x0c7ff640, 0x04001249,
-	0x0ba0c189, 0x0680020c, 0x0680080c, 0x064e020a, 0x0200a30a,
-	0x06c0004a, 0x060e020a, 0x0ba101c9, 0x04001249, 0x0cc00000,
-	0x00000000, 0x0540134d, 0x0540138e, 0x07801d48, 0x0ac04209,
-	0x06800008, 0x07000448, 0x04001451, 0x09401348, 0x0aab4008,
-	0x0680020a, 0x0680020b, 0x0ba0c189, 0x068003cc, 0x06800fcc,
-	0x0aa3400b, 0x07000447, 0x0c05a7c0, 0x04001451, 0x02007287,
-	0x048ff2c7, 0x0a61800b, 0x0aa0cfcc, 0x0b614189, 0x0a6103cc,
-	0x0c7ff740, 0x0980e00e, 0x0400028b, 0x054083cf, 0x0be1004c,
-	0x094083ca, 0x06c0000f, 0x060e020f, 0x0aeb800c, 0x0440130c,
-	0x0ba0c1c9, 0x0cc00000, 0x00000000, 0x0c7ff6c0, 0x04001249,
-	0x0b210408, 0x00000000, 0x0fc10240, 0x04410208, 0x0cc00000,
-	0x0f800208, 0x0c059e80, 0x080c2301, 0x04001347, 0x0fc081c0,
-	0x0c059d80, 0x080c2301, 0x0c059d00, 0x080c2301, 0x0d07ff0d,
-	0x0fc011c0, 0x0fc051c0, 0x0cc00000, 0x0fc0f1c0, 0x07803c47,
-	0x07803c88, 0x0780174b, 0x07800a4d, 0x07800a8e, 0x07802c49,
-	0x07803a4a, 0x0780390c, 0x07803e8f, 0x07803ed0, 0x07803e11,
-	0x0a409247, 0x0a408288, 0x0a40730b, 0x0a4063cd, 0x0a40540e,
-	0x00000000, 0x07800a07, 0x0a402447, 0x0c7825c0, 0x06800007,
-	0x07c07087, 0x07803bc7, 0x09807087, 0x07c03bc7, 0x069fffc7,
-	0x07c03c49, 0x07c03c8a, 0x07c0174c, 0x07c00a4f, 0x07c00a90,
-	0x07c00a11, 0x0a83f207, 0x0688000a, 0x0c056c80, 0x06c0000a,
-	0x068c000a, 0x06c0470a, 0x06804009, 0x0c0564c0, 0x06b0400b,
-	0x0680044a, 0x06031e0a, 0x0649ce09, 0x0aa10009, 0x00000000,
-	0x0809ce00, 0x08007401, 0x06431e0a, 0x0bee804a, 0x00000000,
-	0x07803a47, 0x0a634047, 0x07807187, 0x06804089, 0x054031c7,
-	0x020091c9, 0x07000247, 0x091011c7, 0x020091c9, 0x0740024a,
-	0x04001249, 0x06801fca, 0x0740024a, 0x07c0178a, 0x07807047,
-	0x07c07187, 0x068003ca, 0x06031e0a, 0x0649ce09, 0x0aa10009,
-	0x00000000, 0x0809ce00, 0x08007401, 0x06431e09, 0x0bee8049,
-	0x00000000, 0x0649ce09, 0x0a6dc009, 0x00000000, 0x0c062a80,
-	0x00000000, 0x0649c007, 0x0bef7fc7, 0x07803a47, 0x0a60c047,
-	0x0c780000, 0x00800000, 0x068000c7, 0x0609c007, 0x08007401,
-	0x0c0627c0, 0x0680001b, 0x0649c007, 0x0bef7fc7, 0x07802c47,
-	0x07803a48, 0x095101c8, 0x07803908, 0x097071c8, 0x07802308,
-	0x09021208, 0x097e11c8, 0x0609c107, 0x07803d07, 0x07802108,
-	0x095e11c8, 0x07800688, 0x094c11c8, 0x07803cc8, 0x09102208,
-	0x095a21c8, 0x07803d48, 0x096101c8, 0x0609c207, 0x07803d87,
-	0x07803dc8, 0x096101c8, 0x0609c307, 0x07803e07, 0x07803e48,
-	0x096101c8, 0x0609c407, 0x07803e87, 0x07803ec8, 0x096101c8,
-	0x0609c507, 0x07801ac7, 0x07801a88, 0x096101c8, 0x0609c607,
-	0x07800d07, 0x0609ca07, 0x078009c7, 0x07800988, 0x09610207,
-	0x0609d108, 0x06800047, 0x0609c007, 0x08007401, 0x06800007,
-	0x06800008, 0x06804009, 0x04001249, 0x07400248, 0x040011c7,
-	0x0baf8607, 0x04008249, 0x0680001b, 0x0649c008, 0x0befbfc8,
-	0x091081c8, 0x07c03187, 0x092081c8, 0x07c07047, 0x093081c8,
-	0x07803cc8, 0x09408207, 0x07c03cc8, 0x06800007, 0x07c071c7,
-	0x07c07207, 0x0649c107, 0x07c078c7, 0x058101c7, 0x07c07907,
-	0x0649c407, 0x07c07947, 0x058101c7, 0x07c07987, 0x07803cc8,
-	0x09008208, 0x07802307, 0x090211c7, 0x054011c7, 0x034081c8,
-	0x07803907, 0x07803189, 0x0b004247, 0x00000000, 0x040001c9,
-	0x07c03907, 0x0b803207, 0x044011c8, 0x07c03907, 0x0cc00000,
+	0x0fc101c0, 0x07400447, 0x04001451, 0x0fc101c0, 0x07400447,
+	0x04001451, 0x0fc011c0, 0x07c00687, 0x0680000e, 0x0fc011c0,
+	0x0aa18007, 0x09401387, 0x0c008100, 0x00000000, 0x090aa207,
+	0x07c02f88, 0x0fc011c0, 0x0aa1c007, 0x09421387, 0x0c007f40,
+	0x00000000, 0x0be0c04e, 0x090aa207, 0x07c02f88, 0x0a20c0ce,
+	0x00000000, 0x0fc011c0, 0x0fc011c0, 0x09441387, 0x0fc011c0,
+	0x09461387, 0x0740044e, 0x04001451, 0x0aa24007, 0x06800188,
+	0x0fc011c0, 0x0c061b00, 0x080c2301, 0x0d07ff88, 0x00000000,
+	0x07400447, 0x04001451, 0x07803b47, 0x0a404407, 0x07803bc7,
+	0x09807007, 0x07c03bc7, 0x068f000a, 0x06c0470a, 0x0540a1d0,
+	0x0200a1ca, 0x06806009, 0x0c05eac0, 0x06a0400b, 0x0c7e1a40,
+	0x00000000, 0x0aa1000a, 0x06804047, 0x0c782140, 0x070001d1,
+	0x06804091, 0x07000447, 0x04001451, 0x07c039c7, 0x09108247,
+	0x07000448, 0x04001451, 0x090081c8, 0x07c03a07, 0x064c2908,
+	0x09c080c8, 0x060c2908, 0x0b60d909, 0x0c780680, 0x080e0000,
+	0x0700044d, 0x04001451, 0x064c2908, 0x090211cd, 0x09461207,
+	0x060c2908, 0x0aa3000d, 0x0680000e, 0x06800009, 0x06c00049,
+	0x060e0209, 0x068001c7, 0x07c01d47, 0x0c0062c0, 0x06800009,
+	0x06800009, 0x06c00049, 0x060e0209, 0x064e0007, 0x096e91cd,
+	0x060e0007, 0x064e0307, 0x095081ce, 0x060e0307, 0x07000449,
+	0x04001451, 0x07c020c9, 0x07000447, 0x04001451, 0x07c02147,
+	0x06800088, 0x0a819207, 0x06800008, 0x0a814207, 0x07000447,
+	0x04001451, 0x07c03a87, 0x07000447, 0x04001451, 0x07c03807,
+	0x07000447, 0x04001451, 0x07c03847, 0x07000447, 0x04001451,
+	0x07c03887, 0x07000447, 0x04001451, 0x07c038c7, 0x07000447,
+	0x04001451, 0x07c03987, 0x0c780100, 0x07000447, 0x04001451,
+	0x07c02187, 0x07000449, 0x04001451, 0x090081c9, 0x07c03907,
+	0x091011c9, 0x07c03947, 0x07000447, 0x04001451, 0x060c0907,
+	0x07c02c47, 0x04401247, 0x07c02c09, 0x07000449, 0x04001451,
+	0x07c02c89, 0x0700044d, 0x04001451, 0x090011cd, 0x0a60c007,
+	0x07c02107, 0x05401249, 0x04000289, 0x07802c48, 0x09610288,
+	0x0609520a, 0x05404289, 0x0968c288, 0x0609080a, 0x0e000248,
+	0x00000000, 0x00000000, 0x0f000200, 0x0a610007, 0x07c03a48,
+	0x0902120d, 0x094211c8, 0x07c02947, 0x090411cd, 0x0aa10007,
+	0x054011c7, 0x07802108, 0x094411c8, 0x07c02307, 0x06800087,
+	0x07802108, 0x02408207, 0x07000447, 0x04001451, 0x07000449,
+	0x04001451, 0x09508247, 0x05401249, 0x07c01a89, 0x07000447,
+	0x04001451, 0x07000449, 0x04001451, 0x09508247, 0x03409209,
+	0x07c01ac9, 0x07000447, 0x04001451, 0x0be0c047, 0x0c780900,
+	0x05801347, 0x05801347, 0x0a22c04d, 0x07000447, 0x04001451,
+	0x07c03d47, 0x0a61ffc7, 0x07000447, 0x04001451, 0x07c03d87,
+	0x07000447, 0x04001451, 0x07c03dc7, 0x07000447, 0x04001451,
+	0x0a238047, 0x09421347, 0x07000447, 0x04001451, 0x07c03e47,
+	0x07000447, 0x04001451, 0x07c03e07, 0x07000447, 0x04001451,
+	0x07c03ec7, 0x07000447, 0x04001451, 0x07c03e87, 0x07000447,
+	0x04001451, 0x09444347, 0x0a20c207, 0x07000447, 0x07c01b87,
+	0x0cc00000, 0x07c03d0d, 0x0680c011, 0x06905347, 0x07400447,
+	0x04001451, 0x0c05e900, 0x080c2301, 0x0b20bfc7, 0x0c7dec00,
+	0x04000407, 0x04000247, 0x0c05e780, 0x080c2301, 0x09505247,
+	0x0fc011c0, 0x095a1247, 0x0fc011c0, 0x095c1247, 0x07400449,
+	0x04001451, 0x0c05e540, 0x080c2301, 0x0aa0c007, 0x0c7de840,
+	0x00000000, 0x0c05e400, 0x080c2301, 0x04000207, 0x0c05e340,
+	0x080c2301, 0x094a5207, 0x0fc011c0, 0x09541207, 0x0fc021c0,
+	0x09562207, 0x07400448, 0x04001451, 0x0c05e100, 0x080c2301,
+	0x04000247, 0x0c05e040, 0x080c2301, 0x09508247, 0x07400449,
+	0x04001451, 0x0c05df00, 0x080c2301, 0x04000247, 0x0fc011c0,
+	0x09501247, 0x0fc011c0, 0x09521247, 0x0fc011c0, 0x09541247,
+	0x07400449, 0x064c2907, 0x091c21c7, 0x0a60c0c7, 0x0c780580,
+	0x04001451, 0x098092c9, 0x07400449, 0x04001451, 0x0fc011c0,
+	0x06800149, 0x05401347, 0x02009349, 0x07c01d49, 0x0fc01340,
+	0x094211cd, 0x07400447, 0x04001451, 0x0aa1000d, 0x0680000e,
+	0x0c001f80, 0x06800009, 0x0c05d740, 0x080c2301, 0x07400447,
+	0x04001451, 0x07803b87, 0x0a404407, 0x07803bc7, 0x09807047,
+	0x07c03bc7, 0x06af000a, 0x06c0470a, 0x054091d0, 0x0200a1ca,
+	0x06804009, 0x06a0c00b, 0x0c05a740, 0x00000000, 0x0c7dd6c0,
+	0x00000000, 0x0680c051, 0x07000449, 0x04001451, 0x091a11c9,
+	0x07c02347, 0x0aa0c007, 0x06800007, 0x0687ffc7, 0x07c02a07,
+	0x091c11c9, 0x07c021c7, 0x06800808, 0x07000449, 0x04001451,
+	0x090051c9, 0x07c03ac7, 0x09505207, 0x090a51c9, 0x07c03b07,
+	0x09605207, 0x07802947, 0x096a2207, 0x060c2108, 0x091411c9,
+	0x07c028c7, 0x091621c9, 0x07c02907, 0x07000449, 0x04001451,
+	0x090081c9, 0x0c05cd00, 0x00000000, 0x07c02247, 0x091081c9,
+	0x0c05cc00, 0x00000000, 0x07000449, 0x04001451, 0x090081c9,
+	0x0c05cac0, 0x00000000, 0x06801008, 0x09505207, 0x060c2108,
+	0x06801408, 0x09505207, 0x060c2108, 0x091011c9, 0x07c02287,
+	0x091211c9, 0x064e0e08, 0x09401207, 0x060e0e08, 0x091411c9,
+	0x07c02207, 0x0580b1c9, 0x0be18047, 0x06800007, 0x07802308,
+	0x09c08008, 0x0cc00000, 0x07c02308, 0x07000449, 0x04001451,
+	0x090011c9, 0x0680014d, 0x05401387, 0x0200d38d, 0x07c01d4d,
+	0x07802308, 0x09401207, 0x07c02308, 0x09021349, 0x0aa2800d,
+	0x0680000e, 0x06801c09, 0x06c00049, 0x060e0209, 0x0c0013c0,
+	0x06800009, 0x06800009, 0x06c00049, 0x060e0209, 0x064e0007,
+	0x095c91cd, 0x060e0007, 0x064e0307, 0x094081ce, 0x060e0307,
+	0x07000447, 0x04001451, 0x0c05bdc0, 0x00000000, 0x06801408,
+	0x09505207, 0x0cc00000, 0x060c2108, 0x0ba0c189, 0x0680020c,
+	0x0680080c, 0x07801d47, 0x0b8041c9, 0x04001249, 0x0cc00000,
+	0x00000000, 0x0540134d, 0x0540138e, 0x0fc01200, 0x07400448,
+	0x04001451, 0x09401348, 0x0aac8008, 0x0680020a, 0x0680020b,
+	0x0ba0c189, 0x068003cc, 0x06800fcc, 0x0aa4400b, 0x00000000,
+	0x0c05b4c0, 0x080c2301, 0x07400447, 0x04001451, 0x0c05b5c0,
+	0x00000000, 0x02007287, 0x048ff2c7, 0x0a61800b, 0x0aa0cfcc,
+	0x0b614189, 0x0a6103cc, 0x0c7ff780, 0x0980e00e, 0x0400028b,
+	0x054083cf, 0x0be0c04c, 0x094083ca, 0x06c0000f, 0x0aeac00c,
+	0x0440130c, 0x07801d47, 0x0b8031c9, 0x0cc00000, 0x00000000,
+	0x0c7ff640, 0x04001249, 0x0ba0c189, 0x0680020c, 0x0680080c,
+	0x064e020a, 0x0200a30a, 0x06c0004a, 0x060e020a, 0x0ba101c9,
+	0x04001249, 0x0cc00000, 0x00000000, 0x0540134d, 0x0540138e,
+	0x07801d48, 0x0ac04209, 0x06800008, 0x07000448, 0x04001451,
+	0x09401348, 0x0aab4008, 0x0680020a, 0x0680020b, 0x0ba0c189,
+	0x068003cc, 0x06800fcc, 0x0aa3400b, 0x07000447, 0x0c05a940,
+	0x04001451, 0x02007287, 0x048ff2c7, 0x0a61800b, 0x0aa0cfcc,
+	0x0b614189, 0x0a6103cc, 0x0c7ff740, 0x0980e00e, 0x0400028b,
+	0x054083cf, 0x0be1004c, 0x094083ca, 0x06c0000f, 0x060e020f,
+	0x0aeb800c, 0x0440130c, 0x0ba0c1c9, 0x0cc00000, 0x00000000,
+	0x0c7ff6c0, 0x04001249, 0x0b210408, 0x00000000, 0x0fc10240,
+	0x04410208, 0x0cc00000, 0x0f800208, 0x0c05a000, 0x080c2301,
+	0x04001347, 0x0fc081c0, 0x0c059f00, 0x080c2301, 0x0c059e80,
+	0x080c2301, 0x0d07ff0d, 0x0fc011c0, 0x0fc051c0, 0x0cc00000,
+	0x0fc0f1c0, 0x07803c47, 0x07803c88, 0x0780174b, 0x07800a4d,
+	0x07800a8e, 0x07802c49, 0x07803a4a, 0x0780390c, 0x07803e8f,
+	0x07803ed0, 0x07803e11, 0x0a409247, 0x0a408288, 0x0a40730b,
+	0x0a4063cd, 0x0a40540e, 0x00000000, 0x07800a07, 0x0a402447,
+	0x0c782640, 0x06800007, 0x07c07087, 0x07803bc7, 0x09807087,
+	0x07c03bc7, 0x069fffc7, 0x07c03c49, 0x07c03c8a, 0x07c0174c,
+	0x07c00a4f, 0x07c00a90, 0x07c00a11, 0x0a841207, 0x0688000a,
+	0x0c056e80, 0x06c0000a, 0x068c000a, 0x06c0470a, 0x06804009,
+	0x0c0566c0, 0x06b0400b, 0x0680044a, 0x06031e0a, 0x0649ce09,
+	0x0aa10009, 0x00000000, 0x0809ce00, 0x08007401, 0x06431e0a,
+	0x0bee804a, 0x00000000, 0x07802087, 0x0a63c087, 0x07803a47,
+	0x0a634047, 0x07807187, 0x06804089, 0x054031c7, 0x020091c9,
+	0x07000247, 0x091011c7, 0x020091c9, 0x0740024a, 0x04001249,
+	0x06801fca, 0x0740024a, 0x07c0178a, 0x07807047, 0x07c07187,
+	0x068003ca, 0x06031e0a, 0x0649ce09, 0x0aa10009, 0x00000000,
+	0x0809ce00, 0x08007401, 0x06431e09, 0x0bee8049, 0x00000000,
+	0x0649ce09, 0x0a6dc009, 0x00000000, 0x0c062b00, 0x00000000,
+	0x0649c007, 0x0bef7fc7, 0x07803a47, 0x0a60c047, 0x0c780000,
+	0x00800000, 0x068000c7, 0x0609c007, 0x08007401, 0x0c062840,
+	0x0680001b, 0x0649c007, 0x0bef7fc7, 0x07802c47, 0x07803a48,
+	0x095101c8, 0x07803908, 0x097071c8, 0x07802308, 0x09021208,
+	0x097e11c8, 0x0609c107, 0x07803d07, 0x07802108, 0x095e11c8,
+	0x07800688, 0x094c11c8, 0x07803cc8, 0x09102208, 0x095a21c8,
+	0x07803d48, 0x096101c8, 0x0609c207, 0x07803d87, 0x07803dc8,
+	0x096101c8, 0x0609c307, 0x07803e07, 0x07803e48, 0x096101c8,
+	0x0609c407, 0x07803e87, 0x07803ec8, 0x096101c8, 0x0609c507,
+	0x07801ac7, 0x07801a88, 0x096101c8, 0x0609c607, 0x07800d07,
+	0x0609ca07, 0x078009c7, 0x07800988, 0x09610207, 0x0609d108,
+	0x06800047, 0x0609c007, 0x08007401, 0x06800007, 0x06800008,
+	0x06804009, 0x04001249, 0x07400248, 0x040011c7, 0x0baf8607,
+	0x04008249, 0x0680001b, 0x0649c008, 0x0befbfc8, 0x091081c8,
+	0x07c03187, 0x092081c8, 0x07c07047, 0x093081c8, 0x07803cc8,
+	0x09408207, 0x07c03cc8, 0x06800007, 0x07c071c7, 0x07c07207,
+	0x0649c107, 0x07c078c7, 0x058101c7, 0x07c07907, 0x0649c407,
+	0x07c07947, 0x058101c7, 0x07c07987, 0x07803cc8, 0x09008208,
+	0x07802307, 0x090211c7, 0x054011c7, 0x034081c8, 0x07803907,
+	0x07803189, 0x0b004247, 0x00000000, 0x040001c9, 0x07c03907,
+	0x0b803207, 0x044011c8, 0x07c03907, 0x0cc00000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264list_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264list_linux.h
index 80d76d3..c85d9f8 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264list_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264list_linux.h
@@ -11,142 +11,142 @@ static const u32 MicroCode[] __initconst = {
 	0x0b80324a, 0x0c7801c0, 0x09808688, 0x0400128a, 0x098083c8,
 	0x0a40324a, 0x0440128a, 0x098086c8, 0x0aa1000a, 0x09308287,
 	0x0a60c00a, 0x0400128a, 0x09808388, 0x0b80324a, 0x00000000,
-	0x098081c8, 0x0c780500, 0x060e0408, 0x0a614248, 0x00000000,
-	0x0c009240, 0x00000000, 0x0c780380, 0x0a62c288, 0x06431f20,
-	0x06433f21, 0x0e000860, 0x00000000, 0x00000000, 0x0f000800,
-	0x06031f20, 0x0f010840, 0x0c780100, 0x06033f21, 0x0c780080,
-	0x00000000, 0x08031e00, 0x0cc00000, 0x00400000, 0x0680400f,
-	0x0680a00e, 0x0680ec0d, 0x0680f60c, 0x0780704b, 0x0680000a,
-	0x06800009, 0x06800008, 0x0780776f, 0x07807780, 0x09610bc0,
-	0x0780736e, 0x078020c0, 0x06800041, 0x0342d001, 0x07807300,
-	0x06800081, 0x0b831040, 0x05403c4a, 0x02031c4f, 0x04001c71,
-	0x07000c44, 0x06800c00, 0x0bc25004, 0x09042004, 0x068000c1,
-	0x0a422040, 0x09101004, 0x04001c31, 0x02030030, 0x02030030,
-	0x07000c2c, 0x04001c30, 0x07000c00, 0x09610b00, 0x04005c71,
-	0x07000c6b, 0x0b003bab, 0x00000000, 0x0242bb6b, 0x0202a209,
-	0x05402c2a, 0x02030c0e, 0x07400c0a, 0x068000c0, 0x04001c30,
-	0x07400c00, 0x04001c30, 0x07400c2b, 0x0581002b, 0x04001c30,
-	0x07400c00, 0x0ac05bec, 0x0203024d, 0x07400c2a, 0x04001249,
-	0x0c780100, 0x0203020c, 0x07400c2a, 0x04001208, 0x0400128a,
-	0x0b8d52ca, 0x02000209, 0x07c070c9, 0x0cc00000, 0x07c07100,
-	0x0aa14040, 0x06800047, 0x06800006, 0x0c780100, 0x00000000,
-	0x06800007, 0x06800046, 0x05403c4a, 0x02031c4f, 0x04001c71,
-	0x07000c44, 0x09101004, 0x04001c31, 0x02030030, 0x02030030,
-	0x07000c2c, 0x04001c30, 0x07000c00, 0x09610b00, 0x04005c71,
-	0x07000c6b, 0x0b003bab, 0x00000000, 0x0242bb6b, 0x0be60404,
-	0x0a25c104, 0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a,
-	0x06800040, 0x04001c30, 0x07400c00, 0x0540102b, 0x020001c0,
-	0x04001c30, 0x07400c00, 0x05810000, 0x04001c30, 0x07400c00,
+	0x098081c8, 0x0c780240, 0x060e0408, 0x0a614248, 0x00000000,
+	0x0c008f80, 0x00000000, 0x0c7800c0, 0x0c780080, 0x00000000,
+	0x08031e00, 0x0cc00000, 0x00400000, 0x0680400f, 0x0680a00e,
+	0x0680ec0d, 0x0680f60c, 0x0780704b, 0x0680000a, 0x06800009,
+	0x06800008, 0x0780776f, 0x07807780, 0x09610bc0, 0x0780736e,
+	0x078020c0, 0x06800041, 0x0342d001, 0x07807300, 0x06800081,
+	0x0b831040, 0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44,
+	0x06800c00, 0x0bc25004, 0x09042004, 0x068000c1, 0x0a422040,
+	0x09101004, 0x04001c31, 0x02030030, 0x02030030, 0x07000c2c,
+	0x04001c30, 0x07000c00, 0x09610b00, 0x04005c71, 0x07000c6b,
+	0x0b003bab, 0x00000000, 0x0242bb6b, 0x0202a209, 0x05402c2a,
+	0x02030c0e, 0x07400c0a, 0x068000c0, 0x04001c30, 0x07400c00,
+	0x04001c30, 0x07400c2b, 0x0581002b, 0x04001c30, 0x07400c00,
 	0x0ac05bec, 0x0203024d, 0x07400c2a, 0x04001249, 0x0c780100,
-	0x0203020c, 0x07400c2a, 0x04001208, 0x0be60804, 0x0a25c204,
-	0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a, 0x06800080,
-	0x04001c30, 0x07400c00, 0x0540102b, 0x02000180, 0x04001c30,
+	0x0203020c, 0x07400c2a, 0x04001208, 0x0400128a, 0x0b8d52ca,
+	0x02000209, 0x07c070c9, 0x0cc00000, 0x07c07100, 0x0aa14040,
+	0x06800047, 0x06800006, 0x0c780100, 0x00000000, 0x06800007,
+	0x06800046, 0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44,
+	0x09101004, 0x04001c31, 0x02030030, 0x02030030, 0x07000c2c,
+	0x04001c30, 0x07000c00, 0x09610b00, 0x04005c71, 0x07000c6b,
+	0x0b003bab, 0x00000000, 0x0242bb6b, 0x0be60404, 0x0a25c104,
+	0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a, 0x06800040,
+	0x04001c30, 0x07400c00, 0x0540102b, 0x020001c0, 0x04001c30,
 	0x07400c00, 0x05810000, 0x04001c30, 0x07400c00, 0x0ac05bec,
 	0x0203024d, 0x07400c2a, 0x04001249, 0x0c780100, 0x0203020c,
-	0x07400c2a, 0x04001208, 0x0400128a, 0x0b8be2ca, 0x02000209,
-	0x07c070c9, 0x0cc00000, 0x07c07100, 0x0680400f, 0x0680a00e,
-	0x0680ec0d, 0x0780704b, 0x0680000a, 0x07807109, 0x07807300,
-	0x0ba6c080, 0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44,
-	0x09082004, 0x0a6440c0, 0x04006c71, 0x07000c6b, 0x05402c09,
-	0x02030c0e, 0x07400c0a, 0x068001c0, 0x04001c30, 0x07400c00,
-	0x04001c30, 0x07400c2b, 0x0581002b, 0x04001c30, 0x07400c00,
-	0x0203024d, 0x07400c09, 0x04001249, 0x0400128a, 0x0b8e92ca,
-	0x0cc00000, 0x07c07149, 0x0aa14040, 0x06800047, 0x06800006,
-	0x0c780100, 0x00000000, 0x06800007, 0x06800046, 0x05403c4a,
-	0x02031c4f, 0x04001c71, 0x07000c44, 0x04006c71, 0x07000c6b,
-	0x0a244404, 0x05402c09, 0x02030c0e, 0x07400c0a, 0x06800140,
-	0x04001c30, 0x07400c00, 0x0540102b, 0x020001c0, 0x04001c30,
-	0x07400c00, 0x05810000, 0x04001c30, 0x07400c00, 0x0203024d,
-	0x07400c09, 0x04001249, 0x0a244804, 0x05402c09, 0x02030c0e,
-	0x07400c0a, 0x06800180, 0x04001c30, 0x07400c00, 0x0540102b,
-	0x02000180, 0x04001c30, 0x07400c00, 0x05810000, 0x04001c30,
-	0x07400c00, 0x0203024d, 0x07400c09, 0x04001249, 0x0400128a,
-	0x0b8d72ca, 0x0cc00000, 0x07c07149, 0x0680ec0f, 0x0680f60e,
-	0x0780710a, 0x078070c9, 0x06800008, 0x0240a24a, 0x0200e28e,
-	0x0a60c009, 0x0cc00000, 0x00000000, 0x070003c0, 0x07400380,
-	0x040013cf, 0x0400138e, 0x04001208, 0x0b8fb248, 0x0cc00000,
-	0x00000000, 0x0680ec0f, 0x0680f60e, 0x0780710a, 0x078070c9,
-	0x06800008, 0x0240a24a, 0x0200f24f, 0x0a60c00a, 0x0cc00000,
-	0x00000000, 0x07000380, 0x074003c0, 0x040013cf, 0x0400138e,
-	0x04001208, 0x0b8fb288, 0x0cc00000, 0x00000000, 0x0680ec0f,
-	0x0680f60e, 0x0780710a, 0x07807149, 0x0200f28f, 0x0200e28e,
-	0x0a40324a, 0x0cc00000, 0x00000000, 0x070003c0, 0x07400380,
-	0x040013cf, 0x0400138e, 0x0400128a, 0x0b8fb24a, 0x0cc00000,
-	0x00000000, 0x0b60808e, 0x0c780e00, 0x0680a00c, 0x0680400b,
-	0x0680000a, 0x0a83438a, 0x0400124a, 0x0202f28f, 0x07000bee,
-	0x0540222e, 0x0200820c, 0x04002208, 0x0700022d, 0x04001208,
-	0x07000200, 0x09610b40, 0x0a814389, 0x0202c24f, 0x07000b2b,
-	0x0540222b, 0x0200820c, 0x04002208, 0x0700022a, 0x04001208,
-	0x07000200, 0x09610a80, 0x0a60c00d, 0x0b807aad, 0x0c7800c0,
-	0x0ac05aad, 0x00000000, 0x07400b2e, 0x04000bab, 0x04000b6a,
-	0x04001249, 0x0c7ffb40, 0x07807300, 0x0b644080, 0x0a24004a,
-	0x0540222e, 0x0200820c, 0x04002208, 0x07000207, 0x0a22c047,
-	0x04401b6f, 0x07000b6c, 0x0540222c, 0x0200820c, 0x04002208,
-	0x07000207, 0x0be10047, 0x00000000, 0x07400b6e, 0x04000bac,
-	0x07400bee, 0x0400128a, 0x0c7ff340, 0x0cc00000, 0x00000000,
-	0x0b60808e, 0x0c781680, 0x0680a00c, 0x0680400b, 0x0680000a,
-	0x0a85638a, 0x0400124a, 0x0202f28f, 0x07000bee, 0x0540222e,
-	0x0200820c, 0x07000207, 0x04001208, 0x07000206, 0x054031c7,
-	0x020071cb, 0x09002146, 0x0a6280c5, 0x00000000, 0x040011c7,
-	0x070001c4, 0x09101c44, 0x040011c7, 0x02007c47, 0x02007c47,
-	0x0c780100, 0x00000000, 0x02007147, 0x02007147, 0x070001ed,
-	0x040011c7, 0x070001c0, 0x09610b40, 0x0a825389, 0x0202c24f,
-	0x07000b2b, 0x0540222b, 0x0200820c, 0x07000207, 0x04001208,
-	0x07000206, 0x054031c7, 0x020071cb, 0x09002146, 0x0a6280c5,
-	0x00000000, 0x040011c7, 0x070001c4, 0x09101c44, 0x040011c7,
-	0x02007c47, 0x02007c47, 0x0c780100, 0x00000000, 0x02007147,
-	0x02007147, 0x070001ea, 0x040011c7, 0x070001c0, 0x09610a80,
-	0x0a60c00d, 0x0b807aad, 0x0c7800c0, 0x0ac05aad, 0x00000000,
-	0x07400b2e, 0x04000bab, 0x04000b6a, 0x04001249, 0x0c7ff700,
-	0x07807300, 0x0b644080, 0x0a24004a, 0x0540222e, 0x0200820c,
-	0x04002208, 0x07000207, 0x0a22c047, 0x04401b6f, 0x07000b6c,
-	0x0540222c, 0x0200820c, 0x04002208, 0x07000207, 0x0be10047,
-	0x00000000, 0x07400b6e, 0x04000bac, 0x07400bee, 0x0400128a,
-	0x0c7feac0, 0x0cc00000, 0x00000000, 0x0400120a, 0x0200720f,
-	0x070001c9, 0x05402189, 0x0200618c, 0x04002186, 0x07000185,
-	0x09001005, 0x0a4092c0, 0x04401c47, 0x07000c40, 0x074001c0,
-	0x04401208, 0x0acfc288, 0x040001f1, 0x0cc00000, 0x074001c9,
-	0x04001208, 0x0b8ef388, 0x0cc00000, 0x00000000, 0x0780710e,
-	0x0440134e, 0x0680a00c, 0x0680000a, 0x0b60808e, 0x0c7804c0,
-	0x0200928f, 0x07000248, 0x054021c8, 0x020071cc, 0x040021c7,
-	0x070001c6, 0x0be1804a, 0x0be24046, 0x00000000, 0x0c07f700,
-	0x0680004b, 0x0c780140, 0x0a210046, 0x00000000, 0x0c07f5c0,
-	0x0680000b, 0x0400128a, 0x0b8ef34a, 0x0cc00000, 0x00000000,
-	0x06800008, 0x0700040a, 0x0200720f, 0x070001c9, 0x05402189,
-	0x020061af, 0x04001186, 0x07000185, 0x09041005, 0x0a418a80,
-	0x04001186, 0x07000185, 0x04001186, 0x07000180, 0x09610140,
-	0x0a412305, 0x0a80e348, 0x0ac07348, 0x00000000, 0x0200734f,
-	0x0a80a34a, 0x0400128a, 0x0440120a, 0x0200720f, 0x04401c47,
-	0x07000c40, 0x074001c0, 0x04401208, 0x0acfc348, 0x040001f1,
-	0x074001c9, 0x0cc00000, 0x0740040a, 0x04001208, 0x0b8e0288,
-	0x0cc00000, 0x00000000, 0x0680a02f, 0x078020c0, 0x06800041,
-	0x0342e001, 0x0780736d, 0x07807300, 0x0b614080, 0x00000000,
-	0x05401bae, 0x05401b6d, 0x04001b6d, 0x0242cbad, 0x04000aed,
-	0x0680000d, 0x0680002a, 0x07000380, 0x0400138e, 0x0aa10000,
-	0x0aa30040, 0x0aa50080, 0x0c780680, 0x07000380, 0x0400138e,
-	0x04001000, 0x0242b02b, 0x0b411b2b, 0x0400032b, 0x0202bbab,
-	0x0c780380, 0x0400032b, 0x07000380, 0x0400138e, 0x04001000,
-	0x0202b02b, 0x0b808b6b, 0x0400032b, 0x0242bbab, 0x0c780140,
-	0x0400032b, 0x0680006a, 0x0700038c, 0x0400138e, 0x0c07ec40,
-	0x00000000, 0x0c7ff880, 0x0400134d, 0x0cc00000, 0x00000000,
-	0x0c077280, 0x00000000, 0x0c079600, 0x00000000, 0x07802080,
-	0x0aa64180, 0x00000000, 0x0c07ae80, 0x00000000, 0x07807140,
-	0x07c07240, 0x0680ec0f, 0x0780710e, 0x0680004d, 0x0c07b580,
+	0x07400c2a, 0x04001208, 0x0be60804, 0x0a25c204, 0x0202a209,
+	0x05402c2a, 0x02030c0e, 0x07400c0a, 0x06800080, 0x04001c30,
+	0x07400c00, 0x0540102b, 0x02000180, 0x04001c30, 0x07400c00,
+	0x05810000, 0x04001c30, 0x07400c00, 0x0ac05bec, 0x0203024d,
+	0x07400c2a, 0x04001249, 0x0c780100, 0x0203020c, 0x07400c2a,
+	0x04001208, 0x0400128a, 0x0b8be2ca, 0x02000209, 0x07c070c9,
+	0x0cc00000, 0x07c07100, 0x0680400f, 0x0680a00e, 0x0680ec0d,
+	0x0780704b, 0x0680000a, 0x07807109, 0x07807300, 0x0ba6c080,
+	0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44, 0x09082004,
+	0x0a6440c0, 0x04006c71, 0x07000c6b, 0x05402c09, 0x02030c0e,
+	0x07400c0a, 0x068001c0, 0x04001c30, 0x07400c00, 0x04001c30,
+	0x07400c2b, 0x0581002b, 0x04001c30, 0x07400c00, 0x0203024d,
+	0x07400c09, 0x04001249, 0x0400128a, 0x0b8e92ca, 0x0cc00000,
+	0x07c07149, 0x0aa14040, 0x06800047, 0x06800006, 0x0c780100,
+	0x00000000, 0x06800007, 0x06800046, 0x05403c4a, 0x02031c4f,
+	0x04001c71, 0x07000c44, 0x04006c71, 0x07000c6b, 0x0a244404,
+	0x05402c09, 0x02030c0e, 0x07400c0a, 0x06800140, 0x04001c30,
+	0x07400c00, 0x0540102b, 0x020001c0, 0x04001c30, 0x07400c00,
+	0x05810000, 0x04001c30, 0x07400c00, 0x0203024d, 0x07400c09,
+	0x04001249, 0x0a244804, 0x05402c09, 0x02030c0e, 0x07400c0a,
+	0x06800180, 0x04001c30, 0x07400c00, 0x0540102b, 0x02000180,
+	0x04001c30, 0x07400c00, 0x05810000, 0x04001c30, 0x07400c00,
+	0x0203024d, 0x07400c09, 0x04001249, 0x0400128a, 0x0b8d72ca,
+	0x0cc00000, 0x07c07149, 0x0680ec0f, 0x0680f60e, 0x0780710a,
+	0x078070c9, 0x06800008, 0x0240a24a, 0x0200e28e, 0x0a60c009,
+	0x0cc00000, 0x00000000, 0x070003c0, 0x07400380, 0x040013cf,
+	0x0400138e, 0x04001208, 0x0b8fb248, 0x0cc00000, 0x00000000,
+	0x0680ec0f, 0x0680f60e, 0x0780710a, 0x078070c9, 0x06800008,
+	0x0240a24a, 0x0200f24f, 0x0a60c00a, 0x0cc00000, 0x00000000,
+	0x07000380, 0x074003c0, 0x040013cf, 0x0400138e, 0x04001208,
+	0x0b8fb288, 0x0cc00000, 0x00000000, 0x0680ec0f, 0x0680f60e,
+	0x0780710a, 0x07807149, 0x0200f28f, 0x0200e28e, 0x0a40324a,
+	0x0cc00000, 0x00000000, 0x070003c0, 0x07400380, 0x040013cf,
+	0x0400138e, 0x0400128a, 0x0b8fb24a, 0x0cc00000, 0x00000000,
+	0x0b60808e, 0x0c780e00, 0x0680a00c, 0x0680400b, 0x0680000a,
+	0x0a83438a, 0x0400124a, 0x0202f28f, 0x07000bee, 0x0540222e,
+	0x0200820c, 0x04002208, 0x0700022d, 0x04001208, 0x07000200,
+	0x09610b40, 0x0a814389, 0x0202c24f, 0x07000b2b, 0x0540222b,
+	0x0200820c, 0x04002208, 0x0700022a, 0x04001208, 0x07000200,
+	0x09610a80, 0x0a60c00d, 0x0b807aad, 0x0c7800c0, 0x0ac05aad,
+	0x00000000, 0x07400b2e, 0x04000bab, 0x04000b6a, 0x04001249,
+	0x0c7ffb40, 0x07807300, 0x0b644080, 0x0a24004a, 0x0540222e,
+	0x0200820c, 0x04002208, 0x07000207, 0x0a22c047, 0x04401b6f,
+	0x07000b6c, 0x0540222c, 0x0200820c, 0x04002208, 0x07000207,
+	0x0be10047, 0x00000000, 0x07400b6e, 0x04000bac, 0x07400bee,
+	0x0400128a, 0x0c7ff340, 0x0cc00000, 0x00000000, 0x0b60808e,
+	0x0c781680, 0x0680a00c, 0x0680400b, 0x0680000a, 0x0a85638a,
+	0x0400124a, 0x0202f28f, 0x07000bee, 0x0540222e, 0x0200820c,
+	0x07000207, 0x04001208, 0x07000206, 0x054031c7, 0x020071cb,
+	0x09002146, 0x0a6280c5, 0x00000000, 0x040011c7, 0x070001c4,
+	0x09101c44, 0x040011c7, 0x02007c47, 0x02007c47, 0x0c780100,
+	0x00000000, 0x02007147, 0x02007147, 0x070001ed, 0x040011c7,
+	0x070001c0, 0x09610b40, 0x0a825389, 0x0202c24f, 0x07000b2b,
+	0x0540222b, 0x0200820c, 0x07000207, 0x04001208, 0x07000206,
+	0x054031c7, 0x020071cb, 0x09002146, 0x0a6280c5, 0x00000000,
+	0x040011c7, 0x070001c4, 0x09101c44, 0x040011c7, 0x02007c47,
+	0x02007c47, 0x0c780100, 0x00000000, 0x02007147, 0x02007147,
+	0x070001ea, 0x040011c7, 0x070001c0, 0x09610a80, 0x0a60c00d,
+	0x0b807aad, 0x0c7800c0, 0x0ac05aad, 0x00000000, 0x07400b2e,
+	0x04000bab, 0x04000b6a, 0x04001249, 0x0c7ff700, 0x07807300,
+	0x0b644080, 0x0a24004a, 0x0540222e, 0x0200820c, 0x04002208,
+	0x07000207, 0x0a22c047, 0x04401b6f, 0x07000b6c, 0x0540222c,
+	0x0200820c, 0x04002208, 0x07000207, 0x0be10047, 0x00000000,
+	0x07400b6e, 0x04000bac, 0x07400bee, 0x0400128a, 0x0c7feac0,
+	0x0cc00000, 0x00000000, 0x0400120a, 0x0200720f, 0x070001c9,
+	0x05402189, 0x0200618c, 0x04002186, 0x07000185, 0x09001005,
+	0x0a4092c0, 0x04401c47, 0x07000c40, 0x074001c0, 0x04401208,
+	0x0acfc288, 0x040001f1, 0x0cc00000, 0x074001c9, 0x04001208,
+	0x0b8ef388, 0x0cc00000, 0x00000000, 0x0780710e, 0x0440134e,
+	0x0680a00c, 0x0680000a, 0x0b60808e, 0x0c7804c0, 0x0200928f,
+	0x07000248, 0x054021c8, 0x020071cc, 0x040021c7, 0x070001c6,
+	0x0be1804a, 0x0be24046, 0x00000000, 0x0c07f700, 0x0680004b,
+	0x0c780140, 0x0a210046, 0x00000000, 0x0c07f5c0, 0x0680000b,
+	0x0400128a, 0x0b8ef34a, 0x0cc00000, 0x00000000, 0x06800008,
+	0x0700040a, 0x0200720f, 0x070001c9, 0x05402189, 0x020061af,
+	0x04001186, 0x07000185, 0x09041005, 0x0a418a80, 0x04001186,
+	0x07000185, 0x04001186, 0x07000180, 0x09610140, 0x0a412305,
+	0x0a80e348, 0x0ac07348, 0x00000000, 0x0200734f, 0x0a80a34a,
+	0x0400128a, 0x0440120a, 0x0200720f, 0x04401c47, 0x07000c40,
+	0x074001c0, 0x04401208, 0x0acfc348, 0x040001f1, 0x074001c9,
+	0x0cc00000, 0x0740040a, 0x04001208, 0x0b8e0288, 0x0cc00000,
+	0x00000000, 0x0680a02f, 0x078020c0, 0x06800041, 0x0342e001,
+	0x0780736d, 0x07807300, 0x0b614080, 0x00000000, 0x05401bae,
+	0x05401b6d, 0x04001b6d, 0x0242cbad, 0x04000aed, 0x0680000d,
+	0x0680002a, 0x07000380, 0x0400138e, 0x0aa10000, 0x0aa30040,
+	0x0aa50080, 0x0c780680, 0x07000380, 0x0400138e, 0x04001000,
+	0x0242b02b, 0x0b411b2b, 0x0400032b, 0x0202bbab, 0x0c780380,
+	0x0400032b, 0x07000380, 0x0400138e, 0x04001000, 0x0202b02b,
+	0x0b808b6b, 0x0400032b, 0x0242bbab, 0x0c780140, 0x0400032b,
+	0x0680006a, 0x0700038c, 0x0400138e, 0x0c07ec40, 0x00000000,
+	0x0c7ff880, 0x0400134d, 0x0cc00000, 0x00000000, 0x0c077280,
+	0x00000000, 0x0c079600, 0x00000000, 0x07802080, 0x0aa64180,
+	0x00000000, 0x0c07ae80, 0x00000000, 0x07807140, 0x07c07240,
+	0x0680ec0f, 0x0780710e, 0x0680004d, 0x0c07b580, 0x00000000,
+	0x0680ec0f, 0x0780714e, 0x07807100, 0x0200f00f, 0x0240e00e,
+	0x0680000d, 0x0c07b380, 0x00000000, 0x0680ec0f, 0x0680c00e,
+	0x0c07ed80, 0x06807250, 0x0cc00000, 0x00000000, 0x0680ec0f,
+	0x078070ce, 0x0680004d, 0x0c07bf80, 0x00000000, 0x0680f60f,
+	0x0780710e, 0x078070c0, 0x0240e00e, 0x0680000d, 0x0c07bdc0,
 	0x00000000, 0x0680ec0f, 0x0780714e, 0x07807100, 0x0200f00f,
-	0x0240e00e, 0x0680000d, 0x0c07b380, 0x00000000, 0x0680ec0f,
-	0x0680c00e, 0x0c07ed80, 0x06807250, 0x0cc00000, 0x00000000,
-	0x0680ec0f, 0x078070ce, 0x0680004d, 0x0c07bf80, 0x00000000,
-	0x0680f60f, 0x0780710e, 0x078070c0, 0x0240e00e, 0x0680000d,
-	0x0c07bdc0, 0x00000000, 0x0680ec0f, 0x0780714e, 0x07807100,
-	0x0200f00f, 0x0240e00e, 0x0680000d, 0x0c07ad00, 0x00000000,
-	0x0c07a3c0, 0x00000000, 0x0c079ec0, 0x00000000, 0x0c07a740,
-	0x00000000, 0x07807140, 0x07c07240, 0x07c07280, 0x07807300,
-	0x0b618080, 0x00000000, 0x0c07d4c0, 0x0680ec0f, 0x0c07d440,
-	0x0680f60f, 0x078070c0, 0x07807101, 0x07807170, 0x0ba280b0,
-	0x0aa0c000, 0x0a802040, 0x0c7801c0, 0x0680f60f, 0x0400138f,
-	0x070003c0, 0x07000381, 0x07400380, 0x074003c1, 0x0680ec0f,
-	0x0680c00e, 0x0c07dfc0, 0x06807250, 0x0680f60f, 0x0680d08e,
-	0x0c07dec0, 0x06807290, 0x0cc00000, 0x00000000, 0x00000000,
+	0x0240e00e, 0x0680000d, 0x0c07ad00, 0x00000000, 0x0c07a3c0,
+	0x00000000, 0x0c079ec0, 0x00000000, 0x0c07a740, 0x00000000,
+	0x07807140, 0x07c07240, 0x07c07280, 0x07807300, 0x0b618080,
+	0x00000000, 0x0c07d4c0, 0x0680ec0f, 0x0c07d440, 0x0680f60f,
+	0x078070c0, 0x07807101, 0x07807170, 0x0ba280b0, 0x0aa0c000,
+	0x0a802040, 0x0c7801c0, 0x0680f60f, 0x0400138f, 0x070003c0,
+	0x07000381, 0x07400380, 0x074003c1, 0x0680ec0f, 0x0680c00e,
+	0x0c07dfc0, 0x06807250, 0x0680f60f, 0x0680d08e, 0x0c07dec0,
+	0x06807290, 0x0cc00000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264mmc_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264mmc_linux.h
index 9fb6d49..6e2d3c9 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264mmc_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264mmc_linux.h
@@ -1,15 +1,13 @@
 static const u32 MicroCode[] __initconst = {
 	0x06bfff40, 0x06032400, 0x00400000, 0x0c780000, 0x00000000,
-	0x09027207, 0x0a6140c8, 0x00000000, 0x0c00d600, 0x00000000,
-	0x0c780540, 0x0a614148, 0x00000000, 0x0c003cc0, 0x00000000,
-	0x0c780400, 0x0a614188, 0x00000000, 0x0c006c40, 0x00000000,
-	0x0c7802c0, 0x0a6141c8, 0x00000000, 0x0c007800, 0x00000000,
-	0x0c780180, 0x0a628208, 0x00000000, 0x0c000ec0, 0x00000000,
+	0x09027207, 0x0a6140c8, 0x00000000, 0x0c00d740, 0x00000000,
+	0x0c780540, 0x0a614148, 0x00000000, 0x0c003a00, 0x00000000,
+	0x0c780400, 0x0a614188, 0x00000000, 0x0c006d40, 0x00000000,
+	0x0c7802c0, 0x0a6141c8, 0x00000000, 0x0c007980, 0x00000000,
+	0x0c780180, 0x0a628208, 0x00000000, 0x0c000c40, 0x00000000,
 	0x00000000, 0x08031e00, 0x0cc00000, 0x00400000, 0x0c7ff8c0,
-	0x06431e07, 0x0a62c288, 0x06431f20, 0x06433f21, 0x0e000860,
-	0x00000000, 0x00000000, 0x0f000800, 0x06031f20, 0x0f010840,
-	0x0c7ffc80, 0x06033f21, 0x0aa18000, 0x07800af1, 0x04001c71,
-	0x09010c71, 0x0a610031, 0x00000000, 0x07c00ac0, 0x07c00b00,
+	0x06431e07, 0x0aa18000, 0x07800af1, 0x04001c71, 0x09010c71,
+	0x0a614031, 0x00000000, 0x05810c40, 0x07c00af1, 0x07c00b00,
 	0x0cc00000, 0x00000000, 0x078077c5, 0x04002c4e, 0x07400c45,
 	0x07807800, 0x04003c4e, 0x07400c40, 0x0cc00000, 0x09610140,
 	0x07807846, 0x04004c4e, 0x07400c46, 0x07807880, 0x04005c4e,
@@ -21,90 +19,93 @@ static const u32 MicroCode[] __initconst = {
 	0x0200e38f, 0x04001c4e, 0x07000c4d, 0x078072c0, 0x090a1040,
 	0x090c1c00, 0x02c0cc01, 0x0780730b, 0x0aa1000b, 0x0aa7c04b,
 	0x0c780c40, 0x00000000, 0x0980d00d, 0x0c07f340, 0x0944134c,
-	0x0c07f040, 0x04000005, 0x0a22008d, 0x09481350, 0x04004c4e,
+	0x0c07f000, 0x04000005, 0x0a22008d, 0x09481350, 0x04004c4e,
 	0x07000c46, 0x04005c4e, 0x07000c40, 0x0c780e00, 0x09610180,
 	0x0c07f240, 0x0980d28d, 0x07000380, 0x09c00300, 0x07400380,
 	0x07807200, 0x02000300, 0x07c07200, 0x0649cf00, 0x0be11000,
 	0x06800040, 0x078071c0, 0x04001000, 0x0c780a40, 0x07c071c0,
-	0x0980d04d, 0x0c07ee40, 0x0946134c, 0x0c07e940, 0x04000006,
+	0x0980d04d, 0x0c07ee40, 0x0946134c, 0x0c07e900, 0x04000006,
 	0x0a22004d, 0x094a1350, 0x04002c4e, 0x07000c45, 0x04003c4e,
 	0x07000c40, 0x0c780700, 0x09610140, 0x0c07e940, 0x0980d28d,
 	0x07000380, 0x09800300, 0x0c7ff940, 0x07400380, 0x0980d00d,
 	0x0980d04d, 0x0944134c, 0x0946134c, 0x0c07e6c0, 0x09481350,
-	0x0c07e3c0, 0x04000005, 0x0c07e7c0, 0x094a1350, 0x0980d28d,
+	0x0c07e380, 0x04000005, 0x0c07e7c0, 0x094a1350, 0x0980d28d,
 	0x07807200, 0x02000300, 0x07c07200, 0x0649cf00, 0x0be11000,
 	0x06800040, 0x078071c0, 0x04001000, 0x07c071c0, 0x04006c4e,
 	0x07807340, 0x07400c40, 0x04007c4e, 0x07400c51, 0x094c234b,
 	0x05801010, 0x05409000, 0x02c0d00d, 0x07801e40, 0x07000381,
-	0x09501040, 0x0400100e, 0x07000000, 0x0be100c0, 0x00000000,
-	0x07802080, 0x09523040, 0x07400381, 0x07802fc0, 0x09584340,
-	0x0900200d, 0x0a6100c0, 0x0be0c30d, 0x06800000, 0x09402340,
-	0x09c0d20d, 0x04001c4e, 0x0ac03185, 0x0c780140, 0x07400c4d,
-	0x0980d20d, 0x0c780080, 0x07400c4d, 0x0649cf00, 0x0a2440c0,
-	0x0900200d, 0x0680000b, 0x0940634b, 0x07400c4d, 0x0c002080,
-	0x0780718d, 0x040012cb, 0x0aa1c00b, 0x06804080, 0x0609c000,
-	0x0609ce00, 0x0649cf00, 0x0be08080, 0x0c780000, 0x06800040,
-	0x07c01d80, 0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e,
-	0x078020c0, 0x06800041, 0x0340d001, 0x0780734c, 0x06803fcb,
-	0x06800008, 0x05403c48, 0x02031c4f, 0x04001c71, 0x07000c70,
-	0x0a230330, 0x0be2cc30, 0x04005c71, 0x07000c41, 0x0b803301,
-	0x00000000, 0x02401341, 0x0aa0ffcb, 0x0b80404a, 0x00000000,
-	0x04000281, 0x040002c8, 0x04001208, 0x0b8ef388, 0x0cc00000,
-	0x00000000, 0x0780720d, 0x0780390c, 0x0b82230d, 0x0c07f840,
-	0x00000000, 0x0400024a, 0x0aa7bfcb, 0x0680400f, 0x05403c4b,
-	0x02031c4f, 0x04001c71, 0x07000c70, 0x06800000, 0x09404c00,
-	0x07400c70, 0x07807200, 0x04401000, 0x07c07200, 0x04401071,
-	0x07000040, 0x09005000, 0x06800041, 0x03401001, 0x07807080,
-	0x03000040, 0x07c07080, 0x06810000, 0x0bc09030, 0x078071c0,
-	0x04401000, 0x07c071c0, 0x0649cf00, 0x0be11000, 0x0be0c080,
-	0x0c07f080, 0x0a8e3289, 0x0cc00000, 0x00000000, 0x0680400f,
-	0x0780704e, 0x06803fcd, 0x0680000c, 0x06800008, 0x05403c48,
-	0x02031c4f, 0x04001c71, 0x07000c70, 0x06810000, 0x0a00e030,
-	0x04001c71, 0x09101030, 0x02031031, 0x02031031, 0x07000c41,
-	0x04001c71, 0x07000c40, 0x09610040, 0x0aa0ffcd, 0x0b80404c,
-	0x00000000, 0x04000301, 0x04000348, 0x04001208, 0x0b8ec388,
-	0x0cc00000, 0x00000000, 0x0649c701, 0x0aa24001, 0x04401041,
-	0x0809c700, 0x05403041, 0x020013c1, 0x04001041, 0x07000070,
-	0x09c302f0, 0x07400070, 0x0649c801, 0x0aa24001, 0x04401041,
-	0x0809c800, 0x05403041, 0x020013c1, 0x04001041, 0x07000070,
-	0x09c302f0, 0x07400070, 0x0cc00000, 0x00000000, 0x0680400f,
-	0x05403c4d, 0x02031c4f, 0x04001c71, 0x07000c40, 0x06800081,
-	0x09542001, 0x07400c40, 0x04401c31, 0x07000c04, 0x0c7800c0,
-	0x05808044, 0x0be20041, 0x07801c01, 0x0aa10001, 0x0a216004,
-	0x06800001, 0x07c01c01, 0x05809040, 0x0a218041, 0x06800001,
-	0x09523001, 0x07400c40, 0x0c781300, 0x044012cb, 0x0c07f440,
-	0x00000000, 0x0649c001, 0x0bef7fc1, 0x09101044, 0x0a60c00b,
-	0x05409041, 0x0809d100, 0x09123c04, 0x0540210b, 0x03430130,
-	0x0649d104, 0x02c04c04, 0x0609d104, 0x0940504d, 0x09184c00,
-	0x0aa583f0, 0x068001c4, 0x0aa50030, 0x06800004, 0x0b648170,
-	0x04404130, 0x0649cf04, 0x0be24084, 0x0b6380f0, 0x04002130,
-	0x0aa30070, 0x06800144, 0x0b6280b0, 0x06800184, 0x0c780200,
-	0x068001c4, 0x04401131, 0x07000104, 0x0580c104, 0x0a20c044,
-	0x06800144, 0x06800184, 0x094a3044, 0x07802130, 0x0aa0c030,
-	0x00000000, 0x09801201, 0x090c2c00, 0x0a60c0b0, 0x00000000,
-	0x09801201, 0x04401c71, 0x07000c70, 0x090a2c30, 0x09542070,
-	0x078017f0, 0x09583070, 0x07c00b0c, 0x05810c0c, 0x07c00af0,
-	0x06803230, 0x02030370, 0x07000c30, 0x09610070, 0x06800030,
-	0x02030370, 0x07000c04, 0x0aa0c00b, 0x0aa1404b, 0x00000000,
-	0x0609ca04, 0x0c7801c0, 0x0609c101, 0x0649ca30, 0x09610c04,
-	0x0609ca30, 0x0c780080, 0x0609c201, 0x0649cf01, 0x0be09001,
-	0x0be100c0, 0x078071c0, 0x04401000, 0x07c071c0, 0x0cc00000,
-	0x00000000, 0x0680000b, 0x07803d0d, 0x0a21880d, 0x0780318c,
-	0x07801b8d, 0x0b00334c, 0x00000000, 0x07801b8c, 0x078071cd,
-	0x0649cf00, 0x0be0d000, 0x0b01730d, 0x0c7800c0, 0x0680004c,
-	0x0b80d30d, 0x00000000, 0x0c07d4c0, 0x00000000, 0x0a613fcd,
-	0x0c079cc0, 0x00000000, 0x0c780180, 0x0c07dfc0, 0x00000000,
-	0x040012cb, 0x0aa0808b, 0x0c7ff9c0, 0x0aa1400b, 0x06800080,
-	0x0950800b, 0x0609c000, 0x0609ce00, 0x0cc00000, 0x00000000,
-	0x0649cf0c, 0x0bee208c, 0x078071cc, 0x0bad808c, 0x0c07cf40,
-	0x00000000, 0x0aacffcd, 0x07800b00, 0x07800af0, 0x09610030,
-	0x04002000, 0x07802ff0, 0x0a60c030, 0x0b8e700c, 0x0c7ffac0,
-	0x0b0e500c, 0x0c7ffa40, 0x00000000, 0x0680000b, 0x078071cd,
-	0x0aa3c00d, 0x0c07cb00, 0x00000000, 0x0a613fcd, 0x0c079300,
-	0x00000000, 0x0c780240, 0x07807180, 0x0a807340, 0x00000000,
-	0x0c07d540, 0x00000000, 0x040012cb, 0x0aa0808b, 0x0c7ffc40,
+	0x09501040, 0x0400100e, 0x07000000, 0x0be0c0c0, 0x07802080,
+	0x09523040, 0x07400381, 0x07802fc0, 0x09584340, 0x0900200d,
+	0x0a6100c0, 0x0be0c30d, 0x06800000, 0x09402340, 0x09c0d20d,
+	0x04001c4e, 0x0ac03185, 0x0c780140, 0x07400c4d, 0x0980d20d,
+	0x0c780080, 0x07400c4d, 0x0649cf00, 0x0a2440c0, 0x0900200d,
+	0x0680000b, 0x0940634b, 0x07400c4d, 0x0c002000, 0x0780718d,
+	0x040012cb, 0x0aa1c00b, 0x06804080, 0x0609c000, 0x0609ce00,
+	0x0649cf00, 0x0be08080, 0x0c780000, 0x06800040, 0x07c01d80,
+	0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e, 0x078020c0,
+	0x06800041, 0x0340d001, 0x0780734c, 0x06803fcb, 0x06800008,
+	0x05403c48, 0x02031c4f, 0x04001c71, 0x07000c70, 0x0a230330,
+	0x0be2cc30, 0x04005c71, 0x07000c41, 0x0b803301, 0x00000000,
+	0x02401341, 0x0aa0ffcb, 0x0b80404a, 0x00000000, 0x04000281,
+	0x040002c8, 0x04001208, 0x0b8ef388, 0x0cc00000, 0x00000000,
+	0x0780720d, 0x0780390c, 0x0b81c30d, 0x0c07f840, 0x00000000,
+	0x0aa67fcb, 0x0680400f, 0x05403c4b, 0x02031c4f, 0x04001c71,
+	0x07000c70, 0x06800000, 0x09404c00, 0x07400c70, 0x07807200,
+	0x04401000, 0x07c07200, 0x04401071, 0x07000040, 0x09005000,
+	0x06800041, 0x03401001, 0x07807080, 0x03000040, 0x07c07080,
+	0x06810000, 0x0bc04030, 0x078071c0, 0x04401000, 0x07c071c0,
+	0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e, 0x06803fcd,
+	0x0680000c, 0x06800008, 0x05403c48, 0x02031c4f, 0x04001c71,
+	0x07000c70, 0x06810000, 0x0a00e030, 0x04001c71, 0x09101030,
+	0x02031031, 0x02031031, 0x07000c41, 0x04001c71, 0x07000c40,
+	0x09610040, 0x0aa0ffcd, 0x0b80404c, 0x00000000, 0x04000301,
+	0x04000348, 0x04001208, 0x0b8ec388, 0x00000000, 0x05403c4d,
+	0x02031c4f, 0x07000c70, 0x0cc00000, 0x091233f0, 0x0649c701,
+	0x0aa24001, 0x04401041, 0x0809c700, 0x05403041, 0x020013c1,
+	0x04001041, 0x07000070, 0x09c302f0, 0x07400070, 0x0649c801,
+	0x0aa24001, 0x04401041, 0x0809c800, 0x05403041, 0x020013c1,
+	0x04001041, 0x07000070, 0x09c302f0, 0x07400070, 0x0cc00000,
+	0x00000000, 0x0680400f, 0x05403c4d, 0x02031c4f, 0x04001c71,
+	0x07000c40, 0x06800081, 0x09542001, 0x07400c40, 0x04401c31,
+	0x07000c04, 0x090c2040, 0x0609d701, 0x07802141, 0x0a644001,
+	0x078006c1, 0x0b63c081, 0x0aa24001, 0x07800730, 0x07800741,
+	0x09610c01, 0x0b402c0c, 0x0a64000c, 0x068000b0, 0x0c7801c0,
+	0x07c006f0, 0x07c0070c, 0x0581004c, 0x07c00741, 0x06800041,
+	0x07c006c1, 0x07801c01, 0x0aa10001, 0x0a216004, 0x06800001,
+	0x07c01c01, 0x05809040, 0x0a218041, 0x06800001, 0x09523001,
+	0x07400c40, 0x0c781300, 0x044012cb, 0x0c07f000, 0x00000000,
+	0x0649c001, 0x0bef7fc1, 0x09101044, 0x0a60c00b, 0x05409041,
+	0x0809d100, 0x09123c04, 0x0540210b, 0x03430130, 0x0649d104,
+	0x02c04c04, 0x0609d104, 0x0940504d, 0x09184c00, 0x0aa583f0,
+	0x068001c4, 0x0aa50030, 0x06800004, 0x0b648170, 0x04404130,
+	0x0649cf04, 0x0be24084, 0x0b6380f0, 0x04002130, 0x0aa30070,
+	0x06800144, 0x0b6280b0, 0x06800184, 0x0c780200, 0x068001c4,
+	0x04401131, 0x07000104, 0x0580c104, 0x0a20c044, 0x06800144,
+	0x06800184, 0x094a3044, 0x07802130, 0x0aa0c030, 0x00000000,
+	0x09801201, 0x090c2c00, 0x0a60c0b0, 0x00000000, 0x09801201,
+	0x04401c71, 0x07000c70, 0x090a2c30, 0x09542070, 0x078017f0,
+	0x09583070, 0x07c00b0c, 0x05810c0c, 0x07c00af0, 0x06803230,
+	0x02030370, 0x07000c30, 0x09610070, 0x06800030, 0x02030370,
+	0x07000c04, 0x0aa0c00b, 0x0aa1404b, 0x00000000, 0x0609ca04,
+	0x0c7801c0, 0x0609c101, 0x0649ca30, 0x09610c04, 0x0609ca30,
+	0x0c780080, 0x0609c201, 0x0649cf01, 0x0be09001, 0x0be100c0,
+	0x078071c0, 0x04401000, 0x07c071c0, 0x0cc00000, 0x00000000,
+	0x0680000b, 0x07803d0d, 0x0a21880d, 0x0780318c, 0x07801b8d,
+	0x0b00334c, 0x00000000, 0x07801b8c, 0x078071cd, 0x0649cf00,
+	0x0be0d000, 0x0b01630d, 0x0c7800c0, 0x0680004c, 0x0b80c30d,
+	0x0c07cfc0, 0x00000000, 0x0a613fcd, 0x0c079980, 0x00000000,
+	0x0c780180, 0x0c07dbc0, 0x00000000, 0x040012cb, 0x0aa0808b,
+	0x0c7ffa00, 0x0aa1400b, 0x06800080, 0x0950800b, 0x0609c000,
+	0x0609ce00, 0x0cc00000, 0x00000000, 0x0649cf0c, 0x0bee208c,
+	0x0c07cac0, 0x00000000, 0x0aad7fcd, 0x07800b00, 0x07800af0,
+	0x09610030, 0x078008f0, 0x0a610030, 0x06800070, 0x07c008f0,
+	0x0a8e8300, 0x078071f0, 0x0baac0b0, 0x04002000, 0x0ba0c00c,
+	0x0aa0814f, 0x0b0e200c, 0x0c7ff980, 0x00000000, 0x0680000b,
+	0x078071cd, 0x0aa3800d, 0x0c07c540, 0x00000000, 0x0a613fcd,
+	0x0c078f00, 0x00000000, 0x0c780200, 0x07807180, 0x0a806340,
+	0x0c07d0c0, 0x00000000, 0x040012cb, 0x0aa0808b, 0x0c7ffc80,
 	0x0aa1c00b, 0x06800080, 0x0950800b, 0x0609c000, 0x0609ce00,
-	0x0c7ffac0, 0x0680000b, 0x0cc00000, 0x00000000, 0x0680400f,
+	0x0c7ffb00, 0x0680000b, 0x0cc00000, 0x00000000, 0x0680400f,
 	0x0780704e, 0x06800008, 0x06800007, 0x07807186, 0x078072c0,
 	0x0a225800, 0x07c07087, 0x05403c46, 0x02031c4f, 0x07000c70,
 	0x09005c30, 0x06800041, 0x03401c01, 0x07c07081, 0x05403c48,
@@ -128,8 +129,8 @@ static const u32 MicroCode[] __initconst = {
 	0x094021c0, 0x07807200, 0x04401000, 0x07c07200, 0x04401046,
 	0x07000040, 0x09005000, 0x06800041, 0x03401001, 0x07807080,
 	0x03000040, 0x07c07080, 0x06810000, 0x0bc04007, 0x078071c0,
-	0x04401000, 0x07c071c0, 0x0649cf00, 0x0be14080, 0x07400187,
-	0x0be0d000, 0x04001208, 0x0b8ce248, 0x0cc00000, 0x00000000,
+	0x04401000, 0x07c071c0, 0x0649cf00, 0x0be14080, 0x0cc00000,
+	0x07400187, 0x04001208, 0x0b8ce248, 0x0cc00000, 0x00000000,
 	0x07807108, 0x07807149, 0x0680a00a, 0x0a403209, 0x0cc00000,
 	0x00000000, 0x05402108, 0x0200410a, 0x04002c44, 0x07000c40,
 	0x04001c71, 0x07000c41, 0x09610001, 0x0a42a380, 0x07000105,
@@ -172,36 +173,35 @@ static const u32 MicroCode[] __initconst = {
 	0x03401001, 0x07807080, 0x03000040, 0x07c07080, 0x06810000,
 	0x0bc04007, 0x078071c0, 0x04401000, 0x07c071c0, 0x07400187,
 	0x04001208, 0x0b8dc248, 0x0cc00000, 0x00000000, 0x06800010,
-	0x078020b1, 0x0a62c0b1, 0x07800b71, 0x0aa0c0b1, 0x07800bb1,
-	0x0aa1c031, 0x0c07aa80, 0x07c00b90, 0x07c00b50, 0x07c01e50,
-	0x0c07a300, 0x00000000, 0x0649cf31, 0x0be100b1, 0x078072f1,
-	0x09005031, 0x0a638140, 0x06800011, 0x0c07a780, 0x00000000,
-	0x0780e100, 0x0be18080, 0x09001400, 0x0c079fc0, 0x00000000,
-	0x0c781800, 0x00000000, 0x0c07aec0, 0x00000000, 0x0c781700,
-	0x06800000, 0x090a2071, 0x0780e130, 0x0a858001, 0x0a857030,
-	0x0680e10f, 0x070003c0, 0x0aa2c040, 0x0aa3c080, 0x0aa4c0c0,
-	0x0aa68100, 0x00000000, 0x04605040, 0x0c500740, 0x00000000,
-	0x04606040, 0x0c5010c0, 0x0c781280, 0x04001c4f, 0x0c07ae80,
-	0x07000c4e, 0x0c7ffc40, 0x040023cf, 0x04001c4f, 0x0c07be00,
-	0x07000c4e, 0x0c7ffb00, 0x040023cf, 0x04002c4f, 0x0c07cb80,
-	0x07000c4e, 0x04001c4f, 0x0c07d780, 0x07000c4d, 0x0c7ff900,
-	0x040033cf, 0x04001c4f, 0x07000c4e, 0x0c07e200, 0x00000000,
-	0x0c7ff780, 0x040023cf, 0x0c079a00, 0x00000000, 0x0c079300,
-	0x00000000, 0x06800007, 0x07807331, 0x0b250071, 0x07807770,
-	0x07807780, 0x09610c00, 0x07807841, 0x07807880, 0x09610040,
-	0x02401c01, 0x07c07841, 0x05810001, 0x07c07880, 0x078077c1,
-	0x07807800, 0x09610040, 0x02401c01, 0x07c077c1, 0x05810001,
-	0x07c07800, 0x0c7801c0, 0x07c07441, 0x07c07447, 0x07c077c7,
-	0x07c07807, 0x07c07847, 0x07c07887, 0x07c07347, 0x07c07487,
-	0x07c07647, 0x07c07687, 0x07c076c7, 0x07c07707, 0x07c07747,
-	0x07c07787, 0x0c7fed40, 0x040013cf, 0x04001c4f, 0x07000c4e,
-	0x0c07bd80, 0x00000000, 0x06800050, 0x0400044e, 0x0c7feb40,
-	0x040023cf, 0x0680400f, 0x0780718e, 0x0540338e, 0x0200e38f,
-	0x04001c4e, 0x07000c40, 0x0a2140c0, 0x0c071d80, 0x07c031d0,
-	0x0cc00000, 0x00000000, 0x078072f1, 0x09005031, 0x090a2071,
-	0x0aa10140, 0x0aa0c001, 0x0c074580, 0x00000000, 0x0649cf00,
-	0x0a219000, 0x0c071a40, 0x07c031d0, 0x0c0774c0, 0x00000000,
-	0x0c780140, 0x0c077400, 0x00000000, 0x0c071880, 0x07c031d0,
-	0x0cc00000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x078020b1, 0x0a6280b1, 0x07800b71, 0x0aa0c0b1, 0x07800bb1,
+	0x0aa18031, 0x0c07aa80, 0x07c00b90, 0x07c00b50, 0x0c07a380,
+	0x00000000, 0x0649cf31, 0x0be100b1, 0x078072f1, 0x09005031,
+	0x0a634140, 0x06800011, 0x0c07a7c0, 0x00000000, 0x0780e100,
+	0x0be14080, 0x09001400, 0x0c07a040, 0x00000000, 0x0c7817c0,
+	0x0c07af40, 0x00000000, 0x0c781700, 0x06800000, 0x090a2071,
+	0x0780e130, 0x0a858001, 0x0a857030, 0x0680e10f, 0x070003c0,
+	0x0aa2c040, 0x0aa3c080, 0x0aa4c0c0, 0x0aa68100, 0x00000000,
+	0x04605040, 0x0c500740, 0x00000000, 0x04606040, 0x0c5010c0,
+	0x0c781280, 0x04001c4f, 0x0c07af00, 0x07000c4e, 0x0c7ffc40,
+	0x040023cf, 0x04001c4f, 0x0c07be80, 0x07000c4e, 0x0c7ffb00,
+	0x040023cf, 0x04002c4f, 0x0c07cc00, 0x07000c4e, 0x04001c4f,
+	0x0c07d800, 0x07000c4d, 0x0c7ff900, 0x040033cf, 0x04001c4f,
+	0x07000c4e, 0x0c07e280, 0x00000000, 0x0c7ff780, 0x040023cf,
+	0x0c079a80, 0x00000000, 0x0c0793c0, 0x00000000, 0x06800007,
+	0x07807331, 0x0b250071, 0x07807770, 0x07807780, 0x09610c00,
+	0x07807841, 0x07807880, 0x09610040, 0x02401c01, 0x07c07841,
+	0x05810001, 0x07c07880, 0x078077c1, 0x07807800, 0x09610040,
+	0x02401c01, 0x07c077c1, 0x05810001, 0x07c07800, 0x0c7801c0,
+	0x07c07441, 0x07c07447, 0x07c077c7, 0x07c07807, 0x07c07847,
+	0x07c07887, 0x07c07347, 0x07c07487, 0x07c07647, 0x07c07687,
+	0x07c076c7, 0x07c07707, 0x07c07747, 0x07c07787, 0x0c7fed40,
+	0x040013cf, 0x04001c4f, 0x07000c4e, 0x0c07be00, 0x00000000,
+	0x06800050, 0x0400044e, 0x0c7feb40, 0x040023cf, 0x0680400f,
+	0x0780718e, 0x0540338e, 0x0200e38f, 0x04001c4e, 0x07000c40,
+	0x0a2100c0, 0x0c071a40, 0x07c031d0, 0x0cc00000, 0x078072f1,
+	0x09005031, 0x090a2071, 0x0aa10140, 0x0aa0c001, 0x0c074240,
+	0x00000000, 0x0649cf00, 0x0a219000, 0x0c071740, 0x07c031d0,
+	0x0c077540, 0x00000000, 0x0c780140, 0x0c077480, 0x00000000,
+	0x0c071580, 0x07c031d0, 0x0cc00000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000
 };
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264slice_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264slice_linux.h
index 7c936f3..ab44e82 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxm_h264slice_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxm_h264slice_linux.h
@@ -11,8 +11,8 @@ static const u32 MicroCode[] __initconst = {
 	0x06800000, 0x07c0e100, 0x07c07540, 0x07c07580, 0x07c075c0,
 	0x07c07600, 0x078074b1, 0x04001c71, 0x078020c0, 0x06800041,
 	0x0340f001, 0x044013cf, 0x028313f1, 0x0a834ab1, 0x07c07371,
-	0x07802140, 0x0a60c000, 0x0c780100, 0x07c074b1, 0x0c00a780,
-	0x00000000, 0x068000f3, 0x0c008880, 0x07c02bf3, 0x07807187,
+	0x07802140, 0x0a60c000, 0x0c780100, 0x07c074b1, 0x0c00a480,
+	0x00000000, 0x068000f3, 0x0c008640, 0x07c02bf3, 0x07807187,
 	0x07807048, 0x0a403207, 0x0c7e0200, 0x00000000, 0x06800033,
 	0x07c02bf3, 0x068002c0, 0x06031e00, 0x00000000, 0x06431e00,
 	0x0befc040, 0x00000000, 0x0649cf00, 0x0a20d000, 0x06800340,
@@ -23,14 +23,14 @@ static const u32 MicroCode[] __initconst = {
 	0x06431e00, 0x0bee8040, 0x00000000, 0x0c7ff1c0, 0x00000000,
 	0x07c0736a, 0x07c072eb, 0x07c0732c, 0x07c0e12d, 0x07c0756e,
 	0x0581002e, 0x07c07580, 0x07c075ef, 0x0581002f, 0x07c07600,
-	0x0c009980, 0x00000000, 0x080c3000, 0x07807748, 0x07807789,
+	0x0c009680, 0x00000000, 0x080c3000, 0x07807748, 0x07807789,
 	0x09610209, 0x060c3208, 0x078077c8, 0x07807809, 0x09610209,
 	0x060c3208, 0x07807848, 0x07807889, 0x09610209, 0x060c3208,
-	0x06800073, 0x0c007740, 0x07c02bf3, 0x07807187, 0x07807048,
+	0x06800073, 0x0c007500, 0x07c02bf3, 0x07807187, 0x07807048,
 	0x0a403207, 0x0c7df0c0, 0x00000000, 0x06800033, 0x07c02bf3,
-	0x0aa1000a, 0x00000000, 0x0c780900, 0x00000000, 0x0c07aac0,
+	0x0aa1000a, 0x00000000, 0x0c780900, 0x00000000, 0x0c07a9c0,
 	0x00000000, 0x07800c48, 0x0aa1c008, 0x07800bc8, 0x07800c09,
-	0x09610209, 0x06800009, 0x0c780100, 0x07c00c49, 0x0c062580,
+	0x09610209, 0x06800009, 0x0c780100, 0x07c00c49, 0x0c062500,
 	0x00000000, 0x0649cf09, 0x0be29009, 0x07800cc9, 0x0a620009,
 	0x06800049, 0x07c00cc9, 0x0809c009, 0x0609c108, 0x08007401,
 	0x0649c009, 0x0a6fc009, 0x07c03088, 0x05810208, 0x07c030c8,
@@ -39,134 +39,131 @@ static const u32 MicroCode[] __initconst = {
 	0x07c030c9, 0x054181c7, 0x0609b307, 0x068c000a, 0x0c060740,
 	0x06c0000a, 0x0649b307, 0x054081c7, 0x058081c7, 0x0609b207,
 	0x0609b007, 0x0609b107, 0x06800007, 0x07c01c47, 0x078072c7,
-	0x0be09807, 0x0c780840, 0x06bfffc9, 0x06803008, 0x07802307,
-	0x090211c7, 0x054011c7, 0x038081c8, 0x07807307, 0x0a60c087,
-	0x06800007, 0x06800047, 0x038081c8, 0x07803c07, 0x06031f07,
-	0x06033f08, 0x0c05d080, 0x08031e15, 0x078079c9, 0x07807a0a,
-	0x0961024a, 0x06431f07, 0x02009247, 0x078078c7, 0x07807908,
-	0x096101c8, 0x0b8071c9, 0x07807947, 0x07807988, 0x096101c8,
-	0x0b4031c9, 0x0c7800c0, 0x00000000, 0x06bfffc9, 0x064c3d08,
-	0x09161208, 0x0a6f8008, 0x00000000, 0x060c3809, 0x07802207,
-	0x0aa10007, 0x00000000, 0x0c062040, 0x080c2301, 0x07803ac7,
-	0x07c073c7, 0x07803b07, 0x07c07407, 0x07802087, 0x0aa10187,
-	0x06800148, 0x0a83c207, 0x0c781700, 0x00000000, 0x0fc011c0,
-	0x06800808, 0x096e1207, 0x078073c7, 0x09505207, 0x0fc011c0,
-	0x0aa24007, 0x07807407, 0x0c061b40, 0x080c2301, 0x07c073c7,
-	0x09505207, 0x0c061a40, 0x080c2301, 0x07c07407, 0x09605207,
+	0x0a279807, 0x06bfffc9, 0x06803008, 0x07802307, 0x090211c7,
+	0x054011c7, 0x038081c8, 0x07807307, 0x0a60c087, 0x06800007,
+	0x06800047, 0x038081c8, 0x07803c07, 0x0e000207, 0x078079c9,
+	0x07807a0a, 0x0961024a, 0x0f0001c0, 0x02009247, 0x078078c7,
+	0x07807908, 0x096101c8, 0x0b8071c9, 0x07807947, 0x07807988,
+	0x096101c8, 0x0b4031c9, 0x0c7800c0, 0x00000000, 0x06bfffc9,
+	0x064c3d08, 0x09161208, 0x0a6f8008, 0x00000000, 0x060c3809,
+	0x07802207, 0x0aa10007, 0x00000000, 0x0c0620c0, 0x080c2301,
+	0x07803ac7, 0x07c073c7, 0x07803b07, 0x07c07407, 0x07802087,
+	0x0aa10187, 0x06800148, 0x0a83c207, 0x0c781700, 0x00000000,
+	0x0fc011c0, 0x06800808, 0x096e1207, 0x078073c7, 0x09505207,
+	0x0fc011c0, 0x0aa24007, 0x07807407, 0x0c061bc0, 0x080c2301,
+	0x07c073c7, 0x09505207, 0x0c061ac0, 0x080c2301, 0x07c07407,
+	0x09605207, 0x07802947, 0x096a2207, 0x060c2108, 0x068000c7,
+	0x07c0c007, 0x0fc011c0, 0x0aa10007, 0x00000000, 0x0c06a5c0,
+	0x0680c009, 0x068000c7, 0x07c0d087, 0x0fc011c0, 0x0aa10007,
+	0x00000000, 0x0c06a400, 0x0680d089, 0x07802907, 0x0a60c087,
+	0x06800008, 0x06815408, 0x09402207, 0x0a644047, 0x06094208,
+	0x0c0613c0, 0x080c2301, 0x09484207, 0x0c061300, 0x080c2301,
+	0x09504207, 0x06094208, 0x0680c007, 0x06094007, 0x0c06a5c0,
+	0x078073c9, 0x0680d807, 0x06094007, 0x0c06a4c0, 0x07807409,
+	0x0c7808c0, 0x00000000, 0x0fc011c0, 0x06800808, 0x0aa14007,
+	0x078073c7, 0x0c060e80, 0x080c2301, 0x07c073c7, 0x09505207,
 	0x07802947, 0x096a2207, 0x060c2108, 0x068000c7, 0x07c0c007,
-	0x0fc011c0, 0x0aa10007, 0x00000000, 0x0c06a5c0, 0x0680c009,
-	0x068000c7, 0x07c0d087, 0x0fc011c0, 0x0aa10007, 0x00000000,
-	0x0c06a400, 0x0680d089, 0x07802907, 0x0a60c087, 0x06800008,
-	0x06815408, 0x09402207, 0x0a644047, 0x06094208, 0x0c061340,
-	0x080c2301, 0x09484207, 0x0c061280, 0x080c2301, 0x09504207,
-	0x06094208, 0x0680c007, 0x06094007, 0x0c06a5c0, 0x078073c9,
-	0x0680d807, 0x06094007, 0x0c06a4c0, 0x07807409, 0x0c7808c0,
-	0x00000000, 0x0fc011c0, 0x06800808, 0x0aa14007, 0x078073c7,
-	0x0c060e00, 0x080c2301, 0x07c073c7, 0x09505207, 0x07802947,
-	0x096a2207, 0x060c2108, 0x068000c7, 0x07c0c007, 0x0fc011c0,
-	0x0aa10007, 0x00000000, 0x0c069980, 0x0680c009, 0x078028c7,
-	0x04000207, 0x0aa34007, 0x06094208, 0x0c060980, 0x080c2301,
-	0x09484207, 0x0c0608c0, 0x080c2301, 0x09504207, 0x06094208,
-	0x0680c007, 0x06094007, 0x0c069c00, 0x078073c9, 0x06494007,
-	0x09c07247, 0x06094007, 0x07802047, 0x0aa7c007, 0x07802007,
-	0x06800148, 0x0a82a207, 0x00000000, 0x06800007, 0x07c0e107,
-	0x0fc011c0, 0x0aa5c007, 0x0680e109, 0x04000289, 0x02407289,
-	0x0b610a47, 0x06800007, 0x0c060240, 0x080c2301, 0x0aa3c007,
-	0x07400247, 0x0aae4147, 0x04001249, 0x04000207, 0x0c060080,
-	0x080c2301, 0x07400247, 0x0a6cc0c8, 0x04001249, 0x0c05ff40,
-	0x080c2301, 0x07400247, 0x0c7ffb80, 0x04001249, 0x0649cf07,
-	0x0a20c0c7, 0x06800007, 0x07c0e107, 0x07802347, 0x0aa2c007,
-	0x07802087, 0x0aa24087, 0x06800c08, 0x0c05fbc0, 0x080c2301,
-	0x09402207, 0x0c780100, 0x060c2108, 0x0fc021c0, 0x07c0e107,
-	0x068004ca, 0x06031e0a, 0x0649ce09, 0x0aa10009, 0x00000000,
-	0x0809ce00, 0x08007401, 0x06431e09, 0x0bee8049, 0x00000000,
-	0x07801e87, 0x0a608047, 0x0c782a40, 0x0680a009, 0x0680400a,
-	0x0680ec08, 0x080c2400, 0x0c069f00, 0x078070cc, 0x080c2400,
-	0x0680000b, 0x0780724c, 0x078073cd, 0x0400134d, 0x0b80334c,
-	0x00000000, 0x0400030d, 0x0200d2c8, 0x0700034d, 0x0540234d,
-	0x0200d349, 0x0700034e, 0x05408410, 0x02010390, 0x054033ce,
-	0x0200f3ca, 0x070003cf, 0x091013cf, 0x0aa0c00f, 0x0680004f,
-	0x07c01e4f, 0x0400134d, 0x0700034d, 0x0900234d, 0x094a240d,
-	0x040013cb, 0x0be0c0cf, 0x00000000, 0x060c2210, 0x0a60c00b,
-	0x00000000, 0x07c01990, 0x040012cb, 0x0b8e630b, 0x0a2240cc,
-	0x090022cc, 0x0680010c, 0x0240c2cc, 0x090082d0, 0x05408410,
-	0x0d07ffcc, 0x0940840b, 0x060c2210, 0x07802087, 0x06800188,
-	0x0a802207, 0x0c781cc0, 0x0680f608, 0x080c2408, 0x0c069200,
+	0x0fc011c0, 0x0aa10007, 0x00000000, 0x0c069980, 0x0680c009,
+	0x078028c7, 0x04000207, 0x0aa34007, 0x06094208, 0x0c060a00,
+	0x080c2301, 0x09484207, 0x0c060940, 0x080c2301, 0x09504207,
+	0x06094208, 0x0680c007, 0x06094007, 0x0c069c00, 0x078073c9,
+	0x06494007, 0x09c07247, 0x06094007, 0x07802047, 0x0aa7c007,
+	0x07802007, 0x06800148, 0x0a82a207, 0x00000000, 0x06800007,
+	0x07c0e107, 0x0fc011c0, 0x0aa5c007, 0x0680e109, 0x04000289,
+	0x02407289, 0x0b610a47, 0x06800007, 0x0c0602c0, 0x080c2301,
+	0x0aa3c007, 0x07400247, 0x0aae4147, 0x04001249, 0x04000207,
+	0x0c060100, 0x080c2301, 0x07400247, 0x0a6cc0c8, 0x04001249,
+	0x0c05ffc0, 0x080c2301, 0x07400247, 0x0c7ffb80, 0x04001249,
+	0x0649cf07, 0x0a20c0c7, 0x06800007, 0x07c0e107, 0x07802347,
+	0x0aa2c007, 0x07802087, 0x0aa24087, 0x06800c08, 0x0c05fc40,
+	0x080c2301, 0x09402207, 0x0c780100, 0x060c2108, 0x0fc021c0,
+	0x07c0e107, 0x068004ca, 0x06031e0a, 0x0649ce09, 0x0aa10009,
+	0x00000000, 0x0809ce00, 0x08007401, 0x06431e09, 0x0bee8049,
+	0x00000000, 0x07801e87, 0x0a608047, 0x0c782900, 0x0680a009,
+	0x0680400a, 0x0680ec08, 0x080c2400, 0x0c069f00, 0x078070cc,
+	0x080c2400, 0x0680000b, 0x0780724c, 0x078073cd, 0x0400134d,
+	0x0b80334c, 0x00000000, 0x0400030d, 0x0200d2c8, 0x0700034d,
+	0x0540234d, 0x0200d349, 0x0700034e, 0x05408410, 0x02010390,
+	0x054033ce, 0x0200f3ca, 0x070003cf, 0x091013cf, 0x0aa0c00f,
+	0x0680004f, 0x07c01e4f, 0x0400134d, 0x0700034d, 0x0900234d,
+	0x094a240d, 0x040013cb, 0x0be0c0cf, 0x00000000, 0x060c2210,
+	0x0a60c00b, 0x00000000, 0x07c01990, 0x040012cb, 0x0b8e630b,
+	0x0a2240cc, 0x090022cc, 0x0680010c, 0x0240c2cc, 0x090082d0,
+	0x05408410, 0x0d07ffcc, 0x0940840b, 0x060c2210, 0x07802087,
+	0x06800188, 0x0a46f207, 0x0680f608, 0x080c2408, 0x0c069240,
 	0x0780728c, 0x080c2408, 0x0680000b, 0x0780740d, 0x0400134d,
 	0x0b80334c, 0x00000000, 0x0400030d, 0x0200d2c8, 0x0700034d,
 	0x0540234d, 0x0200d349, 0x0700034e, 0x05408410, 0x02010390,
 	0x0400134d, 0x0700034d, 0x0900234d, 0x054033ce, 0x0200f3ca,
 	0x070003cf, 0x091013cf, 0x0aa0c00f, 0x0680004f, 0x07c01e4f,
-	0x046002cb, 0x0c481140, 0x07803a47, 0x0540338e, 0x0200e38a,
-	0x0700038f, 0x090053cf, 0x06031f07, 0x06033f0f, 0x0c0589c0,
-	0x08031e15, 0x0780732b, 0x0a60c0ab, 0x0680002c, 0x0680006c,
-	0x06431f07, 0x07803c0f, 0x054013cf, 0x0380fb0f, 0x020073c7,
-	0x0680180f, 0x06031f07, 0x06033f0f, 0x0c058640, 0x08031e15,
-	0x06431f07, 0x06433f0f, 0x097081cf, 0x0780230f, 0x090213cf,
-	0x054013cf, 0x038073c7, 0x078078cf, 0x020073c7, 0x0780790f,
-	0x054103cf, 0x020073c7, 0x058031c7, 0x040013ce, 0x070003cf,
-	0x090c2a8f, 0x097c21ea, 0x0ba5c0ab, 0x040023ce, 0x070003ec,
-	0x040033ce, 0x070003ef, 0x09610b2f, 0x040043ce, 0x070003ed,
-	0x040053ce, 0x070003ef, 0x09610b6f, 0x0780776e, 0x078077af,
-	0x09610baf, 0x0b403b2e, 0x0242fb2e, 0x0242fbac, 0x0b403b6e,
-	0x0242cb6e, 0x0242cbad, 0x0b807b2f, 0x0c780180, 0x09807747,
-	0x044013cd, 0x0ba0c0aa, 0x097a11cf, 0x097a11eb, 0x060c3907,
-	0x094a240d, 0x040013cb, 0x0be0c0cf, 0x00000000, 0x060c2210,
-	0x040012cb, 0x0b8a330b, 0x0a2240cc, 0x090022cc, 0x0680010c,
-	0x0240c2cc, 0x090082d0, 0x05408410, 0x0d07ffcc, 0x0940840b,
-	0x060c2210, 0x0780208a, 0x0a60c08a, 0x0680000a, 0x07c01e4a,
-	0x068c000a, 0x06c0470a, 0x0680c009, 0x0c059e40, 0x06a0400b,
-	0x0c05ca80, 0x080c2301, 0x0c05cc00, 0x00000000, 0x0401a1c7,
-	0x07802248, 0x02007207, 0x07c02387, 0x07802287, 0x0aa40007,
-	0x06800009, 0x0c05c7c0, 0x080c2301, 0x0aa30047, 0x09402247,
-	0x0c05c6c0, 0x080c2301, 0x0c05c840, 0x00000000, 0x094c4247,
-	0x0c05c580, 0x080c2301, 0x0c05c700, 0x00000000, 0x09444247,
-	0x060c3109, 0x0c7f1c80, 0x00000000, 0x0c0666c0, 0x00000000,
-	0x0680400f, 0x0780704e, 0x0780734d, 0x0780730c, 0x078072c0,
-	0x090a1040, 0x090c1c00, 0x02c0bc01, 0x07807188, 0x0aa0c00c,
-	0x0aa3c04c, 0x0c780900, 0x05403c48, 0x020313f1, 0x04001c71,
-	0x07000c40, 0x09061040, 0x04005c71, 0x07000c70, 0x0be4c040,
-	0x0a248080, 0x0a4112c1, 0x0a410370, 0x0cc00000, 0x0680004a,
-	0x05403c48, 0x020313f1, 0x04001c71, 0x07000c40, 0x09041040,
-	0x04005c71, 0x07000c70, 0x0be18080, 0x0a214040, 0x0a4042c1,
-	0x0a403370, 0x0cc00000, 0x0680004a, 0x04803000, 0x0aa20000,
-	0x0aa1c0c0, 0x00000000, 0x04405c71, 0x07000c40, 0x09800000,
-	0x09800040, 0x07400c40, 0x06800008, 0x06830007, 0x05403c48,
-	0x020313f1, 0x04001c71, 0x07000c40, 0x0be180c0, 0x0bc051c0,
-	0x06800000, 0x07400c40, 0x0c780140, 0x07c07188, 0x04001208,
-	0x0b8f5388, 0x0c780d40, 0x07807780, 0x0580f000, 0x0a20c040,
-	0x06800001, 0x09801181, 0x07802000, 0x0a60c140, 0x04401c31,
-	0x09801141, 0x07801c40, 0x094e1040, 0x07400c01, 0x0aa7400b,
-	0x06801801, 0x07802300, 0x09021000, 0x05401000, 0x03801001,
-	0x07803cca, 0x0900828a, 0x0340a00a, 0x078078c5, 0x07807900,
-	0x09610140, 0x07803a40, 0x06031f00, 0x06033f01, 0x0c055680,
-	0x08031e15, 0x06800046, 0x07807087, 0x06431f04, 0x06800009,
-	0x03400246, 0x0bc0f1c0, 0x04401071, 0x07000070, 0x09405c09,
-	0x07400070, 0x02c07007, 0x07c07087, 0x0649c900, 0x09c007c0,
-	0x0609c900, 0x07c079c5, 0x05810145, 0x07c07a05, 0x0cc00000,
-	0x0680000a, 0x02005105, 0x04001249, 0x0b8ee289, 0x0649c900,
-	0x098007c0, 0x0609c900, 0x0cc00000, 0x07c0718e, 0x07802171,
-	0x04600031, 0x0c480b40, 0x07802180, 0x06800041, 0x0340f001,
-	0x0580138f, 0x078072c0, 0x09005000, 0x0a614140, 0x06800000,
-	0x07c07640, 0x07c07680, 0x07c07440, 0x0780764d, 0x07807680,
-	0x09610340, 0x0780734c, 0x0780744b, 0x078073b1, 0x0b4052f1,
-	0x02400c4b, 0x0b807380, 0x0c780180, 0x0200d3cd, 0x024002f1,
-	0x0b003380, 0x0c780080, 0x0240d3cd, 0x040002f1, 0x078072c0,
-	0x090a2000, 0x0aa14000, 0x0581000d, 0x07c0764d, 0x07c07680,
-	0x07c0744b, 0x07807331, 0x0b6100b1, 0x020052cd, 0x0c781d80,
-	0x04000185, 0x078074c0, 0x07807501, 0x09610001, 0x0c781c40,
-	0x02006005, 0x078020c0, 0x06800041, 0x0340f001, 0x078072c0,
-	0x09005000, 0x0a61c140, 0x06800000, 0x07c07480, 0x07c076c0,
-	0x07c07700, 0x07c07540, 0x07c07580, 0x0780748e, 0x078076cd,
-	0x07807700, 0x09610340, 0x0780734c, 0x0b40338c, 0x00000000,
-	0x0200d3cd, 0x04602031, 0x0c501200, 0x0780398b, 0x0460000b,
-	0x0c500a80, 0x0680000a, 0x06800009, 0x0200830d, 0x078072c0,
-	0x090a2000, 0x0a610000, 0x0aa0c008, 0x00000000, 0x04401208,
-	0x04000c4b, 0x06808030, 0x07000c00, 0x04001c30, 0x07000c01,
-	0x09610001, 0x04001c30, 0x0d07fef1, 0x02009009, 0x0a608008,
-	0x0c780580, 0x04401208, 0x06800007, 0x0b8052c8, 0x00000000,
-	0x040011c7, 0x0c7fff40, 0x024082c8, 0x06031f07, 0x06033f09,
-	0x0c0535c0, 0x08031e15, 0x04001c48, 0x06808030, 0x06431f0a,
+	0x046002cb, 0x0c481040, 0x07803a47, 0x0540338e, 0x0200e38a,
+	0x0700038f, 0x090053cf, 0x0e0003c7, 0x0780732b, 0x0a60c0ab,
+	0x0680002c, 0x0680006c, 0x0f0001c0, 0x07803c0f, 0x054013cf,
+	0x0380fb0f, 0x020073c7, 0x0680180f, 0x0e0003c7, 0x00000000,
+	0x00000000, 0x0f0001c0, 0x0f0103c0, 0x097081cf, 0x0780230f,
+	0x090213cf, 0x054013cf, 0x038073c7, 0x078078cf, 0x020073c7,
+	0x0780790f, 0x054103cf, 0x020073c7, 0x058031c7, 0x040013ce,
+	0x070003cf, 0x090c2a8f, 0x097c21ea, 0x0ba5c0ab, 0x040023ce,
+	0x070003ec, 0x040033ce, 0x070003ef, 0x09610b2f, 0x040043ce,
+	0x070003ed, 0x040053ce, 0x070003ef, 0x09610b6f, 0x0780776e,
+	0x078077af, 0x09610baf, 0x0b403b2e, 0x0242fb2e, 0x0242fbac,
+	0x0b403b6e, 0x0242cb6e, 0x0242cbad, 0x0b807b2f, 0x0c780180,
+	0x09807747, 0x044013cd, 0x0ba0c0aa, 0x097a11cf, 0x097a11eb,
+	0x060c3907, 0x094a240d, 0x040013cb, 0x0be0c0cf, 0x00000000,
+	0x060c2210, 0x040012cb, 0x0b8a730b, 0x0a2240cc, 0x090022cc,
+	0x0680010c, 0x0240c2cc, 0x090082d0, 0x05408410, 0x0d07ffcc,
+	0x0940840b, 0x060c2210, 0x07802e4a, 0x0a60c14a, 0x0680000a,
+	0x07c01e4a, 0x068c000a, 0x06c0470a, 0x0680c009, 0x0c05a080,
+	0x06a0400b, 0x0c05cc40, 0x080c2301, 0x0c05cdc0, 0x00000000,
+	0x0401a1c7, 0x07802248, 0x02007207, 0x07c02387, 0x07802287,
+	0x0aa40007, 0x06800009, 0x0c05c980, 0x080c2301, 0x0aa30047,
+	0x09402247, 0x0c05c880, 0x080c2301, 0x0c05ca00, 0x00000000,
+	0x094c4247, 0x0c05c740, 0x080c2301, 0x0c05c8c0, 0x00000000,
+	0x09444247, 0x060c3109, 0x0c7f1dc0, 0x00000000, 0x0c066800,
+	0x00000000, 0x0680400f, 0x0780704e, 0x0780734d, 0x0780730c,
+	0x078072c0, 0x090a1040, 0x090c1c00, 0x02c0bc01, 0x07807188,
+	0x0aa0c00c, 0x0aa3c04c, 0x0c780900, 0x05403c48, 0x020313f1,
+	0x04001c71, 0x07000c40, 0x09061040, 0x04005c71, 0x07000c70,
+	0x0be4c040, 0x0a248080, 0x0a4112c1, 0x0a410370, 0x0cc00000,
+	0x0680004a, 0x05403c48, 0x020313f1, 0x04001c71, 0x07000c40,
+	0x09041040, 0x04005c71, 0x07000c70, 0x0be18080, 0x0a214040,
+	0x0a4042c1, 0x0a403370, 0x0cc00000, 0x0680004a, 0x04803000,
+	0x0aa20000, 0x0aa1c0c0, 0x00000000, 0x04405c71, 0x07000c40,
+	0x09800000, 0x09800040, 0x07400c40, 0x06800008, 0x06830007,
+	0x05403c48, 0x020313f1, 0x04001c71, 0x07000c40, 0x0be180c0,
+	0x0bc051c0, 0x06800000, 0x07400c40, 0x0c780140, 0x07c07188,
+	0x04001208, 0x0b8f5388, 0x0c780c80, 0x07807780, 0x0580f000,
+	0x0a20c040, 0x06800001, 0x09801181, 0x07802000, 0x0a60c140,
+	0x04401c31, 0x09801141, 0x07801c40, 0x094e1040, 0x07400c01,
+	0x0aa6800b, 0x06801801, 0x07802300, 0x09021000, 0x05401000,
+	0x03801001, 0x07803cca, 0x0900828a, 0x0340a00a, 0x078078c5,
+	0x07807900, 0x09610140, 0x07803a40, 0x0e000040, 0x06800046,
+	0x07807087, 0x0f000100, 0x06800009, 0x03400246, 0x0bc0f1c0,
+	0x04401071, 0x07000070, 0x09405c09, 0x07400070, 0x02c07007,
+	0x07c07087, 0x0649c900, 0x09c007c0, 0x0609c900, 0x07c079c5,
+	0x05810145, 0x07c07a05, 0x0cc00000, 0x0680000a, 0x02005105,
+	0x04001249, 0x0b8ee289, 0x0649c900, 0x098007c0, 0x0609c900,
+	0x0cc00000, 0x07c0718e, 0x07802171, 0x04600031, 0x0c480b40,
+	0x07802180, 0x06800041, 0x0340f001, 0x0580138f, 0x078072c0,
+	0x09005000, 0x0a614140, 0x06800000, 0x07c07640, 0x07c07680,
+	0x07c07440, 0x0780764d, 0x07807680, 0x09610340, 0x0780734c,
+	0x0780744b, 0x078073b1, 0x0b4052f1, 0x02400c4b, 0x0b807380,
+	0x0c780180, 0x0200d3cd, 0x024002f1, 0x0b003380, 0x0c780080,
+	0x0240d3cd, 0x040002f1, 0x078072c0, 0x090a2000, 0x0aa14000,
+	0x0581000d, 0x07c0764d, 0x07c07680, 0x07c0744b, 0x07807331,
+	0x0b6100b1, 0x020052cd, 0x0c781cc0, 0x04000185, 0x078074c0,
+	0x07807501, 0x09610001, 0x0c781b80, 0x02006005, 0x078020c0,
+	0x06800041, 0x0340f001, 0x078072c0, 0x09005000, 0x0a61c140,
+	0x06800000, 0x07c07480, 0x07c076c0, 0x07c07700, 0x07c07540,
+	0x07c07580, 0x0780748e, 0x078076cd, 0x07807700, 0x09610340,
+	0x0780734c, 0x0b40338c, 0x00000000, 0x0200d3cd, 0x04602031,
+	0x0c501140, 0x0780398b, 0x0460000b, 0x0c5009c0, 0x0680000a,
+	0x06800009, 0x0200830d, 0x078072c0, 0x090a2000, 0x0a610000,
+	0x0aa0c008, 0x00000000, 0x04401208, 0x04000c4b, 0x06808030,
+	0x07000c00, 0x04001c30, 0x07000c01, 0x09610001, 0x04001c30,
+	0x0d07fef1, 0x02009009, 0x0a608008, 0x0c7804c0, 0x04401208,
+	0x06800007, 0x0b8052c8, 0x00000000, 0x040011c7, 0x0c7fff40,
+	0x024082c8, 0x0e000247, 0x04001c48, 0x06808030, 0x0f000280,
 	0x07000c00, 0x04001c30, 0x07000c01, 0x09610001, 0x04001c30,
 	0x0d07fef1, 0x0200a00a, 0x078072c0, 0x090a2000, 0x0a614000,
 	0x07803800, 0x07803841, 0x09610001, 0x0200a00a, 0x07807545,
@@ -203,5 +200,8 @@ static const u32 MicroCode[] __initconst = {
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000
 };
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264c_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264c_linux.h
index 94dc746..a8f87cd 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264c_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264c_linux.h
@@ -1,14 +1,14 @@
 static const u32 MicroCode[] __initconst = {
 	0x06810001, 0x06800000, 0x0d000001, 0x07400040, 0x064c0800,
-	0x09800300, 0x00000000, 0x060c0800, 0x0649d019, 0x0c006140,
+	0x09800300, 0x00000000, 0x060c0800, 0x0649d019, 0x0c0060c0,
 	0x0649c134, 0x06880000, 0x060c2900, 0x080c0002, 0x06bfda80,
-	0x07c02d40, 0x06030400, 0x00400000, 0x0c007b80, 0x00000000,
+	0x07c02d40, 0x06030400, 0x00400000, 0x0c007a80, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0c7ffe80,
-	0x00000000, 0x06431e35, 0x0befc075, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x0c780500, 0x00000000, 0x0cc00000,
 	0x00400000, 0x0c780d40, 0x064c0007, 0x0cc00000, 0x00400000,
-	0x0c787bc0, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
-	0x00400000, 0x0c787a40, 0x00000000, 0x0c787800, 0x00000000,
+	0x0c787ac0, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c787940, 0x00000000, 0x0c787700, 0x00000000,
 	0x0cc00000, 0x00400000, 0x0aa44133, 0x0aa0c033, 0x0c7fff00,
 	0x0680001b, 0x0649cf1c, 0x0bee405c, 0x064c431c, 0x0ae0ffdc,
 	0x0c7ffd80, 0x0680001b, 0x064c411c, 0x0968c71c, 0x0a40bc9c,
@@ -19,19 +19,19 @@ static const u32 MicroCode[] __initconst = {
 	0x00800000, 0x07802d49, 0x0c7ff6c0, 0x06030409, 0x06bf9b89,
 	0x06030409, 0x00400000, 0x064c4309, 0x05801249, 0x0baf9809,
 	0x00000000, 0x0a2c0047, 0x07802bc9, 0x0aa14009, 0x0a608049,
-	0x0c7a08c0, 0x0a6080c9, 0x0c79f700, 0x0a208807, 0x0c782680,
-	0x0be15007, 0x0a208207, 0x0c7845c0, 0x0cb8001a, 0x00000000,
+	0x0c7a08c0, 0x0a6080c9, 0x0c79f700, 0x0a208807, 0x0c782600,
+	0x0be15007, 0x0a208207, 0x0c784540, 0x0cb8001a, 0x00000000,
 	0x0c000280, 0x00000000, 0x06bfffca, 0x07903c08, 0x0a402288,
-	0x0c784580, 0x0be08207, 0x0c7ffdc0, 0x0c784300, 0x00000000,
+	0x0c784500, 0x0be08207, 0x0c7ffdc0, 0x0c784280, 0x00000000,
 	0x0649cd09, 0x04001249, 0x0609cd09, 0x0c000780, 0x064c380e,
 	0x064c0809, 0x064c090b, 0x0680040a, 0x063f000a, 0x0680000a,
 	0x063f000a, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x060c0809, 0x060c090b, 0x0688000a, 0x060c290a, 0x0c0005c0,
 	0x00000000, 0x0680000a, 0x060c0c0a, 0x06c0404a, 0x060c0d0a,
-	0x080c0101, 0x0684044a, 0x060c2e0a, 0x060c380e, 0x0c001780,
+	0x080c0101, 0x0684044a, 0x060c2e0a, 0x060c380e, 0x0c001700,
 	0x00000000, 0x0cc00000, 0x00000000, 0x0683ffc9, 0x0aa18009,
 	0x0649470a, 0x0910828a, 0x07802cc8, 0x0a4fc20a, 0x04401249,
-	0x0cc00000, 0x00000000, 0x0c00a400, 0x00000000, 0x06490b09,
+	0x0cc00000, 0x00000000, 0x0c00a300, 0x00000000, 0x06490b09,
 	0x09809009, 0x09809089, 0x06090b09, 0x09c09009, 0x09c09089,
 	0x06090b09, 0x08095007, 0x08095000, 0x0683ffc9, 0x06498f0a,
 	0x0aa0c009, 0x0a6f800a, 0x04401249, 0x064c3d0a, 0x0580a28a,
@@ -46,356 +46,356 @@ static const u32 MicroCode[] __initconst = {
 	0x0603410a, 0x06810009, 0x06034209, 0x06a3000b, 0x06c001cb,
 	0x0603400b, 0x0643400c, 0x0580f30c, 0x0bef804c, 0x06840008,
 	0x063f0008, 0x06800008, 0x063f0008, 0x08002a09, 0x08002b17,
-	0x06830008, 0x06032608, 0x08032261, 0x06800048, 0x06c00088,
-	0x06032108, 0x0cc00000, 0x00000000, 0x0680004a, 0x060e0c0a,
-	0x07c026ca, 0x07c0250a, 0x068003ca, 0x07c0280a, 0x06805c0a,
-	0x060c210a, 0x080c2170, 0x0680008a, 0x07c02a4a, 0x06800018,
-	0x0680000a, 0x0cc00000, 0x07c0248a, 0x0a25d007, 0x0680004a,
-	0x0c07e540, 0x07c01e4a, 0x064c000a, 0x09c0a18a, 0x0980a20a,
-	0x0980a00a, 0x060c000a, 0x064c2908, 0x09c08348, 0x09808208,
-	0x060c2908, 0x09808348, 0x09c08208, 0x060c2908, 0x064c080a,
-	0x0980a34a, 0x060c080a, 0x0c07e340, 0x00000000, 0x0c07f700,
-	0x00000000, 0x080c0600, 0x0fc081c0, 0x0649cf0a, 0x0a21500a,
-	0x0a611e47, 0x0be0c40a, 0x0c780dc0, 0x00000000, 0x090a2207,
-	0x07c02048, 0x0481f1c7, 0x07c02007, 0x0aa38147, 0x0aa34047,
-	0x0a60c187, 0x0c781040, 0x0681d70d, 0x0a60c1c7, 0x0c780f80,
-	0x0682000d, 0x0a60c207, 0x0c780ec0, 0x0682744d, 0x0a608247,
-	0x0c780740, 0x0c781400, 0x0c78f0c0, 0x00000000, 0x064c4408,
-	0x09101208, 0x0aaf8048, 0x064c5109, 0x064c460a, 0x07801a48,
-	0x05410208, 0x07801a0b, 0x020082c8, 0x0580a208, 0x06031f08,
-	0x06033f09, 0x0c07b640, 0x08031e15, 0x06431f08, 0x06433f09,
-	0x09708209, 0x0540a208, 0x02008288, 0x064c4309, 0x02408248,
-	0x064c4009, 0x02408248, 0x0cc00000, 0x0440a208, 0x0c07f9c0,
-	0x00000000, 0x07c00bc8, 0x05810208, 0x07c00c08, 0x06800048,
-	0x0c780b80, 0x07c00c48, 0x0c07f7c0, 0x00000000, 0x07800909,
-	0x0780094a, 0x0961024a, 0x0609c209, 0x0680a149, 0x02008248,
-	0x07c00908, 0x05810208, 0x07c00948, 0x07807188, 0x0609c108,
-	0x0809c00a, 0x08007401, 0x0649c008, 0x0a6fc008, 0x0c7806c0,
-	0x00000000, 0x07803bc8, 0x090821c8, 0x0aa18047, 0x06800047,
-	0x09482207, 0x0680000a, 0x0c07d7c0, 0x06c0000a, 0x0cb8000d,
-	0x07c03bc8, 0x064c2907, 0x0be14407, 0x064c2307, 0x0bef4047,
-	0x0cc00000, 0x064c2007, 0x0cc00000, 0x06800007, 0x040011c7,
-	0x06800008, 0x0a20c047, 0x058011c7, 0x024071c8, 0x0cc00000,
-	0x00000000, 0x064c0007, 0x0a2fc047, 0x00000000, 0x064c3a07,
-	0x090061c7, 0x0aaec647, 0x00000000, 0x080c0a01, 0x080c2800,
-	0x080c0002, 0x0c7fb100, 0x00000000, 0x0684000a, 0x0c07cfc0,
-	0x06c0000a, 0x069fffc2, 0x07c03b42, 0x07c03b82, 0x07c03c42,
-	0x07c00a02, 0x07c00a42, 0x07c00a82, 0x07c03c82, 0x07c01742,
-	0x07c017c2, 0x068003c2, 0x07c02fc2, 0x064c1e02, 0x09802702,
-	0x060c1e02, 0x0680c002, 0x06094002, 0x06803003, 0x06804002,
-	0x0d000003, 0x06094102, 0x06800002, 0x06094002, 0x0c0005c0,
-	0x00000000, 0x08002501, 0x08002609, 0x08002708, 0x0800290d,
-	0x08002d15, 0x08002c14, 0x0649b802, 0x06800fc3, 0x09508083,
-	0x0609b802, 0x08002609, 0x08002b17, 0x06830002, 0x06032602,
-	0x08032261, 0x06800042, 0x06c00082, 0x06032102, 0x06800032,
-	0x0cc00000, 0x0680001b, 0x06800203, 0x07c03bc3, 0x06800712,
-	0x06800033, 0x07c02bf3, 0x07c01933, 0x07c01973, 0x07c01df3,
-	0x07c01e33, 0x0649c203, 0x0a654003, 0x06800803, 0x068f000a,
-	0x06c0470a, 0x06810002, 0x06800049, 0x06a02bcb, 0x0c07bc00,
-	0x00000000, 0x0d07ff83, 0x0200a08a, 0x06804003, 0x06af000a,
-	0x06c0470a, 0x06808002, 0x06800049, 0x06a02bcb, 0x0c07b980,
-	0x00000000, 0x0d07ff83, 0x0200a08a, 0x064e1203, 0x091e10c3,
-	0x0bef8043, 0x064c0903, 0x06803002, 0x063f0002, 0x06800002,
-	0x063f0002, 0x06803fc2, 0x060c0903, 0x06800002, 0x060c0c02,
-	0x06c04042, 0x060c0d02, 0x080c0101, 0x06840442, 0x060c2e02,
-	0x06bfffc2, 0x07c00ac2, 0x064c4010, 0x064c4211, 0x02411411,
-	0x04008451, 0x07c01a11, 0x05810451, 0x07c01a51, 0x064c1e02,
-	0x09802702, 0x060c1e02, 0x064e0e02, 0x09802242, 0x060e0e02,
-	0x0cc00000, 0x00000000, 0x07802bc2, 0x0aa0c002, 0x06800102,
-	0x06030502, 0x0b60c11b, 0x0cc00000, 0x00000000, 0x00800000,
-	0x00000000, 0x0c079bc0, 0x00000000, 0x080c0a01, 0x080c2800,
-	0x080c0002, 0x0cc00000, 0x00400000, 0x064c441c, 0x0910171c,
-	0x0a6f801c, 0x0c7f87c0, 0x00000000, 0x0cc00000, 0x00400000,
-	0x064e1214, 0x091e1514, 0x0bef0054, 0x078029d5, 0x0649d914,
-	0x0900c514, 0x0acfe554, 0x07802494, 0x0aa50094, 0x0aa08194,
-	0x0c782d00, 0x0c7824c0, 0x07802715, 0x06800015, 0x06c04015,
-	0x07802857, 0x097c1557, 0x060e1215, 0x07802d15, 0x0a20c055,
-	0x06800018, 0x06900018, 0x06c046d8, 0x02018d18, 0x06800014,
-	0x07c02a94, 0x0c782540, 0x06800114, 0x07802a95, 0x0aa08095,
-	0x0c781340, 0x078024d6, 0x0aeb4096, 0x07802857, 0x0aa4c712,
-	0x07802ad4, 0x05406514, 0x07802d15, 0x05801555, 0x0be0c055,
-	0x06800015, 0x06900015, 0x06c046d5, 0x02015d15, 0x02014554,
-	0x04440514, 0x060e1314, 0x0aa44017, 0x040c0614, 0x06805c16,
-	0x060c2116, 0x0c780340, 0x04040618, 0x05405514, 0x07802d15,
+	0x06830008, 0x06032608, 0x08032261, 0x08032101, 0x0cc00000,
+	0x00000000, 0x0680004a, 0x060e0c0a, 0x07c026ca, 0x07c0250a,
+	0x068003ca, 0x07c0280a, 0x06805c0a, 0x060c210a, 0x080c2170,
+	0x0680008a, 0x07c02a4a, 0x06800018, 0x0680000a, 0x0cc00000,
+	0x07c0248a, 0x0a25d007, 0x0680004a, 0x0c07e5c0, 0x07c01e4a,
+	0x064c000a, 0x09c0a18a, 0x0980a20a, 0x0980a00a, 0x060c000a,
+	0x064c2908, 0x09c08348, 0x09808208, 0x060c2908, 0x09808348,
+	0x09c08208, 0x060c2908, 0x064c080a, 0x0980a34a, 0x060c080a,
+	0x0c07e3c0, 0x00000000, 0x0c07f700, 0x00000000, 0x080c0600,
+	0x0fc081c0, 0x0649cf0a, 0x0a21500a, 0x0a611e47, 0x0be0c40a,
+	0x0c780dc0, 0x00000000, 0x090a2207, 0x07c02048, 0x0481f1c7,
+	0x07c02007, 0x0aa38147, 0x0aa34047, 0x0a60c187, 0x0c781040,
+	0x0681d60d, 0x0a60c1c7, 0x0c780f80, 0x0682000d, 0x0a60c207,
+	0x0c780ec0, 0x0682724d, 0x0a608247, 0x0c780740, 0x0c781400,
+	0x0c78f040, 0x00000000, 0x064c4408, 0x09101208, 0x0aaf8048,
+	0x064c5109, 0x064c460a, 0x07801a48, 0x05410208, 0x07801a0b,
+	0x020082c8, 0x0580a208, 0x0e000248, 0x00000000, 0x00000000,
+	0x00000000, 0x0f000200, 0x0f010240, 0x09708209, 0x0540a208,
+	0x02008288, 0x064c4309, 0x02408248, 0x064c4009, 0x02408248,
+	0x0cc00000, 0x0440a208, 0x0c07f9c0, 0x00000000, 0x07c00bc8,
+	0x05810208, 0x07c00c08, 0x06800048, 0x0c780b80, 0x07c00c48,
+	0x0c07f7c0, 0x00000000, 0x07800909, 0x0780094a, 0x0961024a,
+	0x0609c209, 0x0680a149, 0x02008248, 0x07c00908, 0x05810208,
+	0x07c00948, 0x07807188, 0x0609c108, 0x0809c00a, 0x08007401,
+	0x0649c008, 0x0a6fc008, 0x0c7806c0, 0x00000000, 0x07803bc8,
+	0x090821c8, 0x0aa18047, 0x06800047, 0x09482207, 0x0680000a,
+	0x0c07d840, 0x06c0000a, 0x0cb8000d, 0x07c03bc8, 0x064c2907,
+	0x0be14407, 0x064c2307, 0x0bef4047, 0x0cc00000, 0x064c2007,
+	0x0cc00000, 0x06800007, 0x040011c7, 0x06800008, 0x0a20c047,
+	0x058011c7, 0x024071c8, 0x0cc00000, 0x00000000, 0x064c0007,
+	0x0a2fc047, 0x00000000, 0x064c3a07, 0x090061c7, 0x0aaec647,
+	0x00000000, 0x080c0a01, 0x080c2800, 0x080c0002, 0x0c7fb180,
+	0x00000000, 0x0684000a, 0x0c07d040, 0x06c0000a, 0x069fffc2,
+	0x07c03b42, 0x07c03b82, 0x07c03c42, 0x07c00a02, 0x07c00a42,
+	0x07c00a82, 0x07c03c82, 0x07c01742, 0x07c017c2, 0x068003c2,
+	0x07c02fc2, 0x064c1e02, 0x09802702, 0x060c1e02, 0x0680c002,
+	0x06094002, 0x06803003, 0x06804002, 0x0d000003, 0x06094102,
+	0x06800002, 0x06094002, 0x0c000540, 0x00000000, 0x08002501,
+	0x08002609, 0x08002708, 0x0800290d, 0x08002d15, 0x08002c14,
+	0x0649b802, 0x06800fc3, 0x09508083, 0x0609b802, 0x08002609,
+	0x08002b17, 0x06830002, 0x06032602, 0x08032261, 0x08032101,
+	0x06800032, 0x0cc00000, 0x0680001b, 0x06800203, 0x07c03bc3,
+	0x06800712, 0x06800033, 0x07c02bf3, 0x07c01933, 0x07c01973,
+	0x07c01df3, 0x07c01e33, 0x0649c203, 0x0a654003, 0x06800803,
+	0x068f000a, 0x06c0470a, 0x06810002, 0x06800049, 0x06a02bcb,
+	0x0c07bd00, 0x00000000, 0x0d07ff83, 0x0200a08a, 0x06804003,
+	0x06af000a, 0x06c0470a, 0x06808002, 0x06800049, 0x06a02bcb,
+	0x0c07ba80, 0x00000000, 0x0d07ff83, 0x0200a08a, 0x064e1203,
+	0x091e10c3, 0x0bef8043, 0x064c0903, 0x06803002, 0x063f0002,
+	0x06800002, 0x063f0002, 0x06803fc2, 0x060c0903, 0x06800002,
+	0x060c0c02, 0x06c04042, 0x060c0d02, 0x080c0101, 0x06840442,
+	0x060c2e02, 0x06bfffc2, 0x07c00ac2, 0x064c4010, 0x064c4211,
+	0x02411411, 0x04008451, 0x07c01a11, 0x05810451, 0x07c01a51,
+	0x064c1e02, 0x09802702, 0x060c1e02, 0x064e0e02, 0x09802242,
+	0x060e0e02, 0x0cc00000, 0x00000000, 0x07802bc2, 0x0aa0c002,
+	0x06800102, 0x06030502, 0x0b60c11b, 0x0cc00000, 0x00000000,
+	0x00800000, 0x00000000, 0x0c079cc0, 0x00000000, 0x080c0a01,
+	0x080c2800, 0x080c0002, 0x0cc00000, 0x00400000, 0x064c441c,
+	0x0910171c, 0x0a6f801c, 0x0c7f88c0, 0x00000000, 0x0cc00000,
+	0x00400000, 0x064e1214, 0x091e1514, 0x0bef0054, 0x078029d5,
+	0x0649d914, 0x0900c514, 0x0acfe554, 0x07802494, 0x0aa50094,
+	0x0aa08194, 0x0c782d00, 0x0c7824c0, 0x07802715, 0x06800015,
+	0x06c04015, 0x07802857, 0x097c1557, 0x060e1215, 0x07802d15,
+	0x0a20c055, 0x06800018, 0x06900018, 0x06c046d8, 0x02018d18,
+	0x06800014, 0x07c02a94, 0x0c782540, 0x06800114, 0x07802a95,
+	0x0aa08095, 0x0c781340, 0x078024d6, 0x0aeb4096, 0x07802857,
+	0x0aa4c712, 0x07802ad4, 0x05406514, 0x07802d15, 0x05801555,
 	0x0be0c055, 0x06800015, 0x06900015, 0x06c046d5, 0x02015d15,
-	0x02014554, 0x04420514, 0x060e1314, 0x04060614, 0x07802596,
-	0x0aa14016, 0x06a2c215, 0x0aa0c056, 0x06a2c015, 0x06a2c115,
-	0x0aa10017, 0x06c04015, 0x068003d4, 0x09506554, 0x097c1557,
-	0x060e1215, 0x064e0e14, 0x098142d4, 0x060e0e14, 0x06800014,
-	0x07c02a94, 0x06800114, 0x0c781ec0, 0x07c02494, 0x078025d5,
-	0x078029d6, 0x0e000595, 0x05401516, 0x07802857, 0x0aa0c017,
-	0x02014594, 0x02014594, 0x0f000540, 0x02415515, 0x07802694,
-	0x05409514, 0x02014554, 0x05403554, 0x02015d15, 0x060e1315,
-	0x07802596, 0x0aa34016, 0x06a44215, 0x0aa2c056, 0x06a44015,
-	0x0c780240, 0x06a44115, 0x0a6580d5, 0x078026d4, 0x064e0c16,
-	0x09010596, 0x0b8e5594, 0x0cc00000, 0x00400000, 0x0aa10017,
-	0x06c0c015, 0x068005d4, 0x09506554, 0x097c1557, 0x060e1215,
-	0x064e0e14, 0x098142d4, 0x060e0e14, 0x06800018, 0x06800014,
-	0x07c02a94, 0x06800154, 0x0c781380, 0x07c02494, 0x07802515,
-	0x0aa1c015, 0x04401555, 0x07c02515, 0x078024d5, 0x04401555,
-	0x0c780f80, 0x07c024d5, 0x07802615, 0x078029d6, 0x0e000595,
-	0x07c02655, 0x04001515, 0x07c02614, 0x0f000540, 0x07802694,
-	0x05409514, 0x02014554, 0x05403554, 0x02015d15, 0x060e1315,
-	0x07802596, 0x0aa14016, 0x06b16215, 0x0aa0c056, 0x06b16015,
-	0x06b16115, 0x07803056, 0x0aa2c016, 0x078026d4, 0x064e0c16,
-	0x09010596, 0x0b805594, 0x07c02715, 0x06800194, 0x0c7fd680,
-	0x07c02494, 0x04001514, 0x07c026d4, 0x07c02715, 0x06c00015,
-	0x060e1215, 0x06800054, 0x0c780840, 0x07c02494, 0x0ba74114,
-	0x07802855, 0x0a608015, 0x0c7ff400, 0x078026d5, 0x04001555,
-	0x07c026d5, 0x0aa0c114, 0x06800015, 0x080c2170, 0x0c7804c0,
-	0x07c02855, 0x064e0e14, 0x09814314, 0x0cc00000, 0x060e0e14,
-	0x0a6c0054, 0x078024d5, 0x0a608015, 0x0c780900, 0x04401555,
-	0x0b2f8055, 0x07c024d5, 0x0c07fd40, 0x00000000, 0x07802a54,
-	0x0aa0c0d4, 0x00000000, 0x080c2170, 0x06800014, 0x07c02494,
-	0x0cc00000, 0x00400000, 0x091c1518, 0x0aa0c014, 0x06900018,
-	0x06800018, 0x06c046d8, 0x0c780bc0, 0x02018d18, 0x0aa0c712,
-	0x090a8518, 0x090c7518, 0x07802c56, 0x0b829594, 0x0a8f4594,
-	0x0f000540, 0x064e0e14, 0x098142d4, 0x060e0e14, 0x091c1518,
-	0x0aa28014, 0x06900018, 0x0c780200, 0x06800018, 0x078025d5,
-	0x078029d6, 0x0aa70018, 0x0e000595, 0x0c7ffb40, 0x00000000,
-	0x06c046d8, 0x02018d18, 0x07802694, 0x05409514, 0x078029d6,
-	0x02415595, 0x02014554, 0x05403554, 0x02015d15, 0x060e1315,
-	0x07802714, 0x09004554, 0x0aa14015, 0x06a14214, 0x0aa0c115,
-	0x06a14014, 0x06a14114, 0x06c08014, 0x060e0d18, 0x0aa0c712,
-	0x04020618, 0x04020618, 0x0c7ff300, 0x060e1214, 0x07802694,
-	0x05409514, 0x0f000540, 0x02014554, 0x078025d5, 0x04001555,
-	0x07c025d5, 0x05403554, 0x02015d15, 0x060e1315, 0x07802714,
-	0x0a618018, 0x09c141d4, 0x060e1214, 0x068000d4, 0x0c7feec0,
-	0x07c02494, 0x06c08014, 0x09c14394, 0x060e0d18, 0x0aae4712,
-	0x04020618, 0x0c7ffdc0, 0x04020618, 0x0683ffca, 0x0a61000a,
-	0x0440128a, 0x0c780140, 0x080e1200, 0x064e1209, 0x091e1249,
-	0x0bee8049, 0x064e0009, 0x064e030a, 0x064e0e0b, 0x064e0c0c,
-	0x083f0040, 0x083f0000, 0x064c180d, 0x0980d20d, 0x060c180d,
-	0x09c0d20d, 0x060c180d, 0x0680020d, 0x0d00000d, 0x00000000,
-	0x060e0009, 0x060e030a, 0x060e0e0b, 0x0cc00000, 0x060e0c0c,
-	0x0c000cc0, 0x00000000, 0x06810109, 0x06c34749, 0x06090709,
+	0x02014554, 0x04440514, 0x060e1314, 0x0aa44017, 0x040c0614,
+	0x06805c16, 0x060c2116, 0x0c780340, 0x04040618, 0x05405514,
+	0x07802d15, 0x0be0c055, 0x06800015, 0x06900015, 0x06c046d5,
+	0x02015d15, 0x02014554, 0x04420514, 0x060e1314, 0x04060614,
+	0x07802596, 0x0aa14016, 0x06a2c215, 0x0aa0c056, 0x06a2c015,
+	0x06a2c115, 0x0aa10017, 0x06c04015, 0x068003d4, 0x09506554,
+	0x097c1557, 0x060e1215, 0x064e0e14, 0x098142d4, 0x060e0e14,
+	0x06800014, 0x07c02a94, 0x06800114, 0x0c781ec0, 0x07c02494,
+	0x078025d5, 0x078029d6, 0x0e000595, 0x05401516, 0x07802857,
+	0x0aa0c017, 0x02014594, 0x02014594, 0x0f000540, 0x02415515,
+	0x07802694, 0x05409514, 0x02014554, 0x05403554, 0x02015d15,
+	0x060e1315, 0x07802596, 0x0aa34016, 0x06a44215, 0x0aa2c056,
+	0x06a44015, 0x0c780240, 0x06a44115, 0x0a6580d5, 0x078026d4,
+	0x064e0c16, 0x09010596, 0x0b8e5594, 0x0cc00000, 0x00400000,
+	0x0aa10017, 0x06c0c015, 0x068005d4, 0x09506554, 0x097c1557,
+	0x060e1215, 0x064e0e14, 0x098142d4, 0x060e0e14, 0x06800018,
+	0x06800014, 0x07c02a94, 0x06800154, 0x0c781380, 0x07c02494,
+	0x07802515, 0x0aa1c015, 0x04401555, 0x07c02515, 0x078024d5,
+	0x04401555, 0x0c780f80, 0x07c024d5, 0x07802615, 0x078029d6,
+	0x0e000595, 0x07c02655, 0x04001515, 0x07c02614, 0x0f000540,
+	0x07802694, 0x05409514, 0x02014554, 0x05403554, 0x02015d15,
+	0x060e1315, 0x07802596, 0x0aa14016, 0x06b16215, 0x0aa0c056,
+	0x06b16015, 0x06b16115, 0x07803056, 0x0aa2c016, 0x078026d4,
+	0x064e0c16, 0x09010596, 0x0b805594, 0x07c02715, 0x06800194,
+	0x0c7fd680, 0x07c02494, 0x04001514, 0x07c026d4, 0x07c02715,
+	0x06c00015, 0x060e1215, 0x06800054, 0x0c780840, 0x07c02494,
+	0x0ba74114, 0x07802855, 0x0a608015, 0x0c7ff400, 0x078026d5,
+	0x04001555, 0x07c026d5, 0x0aa0c114, 0x06800015, 0x080c2170,
+	0x0c7804c0, 0x07c02855, 0x064e0e14, 0x09814314, 0x0cc00000,
+	0x060e0e14, 0x0a6c0054, 0x078024d5, 0x0a608015, 0x0c780900,
+	0x04401555, 0x0b2f8055, 0x07c024d5, 0x0c07fd40, 0x00000000,
+	0x07802a54, 0x0aa0c0d4, 0x00000000, 0x080c2170, 0x06800014,
+	0x07c02494, 0x0cc00000, 0x00400000, 0x091c1518, 0x0aa0c014,
+	0x06900018, 0x06800018, 0x06c046d8, 0x0c780bc0, 0x02018d18,
+	0x0aa0c712, 0x090a8518, 0x090c7518, 0x07802c56, 0x0b829594,
+	0x0a8f4594, 0x0f000540, 0x064e0e14, 0x098142d4, 0x060e0e14,
+	0x091c1518, 0x0aa28014, 0x06900018, 0x0c780200, 0x06800018,
+	0x078025d5, 0x078029d6, 0x0aa70018, 0x0e000595, 0x0c7ffb40,
+	0x00000000, 0x06c046d8, 0x02018d18, 0x07802694, 0x05409514,
+	0x078029d6, 0x02415595, 0x02014554, 0x05403554, 0x02015d15,
+	0x060e1315, 0x07802714, 0x09004554, 0x0aa14015, 0x06a14214,
+	0x0aa0c115, 0x06a14014, 0x06a14114, 0x06c08014, 0x060e0d18,
+	0x0aa0c712, 0x04020618, 0x04020618, 0x0c7ff300, 0x060e1214,
+	0x07802694, 0x05409514, 0x0f000540, 0x02014554, 0x078025d5,
+	0x04001555, 0x07c025d5, 0x05403554, 0x02015d15, 0x060e1315,
+	0x07802714, 0x0a618018, 0x09c141d4, 0x060e1214, 0x068000d4,
+	0x0c7feec0, 0x07c02494, 0x06c08014, 0x09c14394, 0x060e0d18,
+	0x0aae4712, 0x04020618, 0x0c7ffdc0, 0x04020618, 0x0683ffca,
+	0x0a61000a, 0x0440128a, 0x0c780140, 0x080e1200, 0x064e1209,
+	0x091e1249, 0x0bee8049, 0x064e0009, 0x064e030a, 0x064e0e0b,
+	0x064e0c0c, 0x083f0040, 0x083f0000, 0x064c180d, 0x0980d20d,
+	0x060c180d, 0x09c0d20d, 0x060c180d, 0x0680020d, 0x0d00000d,
+	0x00000000, 0x060e0009, 0x060e030a, 0x060e0e0b, 0x0cc00000,
+	0x060e0c0c, 0x0c000cc0, 0x00000000, 0x06810109, 0x06c34749,
+	0x06090709, 0x06490b09, 0x09809009, 0x09809089, 0x06090b09,
+	0x09c09009, 0x09c09089, 0x06090b09, 0x06800009, 0x06c046c9,
+	0x02009d09, 0x06094409, 0x06900009, 0x06c046c9, 0x02009d09,
+	0x06094509, 0x0cc00000, 0x00000000, 0x0c000e00, 0x00000000,
+	0x06497f08, 0x068000c7, 0x09702207, 0x09808688, 0x06097f08,
+	0x06498e08, 0x09c080c8, 0x06098e08, 0x07802c47, 0x0b20c187,
+	0x00000000, 0x098080c8, 0x09c08788, 0x06098e08, 0x06820888,
+	0x06c00208, 0x068001c9, 0x07802c47, 0x0b20c407, 0x06800447,
+	0x06800c07, 0x09706207, 0x09808648, 0x06095108, 0x06095009,
+	0x0cc00000, 0x08095000, 0x0683ffc8, 0x06490909, 0x0a210049,
+	0x0aa0c008, 0x0c7fff40, 0x04401208, 0x0683ffc8, 0x06490909,
+	0x09343249, 0x0a2241c9, 0x0aa20008, 0x06490b09, 0x098090c9,
+	0x06090b09, 0x09c090c9, 0x06090b09, 0x0c7ffdc0, 0x04401208,
 	0x06490b09, 0x09809009, 0x09809089, 0x06090b09, 0x09c09009,
-	0x09c09089, 0x06090b09, 0x06800009, 0x06c046c9, 0x02009d09,
-	0x06094409, 0x06900009, 0x06c046c9, 0x02009d09, 0x06094509,
-	0x0cc00000, 0x00000000, 0x0c000e00, 0x00000000, 0x06497f08,
-	0x068000c7, 0x09702207, 0x09808688, 0x06097f08, 0x06498e08,
-	0x09c080c8, 0x06098e08, 0x07802c47, 0x0b20c187, 0x00000000,
-	0x098080c8, 0x09c08788, 0x06098e08, 0x06820888, 0x06c00208,
-	0x068001c9, 0x07802c47, 0x0b20c407, 0x06800447, 0x06800c07,
-	0x09706207, 0x09808648, 0x06095108, 0x06095009, 0x0cc00000,
-	0x08095000, 0x0683ffc8, 0x06490909, 0x0a210049, 0x0aa0c008,
-	0x0c7fff40, 0x04401208, 0x0683ffc8, 0x06490909, 0x09343249,
-	0x0a2241c9, 0x0aa20008, 0x06490b09, 0x098090c9, 0x06090b09,
-	0x09c090c9, 0x06090b09, 0x0c7ffdc0, 0x04401208, 0x06490b09,
-	0x09809009, 0x09809089, 0x06090b09, 0x09c09009, 0x09c09089,
-	0x06090b09, 0x0cc00000, 0x00000000, 0x0683ffc9, 0x0649bb08,
-	0x0920c208, 0x06495307, 0x090011c7, 0x020081c8, 0x0aa10008,
-	0x0aa0c009, 0x0c7ffe40, 0x04401249, 0x0cc00000, 0x00000000,
-	0x04000289, 0x02408289, 0x0b64a008, 0x00000000, 0x0c077200,
-	0x080c2301, 0x02408289, 0x0b60d008, 0x00000000, 0x07400247,
-	0x0aa280c7, 0x04001249, 0x0c077000, 0x080c2301, 0x02408289,
-	0x0b60d008, 0x00000000, 0x07400247, 0x0c7ffbc0, 0x04001249,
-	0x068000c7, 0x0404028a, 0x07400287, 0x0cc00000, 0x00000000,
-	0x0680000a, 0x04001249, 0x0fc011c0, 0x0aa20047, 0x0680004b,
-	0x06494207, 0x090841c7, 0x0340b1cb, 0x054082cb, 0x0c780340,
-	0x0609410b, 0x0c076a00, 0x080c2301, 0x0c076b80, 0x00000000,
-	0x040002c7, 0x0c0768c0, 0x080c2301, 0x0c076a40, 0x00000000,
-	0x095091cb, 0x06094107, 0x0fc011c0, 0x0aa24047, 0x0680004b,
-	0x06494207, 0x091041c7, 0x0340b1cb, 0x054082cb, 0x0609410b,
-	0x0c780600, 0x0609410b, 0x0c0764c0, 0x080c2301, 0x0c076640,
-	0x00000000, 0x040002c7, 0x0c076380, 0x080c2301, 0x0c076500,
-	0x00000000, 0x095091cb, 0x06094107, 0x0c076200, 0x080c2301,
-	0x0c076380, 0x00000000, 0x040002c7, 0x0c0760c0, 0x080c2301,
-	0x0c076240, 0x00000000, 0x095091cb, 0x06094107, 0x0400128a,
-	0x0b8cb24a, 0x0cc00000, 0x00000000, 0x0649c707, 0x0aa28007,
-	0x044011c7, 0x0809c700, 0x06804008, 0x054031c7, 0x02007207,
-	0x040011c7, 0x070001c8, 0x09c082c8, 0x074001c8, 0x0649c807,
-	0x0aa28007, 0x044011c7, 0x0809c800, 0x06804008, 0x054031c7,
+	0x09c09089, 0x06090b09, 0x0cc00000, 0x00000000, 0x0683ffc9,
+	0x0649bb08, 0x0920c208, 0x06495307, 0x090011c7, 0x020081c8,
+	0x0aa10008, 0x0aa0c009, 0x0c7ffe40, 0x04401249, 0x0cc00000,
+	0x00000000, 0x04000289, 0x02408289, 0x0b64a008, 0x00000000,
+	0x0c077280, 0x080c2301, 0x02408289, 0x0b60d008, 0x00000000,
+	0x07400247, 0x0aa280c7, 0x04001249, 0x0c077080, 0x080c2301,
+	0x02408289, 0x0b60d008, 0x00000000, 0x07400247, 0x0c7ffbc0,
+	0x04001249, 0x068000c7, 0x0404028a, 0x07400287, 0x0cc00000,
+	0x00000000, 0x0680000a, 0x04001249, 0x0fc011c0, 0x0aa20047,
+	0x0680004b, 0x06494207, 0x090841c7, 0x0340b1cb, 0x054082cb,
+	0x0c780340, 0x0609410b, 0x0c076a80, 0x080c2301, 0x0c076c00,
+	0x00000000, 0x040002c7, 0x0c076940, 0x080c2301, 0x0c076ac0,
+	0x00000000, 0x095091cb, 0x06094107, 0x0fc011c0, 0x0aa24047,
+	0x0680004b, 0x06494207, 0x091041c7, 0x0340b1cb, 0x054082cb,
+	0x0609410b, 0x0c780600, 0x0609410b, 0x0c076540, 0x080c2301,
+	0x0c0766c0, 0x00000000, 0x040002c7, 0x0c076400, 0x080c2301,
+	0x0c076580, 0x00000000, 0x095091cb, 0x06094107, 0x0c076280,
+	0x080c2301, 0x0c076400, 0x00000000, 0x040002c7, 0x0c076140,
+	0x080c2301, 0x0c0762c0, 0x00000000, 0x095091cb, 0x06094107,
+	0x0400128a, 0x0b8cb24a, 0x0cc00000, 0x00000000, 0x0649c707,
+	0x0aa28007, 0x044011c7, 0x0809c700, 0x06804008, 0x054031c7,
 	0x02007207, 0x040011c7, 0x070001c8, 0x09c082c8, 0x074001c8,
-	0x0cc00000, 0x00000000, 0x0200d308, 0x0440134d, 0x0700034d,
-	0x0540234d, 0x0200d349, 0x0700034e, 0x0400040e, 0x0400134d,
-	0x0700034d, 0x0900234d, 0x094a240d, 0x09408390, 0x09508390,
-	0x09608390, 0x09708390, 0x06800210, 0x0d000010, 0x060c220e,
-	0x0cc00000, 0x00000000, 0x0649cd09, 0x06800047, 0x054101c7,
-	0x020091c9, 0x0609cd09, 0x069fffc7, 0x07c03b47, 0x07c03b87,
-	0x07c03c47, 0x07c00a07, 0x07c00a47, 0x07c00a87, 0x07c03c87,
-	0x07c01747, 0x06800207, 0x0c7f5340, 0x07c03bc7, 0x07803c0a,
-	0x0a60c00a, 0x0c780c80, 0x0680004a, 0x07802dca, 0x0aa0800a,
-	0x0c780b80, 0x0649cf07, 0x0a2180c7, 0x07803c07, 0x0aa0c007,
-	0x0680004a, 0x0680000a, 0x0c7809c0, 0x07807347, 0x07801f48,
-	0x0a803207, 0x0c7808c0, 0x0680004a, 0x07802407, 0x07801f08,
-	0x0a803207, 0x0c780780, 0x0680004a, 0x07802047, 0x07802e08,
-	0x02009207, 0x0aa18009, 0x0a803247, 0x0a802248, 0x0c7800c0,
-	0x0c780540, 0x0680004a, 0x07802007, 0x07802e48, 0x0a803207,
-	0x0c780400, 0x0680004a, 0x0a618147, 0x07801f87, 0x07801fc8,
-	0x0a803207, 0x0c780280, 0x0680004a, 0x07802147, 0x0aa1c087,
-	0x07801807, 0x0a4033c7, 0x07801847, 0x0a803407, 0x0c780080,
-	0x0680004a, 0x0cc00000, 0x07c02dca, 0x06490908, 0x0581f208,
-	0x0a6f8008, 0x00000000, 0x06490708, 0x09808648, 0x09c08488,
-	0x06090708, 0x068400c8, 0x096e820b, 0x097e120a, 0x07802407,
-	0x040011c7, 0x048031c7, 0x09542207, 0x0580124a, 0x06094809,
-	0x06094908, 0x06800008, 0x098092c8, 0x07801987, 0x09405247,
-	0x058051c7, 0x040011c7, 0x097c2207, 0x06094809, 0x06094908,
-	0x0c07be00, 0x00000000, 0x06490708, 0x09c08648, 0x09808488,
-	0x06090708, 0x0cc00000, 0x00000000, 0x0649cf07, 0x06800048,
-	0x0a2100c7, 0x07c01e48, 0x0cc00000, 0x00000000, 0x07801988,
-	0x0aa0c008, 0x0a210807, 0x00000000, 0x0cc00000, 0x00000000,
-	0x0c07b900, 0x00000000, 0x0c07b140, 0x00000000, 0x0680001b,
-	0x0780294e, 0x0a61038e, 0x07802c4e, 0x0c780380, 0x0980b00b,
-	0x0ae6011b, 0x0c07f180, 0x00000000, 0x0400128a, 0x0b80438a,
-	0x00000000, 0x0680000a, 0x040012cb, 0x0b8f834b, 0x0b8f730a,
-	0x0c780380, 0x00000000, 0x0ae3011b, 0x0c07ee80, 0x044012cb,
-	0x0c07ee00, 0x040012cb, 0x0400128a, 0x0b80438a, 0x00000000,
-	0x0680000a, 0x040022cb, 0x0b8f634b, 0x0b8f530a, 0x0cc00000,
-	0x0680001b, 0x07803c07, 0x07802e88, 0x0a402207, 0x0c7809c0,
-	0x07c02e87, 0x07802c49, 0x0780294a, 0x0a60c30a, 0x07802c8a,
-	0x0540128a, 0x06800008, 0x0b80a247, 0x095084c7, 0x02407247,
-	0x0b8fd288, 0x04001208, 0x0649cd07, 0x040011c7, 0x0609cd07,
-	0x0cc00000, 0x06800047, 0x0aa0c007, 0x06800049, 0x07c02d89,
-	0x0aa0c712, 0x07c02cc7, 0x05401208, 0x094084c8, 0x07c02d08,
-	0x0780188a, 0x078018cb, 0x07802ccc, 0x07802d0d, 0x0c07ebc0,
-	0x06800009, 0x07802cc7, 0x0aa18007, 0x044011c7, 0x0ba0c707,
-	0x0c7fffc0, 0x0441c1c7, 0x07c02b07, 0x07802cc7, 0x07c01887,
-	0x07802d07, 0x07c018c7, 0x0cc00000, 0x06800007, 0x0c780380,
-	0x06800087, 0x0c780300, 0x06800147, 0x0c780280, 0x06800187,
-	0x0c071f40, 0x080c2301, 0x07c03c07, 0x0c071e80, 0x080c2301,
-	0x0aad41c7, 0x0aad8007, 0x0aadc047, 0x07c01ec7, 0x07803bc8,
-	0x09061248, 0x07c02dc9, 0x0a250208, 0x07803c08, 0x0aa08008,
-	0x0c7f1f40, 0x0649cf09, 0x0a20c0c9, 0x0aa2c087, 0x0c7f1e40,
-	0x07802008, 0x0aa20148, 0x07801c48, 0x0a614008, 0x0aa08087,
-	0x0c7f1cc0, 0x06800048, 0x07c01c48, 0x07c01c08, 0x0649c909,
-	0x04001249, 0x0609c909, 0x06800009, 0x07c01d89, 0x0c079a00,
-	0x00000000, 0x0c07a040, 0x00000000, 0x0c0715c0, 0x080c2301,
-	0x07803b8d, 0x0a806347, 0x07803bc8, 0x06800049, 0x07c02dc9,
-	0x0c780080, 0x07c03b87, 0x09082248, 0x0aa1c049, 0x0680000a,
-	0x0c06e980, 0x06c0000a, 0x06800049, 0x09482209, 0x07c03bc8,
-	0x06af000a, 0x06c0470a, 0x054091c7, 0x0200a1ca, 0x06804009,
-	0x06b0c00b, 0x0c06e340, 0x00000000, 0x0780c007, 0x06905348,
-	0x0a803207, 0x0c7f1280, 0x07c03b8d, 0x0780c047, 0x09105207,
-	0x07803b4e, 0x0a803388, 0x0c7802c0, 0x07c03b48, 0x07803bc7,
-	0x0be20047, 0x068c000a, 0x06c0470a, 0x06808009, 0x06b0400b,
-	0x0c06de80, 0x00000000, 0x0c780900, 0x068f000a, 0x06c0470a,
-	0x07803b48, 0x0540a1c8, 0x0200a1ca, 0x06806009, 0x06b0400b,
-	0x0c06dc00, 0x00000000, 0x07804007, 0x06905348, 0x0a805207,
-	0x00000000, 0x07c03b8d, 0x0c7f0ac0, 0x07c03b4e, 0x0680000a,
-	0x0c00f180, 0x00000000, 0x0c016a80, 0x00000000, 0x07803bc7,
-	0x0be34107, 0x068c000a, 0x06c0470a, 0x06804009, 0x06b0400b,
-	0x0c06d700, 0x00000000, 0x068cc00a, 0x06c0470a, 0x06802009,
-	0x06b0a00b, 0x0c06d580, 0x00000000, 0x0c0130c0, 0x00000000,
-	0x07803bc7, 0x0be34107, 0x068d000a, 0x06c0470a, 0x06804009,
-	0x06b0c00b, 0x0c06d300, 0x00000000, 0x0c780180, 0x068c000a,
-	0x06c0470a, 0x0680c009, 0x0c06d180, 0x06b0400b, 0x078020c8,
-	0x0f8001c8, 0x0649cf0a, 0x0be5808a, 0x07803bca, 0x0be5020a,
-	0x0780200a, 0x0aa4814a, 0x07801f4a, 0x0a810287, 0x0400128a,
-	0x06800049, 0x03409209, 0x04401249, 0x0280a289, 0x0a80a287,
-	0x0780394a, 0x0a62000a, 0x07801eca, 0x0a61008a, 0x0680004a,
-	0x0c780100, 0x07c00b8a, 0x0680004a, 0x07c00b4a, 0x07c01f47,
-	0x07802107, 0x0a61c007, 0x068000c9, 0x0fc011c0, 0x0aa10007,
-	0x00000000, 0x0fc011c0, 0x04001247, 0x07c01f09, 0x07802007,
-	0x0a614147, 0x00000000, 0x0c06f440, 0x080c2301, 0x07c01f87,
-	0x07802147, 0x0a65c007, 0x07802187, 0x0f8001c7, 0x07807388,
-	0x07c01808, 0x07c07387, 0x078074c7, 0x07c01847, 0x06800007,
-	0x07c074c7, 0x07c07507, 0x078021c7, 0x0aa2c007, 0x07801f07,
-	0x0a6240c7, 0x00000000, 0x0c06ef40, 0x080c2301, 0x0c06f0c0,
-	0x00000000, 0x07c074c7, 0x058101c7, 0x07c07507, 0x0780738f,
-	0x078074d0, 0x07802147, 0x06800048, 0x0a422207, 0x07807547,
-	0x07c01807, 0x078075c7, 0x07c01847, 0x06800007, 0x07c07547,
-	0x07c07587, 0x07c075c7, 0x07c07607, 0x07803a87, 0x0aa54047,
-	0x00000000, 0x0c06e940, 0x080c2301, 0x0c06eac0, 0x00000000,
-	0x07c07547, 0x058101c7, 0x07c07587, 0x078021c7, 0x0aa2c007,
-	0x07801f07, 0x0a6240c7, 0x00000000, 0x0c06e640, 0x080c2301,
-	0x0c06e7c0, 0x00000000, 0x07c075c7, 0x058101c7, 0x07c07607,
-	0x0780754f, 0x078075d0, 0x0c079500, 0x00000000, 0x07802dc7,
-	0x0a608007, 0x0c782180, 0x07801e87, 0x069fffc8, 0x0b803207,
-	0x040011c7, 0x06800147, 0x07c01e87, 0x07802d07, 0x078023c8,
-	0x0b802207, 0x0c780200, 0x0780188a, 0x078018cb, 0x0680000c,
-	0x078023cd, 0x06800049, 0x0c07a640, 0x07c01e49, 0x07801d08,
-	0x0649cf09, 0x0aa28008, 0x07803c0a, 0x0aa0800a, 0x0c781bc0,
-	0x04401208, 0x07c01d08, 0x0aa08008, 0x0c781ac0, 0x09c09089,
-	0x0609cf09, 0x0a22c309, 0x0780204a, 0x0a62400a, 0x07802e0a,
-	0x0aa1c00a, 0x07801f0a, 0x0aa0c0ca, 0x0680004a, 0x0680008a,
-	0x0c7817c0, 0x07c01d0a, 0x0680000a, 0x07c01d0a, 0x0688000a,
-	0x0c06b1c0, 0x06c0000a, 0x07803bc7, 0x0be54107, 0x068001ca,
-	0x06031e0a, 0x0680001b, 0x0649ce09, 0x0aa10009, 0x00000000,
-	0x0809ce00, 0x08007401, 0x06431e09, 0x0bee4049, 0x00000000,
-	0x0649cf07, 0x0a2200c7, 0x07801d87, 0x0aa18007, 0x07801ec7,
-	0x0aa10087, 0x06800207, 0x0c7ed640, 0x07c03bc7, 0x06800013,
-	0x07c02cd3, 0x07c02d13, 0x07c02e93, 0x07c01893, 0x07c018d3,
-	0x06803fc7, 0x07c02b07, 0x06800007, 0x07c02547, 0x07c025c7,
-	0x07c02607, 0x07802c07, 0x040011c7, 0x07c024c7, 0x06800047,
-	0x060e0c07, 0x07c026c7, 0x07c02507, 0x068003c7, 0x07c02807,
-	0x06805c07, 0x060c2107, 0x080c2170, 0x06800087, 0x07c02a47,
-	0x06800018, 0x07801ec7, 0x0a61c087, 0x06800007, 0x07800b48,
-	0x0aa1c008, 0x06800088, 0x0c780140, 0x07c00b48, 0x07800b47,
-	0x07801e48, 0x02c07207, 0x07c01e47, 0x068003c7, 0x07c02fc7,
-	0x06800407, 0x060c2407, 0x06800007, 0x07807048, 0x06804009,
-	0x05403287, 0x0200a289, 0x0400128a, 0x0700028b, 0x060c220b,
-	0x0400128a, 0x0700028b, 0x0400128a, 0x0700028c, 0x096102cc,
+	0x0649c807, 0x0aa28007, 0x044011c7, 0x0809c800, 0x06804008,
+	0x054031c7, 0x02007207, 0x040011c7, 0x070001c8, 0x09c082c8,
+	0x074001c8, 0x0cc00000, 0x00000000, 0x0200d308, 0x0440134d,
+	0x0700034d, 0x0540234d, 0x0200d349, 0x0700034e, 0x0400040e,
+	0x0400134d, 0x0700034d, 0x0900234d, 0x094a240d, 0x09408390,
+	0x09508390, 0x09608390, 0x09708390, 0x06800210, 0x0d000010,
+	0x060c220e, 0x0cc00000, 0x00000000, 0x0649cd09, 0x06800047,
+	0x054101c7, 0x020091c9, 0x0609cd09, 0x069fffc7, 0x07c03b47,
+	0x07c03b87, 0x07c03c47, 0x07c00a07, 0x07c00a47, 0x07c00a87,
+	0x07c03c87, 0x07c01747, 0x06800207, 0x0c7f53c0, 0x07c03bc7,
+	0x07803c0a, 0x0a60c00a, 0x0c780c80, 0x0680004a, 0x07802dca,
+	0x0aa0800a, 0x0c780b80, 0x0649cf07, 0x0a2180c7, 0x07803c07,
+	0x0aa0c007, 0x0680004a, 0x0680000a, 0x0c7809c0, 0x07807347,
+	0x07801f48, 0x0a803207, 0x0c7808c0, 0x0680004a, 0x07802407,
+	0x07801f08, 0x0a803207, 0x0c780780, 0x0680004a, 0x07802047,
+	0x07802e08, 0x02009207, 0x0aa18009, 0x0a803247, 0x0a802248,
+	0x0c7800c0, 0x0c780540, 0x0680004a, 0x07802007, 0x07802e48,
+	0x0a803207, 0x0c780400, 0x0680004a, 0x0a618147, 0x07801f87,
+	0x07801fc8, 0x0a803207, 0x0c780280, 0x0680004a, 0x07802147,
+	0x0aa1c087, 0x07801807, 0x0a4033c7, 0x07801847, 0x0a803407,
+	0x0c780080, 0x0680004a, 0x0cc00000, 0x07c02dca, 0x06490908,
+	0x0581f208, 0x0a6f8008, 0x00000000, 0x06490708, 0x09808648,
+	0x09c08488, 0x06090708, 0x068400c8, 0x096e820b, 0x097e120a,
+	0x07802407, 0x040011c7, 0x048031c7, 0x09542207, 0x0580124a,
+	0x06094809, 0x06094908, 0x06800008, 0x098092c8, 0x07801987,
+	0x09405247, 0x058051c7, 0x040011c7, 0x097c2207, 0x06094809,
+	0x06094908, 0x0c07be00, 0x00000000, 0x06490708, 0x09c08648,
+	0x09808488, 0x06090708, 0x0cc00000, 0x00000000, 0x0649cf07,
+	0x06800048, 0x0a2100c7, 0x07c01e48, 0x0cc00000, 0x00000000,
+	0x07801988, 0x0aa0c008, 0x0a210807, 0x00000000, 0x0cc00000,
+	0x00000000, 0x0c07b900, 0x00000000, 0x0c07b140, 0x00000000,
+	0x0680001b, 0x0780294e, 0x0a61038e, 0x07802c4e, 0x0c780380,
+	0x0980b00b, 0x0ae6011b, 0x0c07f180, 0x00000000, 0x0400128a,
+	0x0b80438a, 0x00000000, 0x0680000a, 0x040012cb, 0x0b8f834b,
+	0x0b8f730a, 0x0c780380, 0x00000000, 0x0ae3011b, 0x0c07ee80,
+	0x044012cb, 0x0c07ee00, 0x040012cb, 0x0400128a, 0x0b80438a,
+	0x00000000, 0x0680000a, 0x040022cb, 0x0b8f634b, 0x0b8f530a,
+	0x0cc00000, 0x0680001b, 0x07803c07, 0x07802e88, 0x0a402207,
+	0x0c7809c0, 0x07c02e87, 0x07802c49, 0x0780294a, 0x0a60c30a,
+	0x07802c8a, 0x0540128a, 0x06800008, 0x0b80a247, 0x095084c7,
+	0x02407247, 0x0b8fd288, 0x04001208, 0x0649cd07, 0x040011c7,
+	0x0609cd07, 0x0cc00000, 0x06800047, 0x0aa0c007, 0x06800049,
+	0x07c02d89, 0x0aa0c712, 0x07c02cc7, 0x05401208, 0x094084c8,
+	0x07c02d08, 0x0780188a, 0x078018cb, 0x07802ccc, 0x07802d0d,
+	0x0c07ebc0, 0x06800009, 0x07802cc7, 0x0aa18007, 0x044011c7,
+	0x0ba0c707, 0x0c7fffc0, 0x0441c1c7, 0x07c02b07, 0x07802cc7,
+	0x07c01887, 0x07802d07, 0x07c018c7, 0x0cc00000, 0x06800007,
+	0x0c780380, 0x06800087, 0x0c780300, 0x06800147, 0x0c780280,
+	0x06800187, 0x0c071fc0, 0x080c2301, 0x07c03c07, 0x0c071f00,
+	0x080c2301, 0x0aad41c7, 0x0aad8007, 0x0aadc047, 0x07c01ec7,
+	0x07803bc8, 0x09061248, 0x07c02dc9, 0x0a250208, 0x07803c08,
+	0x0aa08008, 0x0c7f1fc0, 0x0649cf09, 0x0a20c0c9, 0x0aa2c087,
+	0x0c7f1ec0, 0x07802008, 0x0aa20148, 0x07801c48, 0x0a614008,
+	0x0aa08087, 0x0c7f1d40, 0x06800048, 0x07c01c48, 0x07c01c08,
+	0x0649c909, 0x04001249, 0x0609c909, 0x06800009, 0x07c01d89,
+	0x0c079a00, 0x00000000, 0x0c07a040, 0x00000000, 0x0c071640,
+	0x080c2301, 0x07803b8d, 0x0a806347, 0x07803bc8, 0x06800049,
+	0x07c02dc9, 0x0c780080, 0x07c03b87, 0x09082248, 0x0aa1c049,
+	0x0680000a, 0x0c06ea80, 0x06c0000a, 0x06800049, 0x09482209,
+	0x07c03bc8, 0x06af000a, 0x06c0470a, 0x054091c7, 0x0200a1ca,
+	0x06804009, 0x06b0c00b, 0x0c06e440, 0x00000000, 0x0780c007,
+	0x06905348, 0x0a803207, 0x0c7f1300, 0x07c03b8d, 0x0780c047,
+	0x09105207, 0x07803b4e, 0x0a803388, 0x0c7802c0, 0x07c03b48,
+	0x07803bc7, 0x0be20047, 0x068c000a, 0x06c0470a, 0x06808009,
+	0x06b0400b, 0x0c06df80, 0x00000000, 0x0c780900, 0x068f000a,
+	0x06c0470a, 0x07803b48, 0x0540a1c8, 0x0200a1ca, 0x06806009,
+	0x06b0400b, 0x0c06dd00, 0x00000000, 0x07804007, 0x06905348,
+	0x0a805207, 0x00000000, 0x07c03b8d, 0x0c7f0b40, 0x07c03b4e,
+	0x0680000a, 0x0c00f0c0, 0x00000000, 0x0c016980, 0x00000000,
+	0x07803bc7, 0x0be34107, 0x068c000a, 0x06c0470a, 0x06804009,
+	0x06b0400b, 0x0c06d800, 0x00000000, 0x068cc00a, 0x06c0470a,
+	0x06802009, 0x06b0a00b, 0x0c06d680, 0x00000000, 0x0c012fc0,
+	0x00000000, 0x07803bc7, 0x0be34107, 0x068d000a, 0x06c0470a,
+	0x06804009, 0x06b0c00b, 0x0c06d400, 0x00000000, 0x0c780180,
+	0x068c000a, 0x06c0470a, 0x0680c009, 0x0c06d280, 0x06b0400b,
+	0x078020c8, 0x0f8001c8, 0x0649cf0a, 0x0be5808a, 0x07803bca,
+	0x0be5020a, 0x0780200a, 0x0aa4814a, 0x07801f4a, 0x0a810287,
+	0x0400128a, 0x06800049, 0x03409209, 0x04401249, 0x0280a289,
+	0x0a80a287, 0x0780394a, 0x0a62000a, 0x07801eca, 0x0a61008a,
+	0x0680004a, 0x0c780100, 0x07c00b8a, 0x0680004a, 0x07c00b4a,
+	0x07c01f47, 0x07802107, 0x0a61c007, 0x068000c9, 0x0fc011c0,
+	0x0aa10007, 0x00000000, 0x0fc011c0, 0x04001247, 0x07c01f09,
+	0x07802007, 0x0a614147, 0x00000000, 0x0c06f4c0, 0x080c2301,
+	0x07c01f87, 0x07802147, 0x0a65c007, 0x07802187, 0x0f8001c7,
+	0x07807388, 0x07c01808, 0x07c07387, 0x078074c7, 0x07c01847,
+	0x06800007, 0x07c074c7, 0x07c07507, 0x078021c7, 0x0aa2c007,
+	0x07801f07, 0x0a6240c7, 0x00000000, 0x0c06efc0, 0x080c2301,
+	0x0c06f140, 0x00000000, 0x07c074c7, 0x058101c7, 0x07c07507,
+	0x0780738f, 0x078074d0, 0x07802147, 0x06800048, 0x0a422207,
+	0x07807547, 0x07c01807, 0x078075c7, 0x07c01847, 0x06800007,
+	0x07c07547, 0x07c07587, 0x07c075c7, 0x07c07607, 0x07803a87,
+	0x0aa54047, 0x00000000, 0x0c06e9c0, 0x080c2301, 0x0c06eb40,
+	0x00000000, 0x07c07547, 0x058101c7, 0x07c07587, 0x078021c7,
+	0x0aa2c007, 0x07801f07, 0x0a6240c7, 0x00000000, 0x0c06e6c0,
+	0x080c2301, 0x0c06e840, 0x00000000, 0x07c075c7, 0x058101c7,
+	0x07c07607, 0x0780754f, 0x078075d0, 0x0c079500, 0x00000000,
+	0x07802dc7, 0x0a608007, 0x0c782180, 0x07801e87, 0x069fffc8,
+	0x0b803207, 0x040011c7, 0x06800147, 0x07c01e87, 0x07802d07,
+	0x078023c8, 0x0b802207, 0x0c780200, 0x0780188a, 0x078018cb,
+	0x0680000c, 0x078023cd, 0x06800049, 0x0c07a640, 0x07c01e49,
+	0x07801d08, 0x0649cf09, 0x0aa28008, 0x07803c0a, 0x0aa0800a,
+	0x0c781bc0, 0x04401208, 0x07c01d08, 0x0aa08008, 0x0c781ac0,
+	0x09c09089, 0x0609cf09, 0x0a22c309, 0x0780204a, 0x0a62400a,
+	0x07802e0a, 0x0aa1c00a, 0x07801f0a, 0x0aa0c0ca, 0x0680004a,
+	0x0680008a, 0x0c7817c0, 0x07c01d0a, 0x0680000a, 0x07c01d0a,
+	0x0688000a, 0x0c06b2c0, 0x06c0000a, 0x07803bc7, 0x0be54107,
+	0x068001ca, 0x06031e0a, 0x0680001b, 0x0649ce09, 0x0aa10009,
+	0x00000000, 0x0809ce00, 0x08007401, 0x06431e09, 0x0bee4049,
+	0x00000000, 0x0649cf07, 0x0a2200c7, 0x07801d87, 0x0aa18007,
+	0x07801ec7, 0x0aa10087, 0x06800207, 0x0c7ed6c0, 0x07c03bc7,
+	0x06800013, 0x07c02cd3, 0x07c02d13, 0x07c02e93, 0x07c01893,
+	0x07c018d3, 0x06803fc7, 0x07c02b07, 0x06800007, 0x07c02547,
+	0x07c025c7, 0x07c02607, 0x07802c07, 0x040011c7, 0x07c024c7,
+	0x06800047, 0x060e0c07, 0x07c026c7, 0x07c02507, 0x068003c7,
+	0x07c02807, 0x06805c07, 0x060c2107, 0x080c2170, 0x06800087,
+	0x07c02a47, 0x06800018, 0x07801ec7, 0x0a61c087, 0x06800007,
+	0x07800b48, 0x0aa1c008, 0x06800088, 0x0c780140, 0x07c00b48,
+	0x07800b47, 0x07801e48, 0x02c07207, 0x07c01e47, 0x068003c7,
+	0x07c02fc7, 0x06800407, 0x060c2407, 0x06800007, 0x07807048,
+	0x06804009, 0x05403287, 0x0200a289, 0x0400128a, 0x0700028b,
 	0x060c220b, 0x0400128a, 0x0700028b, 0x0400128a, 0x0700028c,
-	0x096102cc, 0x060c220b, 0x040011c7, 0x0b8ee207, 0x00000000,
-	0x07801d07, 0x0aa08007, 0x0c7ec4c0, 0x06800007, 0x07c01947,
-	0x06a00007, 0x060c3d07, 0x07802dc7, 0x0a618007, 0x00000000,
-	0x0c079240, 0x00000000, 0x0aa08007, 0x0c7ec200, 0x07802047,
-	0x07c02e07, 0x07802007, 0x07c02e47, 0x07801ec7, 0x07c02087,
-	0x07801f47, 0x07c07347, 0x07801f07, 0x07c02407, 0x07801f87,
-	0x07c01fc7, 0x0780248a, 0x0a6fc00a, 0x00000000, 0x0c0730c0,
-	0x00000000, 0x07802dc7, 0x0aa10007, 0x00000000, 0x0c0728c0,
-	0x00000000, 0x0c073480, 0x00000000, 0x07802087, 0x06840009,
-	0x0682629a, 0x0aa1c087, 0x06800008, 0x0682305a, 0x0aa10147,
-	0x06800048, 0x06800088, 0x06840009, 0x07c02788, 0x07c02689,
-	0x06800007, 0x07c02a87, 0x07802c8a, 0x07802107, 0x0a630007,
-	0x07802409, 0x0aa280c9, 0x0540128a, 0x0580128a, 0x06490707,
-	0x09807087, 0x098070c7, 0x06090707, 0x06495107, 0x098073c7,
-	0x06095107, 0x07c023ca, 0x07802947, 0x094421c9, 0x07c02947,
-	0x0a648387, 0x068000c9, 0x06495107, 0x094041c9, 0x06800009,
-	0x097821c9, 0x06095107, 0x06490707, 0x09807447, 0x06090707,
-	0x06498e07, 0x09807787, 0x09c070c7, 0x06098e07, 0x07802087,
-	0x0aa0c087, 0x0682519a, 0x068214da, 0x07803bc8, 0x090821c8,
-	0x0aa18087, 0x06800087, 0x09482207, 0x0690000a, 0x0c0680c0,
-	0x06c0000a, 0x0c784cc0, 0x07c03bc8, 0x07802dc7, 0x0aa18007,
-	0x00000000, 0x0c077b80, 0x00000000, 0x0aa08007, 0x0c7eab40,
-	0x06800007, 0x07803bc8, 0x09082208, 0x0aa10008, 0x0684000a,
-	0x0c067cc0, 0x06c0000a, 0x07c03bc7, 0x07802d87, 0x0aa34007,
-	0x07802c47, 0x0b22c2c7, 0x07802cc7, 0x0a614007, 0x06495108,
-	0x09c08608, 0x0c7800c0, 0x07c02d87, 0x09808608, 0x06095108,
-	0x08095017, 0x08095000, 0x0c784500, 0x00000000, 0x0540928c,
-	0x0200a24a, 0x06c046ca, 0x0200ad0a, 0x0400130c, 0x0481f30c,
-	0x07c02b4c, 0x0643500c, 0x0580f30c, 0x0bef804c, 0x00000000,
-	0x0643530c, 0x0900c30c, 0x0a6f800c, 0x00000000, 0x0603510a,
-	0x06803f0a, 0x0603520a, 0x0c792bc0, 0x0603500b, 0x0cc00000,
-	0x00000000, 0x07802cc9, 0x07c02ac9, 0x07802889, 0x07c03049,
-	0x07802809, 0x0aa08009, 0x0cc00000, 0x064e0e09, 0x09809309,
-	0x098092c9, 0x0cc00000, 0x060e0e09, 0x06435007, 0x0580f1c7,
-	0x0bef8047, 0x0aa14712, 0x06800007, 0x07802d07, 0x050011c7,
-	0x048011c7, 0x0b60c709, 0x06808008, 0x0680c008, 0x0c78ed00,
-	0x00000000, 0x0c7806c0, 0x07802807, 0x0aaf8387, 0x00000000,
-	0x07802947, 0x0aaec387, 0x064e0407, 0x091c2207, 0x0a24c0c8,
-	0x080c3e07, 0x064c3f07, 0x064c3f09, 0x09004249, 0x0581b1c7,
-	0x0a234047, 0x090241c7, 0x0a210088, 0x0aa20289, 0x0aa1c309,
-	0x0be18087, 0x0a21c048, 0x0aa102c9, 0x0aa0c309, 0x0be08047,
-	0x0c7800c0, 0x06800049, 0x07c01e49, 0x0cc00000, 0x00000000,
-	0x07800dc8, 0x0aa0c048, 0x0c780780, 0x00000000, 0x06800008,
-	0x07c00dc8, 0x07800d89, 0x07801f08, 0x09610248, 0x0609d509,
-	0x0aa18048, 0x0aa20088, 0x00000000, 0x0680774a, 0x0c780180,
-	0x00000000, 0x068077ca, 0x0c7800c0, 0x00000000, 0x0680784a,
-	0x07000288, 0x0400128a, 0x07000289, 0x09610209, 0x0609d608,
-	0x0649d308, 0x098083c8, 0x0609d308, 0x08007401, 0x0649d308,
-	0x0a6fc008, 0x00000000, 0x0cc00000, 0x00000000, 0x0680000c,
-	0x0680002a, 0x064c2907, 0x0a20c407, 0x0c7e8880, 0x00000000,
-	0x0fc081c0, 0x0aaeffc7, 0x0200c1cc, 0x064c2907, 0x0a20c407,
-	0x0c7e86c0, 0x00000000, 0x0fc081c0, 0x0aaeffc7, 0x0202a1ea,
-	0x0aa5400c, 0x0aa1418c, 0x0462d1cc, 0x0c500880, 0x0a61004c,
-	0x0c780e80, 0x06800047, 0x07c01c47, 0x064c0007, 0x0be14207,
-	0x064c2907, 0x0be0c407, 0x0d07ff2a, 0x0fc081c0, 0x064c0007,
-	0x0be10207, 0x064c2907, 0x0be08407, 0x0c7ff780, 0x0c7e80c0,
-	0x00000000, 0x0c067c80, 0x080c2301, 0x064c232b, 0x05810aeb,
-	0x048ffaeb, 0x068f000a, 0x06c0470a, 0x0540a1c7, 0x0200a1ca,
-	0x06804009, 0x0c064d40, 0x06b0400b, 0x07804007, 0x06905348,
-	0x0a80f207, 0x0c7e7c80, 0x0c067880, 0x080c2301, 0x064c232b,
-	0x05810aeb, 0x048ffaeb, 0x0fc011c0, 0x0aa14047, 0x04001aeb,
-	0x0fc071c0, 0x04007aeb, 0x07c017c7, 0x0c780140, 0x00000000,
-	0x0680004a, 0x0c006040, 0x00000000, 0x048071eb, 0x0580322b,
-	0x0aa14007, 0x06800209, 0x04001208, 0x024071c9, 0x0f8001c7,
-	0x0262a22a, 0x0c57f440, 0x0c7ff280, 0x0680002b, 0x07803d0d,
-	0x0a22830d, 0x07802f87, 0x09005207, 0x04001208, 0x0c00d080,
-	0x0202b22b, 0x090a5207, 0x04001208, 0x0c00cf80, 0x0202b22b,
-	0x0a21440d, 0x00000000, 0x0fc041c0, 0x07c02fc7, 0x04004aeb,
-	0x0c7ff940, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x096102cc, 0x060c220b, 0x0400128a, 0x0700028b, 0x0400128a,
+	0x0700028c, 0x096102cc, 0x060c220b, 0x040011c7, 0x0b8ee207,
+	0x00000000, 0x07801d07, 0x0aa08007, 0x0c7ec540, 0x06800007,
+	0x07c01947, 0x06a00007, 0x060c3d07, 0x07802dc7, 0x0a618007,
+	0x00000000, 0x0c079240, 0x00000000, 0x0aa08007, 0x0c7ec280,
+	0x07802047, 0x07c02e07, 0x07802007, 0x07c02e47, 0x07801ec7,
+	0x07c02087, 0x07801f47, 0x07c07347, 0x07801f07, 0x07c02407,
+	0x07801f87, 0x07c01fc7, 0x0780248a, 0x0a6fc00a, 0x00000000,
+	0x0c0730c0, 0x00000000, 0x07802dc7, 0x0aa10007, 0x00000000,
+	0x0c0728c0, 0x00000000, 0x0c073480, 0x00000000, 0x07802087,
+	0x06840009, 0x0682629a, 0x0aa1c087, 0x06800008, 0x0682305a,
+	0x0aa10147, 0x06800048, 0x06800088, 0x06840009, 0x07c02788,
+	0x07c02689, 0x06800007, 0x07c02a87, 0x07802c8a, 0x07802107,
+	0x0a630007, 0x07802409, 0x0aa280c9, 0x0540128a, 0x0580128a,
+	0x06490707, 0x09807087, 0x098070c7, 0x06090707, 0x06495107,
+	0x098073c7, 0x06095107, 0x07c023ca, 0x07802947, 0x094421c9,
+	0x07c02947, 0x0a648387, 0x068000c9, 0x06495107, 0x094041c9,
+	0x06800009, 0x097821c9, 0x06095107, 0x06490707, 0x09807447,
+	0x06090707, 0x06498e07, 0x09807787, 0x09c070c7, 0x06098e07,
+	0x07802087, 0x0aa0c087, 0x0682519a, 0x068214da, 0x07803bc8,
+	0x090821c8, 0x0aa18087, 0x06800087, 0x09482207, 0x0690000a,
+	0x0c0681c0, 0x06c0000a, 0x0c784dc0, 0x07c03bc8, 0x07802dc7,
+	0x0aa18007, 0x00000000, 0x0c077b80, 0x00000000, 0x0aa08007,
+	0x0c7eabc0, 0x06800007, 0x07803bc8, 0x09082208, 0x0aa10008,
+	0x0684000a, 0x0c067dc0, 0x06c0000a, 0x07c03bc7, 0x07802d87,
+	0x0aa34007, 0x07802c47, 0x0b22c2c7, 0x07802cc7, 0x0a614007,
+	0x06495108, 0x09c08608, 0x0c7800c0, 0x07c02d87, 0x09808608,
+	0x06095108, 0x08095017, 0x08095000, 0x0c784600, 0x00000000,
+	0x0540928c, 0x0200a24a, 0x06c046ca, 0x0200ad0a, 0x0400130c,
+	0x0481f30c, 0x07c02b4c, 0x0643500c, 0x0580f30c, 0x0bef804c,
+	0x00000000, 0x0643530c, 0x0900c30c, 0x0a6f800c, 0x00000000,
+	0x0603510a, 0x06803f0a, 0x0603520a, 0x0c792cc0, 0x0603500b,
+	0x0cc00000, 0x00000000, 0x07802cc9, 0x07c02ac9, 0x07802889,
+	0x07c03049, 0x07802809, 0x0aa08009, 0x0cc00000, 0x064e0e09,
+	0x09809309, 0x098092c9, 0x0cc00000, 0x060e0e09, 0x06435007,
+	0x0580f1c7, 0x0bef8047, 0x0aa14712, 0x06800007, 0x07802d07,
+	0x050011c7, 0x048011c7, 0x0b60c709, 0x06808008, 0x0680c008,
+	0x0c78ee00, 0x00000000, 0x0c7806c0, 0x07802807, 0x0aaf8387,
+	0x00000000, 0x07802947, 0x0aaec387, 0x064e0407, 0x091c2207,
+	0x0a24c0c8, 0x080c3e07, 0x064c3f07, 0x064c3f09, 0x09004249,
+	0x0581b1c7, 0x0a234047, 0x090241c7, 0x0a210088, 0x0aa20289,
+	0x0aa1c309, 0x0be18087, 0x0a21c048, 0x0aa102c9, 0x0aa0c309,
+	0x0be08047, 0x0c7800c0, 0x06800049, 0x07c01e49, 0x0cc00000,
+	0x00000000, 0x07800dc8, 0x0aa0c048, 0x0c780780, 0x00000000,
+	0x06800008, 0x07c00dc8, 0x07800d89, 0x07801f08, 0x09610248,
+	0x0609d509, 0x0aa18048, 0x0aa20088, 0x00000000, 0x0680774a,
+	0x0c780180, 0x00000000, 0x068077ca, 0x0c7800c0, 0x00000000,
+	0x0680784a, 0x07000288, 0x0400128a, 0x07000289, 0x09610209,
+	0x0609d608, 0x0649d308, 0x098083c8, 0x0609d308, 0x08007401,
+	0x0649d308, 0x0a6fc008, 0x00000000, 0x0cc00000, 0x00000000,
+	0x0680000c, 0x0680002a, 0x064c2907, 0x0a20c407, 0x0c7e8900,
+	0x00000000, 0x0fc081c0, 0x0aaeffc7, 0x0200c1cc, 0x064c2907,
+	0x0a20c407, 0x0c7e8740, 0x00000000, 0x0fc081c0, 0x0aaeffc7,
+	0x0202a1ea, 0x0aa5400c, 0x0aa1418c, 0x0462d1cc, 0x0c500880,
+	0x0a61004c, 0x0c780e80, 0x06800047, 0x07c01c47, 0x064c0007,
+	0x0be14207, 0x064c2907, 0x0be0c407, 0x0d07ff2a, 0x0fc081c0,
+	0x064c0007, 0x0be10207, 0x064c2907, 0x0be08407, 0x0c7ff780,
+	0x0c7e8140, 0x00000000, 0x0c067d00, 0x080c2301, 0x064c232b,
+	0x05810aeb, 0x048ffaeb, 0x068f000a, 0x06c0470a, 0x0540a1c7,
+	0x0200a1ca, 0x06804009, 0x0c064e40, 0x06b0400b, 0x07804007,
+	0x06905348, 0x0a80f207, 0x0c7e7d00, 0x0c067900, 0x080c2301,
+	0x064c232b, 0x05810aeb, 0x048ffaeb, 0x0fc011c0, 0x0aa14047,
+	0x04001aeb, 0x0fc071c0, 0x04007aeb, 0x07c017c7, 0x0c780140,
+	0x00000000, 0x0680004a, 0x0c005f80, 0x00000000, 0x048071eb,
+	0x0580322b, 0x0aa14007, 0x06800209, 0x04001208, 0x024071c9,
+	0x0f8001c7, 0x0262a22a, 0x0c57f440, 0x0c7ff280, 0x0680002b,
+	0x07803d0d, 0x0a22830d, 0x07802f87, 0x09005207, 0x04001208,
+	0x0c00cf80, 0x0202b22b, 0x090a5207, 0x04001208, 0x0c00ce80,
+	0x0202b22b, 0x0a21440d, 0x00000000, 0x0fc041c0, 0x07c02fc7,
+	0x04004aeb, 0x0c7ff940, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -500,15 +500,15 @@ static const u32 MicroCode[] __initconst = {
 	0x04c001c7, 0x09807207, 0x060c2107, 0x07802547, 0x0aa14007,
 	0x06a01008, 0x0aa0c047, 0x06a22008, 0x06a40008, 0x06431e09,
 	0x0befc049, 0x06c00108, 0x07802949, 0x0a670389, 0x0a26c053,
-	0x0c074fc0, 0x00000000, 0x0780288a, 0x0aa1c00a, 0x07802a8a,
+	0x0c074ec0, 0x00000000, 0x0780288a, 0x0aa1c00a, 0x07802a8a,
 	0x00800000, 0x078026c9, 0x04001249, 0x07c026c9, 0x00400000,
 	0x0b61408a, 0x00000000, 0x080c2170, 0x0c780700, 0x080c260e,
 	0x0683ffca, 0x0440128a, 0x0aa0c00a, 0x07802489, 0x0a6f4009,
 	0x078026c9, 0x04401249, 0x0c008080, 0x07c026c9, 0x0c780440,
 	0x08030580, 0x060e0508, 0x07802a88, 0x06801809, 0x09502248,
 	0x060c2109, 0x080c260e, 0x07c02587, 0x0ba0c087, 0x040011c7,
-	0x06800007, 0x0c0745c0, 0x07c02547, 0x06800088, 0x07c02488,
-	0x08030580, 0x0c074b00, 0x00000000, 0x07802747, 0x0aa14712,
+	0x06800007, 0x0c0744c0, 0x07c02547, 0x06800088, 0x07c02488,
+	0x08030580, 0x0c074a00, 0x00000000, 0x07802747, 0x0aa14712,
 	0x040011c7, 0x07802d08, 0x0a20c048, 0x00000000, 0x07c02747,
 	0x0c07ae80, 0x07802b0d, 0x0b608008, 0x0c7fed00, 0x0ba13fcd,
 	0x06800008, 0x0c781780, 0x07c02b08, 0x06808008, 0x0ba1070d,
@@ -529,12 +529,12 @@ static const u32 MicroCode[] __initconst = {
 	0x07802c47, 0x07802ccb, 0x024072c7, 0x0b20c0c7, 0x00000000,
 	0x068000c7, 0x095c2307, 0x07c02b4c, 0x07802b4c, 0x091c22cc,
 	0x0aa2800b, 0x044012cb, 0x095c230b, 0x0a61c00b, 0x07c02b4c,
-	0x0a20c04c, 0x06b0800b, 0x06b0c00b, 0x0c072440, 0x06b00009,
+	0x0a20c04c, 0x06b0800b, 0x06b0c00b, 0x0c072340, 0x06b00009,
 	0x0680001b, 0x07802947, 0x0aa5c387, 0x07802cc7, 0x040011c7,
 	0x07c02cc7, 0x07802e88, 0x04001208, 0x07c02e88, 0x07802c48,
 	0x0b828207, 0x06800007, 0x07c02cc7, 0x07802d08, 0x04001208,
 	0x078023c9, 0x0b822248, 0x07c02d08, 0x07802487, 0x0a6fc007,
-	0x00000000, 0x06430507, 0x0a2f0107, 0x0c7dc300, 0x064c0007,
+	0x00000000, 0x06430507, 0x0a2f0107, 0x0c7dc280, 0x064c0007,
 	0x07802d08, 0x0be10048, 0x040011c8, 0x0c780580, 0x07c02d07,
 	0x044011c8, 0x07c02d07, 0x07802cc7, 0x040011c7, 0x07c02cc7,
 	0x07802e88, 0x04001208, 0x07c02e88, 0x07802c48, 0x0b80b207,
@@ -543,14 +543,14 @@ static const u32 MicroCode[] __initconst = {
 	0x064c3b07, 0x0920c1c7, 0x0b218a07, 0x0680004a, 0x07c01e4a,
 	0x07c01d8a, 0x0680204a, 0x07c0194a, 0x07802cc7, 0x095084c7,
 	0x07802d09, 0x094084c9, 0x07801909, 0x0aa14009, 0x04401249,
-	0x0a60c009, 0x07c01909, 0x0c7ef380, 0x07802c49, 0x0b014489,
+	0x0a60c009, 0x07c01909, 0x0c7ef280, 0x07802c49, 0x0b014489,
 	0x06808008, 0x0a628712, 0x0c780840, 0x00000000, 0x07802d0a,
 	0x0a20c04a, 0x0500128a, 0x040011c7, 0x054011c7, 0x0c780840,
 	0x094011ca, 0x040011c7, 0x0a410247, 0x07802b09, 0x07802d07,
-	0x0a25c047, 0x040021c9, 0x0c7f1880, 0x06800007, 0x0aa5c712,
+	0x0a25c047, 0x040021c9, 0x0c7f1780, 0x06800007, 0x0aa5c712,
 	0x07802d0a, 0x0a2bc04a, 0x04001287, 0x0a4ed24a, 0x0c780480,
-	0x06800007, 0x0c7f1440, 0x00000000, 0x0a628047, 0x040021c9,
-	0x07802d07, 0x0be1c047, 0x040021c9, 0x0c7f1480, 0x06800047,
+	0x06800007, 0x0c7f1340, 0x00000000, 0x0a628047, 0x040021c9,
+	0x07802d07, 0x0be1c047, 0x040021c9, 0x0c7f1380, 0x06800047,
 	0x0aadc007, 0x07802b09, 0x040011c9, 0x0ba10707, 0x0b6cce07,
 	0x0680c008, 0x0441c1c7, 0x05403247, 0x020091c9, 0x02008248,
 	0x07000209, 0x07c02449, 0x04001208, 0x07000209, 0x04001208,
@@ -625,142 +625,142 @@ static const u32 MicroCode[] __initconst = {
 	0x064c0909, 0x0ac0924a, 0x0b80324a, 0x0c7801c0, 0x09808688,
 	0x0400128a, 0x098083c8, 0x0a40324a, 0x0440128a, 0x098086c8,
 	0x0aa1000a, 0x09308287, 0x0a60c00a, 0x0400128a, 0x09808388,
-	0x0b80324a, 0x00000000, 0x098081c8, 0x0c780500, 0x060e0408,
-	0x0a614248, 0x00000000, 0x0c009240, 0x00000000, 0x0c780380,
-	0x0a62c288, 0x06431f20, 0x06433f21, 0x0e000860, 0x00000000,
-	0x00000000, 0x0f000800, 0x06031f20, 0x0f010840, 0x0c780100,
-	0x06033f21, 0x0c780080, 0x00000000, 0x08031e00, 0x0cc00000,
-	0x00400000, 0x0680400f, 0x0680a00e, 0x0680ec0d, 0x0680f60c,
-	0x0780704b, 0x0680000a, 0x06800009, 0x06800008, 0x0780776f,
-	0x07807780, 0x09610bc0, 0x0780736e, 0x078020c0, 0x06800041,
-	0x0342d001, 0x07807300, 0x06800081, 0x0b831040, 0x05403c4a,
-	0x02031c4f, 0x04001c71, 0x07000c44, 0x06800c00, 0x0bc25004,
-	0x09042004, 0x068000c1, 0x0a422040, 0x09101004, 0x04001c31,
-	0x02030030, 0x02030030, 0x07000c2c, 0x04001c30, 0x07000c00,
-	0x09610b00, 0x04005c71, 0x07000c6b, 0x0b003bab, 0x00000000,
-	0x0242bb6b, 0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a,
-	0x068000c0, 0x04001c30, 0x07400c00, 0x04001c30, 0x07400c2b,
-	0x0581002b, 0x04001c30, 0x07400c00, 0x0ac05bec, 0x0203024d,
-	0x07400c2a, 0x04001249, 0x0c780100, 0x0203020c, 0x07400c2a,
-	0x04001208, 0x0400128a, 0x0b8d52ca, 0x02000209, 0x07c070c9,
-	0x0cc00000, 0x07c07100, 0x0aa14040, 0x06800047, 0x06800006,
-	0x0c780100, 0x00000000, 0x06800007, 0x06800046, 0x05403c4a,
-	0x02031c4f, 0x04001c71, 0x07000c44, 0x09101004, 0x04001c31,
-	0x02030030, 0x02030030, 0x07000c2c, 0x04001c30, 0x07000c00,
-	0x09610b00, 0x04005c71, 0x07000c6b, 0x0b003bab, 0x00000000,
-	0x0242bb6b, 0x0be60404, 0x0a25c104, 0x0202a209, 0x05402c2a,
-	0x02030c0e, 0x07400c0a, 0x06800040, 0x04001c30, 0x07400c00,
-	0x0540102b, 0x020001c0, 0x04001c30, 0x07400c00, 0x05810000,
+	0x0b80324a, 0x00000000, 0x098081c8, 0x0c780240, 0x060e0408,
+	0x0a614248, 0x00000000, 0x0c008f80, 0x00000000, 0x0c7800c0,
+	0x0c780080, 0x00000000, 0x08031e00, 0x0cc00000, 0x00400000,
+	0x0680400f, 0x0680a00e, 0x0680ec0d, 0x0680f60c, 0x0780704b,
+	0x0680000a, 0x06800009, 0x06800008, 0x0780776f, 0x07807780,
+	0x09610bc0, 0x0780736e, 0x078020c0, 0x06800041, 0x0342d001,
+	0x07807300, 0x06800081, 0x0b831040, 0x05403c4a, 0x02031c4f,
+	0x04001c71, 0x07000c44, 0x06800c00, 0x0bc25004, 0x09042004,
+	0x068000c1, 0x0a422040, 0x09101004, 0x04001c31, 0x02030030,
+	0x02030030, 0x07000c2c, 0x04001c30, 0x07000c00, 0x09610b00,
+	0x04005c71, 0x07000c6b, 0x0b003bab, 0x00000000, 0x0242bb6b,
+	0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a, 0x068000c0,
+	0x04001c30, 0x07400c00, 0x04001c30, 0x07400c2b, 0x0581002b,
 	0x04001c30, 0x07400c00, 0x0ac05bec, 0x0203024d, 0x07400c2a,
 	0x04001249, 0x0c780100, 0x0203020c, 0x07400c2a, 0x04001208,
-	0x0be60804, 0x0a25c204, 0x0202a209, 0x05402c2a, 0x02030c0e,
-	0x07400c0a, 0x06800080, 0x04001c30, 0x07400c00, 0x0540102b,
-	0x02000180, 0x04001c30, 0x07400c00, 0x05810000, 0x04001c30,
+	0x0400128a, 0x0b8d52ca, 0x02000209, 0x07c070c9, 0x0cc00000,
+	0x07c07100, 0x0aa14040, 0x06800047, 0x06800006, 0x0c780100,
+	0x00000000, 0x06800007, 0x06800046, 0x05403c4a, 0x02031c4f,
+	0x04001c71, 0x07000c44, 0x09101004, 0x04001c31, 0x02030030,
+	0x02030030, 0x07000c2c, 0x04001c30, 0x07000c00, 0x09610b00,
+	0x04005c71, 0x07000c6b, 0x0b003bab, 0x00000000, 0x0242bb6b,
+	0x0be60404, 0x0a25c104, 0x0202a209, 0x05402c2a, 0x02030c0e,
+	0x07400c0a, 0x06800040, 0x04001c30, 0x07400c00, 0x0540102b,
+	0x020001c0, 0x04001c30, 0x07400c00, 0x05810000, 0x04001c30,
 	0x07400c00, 0x0ac05bec, 0x0203024d, 0x07400c2a, 0x04001249,
-	0x0c780100, 0x0203020c, 0x07400c2a, 0x04001208, 0x0400128a,
-	0x0b8be2ca, 0x02000209, 0x07c070c9, 0x0cc00000, 0x07c07100,
-	0x0680400f, 0x0680a00e, 0x0680ec0d, 0x0780704b, 0x0680000a,
-	0x07807109, 0x07807300, 0x0ba6c080, 0x05403c4a, 0x02031c4f,
-	0x04001c71, 0x07000c44, 0x09082004, 0x0a6440c0, 0x04006c71,
-	0x07000c6b, 0x05402c09, 0x02030c0e, 0x07400c0a, 0x068001c0,
-	0x04001c30, 0x07400c00, 0x04001c30, 0x07400c2b, 0x0581002b,
+	0x0c780100, 0x0203020c, 0x07400c2a, 0x04001208, 0x0be60804,
+	0x0a25c204, 0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a,
+	0x06800080, 0x04001c30, 0x07400c00, 0x0540102b, 0x02000180,
+	0x04001c30, 0x07400c00, 0x05810000, 0x04001c30, 0x07400c00,
+	0x0ac05bec, 0x0203024d, 0x07400c2a, 0x04001249, 0x0c780100,
+	0x0203020c, 0x07400c2a, 0x04001208, 0x0400128a, 0x0b8be2ca,
+	0x02000209, 0x07c070c9, 0x0cc00000, 0x07c07100, 0x0680400f,
+	0x0680a00e, 0x0680ec0d, 0x0780704b, 0x0680000a, 0x07807109,
+	0x07807300, 0x0ba6c080, 0x05403c4a, 0x02031c4f, 0x04001c71,
+	0x07000c44, 0x09082004, 0x0a6440c0, 0x04006c71, 0x07000c6b,
+	0x05402c09, 0x02030c0e, 0x07400c0a, 0x068001c0, 0x04001c30,
+	0x07400c00, 0x04001c30, 0x07400c2b, 0x0581002b, 0x04001c30,
+	0x07400c00, 0x0203024d, 0x07400c09, 0x04001249, 0x0400128a,
+	0x0b8e92ca, 0x0cc00000, 0x07c07149, 0x0aa14040, 0x06800047,
+	0x06800006, 0x0c780100, 0x00000000, 0x06800007, 0x06800046,
+	0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44, 0x04006c71,
+	0x07000c6b, 0x0a244404, 0x05402c09, 0x02030c0e, 0x07400c0a,
+	0x06800140, 0x04001c30, 0x07400c00, 0x0540102b, 0x020001c0,
+	0x04001c30, 0x07400c00, 0x05810000, 0x04001c30, 0x07400c00,
+	0x0203024d, 0x07400c09, 0x04001249, 0x0a244804, 0x05402c09,
+	0x02030c0e, 0x07400c0a, 0x06800180, 0x04001c30, 0x07400c00,
+	0x0540102b, 0x02000180, 0x04001c30, 0x07400c00, 0x05810000,
 	0x04001c30, 0x07400c00, 0x0203024d, 0x07400c09, 0x04001249,
-	0x0400128a, 0x0b8e92ca, 0x0cc00000, 0x07c07149, 0x0aa14040,
-	0x06800047, 0x06800006, 0x0c780100, 0x00000000, 0x06800007,
-	0x06800046, 0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44,
-	0x04006c71, 0x07000c6b, 0x0a244404, 0x05402c09, 0x02030c0e,
-	0x07400c0a, 0x06800140, 0x04001c30, 0x07400c00, 0x0540102b,
-	0x020001c0, 0x04001c30, 0x07400c00, 0x05810000, 0x04001c30,
-	0x07400c00, 0x0203024d, 0x07400c09, 0x04001249, 0x0a244804,
-	0x05402c09, 0x02030c0e, 0x07400c0a, 0x06800180, 0x04001c30,
-	0x07400c00, 0x0540102b, 0x02000180, 0x04001c30, 0x07400c00,
-	0x05810000, 0x04001c30, 0x07400c00, 0x0203024d, 0x07400c09,
-	0x04001249, 0x0400128a, 0x0b8d72ca, 0x0cc00000, 0x07c07149,
-	0x0680ec0f, 0x0680f60e, 0x0780710a, 0x078070c9, 0x06800008,
-	0x0240a24a, 0x0200e28e, 0x0a60c009, 0x0cc00000, 0x00000000,
-	0x070003c0, 0x07400380, 0x040013cf, 0x0400138e, 0x04001208,
-	0x0b8fb248, 0x0cc00000, 0x00000000, 0x0680ec0f, 0x0680f60e,
-	0x0780710a, 0x078070c9, 0x06800008, 0x0240a24a, 0x0200f24f,
-	0x0a60c00a, 0x0cc00000, 0x00000000, 0x07000380, 0x074003c0,
-	0x040013cf, 0x0400138e, 0x04001208, 0x0b8fb288, 0x0cc00000,
-	0x00000000, 0x0680ec0f, 0x0680f60e, 0x0780710a, 0x07807149,
-	0x0200f28f, 0x0200e28e, 0x0a40324a, 0x0cc00000, 0x00000000,
-	0x070003c0, 0x07400380, 0x040013cf, 0x0400138e, 0x0400128a,
-	0x0b8fb24a, 0x0cc00000, 0x00000000, 0x0b60808e, 0x0c780e00,
-	0x0680a00c, 0x0680400b, 0x0680000a, 0x0a83438a, 0x0400124a,
-	0x0202f28f, 0x07000bee, 0x0540222e, 0x0200820c, 0x04002208,
-	0x0700022d, 0x04001208, 0x07000200, 0x09610b40, 0x0a814389,
-	0x0202c24f, 0x07000b2b, 0x0540222b, 0x0200820c, 0x04002208,
-	0x0700022a, 0x04001208, 0x07000200, 0x09610a80, 0x0a60c00d,
-	0x0b807aad, 0x0c7800c0, 0x0ac05aad, 0x00000000, 0x07400b2e,
-	0x04000bab, 0x04000b6a, 0x04001249, 0x0c7ffb40, 0x07807300,
-	0x0b644080, 0x0a24004a, 0x0540222e, 0x0200820c, 0x04002208,
-	0x07000207, 0x0a22c047, 0x04401b6f, 0x07000b6c, 0x0540222c,
-	0x0200820c, 0x04002208, 0x07000207, 0x0be10047, 0x00000000,
-	0x07400b6e, 0x04000bac, 0x07400bee, 0x0400128a, 0x0c7ff340,
-	0x0cc00000, 0x00000000, 0x0b60808e, 0x0c781680, 0x0680a00c,
-	0x0680400b, 0x0680000a, 0x0a85638a, 0x0400124a, 0x0202f28f,
-	0x07000bee, 0x0540222e, 0x0200820c, 0x07000207, 0x04001208,
-	0x07000206, 0x054031c7, 0x020071cb, 0x09002146, 0x0a6280c5,
-	0x00000000, 0x040011c7, 0x070001c4, 0x09101c44, 0x040011c7,
-	0x02007c47, 0x02007c47, 0x0c780100, 0x00000000, 0x02007147,
-	0x02007147, 0x070001ed, 0x040011c7, 0x070001c0, 0x09610b40,
-	0x0a825389, 0x0202c24f, 0x07000b2b, 0x0540222b, 0x0200820c,
-	0x07000207, 0x04001208, 0x07000206, 0x054031c7, 0x020071cb,
-	0x09002146, 0x0a6280c5, 0x00000000, 0x040011c7, 0x070001c4,
-	0x09101c44, 0x040011c7, 0x02007c47, 0x02007c47, 0x0c780100,
-	0x00000000, 0x02007147, 0x02007147, 0x070001ea, 0x040011c7,
-	0x070001c0, 0x09610a80, 0x0a60c00d, 0x0b807aad, 0x0c7800c0,
-	0x0ac05aad, 0x00000000, 0x07400b2e, 0x04000bab, 0x04000b6a,
-	0x04001249, 0x0c7ff700, 0x07807300, 0x0b644080, 0x0a24004a,
-	0x0540222e, 0x0200820c, 0x04002208, 0x07000207, 0x0a22c047,
-	0x04401b6f, 0x07000b6c, 0x0540222c, 0x0200820c, 0x04002208,
-	0x07000207, 0x0be10047, 0x00000000, 0x07400b6e, 0x04000bac,
-	0x07400bee, 0x0400128a, 0x0c7feac0, 0x0cc00000, 0x00000000,
-	0x0400120a, 0x0200720f, 0x070001c9, 0x05402189, 0x0200618c,
-	0x04002186, 0x07000185, 0x09001005, 0x0a4092c0, 0x04401c47,
-	0x07000c40, 0x074001c0, 0x04401208, 0x0acfc288, 0x040001f1,
-	0x0cc00000, 0x074001c9, 0x04001208, 0x0b8ef388, 0x0cc00000,
-	0x00000000, 0x0780710e, 0x0440134e, 0x0680a00c, 0x0680000a,
-	0x0b60808e, 0x0c7804c0, 0x0200928f, 0x07000248, 0x054021c8,
-	0x020071cc, 0x040021c7, 0x070001c6, 0x0be1804a, 0x0be24046,
-	0x00000000, 0x0c07f700, 0x0680004b, 0x0c780140, 0x0a210046,
-	0x00000000, 0x0c07f5c0, 0x0680000b, 0x0400128a, 0x0b8ef34a,
-	0x0cc00000, 0x00000000, 0x06800008, 0x0700040a, 0x0200720f,
-	0x070001c9, 0x05402189, 0x020061af, 0x04001186, 0x07000185,
-	0x09041005, 0x0a418a80, 0x04001186, 0x07000185, 0x04001186,
-	0x07000180, 0x09610140, 0x0a412305, 0x0a80e348, 0x0ac07348,
-	0x00000000, 0x0200734f, 0x0a80a34a, 0x0400128a, 0x0440120a,
-	0x0200720f, 0x04401c47, 0x07000c40, 0x074001c0, 0x04401208,
-	0x0acfc348, 0x040001f1, 0x074001c9, 0x0cc00000, 0x0740040a,
-	0x04001208, 0x0b8e0288, 0x0cc00000, 0x00000000, 0x0680a02f,
-	0x078020c0, 0x06800041, 0x0342e001, 0x0780736d, 0x07807300,
-	0x0b614080, 0x00000000, 0x05401bae, 0x05401b6d, 0x04001b6d,
-	0x0242cbad, 0x04000aed, 0x0680000d, 0x0680002a, 0x07000380,
-	0x0400138e, 0x0aa10000, 0x0aa30040, 0x0aa50080, 0x0c780680,
-	0x07000380, 0x0400138e, 0x04001000, 0x0242b02b, 0x0b411b2b,
-	0x0400032b, 0x0202bbab, 0x0c780380, 0x0400032b, 0x07000380,
-	0x0400138e, 0x04001000, 0x0202b02b, 0x0b808b6b, 0x0400032b,
-	0x0242bbab, 0x0c780140, 0x0400032b, 0x0680006a, 0x0700038c,
-	0x0400138e, 0x0c07ec40, 0x00000000, 0x0c7ff880, 0x0400134d,
-	0x0cc00000, 0x00000000, 0x0c077280, 0x00000000, 0x0c079600,
-	0x00000000, 0x07802080, 0x0aa64180, 0x00000000, 0x0c07ae80,
-	0x00000000, 0x07807140, 0x07c07240, 0x0680ec0f, 0x0780710e,
-	0x0680004d, 0x0c07b580, 0x00000000, 0x0680ec0f, 0x0780714e,
-	0x07807100, 0x0200f00f, 0x0240e00e, 0x0680000d, 0x0c07b380,
-	0x00000000, 0x0680ec0f, 0x0680c00e, 0x0c07ed80, 0x06807250,
-	0x0cc00000, 0x00000000, 0x0680ec0f, 0x078070ce, 0x0680004d,
-	0x0c07bf80, 0x00000000, 0x0680f60f, 0x0780710e, 0x078070c0,
-	0x0240e00e, 0x0680000d, 0x0c07bdc0, 0x00000000, 0x0680ec0f,
-	0x0780714e, 0x07807100, 0x0200f00f, 0x0240e00e, 0x0680000d,
-	0x0c07ad00, 0x00000000, 0x0c07a3c0, 0x00000000, 0x0c079ec0,
-	0x00000000, 0x0c07a740, 0x00000000, 0x07807140, 0x07c07240,
-	0x07c07280, 0x07807300, 0x0b618080, 0x00000000, 0x0c07d4c0,
-	0x0680ec0f, 0x0c07d440, 0x0680f60f, 0x078070c0, 0x07807101,
-	0x07807170, 0x0ba280b0, 0x0aa0c000, 0x0a802040, 0x0c7801c0,
-	0x0680f60f, 0x0400138f, 0x070003c0, 0x07000381, 0x07400380,
-	0x074003c1, 0x0680ec0f, 0x0680c00e, 0x0c07dfc0, 0x06807250,
-	0x0680f60f, 0x0680d08e, 0x0c07dec0, 0x06807290, 0x0cc00000,
+	0x0400128a, 0x0b8d72ca, 0x0cc00000, 0x07c07149, 0x0680ec0f,
+	0x0680f60e, 0x0780710a, 0x078070c9, 0x06800008, 0x0240a24a,
+	0x0200e28e, 0x0a60c009, 0x0cc00000, 0x00000000, 0x070003c0,
+	0x07400380, 0x040013cf, 0x0400138e, 0x04001208, 0x0b8fb248,
+	0x0cc00000, 0x00000000, 0x0680ec0f, 0x0680f60e, 0x0780710a,
+	0x078070c9, 0x06800008, 0x0240a24a, 0x0200f24f, 0x0a60c00a,
+	0x0cc00000, 0x00000000, 0x07000380, 0x074003c0, 0x040013cf,
+	0x0400138e, 0x04001208, 0x0b8fb288, 0x0cc00000, 0x00000000,
+	0x0680ec0f, 0x0680f60e, 0x0780710a, 0x07807149, 0x0200f28f,
+	0x0200e28e, 0x0a40324a, 0x0cc00000, 0x00000000, 0x070003c0,
+	0x07400380, 0x040013cf, 0x0400138e, 0x0400128a, 0x0b8fb24a,
+	0x0cc00000, 0x00000000, 0x0b60808e, 0x0c780e00, 0x0680a00c,
+	0x0680400b, 0x0680000a, 0x0a83438a, 0x0400124a, 0x0202f28f,
+	0x07000bee, 0x0540222e, 0x0200820c, 0x04002208, 0x0700022d,
+	0x04001208, 0x07000200, 0x09610b40, 0x0a814389, 0x0202c24f,
+	0x07000b2b, 0x0540222b, 0x0200820c, 0x04002208, 0x0700022a,
+	0x04001208, 0x07000200, 0x09610a80, 0x0a60c00d, 0x0b807aad,
+	0x0c7800c0, 0x0ac05aad, 0x00000000, 0x07400b2e, 0x04000bab,
+	0x04000b6a, 0x04001249, 0x0c7ffb40, 0x07807300, 0x0b644080,
+	0x0a24004a, 0x0540222e, 0x0200820c, 0x04002208, 0x07000207,
+	0x0a22c047, 0x04401b6f, 0x07000b6c, 0x0540222c, 0x0200820c,
+	0x04002208, 0x07000207, 0x0be10047, 0x00000000, 0x07400b6e,
+	0x04000bac, 0x07400bee, 0x0400128a, 0x0c7ff340, 0x0cc00000,
+	0x00000000, 0x0b60808e, 0x0c781680, 0x0680a00c, 0x0680400b,
+	0x0680000a, 0x0a85638a, 0x0400124a, 0x0202f28f, 0x07000bee,
+	0x0540222e, 0x0200820c, 0x07000207, 0x04001208, 0x07000206,
+	0x054031c7, 0x020071cb, 0x09002146, 0x0a6280c5, 0x00000000,
+	0x040011c7, 0x070001c4, 0x09101c44, 0x040011c7, 0x02007c47,
+	0x02007c47, 0x0c780100, 0x00000000, 0x02007147, 0x02007147,
+	0x070001ed, 0x040011c7, 0x070001c0, 0x09610b40, 0x0a825389,
+	0x0202c24f, 0x07000b2b, 0x0540222b, 0x0200820c, 0x07000207,
+	0x04001208, 0x07000206, 0x054031c7, 0x020071cb, 0x09002146,
+	0x0a6280c5, 0x00000000, 0x040011c7, 0x070001c4, 0x09101c44,
+	0x040011c7, 0x02007c47, 0x02007c47, 0x0c780100, 0x00000000,
+	0x02007147, 0x02007147, 0x070001ea, 0x040011c7, 0x070001c0,
+	0x09610a80, 0x0a60c00d, 0x0b807aad, 0x0c7800c0, 0x0ac05aad,
+	0x00000000, 0x07400b2e, 0x04000bab, 0x04000b6a, 0x04001249,
+	0x0c7ff700, 0x07807300, 0x0b644080, 0x0a24004a, 0x0540222e,
+	0x0200820c, 0x04002208, 0x07000207, 0x0a22c047, 0x04401b6f,
+	0x07000b6c, 0x0540222c, 0x0200820c, 0x04002208, 0x07000207,
+	0x0be10047, 0x00000000, 0x07400b6e, 0x04000bac, 0x07400bee,
+	0x0400128a, 0x0c7feac0, 0x0cc00000, 0x00000000, 0x0400120a,
+	0x0200720f, 0x070001c9, 0x05402189, 0x0200618c, 0x04002186,
+	0x07000185, 0x09001005, 0x0a4092c0, 0x04401c47, 0x07000c40,
+	0x074001c0, 0x04401208, 0x0acfc288, 0x040001f1, 0x0cc00000,
+	0x074001c9, 0x04001208, 0x0b8ef388, 0x0cc00000, 0x00000000,
+	0x0780710e, 0x0440134e, 0x0680a00c, 0x0680000a, 0x0b60808e,
+	0x0c7804c0, 0x0200928f, 0x07000248, 0x054021c8, 0x020071cc,
+	0x040021c7, 0x070001c6, 0x0be1804a, 0x0be24046, 0x00000000,
+	0x0c07f700, 0x0680004b, 0x0c780140, 0x0a210046, 0x00000000,
+	0x0c07f5c0, 0x0680000b, 0x0400128a, 0x0b8ef34a, 0x0cc00000,
+	0x00000000, 0x06800008, 0x0700040a, 0x0200720f, 0x070001c9,
+	0x05402189, 0x020061af, 0x04001186, 0x07000185, 0x09041005,
+	0x0a418a80, 0x04001186, 0x07000185, 0x04001186, 0x07000180,
+	0x09610140, 0x0a412305, 0x0a80e348, 0x0ac07348, 0x00000000,
+	0x0200734f, 0x0a80a34a, 0x0400128a, 0x0440120a, 0x0200720f,
+	0x04401c47, 0x07000c40, 0x074001c0, 0x04401208, 0x0acfc348,
+	0x040001f1, 0x074001c9, 0x0cc00000, 0x0740040a, 0x04001208,
+	0x0b8e0288, 0x0cc00000, 0x00000000, 0x0680a02f, 0x078020c0,
+	0x06800041, 0x0342e001, 0x0780736d, 0x07807300, 0x0b614080,
+	0x00000000, 0x05401bae, 0x05401b6d, 0x04001b6d, 0x0242cbad,
+	0x04000aed, 0x0680000d, 0x0680002a, 0x07000380, 0x0400138e,
+	0x0aa10000, 0x0aa30040, 0x0aa50080, 0x0c780680, 0x07000380,
+	0x0400138e, 0x04001000, 0x0242b02b, 0x0b411b2b, 0x0400032b,
+	0x0202bbab, 0x0c780380, 0x0400032b, 0x07000380, 0x0400138e,
+	0x04001000, 0x0202b02b, 0x0b808b6b, 0x0400032b, 0x0242bbab,
+	0x0c780140, 0x0400032b, 0x0680006a, 0x0700038c, 0x0400138e,
+	0x0c07ec40, 0x00000000, 0x0c7ff880, 0x0400134d, 0x0cc00000,
+	0x00000000, 0x0c077280, 0x00000000, 0x0c079600, 0x00000000,
+	0x07802080, 0x0aa64180, 0x00000000, 0x0c07ae80, 0x00000000,
+	0x07807140, 0x07c07240, 0x0680ec0f, 0x0780710e, 0x0680004d,
+	0x0c07b580, 0x00000000, 0x0680ec0f, 0x0780714e, 0x07807100,
+	0x0200f00f, 0x0240e00e, 0x0680000d, 0x0c07b380, 0x00000000,
+	0x0680ec0f, 0x0680c00e, 0x0c07ed80, 0x06807250, 0x0cc00000,
+	0x00000000, 0x0680ec0f, 0x078070ce, 0x0680004d, 0x0c07bf80,
+	0x00000000, 0x0680f60f, 0x0780710e, 0x078070c0, 0x0240e00e,
+	0x0680000d, 0x0c07bdc0, 0x00000000, 0x0680ec0f, 0x0780714e,
+	0x07807100, 0x0200f00f, 0x0240e00e, 0x0680000d, 0x0c07ad00,
+	0x00000000, 0x0c07a3c0, 0x00000000, 0x0c079ec0, 0x00000000,
+	0x0c07a740, 0x00000000, 0x07807140, 0x07c07240, 0x07c07280,
+	0x07807300, 0x0b618080, 0x00000000, 0x0c07d4c0, 0x0680ec0f,
+	0x0c07d440, 0x0680f60f, 0x078070c0, 0x07807101, 0x07807170,
+	0x0ba280b0, 0x0aa0c000, 0x0a802040, 0x0c7801c0, 0x0680f60f,
+	0x0400138f, 0x070003c0, 0x07000381, 0x07400380, 0x074003c1,
+	0x0680ec0f, 0x0680c00e, 0x0c07dfc0, 0x06807250, 0x0680f60f,
+	0x0680d08e, 0x0c07dec0, 0x06807290, 0x0cc00000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264data_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264data_linux.h
index 8c7d2bb2..7090305 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264data_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264data_linux.h
@@ -90,15 +90,15 @@ static const u32 MicroCode[] __initconst = {
 	0x080c260f, 0x080c2603, 0x04c001c7, 0x09807207, 0x060c2107,
 	0x07802547, 0x0aa14007, 0x06a01008, 0x0aa0c047, 0x06a22008,
 	0x06a40008, 0x06431e09, 0x0befc049, 0x06c00108, 0x07802949,
-	0x0a670389, 0x0a26c053, 0x0c074fc0, 0x00000000, 0x0780288a,
+	0x0a670389, 0x0a26c053, 0x0c074ec0, 0x00000000, 0x0780288a,
 	0x0aa1c00a, 0x07802a8a, 0x00800000, 0x078026c9, 0x04001249,
 	0x07c026c9, 0x00400000, 0x0b61408a, 0x00000000, 0x080c2170,
 	0x0c780700, 0x080c260e, 0x0683ffca, 0x0440128a, 0x0aa0c00a,
 	0x07802489, 0x0a6f4009, 0x078026c9, 0x04401249, 0x0c008080,
 	0x07c026c9, 0x0c780440, 0x08030580, 0x060e0508, 0x07802a88,
 	0x06801809, 0x09502248, 0x060c2109, 0x080c260e, 0x07c02587,
-	0x0ba0c087, 0x040011c7, 0x06800007, 0x0c0745c0, 0x07c02547,
-	0x06800088, 0x07c02488, 0x08030580, 0x0c074b00, 0x00000000,
+	0x0ba0c087, 0x040011c7, 0x06800007, 0x0c0744c0, 0x07c02547,
+	0x06800088, 0x07c02488, 0x08030580, 0x0c074a00, 0x00000000,
 	0x07802747, 0x0aa14712, 0x040011c7, 0x07802d08, 0x0a20c048,
 	0x00000000, 0x07c02747, 0x0c07ae80, 0x07802b0d, 0x0b608008,
 	0x0c7fed00, 0x0ba13fcd, 0x06800008, 0x0c781780, 0x07c02b08,
@@ -120,12 +120,12 @@ static const u32 MicroCode[] __initconst = {
 	0x0b20c0c7, 0x00000000, 0x068000c7, 0x095c2307, 0x07c02b4c,
 	0x07802b4c, 0x091c22cc, 0x0aa2800b, 0x044012cb, 0x095c230b,
 	0x0a61c00b, 0x07c02b4c, 0x0a20c04c, 0x06b0800b, 0x06b0c00b,
-	0x0c072440, 0x06b00009, 0x0680001b, 0x07802947, 0x0aa5c387,
+	0x0c072340, 0x06b00009, 0x0680001b, 0x07802947, 0x0aa5c387,
 	0x07802cc7, 0x040011c7, 0x07c02cc7, 0x07802e88, 0x04001208,
 	0x07c02e88, 0x07802c48, 0x0b828207, 0x06800007, 0x07c02cc7,
 	0x07802d08, 0x04001208, 0x078023c9, 0x0b822248, 0x07c02d08,
 	0x07802487, 0x0a6fc007, 0x00000000, 0x06430507, 0x0a2f0107,
-	0x0c7dc300, 0x064c0007, 0x07802d08, 0x0be10048, 0x040011c8,
+	0x0c7dc280, 0x064c0007, 0x07802d08, 0x0be10048, 0x040011c8,
 	0x0c780580, 0x07c02d07, 0x044011c8, 0x07c02d07, 0x07802cc7,
 	0x040011c7, 0x07c02cc7, 0x07802e88, 0x04001208, 0x07c02e88,
 	0x07802c48, 0x0b80b207, 0x06800007, 0x07c02cc7, 0x07802d08,
@@ -133,15 +133,15 @@ static const u32 MicroCode[] __initconst = {
 	0x0c7ff880, 0x07c02e87, 0x064c3b07, 0x0920c1c7, 0x0b218a07,
 	0x0680004a, 0x07c01e4a, 0x07c01d8a, 0x0680204a, 0x07c0194a,
 	0x07802cc7, 0x095084c7, 0x07802d09, 0x094084c9, 0x07801909,
-	0x0aa14009, 0x04401249, 0x0a60c009, 0x07c01909, 0x0c7ef380,
+	0x0aa14009, 0x04401249, 0x0a60c009, 0x07c01909, 0x0c7ef280,
 	0x07802c49, 0x0b014489, 0x06808008, 0x0a628712, 0x0c780840,
 	0x00000000, 0x07802d0a, 0x0a20c04a, 0x0500128a, 0x040011c7,
 	0x054011c7, 0x0c780840, 0x094011ca, 0x040011c7, 0x0a410247,
-	0x07802b09, 0x07802d07, 0x0a25c047, 0x040021c9, 0x0c7f1880,
+	0x07802b09, 0x07802d07, 0x0a25c047, 0x040021c9, 0x0c7f1780,
 	0x06800007, 0x0aa5c712, 0x07802d0a, 0x0a2bc04a, 0x04001287,
-	0x0a4ed24a, 0x0c780480, 0x06800007, 0x0c7f1440, 0x00000000,
+	0x0a4ed24a, 0x0c780480, 0x06800007, 0x0c7f1340, 0x00000000,
 	0x0a628047, 0x040021c9, 0x07802d07, 0x0be1c047, 0x040021c9,
-	0x0c7f1480, 0x06800047, 0x0aadc007, 0x07802b09, 0x040011c9,
+	0x0c7f1380, 0x06800047, 0x0aadc007, 0x07802b09, 0x040011c9,
 	0x0ba10707, 0x0b6cce07, 0x0680c008, 0x0441c1c7, 0x05403247,
 	0x020091c9, 0x02008248, 0x07000209, 0x07c02449, 0x04001208,
 	0x07000209, 0x04001208, 0x0700021d, 0x09610749, 0x04001208,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264header_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264header_linux.h
index 666a09f..839dd7d 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264header_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264header_linux.h
@@ -1,196 +1,196 @@
 static const u32 MicroCode[] __initconst = {
 	0x06804011, 0x06905347, 0x07400447, 0x04002451, 0x0fc101c0,
-	0x09108247, 0x0a60e509, 0x0c7e5ec0, 0x00000000, 0x07400447,
-	0x04001451, 0x0fc08280, 0x07c00d0a, 0x0c065980, 0x080c2301,
-	0x0b2087c7, 0x0c7e5c80, 0x04000407, 0x09505287, 0x0740044a,
-	0x04001451, 0x0ba59909, 0x0c065740, 0x080c2301, 0x05001387,
-	0x07803ccd, 0x09502347, 0x07c03ccd, 0x0c0655c0, 0x080c2301,
-	0x0c065540, 0x080c2301, 0x0fc011c0, 0x0fc01340, 0x0942134e,
+	0x09108247, 0x0a60e509, 0x0c7e5e40, 0x00000000, 0x07400447,
+	0x04001451, 0x0fc08280, 0x07c00d0a, 0x0c065900, 0x080c2301,
+	0x0b2087c7, 0x0c7e5c00, 0x04000407, 0x09505287, 0x0740044a,
+	0x04001451, 0x0ba59909, 0x0c0656c0, 0x080c2301, 0x05001387,
+	0x07803ccd, 0x09502347, 0x07c03ccd, 0x0c065540, 0x080c2301,
+	0x0c0654c0, 0x080c2301, 0x0fc011c0, 0x0fc01340, 0x0942134e,
 	0x0740044d, 0x04001451, 0x0aa1800d, 0x0680000e, 0x068001c7,
-	0x07c01d47, 0x0c009bc0, 0x06800009, 0x0c065200, 0x080c2301,
-	0x04004247, 0x07400449, 0x04001451, 0x0c0650c0, 0x080c2301,
+	0x07c01d47, 0x0c0099c0, 0x06800009, 0x0c065180, 0x080c2301,
+	0x04004247, 0x07400449, 0x04001451, 0x0c065040, 0x080c2301,
 	0x07400447, 0x04001451, 0x06800088, 0x0a835207, 0x06800008,
 	0x0a82e207, 0x00000000, 0x0fc011c0, 0x07400447, 0x04001451,
-	0x0c064dc0, 0x080c2301, 0x0c064f40, 0x00000000, 0x07400447,
-	0x04001451, 0x058101c7, 0x07400447, 0x04001451, 0x0c064b80,
-	0x080c2301, 0x0c064d00, 0x00000000, 0x07400447, 0x04001451,
-	0x058101c7, 0x07400447, 0x04001451, 0x0c064940, 0x080c2301,
-	0x0aa68007, 0x0aa12007, 0x05807207, 0x0aa08008, 0x0c7e4b80,
-	0x07400447, 0x04001451, 0x04000287, 0x06808009, 0x0c064680,
-	0x080c2301, 0x0c064800, 0x00000000, 0x07400247, 0x04001249,
+	0x0c064d40, 0x080c2301, 0x0c064ec0, 0x00000000, 0x07400447,
+	0x04001451, 0x058101c7, 0x07400447, 0x04001451, 0x0c064b00,
+	0x080c2301, 0x0c064c80, 0x00000000, 0x07400447, 0x04001451,
+	0x058101c7, 0x07400447, 0x04001451, 0x0c0648c0, 0x080c2301,
+	0x0aa68007, 0x0aa12007, 0x05807207, 0x0aa08008, 0x0c7e4b00,
+	0x07400447, 0x04001451, 0x04000287, 0x06808009, 0x0c064600,
+	0x080c2301, 0x0c064780, 0x00000000, 0x07400247, 0x04001249,
 	0x058101c7, 0x07400247, 0x0d07fe0a, 0x04001249, 0x0c7801c0,
-	0x00000000, 0x0c064380, 0x080c2301, 0x040041c7, 0x07400447,
-	0x04001451, 0x0c064240, 0x080c2301, 0x04000247, 0x0fc011c0,
-	0x09501247, 0x07400449, 0x04001451, 0x0c064080, 0x080c2301,
-	0x04000347, 0x0c063fc0, 0x080c2301, 0x04000387, 0x0c780700,
-	0x00000000, 0x06031f0d, 0x06033f0e, 0x0c05e7c0, 0x08031e15,
-	0x06431f07, 0x06a40008, 0x0b014207, 0x06804009, 0x0b00b24d,
-	0x00000000, 0x0649cf09, 0x0a208089, 0x0c7e3f40, 0x00000000,
-	0x0809c007, 0x0609c10d, 0x08007401, 0x0c780000, 0x00800000,
-	0x0400034e, 0x0b21a40d, 0x0649cf09, 0x0a208089, 0x0c7e3c80,
-	0x0c7ffdc0, 0x0809c008, 0x0400124d, 0x07400449, 0x04001451,
-	0x0400124e, 0x07400449, 0x04001451, 0x0fc011c0, 0x0a610007,
-	0x00000000, 0x0fc01200, 0x094211c8, 0x0fc01200, 0x094411c8,
-	0x07400447, 0x04001451, 0x0fc011c0, 0x0aa20007, 0x06800108,
-	0x0c063380, 0x080c2301, 0x07400447, 0x0d07ff48, 0x04001451,
-	0x0c780140, 0x06800007, 0x07400447, 0x0d07ffc8, 0x04001451,
-	0x06804048, 0x07400211, 0x0fc01200, 0x0a60c008, 0x0c7817c0,
-	0x07400448, 0x0fc011c0, 0x09421207, 0x07400448, 0x0aa30007,
-	0x04001451, 0x0fc081c0, 0x07400447, 0x0a623fc7, 0x04001451,
-	0x0fc101c0, 0x07400447, 0x04001451, 0x0fc101c0, 0x07400447,
-	0x04001451, 0x0fc011c0, 0x0aa0c007, 0x00000000, 0x0fc011c0,
-	0x0fc011c0, 0x0aa38007, 0x00000000, 0x0680000e, 0x0fc051c0,
-	0x09405387, 0x0540838e, 0x0980e34e, 0x0a21c047, 0x00000000,
-	0x0fc101c0, 0x07c00987, 0x0fc081c0, 0x09408387, 0x07c009ce,
-	0x0fc011c0, 0x0aa14007, 0x0c062680, 0x080c2301, 0x0c062600,
-	0x080c2301, 0x0fc011c0, 0x07400447, 0x04001451, 0x0aa40007,
-	0x07c00687, 0x0fc101c0, 0x07400447, 0x04001451, 0x0fc101c0,
+	0x00000000, 0x0c064300, 0x080c2301, 0x040041c7, 0x07400447,
+	0x04001451, 0x0c0641c0, 0x080c2301, 0x04000247, 0x0fc011c0,
+	0x09501247, 0x07400449, 0x04001451, 0x0c064000, 0x080c2301,
+	0x04000347, 0x0c063f40, 0x080c2301, 0x04000387, 0x0c780540,
+	0x00000000, 0x06804009, 0x0b00b24d, 0x00000000, 0x0649cf09,
+	0x0a208089, 0x0c7e4080, 0x00000000, 0x0809c007, 0x0609c10d,
+	0x08007401, 0x0c780000, 0x00800000, 0x0400034e, 0x0b21a40d,
+	0x0649cf09, 0x0a208089, 0x0c7e3dc0, 0x0c7ffdc0, 0x0809c008,
+	0x0400124d, 0x07400449, 0x04001451, 0x0400124e, 0x07400449,
+	0x04001451, 0x0fc011c0, 0x0a610007, 0x00000000, 0x0fc01200,
+	0x094211c8, 0x0fc01200, 0x094411c8, 0x07400447, 0x04001451,
+	0x0fc011c0, 0x0aa20007, 0x06800108, 0x0c0634c0, 0x080c2301,
+	0x07400447, 0x0d07ff48, 0x04001451, 0x0c780140, 0x06800007,
+	0x07400447, 0x0d07ffc8, 0x04001451, 0x06804048, 0x07400211,
+	0x0fc01200, 0x0a60c008, 0x0c7817c0, 0x07400448, 0x0fc011c0,
+	0x09421207, 0x07400448, 0x0aa30007, 0x04001451, 0x0fc081c0,
+	0x07400447, 0x0a623fc7, 0x04001451, 0x0fc101c0, 0x07400447,
+	0x04001451, 0x0fc101c0, 0x07400447, 0x04001451, 0x0fc011c0,
+	0x0aa0c007, 0x00000000, 0x0fc011c0, 0x0fc011c0, 0x0aa38007,
+	0x00000000, 0x0680000e, 0x0fc051c0, 0x09405387, 0x0540838e,
+	0x0980e34e, 0x0a21c047, 0x00000000, 0x0fc101c0, 0x07c00987,
+	0x0fc081c0, 0x09408387, 0x07c009ce, 0x0fc011c0, 0x0aa14007,
+	0x0c0627c0, 0x080c2301, 0x0c062740, 0x080c2301, 0x0fc011c0,
+	0x07400447, 0x04001451, 0x0aa40007, 0x07c00687, 0x0fc101c0,
 	0x07400447, 0x04001451, 0x0fc101c0, 0x07400447, 0x04001451,
-	0x0fc101c0, 0x07400447, 0x04001451, 0x0fc011c0, 0x07c00687,
-	0x0680000e, 0x0fc011c0, 0x0aa18007, 0x09401387, 0x0c008140,
-	0x00000000, 0x090aa207, 0x07c02f88, 0x0fc011c0, 0x0aa1c007,
-	0x09421387, 0x0c007f80, 0x00000000, 0x0be0c04e, 0x090aa207,
-	0x07c02f88, 0x0a20c0ce, 0x00000000, 0x0fc011c0, 0x0fc011c0,
-	0x09441387, 0x0fc011c0, 0x09461387, 0x0740044e, 0x04001451,
-	0x0aa24007, 0x06800188, 0x0fc011c0, 0x0c0619c0, 0x080c2301,
-	0x0d07ff88, 0x00000000, 0x07400447, 0x04001451, 0x07803b47,
-	0x0a404407, 0x07803bc7, 0x09807007, 0x07c03bc7, 0x068f000a,
-	0x06c0470a, 0x0540a1d0, 0x0200a1ca, 0x06806009, 0x0c05e900,
-	0x06a0400b, 0x0c7e1900, 0x00000000, 0x0aa1000a, 0x06804047,
-	0x0c782180, 0x070001d1, 0x06804091, 0x07000447, 0x04001451,
-	0x07c039c7, 0x09108247, 0x07000448, 0x04001451, 0x090081c8,
-	0x07c03a07, 0x064c2908, 0x09c080c8, 0x060c2908, 0x0b60d909,
-	0x0c780680, 0x080e0000, 0x0700044d, 0x04001451, 0x064c2908,
-	0x090211cd, 0x09461207, 0x060c2908, 0x0aa3000d, 0x0680000e,
-	0x06800009, 0x06c00049, 0x060e0209, 0x068001c7, 0x07c01d47,
-	0x0c006300, 0x06800009, 0x06800009, 0x06c00049, 0x060e0209,
-	0x064e0007, 0x096e91cd, 0x060e0007, 0x064e0307, 0x095081ce,
-	0x060e0307, 0x07000449, 0x04001451, 0x07c020c9, 0x07000447,
-	0x04001451, 0x07c02147, 0x06800088, 0x0a819207, 0x06800008,
-	0x0a814207, 0x07000447, 0x04001451, 0x07c03a87, 0x07000447,
-	0x04001451, 0x07c03807, 0x07000447, 0x04001451, 0x07c03847,
-	0x07000447, 0x04001451, 0x07c03887, 0x07000447, 0x04001451,
-	0x07c038c7, 0x07000447, 0x04001451, 0x07c03987, 0x0c780100,
-	0x07000447, 0x04001451, 0x07c02187, 0x07000449, 0x04001451,
-	0x090081c9, 0x07c03907, 0x091011c9, 0x07c03947, 0x07000447,
-	0x04001451, 0x060c0907, 0x07c02c47, 0x04401247, 0x07c02c09,
-	0x07000449, 0x04001451, 0x07c02c89, 0x0700044d, 0x04001451,
-	0x090011cd, 0x0a60c007, 0x07c02107, 0x05401249, 0x04000289,
-	0x07802c48, 0x09610288, 0x0609520a, 0x05404289, 0x0968c288,
-	0x0609080a, 0x06031f08, 0x06033f09, 0x0c05a440, 0x08031e15,
-	0x06431f08, 0x0a610007, 0x07c03a48, 0x0902120d, 0x094211c8,
-	0x07c02947, 0x090411cd, 0x0aa10007, 0x054011c7, 0x07802108,
-	0x094411c8, 0x07c02307, 0x06800087, 0x07802108, 0x02408207,
-	0x07000447, 0x04001451, 0x07000449, 0x04001451, 0x09508247,
-	0x05401249, 0x07c01a89, 0x07000447, 0x04001451, 0x07000449,
-	0x04001451, 0x09508247, 0x03409209, 0x07c01ac9, 0x07000447,
-	0x04001451, 0x0be0c047, 0x0c780900, 0x05801347, 0x05801347,
-	0x0a22c04d, 0x07000447, 0x04001451, 0x07c03d47, 0x0a61ffc7,
-	0x07000447, 0x04001451, 0x07c03d87, 0x07000447, 0x04001451,
-	0x07c03dc7, 0x07000447, 0x04001451, 0x0a238047, 0x09421347,
-	0x07000447, 0x04001451, 0x07c03e47, 0x07000447, 0x04001451,
-	0x07c03e07, 0x07000447, 0x04001451, 0x07c03ec7, 0x07000447,
-	0x04001451, 0x07c03e87, 0x07000447, 0x04001451, 0x09444347,
-	0x0a20c207, 0x07000447, 0x07c01b87, 0x0cc00000, 0x07c03d0d,
-	0x0680c011, 0x06905347, 0x07400447, 0x04001451, 0x0c05e780,
-	0x080c2301, 0x0b20bfc7, 0x0c7dea80, 0x04000407, 0x04000247,
-	0x0c05e600, 0x080c2301, 0x09505247, 0x0fc011c0, 0x095a1247,
-	0x0fc011c0, 0x095c1247, 0x07400449, 0x04001451, 0x0c05e3c0,
-	0x080c2301, 0x0aa0c007, 0x0c7de6c0, 0x00000000, 0x0c05e280,
-	0x080c2301, 0x04000207, 0x0c05e1c0, 0x080c2301, 0x094a5207,
-	0x0fc011c0, 0x09541207, 0x0fc021c0, 0x09562207, 0x07400448,
-	0x04001451, 0x0c05df80, 0x080c2301, 0x04000247, 0x0c05dec0,
-	0x080c2301, 0x09508247, 0x07400449, 0x04001451, 0x0c05dd80,
-	0x080c2301, 0x04000247, 0x0fc011c0, 0x09501247, 0x0fc011c0,
-	0x09521247, 0x0fc011c0, 0x09541247, 0x07400449, 0x064c2907,
-	0x091c21c7, 0x0a60c0c7, 0x0c780580, 0x04001451, 0x098092c9,
-	0x07400449, 0x04001451, 0x0fc011c0, 0x06800149, 0x05401347,
-	0x02009349, 0x07c01d49, 0x0fc01340, 0x094211cd, 0x07400447,
-	0x04001451, 0x0aa1000d, 0x0680000e, 0x0c001f80, 0x06800009,
-	0x0c05d5c0, 0x080c2301, 0x07400447, 0x04001451, 0x07803b87,
-	0x0a404407, 0x07803bc7, 0x09807047, 0x07c03bc7, 0x06af000a,
-	0x06c0470a, 0x054091d0, 0x0200a1ca, 0x06804009, 0x06a0c00b,
-	0x0c05a540, 0x00000000, 0x0c7dd540, 0x00000000, 0x0680c051,
-	0x07000449, 0x04001451, 0x091a11c9, 0x07c02347, 0x0aa0c007,
-	0x06800007, 0x0687ffc7, 0x07c02a07, 0x091c11c9, 0x07c021c7,
-	0x06800808, 0x07000449, 0x04001451, 0x090051c9, 0x07c03ac7,
-	0x09505207, 0x090a51c9, 0x07c03b07, 0x09605207, 0x07802947,
-	0x096a2207, 0x060c2108, 0x091411c9, 0x07c028c7, 0x091621c9,
-	0x07c02907, 0x07000449, 0x04001451, 0x090081c9, 0x0c05cb80,
-	0x00000000, 0x07c02247, 0x091081c9, 0x0c05ca80, 0x00000000,
-	0x07000449, 0x04001451, 0x090081c9, 0x0c05c940, 0x00000000,
-	0x06801008, 0x09505207, 0x060c2108, 0x06801408, 0x09505207,
-	0x060c2108, 0x091011c9, 0x07c02287, 0x091211c9, 0x064e0e08,
-	0x09401207, 0x060e0e08, 0x091411c9, 0x07c02207, 0x0580b1c9,
-	0x0be18047, 0x06800007, 0x07802308, 0x09c08008, 0x0cc00000,
-	0x07c02308, 0x07000449, 0x04001451, 0x090011c9, 0x0680014d,
-	0x05401387, 0x0200d38d, 0x07c01d4d, 0x07802308, 0x09401207,
-	0x07c02308, 0x09021349, 0x0aa2800d, 0x0680000e, 0x06801c09,
-	0x06c00049, 0x060e0209, 0x0c0013c0, 0x06800009, 0x06800009,
-	0x06c00049, 0x060e0209, 0x064e0007, 0x095c91cd, 0x060e0007,
-	0x064e0307, 0x094081ce, 0x060e0307, 0x07000447, 0x04001451,
-	0x0c05bc40, 0x00000000, 0x06801408, 0x09505207, 0x0cc00000,
-	0x060c2108, 0x0ba0c189, 0x0680020c, 0x0680080c, 0x07801d47,
-	0x0b8041c9, 0x04001249, 0x0cc00000, 0x00000000, 0x0540134d,
-	0x0540138e, 0x0fc01200, 0x07400448, 0x04001451, 0x09401348,
-	0x0aac8008, 0x0680020a, 0x0680020b, 0x0ba0c189, 0x068003cc,
-	0x06800fcc, 0x0aa4400b, 0x00000000, 0x0c05b340, 0x080c2301,
-	0x07400447, 0x04001451, 0x0c05b440, 0x00000000, 0x02007287,
-	0x048ff2c7, 0x0a61800b, 0x0aa0cfcc, 0x0b614189, 0x0a6103cc,
-	0x0c7ff780, 0x0980e00e, 0x0400028b, 0x054083cf, 0x0be0c04c,
-	0x094083ca, 0x06c0000f, 0x0aeac00c, 0x0440130c, 0x07801d47,
-	0x0b8031c9, 0x0cc00000, 0x00000000, 0x0c7ff640, 0x04001249,
-	0x0ba0c189, 0x0680020c, 0x0680080c, 0x064e020a, 0x0200a30a,
-	0x06c0004a, 0x060e020a, 0x0ba101c9, 0x04001249, 0x0cc00000,
-	0x00000000, 0x0540134d, 0x0540138e, 0x07801d48, 0x0ac04209,
-	0x06800008, 0x07000448, 0x04001451, 0x09401348, 0x0aab4008,
-	0x0680020a, 0x0680020b, 0x0ba0c189, 0x068003cc, 0x06800fcc,
-	0x0aa3400b, 0x07000447, 0x0c05a7c0, 0x04001451, 0x02007287,
-	0x048ff2c7, 0x0a61800b, 0x0aa0cfcc, 0x0b614189, 0x0a6103cc,
-	0x0c7ff740, 0x0980e00e, 0x0400028b, 0x054083cf, 0x0be1004c,
-	0x094083ca, 0x06c0000f, 0x060e020f, 0x0aeb800c, 0x0440130c,
-	0x0ba0c1c9, 0x0cc00000, 0x00000000, 0x0c7ff6c0, 0x04001249,
-	0x0b210408, 0x00000000, 0x0fc10240, 0x04410208, 0x0cc00000,
-	0x0f800208, 0x0c059e80, 0x080c2301, 0x04001347, 0x0fc081c0,
-	0x0c059d80, 0x080c2301, 0x0c059d00, 0x080c2301, 0x0d07ff0d,
-	0x0fc011c0, 0x0fc051c0, 0x0cc00000, 0x0fc0f1c0, 0x07803c47,
-	0x07803c88, 0x0780174b, 0x07800a4d, 0x07800a8e, 0x07802c49,
-	0x07803a4a, 0x0780390c, 0x07803e8f, 0x07803ed0, 0x07803e11,
-	0x0a409247, 0x0a408288, 0x0a40730b, 0x0a4063cd, 0x0a40540e,
-	0x00000000, 0x07800a07, 0x0a402447, 0x0c7825c0, 0x06800007,
-	0x07c07087, 0x07803bc7, 0x09807087, 0x07c03bc7, 0x069fffc7,
-	0x07c03c49, 0x07c03c8a, 0x07c0174c, 0x07c00a4f, 0x07c00a90,
-	0x07c00a11, 0x0a83f207, 0x0688000a, 0x0c056c80, 0x06c0000a,
-	0x068c000a, 0x06c0470a, 0x06804009, 0x0c0564c0, 0x06b0400b,
-	0x0680044a, 0x06031e0a, 0x0649ce09, 0x0aa10009, 0x00000000,
-	0x0809ce00, 0x08007401, 0x06431e0a, 0x0bee804a, 0x00000000,
-	0x07803a47, 0x0a634047, 0x07807187, 0x06804089, 0x054031c7,
-	0x020091c9, 0x07000247, 0x091011c7, 0x020091c9, 0x0740024a,
-	0x04001249, 0x06801fca, 0x0740024a, 0x07c0178a, 0x07807047,
-	0x07c07187, 0x068003ca, 0x06031e0a, 0x0649ce09, 0x0aa10009,
-	0x00000000, 0x0809ce00, 0x08007401, 0x06431e09, 0x0bee8049,
-	0x00000000, 0x0649ce09, 0x0a6dc009, 0x00000000, 0x0c062900,
-	0x00000000, 0x0649c007, 0x0bef7fc7, 0x07803a47, 0x0a60c047,
-	0x0c780000, 0x00800000, 0x068000c7, 0x0609c007, 0x08007401,
-	0x0c062640, 0x0680001b, 0x0649c007, 0x0bef7fc7, 0x07802c47,
-	0x07803a48, 0x095101c8, 0x07803908, 0x097071c8, 0x07802308,
-	0x09021208, 0x097e11c8, 0x0609c107, 0x07803d07, 0x07802108,
-	0x095e11c8, 0x07800688, 0x094c11c8, 0x07803cc8, 0x09102208,
-	0x095a21c8, 0x07803d48, 0x096101c8, 0x0609c207, 0x07803d87,
-	0x07803dc8, 0x096101c8, 0x0609c307, 0x07803e07, 0x07803e48,
-	0x096101c8, 0x0609c407, 0x07803e87, 0x07803ec8, 0x096101c8,
-	0x0609c507, 0x07801ac7, 0x07801a88, 0x096101c8, 0x0609c607,
-	0x07800d07, 0x0609ca07, 0x078009c7, 0x07800988, 0x09610207,
-	0x0609d108, 0x06800047, 0x0609c007, 0x08007401, 0x06800007,
-	0x06800008, 0x06804009, 0x04001249, 0x07400248, 0x040011c7,
-	0x0baf8607, 0x04008249, 0x0680001b, 0x0649c008, 0x0befbfc8,
-	0x091081c8, 0x07c03187, 0x092081c8, 0x07c07047, 0x093081c8,
-	0x07803cc8, 0x09408207, 0x07c03cc8, 0x06800007, 0x07c071c7,
-	0x07c07207, 0x0649c107, 0x07c078c7, 0x058101c7, 0x07c07907,
-	0x0649c407, 0x07c07947, 0x058101c7, 0x07c07987, 0x07803cc8,
-	0x09008208, 0x07802307, 0x090211c7, 0x054011c7, 0x034081c8,
-	0x07803907, 0x07803189, 0x0b004247, 0x00000000, 0x040001c9,
-	0x07c03907, 0x0b803207, 0x044011c8, 0x07c03907, 0x0cc00000,
+	0x0fc101c0, 0x07400447, 0x04001451, 0x0fc101c0, 0x07400447,
+	0x04001451, 0x0fc011c0, 0x07c00687, 0x0680000e, 0x0fc011c0,
+	0x0aa18007, 0x09401387, 0x0c008100, 0x00000000, 0x090aa207,
+	0x07c02f88, 0x0fc011c0, 0x0aa1c007, 0x09421387, 0x0c007f40,
+	0x00000000, 0x0be0c04e, 0x090aa207, 0x07c02f88, 0x0a20c0ce,
+	0x00000000, 0x0fc011c0, 0x0fc011c0, 0x09441387, 0x0fc011c0,
+	0x09461387, 0x0740044e, 0x04001451, 0x0aa24007, 0x06800188,
+	0x0fc011c0, 0x0c061b00, 0x080c2301, 0x0d07ff88, 0x00000000,
+	0x07400447, 0x04001451, 0x07803b47, 0x0a404407, 0x07803bc7,
+	0x09807007, 0x07c03bc7, 0x068f000a, 0x06c0470a, 0x0540a1d0,
+	0x0200a1ca, 0x06806009, 0x0c05eac0, 0x06a0400b, 0x0c7e1a40,
+	0x00000000, 0x0aa1000a, 0x06804047, 0x0c782140, 0x070001d1,
+	0x06804091, 0x07000447, 0x04001451, 0x07c039c7, 0x09108247,
+	0x07000448, 0x04001451, 0x090081c8, 0x07c03a07, 0x064c2908,
+	0x09c080c8, 0x060c2908, 0x0b60d909, 0x0c780680, 0x080e0000,
+	0x0700044d, 0x04001451, 0x064c2908, 0x090211cd, 0x09461207,
+	0x060c2908, 0x0aa3000d, 0x0680000e, 0x06800009, 0x06c00049,
+	0x060e0209, 0x068001c7, 0x07c01d47, 0x0c0062c0, 0x06800009,
+	0x06800009, 0x06c00049, 0x060e0209, 0x064e0007, 0x096e91cd,
+	0x060e0007, 0x064e0307, 0x095081ce, 0x060e0307, 0x07000449,
+	0x04001451, 0x07c020c9, 0x07000447, 0x04001451, 0x07c02147,
+	0x06800088, 0x0a819207, 0x06800008, 0x0a814207, 0x07000447,
+	0x04001451, 0x07c03a87, 0x07000447, 0x04001451, 0x07c03807,
+	0x07000447, 0x04001451, 0x07c03847, 0x07000447, 0x04001451,
+	0x07c03887, 0x07000447, 0x04001451, 0x07c038c7, 0x07000447,
+	0x04001451, 0x07c03987, 0x0c780100, 0x07000447, 0x04001451,
+	0x07c02187, 0x07000449, 0x04001451, 0x090081c9, 0x07c03907,
+	0x091011c9, 0x07c03947, 0x07000447, 0x04001451, 0x060c0907,
+	0x07c02c47, 0x04401247, 0x07c02c09, 0x07000449, 0x04001451,
+	0x07c02c89, 0x0700044d, 0x04001451, 0x090011cd, 0x0a60c007,
+	0x07c02107, 0x05401249, 0x04000289, 0x07802c48, 0x09610288,
+	0x0609520a, 0x05404289, 0x0968c288, 0x0609080a, 0x0e000248,
+	0x00000000, 0x00000000, 0x0f000200, 0x0a610007, 0x07c03a48,
+	0x0902120d, 0x094211c8, 0x07c02947, 0x090411cd, 0x0aa10007,
+	0x054011c7, 0x07802108, 0x094411c8, 0x07c02307, 0x06800087,
+	0x07802108, 0x02408207, 0x07000447, 0x04001451, 0x07000449,
+	0x04001451, 0x09508247, 0x05401249, 0x07c01a89, 0x07000447,
+	0x04001451, 0x07000449, 0x04001451, 0x09508247, 0x03409209,
+	0x07c01ac9, 0x07000447, 0x04001451, 0x0be0c047, 0x0c780900,
+	0x05801347, 0x05801347, 0x0a22c04d, 0x07000447, 0x04001451,
+	0x07c03d47, 0x0a61ffc7, 0x07000447, 0x04001451, 0x07c03d87,
+	0x07000447, 0x04001451, 0x07c03dc7, 0x07000447, 0x04001451,
+	0x0a238047, 0x09421347, 0x07000447, 0x04001451, 0x07c03e47,
+	0x07000447, 0x04001451, 0x07c03e07, 0x07000447, 0x04001451,
+	0x07c03ec7, 0x07000447, 0x04001451, 0x07c03e87, 0x07000447,
+	0x04001451, 0x09444347, 0x0a20c207, 0x07000447, 0x07c01b87,
+	0x0cc00000, 0x07c03d0d, 0x0680c011, 0x06905347, 0x07400447,
+	0x04001451, 0x0c05e900, 0x080c2301, 0x0b20bfc7, 0x0c7dec00,
+	0x04000407, 0x04000247, 0x0c05e780, 0x080c2301, 0x09505247,
+	0x0fc011c0, 0x095a1247, 0x0fc011c0, 0x095c1247, 0x07400449,
+	0x04001451, 0x0c05e540, 0x080c2301, 0x0aa0c007, 0x0c7de840,
+	0x00000000, 0x0c05e400, 0x080c2301, 0x04000207, 0x0c05e340,
+	0x080c2301, 0x094a5207, 0x0fc011c0, 0x09541207, 0x0fc021c0,
+	0x09562207, 0x07400448, 0x04001451, 0x0c05e100, 0x080c2301,
+	0x04000247, 0x0c05e040, 0x080c2301, 0x09508247, 0x07400449,
+	0x04001451, 0x0c05df00, 0x080c2301, 0x04000247, 0x0fc011c0,
+	0x09501247, 0x0fc011c0, 0x09521247, 0x0fc011c0, 0x09541247,
+	0x07400449, 0x064c2907, 0x091c21c7, 0x0a60c0c7, 0x0c780580,
+	0x04001451, 0x098092c9, 0x07400449, 0x04001451, 0x0fc011c0,
+	0x06800149, 0x05401347, 0x02009349, 0x07c01d49, 0x0fc01340,
+	0x094211cd, 0x07400447, 0x04001451, 0x0aa1000d, 0x0680000e,
+	0x0c001f80, 0x06800009, 0x0c05d740, 0x080c2301, 0x07400447,
+	0x04001451, 0x07803b87, 0x0a404407, 0x07803bc7, 0x09807047,
+	0x07c03bc7, 0x06af000a, 0x06c0470a, 0x054091d0, 0x0200a1ca,
+	0x06804009, 0x06a0c00b, 0x0c05a740, 0x00000000, 0x0c7dd6c0,
+	0x00000000, 0x0680c051, 0x07000449, 0x04001451, 0x091a11c9,
+	0x07c02347, 0x0aa0c007, 0x06800007, 0x0687ffc7, 0x07c02a07,
+	0x091c11c9, 0x07c021c7, 0x06800808, 0x07000449, 0x04001451,
+	0x090051c9, 0x07c03ac7, 0x09505207, 0x090a51c9, 0x07c03b07,
+	0x09605207, 0x07802947, 0x096a2207, 0x060c2108, 0x091411c9,
+	0x07c028c7, 0x091621c9, 0x07c02907, 0x07000449, 0x04001451,
+	0x090081c9, 0x0c05cd00, 0x00000000, 0x07c02247, 0x091081c9,
+	0x0c05cc00, 0x00000000, 0x07000449, 0x04001451, 0x090081c9,
+	0x0c05cac0, 0x00000000, 0x06801008, 0x09505207, 0x060c2108,
+	0x06801408, 0x09505207, 0x060c2108, 0x091011c9, 0x07c02287,
+	0x091211c9, 0x064e0e08, 0x09401207, 0x060e0e08, 0x091411c9,
+	0x07c02207, 0x0580b1c9, 0x0be18047, 0x06800007, 0x07802308,
+	0x09c08008, 0x0cc00000, 0x07c02308, 0x07000449, 0x04001451,
+	0x090011c9, 0x0680014d, 0x05401387, 0x0200d38d, 0x07c01d4d,
+	0x07802308, 0x09401207, 0x07c02308, 0x09021349, 0x0aa2800d,
+	0x0680000e, 0x06801c09, 0x06c00049, 0x060e0209, 0x0c0013c0,
+	0x06800009, 0x06800009, 0x06c00049, 0x060e0209, 0x064e0007,
+	0x095c91cd, 0x060e0007, 0x064e0307, 0x094081ce, 0x060e0307,
+	0x07000447, 0x04001451, 0x0c05bdc0, 0x00000000, 0x06801408,
+	0x09505207, 0x0cc00000, 0x060c2108, 0x0ba0c189, 0x0680020c,
+	0x0680080c, 0x07801d47, 0x0b8041c9, 0x04001249, 0x0cc00000,
+	0x00000000, 0x0540134d, 0x0540138e, 0x0fc01200, 0x07400448,
+	0x04001451, 0x09401348, 0x0aac8008, 0x0680020a, 0x0680020b,
+	0x0ba0c189, 0x068003cc, 0x06800fcc, 0x0aa4400b, 0x00000000,
+	0x0c05b4c0, 0x080c2301, 0x07400447, 0x04001451, 0x0c05b5c0,
+	0x00000000, 0x02007287, 0x048ff2c7, 0x0a61800b, 0x0aa0cfcc,
+	0x0b614189, 0x0a6103cc, 0x0c7ff780, 0x0980e00e, 0x0400028b,
+	0x054083cf, 0x0be0c04c, 0x094083ca, 0x06c0000f, 0x0aeac00c,
+	0x0440130c, 0x07801d47, 0x0b8031c9, 0x0cc00000, 0x00000000,
+	0x0c7ff640, 0x04001249, 0x0ba0c189, 0x0680020c, 0x0680080c,
+	0x064e020a, 0x0200a30a, 0x06c0004a, 0x060e020a, 0x0ba101c9,
+	0x04001249, 0x0cc00000, 0x00000000, 0x0540134d, 0x0540138e,
+	0x07801d48, 0x0ac04209, 0x06800008, 0x07000448, 0x04001451,
+	0x09401348, 0x0aab4008, 0x0680020a, 0x0680020b, 0x0ba0c189,
+	0x068003cc, 0x06800fcc, 0x0aa3400b, 0x07000447, 0x0c05a940,
+	0x04001451, 0x02007287, 0x048ff2c7, 0x0a61800b, 0x0aa0cfcc,
+	0x0b614189, 0x0a6103cc, 0x0c7ff740, 0x0980e00e, 0x0400028b,
+	0x054083cf, 0x0be1004c, 0x094083ca, 0x06c0000f, 0x060e020f,
+	0x0aeb800c, 0x0440130c, 0x0ba0c1c9, 0x0cc00000, 0x00000000,
+	0x0c7ff6c0, 0x04001249, 0x0b210408, 0x00000000, 0x0fc10240,
+	0x04410208, 0x0cc00000, 0x0f800208, 0x0c05a000, 0x080c2301,
+	0x04001347, 0x0fc081c0, 0x0c059f00, 0x080c2301, 0x0c059e80,
+	0x080c2301, 0x0d07ff0d, 0x0fc011c0, 0x0fc051c0, 0x0cc00000,
+	0x0fc0f1c0, 0x07803c47, 0x07803c88, 0x0780174b, 0x07800a4d,
+	0x07800a8e, 0x07802c49, 0x07803a4a, 0x0780390c, 0x07803e8f,
+	0x07803ed0, 0x07803e11, 0x0a409247, 0x0a408288, 0x0a40730b,
+	0x0a4063cd, 0x0a40540e, 0x00000000, 0x07800a07, 0x0a402447,
+	0x0c782640, 0x06800007, 0x07c07087, 0x07803bc7, 0x09807087,
+	0x07c03bc7, 0x069fffc7, 0x07c03c49, 0x07c03c8a, 0x07c0174c,
+	0x07c00a4f, 0x07c00a90, 0x07c00a11, 0x0a841207, 0x0688000a,
+	0x0c056e80, 0x06c0000a, 0x068c000a, 0x06c0470a, 0x06804009,
+	0x0c0566c0, 0x06b0400b, 0x0680044a, 0x06031e0a, 0x0649ce09,
+	0x0aa10009, 0x00000000, 0x0809ce00, 0x08007401, 0x06431e0a,
+	0x0bee804a, 0x00000000, 0x07802087, 0x0a63c087, 0x07803a47,
+	0x0a634047, 0x07807187, 0x06804089, 0x054031c7, 0x020091c9,
+	0x07000247, 0x091011c7, 0x020091c9, 0x0740024a, 0x04001249,
+	0x06801fca, 0x0740024a, 0x07c0178a, 0x07807047, 0x07c07187,
+	0x068003ca, 0x06031e0a, 0x0649ce09, 0x0aa10009, 0x00000000,
+	0x0809ce00, 0x08007401, 0x06431e09, 0x0bee8049, 0x00000000,
+	0x0649ce09, 0x0a6dc009, 0x00000000, 0x0c062980, 0x00000000,
+	0x0649c007, 0x0bef7fc7, 0x07803a47, 0x0a60c047, 0x0c780000,
+	0x00800000, 0x068000c7, 0x0609c007, 0x08007401, 0x0c0626c0,
+	0x0680001b, 0x0649c007, 0x0bef7fc7, 0x07802c47, 0x07803a48,
+	0x095101c8, 0x07803908, 0x097071c8, 0x07802308, 0x09021208,
+	0x097e11c8, 0x0609c107, 0x07803d07, 0x07802108, 0x095e11c8,
+	0x07800688, 0x094c11c8, 0x07803cc8, 0x09102208, 0x095a21c8,
+	0x07803d48, 0x096101c8, 0x0609c207, 0x07803d87, 0x07803dc8,
+	0x096101c8, 0x0609c307, 0x07803e07, 0x07803e48, 0x096101c8,
+	0x0609c407, 0x07803e87, 0x07803ec8, 0x096101c8, 0x0609c507,
+	0x07801ac7, 0x07801a88, 0x096101c8, 0x0609c607, 0x07800d07,
+	0x0609ca07, 0x078009c7, 0x07800988, 0x09610207, 0x0609d108,
+	0x06800047, 0x0609c007, 0x08007401, 0x06800007, 0x06800008,
+	0x06804009, 0x04001249, 0x07400248, 0x040011c7, 0x0baf8607,
+	0x04008249, 0x0680001b, 0x0649c008, 0x0befbfc8, 0x091081c8,
+	0x07c03187, 0x092081c8, 0x07c07047, 0x093081c8, 0x07803cc8,
+	0x09408207, 0x07c03cc8, 0x06800007, 0x07c071c7, 0x07c07207,
+	0x0649c107, 0x07c078c7, 0x058101c7, 0x07c07907, 0x0649c407,
+	0x07c07947, 0x058101c7, 0x07c07987, 0x07803cc8, 0x09008208,
+	0x07802307, 0x090211c7, 0x054011c7, 0x034081c8, 0x07803907,
+	0x07803189, 0x0b004247, 0x00000000, 0x040001c9, 0x07c03907,
+	0x0b803207, 0x044011c8, 0x07c03907, 0x0cc00000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264list_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264list_linux.h
index 80d76d3..c85d9f8 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264list_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264list_linux.h
@@ -11,142 +11,142 @@ static const u32 MicroCode[] __initconst = {
 	0x0b80324a, 0x0c7801c0, 0x09808688, 0x0400128a, 0x098083c8,
 	0x0a40324a, 0x0440128a, 0x098086c8, 0x0aa1000a, 0x09308287,
 	0x0a60c00a, 0x0400128a, 0x09808388, 0x0b80324a, 0x00000000,
-	0x098081c8, 0x0c780500, 0x060e0408, 0x0a614248, 0x00000000,
-	0x0c009240, 0x00000000, 0x0c780380, 0x0a62c288, 0x06431f20,
-	0x06433f21, 0x0e000860, 0x00000000, 0x00000000, 0x0f000800,
-	0x06031f20, 0x0f010840, 0x0c780100, 0x06033f21, 0x0c780080,
-	0x00000000, 0x08031e00, 0x0cc00000, 0x00400000, 0x0680400f,
-	0x0680a00e, 0x0680ec0d, 0x0680f60c, 0x0780704b, 0x0680000a,
-	0x06800009, 0x06800008, 0x0780776f, 0x07807780, 0x09610bc0,
-	0x0780736e, 0x078020c0, 0x06800041, 0x0342d001, 0x07807300,
-	0x06800081, 0x0b831040, 0x05403c4a, 0x02031c4f, 0x04001c71,
-	0x07000c44, 0x06800c00, 0x0bc25004, 0x09042004, 0x068000c1,
-	0x0a422040, 0x09101004, 0x04001c31, 0x02030030, 0x02030030,
-	0x07000c2c, 0x04001c30, 0x07000c00, 0x09610b00, 0x04005c71,
-	0x07000c6b, 0x0b003bab, 0x00000000, 0x0242bb6b, 0x0202a209,
-	0x05402c2a, 0x02030c0e, 0x07400c0a, 0x068000c0, 0x04001c30,
-	0x07400c00, 0x04001c30, 0x07400c2b, 0x0581002b, 0x04001c30,
-	0x07400c00, 0x0ac05bec, 0x0203024d, 0x07400c2a, 0x04001249,
-	0x0c780100, 0x0203020c, 0x07400c2a, 0x04001208, 0x0400128a,
-	0x0b8d52ca, 0x02000209, 0x07c070c9, 0x0cc00000, 0x07c07100,
-	0x0aa14040, 0x06800047, 0x06800006, 0x0c780100, 0x00000000,
-	0x06800007, 0x06800046, 0x05403c4a, 0x02031c4f, 0x04001c71,
-	0x07000c44, 0x09101004, 0x04001c31, 0x02030030, 0x02030030,
-	0x07000c2c, 0x04001c30, 0x07000c00, 0x09610b00, 0x04005c71,
-	0x07000c6b, 0x0b003bab, 0x00000000, 0x0242bb6b, 0x0be60404,
-	0x0a25c104, 0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a,
-	0x06800040, 0x04001c30, 0x07400c00, 0x0540102b, 0x020001c0,
-	0x04001c30, 0x07400c00, 0x05810000, 0x04001c30, 0x07400c00,
+	0x098081c8, 0x0c780240, 0x060e0408, 0x0a614248, 0x00000000,
+	0x0c008f80, 0x00000000, 0x0c7800c0, 0x0c780080, 0x00000000,
+	0x08031e00, 0x0cc00000, 0x00400000, 0x0680400f, 0x0680a00e,
+	0x0680ec0d, 0x0680f60c, 0x0780704b, 0x0680000a, 0x06800009,
+	0x06800008, 0x0780776f, 0x07807780, 0x09610bc0, 0x0780736e,
+	0x078020c0, 0x06800041, 0x0342d001, 0x07807300, 0x06800081,
+	0x0b831040, 0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44,
+	0x06800c00, 0x0bc25004, 0x09042004, 0x068000c1, 0x0a422040,
+	0x09101004, 0x04001c31, 0x02030030, 0x02030030, 0x07000c2c,
+	0x04001c30, 0x07000c00, 0x09610b00, 0x04005c71, 0x07000c6b,
+	0x0b003bab, 0x00000000, 0x0242bb6b, 0x0202a209, 0x05402c2a,
+	0x02030c0e, 0x07400c0a, 0x068000c0, 0x04001c30, 0x07400c00,
+	0x04001c30, 0x07400c2b, 0x0581002b, 0x04001c30, 0x07400c00,
 	0x0ac05bec, 0x0203024d, 0x07400c2a, 0x04001249, 0x0c780100,
-	0x0203020c, 0x07400c2a, 0x04001208, 0x0be60804, 0x0a25c204,
-	0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a, 0x06800080,
-	0x04001c30, 0x07400c00, 0x0540102b, 0x02000180, 0x04001c30,
+	0x0203020c, 0x07400c2a, 0x04001208, 0x0400128a, 0x0b8d52ca,
+	0x02000209, 0x07c070c9, 0x0cc00000, 0x07c07100, 0x0aa14040,
+	0x06800047, 0x06800006, 0x0c780100, 0x00000000, 0x06800007,
+	0x06800046, 0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44,
+	0x09101004, 0x04001c31, 0x02030030, 0x02030030, 0x07000c2c,
+	0x04001c30, 0x07000c00, 0x09610b00, 0x04005c71, 0x07000c6b,
+	0x0b003bab, 0x00000000, 0x0242bb6b, 0x0be60404, 0x0a25c104,
+	0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a, 0x06800040,
+	0x04001c30, 0x07400c00, 0x0540102b, 0x020001c0, 0x04001c30,
 	0x07400c00, 0x05810000, 0x04001c30, 0x07400c00, 0x0ac05bec,
 	0x0203024d, 0x07400c2a, 0x04001249, 0x0c780100, 0x0203020c,
-	0x07400c2a, 0x04001208, 0x0400128a, 0x0b8be2ca, 0x02000209,
-	0x07c070c9, 0x0cc00000, 0x07c07100, 0x0680400f, 0x0680a00e,
-	0x0680ec0d, 0x0780704b, 0x0680000a, 0x07807109, 0x07807300,
-	0x0ba6c080, 0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44,
-	0x09082004, 0x0a6440c0, 0x04006c71, 0x07000c6b, 0x05402c09,
-	0x02030c0e, 0x07400c0a, 0x068001c0, 0x04001c30, 0x07400c00,
-	0x04001c30, 0x07400c2b, 0x0581002b, 0x04001c30, 0x07400c00,
-	0x0203024d, 0x07400c09, 0x04001249, 0x0400128a, 0x0b8e92ca,
-	0x0cc00000, 0x07c07149, 0x0aa14040, 0x06800047, 0x06800006,
-	0x0c780100, 0x00000000, 0x06800007, 0x06800046, 0x05403c4a,
-	0x02031c4f, 0x04001c71, 0x07000c44, 0x04006c71, 0x07000c6b,
-	0x0a244404, 0x05402c09, 0x02030c0e, 0x07400c0a, 0x06800140,
-	0x04001c30, 0x07400c00, 0x0540102b, 0x020001c0, 0x04001c30,
-	0x07400c00, 0x05810000, 0x04001c30, 0x07400c00, 0x0203024d,
-	0x07400c09, 0x04001249, 0x0a244804, 0x05402c09, 0x02030c0e,
-	0x07400c0a, 0x06800180, 0x04001c30, 0x07400c00, 0x0540102b,
-	0x02000180, 0x04001c30, 0x07400c00, 0x05810000, 0x04001c30,
-	0x07400c00, 0x0203024d, 0x07400c09, 0x04001249, 0x0400128a,
-	0x0b8d72ca, 0x0cc00000, 0x07c07149, 0x0680ec0f, 0x0680f60e,
-	0x0780710a, 0x078070c9, 0x06800008, 0x0240a24a, 0x0200e28e,
-	0x0a60c009, 0x0cc00000, 0x00000000, 0x070003c0, 0x07400380,
-	0x040013cf, 0x0400138e, 0x04001208, 0x0b8fb248, 0x0cc00000,
-	0x00000000, 0x0680ec0f, 0x0680f60e, 0x0780710a, 0x078070c9,
-	0x06800008, 0x0240a24a, 0x0200f24f, 0x0a60c00a, 0x0cc00000,
-	0x00000000, 0x07000380, 0x074003c0, 0x040013cf, 0x0400138e,
-	0x04001208, 0x0b8fb288, 0x0cc00000, 0x00000000, 0x0680ec0f,
-	0x0680f60e, 0x0780710a, 0x07807149, 0x0200f28f, 0x0200e28e,
-	0x0a40324a, 0x0cc00000, 0x00000000, 0x070003c0, 0x07400380,
-	0x040013cf, 0x0400138e, 0x0400128a, 0x0b8fb24a, 0x0cc00000,
-	0x00000000, 0x0b60808e, 0x0c780e00, 0x0680a00c, 0x0680400b,
-	0x0680000a, 0x0a83438a, 0x0400124a, 0x0202f28f, 0x07000bee,
-	0x0540222e, 0x0200820c, 0x04002208, 0x0700022d, 0x04001208,
-	0x07000200, 0x09610b40, 0x0a814389, 0x0202c24f, 0x07000b2b,
-	0x0540222b, 0x0200820c, 0x04002208, 0x0700022a, 0x04001208,
-	0x07000200, 0x09610a80, 0x0a60c00d, 0x0b807aad, 0x0c7800c0,
-	0x0ac05aad, 0x00000000, 0x07400b2e, 0x04000bab, 0x04000b6a,
-	0x04001249, 0x0c7ffb40, 0x07807300, 0x0b644080, 0x0a24004a,
-	0x0540222e, 0x0200820c, 0x04002208, 0x07000207, 0x0a22c047,
-	0x04401b6f, 0x07000b6c, 0x0540222c, 0x0200820c, 0x04002208,
-	0x07000207, 0x0be10047, 0x00000000, 0x07400b6e, 0x04000bac,
-	0x07400bee, 0x0400128a, 0x0c7ff340, 0x0cc00000, 0x00000000,
-	0x0b60808e, 0x0c781680, 0x0680a00c, 0x0680400b, 0x0680000a,
-	0x0a85638a, 0x0400124a, 0x0202f28f, 0x07000bee, 0x0540222e,
-	0x0200820c, 0x07000207, 0x04001208, 0x07000206, 0x054031c7,
-	0x020071cb, 0x09002146, 0x0a6280c5, 0x00000000, 0x040011c7,
-	0x070001c4, 0x09101c44, 0x040011c7, 0x02007c47, 0x02007c47,
-	0x0c780100, 0x00000000, 0x02007147, 0x02007147, 0x070001ed,
-	0x040011c7, 0x070001c0, 0x09610b40, 0x0a825389, 0x0202c24f,
-	0x07000b2b, 0x0540222b, 0x0200820c, 0x07000207, 0x04001208,
-	0x07000206, 0x054031c7, 0x020071cb, 0x09002146, 0x0a6280c5,
-	0x00000000, 0x040011c7, 0x070001c4, 0x09101c44, 0x040011c7,
-	0x02007c47, 0x02007c47, 0x0c780100, 0x00000000, 0x02007147,
-	0x02007147, 0x070001ea, 0x040011c7, 0x070001c0, 0x09610a80,
-	0x0a60c00d, 0x0b807aad, 0x0c7800c0, 0x0ac05aad, 0x00000000,
-	0x07400b2e, 0x04000bab, 0x04000b6a, 0x04001249, 0x0c7ff700,
-	0x07807300, 0x0b644080, 0x0a24004a, 0x0540222e, 0x0200820c,
-	0x04002208, 0x07000207, 0x0a22c047, 0x04401b6f, 0x07000b6c,
-	0x0540222c, 0x0200820c, 0x04002208, 0x07000207, 0x0be10047,
-	0x00000000, 0x07400b6e, 0x04000bac, 0x07400bee, 0x0400128a,
-	0x0c7feac0, 0x0cc00000, 0x00000000, 0x0400120a, 0x0200720f,
-	0x070001c9, 0x05402189, 0x0200618c, 0x04002186, 0x07000185,
-	0x09001005, 0x0a4092c0, 0x04401c47, 0x07000c40, 0x074001c0,
-	0x04401208, 0x0acfc288, 0x040001f1, 0x0cc00000, 0x074001c9,
-	0x04001208, 0x0b8ef388, 0x0cc00000, 0x00000000, 0x0780710e,
-	0x0440134e, 0x0680a00c, 0x0680000a, 0x0b60808e, 0x0c7804c0,
-	0x0200928f, 0x07000248, 0x054021c8, 0x020071cc, 0x040021c7,
-	0x070001c6, 0x0be1804a, 0x0be24046, 0x00000000, 0x0c07f700,
-	0x0680004b, 0x0c780140, 0x0a210046, 0x00000000, 0x0c07f5c0,
-	0x0680000b, 0x0400128a, 0x0b8ef34a, 0x0cc00000, 0x00000000,
-	0x06800008, 0x0700040a, 0x0200720f, 0x070001c9, 0x05402189,
-	0x020061af, 0x04001186, 0x07000185, 0x09041005, 0x0a418a80,
-	0x04001186, 0x07000185, 0x04001186, 0x07000180, 0x09610140,
-	0x0a412305, 0x0a80e348, 0x0ac07348, 0x00000000, 0x0200734f,
-	0x0a80a34a, 0x0400128a, 0x0440120a, 0x0200720f, 0x04401c47,
-	0x07000c40, 0x074001c0, 0x04401208, 0x0acfc348, 0x040001f1,
-	0x074001c9, 0x0cc00000, 0x0740040a, 0x04001208, 0x0b8e0288,
-	0x0cc00000, 0x00000000, 0x0680a02f, 0x078020c0, 0x06800041,
-	0x0342e001, 0x0780736d, 0x07807300, 0x0b614080, 0x00000000,
-	0x05401bae, 0x05401b6d, 0x04001b6d, 0x0242cbad, 0x04000aed,
-	0x0680000d, 0x0680002a, 0x07000380, 0x0400138e, 0x0aa10000,
-	0x0aa30040, 0x0aa50080, 0x0c780680, 0x07000380, 0x0400138e,
-	0x04001000, 0x0242b02b, 0x0b411b2b, 0x0400032b, 0x0202bbab,
-	0x0c780380, 0x0400032b, 0x07000380, 0x0400138e, 0x04001000,
-	0x0202b02b, 0x0b808b6b, 0x0400032b, 0x0242bbab, 0x0c780140,
-	0x0400032b, 0x0680006a, 0x0700038c, 0x0400138e, 0x0c07ec40,
-	0x00000000, 0x0c7ff880, 0x0400134d, 0x0cc00000, 0x00000000,
-	0x0c077280, 0x00000000, 0x0c079600, 0x00000000, 0x07802080,
-	0x0aa64180, 0x00000000, 0x0c07ae80, 0x00000000, 0x07807140,
-	0x07c07240, 0x0680ec0f, 0x0780710e, 0x0680004d, 0x0c07b580,
+	0x07400c2a, 0x04001208, 0x0be60804, 0x0a25c204, 0x0202a209,
+	0x05402c2a, 0x02030c0e, 0x07400c0a, 0x06800080, 0x04001c30,
+	0x07400c00, 0x0540102b, 0x02000180, 0x04001c30, 0x07400c00,
+	0x05810000, 0x04001c30, 0x07400c00, 0x0ac05bec, 0x0203024d,
+	0x07400c2a, 0x04001249, 0x0c780100, 0x0203020c, 0x07400c2a,
+	0x04001208, 0x0400128a, 0x0b8be2ca, 0x02000209, 0x07c070c9,
+	0x0cc00000, 0x07c07100, 0x0680400f, 0x0680a00e, 0x0680ec0d,
+	0x0780704b, 0x0680000a, 0x07807109, 0x07807300, 0x0ba6c080,
+	0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44, 0x09082004,
+	0x0a6440c0, 0x04006c71, 0x07000c6b, 0x05402c09, 0x02030c0e,
+	0x07400c0a, 0x068001c0, 0x04001c30, 0x07400c00, 0x04001c30,
+	0x07400c2b, 0x0581002b, 0x04001c30, 0x07400c00, 0x0203024d,
+	0x07400c09, 0x04001249, 0x0400128a, 0x0b8e92ca, 0x0cc00000,
+	0x07c07149, 0x0aa14040, 0x06800047, 0x06800006, 0x0c780100,
+	0x00000000, 0x06800007, 0x06800046, 0x05403c4a, 0x02031c4f,
+	0x04001c71, 0x07000c44, 0x04006c71, 0x07000c6b, 0x0a244404,
+	0x05402c09, 0x02030c0e, 0x07400c0a, 0x06800140, 0x04001c30,
+	0x07400c00, 0x0540102b, 0x020001c0, 0x04001c30, 0x07400c00,
+	0x05810000, 0x04001c30, 0x07400c00, 0x0203024d, 0x07400c09,
+	0x04001249, 0x0a244804, 0x05402c09, 0x02030c0e, 0x07400c0a,
+	0x06800180, 0x04001c30, 0x07400c00, 0x0540102b, 0x02000180,
+	0x04001c30, 0x07400c00, 0x05810000, 0x04001c30, 0x07400c00,
+	0x0203024d, 0x07400c09, 0x04001249, 0x0400128a, 0x0b8d72ca,
+	0x0cc00000, 0x07c07149, 0x0680ec0f, 0x0680f60e, 0x0780710a,
+	0x078070c9, 0x06800008, 0x0240a24a, 0x0200e28e, 0x0a60c009,
+	0x0cc00000, 0x00000000, 0x070003c0, 0x07400380, 0x040013cf,
+	0x0400138e, 0x04001208, 0x0b8fb248, 0x0cc00000, 0x00000000,
+	0x0680ec0f, 0x0680f60e, 0x0780710a, 0x078070c9, 0x06800008,
+	0x0240a24a, 0x0200f24f, 0x0a60c00a, 0x0cc00000, 0x00000000,
+	0x07000380, 0x074003c0, 0x040013cf, 0x0400138e, 0x04001208,
+	0x0b8fb288, 0x0cc00000, 0x00000000, 0x0680ec0f, 0x0680f60e,
+	0x0780710a, 0x07807149, 0x0200f28f, 0x0200e28e, 0x0a40324a,
+	0x0cc00000, 0x00000000, 0x070003c0, 0x07400380, 0x040013cf,
+	0x0400138e, 0x0400128a, 0x0b8fb24a, 0x0cc00000, 0x00000000,
+	0x0b60808e, 0x0c780e00, 0x0680a00c, 0x0680400b, 0x0680000a,
+	0x0a83438a, 0x0400124a, 0x0202f28f, 0x07000bee, 0x0540222e,
+	0x0200820c, 0x04002208, 0x0700022d, 0x04001208, 0x07000200,
+	0x09610b40, 0x0a814389, 0x0202c24f, 0x07000b2b, 0x0540222b,
+	0x0200820c, 0x04002208, 0x0700022a, 0x04001208, 0x07000200,
+	0x09610a80, 0x0a60c00d, 0x0b807aad, 0x0c7800c0, 0x0ac05aad,
+	0x00000000, 0x07400b2e, 0x04000bab, 0x04000b6a, 0x04001249,
+	0x0c7ffb40, 0x07807300, 0x0b644080, 0x0a24004a, 0x0540222e,
+	0x0200820c, 0x04002208, 0x07000207, 0x0a22c047, 0x04401b6f,
+	0x07000b6c, 0x0540222c, 0x0200820c, 0x04002208, 0x07000207,
+	0x0be10047, 0x00000000, 0x07400b6e, 0x04000bac, 0x07400bee,
+	0x0400128a, 0x0c7ff340, 0x0cc00000, 0x00000000, 0x0b60808e,
+	0x0c781680, 0x0680a00c, 0x0680400b, 0x0680000a, 0x0a85638a,
+	0x0400124a, 0x0202f28f, 0x07000bee, 0x0540222e, 0x0200820c,
+	0x07000207, 0x04001208, 0x07000206, 0x054031c7, 0x020071cb,
+	0x09002146, 0x0a6280c5, 0x00000000, 0x040011c7, 0x070001c4,
+	0x09101c44, 0x040011c7, 0x02007c47, 0x02007c47, 0x0c780100,
+	0x00000000, 0x02007147, 0x02007147, 0x070001ed, 0x040011c7,
+	0x070001c0, 0x09610b40, 0x0a825389, 0x0202c24f, 0x07000b2b,
+	0x0540222b, 0x0200820c, 0x07000207, 0x04001208, 0x07000206,
+	0x054031c7, 0x020071cb, 0x09002146, 0x0a6280c5, 0x00000000,
+	0x040011c7, 0x070001c4, 0x09101c44, 0x040011c7, 0x02007c47,
+	0x02007c47, 0x0c780100, 0x00000000, 0x02007147, 0x02007147,
+	0x070001ea, 0x040011c7, 0x070001c0, 0x09610a80, 0x0a60c00d,
+	0x0b807aad, 0x0c7800c0, 0x0ac05aad, 0x00000000, 0x07400b2e,
+	0x04000bab, 0x04000b6a, 0x04001249, 0x0c7ff700, 0x07807300,
+	0x0b644080, 0x0a24004a, 0x0540222e, 0x0200820c, 0x04002208,
+	0x07000207, 0x0a22c047, 0x04401b6f, 0x07000b6c, 0x0540222c,
+	0x0200820c, 0x04002208, 0x07000207, 0x0be10047, 0x00000000,
+	0x07400b6e, 0x04000bac, 0x07400bee, 0x0400128a, 0x0c7feac0,
+	0x0cc00000, 0x00000000, 0x0400120a, 0x0200720f, 0x070001c9,
+	0x05402189, 0x0200618c, 0x04002186, 0x07000185, 0x09001005,
+	0x0a4092c0, 0x04401c47, 0x07000c40, 0x074001c0, 0x04401208,
+	0x0acfc288, 0x040001f1, 0x0cc00000, 0x074001c9, 0x04001208,
+	0x0b8ef388, 0x0cc00000, 0x00000000, 0x0780710e, 0x0440134e,
+	0x0680a00c, 0x0680000a, 0x0b60808e, 0x0c7804c0, 0x0200928f,
+	0x07000248, 0x054021c8, 0x020071cc, 0x040021c7, 0x070001c6,
+	0x0be1804a, 0x0be24046, 0x00000000, 0x0c07f700, 0x0680004b,
+	0x0c780140, 0x0a210046, 0x00000000, 0x0c07f5c0, 0x0680000b,
+	0x0400128a, 0x0b8ef34a, 0x0cc00000, 0x00000000, 0x06800008,
+	0x0700040a, 0x0200720f, 0x070001c9, 0x05402189, 0x020061af,
+	0x04001186, 0x07000185, 0x09041005, 0x0a418a80, 0x04001186,
+	0x07000185, 0x04001186, 0x07000180, 0x09610140, 0x0a412305,
+	0x0a80e348, 0x0ac07348, 0x00000000, 0x0200734f, 0x0a80a34a,
+	0x0400128a, 0x0440120a, 0x0200720f, 0x04401c47, 0x07000c40,
+	0x074001c0, 0x04401208, 0x0acfc348, 0x040001f1, 0x074001c9,
+	0x0cc00000, 0x0740040a, 0x04001208, 0x0b8e0288, 0x0cc00000,
+	0x00000000, 0x0680a02f, 0x078020c0, 0x06800041, 0x0342e001,
+	0x0780736d, 0x07807300, 0x0b614080, 0x00000000, 0x05401bae,
+	0x05401b6d, 0x04001b6d, 0x0242cbad, 0x04000aed, 0x0680000d,
+	0x0680002a, 0x07000380, 0x0400138e, 0x0aa10000, 0x0aa30040,
+	0x0aa50080, 0x0c780680, 0x07000380, 0x0400138e, 0x04001000,
+	0x0242b02b, 0x0b411b2b, 0x0400032b, 0x0202bbab, 0x0c780380,
+	0x0400032b, 0x07000380, 0x0400138e, 0x04001000, 0x0202b02b,
+	0x0b808b6b, 0x0400032b, 0x0242bbab, 0x0c780140, 0x0400032b,
+	0x0680006a, 0x0700038c, 0x0400138e, 0x0c07ec40, 0x00000000,
+	0x0c7ff880, 0x0400134d, 0x0cc00000, 0x00000000, 0x0c077280,
+	0x00000000, 0x0c079600, 0x00000000, 0x07802080, 0x0aa64180,
+	0x00000000, 0x0c07ae80, 0x00000000, 0x07807140, 0x07c07240,
+	0x0680ec0f, 0x0780710e, 0x0680004d, 0x0c07b580, 0x00000000,
+	0x0680ec0f, 0x0780714e, 0x07807100, 0x0200f00f, 0x0240e00e,
+	0x0680000d, 0x0c07b380, 0x00000000, 0x0680ec0f, 0x0680c00e,
+	0x0c07ed80, 0x06807250, 0x0cc00000, 0x00000000, 0x0680ec0f,
+	0x078070ce, 0x0680004d, 0x0c07bf80, 0x00000000, 0x0680f60f,
+	0x0780710e, 0x078070c0, 0x0240e00e, 0x0680000d, 0x0c07bdc0,
 	0x00000000, 0x0680ec0f, 0x0780714e, 0x07807100, 0x0200f00f,
-	0x0240e00e, 0x0680000d, 0x0c07b380, 0x00000000, 0x0680ec0f,
-	0x0680c00e, 0x0c07ed80, 0x06807250, 0x0cc00000, 0x00000000,
-	0x0680ec0f, 0x078070ce, 0x0680004d, 0x0c07bf80, 0x00000000,
-	0x0680f60f, 0x0780710e, 0x078070c0, 0x0240e00e, 0x0680000d,
-	0x0c07bdc0, 0x00000000, 0x0680ec0f, 0x0780714e, 0x07807100,
-	0x0200f00f, 0x0240e00e, 0x0680000d, 0x0c07ad00, 0x00000000,
-	0x0c07a3c0, 0x00000000, 0x0c079ec0, 0x00000000, 0x0c07a740,
-	0x00000000, 0x07807140, 0x07c07240, 0x07c07280, 0x07807300,
-	0x0b618080, 0x00000000, 0x0c07d4c0, 0x0680ec0f, 0x0c07d440,
-	0x0680f60f, 0x078070c0, 0x07807101, 0x07807170, 0x0ba280b0,
-	0x0aa0c000, 0x0a802040, 0x0c7801c0, 0x0680f60f, 0x0400138f,
-	0x070003c0, 0x07000381, 0x07400380, 0x074003c1, 0x0680ec0f,
-	0x0680c00e, 0x0c07dfc0, 0x06807250, 0x0680f60f, 0x0680d08e,
-	0x0c07dec0, 0x06807290, 0x0cc00000, 0x00000000, 0x00000000,
+	0x0240e00e, 0x0680000d, 0x0c07ad00, 0x00000000, 0x0c07a3c0,
+	0x00000000, 0x0c079ec0, 0x00000000, 0x0c07a740, 0x00000000,
+	0x07807140, 0x07c07240, 0x07c07280, 0x07807300, 0x0b618080,
+	0x00000000, 0x0c07d4c0, 0x0680ec0f, 0x0c07d440, 0x0680f60f,
+	0x078070c0, 0x07807101, 0x07807170, 0x0ba280b0, 0x0aa0c000,
+	0x0a802040, 0x0c7801c0, 0x0680f60f, 0x0400138f, 0x070003c0,
+	0x07000381, 0x07400380, 0x074003c1, 0x0680ec0f, 0x0680c00e,
+	0x0c07dfc0, 0x06807250, 0x0680f60f, 0x0680d08e, 0x0c07dec0,
+	0x06807290, 0x0cc00000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264mmc_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264mmc_linux.h
index 9fb6d49..6e2d3c9 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264mmc_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264mmc_linux.h
@@ -1,15 +1,13 @@
 static const u32 MicroCode[] __initconst = {
 	0x06bfff40, 0x06032400, 0x00400000, 0x0c780000, 0x00000000,
-	0x09027207, 0x0a6140c8, 0x00000000, 0x0c00d600, 0x00000000,
-	0x0c780540, 0x0a614148, 0x00000000, 0x0c003cc0, 0x00000000,
-	0x0c780400, 0x0a614188, 0x00000000, 0x0c006c40, 0x00000000,
-	0x0c7802c0, 0x0a6141c8, 0x00000000, 0x0c007800, 0x00000000,
-	0x0c780180, 0x0a628208, 0x00000000, 0x0c000ec0, 0x00000000,
+	0x09027207, 0x0a6140c8, 0x00000000, 0x0c00d740, 0x00000000,
+	0x0c780540, 0x0a614148, 0x00000000, 0x0c003a00, 0x00000000,
+	0x0c780400, 0x0a614188, 0x00000000, 0x0c006d40, 0x00000000,
+	0x0c7802c0, 0x0a6141c8, 0x00000000, 0x0c007980, 0x00000000,
+	0x0c780180, 0x0a628208, 0x00000000, 0x0c000c40, 0x00000000,
 	0x00000000, 0x08031e00, 0x0cc00000, 0x00400000, 0x0c7ff8c0,
-	0x06431e07, 0x0a62c288, 0x06431f20, 0x06433f21, 0x0e000860,
-	0x00000000, 0x00000000, 0x0f000800, 0x06031f20, 0x0f010840,
-	0x0c7ffc80, 0x06033f21, 0x0aa18000, 0x07800af1, 0x04001c71,
-	0x09010c71, 0x0a610031, 0x00000000, 0x07c00ac0, 0x07c00b00,
+	0x06431e07, 0x0aa18000, 0x07800af1, 0x04001c71, 0x09010c71,
+	0x0a614031, 0x00000000, 0x05810c40, 0x07c00af1, 0x07c00b00,
 	0x0cc00000, 0x00000000, 0x078077c5, 0x04002c4e, 0x07400c45,
 	0x07807800, 0x04003c4e, 0x07400c40, 0x0cc00000, 0x09610140,
 	0x07807846, 0x04004c4e, 0x07400c46, 0x07807880, 0x04005c4e,
@@ -21,90 +19,93 @@ static const u32 MicroCode[] __initconst = {
 	0x0200e38f, 0x04001c4e, 0x07000c4d, 0x078072c0, 0x090a1040,
 	0x090c1c00, 0x02c0cc01, 0x0780730b, 0x0aa1000b, 0x0aa7c04b,
 	0x0c780c40, 0x00000000, 0x0980d00d, 0x0c07f340, 0x0944134c,
-	0x0c07f040, 0x04000005, 0x0a22008d, 0x09481350, 0x04004c4e,
+	0x0c07f000, 0x04000005, 0x0a22008d, 0x09481350, 0x04004c4e,
 	0x07000c46, 0x04005c4e, 0x07000c40, 0x0c780e00, 0x09610180,
 	0x0c07f240, 0x0980d28d, 0x07000380, 0x09c00300, 0x07400380,
 	0x07807200, 0x02000300, 0x07c07200, 0x0649cf00, 0x0be11000,
 	0x06800040, 0x078071c0, 0x04001000, 0x0c780a40, 0x07c071c0,
-	0x0980d04d, 0x0c07ee40, 0x0946134c, 0x0c07e940, 0x04000006,
+	0x0980d04d, 0x0c07ee40, 0x0946134c, 0x0c07e900, 0x04000006,
 	0x0a22004d, 0x094a1350, 0x04002c4e, 0x07000c45, 0x04003c4e,
 	0x07000c40, 0x0c780700, 0x09610140, 0x0c07e940, 0x0980d28d,
 	0x07000380, 0x09800300, 0x0c7ff940, 0x07400380, 0x0980d00d,
 	0x0980d04d, 0x0944134c, 0x0946134c, 0x0c07e6c0, 0x09481350,
-	0x0c07e3c0, 0x04000005, 0x0c07e7c0, 0x094a1350, 0x0980d28d,
+	0x0c07e380, 0x04000005, 0x0c07e7c0, 0x094a1350, 0x0980d28d,
 	0x07807200, 0x02000300, 0x07c07200, 0x0649cf00, 0x0be11000,
 	0x06800040, 0x078071c0, 0x04001000, 0x07c071c0, 0x04006c4e,
 	0x07807340, 0x07400c40, 0x04007c4e, 0x07400c51, 0x094c234b,
 	0x05801010, 0x05409000, 0x02c0d00d, 0x07801e40, 0x07000381,
-	0x09501040, 0x0400100e, 0x07000000, 0x0be100c0, 0x00000000,
-	0x07802080, 0x09523040, 0x07400381, 0x07802fc0, 0x09584340,
-	0x0900200d, 0x0a6100c0, 0x0be0c30d, 0x06800000, 0x09402340,
-	0x09c0d20d, 0x04001c4e, 0x0ac03185, 0x0c780140, 0x07400c4d,
-	0x0980d20d, 0x0c780080, 0x07400c4d, 0x0649cf00, 0x0a2440c0,
-	0x0900200d, 0x0680000b, 0x0940634b, 0x07400c4d, 0x0c002080,
-	0x0780718d, 0x040012cb, 0x0aa1c00b, 0x06804080, 0x0609c000,
-	0x0609ce00, 0x0649cf00, 0x0be08080, 0x0c780000, 0x06800040,
-	0x07c01d80, 0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e,
-	0x078020c0, 0x06800041, 0x0340d001, 0x0780734c, 0x06803fcb,
-	0x06800008, 0x05403c48, 0x02031c4f, 0x04001c71, 0x07000c70,
-	0x0a230330, 0x0be2cc30, 0x04005c71, 0x07000c41, 0x0b803301,
-	0x00000000, 0x02401341, 0x0aa0ffcb, 0x0b80404a, 0x00000000,
-	0x04000281, 0x040002c8, 0x04001208, 0x0b8ef388, 0x0cc00000,
-	0x00000000, 0x0780720d, 0x0780390c, 0x0b82230d, 0x0c07f840,
-	0x00000000, 0x0400024a, 0x0aa7bfcb, 0x0680400f, 0x05403c4b,
-	0x02031c4f, 0x04001c71, 0x07000c70, 0x06800000, 0x09404c00,
-	0x07400c70, 0x07807200, 0x04401000, 0x07c07200, 0x04401071,
-	0x07000040, 0x09005000, 0x06800041, 0x03401001, 0x07807080,
-	0x03000040, 0x07c07080, 0x06810000, 0x0bc09030, 0x078071c0,
-	0x04401000, 0x07c071c0, 0x0649cf00, 0x0be11000, 0x0be0c080,
-	0x0c07f080, 0x0a8e3289, 0x0cc00000, 0x00000000, 0x0680400f,
-	0x0780704e, 0x06803fcd, 0x0680000c, 0x06800008, 0x05403c48,
-	0x02031c4f, 0x04001c71, 0x07000c70, 0x06810000, 0x0a00e030,
-	0x04001c71, 0x09101030, 0x02031031, 0x02031031, 0x07000c41,
-	0x04001c71, 0x07000c40, 0x09610040, 0x0aa0ffcd, 0x0b80404c,
-	0x00000000, 0x04000301, 0x04000348, 0x04001208, 0x0b8ec388,
-	0x0cc00000, 0x00000000, 0x0649c701, 0x0aa24001, 0x04401041,
-	0x0809c700, 0x05403041, 0x020013c1, 0x04001041, 0x07000070,
-	0x09c302f0, 0x07400070, 0x0649c801, 0x0aa24001, 0x04401041,
-	0x0809c800, 0x05403041, 0x020013c1, 0x04001041, 0x07000070,
-	0x09c302f0, 0x07400070, 0x0cc00000, 0x00000000, 0x0680400f,
-	0x05403c4d, 0x02031c4f, 0x04001c71, 0x07000c40, 0x06800081,
-	0x09542001, 0x07400c40, 0x04401c31, 0x07000c04, 0x0c7800c0,
-	0x05808044, 0x0be20041, 0x07801c01, 0x0aa10001, 0x0a216004,
-	0x06800001, 0x07c01c01, 0x05809040, 0x0a218041, 0x06800001,
-	0x09523001, 0x07400c40, 0x0c781300, 0x044012cb, 0x0c07f440,
-	0x00000000, 0x0649c001, 0x0bef7fc1, 0x09101044, 0x0a60c00b,
-	0x05409041, 0x0809d100, 0x09123c04, 0x0540210b, 0x03430130,
-	0x0649d104, 0x02c04c04, 0x0609d104, 0x0940504d, 0x09184c00,
-	0x0aa583f0, 0x068001c4, 0x0aa50030, 0x06800004, 0x0b648170,
-	0x04404130, 0x0649cf04, 0x0be24084, 0x0b6380f0, 0x04002130,
-	0x0aa30070, 0x06800144, 0x0b6280b0, 0x06800184, 0x0c780200,
-	0x068001c4, 0x04401131, 0x07000104, 0x0580c104, 0x0a20c044,
-	0x06800144, 0x06800184, 0x094a3044, 0x07802130, 0x0aa0c030,
-	0x00000000, 0x09801201, 0x090c2c00, 0x0a60c0b0, 0x00000000,
-	0x09801201, 0x04401c71, 0x07000c70, 0x090a2c30, 0x09542070,
-	0x078017f0, 0x09583070, 0x07c00b0c, 0x05810c0c, 0x07c00af0,
-	0x06803230, 0x02030370, 0x07000c30, 0x09610070, 0x06800030,
-	0x02030370, 0x07000c04, 0x0aa0c00b, 0x0aa1404b, 0x00000000,
-	0x0609ca04, 0x0c7801c0, 0x0609c101, 0x0649ca30, 0x09610c04,
-	0x0609ca30, 0x0c780080, 0x0609c201, 0x0649cf01, 0x0be09001,
-	0x0be100c0, 0x078071c0, 0x04401000, 0x07c071c0, 0x0cc00000,
-	0x00000000, 0x0680000b, 0x07803d0d, 0x0a21880d, 0x0780318c,
-	0x07801b8d, 0x0b00334c, 0x00000000, 0x07801b8c, 0x078071cd,
-	0x0649cf00, 0x0be0d000, 0x0b01730d, 0x0c7800c0, 0x0680004c,
-	0x0b80d30d, 0x00000000, 0x0c07d4c0, 0x00000000, 0x0a613fcd,
-	0x0c079cc0, 0x00000000, 0x0c780180, 0x0c07dfc0, 0x00000000,
-	0x040012cb, 0x0aa0808b, 0x0c7ff9c0, 0x0aa1400b, 0x06800080,
-	0x0950800b, 0x0609c000, 0x0609ce00, 0x0cc00000, 0x00000000,
-	0x0649cf0c, 0x0bee208c, 0x078071cc, 0x0bad808c, 0x0c07cf40,
-	0x00000000, 0x0aacffcd, 0x07800b00, 0x07800af0, 0x09610030,
-	0x04002000, 0x07802ff0, 0x0a60c030, 0x0b8e700c, 0x0c7ffac0,
-	0x0b0e500c, 0x0c7ffa40, 0x00000000, 0x0680000b, 0x078071cd,
-	0x0aa3c00d, 0x0c07cb00, 0x00000000, 0x0a613fcd, 0x0c079300,
-	0x00000000, 0x0c780240, 0x07807180, 0x0a807340, 0x00000000,
-	0x0c07d540, 0x00000000, 0x040012cb, 0x0aa0808b, 0x0c7ffc40,
+	0x09501040, 0x0400100e, 0x07000000, 0x0be0c0c0, 0x07802080,
+	0x09523040, 0x07400381, 0x07802fc0, 0x09584340, 0x0900200d,
+	0x0a6100c0, 0x0be0c30d, 0x06800000, 0x09402340, 0x09c0d20d,
+	0x04001c4e, 0x0ac03185, 0x0c780140, 0x07400c4d, 0x0980d20d,
+	0x0c780080, 0x07400c4d, 0x0649cf00, 0x0a2440c0, 0x0900200d,
+	0x0680000b, 0x0940634b, 0x07400c4d, 0x0c002000, 0x0780718d,
+	0x040012cb, 0x0aa1c00b, 0x06804080, 0x0609c000, 0x0609ce00,
+	0x0649cf00, 0x0be08080, 0x0c780000, 0x06800040, 0x07c01d80,
+	0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e, 0x078020c0,
+	0x06800041, 0x0340d001, 0x0780734c, 0x06803fcb, 0x06800008,
+	0x05403c48, 0x02031c4f, 0x04001c71, 0x07000c70, 0x0a230330,
+	0x0be2cc30, 0x04005c71, 0x07000c41, 0x0b803301, 0x00000000,
+	0x02401341, 0x0aa0ffcb, 0x0b80404a, 0x00000000, 0x04000281,
+	0x040002c8, 0x04001208, 0x0b8ef388, 0x0cc00000, 0x00000000,
+	0x0780720d, 0x0780390c, 0x0b81c30d, 0x0c07f840, 0x00000000,
+	0x0aa67fcb, 0x0680400f, 0x05403c4b, 0x02031c4f, 0x04001c71,
+	0x07000c70, 0x06800000, 0x09404c00, 0x07400c70, 0x07807200,
+	0x04401000, 0x07c07200, 0x04401071, 0x07000040, 0x09005000,
+	0x06800041, 0x03401001, 0x07807080, 0x03000040, 0x07c07080,
+	0x06810000, 0x0bc04030, 0x078071c0, 0x04401000, 0x07c071c0,
+	0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e, 0x06803fcd,
+	0x0680000c, 0x06800008, 0x05403c48, 0x02031c4f, 0x04001c71,
+	0x07000c70, 0x06810000, 0x0a00e030, 0x04001c71, 0x09101030,
+	0x02031031, 0x02031031, 0x07000c41, 0x04001c71, 0x07000c40,
+	0x09610040, 0x0aa0ffcd, 0x0b80404c, 0x00000000, 0x04000301,
+	0x04000348, 0x04001208, 0x0b8ec388, 0x00000000, 0x05403c4d,
+	0x02031c4f, 0x07000c70, 0x0cc00000, 0x091233f0, 0x0649c701,
+	0x0aa24001, 0x04401041, 0x0809c700, 0x05403041, 0x020013c1,
+	0x04001041, 0x07000070, 0x09c302f0, 0x07400070, 0x0649c801,
+	0x0aa24001, 0x04401041, 0x0809c800, 0x05403041, 0x020013c1,
+	0x04001041, 0x07000070, 0x09c302f0, 0x07400070, 0x0cc00000,
+	0x00000000, 0x0680400f, 0x05403c4d, 0x02031c4f, 0x04001c71,
+	0x07000c40, 0x06800081, 0x09542001, 0x07400c40, 0x04401c31,
+	0x07000c04, 0x090c2040, 0x0609d701, 0x07802141, 0x0a644001,
+	0x078006c1, 0x0b63c081, 0x0aa24001, 0x07800730, 0x07800741,
+	0x09610c01, 0x0b402c0c, 0x0a64000c, 0x068000b0, 0x0c7801c0,
+	0x07c006f0, 0x07c0070c, 0x0581004c, 0x07c00741, 0x06800041,
+	0x07c006c1, 0x07801c01, 0x0aa10001, 0x0a216004, 0x06800001,
+	0x07c01c01, 0x05809040, 0x0a218041, 0x06800001, 0x09523001,
+	0x07400c40, 0x0c781300, 0x044012cb, 0x0c07f000, 0x00000000,
+	0x0649c001, 0x0bef7fc1, 0x09101044, 0x0a60c00b, 0x05409041,
+	0x0809d100, 0x09123c04, 0x0540210b, 0x03430130, 0x0649d104,
+	0x02c04c04, 0x0609d104, 0x0940504d, 0x09184c00, 0x0aa583f0,
+	0x068001c4, 0x0aa50030, 0x06800004, 0x0b648170, 0x04404130,
+	0x0649cf04, 0x0be24084, 0x0b6380f0, 0x04002130, 0x0aa30070,
+	0x06800144, 0x0b6280b0, 0x06800184, 0x0c780200, 0x068001c4,
+	0x04401131, 0x07000104, 0x0580c104, 0x0a20c044, 0x06800144,
+	0x06800184, 0x094a3044, 0x07802130, 0x0aa0c030, 0x00000000,
+	0x09801201, 0x090c2c00, 0x0a60c0b0, 0x00000000, 0x09801201,
+	0x04401c71, 0x07000c70, 0x090a2c30, 0x09542070, 0x078017f0,
+	0x09583070, 0x07c00b0c, 0x05810c0c, 0x07c00af0, 0x06803230,
+	0x02030370, 0x07000c30, 0x09610070, 0x06800030, 0x02030370,
+	0x07000c04, 0x0aa0c00b, 0x0aa1404b, 0x00000000, 0x0609ca04,
+	0x0c7801c0, 0x0609c101, 0x0649ca30, 0x09610c04, 0x0609ca30,
+	0x0c780080, 0x0609c201, 0x0649cf01, 0x0be09001, 0x0be100c0,
+	0x078071c0, 0x04401000, 0x07c071c0, 0x0cc00000, 0x00000000,
+	0x0680000b, 0x07803d0d, 0x0a21880d, 0x0780318c, 0x07801b8d,
+	0x0b00334c, 0x00000000, 0x07801b8c, 0x078071cd, 0x0649cf00,
+	0x0be0d000, 0x0b01630d, 0x0c7800c0, 0x0680004c, 0x0b80c30d,
+	0x0c07cfc0, 0x00000000, 0x0a613fcd, 0x0c079980, 0x00000000,
+	0x0c780180, 0x0c07dbc0, 0x00000000, 0x040012cb, 0x0aa0808b,
+	0x0c7ffa00, 0x0aa1400b, 0x06800080, 0x0950800b, 0x0609c000,
+	0x0609ce00, 0x0cc00000, 0x00000000, 0x0649cf0c, 0x0bee208c,
+	0x0c07cac0, 0x00000000, 0x0aad7fcd, 0x07800b00, 0x07800af0,
+	0x09610030, 0x078008f0, 0x0a610030, 0x06800070, 0x07c008f0,
+	0x0a8e8300, 0x078071f0, 0x0baac0b0, 0x04002000, 0x0ba0c00c,
+	0x0aa0814f, 0x0b0e200c, 0x0c7ff980, 0x00000000, 0x0680000b,
+	0x078071cd, 0x0aa3800d, 0x0c07c540, 0x00000000, 0x0a613fcd,
+	0x0c078f00, 0x00000000, 0x0c780200, 0x07807180, 0x0a806340,
+	0x0c07d0c0, 0x00000000, 0x040012cb, 0x0aa0808b, 0x0c7ffc80,
 	0x0aa1c00b, 0x06800080, 0x0950800b, 0x0609c000, 0x0609ce00,
-	0x0c7ffac0, 0x0680000b, 0x0cc00000, 0x00000000, 0x0680400f,
+	0x0c7ffb00, 0x0680000b, 0x0cc00000, 0x00000000, 0x0680400f,
 	0x0780704e, 0x06800008, 0x06800007, 0x07807186, 0x078072c0,
 	0x0a225800, 0x07c07087, 0x05403c46, 0x02031c4f, 0x07000c70,
 	0x09005c30, 0x06800041, 0x03401c01, 0x07c07081, 0x05403c48,
@@ -128,8 +129,8 @@ static const u32 MicroCode[] __initconst = {
 	0x094021c0, 0x07807200, 0x04401000, 0x07c07200, 0x04401046,
 	0x07000040, 0x09005000, 0x06800041, 0x03401001, 0x07807080,
 	0x03000040, 0x07c07080, 0x06810000, 0x0bc04007, 0x078071c0,
-	0x04401000, 0x07c071c0, 0x0649cf00, 0x0be14080, 0x07400187,
-	0x0be0d000, 0x04001208, 0x0b8ce248, 0x0cc00000, 0x00000000,
+	0x04401000, 0x07c071c0, 0x0649cf00, 0x0be14080, 0x0cc00000,
+	0x07400187, 0x04001208, 0x0b8ce248, 0x0cc00000, 0x00000000,
 	0x07807108, 0x07807149, 0x0680a00a, 0x0a403209, 0x0cc00000,
 	0x00000000, 0x05402108, 0x0200410a, 0x04002c44, 0x07000c40,
 	0x04001c71, 0x07000c41, 0x09610001, 0x0a42a380, 0x07000105,
@@ -172,36 +173,35 @@ static const u32 MicroCode[] __initconst = {
 	0x03401001, 0x07807080, 0x03000040, 0x07c07080, 0x06810000,
 	0x0bc04007, 0x078071c0, 0x04401000, 0x07c071c0, 0x07400187,
 	0x04001208, 0x0b8dc248, 0x0cc00000, 0x00000000, 0x06800010,
-	0x078020b1, 0x0a62c0b1, 0x07800b71, 0x0aa0c0b1, 0x07800bb1,
-	0x0aa1c031, 0x0c07aa80, 0x07c00b90, 0x07c00b50, 0x07c01e50,
-	0x0c07a300, 0x00000000, 0x0649cf31, 0x0be100b1, 0x078072f1,
-	0x09005031, 0x0a638140, 0x06800011, 0x0c07a780, 0x00000000,
-	0x0780e100, 0x0be18080, 0x09001400, 0x0c079fc0, 0x00000000,
-	0x0c781800, 0x00000000, 0x0c07aec0, 0x00000000, 0x0c781700,
-	0x06800000, 0x090a2071, 0x0780e130, 0x0a858001, 0x0a857030,
-	0x0680e10f, 0x070003c0, 0x0aa2c040, 0x0aa3c080, 0x0aa4c0c0,
-	0x0aa68100, 0x00000000, 0x04605040, 0x0c500740, 0x00000000,
-	0x04606040, 0x0c5010c0, 0x0c781280, 0x04001c4f, 0x0c07ae80,
-	0x07000c4e, 0x0c7ffc40, 0x040023cf, 0x04001c4f, 0x0c07be00,
-	0x07000c4e, 0x0c7ffb00, 0x040023cf, 0x04002c4f, 0x0c07cb80,
-	0x07000c4e, 0x04001c4f, 0x0c07d780, 0x07000c4d, 0x0c7ff900,
-	0x040033cf, 0x04001c4f, 0x07000c4e, 0x0c07e200, 0x00000000,
-	0x0c7ff780, 0x040023cf, 0x0c079a00, 0x00000000, 0x0c079300,
-	0x00000000, 0x06800007, 0x07807331, 0x0b250071, 0x07807770,
-	0x07807780, 0x09610c00, 0x07807841, 0x07807880, 0x09610040,
-	0x02401c01, 0x07c07841, 0x05810001, 0x07c07880, 0x078077c1,
-	0x07807800, 0x09610040, 0x02401c01, 0x07c077c1, 0x05810001,
-	0x07c07800, 0x0c7801c0, 0x07c07441, 0x07c07447, 0x07c077c7,
-	0x07c07807, 0x07c07847, 0x07c07887, 0x07c07347, 0x07c07487,
-	0x07c07647, 0x07c07687, 0x07c076c7, 0x07c07707, 0x07c07747,
-	0x07c07787, 0x0c7fed40, 0x040013cf, 0x04001c4f, 0x07000c4e,
-	0x0c07bd80, 0x00000000, 0x06800050, 0x0400044e, 0x0c7feb40,
-	0x040023cf, 0x0680400f, 0x0780718e, 0x0540338e, 0x0200e38f,
-	0x04001c4e, 0x07000c40, 0x0a2140c0, 0x0c071d80, 0x07c031d0,
-	0x0cc00000, 0x00000000, 0x078072f1, 0x09005031, 0x090a2071,
-	0x0aa10140, 0x0aa0c001, 0x0c074580, 0x00000000, 0x0649cf00,
-	0x0a219000, 0x0c071a40, 0x07c031d0, 0x0c0774c0, 0x00000000,
-	0x0c780140, 0x0c077400, 0x00000000, 0x0c071880, 0x07c031d0,
-	0x0cc00000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x078020b1, 0x0a6280b1, 0x07800b71, 0x0aa0c0b1, 0x07800bb1,
+	0x0aa18031, 0x0c07aa80, 0x07c00b90, 0x07c00b50, 0x0c07a380,
+	0x00000000, 0x0649cf31, 0x0be100b1, 0x078072f1, 0x09005031,
+	0x0a634140, 0x06800011, 0x0c07a7c0, 0x00000000, 0x0780e100,
+	0x0be14080, 0x09001400, 0x0c07a040, 0x00000000, 0x0c7817c0,
+	0x0c07af40, 0x00000000, 0x0c781700, 0x06800000, 0x090a2071,
+	0x0780e130, 0x0a858001, 0x0a857030, 0x0680e10f, 0x070003c0,
+	0x0aa2c040, 0x0aa3c080, 0x0aa4c0c0, 0x0aa68100, 0x00000000,
+	0x04605040, 0x0c500740, 0x00000000, 0x04606040, 0x0c5010c0,
+	0x0c781280, 0x04001c4f, 0x0c07af00, 0x07000c4e, 0x0c7ffc40,
+	0x040023cf, 0x04001c4f, 0x0c07be80, 0x07000c4e, 0x0c7ffb00,
+	0x040023cf, 0x04002c4f, 0x0c07cc00, 0x07000c4e, 0x04001c4f,
+	0x0c07d800, 0x07000c4d, 0x0c7ff900, 0x040033cf, 0x04001c4f,
+	0x07000c4e, 0x0c07e280, 0x00000000, 0x0c7ff780, 0x040023cf,
+	0x0c079a80, 0x00000000, 0x0c0793c0, 0x00000000, 0x06800007,
+	0x07807331, 0x0b250071, 0x07807770, 0x07807780, 0x09610c00,
+	0x07807841, 0x07807880, 0x09610040, 0x02401c01, 0x07c07841,
+	0x05810001, 0x07c07880, 0x078077c1, 0x07807800, 0x09610040,
+	0x02401c01, 0x07c077c1, 0x05810001, 0x07c07800, 0x0c7801c0,
+	0x07c07441, 0x07c07447, 0x07c077c7, 0x07c07807, 0x07c07847,
+	0x07c07887, 0x07c07347, 0x07c07487, 0x07c07647, 0x07c07687,
+	0x07c076c7, 0x07c07707, 0x07c07747, 0x07c07787, 0x0c7fed40,
+	0x040013cf, 0x04001c4f, 0x07000c4e, 0x0c07be00, 0x00000000,
+	0x06800050, 0x0400044e, 0x0c7feb40, 0x040023cf, 0x0680400f,
+	0x0780718e, 0x0540338e, 0x0200e38f, 0x04001c4e, 0x07000c40,
+	0x0a2100c0, 0x0c071a40, 0x07c031d0, 0x0cc00000, 0x078072f1,
+	0x09005031, 0x090a2071, 0x0aa10140, 0x0aa0c001, 0x0c074240,
+	0x00000000, 0x0649cf00, 0x0a219000, 0x0c071740, 0x07c031d0,
+	0x0c077540, 0x00000000, 0x0c780140, 0x0c077480, 0x00000000,
+	0x0c071580, 0x07c031d0, 0x0cc00000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000
 };
diff --git a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264slice_linux.h b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264slice_linux.h
index 62e2a6c..b83ed0b 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264slice_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/gxtvbb_h264slice_linux.h
@@ -11,8 +11,8 @@ static const u32 MicroCode[] __initconst = {
 	0x06800000, 0x07c0e100, 0x07c07540, 0x07c07580, 0x07c075c0,
 	0x07c07600, 0x078074b1, 0x04001c71, 0x078020c0, 0x06800041,
 	0x0340f001, 0x044013cf, 0x028313f1, 0x0a834ab1, 0x07c07371,
-	0x07802140, 0x0a60c000, 0x0c780100, 0x07c074b1, 0x0c00a780,
-	0x00000000, 0x068000f3, 0x0c008880, 0x07c02bf3, 0x07807187,
+	0x07802140, 0x0a60c000, 0x0c780100, 0x07c074b1, 0x0c00a480,
+	0x00000000, 0x068000f3, 0x0c008640, 0x07c02bf3, 0x07807187,
 	0x07807048, 0x0a403207, 0x0c7e0200, 0x00000000, 0x06800033,
 	0x07c02bf3, 0x068002c0, 0x06031e00, 0x00000000, 0x06431e00,
 	0x0befc040, 0x00000000, 0x0649cf00, 0x0a20d000, 0x06800340,
@@ -23,14 +23,14 @@ static const u32 MicroCode[] __initconst = {
 	0x06431e00, 0x0bee8040, 0x00000000, 0x0c7ff1c0, 0x00000000,
 	0x07c0736a, 0x07c072eb, 0x07c0732c, 0x07c0e12d, 0x07c0756e,
 	0x0581002e, 0x07c07580, 0x07c075ef, 0x0581002f, 0x07c07600,
-	0x0c009980, 0x00000000, 0x080c3000, 0x07807748, 0x07807789,
+	0x0c009680, 0x00000000, 0x080c3000, 0x07807748, 0x07807789,
 	0x09610209, 0x060c3208, 0x078077c8, 0x07807809, 0x09610209,
 	0x060c3208, 0x07807848, 0x07807889, 0x09610209, 0x060c3208,
-	0x06800073, 0x0c007740, 0x07c02bf3, 0x07807187, 0x07807048,
+	0x06800073, 0x0c007500, 0x07c02bf3, 0x07807187, 0x07807048,
 	0x0a403207, 0x0c7df0c0, 0x00000000, 0x06800033, 0x07c02bf3,
-	0x0aa1000a, 0x00000000, 0x0c780900, 0x00000000, 0x0c07a940,
+	0x0aa1000a, 0x00000000, 0x0c780900, 0x00000000, 0x0c07a840,
 	0x00000000, 0x07800c48, 0x0aa1c008, 0x07800bc8, 0x07800c09,
-	0x09610209, 0x06800009, 0x0c780100, 0x07c00c49, 0x0c062580,
+	0x09610209, 0x06800009, 0x0c780100, 0x07c00c49, 0x0c062500,
 	0x00000000, 0x0649cf09, 0x0be29009, 0x07800cc9, 0x0a620009,
 	0x06800049, 0x07c00cc9, 0x0809c009, 0x0609c108, 0x08007401,
 	0x0649c009, 0x0a6fc009, 0x07c03088, 0x05810208, 0x07c030c8,
@@ -39,134 +39,131 @@ static const u32 MicroCode[] __initconst = {
 	0x07c030c9, 0x054181c7, 0x0609b307, 0x068c000a, 0x0c060740,
 	0x06c0000a, 0x0649b307, 0x054081c7, 0x058081c7, 0x0609b207,
 	0x0609b007, 0x0609b107, 0x06800007, 0x07c01c47, 0x078072c7,
-	0x0be09807, 0x0c780840, 0x06bfffc9, 0x06803008, 0x07802307,
-	0x090211c7, 0x054011c7, 0x038081c8, 0x07807307, 0x0a60c087,
-	0x06800007, 0x06800047, 0x038081c8, 0x07803c07, 0x06031f07,
-	0x06033f08, 0x0c05d080, 0x08031e15, 0x078079c9, 0x07807a0a,
-	0x0961024a, 0x06431f07, 0x02009247, 0x078078c7, 0x07807908,
-	0x096101c8, 0x0b8071c9, 0x07807947, 0x07807988, 0x096101c8,
-	0x0b4031c9, 0x0c7800c0, 0x00000000, 0x06bfffc9, 0x064c3d08,
-	0x09161208, 0x0a6f8008, 0x00000000, 0x060c3809, 0x07802207,
-	0x0aa10007, 0x00000000, 0x0c062040, 0x080c2301, 0x07803ac7,
-	0x07c073c7, 0x07803b07, 0x07c07407, 0x07802087, 0x0aa10187,
-	0x06800148, 0x0a83c207, 0x0c781700, 0x00000000, 0x0fc011c0,
-	0x06800808, 0x096e1207, 0x078073c7, 0x09505207, 0x0fc011c0,
-	0x0aa24007, 0x07807407, 0x0c061b40, 0x080c2301, 0x07c073c7,
-	0x09505207, 0x0c061a40, 0x080c2301, 0x07c07407, 0x09605207,
+	0x0a279807, 0x06bfffc9, 0x06803008, 0x07802307, 0x090211c7,
+	0x054011c7, 0x038081c8, 0x07807307, 0x0a60c087, 0x06800007,
+	0x06800047, 0x038081c8, 0x07803c07, 0x0e000207, 0x078079c9,
+	0x07807a0a, 0x0961024a, 0x0f0001c0, 0x02009247, 0x078078c7,
+	0x07807908, 0x096101c8, 0x0b8071c9, 0x07807947, 0x07807988,
+	0x096101c8, 0x0b4031c9, 0x0c7800c0, 0x00000000, 0x06bfffc9,
+	0x064c3d08, 0x09161208, 0x0a6f8008, 0x00000000, 0x060c3809,
+	0x07802207, 0x0aa10007, 0x00000000, 0x0c0620c0, 0x080c2301,
+	0x07803ac7, 0x07c073c7, 0x07803b07, 0x07c07407, 0x07802087,
+	0x0aa10187, 0x06800148, 0x0a83c207, 0x0c781700, 0x00000000,
+	0x0fc011c0, 0x06800808, 0x096e1207, 0x078073c7, 0x09505207,
+	0x0fc011c0, 0x0aa24007, 0x07807407, 0x0c061bc0, 0x080c2301,
+	0x07c073c7, 0x09505207, 0x0c061ac0, 0x080c2301, 0x07c07407,
+	0x09605207, 0x07802947, 0x096a2207, 0x060c2108, 0x068000c7,
+	0x07c0c007, 0x0fc011c0, 0x0aa10007, 0x00000000, 0x0c06a440,
+	0x0680c009, 0x068000c7, 0x07c0d087, 0x0fc011c0, 0x0aa10007,
+	0x00000000, 0x0c06a280, 0x0680d089, 0x07802907, 0x0a60c087,
+	0x06800008, 0x06815408, 0x09402207, 0x0a644047, 0x06094208,
+	0x0c0613c0, 0x080c2301, 0x09484207, 0x0c061300, 0x080c2301,
+	0x09504207, 0x06094208, 0x0680c007, 0x06094007, 0x0c06a440,
+	0x078073c9, 0x0680d807, 0x06094007, 0x0c06a340, 0x07807409,
+	0x0c7808c0, 0x00000000, 0x0fc011c0, 0x06800808, 0x0aa14007,
+	0x078073c7, 0x0c060e80, 0x080c2301, 0x07c073c7, 0x09505207,
 	0x07802947, 0x096a2207, 0x060c2108, 0x068000c7, 0x07c0c007,
-	0x0fc011c0, 0x0aa10007, 0x00000000, 0x0c06a440, 0x0680c009,
-	0x068000c7, 0x07c0d087, 0x0fc011c0, 0x0aa10007, 0x00000000,
-	0x0c06a280, 0x0680d089, 0x07802907, 0x0a60c087, 0x06800008,
-	0x06815408, 0x09402207, 0x0a644047, 0x06094208, 0x0c061340,
-	0x080c2301, 0x09484207, 0x0c061280, 0x080c2301, 0x09504207,
-	0x06094208, 0x0680c007, 0x06094007, 0x0c06a440, 0x078073c9,
-	0x0680d807, 0x06094007, 0x0c06a340, 0x07807409, 0x0c7808c0,
-	0x00000000, 0x0fc011c0, 0x06800808, 0x0aa14007, 0x078073c7,
-	0x0c060e00, 0x080c2301, 0x07c073c7, 0x09505207, 0x07802947,
-	0x096a2207, 0x060c2108, 0x068000c7, 0x07c0c007, 0x0fc011c0,
-	0x0aa10007, 0x00000000, 0x0c069800, 0x0680c009, 0x078028c7,
-	0x04000207, 0x0aa34007, 0x06094208, 0x0c060980, 0x080c2301,
-	0x09484207, 0x0c0608c0, 0x080c2301, 0x09504207, 0x06094208,
-	0x0680c007, 0x06094007, 0x0c069a80, 0x078073c9, 0x06494007,
-	0x09c07247, 0x06094007, 0x07802047, 0x0aa7c007, 0x07802007,
-	0x06800148, 0x0a82a207, 0x00000000, 0x06800007, 0x07c0e107,
-	0x0fc011c0, 0x0aa5c007, 0x0680e109, 0x04000289, 0x02407289,
-	0x0b610a47, 0x06800007, 0x0c060240, 0x080c2301, 0x0aa3c007,
-	0x07400247, 0x0aae4147, 0x04001249, 0x04000207, 0x0c060080,
-	0x080c2301, 0x07400247, 0x0a6cc0c8, 0x04001249, 0x0c05ff40,
-	0x080c2301, 0x07400247, 0x0c7ffb80, 0x04001249, 0x0649cf07,
-	0x0a20c0c7, 0x06800007, 0x07c0e107, 0x07802347, 0x0aa2c007,
-	0x07802087, 0x0aa24087, 0x06800c08, 0x0c05fbc0, 0x080c2301,
-	0x09402207, 0x0c780100, 0x060c2108, 0x0fc021c0, 0x07c0e107,
-	0x068004ca, 0x06031e0a, 0x0649ce09, 0x0aa10009, 0x00000000,
-	0x0809ce00, 0x08007401, 0x06431e09, 0x0bee8049, 0x00000000,
-	0x07801e87, 0x0a608047, 0x0c782a40, 0x0680a009, 0x0680400a,
-	0x0680ec08, 0x080c2400, 0x0c069d80, 0x078070cc, 0x080c2400,
-	0x0680000b, 0x0780724c, 0x078073cd, 0x0400134d, 0x0b80334c,
-	0x00000000, 0x0400030d, 0x0200d2c8, 0x0700034d, 0x0540234d,
-	0x0200d349, 0x0700034e, 0x05408410, 0x02010390, 0x054033ce,
-	0x0200f3ca, 0x070003cf, 0x091013cf, 0x0aa0c00f, 0x0680004f,
-	0x07c01e4f, 0x0400134d, 0x0700034d, 0x0900234d, 0x094a240d,
-	0x040013cb, 0x0be0c0cf, 0x00000000, 0x060c2210, 0x0a60c00b,
-	0x00000000, 0x07c01990, 0x040012cb, 0x0b8e630b, 0x0a2240cc,
-	0x090022cc, 0x0680010c, 0x0240c2cc, 0x090082d0, 0x05408410,
-	0x0d07ffcc, 0x0940840b, 0x060c2210, 0x07802087, 0x06800188,
-	0x0a802207, 0x0c781cc0, 0x0680f608, 0x080c2408, 0x0c069080,
+	0x0fc011c0, 0x0aa10007, 0x00000000, 0x0c069800, 0x0680c009,
+	0x078028c7, 0x04000207, 0x0aa34007, 0x06094208, 0x0c060a00,
+	0x080c2301, 0x09484207, 0x0c060940, 0x080c2301, 0x09504207,
+	0x06094208, 0x0680c007, 0x06094007, 0x0c069a80, 0x078073c9,
+	0x06494007, 0x09c07247, 0x06094007, 0x07802047, 0x0aa7c007,
+	0x07802007, 0x06800148, 0x0a82a207, 0x00000000, 0x06800007,
+	0x07c0e107, 0x0fc011c0, 0x0aa5c007, 0x0680e109, 0x04000289,
+	0x02407289, 0x0b610a47, 0x06800007, 0x0c0602c0, 0x080c2301,
+	0x0aa3c007, 0x07400247, 0x0aae4147, 0x04001249, 0x04000207,
+	0x0c060100, 0x080c2301, 0x07400247, 0x0a6cc0c8, 0x04001249,
+	0x0c05ffc0, 0x080c2301, 0x07400247, 0x0c7ffb80, 0x04001249,
+	0x0649cf07, 0x0a20c0c7, 0x06800007, 0x07c0e107, 0x07802347,
+	0x0aa2c007, 0x07802087, 0x0aa24087, 0x06800c08, 0x0c05fc40,
+	0x080c2301, 0x09402207, 0x0c780100, 0x060c2108, 0x0fc021c0,
+	0x07c0e107, 0x068004ca, 0x06031e0a, 0x0649ce09, 0x0aa10009,
+	0x00000000, 0x0809ce00, 0x08007401, 0x06431e09, 0x0bee8049,
+	0x00000000, 0x07801e87, 0x0a608047, 0x0c782900, 0x0680a009,
+	0x0680400a, 0x0680ec08, 0x080c2400, 0x0c069d80, 0x078070cc,
+	0x080c2400, 0x0680000b, 0x0780724c, 0x078073cd, 0x0400134d,
+	0x0b80334c, 0x00000000, 0x0400030d, 0x0200d2c8, 0x0700034d,
+	0x0540234d, 0x0200d349, 0x0700034e, 0x05408410, 0x02010390,
+	0x054033ce, 0x0200f3ca, 0x070003cf, 0x091013cf, 0x0aa0c00f,
+	0x0680004f, 0x07c01e4f, 0x0400134d, 0x0700034d, 0x0900234d,
+	0x094a240d, 0x040013cb, 0x0be0c0cf, 0x00000000, 0x060c2210,
+	0x0a60c00b, 0x00000000, 0x07c01990, 0x040012cb, 0x0b8e630b,
+	0x0a2240cc, 0x090022cc, 0x0680010c, 0x0240c2cc, 0x090082d0,
+	0x05408410, 0x0d07ffcc, 0x0940840b, 0x060c2210, 0x07802087,
+	0x06800188, 0x0a46f207, 0x0680f608, 0x080c2408, 0x0c0690c0,
 	0x0780728c, 0x080c2408, 0x0680000b, 0x0780740d, 0x0400134d,
 	0x0b80334c, 0x00000000, 0x0400030d, 0x0200d2c8, 0x0700034d,
 	0x0540234d, 0x0200d349, 0x0700034e, 0x05408410, 0x02010390,
 	0x0400134d, 0x0700034d, 0x0900234d, 0x054033ce, 0x0200f3ca,
 	0x070003cf, 0x091013cf, 0x0aa0c00f, 0x0680004f, 0x07c01e4f,
-	0x046002cb, 0x0c481140, 0x07803a47, 0x0540338e, 0x0200e38a,
-	0x0700038f, 0x090053cf, 0x06031f07, 0x06033f0f, 0x0c0589c0,
-	0x08031e15, 0x0780732b, 0x0a60c0ab, 0x0680002c, 0x0680006c,
-	0x06431f07, 0x07803c0f, 0x054013cf, 0x0380fb0f, 0x020073c7,
-	0x0680180f, 0x06031f07, 0x06033f0f, 0x0c058640, 0x08031e15,
-	0x06431f07, 0x06433f0f, 0x097081cf, 0x0780230f, 0x090213cf,
-	0x054013cf, 0x038073c7, 0x078078cf, 0x020073c7, 0x0780790f,
-	0x054103cf, 0x020073c7, 0x058031c7, 0x040013ce, 0x070003cf,
-	0x090c2a8f, 0x097c21ea, 0x0ba5c0ab, 0x040023ce, 0x070003ec,
-	0x040033ce, 0x070003ef, 0x09610b2f, 0x040043ce, 0x070003ed,
-	0x040053ce, 0x070003ef, 0x09610b6f, 0x0780776e, 0x078077af,
-	0x09610baf, 0x0b403b2e, 0x0242fb2e, 0x0242fbac, 0x0b403b6e,
-	0x0242cb6e, 0x0242cbad, 0x0b807b2f, 0x0c780180, 0x09807747,
-	0x044013cd, 0x0ba0c0aa, 0x097a11cf, 0x097a11eb, 0x060c3907,
-	0x094a240d, 0x040013cb, 0x0be0c0cf, 0x00000000, 0x060c2210,
-	0x040012cb, 0x0b8a330b, 0x0a2240cc, 0x090022cc, 0x0680010c,
-	0x0240c2cc, 0x090082d0, 0x05408410, 0x0d07ffcc, 0x0940840b,
-	0x060c2210, 0x0780208a, 0x0a60c08a, 0x0680000a, 0x07c01e4a,
-	0x068c000a, 0x06c0470a, 0x0680c009, 0x0c059e40, 0x06a0400b,
-	0x0c05ca80, 0x080c2301, 0x0c05cc00, 0x00000000, 0x0401a1c7,
-	0x07802248, 0x02007207, 0x07c02387, 0x07802287, 0x0aa40007,
-	0x06800009, 0x0c05c7c0, 0x080c2301, 0x0aa30047, 0x09402247,
-	0x0c05c6c0, 0x080c2301, 0x0c05c840, 0x00000000, 0x094c4247,
-	0x0c05c580, 0x080c2301, 0x0c05c700, 0x00000000, 0x09444247,
-	0x060c3109, 0x0c7f1b00, 0x00000000, 0x0c066540, 0x00000000,
-	0x0680400f, 0x0780704e, 0x0780734d, 0x0780730c, 0x078072c0,
-	0x090a1040, 0x090c1c00, 0x02c0bc01, 0x07807188, 0x0aa0c00c,
-	0x0aa3c04c, 0x0c780900, 0x05403c48, 0x020313f1, 0x04001c71,
-	0x07000c40, 0x09061040, 0x04005c71, 0x07000c70, 0x0be4c040,
-	0x0a248080, 0x0a4112c1, 0x0a410370, 0x0cc00000, 0x0680004a,
-	0x05403c48, 0x020313f1, 0x04001c71, 0x07000c40, 0x09041040,
-	0x04005c71, 0x07000c70, 0x0be18080, 0x0a214040, 0x0a4042c1,
-	0x0a403370, 0x0cc00000, 0x0680004a, 0x04803000, 0x0aa20000,
-	0x0aa1c0c0, 0x00000000, 0x04405c71, 0x07000c40, 0x09800000,
-	0x09800040, 0x07400c40, 0x06800008, 0x06830007, 0x05403c48,
-	0x020313f1, 0x04001c71, 0x07000c40, 0x0be180c0, 0x0bc051c0,
-	0x06800000, 0x07400c40, 0x0c780140, 0x07c07188, 0x04001208,
-	0x0b8f5388, 0x0c780d40, 0x07807780, 0x0580f000, 0x0a20c040,
-	0x06800001, 0x09801181, 0x07802000, 0x0a60c140, 0x04401c31,
-	0x09801141, 0x07801c40, 0x094e1040, 0x07400c01, 0x0aa7400b,
-	0x06801801, 0x07802300, 0x09021000, 0x05401000, 0x03801001,
-	0x07803cca, 0x0900828a, 0x0340a00a, 0x078078c5, 0x07807900,
-	0x09610140, 0x07803a40, 0x06031f00, 0x06033f01, 0x0c055680,
-	0x08031e15, 0x06800046, 0x07807087, 0x06431f04, 0x06800009,
-	0x03400246, 0x0bc0f1c0, 0x04401071, 0x07000070, 0x09405c09,
-	0x07400070, 0x02c07007, 0x07c07087, 0x0649c900, 0x09c007c0,
-	0x0609c900, 0x07c079c5, 0x05810145, 0x07c07a05, 0x0cc00000,
-	0x0680000a, 0x02005105, 0x04001249, 0x0b8ee289, 0x0649c900,
-	0x098007c0, 0x0609c900, 0x0cc00000, 0x07c0718e, 0x07802171,
-	0x04600031, 0x0c480b40, 0x07802180, 0x06800041, 0x0340f001,
-	0x0580138f, 0x078072c0, 0x09005000, 0x0a614140, 0x06800000,
-	0x07c07640, 0x07c07680, 0x07c07440, 0x0780764d, 0x07807680,
-	0x09610340, 0x0780734c, 0x0780744b, 0x078073b1, 0x0b4052f1,
-	0x02400c4b, 0x0b807380, 0x0c780180, 0x0200d3cd, 0x024002f1,
-	0x0b003380, 0x0c780080, 0x0240d3cd, 0x040002f1, 0x078072c0,
-	0x090a2000, 0x0aa14000, 0x0581000d, 0x07c0764d, 0x07c07680,
-	0x07c0744b, 0x07807331, 0x0b6100b1, 0x020052cd, 0x0c781d80,
-	0x04000185, 0x078074c0, 0x07807501, 0x09610001, 0x0c781c40,
-	0x02006005, 0x078020c0, 0x06800041, 0x0340f001, 0x078072c0,
-	0x09005000, 0x0a61c140, 0x06800000, 0x07c07480, 0x07c076c0,
-	0x07c07700, 0x07c07540, 0x07c07580, 0x0780748e, 0x078076cd,
-	0x07807700, 0x09610340, 0x0780734c, 0x0b40338c, 0x00000000,
-	0x0200d3cd, 0x04602031, 0x0c501200, 0x0780398b, 0x0460000b,
-	0x0c500a80, 0x0680000a, 0x06800009, 0x0200830d, 0x078072c0,
-	0x090a2000, 0x0a610000, 0x0aa0c008, 0x00000000, 0x04401208,
-	0x04000c4b, 0x06808030, 0x07000c00, 0x04001c30, 0x07000c01,
-	0x09610001, 0x04001c30, 0x0d07fef1, 0x02009009, 0x0a608008,
-	0x0c780580, 0x04401208, 0x06800007, 0x0b8052c8, 0x00000000,
-	0x040011c7, 0x0c7fff40, 0x024082c8, 0x06031f07, 0x06033f09,
-	0x0c0535c0, 0x08031e15, 0x04001c48, 0x06808030, 0x06431f0a,
+	0x046002cb, 0x0c481040, 0x07803a47, 0x0540338e, 0x0200e38a,
+	0x0700038f, 0x090053cf, 0x0e0003c7, 0x0780732b, 0x0a60c0ab,
+	0x0680002c, 0x0680006c, 0x0f0001c0, 0x07803c0f, 0x054013cf,
+	0x0380fb0f, 0x020073c7, 0x0680180f, 0x0e0003c7, 0x00000000,
+	0x00000000, 0x0f0001c0, 0x0f0103c0, 0x097081cf, 0x0780230f,
+	0x090213cf, 0x054013cf, 0x038073c7, 0x078078cf, 0x020073c7,
+	0x0780790f, 0x054103cf, 0x020073c7, 0x058031c7, 0x040013ce,
+	0x070003cf, 0x090c2a8f, 0x097c21ea, 0x0ba5c0ab, 0x040023ce,
+	0x070003ec, 0x040033ce, 0x070003ef, 0x09610b2f, 0x040043ce,
+	0x070003ed, 0x040053ce, 0x070003ef, 0x09610b6f, 0x0780776e,
+	0x078077af, 0x09610baf, 0x0b403b2e, 0x0242fb2e, 0x0242fbac,
+	0x0b403b6e, 0x0242cb6e, 0x0242cbad, 0x0b807b2f, 0x0c780180,
+	0x09807747, 0x044013cd, 0x0ba0c0aa, 0x097a11cf, 0x097a11eb,
+	0x060c3907, 0x094a240d, 0x040013cb, 0x0be0c0cf, 0x00000000,
+	0x060c2210, 0x040012cb, 0x0b8a730b, 0x0a2240cc, 0x090022cc,
+	0x0680010c, 0x0240c2cc, 0x090082d0, 0x05408410, 0x0d07ffcc,
+	0x0940840b, 0x060c2210, 0x07802e4a, 0x0a60c14a, 0x0680000a,
+	0x07c01e4a, 0x068c000a, 0x06c0470a, 0x0680c009, 0x0c05a080,
+	0x06a0400b, 0x0c05cc40, 0x080c2301, 0x0c05cdc0, 0x00000000,
+	0x0401a1c7, 0x07802248, 0x02007207, 0x07c02387, 0x07802287,
+	0x0aa40007, 0x06800009, 0x0c05c980, 0x080c2301, 0x0aa30047,
+	0x09402247, 0x0c05c880, 0x080c2301, 0x0c05ca00, 0x00000000,
+	0x094c4247, 0x0c05c740, 0x080c2301, 0x0c05c8c0, 0x00000000,
+	0x09444247, 0x060c3109, 0x0c7f1c40, 0x00000000, 0x0c066680,
+	0x00000000, 0x0680400f, 0x0780704e, 0x0780734d, 0x0780730c,
+	0x078072c0, 0x090a1040, 0x090c1c00, 0x02c0bc01, 0x07807188,
+	0x0aa0c00c, 0x0aa3c04c, 0x0c780900, 0x05403c48, 0x020313f1,
+	0x04001c71, 0x07000c40, 0x09061040, 0x04005c71, 0x07000c70,
+	0x0be4c040, 0x0a248080, 0x0a4112c1, 0x0a410370, 0x0cc00000,
+	0x0680004a, 0x05403c48, 0x020313f1, 0x04001c71, 0x07000c40,
+	0x09041040, 0x04005c71, 0x07000c70, 0x0be18080, 0x0a214040,
+	0x0a4042c1, 0x0a403370, 0x0cc00000, 0x0680004a, 0x04803000,
+	0x0aa20000, 0x0aa1c0c0, 0x00000000, 0x04405c71, 0x07000c40,
+	0x09800000, 0x09800040, 0x07400c40, 0x06800008, 0x06830007,
+	0x05403c48, 0x020313f1, 0x04001c71, 0x07000c40, 0x0be180c0,
+	0x0bc051c0, 0x06800000, 0x07400c40, 0x0c780140, 0x07c07188,
+	0x04001208, 0x0b8f5388, 0x0c780c80, 0x07807780, 0x0580f000,
+	0x0a20c040, 0x06800001, 0x09801181, 0x07802000, 0x0a60c140,
+	0x04401c31, 0x09801141, 0x07801c40, 0x094e1040, 0x07400c01,
+	0x0aa6800b, 0x06801801, 0x07802300, 0x09021000, 0x05401000,
+	0x03801001, 0x07803cca, 0x0900828a, 0x0340a00a, 0x078078c5,
+	0x07807900, 0x09610140, 0x07803a40, 0x0e000040, 0x06800046,
+	0x07807087, 0x0f000100, 0x06800009, 0x03400246, 0x0bc0f1c0,
+	0x04401071, 0x07000070, 0x09405c09, 0x07400070, 0x02c07007,
+	0x07c07087, 0x0649c900, 0x09c007c0, 0x0609c900, 0x07c079c5,
+	0x05810145, 0x07c07a05, 0x0cc00000, 0x0680000a, 0x02005105,
+	0x04001249, 0x0b8ee289, 0x0649c900, 0x098007c0, 0x0609c900,
+	0x0cc00000, 0x07c0718e, 0x07802171, 0x04600031, 0x0c480b40,
+	0x07802180, 0x06800041, 0x0340f001, 0x0580138f, 0x078072c0,
+	0x09005000, 0x0a614140, 0x06800000, 0x07c07640, 0x07c07680,
+	0x07c07440, 0x0780764d, 0x07807680, 0x09610340, 0x0780734c,
+	0x0780744b, 0x078073b1, 0x0b4052f1, 0x02400c4b, 0x0b807380,
+	0x0c780180, 0x0200d3cd, 0x024002f1, 0x0b003380, 0x0c780080,
+	0x0240d3cd, 0x040002f1, 0x078072c0, 0x090a2000, 0x0aa14000,
+	0x0581000d, 0x07c0764d, 0x07c07680, 0x07c0744b, 0x07807331,
+	0x0b6100b1, 0x020052cd, 0x0c781cc0, 0x04000185, 0x078074c0,
+	0x07807501, 0x09610001, 0x0c781b80, 0x02006005, 0x078020c0,
+	0x06800041, 0x0340f001, 0x078072c0, 0x09005000, 0x0a61c140,
+	0x06800000, 0x07c07480, 0x07c076c0, 0x07c07700, 0x07c07540,
+	0x07c07580, 0x0780748e, 0x078076cd, 0x07807700, 0x09610340,
+	0x0780734c, 0x0b40338c, 0x00000000, 0x0200d3cd, 0x04602031,
+	0x0c501140, 0x0780398b, 0x0460000b, 0x0c5009c0, 0x0680000a,
+	0x06800009, 0x0200830d, 0x078072c0, 0x090a2000, 0x0a610000,
+	0x0aa0c008, 0x00000000, 0x04401208, 0x04000c4b, 0x06808030,
+	0x07000c00, 0x04001c30, 0x07000c01, 0x09610001, 0x04001c30,
+	0x0d07fef1, 0x02009009, 0x0a608008, 0x0c7804c0, 0x04401208,
+	0x06800007, 0x0b8052c8, 0x00000000, 0x040011c7, 0x0c7fff40,
+	0x024082c8, 0x0e000247, 0x04001c48, 0x06808030, 0x0f000280,
 	0x07000c00, 0x04001c30, 0x07000c01, 0x09610001, 0x04001c30,
 	0x0d07fef1, 0x0200a00a, 0x078072c0, 0x090a2000, 0x0a614000,
 	0x07803800, 0x07803841, 0x09610001, 0x0200a00a, 0x07807545,
@@ -203,5 +200,8 @@ static const u32 MicroCode[] __initconst = {
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000
 };
diff --git a/drivers/amlogic/amports/arch/ucode/h264/h264header_linux.h b/drivers/amlogic/amports/arch/ucode/h264/h264header_linux.h
index 82b076b..8e351e3 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/h264header_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/h264header_linux.h
@@ -157,33 +157,35 @@ static const u32 MicroCode[] __initconst = {
 	0x07800a8e, 0x07802c49, 0x07803a4a, 0x0780390c, 0x07803e8f,
 	0x07803ed0, 0x07803e11, 0x0a409247, 0x0a408288, 0x0a40730b,
 	0x0a4063cd, 0x0a40540e, 0x00000000, 0x07800a07, 0x0a402447,
-	0x0c7825c0, 0x06800007, 0x07c07087, 0x07803bc7, 0x09807087,
+	0x0c782840, 0x06800007, 0x07c07087, 0x07803bc7, 0x09807087,
 	0x07c03bc7, 0x069fffc7, 0x07c03c49, 0x07c03c8a, 0x07c0174c,
-	0x07c00a4f, 0x07c00a90, 0x07c00a11, 0x0a83f207, 0x0688000a,
+	0x07c00a4f, 0x07c00a90, 0x07c00a11, 0x0a841207, 0x0688000a,
 	0x0c057200, 0x06c0000a, 0x0694000a, 0x06c0444a, 0x06804009,
 	0x0c056a40, 0x06b0400b, 0x0680044a, 0x06031e0a, 0x0649ce09,
 	0x0aa10009, 0x00000000, 0x0809ce00, 0x08007401, 0x06431e0a,
-	0x0bee804a, 0x00000000, 0x07803a47, 0x0a634047, 0x07807187,
-	0x06804089, 0x054031c7, 0x020091c9, 0x07000247, 0x091011c7,
-	0x020091c9, 0x0740024a, 0x04001249, 0x06801fca, 0x0740024a,
-	0x07c0178a, 0x07807047, 0x07c07187, 0x068003ca, 0x06031e0a,
-	0x0649ce09, 0x0aa10009, 0x00000000, 0x0809ce00, 0x08007401,
-	0x06431e09, 0x0bee8049, 0x00000000, 0x0649ce09, 0x0a6dc009,
-	0x00000000, 0x0c0622c0, 0x00000000, 0x0649c007, 0x0bef7fc7,
-	0x07803a47, 0x0a60c047, 0x0c780000, 0x00800000, 0x068000c7,
-	0x0609c007, 0x08007401, 0x0c062000, 0x0680001b, 0x0649c007,
-	0x0bef7fc7, 0x07802c47, 0x07803a48, 0x095101c8, 0x07803908,
-	0x097071c8, 0x07802308, 0x09021208, 0x097e11c8, 0x0609c107,
-	0x07803d07, 0x07802108, 0x095e11c8, 0x07800688, 0x094c11c8,
-	0x07803cc8, 0x09102208, 0x095a21c8, 0x07803d48, 0x096101c8,
-	0x0609c207, 0x07803d87, 0x07803dc8, 0x096101c8, 0x0609c307,
-	0x07803e07, 0x07803e48, 0x096101c8, 0x0609c407, 0x07803e87,
-	0x07803ec8, 0x096101c8, 0x0609c507, 0x07801ac7, 0x07801a88,
-	0x096101c8, 0x0609c607, 0x07800d07, 0x0609ca07, 0x078009c7,
-	0x07800988, 0x09610207, 0x0609d108, 0x06800047, 0x0609c007,
-	0x08007401, 0x06800007, 0x06800008, 0x06804009, 0x04001249,
-	0x07400248, 0x040011c7, 0x0baf8607, 0x04008249, 0x0680001b,
-	0x0649c008, 0x0befbfc8, 0x091081c8, 0x07c03187, 0x092081c8,
+	0x0bee804a, 0x00000000, 0x07802087, 0x0a63c087, 0x07803a47,
+	0x0a634047, 0x07807187, 0x06804089, 0x054031c7, 0x020091c9,
+	0x07000247, 0x091011c7, 0x020091c9, 0x0740024a, 0x04001249,
+	0x06801fca, 0x0740024a, 0x07c0178a, 0x07807047, 0x07c07187,
+	0x068003ca, 0x06031e0a, 0x0649ce09, 0x0aa10009, 0x00000000,
+	0x0809ce00, 0x08007401, 0x06431e09, 0x0bee8049, 0x00000000,
+	0x0649ce09, 0x0a6dc009, 0x00000000, 0x0c062240, 0x00000000,
+	0x0649c007, 0x0bef7fc7, 0x07803a47, 0x0a60c047, 0x0c780000,
+	0x00800000, 0x068000c7, 0x0609c007, 0x08007401, 0x0c061f80,
+	0x0680001b, 0x0649c007, 0x0bef7fc7, 0x07802c47, 0x07803a48,
+	0x095101c8, 0x07803908, 0x097071c8, 0x07802308, 0x09021208,
+	0x097e11c8, 0x0609c107, 0x07803d07, 0x07802108, 0x095e11c8,
+	0x07800688, 0x094c11c8, 0x07803cc8, 0x09102208, 0x095a21c8,
+	0x07803d48, 0x096101c8, 0x0609c207, 0x07803d87, 0x07803dc8,
+	0x096101c8, 0x0609c307, 0x07803e07, 0x07803e48, 0x096101c8,
+	0x0609c407, 0x07803e87, 0x07803ec8, 0x096101c8, 0x0609c507,
+	0x07801ac7, 0x07801a88, 0x096101c8, 0x0609c607, 0x07800d07,
+	0x0609ca07, 0x078009c7, 0x07800988, 0x09610207, 0x0609d108,
+	0x06800047, 0x0609c007, 0x08007401, 0x06800007, 0x06800008,
+	0x06804009, 0x04001249, 0x07400248, 0x040011c7, 0x0baf8607,
+	0x04008249, 0x0680001b, 0x0649c008, 0x0befbfc8, 0x091081c8,
+	0x07c03187, 0x07803d09, 0x0be0c809, 0x0c780180, 0x07c01b87,
+	0x07801b89, 0x0b0031c9, 0x00000000, 0x07c01b87, 0x092081c8,
 	0x07c07047, 0x093081c8, 0x07803cc8, 0x09408207, 0x07c03cc8,
 	0x06800007, 0x07c071c7, 0x07c07207, 0x0649c107, 0x07c078c7,
 	0x058101c7, 0x07c07907, 0x0649c407, 0x07c07947, 0x058101c7,
@@ -201,7 +203,5 @@ static const u32 MicroCode[] __initconst = {
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000
 };
diff --git a/drivers/amlogic/amports/arch/ucode/h264/h264mmc_linux.h b/drivers/amlogic/amports/arch/ucode/h264/h264mmc_linux.h
index 9fb6d49..9084a84 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/h264mmc_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/h264mmc_linux.h
@@ -1,47 +1,47 @@
 static const u32 MicroCode[] __initconst = {
 	0x06bfff40, 0x06032400, 0x00400000, 0x0c780000, 0x00000000,
-	0x09027207, 0x0a6140c8, 0x00000000, 0x0c00d600, 0x00000000,
+	0x09027207, 0x0a6140c8, 0x00000000, 0x0c00d880, 0x00000000,
 	0x0c780540, 0x0a614148, 0x00000000, 0x0c003cc0, 0x00000000,
-	0x0c780400, 0x0a614188, 0x00000000, 0x0c006c40, 0x00000000,
-	0x0c7802c0, 0x0a6141c8, 0x00000000, 0x0c007800, 0x00000000,
-	0x0c780180, 0x0a628208, 0x00000000, 0x0c000ec0, 0x00000000,
+	0x0c780400, 0x0a614188, 0x00000000, 0x0c007000, 0x00000000,
+	0x0c7802c0, 0x0a6141c8, 0x00000000, 0x0c007ac0, 0x00000000,
+	0x0c780180, 0x0a628208, 0x00000000, 0x0c000f00, 0x00000000,
 	0x00000000, 0x08031e00, 0x0cc00000, 0x00400000, 0x0c7ff8c0,
 	0x06431e07, 0x0a62c288, 0x06431f20, 0x06433f21, 0x0e000860,
 	0x00000000, 0x00000000, 0x0f000800, 0x06031f20, 0x0f010840,
 	0x0c7ffc80, 0x06033f21, 0x0aa18000, 0x07800af1, 0x04001c71,
-	0x09010c71, 0x0a610031, 0x00000000, 0x07c00ac0, 0x07c00b00,
-	0x0cc00000, 0x00000000, 0x078077c5, 0x04002c4e, 0x07400c45,
-	0x07807800, 0x04003c4e, 0x07400c40, 0x0cc00000, 0x09610140,
-	0x07807846, 0x04004c4e, 0x07400c46, 0x07807880, 0x04005c4e,
-	0x07400c40, 0x0cc00000, 0x09610180, 0x0680400f, 0x0780704e,
-	0x040013cf, 0x06800000, 0x07c07080, 0x07c071c0, 0x07c07200,
-	0x070003c1, 0x0940b040, 0x074003c1, 0x0d07ff4e, 0x040083cf,
-	0x0cc00000, 0x00000000, 0x0649c900, 0x05808000, 0x05408000,
-	0x0609c900, 0x078031d0, 0x0680400f, 0x0780718e, 0x0540338e,
-	0x0200e38f, 0x04001c4e, 0x07000c4d, 0x078072c0, 0x090a1040,
-	0x090c1c00, 0x02c0cc01, 0x0780730b, 0x0aa1000b, 0x0aa7c04b,
-	0x0c780c40, 0x00000000, 0x0980d00d, 0x0c07f340, 0x0944134c,
-	0x0c07f040, 0x04000005, 0x0a22008d, 0x09481350, 0x04004c4e,
-	0x07000c46, 0x04005c4e, 0x07000c40, 0x0c780e00, 0x09610180,
-	0x0c07f240, 0x0980d28d, 0x07000380, 0x09c00300, 0x07400380,
-	0x07807200, 0x02000300, 0x07c07200, 0x0649cf00, 0x0be11000,
-	0x06800040, 0x078071c0, 0x04001000, 0x0c780a40, 0x07c071c0,
-	0x0980d04d, 0x0c07ee40, 0x0946134c, 0x0c07e940, 0x04000006,
-	0x0a22004d, 0x094a1350, 0x04002c4e, 0x07000c45, 0x04003c4e,
-	0x07000c40, 0x0c780700, 0x09610140, 0x0c07e940, 0x0980d28d,
-	0x07000380, 0x09800300, 0x0c7ff940, 0x07400380, 0x0980d00d,
-	0x0980d04d, 0x0944134c, 0x0946134c, 0x0c07e6c0, 0x09481350,
-	0x0c07e3c0, 0x04000005, 0x0c07e7c0, 0x094a1350, 0x0980d28d,
-	0x07807200, 0x02000300, 0x07c07200, 0x0649cf00, 0x0be11000,
-	0x06800040, 0x078071c0, 0x04001000, 0x07c071c0, 0x04006c4e,
-	0x07807340, 0x07400c40, 0x04007c4e, 0x07400c51, 0x094c234b,
-	0x05801010, 0x05409000, 0x02c0d00d, 0x07801e40, 0x07000381,
-	0x09501040, 0x0400100e, 0x07000000, 0x0be100c0, 0x00000000,
+	0x09010c71, 0x0a614031, 0x00000000, 0x05810c40, 0x07c00af1,
+	0x07c00b00, 0x0cc00000, 0x00000000, 0x078077c5, 0x04002c4e,
+	0x07400c45, 0x07807800, 0x04003c4e, 0x07400c40, 0x0cc00000,
+	0x09610140, 0x07807846, 0x04004c4e, 0x07400c46, 0x07807880,
+	0x04005c4e, 0x07400c40, 0x0cc00000, 0x09610180, 0x0680400f,
+	0x0780704e, 0x040013cf, 0x06800000, 0x07c07080, 0x07c071c0,
+	0x07c07200, 0x070003c1, 0x0940b040, 0x074003c1, 0x0d07ff4e,
+	0x040083cf, 0x0cc00000, 0x00000000, 0x0649c900, 0x05808000,
+	0x05408000, 0x0609c900, 0x078031d0, 0x0680400f, 0x0780718e,
+	0x0540338e, 0x0200e38f, 0x04001c4e, 0x07000c4d, 0x078072c0,
+	0x090a1040, 0x090c1c00, 0x02c0cc01, 0x0780730b, 0x0aa1000b,
+	0x0aa7c04b, 0x0c780c40, 0x00000000, 0x0980d00d, 0x0c07f340,
+	0x0944134c, 0x0c07f000, 0x04000005, 0x0a22008d, 0x09481350,
+	0x04004c4e, 0x07000c46, 0x04005c4e, 0x07000c40, 0x0c780e00,
+	0x09610180, 0x0c07f240, 0x0980d28d, 0x07000380, 0x09c00300,
+	0x07400380, 0x07807200, 0x02000300, 0x07c07200, 0x0649cf00,
+	0x0be11000, 0x06800040, 0x078071c0, 0x04001000, 0x0c780a40,
+	0x07c071c0, 0x0980d04d, 0x0c07ee40, 0x0946134c, 0x0c07e900,
+	0x04000006, 0x0a22004d, 0x094a1350, 0x04002c4e, 0x07000c45,
+	0x04003c4e, 0x07000c40, 0x0c780700, 0x09610140, 0x0c07e940,
+	0x0980d28d, 0x07000380, 0x09800300, 0x0c7ff940, 0x07400380,
+	0x0980d00d, 0x0980d04d, 0x0944134c, 0x0946134c, 0x0c07e6c0,
+	0x09481350, 0x0c07e380, 0x04000005, 0x0c07e7c0, 0x094a1350,
+	0x0980d28d, 0x07807200, 0x02000300, 0x07c07200, 0x0649cf00,
+	0x0be11000, 0x06800040, 0x078071c0, 0x04001000, 0x07c071c0,
+	0x04006c4e, 0x07807340, 0x07400c40, 0x04007c4e, 0x07400c51,
+	0x094c234b, 0x05801010, 0x05409000, 0x02c0d00d, 0x07801e40,
+	0x07000381, 0x09501040, 0x0400100e, 0x07000000, 0x0be0c0c0,
 	0x07802080, 0x09523040, 0x07400381, 0x07802fc0, 0x09584340,
 	0x0900200d, 0x0a6100c0, 0x0be0c30d, 0x06800000, 0x09402340,
 	0x09c0d20d, 0x04001c4e, 0x0ac03185, 0x0c780140, 0x07400c4d,
 	0x0980d20d, 0x0c780080, 0x07400c4d, 0x0649cf00, 0x0a2440c0,
-	0x0900200d, 0x0680000b, 0x0940634b, 0x07400c4d, 0x0c002080,
+	0x0900200d, 0x0680000b, 0x0940634b, 0x07400c4d, 0x0c002000,
 	0x0780718d, 0x040012cb, 0x0aa1c00b, 0x06804080, 0x0609c000,
 	0x0609ce00, 0x0649cf00, 0x0be08080, 0x0c780000, 0x06800040,
 	0x07c01d80, 0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e,
@@ -50,29 +50,32 @@ static const u32 MicroCode[] __initconst = {
 	0x0a230330, 0x0be2cc30, 0x04005c71, 0x07000c41, 0x0b803301,
 	0x00000000, 0x02401341, 0x0aa0ffcb, 0x0b80404a, 0x00000000,
 	0x04000281, 0x040002c8, 0x04001208, 0x0b8ef388, 0x0cc00000,
-	0x00000000, 0x0780720d, 0x0780390c, 0x0b82230d, 0x0c07f840,
-	0x00000000, 0x0400024a, 0x0aa7bfcb, 0x0680400f, 0x05403c4b,
-	0x02031c4f, 0x04001c71, 0x07000c70, 0x06800000, 0x09404c00,
-	0x07400c70, 0x07807200, 0x04401000, 0x07c07200, 0x04401071,
-	0x07000040, 0x09005000, 0x06800041, 0x03401001, 0x07807080,
-	0x03000040, 0x07c07080, 0x06810000, 0x0bc09030, 0x078071c0,
-	0x04401000, 0x07c071c0, 0x0649cf00, 0x0be11000, 0x0be0c080,
-	0x0c07f080, 0x0a8e3289, 0x0cc00000, 0x00000000, 0x0680400f,
-	0x0780704e, 0x06803fcd, 0x0680000c, 0x06800008, 0x05403c48,
-	0x02031c4f, 0x04001c71, 0x07000c70, 0x06810000, 0x0a00e030,
-	0x04001c71, 0x09101030, 0x02031031, 0x02031031, 0x07000c41,
-	0x04001c71, 0x07000c40, 0x09610040, 0x0aa0ffcd, 0x0b80404c,
-	0x00000000, 0x04000301, 0x04000348, 0x04001208, 0x0b8ec388,
-	0x0cc00000, 0x00000000, 0x0649c701, 0x0aa24001, 0x04401041,
-	0x0809c700, 0x05403041, 0x020013c1, 0x04001041, 0x07000070,
-	0x09c302f0, 0x07400070, 0x0649c801, 0x0aa24001, 0x04401041,
-	0x0809c800, 0x05403041, 0x020013c1, 0x04001041, 0x07000070,
-	0x09c302f0, 0x07400070, 0x0cc00000, 0x00000000, 0x0680400f,
-	0x05403c4d, 0x02031c4f, 0x04001c71, 0x07000c40, 0x06800081,
-	0x09542001, 0x07400c40, 0x04401c31, 0x07000c04, 0x0c7800c0,
-	0x05808044, 0x0be20041, 0x07801c01, 0x0aa10001, 0x0a216004,
+	0x00000000, 0x0780720d, 0x0780390c, 0x0b81c30d, 0x0c07f840,
+	0x00000000, 0x0aa67fcb, 0x0680400f, 0x05403c4b, 0x02031c4f,
+	0x04001c71, 0x07000c70, 0x06800000, 0x09404c00, 0x07400c70,
+	0x07807200, 0x04401000, 0x07c07200, 0x04401071, 0x07000040,
+	0x09005000, 0x06800041, 0x03401001, 0x07807080, 0x03000040,
+	0x07c07080, 0x06810000, 0x0bc04030, 0x078071c0, 0x04401000,
+	0x07c071c0, 0x0cc00000, 0x00000000, 0x0680400f, 0x0780704e,
+	0x06803fcd, 0x0680000c, 0x06800008, 0x05403c48, 0x02031c4f,
+	0x04001c71, 0x07000c70, 0x06810000, 0x0a00e030, 0x04001c71,
+	0x09101030, 0x02031031, 0x02031031, 0x07000c41, 0x04001c71,
+	0x07000c40, 0x09610040, 0x0aa0ffcd, 0x0b80404c, 0x00000000,
+	0x04000301, 0x04000348, 0x04001208, 0x0b8ec388, 0x00000000,
+	0x05403c4d, 0x02031c4f, 0x07000c70, 0x0cc00000, 0x091233f0,
+	0x0649c701, 0x0aa24001, 0x04401041, 0x0809c700, 0x05403041,
+	0x020013c1, 0x04001041, 0x07000070, 0x09c302f0, 0x07400070,
+	0x0649c801, 0x0aa24001, 0x04401041, 0x0809c800, 0x05403041,
+	0x020013c1, 0x04001041, 0x07000070, 0x09c302f0, 0x07400070,
+	0x0cc00000, 0x00000000, 0x0680400f, 0x05403c4d, 0x02031c4f,
+	0x04001c71, 0x07000c40, 0x06800081, 0x09542001, 0x07400c40,
+	0x04401c31, 0x07000c04, 0x090c2040, 0x0609d701, 0x07802141,
+	0x0a644001, 0x078006c1, 0x0b63c081, 0x0aa24001, 0x07800730,
+	0x07800741, 0x09610c01, 0x0b402c0c, 0x0a64000c, 0x068000b0,
+	0x0c7801c0, 0x07c006f0, 0x07c0070c, 0x0581004c, 0x07c00741,
+	0x06800041, 0x07c006c1, 0x07801c01, 0x0aa10001, 0x0a216004,
 	0x06800001, 0x07c01c01, 0x05809040, 0x0a218041, 0x06800001,
-	0x09523001, 0x07400c40, 0x0c781300, 0x044012cb, 0x0c07f440,
+	0x09523001, 0x07400c40, 0x0c781300, 0x044012cb, 0x0c07f000,
 	0x00000000, 0x0649c001, 0x0bef7fc1, 0x09101044, 0x0a60c00b,
 	0x05409041, 0x0809d100, 0x09123c04, 0x0540210b, 0x03430130,
 	0x0649d104, 0x02c04c04, 0x0609d104, 0x0940504d, 0x09184c00,
@@ -89,22 +92,21 @@ static const u32 MicroCode[] __initconst = {
 	0x0609ca04, 0x0c7801c0, 0x0609c101, 0x0649ca30, 0x09610c04,
 	0x0609ca30, 0x0c780080, 0x0609c201, 0x0649cf01, 0x0be09001,
 	0x0be100c0, 0x078071c0, 0x04401000, 0x07c071c0, 0x0cc00000,
-	0x00000000, 0x0680000b, 0x07803d0d, 0x0a21880d, 0x0780318c,
-	0x07801b8d, 0x0b00334c, 0x00000000, 0x07801b8c, 0x078071cd,
-	0x0649cf00, 0x0be0d000, 0x0b01730d, 0x0c7800c0, 0x0680004c,
-	0x0b80d30d, 0x00000000, 0x0c07d4c0, 0x00000000, 0x0a613fcd,
-	0x0c079cc0, 0x00000000, 0x0c780180, 0x0c07dfc0, 0x00000000,
-	0x040012cb, 0x0aa0808b, 0x0c7ff9c0, 0x0aa1400b, 0x06800080,
-	0x0950800b, 0x0609c000, 0x0609ce00, 0x0cc00000, 0x00000000,
-	0x0649cf0c, 0x0bee208c, 0x078071cc, 0x0bad808c, 0x0c07cf40,
-	0x00000000, 0x0aacffcd, 0x07800b00, 0x07800af0, 0x09610030,
-	0x04002000, 0x07802ff0, 0x0a60c030, 0x0b8e700c, 0x0c7ffac0,
-	0x0b0e500c, 0x0c7ffa40, 0x00000000, 0x0680000b, 0x078071cd,
-	0x0aa3c00d, 0x0c07cb00, 0x00000000, 0x0a613fcd, 0x0c079300,
-	0x00000000, 0x0c780240, 0x07807180, 0x0a807340, 0x00000000,
-	0x0c07d540, 0x00000000, 0x040012cb, 0x0aa0808b, 0x0c7ffc40,
+	0x00000000, 0x0680000b, 0x078071cd, 0x07801b8c, 0x0649cf00,
+	0x0be0d000, 0x0b01630d, 0x0c7800c0, 0x0680004c, 0x0b80c30d,
+	0x0c07d140, 0x00000000, 0x0a613fcd, 0x0c079b00, 0x00000000,
+	0x0c780180, 0x0c07dd40, 0x00000000, 0x040012cb, 0x0aa0808b,
+	0x0c7ffb80, 0x0aa1400b, 0x06800080, 0x0950800b, 0x0609c000,
+	0x0609ce00, 0x0cc00000, 0x00000000, 0x0649cf0c, 0x0bee208c,
+	0x0c07cc40, 0x00000000, 0x0aad7fcd, 0x07800b00, 0x07800af0,
+	0x09610030, 0x078008f0, 0x0a610030, 0x06800070, 0x07c008f0,
+	0x0a8e8300, 0x078071f0, 0x0baac0b0, 0x04002000, 0x0ba0c00c,
+	0x0aa0814f, 0x0b0e200c, 0x0c7ff980, 0x00000000, 0x0680000b,
+	0x078071cd, 0x0aa3800d, 0x0c07c6c0, 0x00000000, 0x0a613fcd,
+	0x0c079080, 0x00000000, 0x0c780200, 0x07807180, 0x0a806340,
+	0x0c07d240, 0x00000000, 0x040012cb, 0x0aa0808b, 0x0c7ffc80,
 	0x0aa1c00b, 0x06800080, 0x0950800b, 0x0609c000, 0x0609ce00,
-	0x0c7ffac0, 0x0680000b, 0x0cc00000, 0x00000000, 0x0680400f,
+	0x0c7ffb00, 0x0680000b, 0x0cc00000, 0x00000000, 0x0680400f,
 	0x0780704e, 0x06800008, 0x06800007, 0x07807186, 0x078072c0,
 	0x0a225800, 0x07c07087, 0x05403c46, 0x02031c4f, 0x07000c70,
 	0x09005c30, 0x06800041, 0x03401c01, 0x07c07081, 0x05403c48,
@@ -128,8 +130,8 @@ static const u32 MicroCode[] __initconst = {
 	0x094021c0, 0x07807200, 0x04401000, 0x07c07200, 0x04401046,
 	0x07000040, 0x09005000, 0x06800041, 0x03401001, 0x07807080,
 	0x03000040, 0x07c07080, 0x06810000, 0x0bc04007, 0x078071c0,
-	0x04401000, 0x07c071c0, 0x0649cf00, 0x0be14080, 0x07400187,
-	0x0be0d000, 0x04001208, 0x0b8ce248, 0x0cc00000, 0x00000000,
+	0x04401000, 0x07c071c0, 0x0649cf00, 0x0be14080, 0x0cc00000,
+	0x07400187, 0x04001208, 0x0b8ce248, 0x0cc00000, 0x00000000,
 	0x07807108, 0x07807149, 0x0680a00a, 0x0a403209, 0x0cc00000,
 	0x00000000, 0x05402108, 0x0200410a, 0x04002c44, 0x07000c40,
 	0x04001c71, 0x07000c41, 0x09610001, 0x0a42a380, 0x07000105,
@@ -172,36 +174,34 @@ static const u32 MicroCode[] __initconst = {
 	0x03401001, 0x07807080, 0x03000040, 0x07c07080, 0x06810000,
 	0x0bc04007, 0x078071c0, 0x04401000, 0x07c071c0, 0x07400187,
 	0x04001208, 0x0b8dc248, 0x0cc00000, 0x00000000, 0x06800010,
-	0x078020b1, 0x0a62c0b1, 0x07800b71, 0x0aa0c0b1, 0x07800bb1,
-	0x0aa1c031, 0x0c07aa80, 0x07c00b90, 0x07c00b50, 0x07c01e50,
-	0x0c07a300, 0x00000000, 0x0649cf31, 0x0be100b1, 0x078072f1,
-	0x09005031, 0x0a638140, 0x06800011, 0x0c07a780, 0x00000000,
-	0x0780e100, 0x0be18080, 0x09001400, 0x0c079fc0, 0x00000000,
-	0x0c781800, 0x00000000, 0x0c07aec0, 0x00000000, 0x0c781700,
-	0x06800000, 0x090a2071, 0x0780e130, 0x0a858001, 0x0a857030,
-	0x0680e10f, 0x070003c0, 0x0aa2c040, 0x0aa3c080, 0x0aa4c0c0,
-	0x0aa68100, 0x00000000, 0x04605040, 0x0c500740, 0x00000000,
-	0x04606040, 0x0c5010c0, 0x0c781280, 0x04001c4f, 0x0c07ae80,
-	0x07000c4e, 0x0c7ffc40, 0x040023cf, 0x04001c4f, 0x0c07be00,
-	0x07000c4e, 0x0c7ffb00, 0x040023cf, 0x04002c4f, 0x0c07cb80,
-	0x07000c4e, 0x04001c4f, 0x0c07d780, 0x07000c4d, 0x0c7ff900,
-	0x040033cf, 0x04001c4f, 0x07000c4e, 0x0c07e200, 0x00000000,
-	0x0c7ff780, 0x040023cf, 0x0c079a00, 0x00000000, 0x0c079300,
-	0x00000000, 0x06800007, 0x07807331, 0x0b250071, 0x07807770,
-	0x07807780, 0x09610c00, 0x07807841, 0x07807880, 0x09610040,
-	0x02401c01, 0x07c07841, 0x05810001, 0x07c07880, 0x078077c1,
-	0x07807800, 0x09610040, 0x02401c01, 0x07c077c1, 0x05810001,
-	0x07c07800, 0x0c7801c0, 0x07c07441, 0x07c07447, 0x07c077c7,
-	0x07c07807, 0x07c07847, 0x07c07887, 0x07c07347, 0x07c07487,
-	0x07c07647, 0x07c07687, 0x07c076c7, 0x07c07707, 0x07c07747,
-	0x07c07787, 0x0c7fed40, 0x040013cf, 0x04001c4f, 0x07000c4e,
-	0x0c07bd80, 0x00000000, 0x06800050, 0x0400044e, 0x0c7feb40,
-	0x040023cf, 0x0680400f, 0x0780718e, 0x0540338e, 0x0200e38f,
-	0x04001c4e, 0x07000c40, 0x0a2140c0, 0x0c071d80, 0x07c031d0,
-	0x0cc00000, 0x00000000, 0x078072f1, 0x09005031, 0x090a2071,
-	0x0aa10140, 0x0aa0c001, 0x0c074580, 0x00000000, 0x0649cf00,
-	0x0a219000, 0x0c071a40, 0x07c031d0, 0x0c0774c0, 0x00000000,
-	0x0c780140, 0x0c077400, 0x00000000, 0x0c071880, 0x07c031d0,
-	0x0cc00000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000
+	0x078020b1, 0x0a6280b1, 0x07800b71, 0x0aa0c0b1, 0x07800bb1,
+	0x0aa18031, 0x0c07aa80, 0x07c00b90, 0x07c00b50, 0x0c07a380,
+	0x00000000, 0x0649cf31, 0x0be100b1, 0x078072f1, 0x09005031,
+	0x0a634140, 0x06800011, 0x0c07a7c0, 0x00000000, 0x0780e100,
+	0x0be14080, 0x09001400, 0x0c07a040, 0x00000000, 0x0c7817c0,
+	0x0c07af40, 0x00000000, 0x0c781700, 0x06800000, 0x090a2071,
+	0x0780e130, 0x0a858001, 0x0a857030, 0x0680e10f, 0x070003c0,
+	0x0aa2c040, 0x0aa3c080, 0x0aa4c0c0, 0x0aa68100, 0x00000000,
+	0x04605040, 0x0c500740, 0x00000000, 0x04606040, 0x0c5010c0,
+	0x0c781280, 0x04001c4f, 0x0c07af00, 0x07000c4e, 0x0c7ffc40,
+	0x040023cf, 0x04001c4f, 0x0c07be80, 0x07000c4e, 0x0c7ffb00,
+	0x040023cf, 0x04002c4f, 0x0c07cc00, 0x07000c4e, 0x04001c4f,
+	0x0c07d800, 0x07000c4d, 0x0c7ff900, 0x040033cf, 0x04001c4f,
+	0x07000c4e, 0x0c07e280, 0x00000000, 0x0c7ff780, 0x040023cf,
+	0x0c079a80, 0x00000000, 0x0c0793c0, 0x00000000, 0x06800007,
+	0x07807331, 0x0b250071, 0x07807770, 0x07807780, 0x09610c00,
+	0x07807841, 0x07807880, 0x09610040, 0x02401c01, 0x07c07841,
+	0x05810001, 0x07c07880, 0x078077c1, 0x07807800, 0x09610040,
+	0x02401c01, 0x07c077c1, 0x05810001, 0x07c07800, 0x0c7801c0,
+	0x07c07441, 0x07c07447, 0x07c077c7, 0x07c07807, 0x07c07847,
+	0x07c07887, 0x07c07347, 0x07c07487, 0x07c07647, 0x07c07687,
+	0x07c076c7, 0x07c07707, 0x07c07747, 0x07c07787, 0x0c7fed40,
+	0x040013cf, 0x04001c4f, 0x07000c4e, 0x0c07be00, 0x00000000,
+	0x06800050, 0x0400044e, 0x0c7feb40, 0x040023cf, 0x0680400f,
+	0x0780718e, 0x0540338e, 0x0200e38f, 0x04001c4e, 0x07000c40,
+	0x0a2100c0, 0x0c071bc0, 0x07c031d0, 0x0cc00000, 0x078072f1,
+	0x09005031, 0x090a2071, 0x0aa10140, 0x0aa0c001, 0x0c0743c0,
+	0x00000000, 0x0649cf00, 0x0a219000, 0x0c0718c0, 0x07c031d0,
+	0x0c0776c0, 0x00000000, 0x0c780140, 0x0c077600, 0x00000000,
+	0x0c071700, 0x07c031d0, 0x0cc00000, 0x00000000
 };
diff --git a/drivers/amlogic/amports/arch/ucode/h264/h264slice_linux.h b/drivers/amlogic/amports/arch/ucode/h264/h264slice_linux.h
index 3beb510..35de005 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/h264slice_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/h264/h264slice_linux.h
@@ -114,7 +114,7 @@ static const u32 MicroCode[] __initconst = {
 	0x094a240d, 0x040013cb, 0x0be0c0cf, 0x00000000, 0x060c2210,
 	0x040012cb, 0x0b8a330b, 0x0a2240cc, 0x090022cc, 0x0680010c,
 	0x0240c2cc, 0x090082d0, 0x05408410, 0x0d07ffcc, 0x0940840b,
-	0x060c2210, 0x0780208a, 0x0a60c08a, 0x0680000a, 0x07c01e4a,
+	0x060c2210, 0x07802e4a, 0x0a60c14a, 0x0680000a, 0x07c01e4a,
 	0x0694000a, 0x06c0444a, 0x0680c009, 0x0c05a300, 0x06a0400b,
 	0x0c05cf40, 0x080c2301, 0x0c05d0c0, 0x00000000, 0x0401a1c7,
 	0x07802248, 0x02007207, 0x07c02387, 0x07802287, 0x0aa40007,
diff --git a/drivers/amlogic/amports/arch/ucode/h264/mh264c_linux.h b/drivers/amlogic/amports/arch/ucode/h264/mh264c_linux.h
new file mode 100644
index 0000000..8695885
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264/mh264c_linux.h
@@ -0,0 +1,822 @@
+static const u32 MicroCode[] __initconst = {
+	0x06810001, 0x06800000, 0x0d000001, 0x07400040, 0x064c0800,
+	0x09800300, 0x00000000, 0x060c0800, 0x0649d019, 0x0c007200,
+	0x0649c834, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0c780800, 0x00000000, 0x00000000, 0x00000000, 0x0c7ffe80,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x0c781400, 0x00000000, 0x0cc00000,
+	0x00400000, 0x0c7815c0, 0x064c0007, 0x0cc00000, 0x00400000,
+	0x0c788b40, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c7889c0, 0x00000000, 0x0c7885c0, 0x00000000,
+	0x0cc00000, 0x00400000, 0x0680001b, 0x0649d302, 0x0a6fbc02,
+	0x00000000, 0x0809d383, 0x0649c300, 0x0aa20000, 0x00000000,
+	0x064c0801, 0x09801301, 0x060c0801, 0x0fc10040, 0x0d07ffc0,
+	0x00000000, 0x080c0002, 0x06bfda80, 0x07c02d40, 0x06030400,
+	0x00400000, 0x0649c702, 0x04001082, 0x0609c702, 0x00000000,
+	0x0649d302, 0x0aa7bc02, 0x00000000, 0x0aa17cc2, 0x0aa13c42,
+	0x0aa320c2, 0x0c7ffd80, 0x0680001b, 0x07803f03, 0x0a8044c3,
+	0x07c03f13, 0x0c7ffc40, 0x0680001b, 0x0b2bc11b, 0x06800843,
+	0x0c780300, 0x0680001b, 0x064c4303, 0x0a403703, 0x04000703,
+	0x0b20d003, 0x0c7ff9c0, 0x0680001b, 0x0b29421b, 0x06800883,
+	0x0c780080, 0x0680001b, 0x0609d303, 0x08007401, 0x00800000,
+	0x0c780000, 0x0680001b, 0x0809d383, 0x080c0002, 0x00400000,
+	0x0c7ff640, 0x00000000, 0x0c7ff080, 0x040016db, 0x07801949,
+	0x0a212009, 0x09c091c9, 0x0c7a7540, 0x07c01949, 0x00800000,
+	0x07802d49, 0x0c7fee40, 0x06030409, 0x06bf9b89, 0x06030409,
+	0x00400000, 0x064c470a, 0x0b20ffca, 0x0c780140, 0x00000000,
+	0x0809d320, 0x08007401, 0x0c780000, 0x064c4309, 0x05801249,
+	0x0badd809, 0x00000000, 0x0a2a4047, 0x0a208807, 0x0c782ac0,
+	0x0be51007, 0x0a208207, 0x0c784c00, 0x0683ffca, 0x0aa4000a,
+	0x0440128a, 0x064e0f07, 0x09003207, 0x09063247, 0x0b403209,
+	0x02409209, 0x04008249, 0x0ba180c9, 0x0aedc0c9, 0x080c3e00,
+	0x064c3f07, 0x090021c7, 0x0a6cc0c7, 0x0cb8001a, 0x00000000,
+	0x0c000280, 0x00000000, 0x06bfffca, 0x07903c08, 0x0a402288,
+	0x0c784980, 0x0be08207, 0x0c7ffa00, 0x0c784580, 0x00000000,
+	0x0649cd09, 0x04001249, 0x0609cd09, 0x0c000780, 0x064c380e,
+	0x064c0809, 0x064c090b, 0x0680040a, 0x063f000a, 0x0680000a,
+	0x063f000a, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x060c0809, 0x060c090b, 0x0688000a, 0x060c290a, 0x0c0005c0,
+	0x00000000, 0x0680000a, 0x060c0c0a, 0x06c0404a, 0x060c0d0a,
+	0x080c0101, 0x0684044a, 0x060c2e0a, 0x060c380e, 0x0c001800,
+	0x00000000, 0x0cc00000, 0x00000000, 0x0683ffc9, 0x0aa18009,
+	0x0649470a, 0x0910828a, 0x07802cc8, 0x0a4fc20a, 0x04401249,
+	0x0cc00000, 0x00000000, 0x0c009f80, 0x00000000, 0x06490b09,
+	0x09809009, 0x09809089, 0x06090b09, 0x09c09009, 0x09c09089,
+	0x06090b09, 0x08095007, 0x08095000, 0x0683ffc9, 0x06498f0a,
+	0x0aa0c009, 0x0a6f800a, 0x04401249, 0x064c3d0a, 0x0580a28a,
+	0x0bef80ca, 0x00000000, 0x06498e0a, 0x0980a00a, 0x068007c9,
+	0x09706289, 0x06098e0a, 0x06800009, 0x09706289, 0x09c0a00a,
+	0x06098e0a, 0x0649b80a, 0x06800fc9, 0x09508289, 0x0cc00000,
+	0x0609b80a, 0x0200ad0a, 0x0603510a, 0x06035209, 0x0603500b,
+	0x0643500c, 0x0580f30c, 0x0bef804c, 0x00000000, 0x0643530c,
+	0x0900c30c, 0x0a6f800c, 0x00000000, 0x0cc00000, 0x0240ad0a,
+	0x0200a64a, 0x0603410a, 0x06810009, 0x06034209, 0x06a2000b,
+	0x06c001cb, 0x0603400b, 0x0643400c, 0x0580f30c, 0x0bef804c,
+	0x0cc00000, 0x00000000, 0x08032100, 0x0200a64a, 0x0603410a,
+	0x06810009, 0x06034209, 0x06a3000b, 0x06c001cb, 0x0603400b,
+	0x0643400c, 0x0580f30c, 0x0bef804c, 0x06840008, 0x063f0008,
+	0x06800008, 0x063f0008, 0x08002a09, 0x08002b17, 0x06830008,
+	0x06032608, 0x08032261, 0x08032101, 0x0cc00000, 0x00000000,
+	0x0680004a, 0x060e0c0a, 0x07c026ca, 0x07c0250a, 0x068003ca,
+	0x07c0280a, 0x06805c0a, 0x060c210a, 0x080c2170, 0x0680008a,
+	0x07c02a4a, 0x06800018, 0x0680000a, 0x0cc00000, 0x07c0248a,
+	0x0a25d007, 0x0680004a, 0x0c07e4c0, 0x07c01e4a, 0x064c000a,
+	0x09c0a18a, 0x0980a20a, 0x0980a00a, 0x060c000a, 0x064c2908,
+	0x09c08348, 0x09808208, 0x060c2908, 0x09808348, 0x09c08208,
+	0x060c2908, 0x064c080a, 0x0980a34a, 0x060c080a, 0x0c07e2c0,
+	0x00000000, 0x0c07f700, 0x00000000, 0x080c0600, 0x0fc081c0,
+	0x06803fc9, 0x0a404247, 0x00000000, 0x0c7815c0, 0x0680048a,
+	0x090a2207, 0x07c02048, 0x0481f1c7, 0x07c02007, 0x0aa38147,
+	0x0aa34047, 0x0a60c187, 0x0c780b80, 0x0682b78d, 0x0a60c1c7,
+	0x0c780ac0, 0x0682000d, 0x0a60c207, 0x0c780a00, 0x06826ecd,
+	0x0a608247, 0x0c780740, 0x0c781640, 0x0c78dd40, 0x00000000,
+	0x064c4408, 0x09101208, 0x0aaf8048, 0x064c5109, 0x064c460a,
+	0x064c400b, 0x064c4208, 0x024082c8, 0x04008208, 0x0580a208,
+	0x0e000248, 0x00000000, 0x00000000, 0x00000000, 0x0f000200,
+	0x0f010240, 0x09708209, 0x0540a208, 0x02008288, 0x064c4309,
+	0x02408248, 0x064c4009, 0x02408248, 0x0cc00000, 0x0440a208,
+	0x0c07f9c0, 0x00000000, 0x07c00bc8, 0x05810208, 0x07c00c08,
+	0x06800048, 0x0c780dc0, 0x07c00c48, 0x07803bc8, 0x090821c8,
+	0x0aa18047, 0x06800047, 0x09482207, 0x0680000a, 0x0c07dd40,
+	0x06c0000a, 0x07c03bc8, 0x0cb8000d, 0x00000000, 0x064c2907,
+	0x0be14407, 0x064c2307, 0x0bef4047, 0x0cc00000, 0x064c2007,
+	0x0cc00000, 0x06800007, 0x040011c7, 0x06800008, 0x0a20c047,
+	0x058011c7, 0x024071c8, 0x0cc00000, 0x00000000, 0x07802487,
+	0x0a6fc007, 0x00000000, 0x06430507, 0x0a2f0107, 0x00000000,
+	0x064c0007, 0x0a2fc047, 0x00000000, 0x064c3a07, 0x090061c7,
+	0x0aaec647, 0x00000000, 0x06a00007, 0x060c3d07, 0x0c007f00,
+	0x00000000, 0x0c0077c0, 0x00000000, 0x080c0a01, 0x080c2800,
+	0x00800000, 0x0609d30a, 0x08007401, 0x07802d49, 0x0cc00000,
+	0x06030409, 0x064c1a07, 0x0ae14807, 0x00000000, 0x00800000,
+	0x0c7ff9c0, 0x0680048a, 0x064c0007, 0x0a2e4047, 0x00000000,
+	0x064c3a07, 0x090061c7, 0x0aad4647, 0x00000000, 0x080c0a01,
+	0x080c2800, 0x0809d383, 0x080c0002, 0x0c7fa8c0, 0x00000000,
+	0x06800013, 0x0684000a, 0x0c07cc40, 0x06c0000a, 0x069fffc2,
+	0x07c03b42, 0x07c03b82, 0x07c03c42, 0x07c00a02, 0x07c00a42,
+	0x07c00a82, 0x07c03c82, 0x07c01742, 0x07c017c2, 0x068003c2,
+	0x07c02fc2, 0x0680c002, 0x06094002, 0x06803003, 0x06804002,
+	0x0d000003, 0x06094102, 0x06800002, 0x06094002, 0x0649c207,
+	0x0a614007, 0x00000000, 0x0c000680, 0x00000000, 0x06800007,
+	0x07c01e87, 0x06800007, 0x060c0c07, 0x06c04047, 0x060c0d07,
+	0x08002501, 0x08002605, 0x08002708, 0x0800290d, 0x08002d15,
+	0x08002c14, 0x0649b802, 0x06800fc3, 0x09508083, 0x0609b802,
+	0x08002a09, 0x08002b17, 0x06830002, 0x06032602, 0x08032261,
+	0x08032101, 0x0cc00000, 0x0680001b, 0x0649c203, 0x0aa08003,
+	0x0c780800, 0x06800203, 0x07c03bc3, 0x06800712, 0x06800033,
+	0x07c02bf3, 0x07c01933, 0x07c01973, 0x07c01df3, 0x07c01e33,
+	0x0649c203, 0x0a654003, 0x06800803, 0x0697000a, 0x06c0444a,
+	0x06810002, 0x06800049, 0x06a02bcb, 0x0c07b700, 0x00000000,
+	0x0d07ff83, 0x0200a08a, 0x06804003, 0x06b7000a, 0x06c0444a,
+	0x06808002, 0x06800049, 0x06a02bcb, 0x0c07b480, 0x00000000,
+	0x0d07ff83, 0x0200a08a, 0x064e1203, 0x091e10c3, 0x0bef8043,
+	0x064c0903, 0x06803002, 0x0649c20a, 0x0a63400a, 0x063f0002,
+	0x06800002, 0x063f0002, 0x06803fc2, 0x060c0903, 0x06800002,
+	0x060c0c02, 0x06c04042, 0x060c0d02, 0x080c0101, 0x06840442,
+	0x060c2e02, 0x0cc00000, 0x00000000, 0x07802bc2, 0x0aa0c002,
+	0x06800102, 0x06030502, 0x0b60c21b, 0x0cc00000, 0x00000000,
+	0x00800000, 0x0cc00000, 0x00400000, 0x064c441c, 0x064c4732,
+	0x0910171c, 0x0b213ff2, 0x0a6f001c, 0x0c780140, 0x00000000,
+	0x0809d320, 0x08007401, 0x0c780000, 0x0c7f7840, 0x00000000,
+	0x0cc00000, 0x00400000, 0x064e1214, 0x091e1514, 0x0bef0054,
+	0x078029d5, 0x0649d914, 0x0900c514, 0x0acfe554, 0x07802494,
+	0x0aa44094, 0x0c7828c0, 0x06800015, 0x06c04015, 0x07802857,
+	0x097c1557, 0x060e1215, 0x07802d15, 0x0a20c055, 0x06800018,
+	0x06880018, 0x06c04418, 0x02018d18, 0x06800014, 0x07c02a94,
+	0x0c782280, 0x06800114, 0x07802a95, 0x0aa08095, 0x0c781200,
+	0x078024d6, 0x0aeb4096, 0x07802857, 0x0aa4c712, 0x07802ad4,
+	0x05406514, 0x07802d15, 0x05801555, 0x0be0c055, 0x06800015,
+	0x06880015, 0x06c04415, 0x02015d15, 0x02014554, 0x04440514,
+	0x060e1314, 0x0aa44017, 0x040c0614, 0x06805c16, 0x060c2116,
+	0x0c780340, 0x04040618, 0x05405514, 0x07802d15, 0x0be0c055,
+	0x06800015, 0x06880015, 0x06c04415, 0x02015d15, 0x02014554,
+	0x04420514, 0x060e1314, 0x04060614, 0x07802596, 0x0aa14016,
+	0x06a2c215, 0x0aa0c056, 0x06a2c015, 0x06a2c115, 0x0aa10017,
+	0x06c04015, 0x068003d4, 0x09506554, 0x097c1557, 0x060e1215,
+	0x06800014, 0x07c02a94, 0x06800114, 0x0c781b00, 0x07c02494,
+	0x078025d5, 0x078029d6, 0x02415595, 0x02415595, 0x07802857,
+	0x0aa0c017, 0x02415595, 0x02415595, 0x07802694, 0x05409514,
+	0x02014554, 0x05403554, 0x02015d15, 0x060e1315, 0x07802596,
+	0x0aa34016, 0x06a44215, 0x0aa2c056, 0x06a44015, 0x0c780240,
+	0x06a44115, 0x0a64c0d5, 0x078026d4, 0x064e0c16, 0x09010596,
+	0x0b8e7594, 0x0cc00000, 0x00400000, 0x0aa10017, 0x06c0c015,
+	0x068005d4, 0x09506554, 0x097c1557, 0x060e1215, 0x06800018,
+	0x06800014, 0x07c02a94, 0x06800154, 0x0c781100, 0x07c02494,
+	0x07802515, 0x0aa1c015, 0x04401555, 0x07c02515, 0x078024d5,
+	0x04401555, 0x0c780d80, 0x07c024d5, 0x07802615, 0x07c02655,
+	0x07802694, 0x05409514, 0x02014554, 0x078029d6, 0x02015595,
+	0x07c02615, 0x05403554, 0x02015d15, 0x060e1315, 0x07802596,
+	0x0aa14016, 0x06a16215, 0x0aa0c056, 0x06a16015, 0x06a16115,
+	0x07803056, 0x0aa28016, 0x078026d4, 0x064e0c16, 0x09010596,
+	0x0b804594, 0x07802656, 0x0c7fda00, 0x07c02616, 0x04001514,
+	0x07c026d4, 0x07c02715, 0x06c00015, 0x060e1215, 0x06800054,
+	0x0c780680, 0x07c02494, 0x0ba58114, 0x07802855, 0x0a608015,
+	0x0c7ff4c0, 0x078026d5, 0x04001555, 0x07c026d5, 0x0aa0c114,
+	0x06800015, 0x080c2170, 0x0c780300, 0x07c02855, 0x0a6d0054,
+	0x078024d5, 0x0aa74015, 0x04401555, 0x0b26c055, 0x07c024d5,
+	0x07802a54, 0x0aa0c0d4, 0x00000000, 0x080c2170, 0x06800014,
+	0x07c02494, 0x0cc00000, 0x00400000, 0x0aa0c014, 0x06880018,
+	0x06800018, 0x06c04418, 0x0c780a40, 0x02018d18, 0x0aa0c712,
+	0x090a8518, 0x090c7518, 0x07802c56, 0x0b823594, 0x0a8f5594,
+	0x091a1518, 0x0aa20014, 0x06880018, 0x0c780180, 0x06800018,
+	0x0aa70018, 0x078025d5, 0x0c7ffcc0, 0x00000000, 0x06c04418,
+	0x02018d18, 0x07802694, 0x05409514, 0x078029d6, 0x02415595,
+	0x02014554, 0x05403554, 0x02015d15, 0x060e1315, 0x07802714,
+	0x09004554, 0x0aa14015, 0x06a14214, 0x0aa0c115, 0x06a14014,
+	0x06a14114, 0x06c08014, 0x060e0d18, 0x0aa0c712, 0x04020618,
+	0x04020618, 0x0c7ff4c0, 0x060e1214, 0x07802694, 0x05409514,
+	0x02014554, 0x078029d6, 0x02015595, 0x07c025d5, 0x05403554,
+	0x02015d15, 0x060e1315, 0x07802714, 0x0a618018, 0x09c141d4,
+	0x060e1214, 0x068000d4, 0x0c7ff0c0, 0x07c02494, 0x06c08014,
+	0x060e0d18, 0x0aae8712, 0x04020618, 0x0c7ffe00, 0x04020618,
+	0x0683ffca, 0x0a61000a, 0x0440128a, 0x0c780140, 0x080e1200,
+	0x064e1209, 0x091e1249, 0x0bee8049, 0x064e0009, 0x064e030a,
+	0x064e0e0b, 0x064e0c0c, 0x083f0040, 0x083f0000, 0x0680020d,
+	0x0d00000d, 0x00000000, 0x060e0009, 0x060e030a, 0x060e0e0b,
+	0x0cc00000, 0x060e0c0c, 0x0c000ac0, 0x00000000, 0x06810109,
+	0x06c34749, 0x06090709, 0x06490b09, 0x09809009, 0x09809089,
+	0x06090b09, 0x09c09009, 0x09c09089, 0x06090b09, 0x06800009,
+	0x06c04409, 0x02009d09, 0x06094409, 0x06880009, 0x06c04409,
+	0x02009d09, 0x06094509, 0x0cc00000, 0x00000000, 0x0c000c00,
+	0x00000000, 0x06497f08, 0x068000c7, 0x09702207, 0x06097f08,
+	0x06498e08, 0x09c08788, 0x06098e08, 0x06820888, 0x06c00208,
+	0x07802c47, 0x0b20c2c7, 0x06800447, 0x06800c07, 0x09706207,
+	0x09808648, 0x06095108, 0x08095007, 0x0cc00000, 0x08095000,
+	0x0683ffc8, 0x06490909, 0x0a210049, 0x0aa0c008, 0x0c7fff40,
+	0x04401208, 0x0683ffc8, 0x06490909, 0x09343249, 0x0a2241c9,
+	0x0aa20008, 0x06490b09, 0x098090c9, 0x06090b09, 0x09c090c9,
+	0x06090b09, 0x0c7ffdc0, 0x04401208, 0x06490b09, 0x09809009,
+	0x09809089, 0x06090b09, 0x09c09009, 0x09c09089, 0x06090b09,
+	0x0cc00000, 0x00000000, 0x0683ffc9, 0x0649bb08, 0x0920c208,
+	0x06495307, 0x090011c7, 0x020081c8, 0x0aa10008, 0x0aa0c009,
+	0x0c7ffe40, 0x04401249, 0x0cc00000, 0x00000000, 0x04000289,
+	0x02408289, 0x0b64a008, 0x00000000, 0x0c077580, 0x080c2301,
+	0x02408289, 0x0b60d008, 0x00000000, 0x07400247, 0x0aa280c7,
+	0x04001249, 0x0c077380, 0x080c2301, 0x02408289, 0x0b60d008,
+	0x00000000, 0x07400247, 0x0c7ffbc0, 0x04001249, 0x068000c7,
+	0x0404028a, 0x07400287, 0x0cc00000, 0x00000000, 0x0680000a,
+	0x04001249, 0x0fc011c0, 0x0aa20047, 0x0680004b, 0x06494207,
+	0x090841c7, 0x0340b1cb, 0x054082cb, 0x0c780340, 0x0609410b,
+	0x0c076d80, 0x080c2301, 0x0c076f00, 0x00000000, 0x040002c7,
+	0x0c076c40, 0x080c2301, 0x0c076dc0, 0x00000000, 0x095091cb,
+	0x06094107, 0x0fc011c0, 0x0aa24047, 0x0680004b, 0x06494207,
+	0x091041c7, 0x0340b1cb, 0x054082cb, 0x0609410b, 0x0c780600,
+	0x0609410b, 0x0c076840, 0x080c2301, 0x0c0769c0, 0x00000000,
+	0x040002c7, 0x0c076700, 0x080c2301, 0x0c076880, 0x00000000,
+	0x095091cb, 0x06094107, 0x0c076580, 0x080c2301, 0x0c076700,
+	0x00000000, 0x040002c7, 0x0c076440, 0x080c2301, 0x0c0765c0,
+	0x00000000, 0x095091cb, 0x06094107, 0x0400128a, 0x0b8cb24a,
+	0x0cc00000, 0x00000000, 0x0649cd09, 0x06800047, 0x054101c7,
+	0x020091c9, 0x0609cd09, 0x069fffc7, 0x07c03b47, 0x07c03b87,
+	0x07c03c47, 0x07c00a07, 0x07c00a47, 0x07c00a87, 0x07c03c87,
+	0x07c01747, 0x06800207, 0x07c03bc7, 0x0c7f6840, 0x00000000,
+	0x07803c0a, 0x0a60c00a, 0x0c780c80, 0x0680004a, 0x07802dca,
+	0x0aa0800a, 0x0c780b80, 0x0649cf07, 0x0a2180c7, 0x07803c07,
+	0x0aa0c007, 0x0680004a, 0x0680000a, 0x0c7809c0, 0x07807347,
+	0x07801f48, 0x0a803207, 0x0c7808c0, 0x0680004a, 0x07802407,
+	0x07801f08, 0x0a803207, 0x0c780780, 0x0680004a, 0x07802047,
+	0x07802e08, 0x02009207, 0x0aa18009, 0x0a803247, 0x0a802248,
+	0x0c7800c0, 0x0c780540, 0x0680004a, 0x07802007, 0x07802e48,
+	0x0a803207, 0x0c780400, 0x0680004a, 0x0a618147, 0x07801f87,
+	0x07801fc8, 0x0a803207, 0x0c780280, 0x0680004a, 0x07802147,
+	0x0aa1c087, 0x07801807, 0x0a4033c7, 0x07801847, 0x0a803407,
+	0x0c780080, 0x0680004a, 0x0cc00000, 0x07c02dca, 0x06490908,
+	0x0581f208, 0x0a6f8008, 0x00000000, 0x06490708, 0x09808648,
+	0x09c08488, 0x06090708, 0x068400c8, 0x096e820b, 0x097e120a,
+	0x07802407, 0x040011c7, 0x048031c7, 0x09542207, 0x0580124a,
+	0x06094809, 0x06094908, 0x06800008, 0x098092c8, 0x07801987,
+	0x09405247, 0x058051c7, 0x040011c7, 0x097c2207, 0x06094809,
+	0x06094908, 0x0c07c8c0, 0x00000000, 0x06490708, 0x09c08648,
+	0x09808488, 0x06090708, 0x0cc00000, 0x00000000, 0x0649cf07,
+	0x06800048, 0x0a2100c7, 0x07c01e48, 0x0cc00000, 0x00000000,
+	0x07801988, 0x0aa0c008, 0x0a210807, 0x00000000, 0x0cc00000,
+	0x00000000, 0x0c07c3c0, 0x00000000, 0x0c07be00, 0x00000000,
+	0x0780294e, 0x0a61038e, 0x07802c4e, 0x0c780340, 0x0980b00b,
+	0x0c07f200, 0x00000000, 0x0400128a, 0x0b80438a, 0x00000000,
+	0x0680000a, 0x040012cb, 0x0b8f934b, 0x0b8f830a, 0x0c780340,
+	0x00000000, 0x0c07ef40, 0x044012cb, 0x0c07eec0, 0x040012cb,
+	0x0400128a, 0x0b80438a, 0x00000000, 0x0680000a, 0x040022cb,
+	0x0b8f734b, 0x0b8f630a, 0x0cc00000, 0x00000000, 0x07803c07,
+	0x07802e88, 0x0a402207, 0x0c7809c0, 0x07c02e87, 0x07802c49,
+	0x0780294a, 0x0a60c30a, 0x07802c8a, 0x0540128a, 0x06800008,
+	0x0b80a247, 0x095084c7, 0x02407247, 0x0b8fd288, 0x04001208,
+	0x0649cd07, 0x040011c7, 0x0609cd07, 0x0cc00000, 0x06800047,
+	0x0aa0c007, 0x06800049, 0x07c02d89, 0x0aa0c712, 0x07c02cc7,
+	0x05401208, 0x094084c8, 0x07c02d08, 0x0780188a, 0x078018cb,
+	0x07802ccc, 0x07802d0d, 0x0c07ec80, 0x06800009, 0x07802cc7,
+	0x0aa18007, 0x044011c7, 0x0ba0c707, 0x0c7fffc0, 0x0441c1c7,
+	0x07c02b07, 0x07802cc7, 0x07c01887, 0x07802d07, 0x07c018c7,
+	0x0cc00000, 0x06800007, 0x0c7805c0, 0x06800087, 0x0c780540,
+	0x06800147, 0x0c7804c0, 0x06800187, 0x07800c48, 0x0a618008,
+	0x0c0722c0, 0x00000000, 0x07c00bc8, 0x05810208, 0x07c00c08,
+	0x06800008, 0x07c00c48, 0x0c072c00, 0x080c2301, 0x07c03c07,
+	0x0c072b40, 0x080c2301, 0x0aab01c7, 0x0aab4007, 0x0aab8047,
+	0x07c01ec7, 0x07803bc8, 0x09061248, 0x07c02dc9, 0x0a250208,
+	0x07803c08, 0x0aa08008, 0x0c7f32c0, 0x0649cf09, 0x0a20c0c9,
+	0x0aa2c087, 0x0c7f31c0, 0x07802008, 0x0aa20148, 0x07801c48,
+	0x0a614008, 0x0aa08087, 0x0c7f3040, 0x06800048, 0x07c01c48,
+	0x07c01c08, 0x0649c909, 0x04001249, 0x0609c909, 0x06800009,
+	0x07c01d89, 0x0c07a340, 0x00000000, 0x0c07a980, 0x00000000,
+	0x0c072280, 0x080c2301, 0x07803b8d, 0x0a806347, 0x07803bc8,
+	0x06800049, 0x07c02dc9, 0x0c780080, 0x07c03b87, 0x09082248,
+	0x0aa1c049, 0x0680000a, 0x0c06fb80, 0x06c0000a, 0x06800049,
+	0x09482209, 0x07c03bc8, 0x06b7000a, 0x06c0444a, 0x054091c7,
+	0x0200a1ca, 0x06804009, 0x06b0c00b, 0x0c06f540, 0x00000000,
+	0x0780c047, 0x09105207, 0x07803b4e, 0x07c03b48, 0x0697000a,
+	0x06c0444a, 0x07803b48, 0x0540a1c8, 0x0200a1ca, 0x06806009,
+	0x06b0400b, 0x0c06f200, 0x00000000, 0x0680000a, 0x0c00f680,
+	0x00000000, 0x0c018880, 0x00000000, 0x07803bc7, 0x0be34107,
+	0x0694000a, 0x06c0444a, 0x06804009, 0x06b0400b, 0x0c06eec0,
+	0x00000000, 0x0694c00a, 0x06c0444a, 0x06802009, 0x06b0a00b,
+	0x0c06ed40, 0x00000000, 0x0c0135c0, 0x00000000, 0x07803bc7,
+	0x0be34107, 0x0695000a, 0x06c0444a, 0x06804009, 0x06b0c00b,
+	0x0c06eac0, 0x00000000, 0x0c780180, 0x0694000a, 0x06c0444a,
+	0x0680c009, 0x0c06e940, 0x06b0400b, 0x078020c8, 0x0f8001c8,
+	0x0649cf0a, 0x0be5c0ca, 0x07803bca, 0x0be5420a, 0x0780200a,
+	0x0aa4c14a, 0x07801f4a, 0x0a811287, 0x0400128a, 0x06800049,
+	0x03409209, 0x04401249, 0x0280a289, 0x0a80b287, 0x0780394a,
+	0x0a62400a, 0x07803bca, 0x0be1c20a, 0x00000000, 0x0649cf09,
+	0x09081289, 0x0be0c04a, 0x00000000, 0x0c7fa840, 0x07c01f47,
+	0x07802107, 0x0a61c007, 0x068000c9, 0x0fc011c0, 0x0aa10007,
+	0x00000000, 0x0fc011c0, 0x04001247, 0x07c01f09, 0x07802007,
+	0x0a614147, 0x00000000, 0x0c070680, 0x080c2301, 0x07c01f87,
+	0x07802147, 0x0a65c007, 0x07802187, 0x0f8001c7, 0x07807388,
+	0x07c01808, 0x07c07387, 0x078074c7, 0x07c01847, 0x06800007,
+	0x07c074c7, 0x07c07507, 0x078021c7, 0x0aa2c007, 0x07801f07,
+	0x0a6240c7, 0x00000000, 0x0c070180, 0x080c2301, 0x0c070300,
+	0x00000000, 0x07c074c7, 0x058101c7, 0x07c07507, 0x0780738f,
+	0x078074d0, 0x07802147, 0x06800048, 0x0a422207, 0x07807547,
+	0x07c01807, 0x078075c7, 0x07c01847, 0x06800007, 0x07c07547,
+	0x07c07587, 0x07c075c7, 0x07c07607, 0x07803a87, 0x0aa54047,
+	0x00000000, 0x0c06fb80, 0x080c2301, 0x0c06fd00, 0x00000000,
+	0x07c07547, 0x058101c7, 0x07c07587, 0x078021c7, 0x0aa2c007,
+	0x07801f07, 0x0a6240c7, 0x00000000, 0x0c06f880, 0x080c2301,
+	0x0c06fa00, 0x00000000, 0x07c075c7, 0x058101c7, 0x07c07607,
+	0x0780754f, 0x078075d0, 0x0c079900, 0x00000000, 0x06800007,
+	0x07c02dc7, 0x0c780940, 0x00000000, 0x06800013, 0x07c02cd3,
+	0x07c02d13, 0x07c02e93, 0x07c01893, 0x07c018d3, 0x06803fc7,
+	0x07c02b07, 0x06800007, 0x07c02547, 0x07c025c7, 0x07c02607,
+	0x07802c07, 0x040011c7, 0x07c024c7, 0x06800047, 0x060e0c07,
+	0x07c026c7, 0x07c02507, 0x068003c7, 0x07c02807, 0x06805c07,
+	0x060c2107, 0x080c2170, 0x06800087, 0x07c02a47, 0x06800018,
+	0x07801ec7, 0x0a60c087, 0x06800007, 0x07c01e47, 0x068003c7,
+	0x07c02fc7, 0x0cc00000, 0x00000000, 0x07801d07, 0x0aa08007,
+	0x0c7ef600, 0x06800007, 0x07c01947, 0x06a00007, 0x060c3d07,
+	0x07802dc7, 0x0a618007, 0x00000000, 0x0c07adc0, 0x00000000,
+	0x0aa08007, 0x0c7ef340, 0x07802047, 0x07c02e07, 0x07802007,
+	0x07c02e47, 0x07801ec7, 0x07c02087, 0x07801f47, 0x07c07347,
+	0x07801f07, 0x07c02407, 0x07801f87, 0x07c01fc7, 0x0780248a,
+	0x0a6fc00a, 0x00000000, 0x0c0759c0, 0x00000000, 0x0c075ec0,
+	0x00000000, 0x07802087, 0x06840009, 0x0682605a, 0x0aa1c087,
+	0x06800008, 0x06822fda, 0x0aa10147, 0x06800048, 0x06800088,
+	0x06840009, 0x07c02788, 0x07c02689, 0x06800007, 0x07c02a87,
+	0x07802c8a, 0x07802107, 0x0a630007, 0x07802409, 0x0aa280c9,
+	0x0540128a, 0x0580128a, 0x06490707, 0x09807087, 0x098070c7,
+	0x06090707, 0x06495107, 0x098073c7, 0x06095107, 0x07c023ca,
+	0x07802947, 0x094421c9, 0x07c02947, 0x0a644387, 0x068000c9,
+	0x06495107, 0x094041c9, 0x06800009, 0x097821c9, 0x06095107,
+	0x06490707, 0x09807447, 0x06090707, 0x06498e07, 0x09807787,
+	0x06098e07, 0x07802087, 0x0aa0c087, 0x0682505a, 0x068214da,
+	0x07803bc8, 0x090821c8, 0x0aa18087, 0x06800087, 0x09482207,
+	0x0690000a, 0x0c06b200, 0x06c0000a, 0x07c03bc8, 0x0c787040,
+	0x00000000, 0x0c000fc0, 0x00000000, 0x0649d308, 0x0a63bcc8,
+	0x00000000, 0x06800047, 0x07c02dc7, 0x0c074280, 0x00000000,
+	0x07801e87, 0x069fffc8, 0x0b803207, 0x040011c7, 0x06800147,
+	0x07c01e87, 0x0c07dc40, 0x00000000, 0x07802dc7, 0x0aa18007,
+	0x00000000, 0x0c079400, 0x00000000, 0x0aa08007, 0x0c7ed980,
+	0x06800007, 0x07803bc8, 0x09082208, 0x0aa10008, 0x0684000a,
+	0x0c06a980, 0x06c0000a, 0x07c03bc7, 0x07802d87, 0x0aa34007,
+	0x07802c47, 0x0b22c2c7, 0x07802cc7, 0x0a614007, 0x06495108,
+	0x09c08608, 0x0c7800c0, 0x07c02d87, 0x09808608, 0x06095108,
+	0x08095017, 0x08095000, 0x0c786440, 0x00000000, 0x07802cc9,
+	0x07c02ac9, 0x07802889, 0x0cc00000, 0x07c03049, 0x0aa14712,
+	0x06800007, 0x07802d07, 0x050011c7, 0x048011c7, 0x0b60c709,
+	0x06808008, 0x0680c008, 0x0c790940, 0x00000000, 0x0649d508,
+	0x06035108, 0x0680fc08, 0x06035208, 0x06a00008, 0x06035008,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06435308,
+	0x0900c208, 0x0a6f8008, 0x00000000, 0x0809d301, 0x08007401,
+	0x0649d308, 0x0aa0fc48, 0x0a6fbcc8, 0x00000000, 0x0cc00000,
+	0x00000000, 0x0780254b, 0x0a60c00b, 0x044011cb, 0x06800087,
+	0x0aa14007, 0x06a01008, 0x0aa0c047, 0x06a22008, 0x06a40008,
+	0x06c00108, 0x060e0508, 0x07c02587, 0x07802a88, 0x06801809,
+	0x09502248, 0x060c2109, 0x080c260e, 0x06800049, 0x07c02849,
+	0x07802cc8, 0x07c02ac8, 0x07802888, 0x07c03048, 0x06800088,
+	0x0cc00000, 0x07c02488, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x07802787, 0x07802408,
+	0x094c21c8, 0x060c0407, 0x080c0a01, 0x07802347, 0x0a610007,
+	0x07802387, 0x0c780b00, 0x060c0a07, 0x0fc071c0, 0x080c2940,
+	0x07802387, 0x09807187, 0x098073c7, 0x060c0a07, 0x09c073c7,
+	0x09807387, 0x0c00ab00, 0x060c0a07, 0x07802788, 0x064c0a07,
+	0x091c21c7, 0x0a6f8007, 0x07802a21, 0x06c00021, 0x06800022,
+	0x06c00022, 0x06800023, 0x06c00023, 0x06800024, 0x06c00024,
+	0x06bfffe5, 0x0a628008, 0x07802947, 0x06800309, 0x0aa18387,
+	0x07c029c9, 0x06800189, 0x07c029c9, 0x0c785740, 0x060c0713,
+	0x0c784900, 0x06800309, 0x0aa18387, 0x07c029c9, 0x06800189,
+	0x07c029c9, 0x0c782540, 0x060c0713, 0x0c780bc0, 0x00000000,
+	0x0c00a280, 0x080c0600, 0x07802a21, 0x06c00021, 0x06800022,
+	0x06c00022, 0x06800023, 0x06c00023, 0x06800024, 0x06c00024,
+	0x06bfffe5, 0x07802788, 0x0a628008, 0x07802947, 0x06800309,
+	0x0aa18387, 0x07c029c9, 0x06800189, 0x07c029c9, 0x0c784f80,
+	0x060c0713, 0x0c784140, 0x06800309, 0x0aa18387, 0x07c029c9,
+	0x06800189, 0x07c029c9, 0x0c781d80, 0x060c0713, 0x0c780400,
+	0x00000000, 0x064c0321, 0x064c0322, 0x064c0323, 0x064c0324,
+	0x064c2725, 0x0a224053, 0x07802447, 0x07c02987, 0x0400099d,
+	0x040009de, 0x04000a1f, 0x04000a60, 0x0c781400, 0x060c0713,
+	0x0683ffc7, 0x044011c7, 0x0aa0c007, 0x0780248a, 0x0a6f400a,
+	0x068000ca, 0x07802747, 0x09510287, 0x07802cc7, 0x09708287,
+	0x06031e0a, 0x0aa08007, 0x0c780b00, 0x080c0700, 0x07802a08,
+	0x06c00008, 0x060c0208, 0x06800008, 0x06c00008, 0x060c0208,
+	0x06800008, 0x06c00008, 0x060c0208, 0x06800008, 0x06c00008,
+	0x060c0208, 0x06bfffc9, 0x060c0326, 0x060c0327, 0x060c0328,
+	0x060c0329, 0x07802988, 0x09610209, 0x060c2708, 0x080c0701,
+	0x07802a08, 0x06c00008, 0x060c0208, 0x06800008, 0x06c00008,
+	0x060c0208, 0x06800008, 0x06c00008, 0x060c0208, 0x06800008,
+	0x06c00008, 0x060c0208, 0x060c031d, 0x060c031e, 0x060c031f,
+	0x060c0320, 0x0780244a, 0x09610289, 0x060c270a, 0x0c780580,
+	0x060c0713, 0x064c2709, 0x09210249, 0x060c0326, 0x060c0327,
+	0x060c0328, 0x060c0329, 0x07802988, 0x09610209, 0x060c2708,
+	0x080c0701, 0x064c2709, 0x09210249, 0x060c031d, 0x060c031e,
+	0x060c031f, 0x060c0320, 0x07802448, 0x09610209, 0x060c2708,
+	0x060c0713, 0x06431e09, 0x0befc049, 0x07802307, 0x04c301c7,
+	0x0c780e40, 0x060c2507, 0x0683ffc8, 0x080c3e01, 0x064c3f07,
+	0x093e11c7, 0x0aaf4007, 0x064c2307, 0x09304247, 0x0aa0c009,
+	0x0aee4008, 0x04401208, 0x0cc00000, 0x00000000, 0x064c0321,
+	0x064c0322, 0x064c0323, 0x064c0324, 0x064c2725, 0x060c0713,
+	0x09210265, 0x07802cc7, 0x0a638007, 0x07802a08, 0x06c00008,
+	0x060c0208, 0x06800008, 0x06c00008, 0x060c0208, 0x06800008,
+	0x06c00008, 0x060c0208, 0x06800008, 0x06c00008, 0x060c0208,
+	0x06bfffc9, 0x060c031d, 0x060c031e, 0x060c031f, 0x060c0320,
+	0x07802448, 0x09610209, 0x060c2708, 0x07802307, 0x04c301c7,
+	0x060c2507, 0x0683ffc9, 0x0780248a, 0x0aa0c00a, 0x0a6f8009,
+	0x04401249, 0x068000ca, 0x07802749, 0x09510289, 0x07802cc9,
+	0x09708289, 0x06031e0a, 0x07802807, 0x07c02887, 0x064c2307,
+	0x09304207, 0x0a6f8008, 0x090a1207, 0x090241c7, 0x095211c8,
+	0x0780194b, 0x0aa0c00b, 0x07c02807, 0x0c781040, 0x0aa64247,
+	0x060c2507, 0x0aa64287, 0x0aa58347, 0x0aa1c048, 0x0aa58387,
+	0x0a60c007, 0x0c7801c0, 0x00000000, 0x080c2605, 0x080c2606,
+	0x080c2602, 0x080c260f, 0x080c2603, 0x07802a48, 0x0aa100c8,
+	0x06800089, 0x0c7829c0, 0x07c02a49, 0x0780248b, 0x0a6fc00b,
+	0x00000000, 0x07c02a88, 0x0c782840, 0x07c02a49, 0x080c2602,
+	0x080c260f, 0x080c2603, 0x07802a48, 0x0aa50088, 0x068000c9,
+	0x07802cc8, 0x0aa0c008, 0x0c7825c0, 0x07c02a49, 0x0aa08712,
+	0x0bef4053, 0x0683ffcb, 0x078026c8, 0x064e0c09, 0x09010249,
+	0x0b804248, 0x0aa0c00b, 0x0c7ffec0, 0x044012cb, 0x06800088,
+	0x068000c9, 0x0680180b, 0x060c210b, 0x0683ffcc, 0x0aa2c00c,
+	0x064e110b, 0x091012cb, 0x0a6f400b, 0x0440130c, 0x064e110b,
+	0x091012cb, 0x0a6e400b, 0x0780248b, 0x0a6dc00b, 0x00000000,
+	0x07c02a88, 0x0c781e80, 0x07c02a49, 0x06800007, 0x07c02807,
+	0x060c2507, 0x06431e07, 0x0befc047, 0x068fdfc8, 0x06fcffc8,
+	0x064e0407, 0x02807207, 0x0c7ff140, 0x060e0407, 0x064c0321,
+	0x064c0322, 0x064c2725, 0x0a228053, 0x07802447, 0x07c02987,
+	0x0400099d, 0x040009de, 0x060c0713, 0x07802307, 0x04c301c7,
+	0x0c781500, 0x060c2507, 0x07802cc7, 0x0a658007, 0x080c0700,
+	0x07802a08, 0x06c00008, 0x060c0208, 0x080c0200, 0x06bfffc9,
+	0x060c0326, 0x060c0327, 0x0780298a, 0x09610289, 0x060c270a,
+	0x080c0701, 0x060c0208, 0x080c0200, 0x060c031d, 0x060c031e,
+	0x0780244a, 0x09610289, 0x060c270a, 0x0c780480, 0x060c0713,
+	0x064c2709, 0x09210249, 0x060c0326, 0x060c0327, 0x07802988,
+	0x09610209, 0x060c2708, 0x080c0701, 0x064c2709, 0x09210249,
+	0x060c031d, 0x060c031e, 0x07802448, 0x09610209, 0x060c2708,
+	0x060c0713, 0x07802307, 0x04c301c7, 0x060c2507, 0x0780248a,
+	0x0a6fc00a, 0x068000ca, 0x07802749, 0x09510289, 0x07802cc9,
+	0x09708289, 0x0c780840, 0x06031e0a, 0x064c0321, 0x064c0322,
+	0x064c2725, 0x060c0713, 0x09210265, 0x07802cc7, 0x0a618007,
+	0x07802a08, 0x06c00008, 0x060c0208, 0x080c0200, 0x06bfffc9,
+	0x060c031d, 0x060c031e, 0x07802448, 0x09610209, 0x060c2708,
+	0x07802307, 0x04c301c7, 0x060c2507, 0x0683ffc9, 0x04401249,
+	0x0aa0c009, 0x0780248a, 0x0a6f400a, 0x068000ca, 0x07802749,
+	0x09510289, 0x07802cc9, 0x09708289, 0x06031e0a, 0x07802807,
+	0x0c07c480, 0x07c02887, 0x090241c7, 0x0b614008, 0x07c02807,
+	0x06bfffc8, 0x0c7dbe40, 0x07c03c08, 0x0aa10287, 0x060c2507,
+	0x080c2602, 0x080c260f, 0x080c2603, 0x04c001c7, 0x09807207,
+	0x060c2107, 0x07802547, 0x0aa14007, 0x06a01008, 0x0aa0c047,
+	0x06a22008, 0x06a40008, 0x06431e09, 0x0befc049, 0x06c00108,
+	0x07802949, 0x0a668389, 0x0a264053, 0x0780288a, 0x0aa1c00a,
+	0x07802a8a, 0x00800000, 0x078026c9, 0x04001249, 0x07c026c9,
+	0x00400000, 0x0b61408a, 0x00000000, 0x080c2170, 0x0c7807c0,
+	0x080c260e, 0x0683ffca, 0x0440128a, 0x0aa0c00a, 0x07802489,
+	0x0a6f4009, 0x078026c9, 0x04401249, 0x0c073140, 0x07c026c9,
+	0x0c780500, 0x08030580, 0x060e0508, 0x07802a88, 0x06801809,
+	0x09502248, 0x060c2109, 0x080c260e, 0x06800088, 0x07c02587,
+	0x0ba0c087, 0x040011c7, 0x06800007, 0x07c02547, 0x07802cc7,
+	0x07c02ac7, 0x07802887, 0x07c03047, 0x07c02488, 0x08030580,
+	0x07802747, 0x0aa14712, 0x040011c7, 0x07802d08, 0x0a20c048,
+	0x00000000, 0x07c02747, 0x0c07b140, 0x07802b0d, 0x0b608008,
+	0x0c7fed40, 0x0ba13fcd, 0x06800008, 0x0c7810c0, 0x07c02b08,
+	0x06808008, 0x0ba1070d, 0x0400024d, 0x0441c249, 0x0680c008,
+	0x05403289, 0x0200a24a, 0x02008288, 0x07400225, 0x04001208,
+	0x092102e1, 0x0740020b, 0x04001208, 0x07400221, 0x04001208,
+	0x07400222, 0x04001208, 0x092102e2, 0x0740020b, 0x04001208,
+	0x07400223, 0x04001208, 0x092102e3, 0x0740020b, 0x04001208,
+	0x07400224, 0x04001208, 0x092102e4, 0x0740020b, 0x07802c48,
+	0x0ac07488, 0x07802cca, 0x0aa38712, 0x040002ca, 0x07802d0a,
+	0x0c7802c0, 0x0942f28b, 0x0a61000a, 0x0aa14712, 0x07802d0a,
+	0x0a20c04a, 0x0a6146c9, 0x0400128d, 0x0b60c70d, 0x0680000a,
+	0x0680070a, 0x07c02b0a, 0x0b012488, 0x0aa0800a, 0x0a64070a,
+	0x07802b4a, 0x0a20c04a, 0x06a0800b, 0x06a0c00b, 0x06b80009,
+	0x07802b8c, 0x0540928c, 0x0200a24a, 0x06c0440a, 0x0200ad0a,
+	0x0603510a, 0x06803f0a, 0x0603520a, 0x0c006000, 0x0603500b,
+	0x0680001b, 0x07802947, 0x0a608387, 0x0c780480, 0x07802cc7,
+	0x040011c7, 0x07c02cc7, 0x07802e88, 0x04001208, 0x07c02e88,
+	0x07802c48, 0x0b823207, 0x06800007, 0x07c02cc7, 0x07802d08,
+	0x04001208, 0x078023c9, 0x0b81d248, 0x07c02d08, 0x0c7dd640,
+	0x0680008a, 0x07802d08, 0x0be10048, 0x040011c8, 0x0c780580,
+	0x07c02d07, 0x044011c8, 0x07c02d07, 0x07802cc7, 0x040011c7,
+	0x07c02cc7, 0x07802e88, 0x04001208, 0x07c02e88, 0x07802c48,
+	0x0b80b207, 0x06800007, 0x07c02cc7, 0x07802d08, 0x04002208,
+	0x078023c9, 0x0b805248, 0x07c02d08, 0x06800007, 0x0c7ff9c0,
+	0x07c02e87, 0x064c3b07, 0x0920c1c7, 0x0b218a07, 0x0680004a,
+	0x07c01e4a, 0x07c01d8a, 0x0680204a, 0x07c0194a, 0x07802cc7,
+	0x095084c7, 0x07802d09, 0x094084c9, 0x07801909, 0x0aa14009,
+	0x04401249, 0x0a60c009, 0x07c01909, 0x0c7edc40, 0x07802c49,
+	0x0b014489, 0x06808008, 0x0a628712, 0x0c780840, 0x00000000,
+	0x07802d0a, 0x0a20c04a, 0x0500128a, 0x040011c7, 0x054011c7,
+	0x0c780840, 0x094011ca, 0x040011c7, 0x0a410247, 0x07802b09,
+	0x07802d07, 0x0a25c047, 0x040021c9, 0x0c7efc40, 0x06800007,
+	0x0aa5c712, 0x07802d0a, 0x0a2bc04a, 0x04001287, 0x0a4ed24a,
+	0x0c780480, 0x06800007, 0x0c7ef8c0, 0x00000000, 0x0a628047,
+	0x040021c9, 0x07802d07, 0x0be1c047, 0x040021c9, 0x0c7ef840,
+	0x06800047, 0x0aadc007, 0x07802b09, 0x040011c9, 0x0ba10707,
+	0x0b6cce07, 0x0680c008, 0x0441c1c7, 0x05403247, 0x020091c9,
+	0x02008248, 0x07000209, 0x07c02449, 0x04001208, 0x07000209,
+	0x04001208, 0x0700021d, 0x09610749, 0x04001208, 0x0700021e,
+	0x04001208, 0x07000209, 0x09610789, 0x04001208, 0x0700021f,
+	0x04001208, 0x07000209, 0x096107c9, 0x04001208, 0x07000220,
+	0x04001208, 0x07000209, 0x09610809, 0x0c7d6d80, 0x00000000,
+	0x07802dc7, 0x0aa18007, 0x07802087, 0x0a614087, 0x00000000,
+	0x08098002, 0x080980f0, 0x0c780a40, 0x080c2400, 0x064c2207,
+	0x09305207, 0x093a2287, 0x09205247, 0x092a22c7, 0x054022cb,
+	0x02c0a2ca, 0x09105347, 0x091a22c7, 0x054042cb, 0x02c0a2ca,
+	0x09005387, 0x090a22c7, 0x054062cb, 0x02c0a2ca, 0x07802087,
+	0x0a63c187, 0x080c2408, 0x064c2207, 0x048032ca, 0x0aa340cb,
+	0x00000000, 0x0480f28a, 0x09305347, 0x093a22c7, 0x054042cb,
+	0x02c0a2ca, 0x09205387, 0x092a22c7, 0x054062cb, 0x02c0a2ca,
+	0x0c780240, 0x00000000, 0x0480328a, 0x09305247, 0x093a22c7,
+	0x054022cb, 0x0c7800c0, 0x02c0a2ca, 0x0c780580, 0x05418208,
+	0x0609b308, 0x0649b308, 0x05418249, 0x0609b309, 0x0649b309,
+	0x0541834d, 0x0609b30d, 0x0649b30d, 0x0541838e, 0x0609b30e,
+	0x0649b30e, 0x08098002, 0x06bfffcb, 0x054102cb, 0x06bfffcc,
+	0x02c0c2cc, 0x0609820c, 0x048032ca, 0x0a6480cb, 0x0c780080,
+	0x0c780640, 0x054102c8, 0x058102cb, 0x05410308, 0x02c0c2cc,
+	0x0609810c, 0x054042ca, 0x0609800b, 0x0a811248, 0x00000000,
+	0x054102c9, 0x058102cb, 0x05410309, 0x02c0c2cc, 0x0c7802c0,
+	0x0609820c, 0x054102c8, 0x058102cb, 0x05410309, 0x02c0c2cc,
+	0x0609810c, 0x054042ca, 0x04c042cb, 0x0c7800c0, 0x0609800b,
+	0x0c780340, 0x048032ca, 0x054182cb, 0x02c0b20b, 0x0483030a,
+	0x0541430c, 0x02c0c34c, 0x0a80630b, 0x054102cd, 0x058102cb,
+	0x0541030e, 0x02c0c2cc, 0x0609820c, 0x0780294b, 0x0a60c38b,
+	0x06800712, 0x05801492, 0x06bfffcb, 0x06800021, 0x07802a1d,
+	0x0680001e, 0x06800022, 0x0680001f, 0x06800023, 0x06800020,
+	0x06800024, 0x0400099d, 0x040009de, 0x04000a1f, 0x04000a60,
+	0x0680800a, 0x0680070e, 0x0740028b, 0x0400128a, 0x074002a1,
+	0x0400128a, 0x0740029d, 0x0400128a, 0x0740029e, 0x0400128a,
+	0x074002a2, 0x0400128a, 0x0740029f, 0x0400128a, 0x074002a3,
+	0x0400128a, 0x074002a0, 0x0400128a, 0x074002a4, 0x0d07fbce,
+	0x0400128a, 0x07c0244b, 0x07c0298b, 0x096102cb, 0x080c0700,
+	0x060c270b, 0x09610761, 0x060c021d, 0x096107a2, 0x0780278e,
+	0x0aa1800e, 0x060c021e, 0x096107e3, 0x060c021f, 0x09610824,
+	0x060c0220, 0x080c0701, 0x060c270b, 0x060c021d, 0x0aa1000e,
+	0x060c021e, 0x060c021f, 0x060c0220, 0x07802c4e, 0x0b00948e,
+	0x06b80007, 0x06c04407, 0x02007d07, 0x06035107, 0x06803f07,
+	0x06035207, 0x06a08007, 0x06035007, 0x07802cc7, 0x0aa24007,
+	0x06803fc7, 0x07802947, 0x0aa1c387, 0x07802cc7, 0x044011c7,
+	0x0ba0c707, 0x0c7fffc0, 0x0441c1c7, 0x07c02b07, 0x06800007,
+	0x07c02747, 0x0ac0b48e, 0x07802b07, 0x0b613fc7, 0x0ba0c707,
+	0x0441c1c7, 0x07c02b07, 0x06435007, 0x0580f1c7, 0x0bef8047,
+	0x0cc00000, 0x00000000, 0x06435007, 0x0580f1c7, 0x0bef8047,
+	0x00000000, 0x06435307, 0x0900c1c7, 0x0a6f8007, 0x06b80007,
+	0x06c04407, 0x02007d07, 0x06035107, 0x06803f07, 0x06035207,
+	0x06b0c007, 0x06035007, 0x054011d2, 0x0ac051ce, 0x06800087,
+	0x07c02b47, 0x0c7ff8c0, 0x07c02b87, 0x06b90008, 0x06c04408,
+	0x02008d08, 0x05401252, 0x02009489, 0x0680008a, 0x07c02b4a,
+	0x068000ca, 0x06435007, 0x0580f1c7, 0x0bef8047, 0x06803f07,
+	0x06035108, 0x06035207, 0x06a08007, 0x06035007, 0x0ac0324e,
+	0x0c7ff400, 0x07c02b8a, 0x06808007, 0x020081c8, 0x02009489,
+	0x0c7ffc80, 0x0400128a, 0x0400130c, 0x0480f30c, 0x07c02b8c,
+	0x0980b38b, 0x07802b4c, 0x0540928c, 0x0200a24a, 0x06c0440a,
+	0x0200ad0a, 0x0400130c, 0x0480f30c, 0x07c02b4c, 0x0643500c,
+	0x0580f30c, 0x0bef804c, 0x00000000, 0x0643530c, 0x0900c30c,
+	0x0a6f800c, 0x00000000, 0x0603510a, 0x06803f0a, 0x0603520a,
+	0x0c7fedc0, 0x0603500b, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x06bff7c0, 0x06032400,
+	0x00400000, 0x0c780000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0cc00000,
+	0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000,
+	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0c780080,
+	0x06431e07, 0x09027207, 0x0a668048, 0x068fdfca, 0x06fcffca,
+	0x064e0408, 0x02808288, 0x09110287, 0x064c0909, 0x0ac0924a,
+	0x0b80324a, 0x0c7801c0, 0x09808688, 0x0400128a, 0x098083c8,
+	0x0a40324a, 0x0440128a, 0x098086c8, 0x0aa1000a, 0x09308287,
+	0x0a60c00a, 0x0400128a, 0x09808388, 0x0b80324a, 0x00000000,
+	0x098081c8, 0x0c780240, 0x060e0408, 0x0a614248, 0x00000000,
+	0x0c008f80, 0x00000000, 0x0c7800c0, 0x0c780080, 0x00000000,
+	0x08031e00, 0x0cc00000, 0x00400000, 0x0680400f, 0x0680a00e,
+	0x0680ec0d, 0x0680f60c, 0x0780704b, 0x0680000a, 0x06800009,
+	0x06800008, 0x0780776f, 0x07807780, 0x09610bc0, 0x0780736e,
+	0x078020c0, 0x06800041, 0x0342d001, 0x07807300, 0x06800081,
+	0x0b831040, 0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44,
+	0x06800c00, 0x0bc25004, 0x09042004, 0x068000c1, 0x0a422040,
+	0x09101004, 0x04001c31, 0x02030030, 0x02030030, 0x07000c2c,
+	0x04001c30, 0x07000c00, 0x09610b00, 0x04005c71, 0x07000c6b,
+	0x0b003bab, 0x00000000, 0x0242bb6b, 0x0202a209, 0x05402c2a,
+	0x02030c0e, 0x07400c0a, 0x068000c0, 0x04001c30, 0x07400c00,
+	0x04001c30, 0x07400c2b, 0x0581002b, 0x04001c30, 0x07400c00,
+	0x0ac05bec, 0x0203024d, 0x07400c2a, 0x04001249, 0x0c780100,
+	0x0203020c, 0x07400c2a, 0x04001208, 0x0400128a, 0x0b8d52ca,
+	0x02000209, 0x07c070c9, 0x0cc00000, 0x07c07100, 0x0aa14040,
+	0x06800047, 0x06800006, 0x0c780100, 0x00000000, 0x06800007,
+	0x06800046, 0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44,
+	0x09101004, 0x04001c31, 0x02030030, 0x02030030, 0x07000c2c,
+	0x04001c30, 0x07000c00, 0x09610b00, 0x04005c71, 0x07000c6b,
+	0x0b003bab, 0x00000000, 0x0242bb6b, 0x0be60404, 0x0a25c104,
+	0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a, 0x06800040,
+	0x04001c30, 0x07400c00, 0x0540102b, 0x020001c0, 0x04001c30,
+	0x07400c00, 0x05810000, 0x04001c30, 0x07400c00, 0x0ac05bec,
+	0x0203024d, 0x07400c2a, 0x04001249, 0x0c780100, 0x0203020c,
+	0x07400c2a, 0x04001208, 0x0be60804, 0x0a25c204, 0x0202a209,
+	0x05402c2a, 0x02030c0e, 0x07400c0a, 0x06800080, 0x04001c30,
+	0x07400c00, 0x0540102b, 0x02000180, 0x04001c30, 0x07400c00,
+	0x05810000, 0x04001c30, 0x07400c00, 0x0ac05bec, 0x0203024d,
+	0x07400c2a, 0x04001249, 0x0c780100, 0x0203020c, 0x07400c2a,
+	0x04001208, 0x0400128a, 0x0b8be2ca, 0x02000209, 0x07c070c9,
+	0x0cc00000, 0x07c07100, 0x0680400f, 0x0680a00e, 0x0680ec0d,
+	0x0780704b, 0x0680000a, 0x07807109, 0x07807300, 0x0ba6c080,
+	0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44, 0x09082004,
+	0x0a6440c0, 0x04006c71, 0x07000c6b, 0x05402c09, 0x02030c0e,
+	0x07400c0a, 0x068001c0, 0x04001c30, 0x07400c00, 0x04001c30,
+	0x07400c2b, 0x0581002b, 0x04001c30, 0x07400c00, 0x0203024d,
+	0x07400c09, 0x04001249, 0x0400128a, 0x0b8e92ca, 0x0cc00000,
+	0x07c07149, 0x0aa14040, 0x06800047, 0x06800006, 0x0c780100,
+	0x00000000, 0x06800007, 0x06800046, 0x05403c4a, 0x02031c4f,
+	0x04001c71, 0x07000c44, 0x04006c71, 0x07000c6b, 0x0a244404,
+	0x05402c09, 0x02030c0e, 0x07400c0a, 0x06800140, 0x04001c30,
+	0x07400c00, 0x0540102b, 0x020001c0, 0x04001c30, 0x07400c00,
+	0x05810000, 0x04001c30, 0x07400c00, 0x0203024d, 0x07400c09,
+	0x04001249, 0x0a244804, 0x05402c09, 0x02030c0e, 0x07400c0a,
+	0x06800180, 0x04001c30, 0x07400c00, 0x0540102b, 0x02000180,
+	0x04001c30, 0x07400c00, 0x05810000, 0x04001c30, 0x07400c00,
+	0x0203024d, 0x07400c09, 0x04001249, 0x0400128a, 0x0b8d72ca,
+	0x0cc00000, 0x07c07149, 0x0680ec0f, 0x0680f60e, 0x0780710a,
+	0x078070c9, 0x06800008, 0x0240a24a, 0x0200e28e, 0x0a60c009,
+	0x0cc00000, 0x00000000, 0x070003c0, 0x07400380, 0x040013cf,
+	0x0400138e, 0x04001208, 0x0b8fb248, 0x0cc00000, 0x00000000,
+	0x0680ec0f, 0x0680f60e, 0x0780710a, 0x078070c9, 0x06800008,
+	0x0240a24a, 0x0200f24f, 0x0a60c00a, 0x0cc00000, 0x00000000,
+	0x07000380, 0x074003c0, 0x040013cf, 0x0400138e, 0x04001208,
+	0x0b8fb288, 0x0cc00000, 0x00000000, 0x0680ec0f, 0x0680f60e,
+	0x0780710a, 0x07807149, 0x0200f28f, 0x0200e28e, 0x0a40324a,
+	0x0cc00000, 0x00000000, 0x070003c0, 0x07400380, 0x040013cf,
+	0x0400138e, 0x0400128a, 0x0b8fb24a, 0x0cc00000, 0x00000000,
+	0x0b60808e, 0x0c780e00, 0x0680a00c, 0x0680400b, 0x0680000a,
+	0x0a83438a, 0x0400124a, 0x0202f28f, 0x07000bee, 0x0540222e,
+	0x0200820c, 0x04002208, 0x0700022d, 0x04001208, 0x07000200,
+	0x09610b40, 0x0a814389, 0x0202c24f, 0x07000b2b, 0x0540222b,
+	0x0200820c, 0x04002208, 0x0700022a, 0x04001208, 0x07000200,
+	0x09610a80, 0x0a60c00d, 0x0b807aad, 0x0c7800c0, 0x0ac05aad,
+	0x00000000, 0x07400b2e, 0x04000bab, 0x04000b6a, 0x04001249,
+	0x0c7ffb40, 0x07807300, 0x0b644080, 0x0a24004a, 0x0540222e,
+	0x0200820c, 0x04002208, 0x07000207, 0x0a22c047, 0x04401b6f,
+	0x07000b6c, 0x0540222c, 0x0200820c, 0x04002208, 0x07000207,
+	0x0be10047, 0x00000000, 0x07400b6e, 0x04000bac, 0x07400bee,
+	0x0400128a, 0x0c7ff340, 0x0cc00000, 0x00000000, 0x0b60808e,
+	0x0c781680, 0x0680a00c, 0x0680400b, 0x0680000a, 0x0a85638a,
+	0x0400124a, 0x0202f28f, 0x07000bee, 0x0540222e, 0x0200820c,
+	0x07000207, 0x04001208, 0x07000206, 0x054031c7, 0x020071cb,
+	0x09002146, 0x0a6280c5, 0x00000000, 0x040011c7, 0x070001c4,
+	0x09101c44, 0x040011c7, 0x02007c47, 0x02007c47, 0x0c780100,
+	0x00000000, 0x02007147, 0x02007147, 0x070001ed, 0x040011c7,
+	0x070001c0, 0x09610b40, 0x0a825389, 0x0202c24f, 0x07000b2b,
+	0x0540222b, 0x0200820c, 0x07000207, 0x04001208, 0x07000206,
+	0x054031c7, 0x020071cb, 0x09002146, 0x0a6280c5, 0x00000000,
+	0x040011c7, 0x070001c4, 0x09101c44, 0x040011c7, 0x02007c47,
+	0x02007c47, 0x0c780100, 0x00000000, 0x02007147, 0x02007147,
+	0x070001ea, 0x040011c7, 0x070001c0, 0x09610a80, 0x0a60c00d,
+	0x0b807aad, 0x0c7800c0, 0x0ac05aad, 0x00000000, 0x07400b2e,
+	0x04000bab, 0x04000b6a, 0x04001249, 0x0c7ff700, 0x07807300,
+	0x0b644080, 0x0a24004a, 0x0540222e, 0x0200820c, 0x04002208,
+	0x07000207, 0x0a22c047, 0x04401b6f, 0x07000b6c, 0x0540222c,
+	0x0200820c, 0x04002208, 0x07000207, 0x0be10047, 0x00000000,
+	0x07400b6e, 0x04000bac, 0x07400bee, 0x0400128a, 0x0c7feac0,
+	0x0cc00000, 0x00000000, 0x0400120a, 0x0200720f, 0x070001c9,
+	0x05402189, 0x0200618c, 0x04002186, 0x07000185, 0x09001005,
+	0x0a4092c0, 0x04401c47, 0x07000c40, 0x074001c0, 0x04401208,
+	0x0acfc288, 0x040001f1, 0x0cc00000, 0x074001c9, 0x04001208,
+	0x0b8ef388, 0x0cc00000, 0x00000000, 0x0780710e, 0x0440134e,
+	0x0680a00c, 0x0680000a, 0x0b60808e, 0x0c7804c0, 0x0200928f,
+	0x07000248, 0x054021c8, 0x020071cc, 0x040021c7, 0x070001c6,
+	0x0be1804a, 0x0be24046, 0x00000000, 0x0c07f700, 0x0680004b,
+	0x0c780140, 0x0a210046, 0x00000000, 0x0c07f5c0, 0x0680000b,
+	0x0400128a, 0x0b8ef34a, 0x0cc00000, 0x00000000, 0x06800008,
+	0x0700040a, 0x0200720f, 0x070001c9, 0x05402189, 0x020061af,
+	0x04001186, 0x07000185, 0x09041005, 0x0a418a80, 0x04001186,
+	0x07000185, 0x04001186, 0x07000180, 0x09610140, 0x0a412305,
+	0x0a80e348, 0x0ac07348, 0x00000000, 0x0200734f, 0x0a80a34a,
+	0x0400128a, 0x0440120a, 0x0200720f, 0x04401c47, 0x07000c40,
+	0x074001c0, 0x04401208, 0x0acfc348, 0x040001f1, 0x074001c9,
+	0x0cc00000, 0x0740040a, 0x04001208, 0x0b8e0288, 0x0cc00000,
+	0x00000000, 0x0680a02f, 0x078020c0, 0x06800041, 0x0342e001,
+	0x0780736d, 0x07807300, 0x0b614080, 0x00000000, 0x05401bae,
+	0x05401b6d, 0x04001b6d, 0x0242cbad, 0x04000aed, 0x0680000d,
+	0x0680002a, 0x07000380, 0x0400138e, 0x0aa10000, 0x0aa30040,
+	0x0aa50080, 0x0c780680, 0x07000380, 0x0400138e, 0x04001000,
+	0x0242b02b, 0x0b411b2b, 0x0400032b, 0x0202bbab, 0x0c780380,
+	0x0400032b, 0x07000380, 0x0400138e, 0x04001000, 0x0202b02b,
+	0x0b808b6b, 0x0400032b, 0x0242bbab, 0x0c780140, 0x0400032b,
+	0x0680006a, 0x0700038c, 0x0400138e, 0x0c07ec40, 0x00000000,
+	0x0c7ff880, 0x0400134d, 0x0cc00000, 0x00000000, 0x0c077280,
+	0x00000000, 0x0c079600, 0x00000000, 0x07802080, 0x0aa64180,
+	0x00000000, 0x0c07ae80, 0x00000000, 0x07807140, 0x07c07240,
+	0x0680ec0f, 0x0780710e, 0x0680004d, 0x0c07b580, 0x00000000,
+	0x0680ec0f, 0x0780714e, 0x07807100, 0x0200f00f, 0x0240e00e,
+	0x0680000d, 0x0c07b380, 0x00000000, 0x0680ec0f, 0x0680c00e,
+	0x0c07ed80, 0x06807250, 0x0cc00000, 0x00000000, 0x0680ec0f,
+	0x078070ce, 0x0680004d, 0x0c07bf80, 0x00000000, 0x0680f60f,
+	0x0780710e, 0x078070c0, 0x0240e00e, 0x0680000d, 0x0c07bdc0,
+	0x00000000, 0x0680ec0f, 0x0780714e, 0x07807100, 0x0200f00f,
+	0x0240e00e, 0x0680000d, 0x0c07ad00, 0x00000000, 0x0c07a3c0,
+	0x00000000, 0x0c079ec0, 0x00000000, 0x0c07a740, 0x00000000,
+	0x07807140, 0x07c07240, 0x07c07280, 0x07807300, 0x0b618080,
+	0x00000000, 0x0c07d4c0, 0x0680ec0f, 0x0c07d440, 0x0680f60f,
+	0x078070c0, 0x07807101, 0x07807170, 0x0ba280b0, 0x0aa0c000,
+	0x0a802040, 0x0c7801c0, 0x0680f60f, 0x0400138f, 0x070003c0,
+	0x07000381, 0x07400380, 0x074003c1, 0x0680ec0f, 0x0680c00e,
+	0x0c07dfc0, 0x06807250, 0x0680f60f, 0x0680d08e, 0x0c07dec0,
+	0x06807290, 0x0cc00000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264/mh264data_linux.h b/drivers/amlogic/amports/arch/ucode/h264/mh264data_linux.h
new file mode 100644
index 0000000..406ba3e
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264/mh264data_linux.h
@@ -0,0 +1,207 @@
+static const u32 MicroCode[] __initconst = {
+	0x07802787, 0x07802408, 0x094c21c8, 0x060c0407, 0x080c0a01,
+	0x07802347, 0x0a610007, 0x07802387, 0x0c780b00, 0x060c0a07,
+	0x0fc071c0, 0x080c2940, 0x07802387, 0x09807187, 0x098073c7,
+	0x060c0a07, 0x09c073c7, 0x09807387, 0x0c00ab00, 0x060c0a07,
+	0x07802788, 0x064c0a07, 0x091c21c7, 0x0a6f8007, 0x07802a21,
+	0x06c00021, 0x06800022, 0x06c00022, 0x06800023, 0x06c00023,
+	0x06800024, 0x06c00024, 0x06bfffe5, 0x0a628008, 0x07802947,
+	0x06800309, 0x0aa18387, 0x07c029c9, 0x06800189, 0x07c029c9,
+	0x0c785740, 0x060c0713, 0x0c784900, 0x06800309, 0x0aa18387,
+	0x07c029c9, 0x06800189, 0x07c029c9, 0x0c782540, 0x060c0713,
+	0x0c780bc0, 0x00000000, 0x0c00a280, 0x080c0600, 0x07802a21,
+	0x06c00021, 0x06800022, 0x06c00022, 0x06800023, 0x06c00023,
+	0x06800024, 0x06c00024, 0x06bfffe5, 0x07802788, 0x0a628008,
+	0x07802947, 0x06800309, 0x0aa18387, 0x07c029c9, 0x06800189,
+	0x07c029c9, 0x0c784f80, 0x060c0713, 0x0c784140, 0x06800309,
+	0x0aa18387, 0x07c029c9, 0x06800189, 0x07c029c9, 0x0c781d80,
+	0x060c0713, 0x0c780400, 0x00000000, 0x064c0321, 0x064c0322,
+	0x064c0323, 0x064c0324, 0x064c2725, 0x0a224053, 0x07802447,
+	0x07c02987, 0x0400099d, 0x040009de, 0x04000a1f, 0x04000a60,
+	0x0c781400, 0x060c0713, 0x0683ffc7, 0x044011c7, 0x0aa0c007,
+	0x0780248a, 0x0a6f400a, 0x068000ca, 0x07802747, 0x09510287,
+	0x07802cc7, 0x09708287, 0x06031e0a, 0x0aa08007, 0x0c780b00,
+	0x080c0700, 0x07802a08, 0x06c00008, 0x060c0208, 0x06800008,
+	0x06c00008, 0x060c0208, 0x06800008, 0x06c00008, 0x060c0208,
+	0x06800008, 0x06c00008, 0x060c0208, 0x06bfffc9, 0x060c0326,
+	0x060c0327, 0x060c0328, 0x060c0329, 0x07802988, 0x09610209,
+	0x060c2708, 0x080c0701, 0x07802a08, 0x06c00008, 0x060c0208,
+	0x06800008, 0x06c00008, 0x060c0208, 0x06800008, 0x06c00008,
+	0x060c0208, 0x06800008, 0x06c00008, 0x060c0208, 0x060c031d,
+	0x060c031e, 0x060c031f, 0x060c0320, 0x0780244a, 0x09610289,
+	0x060c270a, 0x0c780580, 0x060c0713, 0x064c2709, 0x09210249,
+	0x060c0326, 0x060c0327, 0x060c0328, 0x060c0329, 0x07802988,
+	0x09610209, 0x060c2708, 0x080c0701, 0x064c2709, 0x09210249,
+	0x060c031d, 0x060c031e, 0x060c031f, 0x060c0320, 0x07802448,
+	0x09610209, 0x060c2708, 0x060c0713, 0x06431e09, 0x0befc049,
+	0x07802307, 0x04c301c7, 0x0c780e40, 0x060c2507, 0x0683ffc8,
+	0x080c3e01, 0x064c3f07, 0x093e11c7, 0x0aaf4007, 0x064c2307,
+	0x09304247, 0x0aa0c009, 0x0aee4008, 0x04401208, 0x0cc00000,
+	0x00000000, 0x064c0321, 0x064c0322, 0x064c0323, 0x064c0324,
+	0x064c2725, 0x060c0713, 0x09210265, 0x07802cc7, 0x0a638007,
+	0x07802a08, 0x06c00008, 0x060c0208, 0x06800008, 0x06c00008,
+	0x060c0208, 0x06800008, 0x06c00008, 0x060c0208, 0x06800008,
+	0x06c00008, 0x060c0208, 0x06bfffc9, 0x060c031d, 0x060c031e,
+	0x060c031f, 0x060c0320, 0x07802448, 0x09610209, 0x060c2708,
+	0x07802307, 0x04c301c7, 0x060c2507, 0x0683ffc9, 0x0780248a,
+	0x0aa0c00a, 0x0a6f8009, 0x04401249, 0x068000ca, 0x07802749,
+	0x09510289, 0x07802cc9, 0x09708289, 0x06031e0a, 0x07802807,
+	0x07c02887, 0x064c2307, 0x09304207, 0x0a6f8008, 0x090a1207,
+	0x090241c7, 0x095211c8, 0x0780194b, 0x0aa0c00b, 0x07c02807,
+	0x0c781040, 0x0aa64247, 0x060c2507, 0x0aa64287, 0x0aa58347,
+	0x0aa1c048, 0x0aa58387, 0x0a60c007, 0x0c7801c0, 0x00000000,
+	0x080c2605, 0x080c2606, 0x080c2602, 0x080c260f, 0x080c2603,
+	0x07802a48, 0x0aa100c8, 0x06800089, 0x0c7829c0, 0x07c02a49,
+	0x0780248b, 0x0a6fc00b, 0x00000000, 0x07c02a88, 0x0c782840,
+	0x07c02a49, 0x080c2602, 0x080c260f, 0x080c2603, 0x07802a48,
+	0x0aa50088, 0x068000c9, 0x07802cc8, 0x0aa0c008, 0x0c7825c0,
+	0x07c02a49, 0x0aa08712, 0x0bef4053, 0x0683ffcb, 0x078026c8,
+	0x064e0c09, 0x09010249, 0x0b804248, 0x0aa0c00b, 0x0c7ffec0,
+	0x044012cb, 0x06800088, 0x068000c9, 0x0680180b, 0x060c210b,
+	0x0683ffcc, 0x0aa2c00c, 0x064e110b, 0x091012cb, 0x0a6f400b,
+	0x0440130c, 0x064e110b, 0x091012cb, 0x0a6e400b, 0x0780248b,
+	0x0a6dc00b, 0x00000000, 0x07c02a88, 0x0c781e80, 0x07c02a49,
+	0x06800007, 0x07c02807, 0x060c2507, 0x06431e07, 0x0befc047,
+	0x068fdfc8, 0x06fcffc8, 0x064e0407, 0x02807207, 0x0c7ff140,
+	0x060e0407, 0x064c0321, 0x064c0322, 0x064c2725, 0x0a228053,
+	0x07802447, 0x07c02987, 0x0400099d, 0x040009de, 0x060c0713,
+	0x07802307, 0x04c301c7, 0x0c781500, 0x060c2507, 0x07802cc7,
+	0x0a658007, 0x080c0700, 0x07802a08, 0x06c00008, 0x060c0208,
+	0x080c0200, 0x06bfffc9, 0x060c0326, 0x060c0327, 0x0780298a,
+	0x09610289, 0x060c270a, 0x080c0701, 0x060c0208, 0x080c0200,
+	0x060c031d, 0x060c031e, 0x0780244a, 0x09610289, 0x060c270a,
+	0x0c780480, 0x060c0713, 0x064c2709, 0x09210249, 0x060c0326,
+	0x060c0327, 0x07802988, 0x09610209, 0x060c2708, 0x080c0701,
+	0x064c2709, 0x09210249, 0x060c031d, 0x060c031e, 0x07802448,
+	0x09610209, 0x060c2708, 0x060c0713, 0x07802307, 0x04c301c7,
+	0x060c2507, 0x0780248a, 0x0a6fc00a, 0x068000ca, 0x07802749,
+	0x09510289, 0x07802cc9, 0x09708289, 0x0c780840, 0x06031e0a,
+	0x064c0321, 0x064c0322, 0x064c2725, 0x060c0713, 0x09210265,
+	0x07802cc7, 0x0a618007, 0x07802a08, 0x06c00008, 0x060c0208,
+	0x080c0200, 0x06bfffc9, 0x060c031d, 0x060c031e, 0x07802448,
+	0x09610209, 0x060c2708, 0x07802307, 0x04c301c7, 0x060c2507,
+	0x0683ffc9, 0x04401249, 0x0aa0c009, 0x0780248a, 0x0a6f400a,
+	0x068000ca, 0x07802749, 0x09510289, 0x07802cc9, 0x09708289,
+	0x06031e0a, 0x07802807, 0x0c07c480, 0x07c02887, 0x090241c7,
+	0x0b614008, 0x07c02807, 0x06bfffc8, 0x0c7dbe40, 0x07c03c08,
+	0x0aa10287, 0x060c2507, 0x080c2602, 0x080c260f, 0x080c2603,
+	0x04c001c7, 0x09807207, 0x060c2107, 0x07802547, 0x0aa14007,
+	0x06a01008, 0x0aa0c047, 0x06a22008, 0x06a40008, 0x06431e09,
+	0x0befc049, 0x06c00108, 0x07802949, 0x0a668389, 0x0a264053,
+	0x0780288a, 0x0aa1c00a, 0x07802a8a, 0x00800000, 0x078026c9,
+	0x04001249, 0x07c026c9, 0x00400000, 0x0b61408a, 0x00000000,
+	0x080c2170, 0x0c7807c0, 0x080c260e, 0x0683ffca, 0x0440128a,
+	0x0aa0c00a, 0x07802489, 0x0a6f4009, 0x078026c9, 0x04401249,
+	0x0c073140, 0x07c026c9, 0x0c780500, 0x08030580, 0x060e0508,
+	0x07802a88, 0x06801809, 0x09502248, 0x060c2109, 0x080c260e,
+	0x06800088, 0x07c02587, 0x0ba0c087, 0x040011c7, 0x06800007,
+	0x07c02547, 0x07802cc7, 0x07c02ac7, 0x07802887, 0x07c03047,
+	0x07c02488, 0x08030580, 0x07802747, 0x0aa14712, 0x040011c7,
+	0x07802d08, 0x0a20c048, 0x00000000, 0x07c02747, 0x0c07b140,
+	0x07802b0d, 0x0b608008, 0x0c7fed40, 0x0ba13fcd, 0x06800008,
+	0x0c7810c0, 0x07c02b08, 0x06808008, 0x0ba1070d, 0x0400024d,
+	0x0441c249, 0x0680c008, 0x05403289, 0x0200a24a, 0x02008288,
+	0x07400225, 0x04001208, 0x092102e1, 0x0740020b, 0x04001208,
+	0x07400221, 0x04001208, 0x07400222, 0x04001208, 0x092102e2,
+	0x0740020b, 0x04001208, 0x07400223, 0x04001208, 0x092102e3,
+	0x0740020b, 0x04001208, 0x07400224, 0x04001208, 0x092102e4,
+	0x0740020b, 0x07802c48, 0x0ac07488, 0x07802cca, 0x0aa38712,
+	0x040002ca, 0x07802d0a, 0x0c7802c0, 0x0942f28b, 0x0a61000a,
+	0x0aa14712, 0x07802d0a, 0x0a20c04a, 0x0a6146c9, 0x0400128d,
+	0x0b60c70d, 0x0680000a, 0x0680070a, 0x07c02b0a, 0x0b012488,
+	0x0aa0800a, 0x0a64070a, 0x07802b4a, 0x0a20c04a, 0x06a0800b,
+	0x06a0c00b, 0x06b80009, 0x07802b8c, 0x0540928c, 0x0200a24a,
+	0x06c0440a, 0x0200ad0a, 0x0603510a, 0x06803f0a, 0x0603520a,
+	0x0c006000, 0x0603500b, 0x0680001b, 0x07802947, 0x0a608387,
+	0x0c780480, 0x07802cc7, 0x040011c7, 0x07c02cc7, 0x07802e88,
+	0x04001208, 0x07c02e88, 0x07802c48, 0x0b823207, 0x06800007,
+	0x07c02cc7, 0x07802d08, 0x04001208, 0x078023c9, 0x0b81d248,
+	0x07c02d08, 0x0c7dd640, 0x0680008a, 0x07802d08, 0x0be10048,
+	0x040011c8, 0x0c780580, 0x07c02d07, 0x044011c8, 0x07c02d07,
+	0x07802cc7, 0x040011c7, 0x07c02cc7, 0x07802e88, 0x04001208,
+	0x07c02e88, 0x07802c48, 0x0b80b207, 0x06800007, 0x07c02cc7,
+	0x07802d08, 0x04002208, 0x078023c9, 0x0b805248, 0x07c02d08,
+	0x06800007, 0x0c7ff9c0, 0x07c02e87, 0x064c3b07, 0x0920c1c7,
+	0x0b218a07, 0x0680004a, 0x07c01e4a, 0x07c01d8a, 0x0680204a,
+	0x07c0194a, 0x07802cc7, 0x095084c7, 0x07802d09, 0x094084c9,
+	0x07801909, 0x0aa14009, 0x04401249, 0x0a60c009, 0x07c01909,
+	0x0c7edc40, 0x07802c49, 0x0b014489, 0x06808008, 0x0a628712,
+	0x0c780840, 0x00000000, 0x07802d0a, 0x0a20c04a, 0x0500128a,
+	0x040011c7, 0x054011c7, 0x0c780840, 0x094011ca, 0x040011c7,
+	0x0a410247, 0x07802b09, 0x07802d07, 0x0a25c047, 0x040021c9,
+	0x0c7efc40, 0x06800007, 0x0aa5c712, 0x07802d0a, 0x0a2bc04a,
+	0x04001287, 0x0a4ed24a, 0x0c780480, 0x06800007, 0x0c7ef8c0,
+	0x00000000, 0x0a628047, 0x040021c9, 0x07802d07, 0x0be1c047,
+	0x040021c9, 0x0c7ef840, 0x06800047, 0x0aadc007, 0x07802b09,
+	0x040011c9, 0x0ba10707, 0x0b6cce07, 0x0680c008, 0x0441c1c7,
+	0x05403247, 0x020091c9, 0x02008248, 0x07000209, 0x07c02449,
+	0x04001208, 0x07000209, 0x04001208, 0x0700021d, 0x09610749,
+	0x04001208, 0x0700021e, 0x04001208, 0x07000209, 0x09610789,
+	0x04001208, 0x0700021f, 0x04001208, 0x07000209, 0x096107c9,
+	0x04001208, 0x07000220, 0x04001208, 0x07000209, 0x09610809,
+	0x0c7d6d80, 0x00000000, 0x07802dc7, 0x0aa18007, 0x07802087,
+	0x0a614087, 0x00000000, 0x08098002, 0x080980f0, 0x0c780a40,
+	0x080c2400, 0x064c2207, 0x09305207, 0x093a2287, 0x09205247,
+	0x092a22c7, 0x054022cb, 0x02c0a2ca, 0x09105347, 0x091a22c7,
+	0x054042cb, 0x02c0a2ca, 0x09005387, 0x090a22c7, 0x054062cb,
+	0x02c0a2ca, 0x07802087, 0x0a63c187, 0x080c2408, 0x064c2207,
+	0x048032ca, 0x0aa340cb, 0x00000000, 0x0480f28a, 0x09305347,
+	0x093a22c7, 0x054042cb, 0x02c0a2ca, 0x09205387, 0x092a22c7,
+	0x054062cb, 0x02c0a2ca, 0x0c780240, 0x00000000, 0x0480328a,
+	0x09305247, 0x093a22c7, 0x054022cb, 0x0c7800c0, 0x02c0a2ca,
+	0x0c780580, 0x05418208, 0x0609b308, 0x0649b308, 0x05418249,
+	0x0609b309, 0x0649b309, 0x0541834d, 0x0609b30d, 0x0649b30d,
+	0x0541838e, 0x0609b30e, 0x0649b30e, 0x08098002, 0x06bfffcb,
+	0x054102cb, 0x06bfffcc, 0x02c0c2cc, 0x0609820c, 0x048032ca,
+	0x0a6480cb, 0x0c780080, 0x0c780640, 0x054102c8, 0x058102cb,
+	0x05410308, 0x02c0c2cc, 0x0609810c, 0x054042ca, 0x0609800b,
+	0x0a811248, 0x00000000, 0x054102c9, 0x058102cb, 0x05410309,
+	0x02c0c2cc, 0x0c7802c0, 0x0609820c, 0x054102c8, 0x058102cb,
+	0x05410309, 0x02c0c2cc, 0x0609810c, 0x054042ca, 0x04c042cb,
+	0x0c7800c0, 0x0609800b, 0x0c780340, 0x048032ca, 0x054182cb,
+	0x02c0b20b, 0x0483030a, 0x0541430c, 0x02c0c34c, 0x0a80630b,
+	0x054102cd, 0x058102cb, 0x0541030e, 0x02c0c2cc, 0x0609820c,
+	0x0780294b, 0x0a60c38b, 0x06800712, 0x05801492, 0x06bfffcb,
+	0x06800021, 0x07802a1d, 0x0680001e, 0x06800022, 0x0680001f,
+	0x06800023, 0x06800020, 0x06800024, 0x0400099d, 0x040009de,
+	0x04000a1f, 0x04000a60, 0x0680800a, 0x0680070e, 0x0740028b,
+	0x0400128a, 0x074002a1, 0x0400128a, 0x0740029d, 0x0400128a,
+	0x0740029e, 0x0400128a, 0x074002a2, 0x0400128a, 0x0740029f,
+	0x0400128a, 0x074002a3, 0x0400128a, 0x074002a0, 0x0400128a,
+	0x074002a4, 0x0d07fbce, 0x0400128a, 0x07c0244b, 0x07c0298b,
+	0x096102cb, 0x080c0700, 0x060c270b, 0x09610761, 0x060c021d,
+	0x096107a2, 0x0780278e, 0x0aa1800e, 0x060c021e, 0x096107e3,
+	0x060c021f, 0x09610824, 0x060c0220, 0x080c0701, 0x060c270b,
+	0x060c021d, 0x0aa1000e, 0x060c021e, 0x060c021f, 0x060c0220,
+	0x07802c4e, 0x0b00948e, 0x06b80007, 0x06c04407, 0x02007d07,
+	0x06035107, 0x06803f07, 0x06035207, 0x06a08007, 0x06035007,
+	0x07802cc7, 0x0aa24007, 0x06803fc7, 0x07802947, 0x0aa1c387,
+	0x07802cc7, 0x044011c7, 0x0ba0c707, 0x0c7fffc0, 0x0441c1c7,
+	0x07c02b07, 0x06800007, 0x07c02747, 0x0ac0b48e, 0x07802b07,
+	0x0b613fc7, 0x0ba0c707, 0x0441c1c7, 0x07c02b07, 0x06435007,
+	0x0580f1c7, 0x0bef8047, 0x0cc00000, 0x00000000, 0x06435007,
+	0x0580f1c7, 0x0bef8047, 0x00000000, 0x06435307, 0x0900c1c7,
+	0x0a6f8007, 0x06b80007, 0x06c04407, 0x02007d07, 0x06035107,
+	0x06803f07, 0x06035207, 0x06b0c007, 0x06035007, 0x054011d2,
+	0x0ac051ce, 0x06800087, 0x07c02b47, 0x0c7ff8c0, 0x07c02b87,
+	0x06b90008, 0x06c04408, 0x02008d08, 0x05401252, 0x02009489,
+	0x0680008a, 0x07c02b4a, 0x068000ca, 0x06435007, 0x0580f1c7,
+	0x0bef8047, 0x06803f07, 0x06035108, 0x06035207, 0x06a08007,
+	0x06035007, 0x0ac0324e, 0x0c7ff400, 0x07c02b8a, 0x06808007,
+	0x020081c8, 0x02009489, 0x0c7ffc80, 0x0400128a, 0x0400130c,
+	0x0480f30c, 0x07c02b8c, 0x0980b38b, 0x07802b4c, 0x0540928c,
+	0x0200a24a, 0x06c0440a, 0x0200ad0a, 0x0400130c, 0x0480f30c,
+	0x07c02b4c, 0x0643500c, 0x0580f30c, 0x0bef804c, 0x00000000,
+	0x0643530c, 0x0900c30c, 0x0a6f800c, 0x00000000, 0x0603510a,
+	0x06803f0a, 0x0603520a, 0x0c7fedc0, 0x0603500b, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264/mh264header_linux.h b/drivers/amlogic/amports/arch/ucode/h264/mh264header_linux.h
new file mode 100644
index 0000000..115126c
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264/mh264header_linux.h
@@ -0,0 +1,207 @@
+static const u32 MicroCode[] __initconst = {
+	0x06804011, 0x06905347, 0x07400447, 0x04002451, 0x0fc101c0,
+	0x09108247, 0x0a60e509, 0x0c7e6dc0, 0x00000000, 0x07400447,
+	0x04001451, 0x0fc08280, 0x07c00d0a, 0x0c0661c0, 0x080c2301,
+	0x0b2087c7, 0x0c7e6b80, 0x04000407, 0x09505287, 0x0740044a,
+	0x04001451, 0x0ba59909, 0x0c065f80, 0x080c2301, 0x05001387,
+	0x07803ccd, 0x09502347, 0x07c03ccd, 0x0c065e00, 0x080c2301,
+	0x0c065d80, 0x080c2301, 0x0fc011c0, 0x0fc01340, 0x0942134e,
+	0x0740044d, 0x04001451, 0x0aa1800d, 0x0680000e, 0x068001c7,
+	0x07c01d47, 0x0c009680, 0x06800009, 0x0c065a40, 0x080c2301,
+	0x04004247, 0x07400449, 0x04001451, 0x0c065900, 0x080c2301,
+	0x07400447, 0x04001451, 0x06800088, 0x0a835207, 0x06800008,
+	0x0a82e207, 0x00000000, 0x0fc011c0, 0x07400447, 0x04001451,
+	0x0c065600, 0x080c2301, 0x0c065780, 0x00000000, 0x07400447,
+	0x04001451, 0x058101c7, 0x07400447, 0x04001451, 0x0c0653c0,
+	0x080c2301, 0x0c065540, 0x00000000, 0x07400447, 0x04001451,
+	0x058101c7, 0x07400447, 0x04001451, 0x0c065180, 0x080c2301,
+	0x0aa68007, 0x0aa12007, 0x05807207, 0x0aa08008, 0x0c7e5a80,
+	0x07400447, 0x04001451, 0x04000287, 0x06808009, 0x0c064ec0,
+	0x080c2301, 0x0c065040, 0x00000000, 0x07400247, 0x04001249,
+	0x058101c7, 0x07400247, 0x0d07fe0a, 0x04001249, 0x0c7801c0,
+	0x00000000, 0x0c064bc0, 0x080c2301, 0x040041c7, 0x07400447,
+	0x04001451, 0x0c064a80, 0x080c2301, 0x04000247, 0x0fc011c0,
+	0x09501247, 0x07400449, 0x04001451, 0x0c0648c0, 0x080c2301,
+	0x04000347, 0x0c064800, 0x080c2301, 0x04000387, 0x0e00024d,
+	0x00000000, 0x00000000, 0x00000000, 0x0f0001c0, 0x0687c948,
+	0x0b007207, 0x0b20ddcd, 0x00000000, 0x0c7e4f80, 0x0400034e,
+	0x0b2090cd, 0x0c7e4ec0, 0x0400124d, 0x07400449, 0x04001451,
+	0x0400124e, 0x07400449, 0x04001451, 0x0fc011c0, 0x0a610007,
+	0x00000000, 0x0fc01200, 0x094211c8, 0x0fc01200, 0x094411c8,
+	0x07400447, 0x04001451, 0x0fc011c0, 0x0aa20007, 0x06800108,
+	0x0c063f80, 0x080c2301, 0x07400447, 0x0d07ff48, 0x04001451,
+	0x0c780140, 0x06800007, 0x07400447, 0x0d07ffc8, 0x04001451,
+	0x06804048, 0x07400211, 0x0fc01200, 0x0a60c008, 0x0c781600,
+	0x07400448, 0x0fc011c0, 0x09421207, 0x07400448, 0x0aa30007,
+	0x04001451, 0x0fc081c0, 0x07400447, 0x0a623fc7, 0x04001451,
+	0x0fc101c0, 0x07400447, 0x04001451, 0x0fc101c0, 0x07400447,
+	0x04001451, 0x0fc011c0, 0x0aa0c007, 0x00000000, 0x0fc011c0,
+	0x0fc011c0, 0x0aa1c007, 0x00000000, 0x0fc051c0, 0x0a210047,
+	0x00000000, 0x0fc101c0, 0x0fc081c0, 0x0fc011c0, 0x0aa14007,
+	0x0c063440, 0x080c2301, 0x0c0633c0, 0x080c2301, 0x0fc011c0,
+	0x07400447, 0x04001451, 0x0aa40007, 0x07c00687, 0x0fc101c0,
+	0x07400447, 0x04001451, 0x0fc101c0, 0x07400447, 0x04001451,
+	0x0fc101c0, 0x07400447, 0x04001451, 0x0fc101c0, 0x07400447,
+	0x04001451, 0x0fc011c0, 0x07c00687, 0x0680000e, 0x0fc011c0,
+	0x0aa18007, 0x09401387, 0x0c009a80, 0x00000000, 0x090aa207,
+	0x07c02f88, 0x0fc011c0, 0x0aa1c007, 0x09421387, 0x0c0098c0,
+	0x00000000, 0x0be0c04e, 0x090aa207, 0x07c02f88, 0x0a20c0ce,
+	0x00000000, 0x0fc011c0, 0x0fc011c0, 0x09441387, 0x0fc011c0,
+	0x09461387, 0x0740044e, 0x04001451, 0x0aa24007, 0x06800188,
+	0x0fc011c0, 0x0c062780, 0x080c2301, 0x0d07ff88, 0x00000000,
+	0x07400447, 0x04001451, 0x07803b47, 0x0a404407, 0x07803bc7,
+	0x09807007, 0x07c03bc7, 0x0697000a, 0x06c0444a, 0x0540a1d0,
+	0x0200a1ca, 0x06806009, 0x0c05fc00, 0x06a0400b, 0x0809d380,
+	0x0c7e2d40, 0x00000000, 0x0aa1000a, 0x06804047, 0x0c782140,
+	0x070001d1, 0x06804091, 0x07000447, 0x04001451, 0x07c039c7,
+	0x09108247, 0x07000448, 0x04001451, 0x090081c8, 0x07c03a07,
+	0x064c2908, 0x09c080c8, 0x060c2908, 0x0b60d909, 0x0c780680,
+	0x080e0000, 0x0700044d, 0x04001451, 0x064c2908, 0x090211cd,
+	0x09461207, 0x060c2908, 0x0aa3000d, 0x0680000e, 0x06800009,
+	0x06c00049, 0x060e0209, 0x068001c7, 0x07c01d47, 0x0c006300,
+	0x06800009, 0x06800009, 0x06c00049, 0x060e0209, 0x064e0007,
+	0x096e91cd, 0x060e0007, 0x064e0307, 0x095081ce, 0x060e0307,
+	0x07000449, 0x04001451, 0x07c020c9, 0x07000447, 0x04001451,
+	0x07c02147, 0x06800088, 0x0a819207, 0x06800008, 0x0a814207,
+	0x07000447, 0x04001451, 0x07c03a87, 0x07000447, 0x04001451,
+	0x07c03807, 0x07000447, 0x04001451, 0x07c03847, 0x07000447,
+	0x04001451, 0x07c03887, 0x07000447, 0x04001451, 0x07c038c7,
+	0x07000447, 0x04001451, 0x07c03987, 0x0c780100, 0x07000447,
+	0x04001451, 0x07c02187, 0x07000449, 0x04001451, 0x090081c9,
+	0x07c03907, 0x091011c9, 0x07c03947, 0x07000447, 0x04001451,
+	0x060c0907, 0x07c02c47, 0x04401247, 0x07c02c09, 0x07000449,
+	0x04001451, 0x07c02c89, 0x0700044d, 0x04001451, 0x090011cd,
+	0x0a60c007, 0x07c02107, 0x05401249, 0x04000289, 0x07802c48,
+	0x09610288, 0x0609520a, 0x05404289, 0x0968c288, 0x0609080a,
+	0x0e000248, 0x00000000, 0x00000000, 0x0f000200, 0x0a610007,
+	0x07c03a48, 0x0902120d, 0x094211c8, 0x07c02947, 0x090411cd,
+	0x0aa10007, 0x054011c7, 0x07802108, 0x094411c8, 0x07c02307,
+	0x06800087, 0x07802108, 0x02408207, 0x07000447, 0x04001451,
+	0x07000449, 0x04001451, 0x09508247, 0x05401249, 0x07c01a89,
+	0x07000447, 0x04001451, 0x07000449, 0x04001451, 0x09508247,
+	0x03409209, 0x07c01ac9, 0x07000447, 0x04001451, 0x0be0c047,
+	0x0c780900, 0x05801347, 0x05801347, 0x0a22c04d, 0x07000447,
+	0x04001451, 0x07c03d47, 0x0a61ffc7, 0x07000447, 0x04001451,
+	0x07c03d87, 0x07000447, 0x04001451, 0x07c03dc7, 0x07000447,
+	0x04001451, 0x0a238047, 0x09421347, 0x07000447, 0x04001451,
+	0x07c03e47, 0x07000447, 0x04001451, 0x07c03e07, 0x07000447,
+	0x04001451, 0x07c03ec7, 0x07000447, 0x04001451, 0x07c03e87,
+	0x07000447, 0x04001451, 0x09444347, 0x0a20c207, 0x07000447,
+	0x07c01b87, 0x0cc00000, 0x07c03d0d, 0x0680c011, 0x06905347,
+	0x07400447, 0x04001451, 0x0c05f540, 0x080c2301, 0x0b20bfc7,
+	0x0c7dff00, 0x04000407, 0x04000247, 0x0c05f3c0, 0x080c2301,
+	0x09505247, 0x0fc011c0, 0x095a1247, 0x0fc011c0, 0x095c1247,
+	0x07400449, 0x04001451, 0x0c05f180, 0x080c2301, 0x0aa0c007,
+	0x0c7dfb40, 0x00000000, 0x0c05f040, 0x080c2301, 0x04000207,
+	0x0c05ef80, 0x080c2301, 0x094a5207, 0x0fc011c0, 0x09541207,
+	0x0fc021c0, 0x09562207, 0x07400448, 0x04001451, 0x0c05ed40,
+	0x080c2301, 0x04000247, 0x0c05ec80, 0x080c2301, 0x09508247,
+	0x07400449, 0x04001451, 0x0c05eb40, 0x080c2301, 0x04000247,
+	0x0fc011c0, 0x09501247, 0x0fc011c0, 0x09521247, 0x0fc011c0,
+	0x09541247, 0x07400449, 0x064c2907, 0x091c21c7, 0x0a60c0c7,
+	0x0c780580, 0x04001451, 0x098092c9, 0x07400449, 0x04001451,
+	0x0fc011c0, 0x06800149, 0x05401347, 0x02009349, 0x07c01d49,
+	0x0fc01340, 0x094211cd, 0x07400447, 0x04001451, 0x0aa1000d,
+	0x0680000e, 0x0c001fc0, 0x06800009, 0x0c05e380, 0x080c2301,
+	0x07400447, 0x04001451, 0x07803b87, 0x0a404407, 0x07803bc7,
+	0x09807047, 0x07c03bc7, 0x06b7000a, 0x06c0444a, 0x054091d0,
+	0x0200a1ca, 0x06804009, 0x06a0c00b, 0x0c05b840, 0x00000000,
+	0x0809d381, 0x0c7de980, 0x00000000, 0x0680c051, 0x07000449,
+	0x04001451, 0x091a11c9, 0x07c02347, 0x0aa0c007, 0x06800007,
+	0x0687ffc7, 0x07c02a07, 0x091c11c9, 0x07c021c7, 0x06800808,
+	0x07000449, 0x04001451, 0x090051c9, 0x07c03ac7, 0x09505207,
+	0x090a51c9, 0x07c03b07, 0x09605207, 0x07802947, 0x096a2207,
+	0x060c2108, 0x091411c9, 0x07c028c7, 0x091621c9, 0x07c02907,
+	0x07000449, 0x04001451, 0x090081c9, 0x0c05d900, 0x00000000,
+	0x07c02247, 0x091081c9, 0x0c05d800, 0x00000000, 0x07000449,
+	0x04001451, 0x090081c9, 0x0c05d6c0, 0x00000000, 0x06801008,
+	0x09505207, 0x060c2108, 0x06801408, 0x09505207, 0x060c2108,
+	0x091011c9, 0x07c02287, 0x091211c9, 0x064e0e08, 0x09401207,
+	0x060e0e08, 0x091411c9, 0x07c02207, 0x0580b1c9, 0x0be18047,
+	0x06800007, 0x07802308, 0x09c08008, 0x0cc00000, 0x07c02308,
+	0x07000449, 0x04001451, 0x090011c9, 0x0680014d, 0x05401387,
+	0x0200d38d, 0x07c01d4d, 0x07802308, 0x09401207, 0x07c02308,
+	0x09021349, 0x0aa2800d, 0x0680000e, 0x06801c09, 0x06c00049,
+	0x060e0209, 0x0c0013c0, 0x06800009, 0x06800009, 0x06c00049,
+	0x060e0209, 0x064e0007, 0x095c91cd, 0x060e0007, 0x064e0307,
+	0x094081ce, 0x060e0307, 0x07000447, 0x04001451, 0x0c05c9c0,
+	0x00000000, 0x06801408, 0x09505207, 0x0cc00000, 0x060c2108,
+	0x0ba0c189, 0x0680020c, 0x0680080c, 0x07801d47, 0x0b8041c9,
+	0x04001249, 0x0cc00000, 0x00000000, 0x0540134d, 0x0540138e,
+	0x0fc01200, 0x07400448, 0x04001451, 0x09401348, 0x0aac8008,
+	0x0680020a, 0x0680020b, 0x0ba0c189, 0x068003cc, 0x06800fcc,
+	0x0aa4400b, 0x00000000, 0x0c05c0c0, 0x080c2301, 0x07400447,
+	0x04001451, 0x0c05c1c0, 0x00000000, 0x02007287, 0x048ff2c7,
+	0x0a61800b, 0x0aa0cfcc, 0x0b614189, 0x0a6103cc, 0x0c7ff780,
+	0x0980e00e, 0x0400028b, 0x054083cf, 0x0be0c04c, 0x094083ca,
+	0x06c0000f, 0x0aeac00c, 0x0440130c, 0x07801d47, 0x0b8031c9,
+	0x0cc00000, 0x00000000, 0x0c7ff640, 0x04001249, 0x0ba0c189,
+	0x0680020c, 0x0680080c, 0x064e020a, 0x0200a30a, 0x06c0004a,
+	0x060e020a, 0x0ba101c9, 0x04001249, 0x0cc00000, 0x00000000,
+	0x0540134d, 0x0540138e, 0x07801d48, 0x0ac04209, 0x06800008,
+	0x07000448, 0x04001451, 0x09401348, 0x0aab4008, 0x0680020a,
+	0x0680020b, 0x0ba0c189, 0x068003cc, 0x06800fcc, 0x0aa3400b,
+	0x07000447, 0x0c05b540, 0x04001451, 0x02007287, 0x048ff2c7,
+	0x0a61800b, 0x0aa0cfcc, 0x0b614189, 0x0a6103cc, 0x0c7ff740,
+	0x0980e00e, 0x0400028b, 0x054083cf, 0x0be1004c, 0x094083ca,
+	0x06c0000f, 0x060e020f, 0x0aeb800c, 0x0440130c, 0x0ba0c1c9,
+	0x0cc00000, 0x00000000, 0x0c7ff6c0, 0x04001249, 0x0680000c,
+	0x0680002a, 0x064c2907, 0x0a20c407, 0x0c7db700, 0x00000000,
+	0x0fc081c0, 0x0aaeffc7, 0x0200c1cc, 0x064c2907, 0x0a20c407,
+	0x0c7db540, 0x00000000, 0x0fc081c0, 0x0aaeffc7, 0x0202a1ea,
+	0x0aa5c00c, 0x0c7db3c0, 0x00000000, 0x0aa1418c, 0x0462d1cc,
+	0x0c500880, 0x0a61004c, 0x0c780e80, 0x06800047, 0x07c01c47,
+	0x064c0007, 0x0be14207, 0x064c2907, 0x0be0c407, 0x0d07ff2a,
+	0x0fc081c0, 0x064c0007, 0x0be10207, 0x064c2907, 0x0be08407,
+	0x0c7ff700, 0x0c7daec0, 0x00000000, 0x0c05a3c0, 0x080c2301,
+	0x064c232b, 0x05810aeb, 0x048ffaeb, 0x0697000a, 0x06c0444a,
+	0x0540a1c7, 0x0200a1ca, 0x06804009, 0x0c0579c0, 0x06b0400b,
+	0x07804007, 0x06905348, 0x0a80f207, 0x0c7daa80, 0x0c059fc0,
+	0x080c2301, 0x064c232b, 0x05810aeb, 0x048ffaeb, 0x0fc011c0,
+	0x0aa14047, 0x04001aeb, 0x0fc071c0, 0x04007aeb, 0x07c017c7,
+	0x0c780140, 0x00000000, 0x0680004a, 0x0c077a00, 0x00000000,
+	0x048071eb, 0x0580322b, 0x0aa14007, 0x06800209, 0x04001208,
+	0x024071c9, 0x0f8001c7, 0x0262a22a, 0x0c57f440, 0x0c7ff280,
+	0x0680002b, 0x07803d0d, 0x0a22830d, 0x07802f87, 0x09005207,
+	0x04001208, 0x0c000340, 0x0202b22b, 0x090a5207, 0x04001208,
+	0x0c000240, 0x0202b22b, 0x0a21440d, 0x00000000, 0x0fc041c0,
+	0x07c02fc7, 0x04004aeb, 0x0c7ff940, 0x00000000, 0x0b210408,
+	0x00000000, 0x0fc10240, 0x04410208, 0x0cc00000, 0x0f800208,
+	0x0c059300, 0x080c2301, 0x04001347, 0x0fc081c0, 0x0c059200,
+	0x080c2301, 0x0c059180, 0x080c2301, 0x0d07ff0d, 0x0fc011c0,
+	0x0fc051c0, 0x0cc00000, 0x0fc0f1c0, 0x06800007, 0x07c03c47,
+	0x07c03c87, 0x07c01747, 0x07803c47, 0x07803c88, 0x0780174b,
+	0x07800a4d, 0x07800a8e, 0x07802c49, 0x07803a4a, 0x0780390c,
+	0x07803e8f, 0x07803ed0, 0x07803e11, 0x0a409247, 0x0a408288,
+	0x0a40730b, 0x0a4063cd, 0x0a40540e, 0x00000000, 0x07800a07,
+	0x0a402447, 0x0c781480, 0x06800007, 0x07c07087, 0x07803bc7,
+	0x09807087, 0x07c03bc7, 0x069fffc7, 0x07c03c49, 0x07c03c8a,
+	0x07c0174c, 0x07c00a4f, 0x07c00a90, 0x07c00a11, 0x0a803207,
+	0x07807047, 0x07c07187, 0x07802c47, 0x07803a48, 0x095101c8,
+	0x07803908, 0x097071c8, 0x07802308, 0x09041208, 0x097e11c8,
+	0x0609c107, 0x07803d07, 0x07802108, 0x095e11c8, 0x07800688,
+	0x094c11c8, 0x07803cc8, 0x09102208, 0x095a21c8, 0x07803d48,
+	0x096101c8, 0x0609c207, 0x07803d87, 0x07803dc8, 0x096101c8,
+	0x0609c307, 0x07803e07, 0x07803e48, 0x096101c8, 0x0609c407,
+	0x07803e87, 0x07803ec8, 0x096101c8, 0x0609c507, 0x07801ac7,
+	0x07801a88, 0x096101c8, 0x0609c607, 0x07803908, 0x07800d07,
+	0x095081c8, 0x0609cb07, 0x06800047, 0x0609c007, 0x0809d311,
+	0x08007401, 0x0680001b, 0x0649c008, 0x0befbfc8, 0x091081c8,
+	0x07c03187, 0x092081c8, 0x07c07047, 0x093081c8, 0x07803cc8,
+	0x09408207, 0x07c03cc8, 0x06800007, 0x07c071c7, 0x07c07207,
+	0x0649c107, 0x07c078c7, 0x058101c7, 0x07c07907, 0x0649c407,
+	0x07c07947, 0x058101c7, 0x07c07987, 0x07803cc8, 0x09008208,
+	0x07802307, 0x090411c7, 0x054011c7, 0x034081c8, 0x07803907,
+	0x07803189, 0x0b004247, 0x00000000, 0x040001c9, 0x07c03907,
+	0x0b803207, 0x044011c8, 0x07c03907, 0x0cc00000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264/mh264list_linux.h b/drivers/amlogic/amports/arch/ucode/h264/mh264list_linux.h
new file mode 100644
index 0000000..451fa27
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264/mh264list_linux.h
@@ -0,0 +1,207 @@
+static const u32 MicroCode[] __initconst = {
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x06bff7c0, 0x06032400, 0x00400000, 0x0c780000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000,
+	0x0cc00000, 0x00400000, 0x0c780080, 0x06431e07, 0x09027207,
+	0x0a668048, 0x068fdfca, 0x06fcffca, 0x064e0408, 0x02808288,
+	0x09110287, 0x064c0909, 0x0ac0924a, 0x0b80324a, 0x0c7801c0,
+	0x09808688, 0x0400128a, 0x098083c8, 0x0a40324a, 0x0440128a,
+	0x098086c8, 0x0aa1000a, 0x09308287, 0x0a60c00a, 0x0400128a,
+	0x09808388, 0x0b80324a, 0x00000000, 0x098081c8, 0x0c780240,
+	0x060e0408, 0x0a614248, 0x00000000, 0x0c008f80, 0x00000000,
+	0x0c7800c0, 0x0c780080, 0x00000000, 0x08031e00, 0x0cc00000,
+	0x00400000, 0x0680400f, 0x0680a00e, 0x0680ec0d, 0x0680f60c,
+	0x0780704b, 0x0680000a, 0x06800009, 0x06800008, 0x0780776f,
+	0x07807780, 0x09610bc0, 0x0780736e, 0x078020c0, 0x06800041,
+	0x0342d001, 0x07807300, 0x06800081, 0x0b831040, 0x05403c4a,
+	0x02031c4f, 0x04001c71, 0x07000c44, 0x06800c00, 0x0bc25004,
+	0x09042004, 0x068000c1, 0x0a422040, 0x09101004, 0x04001c31,
+	0x02030030, 0x02030030, 0x07000c2c, 0x04001c30, 0x07000c00,
+	0x09610b00, 0x04005c71, 0x07000c6b, 0x0b003bab, 0x00000000,
+	0x0242bb6b, 0x0202a209, 0x05402c2a, 0x02030c0e, 0x07400c0a,
+	0x068000c0, 0x04001c30, 0x07400c00, 0x04001c30, 0x07400c2b,
+	0x0581002b, 0x04001c30, 0x07400c00, 0x0ac05bec, 0x0203024d,
+	0x07400c2a, 0x04001249, 0x0c780100, 0x0203020c, 0x07400c2a,
+	0x04001208, 0x0400128a, 0x0b8d52ca, 0x02000209, 0x07c070c9,
+	0x0cc00000, 0x07c07100, 0x0aa14040, 0x06800047, 0x06800006,
+	0x0c780100, 0x00000000, 0x06800007, 0x06800046, 0x05403c4a,
+	0x02031c4f, 0x04001c71, 0x07000c44, 0x09101004, 0x04001c31,
+	0x02030030, 0x02030030, 0x07000c2c, 0x04001c30, 0x07000c00,
+	0x09610b00, 0x04005c71, 0x07000c6b, 0x0b003bab, 0x00000000,
+	0x0242bb6b, 0x0be60404, 0x0a25c104, 0x0202a209, 0x05402c2a,
+	0x02030c0e, 0x07400c0a, 0x06800040, 0x04001c30, 0x07400c00,
+	0x0540102b, 0x020001c0, 0x04001c30, 0x07400c00, 0x05810000,
+	0x04001c30, 0x07400c00, 0x0ac05bec, 0x0203024d, 0x07400c2a,
+	0x04001249, 0x0c780100, 0x0203020c, 0x07400c2a, 0x04001208,
+	0x0be60804, 0x0a25c204, 0x0202a209, 0x05402c2a, 0x02030c0e,
+	0x07400c0a, 0x06800080, 0x04001c30, 0x07400c00, 0x0540102b,
+	0x02000180, 0x04001c30, 0x07400c00, 0x05810000, 0x04001c30,
+	0x07400c00, 0x0ac05bec, 0x0203024d, 0x07400c2a, 0x04001249,
+	0x0c780100, 0x0203020c, 0x07400c2a, 0x04001208, 0x0400128a,
+	0x0b8be2ca, 0x02000209, 0x07c070c9, 0x0cc00000, 0x07c07100,
+	0x0680400f, 0x0680a00e, 0x0680ec0d, 0x0780704b, 0x0680000a,
+	0x07807109, 0x07807300, 0x0ba6c080, 0x05403c4a, 0x02031c4f,
+	0x04001c71, 0x07000c44, 0x09082004, 0x0a6440c0, 0x04006c71,
+	0x07000c6b, 0x05402c09, 0x02030c0e, 0x07400c0a, 0x068001c0,
+	0x04001c30, 0x07400c00, 0x04001c30, 0x07400c2b, 0x0581002b,
+	0x04001c30, 0x07400c00, 0x0203024d, 0x07400c09, 0x04001249,
+	0x0400128a, 0x0b8e92ca, 0x0cc00000, 0x07c07149, 0x0aa14040,
+	0x06800047, 0x06800006, 0x0c780100, 0x00000000, 0x06800007,
+	0x06800046, 0x05403c4a, 0x02031c4f, 0x04001c71, 0x07000c44,
+	0x04006c71, 0x07000c6b, 0x0a244404, 0x05402c09, 0x02030c0e,
+	0x07400c0a, 0x06800140, 0x04001c30, 0x07400c00, 0x0540102b,
+	0x020001c0, 0x04001c30, 0x07400c00, 0x05810000, 0x04001c30,
+	0x07400c00, 0x0203024d, 0x07400c09, 0x04001249, 0x0a244804,
+	0x05402c09, 0x02030c0e, 0x07400c0a, 0x06800180, 0x04001c30,
+	0x07400c00, 0x0540102b, 0x02000180, 0x04001c30, 0x07400c00,
+	0x05810000, 0x04001c30, 0x07400c00, 0x0203024d, 0x07400c09,
+	0x04001249, 0x0400128a, 0x0b8d72ca, 0x0cc00000, 0x07c07149,
+	0x0680ec0f, 0x0680f60e, 0x0780710a, 0x078070c9, 0x06800008,
+	0x0240a24a, 0x0200e28e, 0x0a60c009, 0x0cc00000, 0x00000000,
+	0x070003c0, 0x07400380, 0x040013cf, 0x0400138e, 0x04001208,
+	0x0b8fb248, 0x0cc00000, 0x00000000, 0x0680ec0f, 0x0680f60e,
+	0x0780710a, 0x078070c9, 0x06800008, 0x0240a24a, 0x0200f24f,
+	0x0a60c00a, 0x0cc00000, 0x00000000, 0x07000380, 0x074003c0,
+	0x040013cf, 0x0400138e, 0x04001208, 0x0b8fb288, 0x0cc00000,
+	0x00000000, 0x0680ec0f, 0x0680f60e, 0x0780710a, 0x07807149,
+	0x0200f28f, 0x0200e28e, 0x0a40324a, 0x0cc00000, 0x00000000,
+	0x070003c0, 0x07400380, 0x040013cf, 0x0400138e, 0x0400128a,
+	0x0b8fb24a, 0x0cc00000, 0x00000000, 0x0b60808e, 0x0c780e00,
+	0x0680a00c, 0x0680400b, 0x0680000a, 0x0a83438a, 0x0400124a,
+	0x0202f28f, 0x07000bee, 0x0540222e, 0x0200820c, 0x04002208,
+	0x0700022d, 0x04001208, 0x07000200, 0x09610b40, 0x0a814389,
+	0x0202c24f, 0x07000b2b, 0x0540222b, 0x0200820c, 0x04002208,
+	0x0700022a, 0x04001208, 0x07000200, 0x09610a80, 0x0a60c00d,
+	0x0b807aad, 0x0c7800c0, 0x0ac05aad, 0x00000000, 0x07400b2e,
+	0x04000bab, 0x04000b6a, 0x04001249, 0x0c7ffb40, 0x07807300,
+	0x0b644080, 0x0a24004a, 0x0540222e, 0x0200820c, 0x04002208,
+	0x07000207, 0x0a22c047, 0x04401b6f, 0x07000b6c, 0x0540222c,
+	0x0200820c, 0x04002208, 0x07000207, 0x0be10047, 0x00000000,
+	0x07400b6e, 0x04000bac, 0x07400bee, 0x0400128a, 0x0c7ff340,
+	0x0cc00000, 0x00000000, 0x0b60808e, 0x0c781680, 0x0680a00c,
+	0x0680400b, 0x0680000a, 0x0a85638a, 0x0400124a, 0x0202f28f,
+	0x07000bee, 0x0540222e, 0x0200820c, 0x07000207, 0x04001208,
+	0x07000206, 0x054031c7, 0x020071cb, 0x09002146, 0x0a6280c5,
+	0x00000000, 0x040011c7, 0x070001c4, 0x09101c44, 0x040011c7,
+	0x02007c47, 0x02007c47, 0x0c780100, 0x00000000, 0x02007147,
+	0x02007147, 0x070001ed, 0x040011c7, 0x070001c0, 0x09610b40,
+	0x0a825389, 0x0202c24f, 0x07000b2b, 0x0540222b, 0x0200820c,
+	0x07000207, 0x04001208, 0x07000206, 0x054031c7, 0x020071cb,
+	0x09002146, 0x0a6280c5, 0x00000000, 0x040011c7, 0x070001c4,
+	0x09101c44, 0x040011c7, 0x02007c47, 0x02007c47, 0x0c780100,
+	0x00000000, 0x02007147, 0x02007147, 0x070001ea, 0x040011c7,
+	0x070001c0, 0x09610a80, 0x0a60c00d, 0x0b807aad, 0x0c7800c0,
+	0x0ac05aad, 0x00000000, 0x07400b2e, 0x04000bab, 0x04000b6a,
+	0x04001249, 0x0c7ff700, 0x07807300, 0x0b644080, 0x0a24004a,
+	0x0540222e, 0x0200820c, 0x04002208, 0x07000207, 0x0a22c047,
+	0x04401b6f, 0x07000b6c, 0x0540222c, 0x0200820c, 0x04002208,
+	0x07000207, 0x0be10047, 0x00000000, 0x07400b6e, 0x04000bac,
+	0x07400bee, 0x0400128a, 0x0c7feac0, 0x0cc00000, 0x00000000,
+	0x0400120a, 0x0200720f, 0x070001c9, 0x05402189, 0x0200618c,
+	0x04002186, 0x07000185, 0x09001005, 0x0a4092c0, 0x04401c47,
+	0x07000c40, 0x074001c0, 0x04401208, 0x0acfc288, 0x040001f1,
+	0x0cc00000, 0x074001c9, 0x04001208, 0x0b8ef388, 0x0cc00000,
+	0x00000000, 0x0780710e, 0x0440134e, 0x0680a00c, 0x0680000a,
+	0x0b60808e, 0x0c7804c0, 0x0200928f, 0x07000248, 0x054021c8,
+	0x020071cc, 0x040021c7, 0x070001c6, 0x0be1804a, 0x0be24046,
+	0x00000000, 0x0c07f700, 0x0680004b, 0x0c780140, 0x0a210046,
+	0x00000000, 0x0c07f5c0, 0x0680000b, 0x0400128a, 0x0b8ef34a,
+	0x0cc00000, 0x00000000, 0x06800008, 0x0700040a, 0x0200720f,
+	0x070001c9, 0x05402189, 0x020061af, 0x04001186, 0x07000185,
+	0x09041005, 0x0a418a80, 0x04001186, 0x07000185, 0x04001186,
+	0x07000180, 0x09610140, 0x0a412305, 0x0a80e348, 0x0ac07348,
+	0x00000000, 0x0200734f, 0x0a80a34a, 0x0400128a, 0x0440120a,
+	0x0200720f, 0x04401c47, 0x07000c40, 0x074001c0, 0x04401208,
+	0x0acfc348, 0x040001f1, 0x074001c9, 0x0cc00000, 0x0740040a,
+	0x04001208, 0x0b8e0288, 0x0cc00000, 0x00000000, 0x0680a02f,
+	0x078020c0, 0x06800041, 0x0342e001, 0x0780736d, 0x07807300,
+	0x0b614080, 0x00000000, 0x05401bae, 0x05401b6d, 0x04001b6d,
+	0x0242cbad, 0x04000aed, 0x0680000d, 0x0680002a, 0x07000380,
+	0x0400138e, 0x0aa10000, 0x0aa30040, 0x0aa50080, 0x0c780680,
+	0x07000380, 0x0400138e, 0x04001000, 0x0242b02b, 0x0b411b2b,
+	0x0400032b, 0x0202bbab, 0x0c780380, 0x0400032b, 0x07000380,
+	0x0400138e, 0x04001000, 0x0202b02b, 0x0b808b6b, 0x0400032b,
+	0x0242bbab, 0x0c780140, 0x0400032b, 0x0680006a, 0x0700038c,
+	0x0400138e, 0x0c07ec40, 0x00000000, 0x0c7ff880, 0x0400134d,
+	0x0cc00000, 0x00000000, 0x0c077280, 0x00000000, 0x0c079600,
+	0x00000000, 0x07802080, 0x0aa64180, 0x00000000, 0x0c07ae80,
+	0x00000000, 0x07807140, 0x07c07240, 0x0680ec0f, 0x0780710e,
+	0x0680004d, 0x0c07b580, 0x00000000, 0x0680ec0f, 0x0780714e,
+	0x07807100, 0x0200f00f, 0x0240e00e, 0x0680000d, 0x0c07b380,
+	0x00000000, 0x0680ec0f, 0x0680c00e, 0x0c07ed80, 0x06807250,
+	0x0cc00000, 0x00000000, 0x0680ec0f, 0x078070ce, 0x0680004d,
+	0x0c07bf80, 0x00000000, 0x0680f60f, 0x0780710e, 0x078070c0,
+	0x0240e00e, 0x0680000d, 0x0c07bdc0, 0x00000000, 0x0680ec0f,
+	0x0780714e, 0x07807100, 0x0200f00f, 0x0240e00e, 0x0680000d,
+	0x0c07ad00, 0x00000000, 0x0c07a3c0, 0x00000000, 0x0c079ec0,
+	0x00000000, 0x0c07a740, 0x00000000, 0x07807140, 0x07c07240,
+	0x07c07280, 0x07807300, 0x0b618080, 0x00000000, 0x0c07d4c0,
+	0x0680ec0f, 0x0c07d440, 0x0680f60f, 0x078070c0, 0x07807101,
+	0x07807170, 0x0ba280b0, 0x0aa0c000, 0x0a802040, 0x0c7801c0,
+	0x0680f60f, 0x0400138f, 0x070003c0, 0x07000381, 0x07400380,
+	0x074003c1, 0x0680ec0f, 0x0680c00e, 0x0c07dfc0, 0x06807250,
+	0x0680f60f, 0x0680d08e, 0x0c07dec0, 0x06807290, 0x0cc00000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264/mh264mmc_linux.h b/drivers/amlogic/amports/arch/ucode/h264/mh264mmc_linux.h
new file mode 100644
index 0000000..6badd4e
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264/mh264mmc_linux.h
@@ -0,0 +1,207 @@
+static const u32 MicroCode[] __initconst = {
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264/mh264slice_linux.h b/drivers/amlogic/amports/arch/ucode/h264/mh264slice_linux.h
new file mode 100644
index 0000000..92bb2cb
--- /dev/null
+++ b/drivers/amlogic/amports/arch/ucode/h264/mh264slice_linux.h
@@ -0,0 +1,207 @@
+static const u32 MicroCode[] __initconst = {
+	0x07802007, 0x07802048, 0x094a21c8, 0x07c072c7, 0x07802407,
+	0x044011c7, 0x07802948, 0x02808207, 0x09021208, 0x02007207,
+	0x07c07307, 0x07802dc7, 0x0aa08047, 0x0c780140, 0x07802007,
+	0x068c000a, 0x0c064000, 0x06c0000a, 0x07802207, 0x0aa10007,
+	0x00000000, 0x0c065fc0, 0x080c2301, 0x07803ac7, 0x07c073c7,
+	0x07803b07, 0x07c07407, 0x07802087, 0x0aa10187, 0x06800148,
+	0x0a83c207, 0x0c781700, 0x00000000, 0x0fc011c0, 0x06800808,
+	0x096e1207, 0x078073c7, 0x09505207, 0x0fc011c0, 0x0aa24007,
+	0x07807407, 0x0c065ac0, 0x080c2301, 0x07c073c7, 0x09505207,
+	0x0c0659c0, 0x080c2301, 0x07c07407, 0x09605207, 0x07802947,
+	0x096a2207, 0x060c2108, 0x068000c7, 0x07c0c007, 0x0fc011c0,
+	0x0aa10007, 0x00000000, 0x0c06e040, 0x0680c009, 0x068000c7,
+	0x07c0d087, 0x0fc011c0, 0x0aa10007, 0x00000000, 0x0c06de80,
+	0x0680d089, 0x07802907, 0x0a60c087, 0x06800008, 0x06815408,
+	0x09402207, 0x0a644047, 0x06094208, 0x0c0652c0, 0x080c2301,
+	0x09484207, 0x0c065200, 0x080c2301, 0x09504207, 0x06094208,
+	0x0680c007, 0x06094007, 0x0c06e040, 0x078073c9, 0x0680d807,
+	0x06094007, 0x0c06df40, 0x07807409, 0x0c7808c0, 0x00000000,
+	0x0fc011c0, 0x06800808, 0x0aa14007, 0x078073c7, 0x0c064d80,
+	0x080c2301, 0x07c073c7, 0x09505207, 0x07802947, 0x096a2207,
+	0x060c2108, 0x068000c7, 0x07c0c007, 0x0fc011c0, 0x0aa10007,
+	0x00000000, 0x0c06d400, 0x0680c009, 0x078028c7, 0x04000207,
+	0x0aa34007, 0x06094208, 0x0c064900, 0x080c2301, 0x09484207,
+	0x0c064840, 0x080c2301, 0x09504207, 0x06094208, 0x0680c007,
+	0x06094007, 0x0c06d680, 0x078073c9, 0x06494007, 0x09c07247,
+	0x06094007, 0x07802047, 0x0aa7c007, 0x07802007, 0x06800148,
+	0x0a82a207, 0x00000000, 0x06800007, 0x07c0e107, 0x0fc011c0,
+	0x0aa5c007, 0x0680e109, 0x04000289, 0x02407289, 0x0b610a47,
+	0x06800007, 0x0c0641c0, 0x080c2301, 0x0aa3c007, 0x07400247,
+	0x0aae4147, 0x04001249, 0x04000207, 0x0c064000, 0x080c2301,
+	0x07400247, 0x0a6cc0c8, 0x04001249, 0x0c063ec0, 0x080c2301,
+	0x07400247, 0x0c7ffb80, 0x04001249, 0x0649cf07, 0x0a20c0c7,
+	0x06800007, 0x07c0e107, 0x07802347, 0x0aa2c007, 0x07802087,
+	0x0aa24087, 0x06800c08, 0x0c063b40, 0x080c2301, 0x09402207,
+	0x0c780100, 0x060c2108, 0x0fc021c0, 0x07c0e107, 0x07801e87,
+	0x0a608047, 0x0c780140, 0x07802087, 0x06800188, 0x0a402207,
+	0x0680f608, 0x0694000a, 0x06c0444a, 0x0680c009, 0x0c060f80,
+	0x06a0400b, 0x0c063680, 0x080c2301, 0x0c063800, 0x00000000,
+	0x0401a1c7, 0x07802248, 0x02007207, 0x07c02387, 0x07802287,
+	0x0aa40007, 0x06800009, 0x0c0633c0, 0x080c2301, 0x0aa30047,
+	0x09402247, 0x0c0632c0, 0x080c2301, 0x0c063440, 0x00000000,
+	0x094c4247, 0x0c063180, 0x080c2301, 0x0c063300, 0x00000000,
+	0x09444247, 0x060c3109, 0x0c7f5b40, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000
+};
diff --git a/drivers/amlogic/amports/arch/ucode/h264/vh264_mc.c b/drivers/amlogic/amports/arch/ucode/h264/vh264_mc.c
index b040f3f..721af91 100644
--- a/drivers/amlogic/amports/arch/ucode/h264/vh264_mc.c
+++ b/drivers/amlogic/amports/arch/ucode/h264/vh264_mc.c
@@ -88,6 +88,29 @@
 #define MicroCode gxm_vh264_slice_mc
 #include "gxm_h264slice_linux.h"
 
+#undef MicroCode
+#define MicroCode vmh264_mc
+#include "mh264c_linux.h"
+
+#undef MicroCode
+#define MicroCode vmh264_header_mc
+#include "mh264header_linux.h"
+
+#undef MicroCode
+#define MicroCode vmh264_data_mc
+#include "mh264data_linux.h"
+
+#undef MicroCode
+#define MicroCode vmh264_mmco_mc
+#include "mh264mmc_linux.h"
+
+#undef MicroCode
+#define MicroCode vmh264_list_mc
+#include "mh264list_linux.h"
+
+#undef MicroCode
+#define MicroCode vmh264_slice_mc
+#include "mh264slice_linux.h"
 
 #undef FOR_CPUS
 #define FOR_CPUS {MESON_CPU_MAJOR_ID_GXTVBB, MESON_CPU_MAJOR_ID_GXL,\
@@ -133,6 +156,12 @@
 		DEF_FIRMWARE(gxtvbb_vh264_slice_mc);\
 		DEF_FIRMEARE_FOR_GXM(gxm_vh264_slice_mc);\
 		DEF_FIRMEARE_FOR_TXL(gxm_vh264_slice_mc);\
+		DEF_FIRMWARE(vmh264_mc);\
+		DEF_FIRMWARE(vmh264_header_mc);\
+		DEF_FIRMWARE(vmh264_data_mc);\
+		DEF_FIRMWARE(vmh264_mmco_mc);\
+		DEF_FIRMWARE(vmh264_list_mc);\
+		DEF_FIRMWARE(vmh264_slice_mc);\
 	} while (0)
 
 INIT_DEF_FIRMWARE();
diff --git a/drivers/amlogic/amports/arch/ucode/h264mvc/vh264mvc_mc.c b/drivers/amlogic/amports/arch/ucode/h264mvc/vh264mvc_mc.c
index acdf089..f19b8ea 100644
--- a/drivers/amlogic/amports/arch/ucode/h264mvc/vh264mvc_mc.c
+++ b/drivers/amlogic/amports/arch/ucode/h264mvc/vh264mvc_mc.c
@@ -50,9 +50,10 @@
 
 #define FOR_VFORMAT VFORMAT_H264MVC
 
+#define GXM_TXL_CPUS {MESON_CPU_MAJOR_ID_GXM, MESON_CPU_MAJOR_ID_TXL, 0}
 #define DEF_FIRMEARE_FOR_GXM(n) \
-		REGISTER_FIRMARE_PER_CPU(MESON_CPU_MAJOR_ID_GXM,\
-		FOR_VFORMAT, n)
+	DEF_FIRMWARE_FOR_CPUS_TYPE_VER(GXM_TXL_CPUS, \
+		FOR_VFORMAT, n, F_VERSION)
 
 #define REG_FIRMWARE_ALL()\
 	do {\
diff --git a/drivers/amlogic/amports/arch/ucode/h265/vh265_mc.c b/drivers/amlogic/amports/arch/ucode/h265/vh265_mc.c
index a661fc7..1d9d8aa 100644
--- a/drivers/amlogic/amports/arch/ucode/h265/vh265_mc.c
+++ b/drivers/amlogic/amports/arch/ucode/h265/vh265_mc.c
@@ -16,60 +16,65 @@
 */
 
 #include "../firmware_def.h"
-/* commit 11e8fec363d34cf56b1c661c2d670ea7d9a9b454*/
+/* commit f80e4758452b458c65263953d6b1e7a1e4df41a6*/
 
 /* #undef SEND_PARAM_WITH_REG */
-#define VERSTR "11e8fec3"
+#define VERSTR "f80e4758"
+#define VERSTR_MMU "f80e4758"
 
 const u32  vh265_mc[] __initconst = {
 	0x06810001, 0x06800000, 0x0d000001, 0x07400040, 0x0c000900,
 	0x00000000, 0x06bffe40, 0x07c00000, 0x06030400, 0x00400000,
-	0x0800c0ff, 0x0c033300, 0x00000000, 0x00000000, 0x00000000,
+	0x0800c0ff, 0x0c034ec0, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x0c7ffd80, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x0c7a6580, 0x00000000, 0x0c7a1380,
-	0x06412108, 0x0c780900, 0x00000000, 0x0cc00000, 0x00400000,
-	0x0800c000, 0x08002515, 0x08002608, 0x06bfbb80, 0x06ffbfc0,
-	0x06070500, 0x06070600, 0x06070700, 0x06803fc0, 0x07c00140,
-	0x07c007c0, 0x07c01740, 0x0640d000, 0x07c036c0, 0x0640d200,
-	0x07c03640, 0x0640c108, 0x06035108, 0x06800408, 0x06035208,
-	0x06a04008, 0x06035008, 0x06435008, 0x0580f208, 0x0bef8048,
-	0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008, 0x00000000,
-	0x0cc00000, 0x00000000, 0x06bfff88, 0x06030408, 0x00400000,
-	0x0640c008, 0x0a618808, 0x00000000, 0x0c02fdc0, 0x00000000,
-	0x0c7a0380, 0x0800c0ff, 0x0aa0c048, 0x0c781f40, 0x00000000,
-	0x06410c08, 0x08010e90, 0x09326208, 0x0aa0c808, 0x0c7a0140,
-	0x0800c0fe, 0x07803688, 0x09808008, 0x07c03688, 0x06410c08,
-	0x08010e90, 0x09384288, 0x09223248, 0x07c00189, 0x09201248,
-	0x07c001c9, 0x08010e90, 0x07800148, 0x0a805288, 0x07c0010a,
-	0x0aa0ffc8, 0x0c027d00, 0x05407308, 0x0780010a, 0x07c0014a,
-	0x06410c08, 0x08010e88, 0x09305248, 0x07c00209, 0x06410c08,
-	0x08010e90, 0x09210248, 0x07c00249, 0x06410c08, 0x08010e90,
-	0x09210248, 0x07c00289, 0x06410c08, 0x08010e84, 0x09384248,
-	0x07c04f49, 0x08010e90, 0x08010e90, 0x08010e8c, 0x06410c08,
-	0x08010e88, 0x09308248, 0x07c002c9, 0x0780018b, 0x0aa6400b,
-	0x00000000, 0x06410c0a, 0x08010e90, 0x0aa5400b, 0x093e124a,
-	0x0aa30009, 0x06410c08, 0x08010e88, 0x06410c08, 0x08010e90,
-	0x06410c08, 0x08010e90, 0x06410c08, 0x08010e84, 0x08010e90,
-	0x08010e90, 0x08010e8c, 0x093c124a, 0x0aa0c009, 0x06410c08,
-	0x08010e88, 0x0540228a, 0x0c7ffb40, 0x044012cb, 0x06410c08,
-	0x08010e81, 0x093e1248, 0x0780018b, 0x0a60c009, 0x0680000a,
-	0x0780018a, 0x0ac0a2ca, 0x00000000, 0x0c01ee80, 0x06800309,
-	0x0c01ee00, 0x06800409, 0x0c01ed80, 0x06800509, 0x0c7ffe00,
-	0x0400128a, 0x08010e86, 0x06806008, 0x06010e08, 0x06410f08,
-	0x0befc0c8, 0x09118208, 0x0aa08008, 0x0c780000, 0x06410c08,
+	0x00000000, 0x00000000, 0x0c7a7940, 0x00000000, 0x0c7a2340,
+	0x06412108, 0x0c780d00, 0x00000000, 0x0cc00000, 0x00400000,
+	0x0640d323, 0x09008923, 0x058088e3, 0x07c03aa4, 0x07c03ae3,
+	0x06410d23, 0x09010923, 0x07c038a4, 0x09210923, 0x07c038e4,
+	0x0800c000, 0x08002515, 0x08002608, 0x0800271a, 0x06bfbb80,
+	0x06ffbfc0, 0x06070500, 0x06070600, 0x06070700, 0x06803fc0,
+	0x07c00140, 0x07c007c0, 0x07c01740, 0x0640d000, 0x07c036c0,
+	0x0640d200, 0x07c03640, 0x0640c108, 0x06035108, 0x06800408,
+	0x06035208, 0x06a04008, 0x06035008, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008,
+	0x00000000, 0x06800067, 0x0c039dc0, 0x0640d328, 0x0c038080,
+	0x00000000, 0x0cc00000, 0x00000000, 0x06bfff88, 0x06030408,
+	0x00400000, 0x0640c008, 0x0a618c08, 0x00000000, 0x0c031580,
+	0x00000000, 0x0c7a0f40, 0x0800c0ff, 0x0aa0c048, 0x0c782040,
+	0x00000000, 0x06410c08, 0x08010e90, 0x09326208, 0x0aa0c808,
+	0x0c7a0d00, 0x0800c0fe, 0x07803688, 0x09808008, 0x07c03688,
+	0x06410c08, 0x08010e90, 0x09384288, 0x09223248, 0x07c00189,
+	0x09201248, 0x07c001c9, 0x08010e90, 0x07800148, 0x0a805288,
+	0x07c0010a, 0x0aa0ffc8, 0x0c029080, 0x05407308, 0x0780010a,
+	0x07c0014a, 0x06410c08, 0x08010e88, 0x09305248, 0x07c00209,
+	0x06410c08, 0x08010e90, 0x09210248, 0x07c00249, 0x06410c08,
+	0x08010e90, 0x09210248, 0x07c00289, 0x06410c08, 0x08010e84,
+	0x09384248, 0x07c04f49, 0x08010e90, 0x08010e90, 0x08010e8c,
+	0x06410c08, 0x08010e88, 0x09308248, 0x07c002c9, 0x0780018b,
+	0x0aa6400b, 0x00000000, 0x06410c0a, 0x08010e90, 0x0aa5400b,
+	0x093e124a, 0x0aa30009, 0x06410c08, 0x08010e88, 0x06410c08,
+	0x08010e90, 0x06410c08, 0x08010e90, 0x06410c08, 0x08010e84,
+	0x08010e90, 0x08010e90, 0x08010e8c, 0x093c124a, 0x0aa0c009,
+	0x06410c08, 0x08010e88, 0x0540228a, 0x0c7ffb40, 0x044012cb,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0780018b, 0x0a60c009,
+	0x0680000a, 0x0780018a, 0x0ac0a2ca, 0x00000000, 0x0c01fa40,
+	0x06800309, 0x0c01f9c0, 0x06800409, 0x0c01f940, 0x06800509,
+	0x0c7ffe00, 0x0400128a, 0x08010e86, 0x06806008, 0x06010e08,
+	0x06410f08, 0x0befc0c8, 0x09118208, 0x0aa18008, 0x00000000,
+	0x06801c27, 0x0c038000, 0x04000a09, 0x0c780000, 0x06410c08,
 	0x08010e81, 0x093e1248, 0x0aa38009, 0x08010e90, 0x08010e90,
 	0x08010e90, 0x08010e90, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x0aa0c009, 0x0c01e780, 0x06800049, 0x0c01e700, 0x06800049,
-	0x0aa04008, 0x08010e81, 0x07800148, 0x0aa0ffc8, 0x0c026480,
-	0x05407308, 0x0c79e400, 0x0800c0ff, 0x0aa0c088, 0x0c78c3c0,
+	0x0aa0c009, 0x0c01f240, 0x06800049, 0x0c01f1c0, 0x06800049,
+	0x0aa04008, 0x08010e81, 0x07800148, 0x0aa0ffc8, 0x0c027700,
+	0x05407308, 0x0c79eec0, 0x0800c0ff, 0x0aa0c088, 0x0c78c3c0,
 	0x00000000, 0x06410c08, 0x08010e90, 0x09326208, 0x0aa0c848,
-	0x0c79e1c0, 0x0800c0fe, 0x07803688, 0x09808048, 0x07c03688,
+	0x0c79ec80, 0x0800c0fe, 0x07803688, 0x09808048, 0x07c03688,
 	0x06410c08, 0x08010e88, 0x09384288, 0x07c0060a, 0x09323248,
 	0x07c00649, 0x09301248, 0x07c00689, 0x07800148, 0x0a808288,
-	0x07c0010a, 0x0c025dc0, 0x05407308, 0x0780010a, 0x07c0014a,
-	0x0c026940, 0x0540730a, 0x06410c08, 0x08010e88, 0x09305248,
+	0x07c0010a, 0x0c027040, 0x05407308, 0x0780010a, 0x07c0014a,
+	0x0c027bc0, 0x0540730a, 0x06410c08, 0x08010e88, 0x09305248,
 	0x07c006c9, 0x06410c08, 0x08010e90, 0x09210248, 0x07c00709,
 	0x06410c08, 0x08010e90, 0x09210248, 0x07c00749, 0x06410c08,
 	0x08010e84, 0x08010e90, 0x08010e90, 0x08010e8c, 0x06410c08,
@@ -78,65 +83,65 @@ const u32  vh265_mc[] __initconst = {
 	0x0aa30009, 0x06410c08, 0x08010e88, 0x06410c08, 0x08010e90,
 	0x06410c08, 0x08010e90, 0x06410c08, 0x08010e84, 0x08010e90,
 	0x08010e90, 0x08010e8c, 0x093c124a, 0x0aa0c009, 0x06410c08,
-	0x08010e88, 0x0540228a, 0x0c7ffb40, 0x044012cb, 0x0c01d180,
+	0x08010e88, 0x0540228a, 0x0c7ffb40, 0x044012cb, 0x0c01dc40,
 	0x06800049, 0x078007c9, 0x0a805209, 0x07c00108, 0x0aa0ffc9,
-	0x0c025540, 0x05407309, 0x07800108, 0x07c007c8, 0x0c01cf00,
-	0x06800809, 0x0c01ce80, 0x06800849, 0x0c01ce00, 0x06800889,
+	0x0c0267c0, 0x05407309, 0x07800108, 0x07c007c8, 0x0c01d9c0,
+	0x06800809, 0x0c01d940, 0x06800849, 0x0c01d8c0, 0x06800889,
 	0x07800848, 0x07800889, 0x09610209, 0x06412309, 0x0a805209,
 	0x06460309, 0x093e1249, 0x0a6f8009, 0x00000000, 0x06012308,
 	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa28009, 0x07c01609,
-	0x0c01c9c0, 0x06801649, 0x0c01c940, 0x06801689, 0x0c01c8c0,
-	0x068016c9, 0x0c01c840, 0x06801709, 0x0c01c7c0, 0x068008c9,
-	0x0c01c740, 0x06800909, 0x0c01c6c0, 0x06800949, 0x06410c08,
+	0x0c01d480, 0x06801649, 0x0c01d400, 0x06801689, 0x0c01d380,
+	0x068016c9, 0x0c01d300, 0x06801709, 0x0c01d280, 0x068008c9,
+	0x0c01d200, 0x06800909, 0x0c01d180, 0x06800949, 0x06410c08,
 	0x08010e81, 0x093e1248, 0x0780064b, 0x0a60c009, 0x0680000a,
-	0x0780064a, 0x0ac0a2ca, 0x00000000, 0x0c01c400, 0x06800989,
-	0x0c01c380, 0x06800a89, 0x0c01c300, 0x06800b89, 0x0c7ffe00,
-	0x0400128a, 0x0c01c200, 0x06800c89, 0x07800c89, 0x07c00d09,
-	0x0c01c100, 0x06800cc9, 0x07800c89, 0x07800cc8, 0x02009209,
+	0x0780064a, 0x0ac0a2ca, 0x00000000, 0x0c01cec0, 0x06800989,
+	0x0c01ce40, 0x06800a89, 0x0c01cdc0, 0x06800b89, 0x0c7ffe00,
+	0x0400128a, 0x0c01ccc0, 0x06800c89, 0x07800c89, 0x07c00d09,
+	0x0c01cbc0, 0x06800cc9, 0x07800c89, 0x07800cc8, 0x02009209,
 	0x07c00d49, 0x07800d48, 0x0a6300c8, 0x07800849, 0x0403f249,
 	0x05806249, 0x07c00e09, 0x07800889, 0x0403f249, 0x05806249,
-	0x07c00e49, 0x08040640, 0x0c780900, 0x068253a0, 0x0a630088,
+	0x07c00e49, 0x08040640, 0x0c780900, 0x06826760, 0x0a630088,
 	0x07800849, 0x0401f249, 0x05805249, 0x07c00e09, 0x07800889,
 	0x0401f249, 0x05805249, 0x07c00e49, 0x08040620, 0x0c780600,
-	0x06825920, 0x0a630048, 0x07800849, 0x0400f249, 0x05804249,
+	0x06826ce0, 0x0a630048, 0x07800849, 0x0400f249, 0x05804249,
 	0x07c00e09, 0x07800889, 0x0400f249, 0x05804249, 0x07c00e49,
-	0x08040610, 0x0c780300, 0x06826160, 0x07800849, 0x04007249,
+	0x08040610, 0x0c780300, 0x06827520, 0x07800849, 0x04007249,
 	0x05803249, 0x07c00e09, 0x07800889, 0x04007249, 0x05803249,
-	0x07c00e49, 0x08040608, 0x06826ca0, 0x07800e08, 0x07800e49,
+	0x07c00e49, 0x08040608, 0x06828060, 0x07800e08, 0x07800e49,
 	0x0e000248, 0x00000000, 0x00000000, 0x06800009, 0x0f000200,
 	0x04401208, 0x0aa10008, 0x05801208, 0x0c7fff80, 0x04001249,
 	0x07c01449, 0x06460309, 0x093e1249, 0x0a6f8009, 0x00000000,
 	0x07800849, 0x0780088a, 0x0960f24a, 0x06040209, 0x07800e09,
-	0x07800e4a, 0x0960c24a, 0x06040309, 0x08040400, 0x0c01ad40,
-	0x06800049, 0x07800049, 0x07c00d89, 0x0c01ac40, 0x06800089,
-	0x07800049, 0x07800088, 0x02009209, 0x07c00dc9, 0x0c01aac0,
-	0x06800ec9, 0x0c01aa40, 0x06800f09, 0x06410c08, 0x08010e81,
+	0x07800e4a, 0x0960c24a, 0x06040309, 0x08040400, 0x0c01b800,
+	0x06800049, 0x07800049, 0x07c00d89, 0x0c01b700, 0x06800089,
+	0x07800049, 0x07800088, 0x02009209, 0x07c00dc9, 0x0c01b580,
+	0x06800ec9, 0x0c01b500, 0x06800f09, 0x06410c08, 0x08010e81,
 	0x093e1248, 0x0aa38009, 0x07c00f49, 0x06410c08, 0x08010e81,
 	0x093e1248, 0x0aa0c009, 0x0c001a80, 0x00000000, 0x078007c8,
-	0x0aa0c008, 0x068f000c, 0x069f000c, 0x0c024540, 0x00000000,
+	0x0aa0c008, 0x068f000c, 0x069f000c, 0x0c0257c0, 0x00000000,
 	0x06410c08, 0x08010e83, 0x093e1248, 0x07c00f89, 0x093c1248,
 	0x07c00fc9, 0x093a1248, 0x0aa58009, 0x06800009, 0x06410c08,
 	0x08010e88, 0x09384248, 0x04001249, 0x07c01049, 0x09304248,
-	0x04001249, 0x07c01089, 0x0c01a140, 0x068010c9, 0x0c01a0c0,
+	0x04001249, 0x07c01089, 0x0c01ac00, 0x068010c9, 0x0c01ab80,
 	0x06801109, 0x078010c9, 0x02008248, 0x07c01108, 0x06410c08,
 	0x08010e81, 0x093e1248, 0x07c01149, 0x06800049, 0x07c01009,
-	0x0c019e00, 0x06801189, 0x0680000e, 0x0780118f, 0x044013cf,
+	0x0c01a8c0, 0x06801189, 0x0680000e, 0x0780118f, 0x044013cf,
 	0x0aa1000f, 0x058013cf, 0x0c7fff80, 0x0400138e, 0x07c011ce,
 	0x0780118f, 0x0680000e, 0x0b4143ce, 0x00000000, 0x0480f20e,
 	0x05404208, 0x0680800d, 0x0200d20d, 0x0c002940, 0x00000000,
 	0x0480f20e, 0x0aa1c3c8, 0x00000000, 0x0400120e, 0x0b4043c8,
 	0x00000000, 0x0c780100, 0x00000000, 0x0c0049c0, 0x00000000,
 	0x0c7ffb80, 0x0400138e, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x07c01209, 0x0aa28009, 0x0c0194c0, 0x06801249, 0x0aa1c008,
+	0x07c01209, 0x0aa28009, 0x0c019f80, 0x06801249, 0x0aa1c008,
 	0x06410c08, 0x08010e89, 0x09308248, 0x092e1248, 0x0c7ffec0,
 	0x04401208, 0x06410c08, 0x08010e83, 0x093e1248, 0x07c01289,
 	0x093c1248, 0x07c012c9, 0x093a1248, 0x06800008, 0x07c014c8,
 	0x07c01508, 0x07c01548, 0x07c01588, 0x0aa0c009, 0x0c004b80,
-	0x00000000, 0x08010e81, 0x078007c8, 0x0aa0ffc8, 0x0c021340,
-	0x05407308, 0x0c798c80, 0x0800c0ff, 0x068c8408, 0x06c41508,
+	0x00000000, 0x08010e81, 0x078007c8, 0x0aa0ffc8, 0x0c0225c0,
+	0x05407308, 0x0c799740, 0x0800c0ff, 0x068c8408, 0x06c41508,
 	0x06070508, 0x06070608, 0x06070708, 0x0680000b, 0x0680000a,
 	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa08009, 0x0c780f00,
-	0x0c018a00, 0x06800049, 0x0aa140cb, 0x0400e3ca, 0x0ba0c0ca,
+	0x0c0194c0, 0x06800049, 0x0aa140cb, 0x0400e3ca, 0x0ba0c0ca,
 	0x0680038f, 0x068003cf, 0x0a60c00b, 0x0c780180, 0x0647050d,
 	0x0a60c04b, 0x0c7800c0, 0x0647060d, 0x0647070d, 0x0aa38008,
 	0x0400038f, 0x0aa300cb, 0x0680000e, 0x0240f20a, 0x0aa2410f,
@@ -148,20 +153,20 @@ const u32  vh265_mc[] __initconst = {
 	0x0948434e, 0x0c780140, 0x0950434e, 0x0c7800c0, 0x0958434e,
 	0x0960434e, 0x0aa1000b, 0x0aa1404b, 0x0c7809c0, 0x0607070d,
 	0x0c780940, 0x0607050d, 0x0c7808c0, 0x0607060d, 0x0ba2c08b,
-	0x0680020c, 0x0c017c80, 0x06800049, 0x04008308, 0x0aa0c08b,
+	0x0680020c, 0x0c018740, 0x06800049, 0x04008308, 0x0aa0c08b,
 	0x0680f808, 0x0680f988, 0x02008288, 0x06070208, 0x0607040c,
 	0x0aa1c00b, 0x0680e008, 0x0aa1404b, 0x06800008, 0x0aa0c08b,
 	0x06806008, 0x0680c008, 0x0680040e, 0x0aa1000b, 0x0540424a,
 	0x0680100e, 0x0540624a, 0x02008248, 0x06070208, 0x0680004d,
-	0x0c017680, 0x06800049, 0x0200c20c, 0x048ff30c, 0x0607040c,
+	0x0c018140, 0x06800049, 0x0200c20c, 0x048ff30c, 0x0607040c,
 	0x0b8fb38d, 0x0400134d, 0x0ba0c0cb, 0x06800149, 0x06800049,
 	0x0b40324a, 0x0c7fe6c0, 0x0400128a, 0x0b60c0cb, 0x0c7fe5c0,
 	0x040012cb, 0x0cc00000, 0x00000000, 0x0aa1400e, 0x06800009,
 	0x06410c08, 0x08010e81, 0x093e1248, 0x0a608009, 0x0c781540,
-	0x07801189, 0x0a40624e, 0x0440144e, 0x0c016dc0, 0x06800049,
+	0x07801189, 0x0a40624e, 0x0440144e, 0x0c017880, 0x06800049,
 	0x0c002500, 0x02411211, 0x0480f451, 0x05404451, 0x06808008,
 	0x02011211, 0x06800010, 0x06800012, 0x06410c08, 0x08010e81,
-	0x093e1288, 0x0c016a80, 0x06800049, 0x0aa1000a, 0x040014c8,
+	0x093e1288, 0x0c017540, 0x06800049, 0x0aa1000a, 0x040014c8,
 	0x06800009, 0x024134c9, 0x0b60c412, 0x06a0000b, 0x0700044b,
 	0x04001451, 0x04001492, 0x0200c2d3, 0x091e12cb, 0x0900e30c,
 	0x06410c08, 0x08010e81, 0x093e1288, 0x095c130a, 0x0a62000a,
@@ -174,13 +179,13 @@ const u32  vh265_mc[] __initconst = {
 	0x0900e451, 0x091a12d1, 0x06900013, 0x0aa0c00b, 0x0200b453,
 	0x0240b453, 0x0b4072d2, 0x0241130d, 0x0400048b, 0x0700044b,
 	0x07000353, 0x0740034b, 0x07400453, 0x0c7ffc00, 0x0400130c,
-	0x0c7ff8c0, 0x04401410, 0x0cc00000, 0x00000000, 0x0c015980,
-	0x06800049, 0x0c015900, 0x06800089, 0x06800010, 0x0680000a,
-	0x0680000b, 0x0780004c, 0x0b41130b, 0x0c015740, 0x068000c9,
+	0x0c7ff8c0, 0x04401410, 0x0cc00000, 0x00000000, 0x0c016440,
+	0x06800049, 0x0c0163c0, 0x06800089, 0x06800010, 0x0680000a,
+	0x0680000b, 0x0780004c, 0x0b41130b, 0x0c016200, 0x068000c9,
 	0x0240a20a, 0x0440128a, 0x06410c08, 0x08010e81, 0x093e1248,
 	0x0900e20a, 0x095c1209, 0x07400348, 0x0400134d, 0x04001410,
 	0x0bacc410, 0x040012cb, 0x0cc00000, 0x00000000, 0x0680000a,
-	0x0680000b, 0x0780008c, 0x0b41130b, 0x0c015240, 0x068000c9,
+	0x0680000b, 0x0780008c, 0x0b41130b, 0x0c015d00, 0x068000c9,
 	0x0200a20a, 0x0400128a, 0x06410c08, 0x08010e81, 0x093e1248,
 	0x0900e20a, 0x095c1209, 0x07400348, 0x0400134d, 0x04001410,
 	0x0bacc410, 0x040012cb, 0x0cc00000, 0x00000000, 0x06a00008,
@@ -200,18 +205,18 @@ const u32  vh265_mc[] __initconst = {
 	0x093e1248, 0x0aa34009, 0x0924e248, 0x07c04fc9, 0x09050248,
 	0x07c05989, 0x06410c08, 0x08010e85, 0x09361248, 0x0aa14009,
 	0x00000000, 0x08010e88, 0x00000000, 0x08010e90, 0x06410c08,
-	0x08010e81, 0x093e1248, 0x0aa14009, 0x0c013940, 0x06800089,
-	0x0c0138c0, 0x06800089, 0x06410c08, 0x08010e84, 0x093e1248,
+	0x08010e81, 0x093e1248, 0x0aa14009, 0x0c014400, 0x06800089,
+	0x0c014380, 0x06800089, 0x06410c08, 0x08010e84, 0x093e1248,
 	0x093c1248, 0x093a1248, 0x07c015c9, 0x09381248, 0x0aa38009,
 	0x06410c08, 0x09118208, 0x0a60c008, 0x0cc00000, 0x00000000,
-	0x0c013500, 0x06801349, 0x0c013480, 0x06801389, 0x0c013400,
-	0x068013c9, 0x0c013380, 0x06801409, 0x06410c08, 0x08010e81,
+	0x0c013fc0, 0x06801349, 0x0c013f40, 0x06801389, 0x0c013ec0,
+	0x068013c9, 0x0c013e40, 0x06801409, 0x06410c08, 0x08010e81,
 	0x093e1248, 0x0aa10009, 0x06410c08, 0x09018208, 0x0a608008,
 	0x0c7807c0, 0x06410c08, 0x08010e90, 0x09210248, 0x07c014c9,
 	0x06410c08, 0x08010e90, 0x09210248, 0x07c01509, 0x06410c08,
 	0x08010e90, 0x09210248, 0x07c01549, 0x06410c08, 0x08010e90,
 	0x09210248, 0x07c01589, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x0aa10009, 0x0c012c00, 0x06800049, 0x04001208, 0x06410c08,
+	0x0aa10009, 0x0c0136c0, 0x06800049, 0x04001208, 0x06410c08,
 	0x08010e81, 0x093e1248, 0x0aa10009, 0x0680004a, 0x0c000100,
 	0x0780064b, 0x0cc00000, 0x00000000, 0x0a60c00a, 0x0c7807c0,
 	0x00000000, 0x06410c08, 0x08010e82, 0x093c2248, 0x0aaec009,
@@ -221,571 +226,578 @@ const u32  vh265_mc[] __initconst = {
 	0x09304248, 0x0aa1000c, 0x06410c08, 0x08010e84, 0x09384248,
 	0x06410c08, 0x08010e8f, 0x09365248, 0x092c5248, 0x09225248,
 	0x0cc00000, 0x00000000, 0x0aa0c0c8, 0x0c783240, 0x00000000,
-	0x06410c08, 0x08010e90, 0x09326208, 0x0aa0c888, 0x0c791dc0,
-	0x0800c0fe, 0x07803688, 0x09808088, 0x07c03688, 0x0c011d80,
+	0x06410c08, 0x08010e90, 0x09326208, 0x0aa0c888, 0x0c792880,
+	0x0800c0fe, 0x07803688, 0x09808088, 0x07c03688, 0x0c012840,
 	0x06800049, 0x07801749, 0x0a805209, 0x07c00108, 0x0aa0ffc9,
-	0x0c01b200, 0x05407309, 0x07800108, 0x07c01748, 0x0c011b00,
+	0x0c01c480, 0x05407309, 0x07800108, 0x07c01748, 0x0c0125c0,
 	0x06801789, 0x078007ca, 0x0a806288, 0x07c00108, 0x0780010a,
-	0x07c007ca, 0x0c01aa00, 0x0540730a, 0x0780060a, 0x07800148,
-	0x0a804288, 0x07c0014a, 0x0c01a340, 0x0540730a, 0x06410c08,
+	0x07c007ca, 0x0c01bc80, 0x0540730a, 0x0780060a, 0x07800148,
+	0x0a804288, 0x07c0014a, 0x0c01b5c0, 0x0540730a, 0x06410c08,
 	0x08010e87, 0x093e1248, 0x07c017c9, 0x093c1248, 0x07c01809,
 	0x09363248, 0x07c01849, 0x09341248, 0x07c01889, 0x09321248,
-	0x07c018c9, 0x0c011440, 0x06801909, 0x04001208, 0x07c01908,
-	0x0c011340, 0x06801949, 0x04001208, 0x07c01948, 0x0c011400,
+	0x07c018c9, 0x0c011f00, 0x06801909, 0x04001208, 0x07c01908,
+	0x0c011e00, 0x06801949, 0x04001208, 0x07c01948, 0x0c011ec0,
 	0x06801989, 0x0401a208, 0x07c01988, 0x06410c08, 0x08010e83,
 	0x093e1248, 0x07c019c9, 0x093c1248, 0x07c01a09, 0x093a1248,
-	0x07c01a49, 0x0aa10009, 0x06800008, 0x0c010ec0, 0x06801a89,
-	0x07c01a88, 0x0c010fc0, 0x06801ac9, 0x0c010f40, 0x06801b09,
+	0x07c01a49, 0x0aa10009, 0x06800008, 0x0c011980, 0x06801a89,
+	0x07c01a88, 0x0c011a80, 0x06801ac9, 0x0c011a00, 0x06801b09,
 	0x06410c08, 0x08010e86, 0x093e1248, 0x07c01b49, 0x093c1248,
 	0x07c01b89, 0x093a1248, 0x07c01bc9, 0x09381248, 0x07c01c09,
 	0x09361248, 0x07c01c49, 0x09341248, 0x07c01fc9, 0x0aa0c009,
-	0x0c015f80, 0x00000000, 0x06800048, 0x07c01f88, 0x07801c89,
+	0x0c017200, 0x00000000, 0x06800048, 0x07c01f88, 0x07801c89,
 	0x07801c48, 0x02c09209, 0x07c01c89, 0x0a608008, 0x0c780a80,
-	0x0c0106c0, 0x06801d09, 0x07800e08, 0x07c01d88, 0x0c0105c0,
+	0x0c011180, 0x06801d09, 0x07800e08, 0x07c01d88, 0x0c011080,
 	0x06801d49, 0x07800e48, 0x07c01e88, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x07c01cc9, 0x0aa14009, 0x0c016200, 0x00000000,
+	0x093e1248, 0x07c01cc9, 0x0aa14009, 0x0c017480, 0x00000000,
 	0x0c780580, 0x00000000, 0x07801d0b, 0x0ae0010b, 0x0680000a,
-	0x0b4072ca, 0x0c010180, 0x0407624a, 0x04001208, 0x07400248,
+	0x0b4072ca, 0x0c010c40, 0x0407624a, 0x04001208, 0x07400248,
 	0x0c7ffec0, 0x0400128a, 0x07801d4b, 0x0ae0010b, 0x0680000a,
-	0x0b4072ca, 0x0c00ff00, 0x0407a24a, 0x04001208, 0x07400248,
+	0x0b4072ca, 0x0c0109c0, 0x0407a24a, 0x04001208, 0x07400248,
 	0x0c7ffec0, 0x0400128a, 0x06410c08, 0x08010e81, 0x093e1248,
 	0x07c01f89, 0x06410c08, 0x08010e82, 0x093e1248, 0x07c02009,
 	0x093c1248, 0x0a618009, 0x07c02049, 0x07c02089, 0x07c020c9,
 	0x0c780340, 0x07c02109, 0x06410c08, 0x08010e82, 0x093e1248,
-	0x07c02049, 0x093c1248, 0x0a618009, 0x07c02089, 0x0c00f9c0,
-	0x068020c9, 0x0c00f940, 0x06802109, 0x06410c08, 0x08010e81,
+	0x07c02049, 0x093c1248, 0x0a618009, 0x07c02089, 0x0c010480,
+	0x068020c9, 0x0c010400, 0x06802109, 0x06410c08, 0x08010e81,
 	0x093e1248, 0x0a628009, 0x07800f48, 0x0aa28008, 0x07801788,
-	0x0aa0c008, 0x068f000c, 0x069f000c, 0x0c01a740, 0x00000000,
+	0x0aa0c008, 0x068f000c, 0x069f000c, 0x0c01b9c0, 0x00000000,
 	0x0c7800c0, 0x0c0766c0, 0x00000000, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x07c02149, 0x0c00f240, 0x06802189, 0x04002208,
+	0x093e1248, 0x07c02149, 0x0c00fd00, 0x06802189, 0x04002208,
 	0x07c02188, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c021c9,
-	0x08010e81, 0x0c01ad80, 0x00000000, 0x07801748, 0x0aa0ffc8,
-	0x0c018500, 0x05407308, 0x0c78ed80, 0x0800c0ff, 0x0680400d,
-	0x0aa0c1c8, 0x0c781000, 0x00000000, 0x08010e90, 0x06803fcb,
-	0x06800009, 0x06410c08, 0x08010e88, 0x09308208, 0x02009209,
-	0x0a8fc2c8, 0x0680000a, 0x06410c08, 0x08010e88, 0x09308208,
-	0x0200a20a, 0x0a8fc2c8, 0x00000000, 0x06801027, 0x0c022580,
-	0x04000a09, 0x06801067, 0x0c0224c0, 0x04000a0a, 0x0440134d,
-	0x0aa0800d, 0x0a60800a, 0x0c780900, 0x0aa54049, 0x0aa2e249,
-	0x00000000, 0x0aa9400a, 0x00000000, 0x06410c08, 0x08010e88,
-	0x06801127, 0x0c022140, 0x04000a08, 0x0c7ffe40, 0x0440128a,
-	0x0961024a, 0x0600d309, 0x0800c00c, 0x08007401, 0x0640c00a,
-	0x0a6fc34a, 0x00000000, 0x0c780400, 0x00000000, 0x078015c9,
-	0x0a22c049, 0x00000000, 0x06410c08, 0x08010e87, 0x09327208,
-	0x07c04f88, 0x068010a7, 0x0c021c00, 0x04000a08, 0x08010e81,
-	0x0440128a, 0x0c7ff880, 0x00000000, 0x0c78dd00, 0x0800c0ff,
-	0x0aa0c108, 0x0c787640, 0x00000000, 0x0c0224c0, 0x069fffa9,
-	0x06410c08, 0x08010e90, 0x09326208, 0x0b210548, 0x07c02208,
-	0x0c78da00, 0x0800c0fe, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x07c02249, 0x07802208, 0x0ba1c408, 0x06800009, 0x0ae14548,
-	0x06800009, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c02289,
-	0x0c00d740, 0x06800049, 0x07801749, 0x0a812248, 0x07c00108,
-	0x0a633fc9, 0x00000000, 0x0c016100, 0x0680000c, 0x0c0165c0,
-	0x0680000c, 0x0c018740, 0x00000000, 0x0680000c, 0x07c00e8c,
-	0x0c022140, 0x00000000, 0x07800108, 0x07c01748, 0x0c017c80,
-	0x05407308, 0x07801788, 0x078007c9, 0x0a806248, 0x07c00108,
-	0x07800109, 0x07c007c9, 0x0c016140, 0x05407309, 0x0780060a,
-	0x07800148, 0x0a804288, 0x07c0014a, 0x0c015a80, 0x0540730a,
-	0x07802248, 0x06800009, 0x0aa10008, 0x07c02309, 0x0c780440,
-	0x07c022c9, 0x078017c8, 0x0aa14008, 0x06800009, 0x06410c08,
-	0x08010e81, 0x093e1248, 0x07c02309, 0x07801449, 0x06410c08,
+	0x08010e81, 0x0c01c000, 0x00000000, 0x07801748, 0x0aa0ffc8,
+	0x0c019780, 0x05407308, 0x0c78f840, 0x0800c0ff, 0x0680040d,
+	0x0aa0c1c8, 0x0c781380, 0x00000000, 0x0640d20e, 0x0581338e,
+	0x0a21804e, 0x00000000, 0x0c026b00, 0x0680008e, 0x0c78f540,
+	0x0800c0ff, 0x08010e90, 0x06803fcb, 0x06800009, 0x06410c08,
+	0x08010e88, 0x09308208, 0x02009209, 0x0a8fc2c8, 0x0680000a,
+	0x06410c08, 0x08010e88, 0x09308208, 0x0200a20a, 0x0a8fc2c8,
+	0x00000000, 0x06801027, 0x0c027bc0, 0x04000a09, 0x06801067,
+	0x0c027b00, 0x04000a0a, 0x0440134d, 0x0aa0800d, 0x0a60800a,
+	0x0c780a80, 0x0aa6c049, 0x0aa46249, 0x00000000, 0x06800009,
+	0x0aa9000a, 0x00000000, 0x06410c08, 0x08010e88, 0x06801127,
+	0x0c027740, 0x04000a08, 0x0a81e248, 0x04000248, 0x05808208,
+	0x0aa6c008, 0x0aa68048, 0x0c7ffd00, 0x0440128a, 0x0961024a,
+	0x0600d309, 0x0800c00c, 0x08007401, 0x0640c00a, 0x0a6fc34a,
+	0x00000000, 0x0c7ff3c0, 0x00000000, 0x078015c9, 0x0a22c049,
+	0x00000000, 0x06410c08, 0x08010e87, 0x09327208, 0x07c04f88,
+	0x068010a7, 0x0c0270c0, 0x04000a08, 0x08010e81, 0x0440128a,
+	0x0c7ff740, 0x00000000, 0x0c78e440, 0x0800c0ff, 0x0aa0d088,
+	0x0c780380, 0x00000000, 0x07803a89, 0x0aa1c0c9, 0x0aa18109,
+	0x00000000, 0x0c025b00, 0x068000ce, 0x0c780100, 0x00000000,
+	0x0c025640, 0x068000ce, 0x0c78e080, 0x0800c0ff, 0x0aa0d048,
+	0x0c780180, 0x00000000, 0x0c025480, 0x0680004e, 0x0c78dec0,
+	0x0800c0ff, 0x0aa0c108, 0x0c787800, 0x00000000, 0x0c027400,
+	0x069fffa9, 0x06410c08, 0x08010e90, 0x09326208, 0x0b210548,
+	0x07c02208, 0x0c78dbc0, 0x0800c0fe, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x07c02249, 0x07802208, 0x0ba1c408, 0x06800009,
+	0x0ae14548, 0x06800009, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x07c02289, 0x0c00d900, 0x06800049, 0x07801749, 0x0a818248,
+	0x07c00108, 0x0a64bfc9, 0x00000000, 0x0c016a80, 0x0680000c,
+	0x0c016f40, 0x0680000c, 0x0c0190c0, 0x00000000, 0x0680000c,
+	0x07c00e8c, 0x0c027080, 0x00000000, 0x0640d70c, 0x0aa1400c,
+	0x06803fcc, 0x07c0148c, 0x0c0780c0, 0x06800011, 0x07800108,
+	0x07c01748, 0x0c018480, 0x05407308, 0x07801788, 0x078007c9,
+	0x0a806248, 0x07c00108, 0x07800109, 0x07c007c9, 0x0c016940,
+	0x05407309, 0x0780060a, 0x07800148, 0x0a804288, 0x07c0014a,
+	0x0c016280, 0x0540730a, 0x07802248, 0x06800009, 0x0aa10008,
+	0x07c02309, 0x0c780440, 0x07c022c9, 0x078017c8, 0x0aa14008,
+	0x06800009, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c02309,
+	0x07801449, 0x06410c08, 0x0680080a, 0x0240a24a, 0x098091c9,
+	0x06010e09, 0x03808288, 0x07c022c8, 0x07802308, 0x0aa0c008,
+	0x0c784d00, 0x00000000, 0x0c01d800, 0x00000000, 0x07801848,
+	0x0aa0c008, 0x098081c8, 0x06010e08, 0x0c00c700, 0x06802349,
+	0x07801808, 0x0aa14008, 0x06800049, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x07c02389, 0x07802209, 0x0aa084c9, 0x0a610509,
+	0x06800008, 0x0c7818c0, 0x07c023c8, 0x06410c08, 0x07800949,
+	0x04004249, 0x0680080a, 0x0240a24a, 0x098091c9, 0x06010e09,
+	0x03808288, 0x07c023c8, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0a614009, 0x0680400d, 0x0c0744c0, 0x0780118e, 0x0c780600,
+	0x078011c9, 0x06410c08, 0x068007ca, 0x0240a24a, 0x098091c9,
+	0x06010e09, 0x03808288, 0x05801208, 0x07c02408, 0x0c0769c0,
+	0x04000448, 0x0480f211, 0x05404208, 0x06808009, 0x02009209,
+	0x0680400d, 0x06800008, 0x0700024a, 0x0740034a, 0x0400134d,
+	0x04001208, 0x0baf0408, 0x04001249, 0x07801208, 0x0a608008,
+	0x0c780b80, 0x0780124a, 0x0aa1400a, 0x0680000b, 0x0c00b7c0,
+	0x06800049, 0x040002c8, 0x0c00b700, 0x06800049, 0x0200c20b,
+	0x0a60800c, 0x0c7808c0, 0x0ac0f2cc, 0x07801248, 0x0ba60048,
+	0x07801248, 0x0b21c088, 0x06802049, 0x0b214108, 0x06802089,
+	0x0b20c208, 0x068020c9, 0x06802109, 0x06410c08, 0x06010e09,
+	0x0c780340, 0x00000000, 0x06410c08, 0x07800949, 0x04004249,
 	0x0680080a, 0x0240a24a, 0x098091c9, 0x06010e09, 0x03808288,
-	0x07c022c8, 0x07802308, 0x0aa0c008, 0x0c784d00, 0x00000000,
-	0x0c01cbc0, 0x00000000, 0x07801848, 0x0aa0c008, 0x098081c8,
-	0x06010e08, 0x0c00c6c0, 0x06802349, 0x07801808, 0x0aa14008,
-	0x06800049, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c02389,
-	0x07802209, 0x0aa084c9, 0x0a610509, 0x06800008, 0x0c7818c0,
-	0x07c023c8, 0x06410c08, 0x07800949, 0x04004249, 0x0680080a,
-	0x0240a24a, 0x098091c9, 0x06010e09, 0x03808288, 0x07c023c8,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0a614009, 0x0680400d,
-	0x0c074f40, 0x0780118e, 0x0c780600, 0x078011c9, 0x06410c08,
-	0x068007ca, 0x0240a24a, 0x098091c9, 0x06010e09, 0x03808288,
-	0x05801208, 0x07c02408, 0x0c077440, 0x04000448, 0x0480f211,
-	0x05404208, 0x06808009, 0x02009209, 0x0680400d, 0x06800008,
-	0x0700024a, 0x0740034a, 0x0400134d, 0x04001208, 0x0baf0408,
-	0x04001249, 0x07801208, 0x0a608008, 0x0c780b80, 0x0780124a,
-	0x0aa1400a, 0x0680000b, 0x0c00b780, 0x06800049, 0x040002c8,
-	0x0c00b6c0, 0x06800049, 0x0200c20b, 0x0a60800c, 0x0c7808c0,
-	0x0ac0f2cc, 0x07801248, 0x0ba60048, 0x07801248, 0x0b21c088,
-	0x06802049, 0x0b214108, 0x06802089, 0x0b20c208, 0x068020c9,
-	0x06802109, 0x06410c08, 0x06010e09, 0x0c780340, 0x00000000,
-	0x06410c08, 0x07800949, 0x04004249, 0x0680080a, 0x0240a24a,
-	0x098091c9, 0x06010e09, 0x03808288, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa0c009,
-	0x0c00ae00, 0x06800049, 0x0c7ff780, 0x0440130c, 0x0c01a980,
-	0x00000000, 0x07801288, 0x0aa14008, 0x06800009, 0x06410c08,
-	0x08010e81, 0x093e1248, 0x07c02449, 0x07800fc8, 0x0a610008,
-	0x07c02488, 0x0c780200, 0x07c024c8, 0x06410c08, 0x08010e82,
-	0x093e1248, 0x07c02489, 0x093c1248, 0x07c024c9, 0x0780234b,
-	0x0a60c08b, 0x0c781700, 0x00000000, 0x0641170a, 0x06410c08,
-	0x08010e81, 0x093e1248, 0x0a628009, 0x07801909, 0x09546289,
-	0x07c02509, 0x0a60c00b, 0x06800009, 0x07801949, 0x09606289,
-	0x0c7803c0, 0x07c02549, 0x0c00a380, 0x06802509, 0x07802509,
-	0x04001249, 0x09546289, 0x07c02509, 0x0aa1c04b, 0x0c00a1c0,
-	0x06802549, 0x07802549, 0x04001249, 0x09606289, 0x07c02549,
-	0x0601170a, 0x06800009, 0x07c02c89, 0x07802149, 0x0aa14009,
-	0x07802c49, 0x0b20c049, 0x0c01a340, 0x00000000, 0x0a61400b,
-	0x06800009, 0x06410c08, 0x08010e81, 0x093e1248, 0x0641170a,
-	0x096c1289, 0x0601170a, 0x07c02589, 0x078018c9, 0x0aa14009,
-	0x06800009, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c025c9,
-	0x06411008, 0x09581209, 0x06011008, 0x07802449, 0x0aa48009,
-	0x0a61400b, 0x06800049, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x07c02609, 0x0aa1808b, 0x0aa0c009, 0x06802549, 0x06802509,
-	0x07000249, 0x0ae10049, 0x06800009, 0x0c780100, 0x07c02649,
-	0x0c009500, 0x06802649, 0x0aa0c04b, 0x07801b89, 0x07801bc9,
-	0x06047b09, 0x08047c00, 0x0aa10009, 0x08047d00, 0x0c007540,
-	0x00000000, 0x0c009240, 0x06802689, 0x06800149, 0x02409209,
-	0x06411708, 0x096e3209, 0x06011708, 0x0c009240, 0x068026c9,
-	0x07801988, 0x079026c9, 0x02008248, 0x07c02708, 0x07802349,
-	0x09446248, 0x078024c8, 0x09501248, 0x07802488, 0x09521248,
-	0x07800d08, 0x09542248, 0x07800d48, 0x09582248, 0x07800d88,
-	0x095c2248, 0x07800dc8, 0x09602248, 0x07801ac8, 0x09647248,
-	0x07801b08, 0x09727248, 0x06011109, 0x06411009, 0x09809389,
-	0x06011009, 0x07801b48, 0x0aa3c008, 0x0c008ac0, 0x06802749,
-	0x0c008a40, 0x06802789, 0x06411109, 0x07801ac8, 0x0780274a,
-	0x02008288, 0x09647248, 0x07801b08, 0x0780278a, 0x02008288,
-	0x09727248, 0x06011109, 0x07802048, 0x0aa14008, 0x06800009,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x07c027c9, 0x0a620009,
-	0x07802089, 0x07c02809, 0x078020c9, 0x07c02849, 0x07802109,
-	0x0c7802c0, 0x07c02889, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x0a618009, 0x07c02809, 0x0c008240, 0x06802849, 0x0c0081c0,
-	0x06802889, 0x07802008, 0x0aa34008, 0x06800009, 0x07802488,
-	0x0a61c008, 0x078024c8, 0x0a614008, 0x07802808, 0x0aa0c008,
-	0x0c780140, 0x06800009, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x07c028c9, 0x07801c48, 0x0a610008, 0x07801fc8, 0x0a608008,
-	0x0c780440, 0x0c007a80, 0x06802909, 0x0780290b, 0x0aa3400b,
-	0x0c007980, 0x06800049, 0x04001308, 0x0680080a, 0x0240a30a,
-	0x0980c1cc, 0x06410c08, 0x06010e0c, 0x03808288, 0x07c00048,
-	0x0aef004b, 0x044012cb, 0x078021c8, 0x0aa20008, 0x0c007600,
-	0x06800049, 0x0aa14008, 0x00000000, 0x08010e88, 0x0c7fff40,
-	0x04401208, 0x0c014580, 0x00000000, 0x0640ce09, 0x0a240089,
-	0x06460308, 0x093e1208, 0x0a6f8008, 0x00000000, 0x06420408,
-	0x09c08748, 0x06020408, 0x06460108, 0x0a216008, 0x00000000,
-	0x06460408, 0x0a2fc048, 0x00000000, 0x06460408, 0x06060408,
-	0x07802248, 0x0aa28008, 0x00000000, 0x06460408, 0x09808708,
-	0x06060408, 0x06400408, 0x09808508, 0x09808588, 0x06000408,
-	0x08000400, 0x0c01b4c0, 0x069fffe9, 0x0640d208, 0x0a240208,
-	0x07803688, 0x0be30208, 0x078022c9, 0x0a60c009, 0x07802349,
-	0x0aa20089, 0x0640d209, 0x0928c209, 0x04001208, 0x0968c248,
-	0x0600d209, 0x0c786800, 0x0800c0ff, 0x098080c8, 0x07c03688,
-	0x0800c008, 0x08007401, 0x0c786680, 0x00000000, 0x0aa0c148,
-	0x0c784800, 0x00000000, 0x0c01ae40, 0x069fff69, 0x08010e81,
-	0x06812008, 0x06010e08, 0x00000000, 0x08010e00, 0x07802308,
-	0x0a60c008, 0x06800008, 0x07c02948, 0x07802248, 0x0aa58008,
-	0x06800008, 0x07c02b88, 0x07c02bc8, 0x07c00e88, 0x07c02988,
-	0x07c029c8, 0x07c02a08, 0x07c02a48, 0x07801c49, 0x0aa0c009,
-	0x07800e08, 0x07801d88, 0x07c02a88, 0x07c02b08, 0x0aa0c009,
-	0x07800e48, 0x07801e88, 0x07c02ac8, 0x07c02b48, 0x0c780280,
-	0x068001df, 0x078022c8, 0x07800e89, 0x0a806248, 0x06800827,
-	0x0c019940, 0x078022e8, 0x0c785b40, 0x0800c0ff, 0x07802308,
-	0x0a61c008, 0x00000000, 0x068001df, 0x07802b89, 0x07802bc8,
-	0x09508248, 0x07c02d09, 0x07802b89, 0x0a614049, 0x07801fc9,
-	0x0aa0c009, 0x00000000, 0x0981f15f, 0x07802b89, 0x07802bc8,
-	0x0958c248, 0x0978425f, 0x06011609, 0x0c000300, 0x00000000,
-	0x07800e88, 0x09808788, 0x098087c8, 0x06012408, 0x0c019d80,
-	0x07800ea9, 0x06a00008, 0x06011408, 0x0c786b80, 0x00000000,
-	0x07802a89, 0x07c02cc9, 0x07802bc9, 0x07802a4a, 0x0a40b289,
-	0x0680000c, 0x07802b8b, 0x07802a0a, 0x0a40728b, 0x0680000c,
-	0x0a614009, 0x0680008c, 0x0a60c00a, 0x0680008c, 0x068000cc,
-	0x07802308, 0x09441308, 0x06460109, 0x094a324c, 0x06060109,
-	0x06420109, 0x0944324c, 0x07802348, 0x09402248, 0x07800d48,
-	0x04003208, 0x09604248, 0x07800d08, 0x04003208, 0x09684248,
-	0x06020109, 0x07801c88, 0x06424c09, 0x09809009, 0x0aa10008,
-	0x09809049, 0x09c09009, 0x09c09049, 0x06024c09, 0x06460109,
-	0x0aa0c008, 0x098097c9, 0x09c097c9, 0x06060109, 0x07800848,
-	0x07800889, 0x09610209, 0x06020508, 0x07802a08, 0x07802a49,
-	0x09610209, 0x06020708, 0x06060708, 0x07802b08, 0x07802b49,
-	0x09610209, 0x06020808, 0x06060808, 0x07800e08, 0x04401208,
-	0x07800e49, 0x04401249, 0x09610209, 0x06020608, 0x06800048,
-	0x0541f208, 0x06020408, 0x06450a08, 0x09005208, 0x0a6f8008,
-	0x06800008, 0x07801c49, 0x0a60c009, 0x06f00008, 0x06d00008,
-	0x06050a08, 0x06450108, 0x078008c9, 0x09602209, 0x07800909,
-	0x09642209, 0x06050108, 0x07802a08, 0x07802a49, 0x0960a209,
-	0x07801c49, 0x097e1209, 0x06050608, 0x07802b0a, 0x07802b49,
-	0x0960a289, 0x0605070a, 0x09c087c8, 0x07802b8a, 0x07802bc9,
-	0x0960a289, 0x0a40c288, 0x00000000, 0x098087c8, 0x07802a09,
-	0x07802a4a, 0x0960a24a, 0x0a618009, 0x00000000, 0x06450009,
-	0x09809009, 0x09809049, 0x06050009, 0x06050808, 0x07802bc9,
-	0x07802a4a, 0x0a404289, 0x07802b89, 0x07802a0a, 0x0a802289,
-	0x0c780740, 0x0640c908, 0x0e000248, 0x0640ca0a, 0x00000000,
-	0x0f000240, 0x0200a24a, 0x0606110a, 0x0606150a, 0x0606140a,
-	0x04020208, 0x07802bc9, 0x0e000248, 0x0640cc0a, 0x0640cb0c,
-	0x0f000340, 0x07802988, 0x0e000308, 0x0200b34a, 0x0402028b,
-	0x00000000, 0x0f000240, 0x0200a24a, 0x0606120a, 0x0606160a,
-	0x02409309, 0x0200b24b, 0x0606130b, 0x0606170b, 0x06460408,
-	0x06060408, 0x06800048, 0x0541f208, 0x06060408, 0x07801c48,
-	0x06040508, 0x07802b08, 0x07802b49, 0x09610209, 0x06040308,
-	0x07802a08, 0x07802a49, 0x09610209, 0x06040408, 0x07802308,
-	0x0a638008, 0x06804808, 0x06043008, 0x06443108, 0x0900a248,
-	0x0a6f0009, 0x091e5248, 0x0a6e8009, 0x00000000, 0x06440008,
-	0x09808008, 0x06040008, 0x09c08008, 0x06040008, 0x08040701,
-	0x07802308, 0x0aa4c008, 0x07802b88, 0x0a614008, 0x07801fc9,
-	0x0aa0c009, 0x0c0081c0, 0x00000000, 0x06411009, 0x091c1249,
-	0x0a6f8009, 0x00000000, 0x06411009, 0x098093c9, 0x06011009,
-	0x06411009, 0x091e1249, 0x0a6f8009, 0x0cc00000, 0x00000000,
-	0x06411009, 0x091c1249, 0x0a6f8009, 0x00000000, 0x07800e09,
-	0x0ae0c049, 0x0c007a40, 0x00000000, 0x06411009, 0x098093c9,
-	0x06011009, 0x08011c00, 0x08011e00, 0x06411009, 0x091e1249,
-	0x0a6f8009, 0x0cc00000, 0x00000000, 0x0a60fc08, 0x00000000,
-	0x08010e90, 0x0c781d00, 0x0800c0ff, 0x0780080b, 0x0c001d40,
-	0x06800049, 0x06047e08, 0x0aa1000b, 0x0c001e00, 0x06800049,
-	0x06047f08, 0x08048000, 0x0c0002c0, 0x0780250a, 0x06047c0c,
-	0x0780234a, 0x0a61400a, 0x08048020, 0x0c000140, 0x0780254a,
-	0x06047d0c, 0x0cc00000, 0x00000000, 0x0400034a, 0x06410c0e,
-	0x0980d1cd, 0x06010e0d, 0x0680000c, 0x0400034a, 0x0aa1c00d,
-	0x093e13ce, 0x0580130c, 0x097e130f, 0x0540138e, 0x0c7ffec0,
-	0x0440134d, 0x0680040d, 0x0240d28d, 0x0380c34c, 0x0aa4000b,
-	0x0400034a, 0x06410c0e, 0x0980d1cd, 0x06010e0d, 0x0400034a,
-	0x0aa1c00d, 0x093e13ce, 0x0580130c, 0x097e130f, 0x0540138e,
-	0x0c7ffec0, 0x0440134d, 0x0680040d, 0x0240d28d, 0x0380c34c,
-	0x0400034c, 0x0ae0c00a, 0x0cc00000, 0x00000000, 0x0680000e,
-	0x0680000f, 0x0900140d, 0x0aa1c010, 0x0c001040, 0x06800049,
-	0x09408388, 0x0c000f80, 0x06800049, 0x094083c8, 0x0920140d,
-	0x0aa44010, 0x0c000e40, 0x06800049, 0x09508388, 0x0c000d80,
-	0x06800049, 0x0c000400, 0x09121248, 0x0950a3c8, 0x0c000c40,
-	0x06800049, 0x09608388, 0x0c000b80, 0x06800049, 0x0c000200,
-	0x09121248, 0x0964a3c8, 0x0604810e, 0x0604810f, 0x0580134d,
-	0x0c7ff780, 0x0440128a, 0x090e1408, 0x0a816409, 0x0a62c009,
-	0x09101248, 0x0aa0c009, 0x0cc00000, 0x06805fc8, 0x090c1248,
-	0x0aa0c009, 0x0cc00000, 0x06804008, 0x0cc00000, 0x06801fc8,
-	0x09101248, 0x0a60c009, 0x0cc00000, 0x0680a008, 0x090c1248,
-	0x0a60c009, 0x0cc00000, 0x0680bfc8, 0x0cc00000, 0x0680e008,
-	0x0cc00000, 0x00000000, 0x00800000, 0x07800008, 0x0c7df180,
-	0x06030408, 0x06806008, 0x06010e08, 0x06410f08, 0x0befc0c8,
-	0x09118208, 0x0cc00000, 0x07400248, 0x0680e008, 0x06010e08,
-	0x06410f08, 0x0befc0c8, 0x09118208, 0x0cc00000, 0x07400248,
-	0x06410509, 0x06bfff89, 0x06030409, 0x00400000, 0x0be0c108,
-	0x0c7ffa40, 0x00000000, 0x08012104, 0x07800e09, 0x0ae0c049,
-	0x06411c22, 0x04000862, 0x0a26891f, 0x06011c21, 0x0a21481f,
-	0x0c005140, 0x00000000, 0x0a25411f, 0x09c1f15f, 0x07801fc9,
-	0x0aa48009, 0x08011e00, 0x0be42022, 0x06a907c9, 0x06012b09,
-	0x00000000, 0x00000000, 0x06412b09, 0x0c005080, 0x00000000,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa0c009, 0x0c00ae40, 0x06800049, 0x0c7ff780,
+	0x0440130c, 0x0c01b5c0, 0x00000000, 0x07801288, 0x0aa14008,
+	0x06800009, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c02449,
+	0x07800fc8, 0x0a610008, 0x07c02488, 0x0c780200, 0x07c024c8,
+	0x06410c08, 0x08010e82, 0x093e1248, 0x07c02489, 0x093c1248,
+	0x07c024c9, 0x0780234b, 0x0a60c08b, 0x0c781700, 0x00000000,
+	0x0641170a, 0x06410c08, 0x08010e81, 0x093e1248, 0x0a628009,
+	0x07801909, 0x09546289, 0x07c02509, 0x0a60c00b, 0x06800009,
+	0x07801949, 0x09606289, 0x0c7803c0, 0x07c02549, 0x0c00a3c0,
+	0x06802509, 0x07802509, 0x04001249, 0x09546289, 0x07c02509,
+	0x0aa1c04b, 0x0c00a200, 0x06802549, 0x07802549, 0x04001249,
+	0x09606289, 0x07c02549, 0x0601170a, 0x06800009, 0x07c02c89,
+	0x07802149, 0x0aa14009, 0x07802c49, 0x0b20c049, 0x0c01af80,
+	0x00000000, 0x0a61400b, 0x06800009, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0641170a, 0x096c1289, 0x0601170a, 0x07c02589,
+	0x078018c9, 0x0aa14009, 0x06800009, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x07c025c9, 0x06411008, 0x09581209, 0x06011008,
+	0x07802449, 0x0aa48009, 0x0a61400b, 0x06800049, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x07c02609, 0x0aa1808b, 0x0aa0c009,
+	0x06802549, 0x06802509, 0x07000249, 0x0ae10049, 0x06800009,
+	0x0c780100, 0x07c02649, 0x0c009540, 0x06802649, 0x0aa0c04b,
+	0x07801b89, 0x07801bc9, 0x06047b09, 0x08047c00, 0x0aa10009,
+	0x08047d00, 0x0c007580, 0x00000000, 0x0c009280, 0x06802689,
+	0x06800149, 0x02409209, 0x06411708, 0x096e3209, 0x06011708,
+	0x0c009280, 0x068026c9, 0x07801988, 0x079026c9, 0x02008248,
+	0x07c02708, 0x07802349, 0x09446248, 0x078024c8, 0x09501248,
+	0x07802488, 0x09521248, 0x07800d08, 0x09542248, 0x07800d48,
+	0x09582248, 0x07800d88, 0x095c2248, 0x07800dc8, 0x09602248,
+	0x07801ac8, 0x09647248, 0x07801b08, 0x09727248, 0x06011109,
+	0x06411009, 0x09809389, 0x06011009, 0x07801b48, 0x0aa3c008,
+	0x0c008b00, 0x06802749, 0x0c008a80, 0x06802789, 0x06411109,
+	0x07801ac8, 0x0780274a, 0x02008288, 0x09647248, 0x07801b08,
+	0x0780278a, 0x02008288, 0x09727248, 0x06011109, 0x07802048,
+	0x0aa14008, 0x06800009, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x07c027c9, 0x0a620009, 0x07802089, 0x07c02809, 0x078020c9,
+	0x07c02849, 0x07802109, 0x0c7802c0, 0x07c02889, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0a618009, 0x07c02809, 0x0c008280,
+	0x06802849, 0x0c008200, 0x06802889, 0x07802008, 0x0aa34008,
+	0x06800009, 0x07802488, 0x0a61c008, 0x078024c8, 0x0a614008,
+	0x07802808, 0x0aa0c008, 0x0c780140, 0x06800009, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x07c028c9, 0x07801c48, 0x0a610008,
+	0x07801fc8, 0x0a608008, 0x0c780440, 0x0c007ac0, 0x06802909,
+	0x0780290b, 0x0aa3400b, 0x0c0079c0, 0x06800049, 0x04001308,
+	0x0680080a, 0x0240a30a, 0x0980c1cc, 0x06410c08, 0x06010e0c,
+	0x03808288, 0x07c00048, 0x0aef004b, 0x044012cb, 0x078021c8,
+	0x0aa20008, 0x0c007640, 0x06800049, 0x0aa14008, 0x00000000,
+	0x08010e88, 0x0c7fff40, 0x04401208, 0x0c014d80, 0x00000000,
+	0x0640ce09, 0x0a240089, 0x06460308, 0x093e1208, 0x0a6f8008,
+	0x00000000, 0x06420408, 0x09c08748, 0x06020408, 0x06460108,
+	0x0a216008, 0x00000000, 0x06460408, 0x0a2fc048, 0x00000000,
+	0x06460408, 0x06060408, 0x07802248, 0x0aa28008, 0x00000000,
+	0x06460408, 0x09808708, 0x06060408, 0x06400408, 0x09808508,
+	0x09808588, 0x06000408, 0x08000400, 0x0c020280, 0x069fffe9,
+	0x0640d208, 0x0a230208, 0x07803688, 0x0be20208, 0x078022c9,
+	0x0a60c009, 0x07802349, 0x0aa10089, 0x00000000, 0x0c786940,
+	0x0800c0ff, 0x098080c8, 0x07c03688, 0x07803a89, 0x0aa100c9,
+	0x0aa0c109, 0x0c01d940, 0x00000000, 0x0800c008, 0x08007401,
+	0x0c786680, 0x00000000, 0x0aa0c148, 0x0c784800, 0x00000000,
+	0x0c01fbc0, 0x069fff69, 0x08010e81, 0x06812008, 0x06010e08,
+	0x00000000, 0x08010e00, 0x07802308, 0x0a60c008, 0x06800008,
+	0x07c02948, 0x07802248, 0x0aa58008, 0x06800008, 0x07c02b88,
+	0x07c02bc8, 0x07c00e88, 0x07c02988, 0x07c029c8, 0x07c02a08,
+	0x07c02a48, 0x07801c49, 0x0aa0c009, 0x07800e08, 0x07801d88,
+	0x07c02a88, 0x07c02b08, 0x0aa0c009, 0x07800e48, 0x07801e88,
+	0x07c02ac8, 0x07c02b48, 0x0c780280, 0x068001df, 0x078022c8,
+	0x07800e89, 0x0a806248, 0x06800827, 0x0c01e6c0, 0x078022e8,
+	0x0c785b40, 0x0800c0ff, 0x07802308, 0x0a61c008, 0x00000000,
+	0x068001df, 0x07802b89, 0x07802bc8, 0x09508248, 0x07c02d09,
+	0x07802b89, 0x0a614049, 0x07801fc9, 0x0aa0c009, 0x00000000,
+	0x0981f15f, 0x07802b89, 0x07802bc8, 0x0958c248, 0x0978425f,
+	0x06011609, 0x0c000300, 0x00000000, 0x07800e88, 0x09808788,
+	0x098087c8, 0x06012408, 0x0c01eb00, 0x07800ea9, 0x06a00008,
+	0x06011408, 0x0c786f00, 0x00000000, 0x07802a89, 0x07c02cc9,
+	0x07802bc9, 0x07802a4a, 0x0a40b289, 0x0680000c, 0x07802b8b,
+	0x07802a0a, 0x0a40728b, 0x0680000c, 0x0a614009, 0x0680008c,
+	0x0a60c00a, 0x0680008c, 0x068000cc, 0x07802308, 0x09441308,
+	0x06460109, 0x094a324c, 0x06060109, 0x06420109, 0x0944324c,
+	0x07802348, 0x09402248, 0x07800d48, 0x04003208, 0x09604248,
+	0x07800d08, 0x04003208, 0x09684248, 0x06020109, 0x07801c88,
+	0x06424c09, 0x09809009, 0x0aa10008, 0x09809049, 0x09c09009,
+	0x09c09049, 0x06024c09, 0x06460109, 0x0aa0c008, 0x098097c9,
+	0x09c097c9, 0x06060109, 0x07800848, 0x07800889, 0x09610209,
+	0x06020508, 0x07802a08, 0x07802a49, 0x09610209, 0x06020708,
+	0x06060708, 0x07802b08, 0x07802b49, 0x09610209, 0x06020808,
+	0x06060808, 0x07800e08, 0x04401208, 0x07800e49, 0x04401249,
+	0x09610209, 0x06020608, 0x06800048, 0x0541f208, 0x06020408,
+	0x06450a08, 0x09005208, 0x0a6f8008, 0x06800008, 0x07801c49,
+	0x0a60c009, 0x06f00008, 0x06d00008, 0x06050a08, 0x06450108,
+	0x078008c9, 0x09602209, 0x07800909, 0x09642209, 0x06050108,
+	0x07802a08, 0x07802a49, 0x0960a209, 0x07801c49, 0x097e1209,
+	0x06050608, 0x07802b0a, 0x07802b49, 0x0960a289, 0x0605070a,
+	0x09c087c8, 0x07802b8a, 0x07802bc9, 0x0960a289, 0x0a40c288,
+	0x00000000, 0x098087c8, 0x07802a09, 0x07802a4a, 0x0960a24a,
+	0x0a618009, 0x00000000, 0x06450009, 0x09809009, 0x09809049,
+	0x06050009, 0x06050808, 0x07802bc9, 0x07802a4a, 0x0a404289,
+	0x07802b89, 0x07802a0a, 0x0a802289, 0x0c780740, 0x0640c908,
+	0x0e000248, 0x0640ca0a, 0x00000000, 0x0f000240, 0x0200a24a,
+	0x0606110a, 0x0606150a, 0x0606140a, 0x04020208, 0x07802bc9,
+	0x0e000248, 0x0640cc0a, 0x0640cb0c, 0x0f000340, 0x07802988,
+	0x0e000308, 0x0200b34a, 0x0402028b, 0x00000000, 0x0f000240,
+	0x0200a24a, 0x0606120a, 0x0606160a, 0x02409309, 0x0200b24b,
+	0x0606130b, 0x0606170b, 0x06460408, 0x06060408, 0x06800048,
+	0x0541f208, 0x06060408, 0x07801c48, 0x06040508, 0x07802b08,
+	0x07802b49, 0x09610209, 0x06040308, 0x07802a08, 0x07802a49,
+	0x09610209, 0x06040408, 0x07802308, 0x0a638008, 0x06804808,
+	0x06043008, 0x06443108, 0x0900a248, 0x0a6f0009, 0x091e5248,
+	0x0a6e8009, 0x00000000, 0x06440008, 0x09808008, 0x06040008,
+	0x09c08008, 0x06040008, 0x08040701, 0x07802308, 0x0aa4c008,
+	0x07802b88, 0x0a614008, 0x07801fc9, 0x0aa0c009, 0x0c008980,
+	0x00000000, 0x06411009, 0x091c1249, 0x0a6f8009, 0x00000000,
 	0x06411009, 0x098093c9, 0x06011009, 0x06411009, 0x091e1249,
-	0x0a6f8009, 0x0c780840, 0x00000000, 0x0a2fa022, 0x06a907c9,
-	0x06012b09, 0x00000000, 0x00000000, 0x06412b09, 0x0c010080,
-	0x00000000, 0x06411609, 0x093e1249, 0x0aa4c009, 0x06800008,
-	0x07c02948, 0x06411109, 0x07802708, 0x09446248, 0x06011109,
-	0x06411009, 0x09809389, 0x06011009, 0x06411e08, 0x0be22008,
-	0x068001df, 0x0c079940, 0x0978479f, 0x06420409, 0x09c09749,
-	0x0c780100, 0x06020409, 0x0c7feac0, 0x0800c0ff, 0x0601161e,
-	0x07800e88, 0x09808788, 0x098087c8, 0x06012408, 0x0c013200,
-	0x07800ea9, 0x06a00008, 0x06011408, 0x07801c48, 0x0aa0c008,
-	0x0c00f900, 0x00000000, 0x09c1f09f, 0x07800e88, 0x04001208,
-	0x07c00e88, 0x07802948, 0x04001208, 0x07c02948, 0x0a21409f,
-	0x07802b09, 0x0b803248, 0x00000000, 0x09c1f05f, 0x07802b88,
-	0x0a618048, 0x04001208, 0x07801fc9, 0x0aa0c009, 0x00000000,
-	0x0981f15f, 0x07802a89, 0x0b815248, 0x07c02b88, 0x07802a08,
-	0x07c02b88, 0x0981f09f, 0x07800e88, 0x07800e09, 0x02008248,
-	0x07802b09, 0x02408248, 0x07c00e88, 0x07802bc8, 0x04001208,
-	0x07802ac9, 0x0b807248, 0x07c02bc8, 0x07801c48, 0x0aa0c008,
-	0x0c7806c0, 0x00000000, 0x0981f0df, 0x07802bc8, 0x04001208,
-	0x07802ac9, 0x0b80f248, 0x07802b88, 0x04001208, 0x07802a89,
-	0x0b80b248, 0x07800e09, 0x0b807248, 0x07802bc8, 0x04001208,
-	0x07800e49, 0x0b803248, 0x0c7800c0, 0x09c1f11f, 0x0981f11f,
-	0x0981f0df, 0x07802b9e, 0x07802bc8, 0x0958c788, 0x0978479f,
-	0x0cb80020, 0x00000000, 0x06800048, 0x07c02308, 0x07802988,
-	0x07801d0c, 0x0b41a308, 0x06801d89, 0x02009209, 0x0700024a,
-	0x07802a0b, 0x0200b28b, 0x07c02a0b, 0x07c02b8b, 0x07802a4b,
-	0x07c02bcb, 0x04001208, 0x0b808308, 0x07c02988, 0x07800e09,
-	0x07c02a89, 0x07802a0a, 0x02409289, 0x0c780ac0, 0x07c02b09,
-	0x04001249, 0x0700024a, 0x07c02b0a, 0x07802a8b, 0x0200b28b,
-	0x0c780900, 0x07c02a8b, 0x078029c8, 0x07801d4c, 0x0b802308,
-	0x0c7ff600, 0x06800008, 0x07c02988, 0x07c02b88, 0x07c02a08,
-	0x07801d89, 0x07c02b09, 0x07c02a89, 0x078029c8, 0x06801e89,
-	0x02009209, 0x0700024a, 0x07802a4b, 0x0200b28b, 0x07c02a4b,
-	0x07c02bcb, 0x04001208, 0x0b808308, 0x07c029c8, 0x07800e49,
-	0x07c02ac9, 0x07802a4a, 0x02409289, 0x0c780200, 0x07c02b49,
-	0x04001249, 0x0700024a, 0x07c02b4a, 0x07802acb, 0x0200b28b,
-	0x07c02acb, 0x07802a48, 0x07800e09, 0x0e000248, 0x00000000,
-	0x00000000, 0x07802a09, 0x0f000200, 0x02008248, 0x07c00e88,
-	0x0c7fe780, 0x04c177df, 0x07802b89, 0x07802a0a, 0x0400228a,
-	0x0b407289, 0x04402209, 0x0440128a, 0x07802a88, 0x0b403289,
-	0x04401208, 0x04401208, 0x0680c009, 0x02009209, 0x07400262,
-	0x0a21009f, 0x06800021, 0x0c7fc040, 0x00000000, 0x07802b88,
-	0x0680c009, 0x02009209, 0x0c7fbf00, 0x07000261, 0x07802b89,
-	0x07802a0a, 0x0400228a, 0x0b407289, 0x04402209, 0x0440128a,
-	0x07802a88, 0x0b403289, 0x04401208, 0x04401208, 0x0680c009,
-	0x05801288, 0x02009289, 0x0700024a, 0x0a20c048, 0x0c7800c0,
-	0x094082a2, 0x095102a2, 0x0740024a, 0x0a21009f, 0x06800021,
-	0x0c7fb940, 0x00000000, 0x07802b88, 0x0680c009, 0x05801288,
-	0x02009289, 0x0700024a, 0x0a20c048, 0x0911084a, 0x0900884a,
-	0x0c7fb6c0, 0x00000000, 0x07802b89, 0x07802a0a, 0x0400228a,
-	0x0b407289, 0x04402209, 0x0440128a, 0x07802a88, 0x0b403289,
-	0x04401208, 0x04401208, 0x0680c009, 0x05802288, 0x02009289,
-	0x0700024a, 0x09002208, 0x0a60c008, 0x0c780240, 0x095842a2,
-	0x0a60c048, 0x0c780180, 0x095042a2, 0x0a60c088, 0x0c7800c0,
-	0x094842a2, 0x094042a2, 0x0740024a, 0x0a21009f, 0x06800021,
-	0x0c7faf40, 0x00000000, 0x07802b88, 0x0680c009, 0x05802288,
-	0x02009289, 0x0700024a, 0x09002208, 0x0aa1c008, 0x0918484a,
-	0x0aa14048, 0x0910484a, 0x0aa0c088, 0x0908484a, 0x0900484a,
-	0x0c7fab80, 0x00000000, 0x0c780080, 0x06800021, 0x0c7faa80,
-	0x00000000, 0x06412106, 0x090c1186, 0x0a6f8006, 0x0c7d9b40,
-	0x00000000, 0x06804009, 0x06012d09, 0x06800f8a, 0x08012e00,
-	0x00000000, 0x0d07ff8a, 0x00000000, 0x0cc00000, 0x00000000,
-	0x06804009, 0x06012c09, 0x06809009, 0x06012d09, 0x06800f8a,
-	0x06412e09, 0x0d07ffca, 0x06012e09, 0x0cc00000, 0x00000000,
-	0x06809009, 0x06012c09, 0x06804009, 0x06012d09, 0x06800f8a,
-	0x06412e09, 0x0d07ffca, 0x06012e09, 0x06411109, 0x07802708,
-	0x09446248, 0x06011109, 0x0cc00000, 0x00000000, 0x07800e08,
-	0x07801d09, 0x0a608009, 0x0c780880, 0x0aa18049, 0x0aa20089,
-	0x0aa640c9, 0x0a608109, 0x0c7806c0, 0x0c780000, 0x05801288,
-	0x0c780680, 0x07c01d8a, 0x05802288, 0x0540124a, 0x02009289,
-	0x0b0fe209, 0x0400128a, 0x0440224a, 0x07c01d89, 0x05401289,
-	0x0400128a, 0x0540124a, 0x02009289, 0x05401208, 0x0b003209,
-	0x07801d89, 0x0440128a, 0x0240a24a, 0x0c780200, 0x07c01dca,
-	0x0c000b40, 0x06801d8c, 0x0c780100, 0x00000000, 0x0c000dc0,
-	0x06801d8c, 0x07800e48, 0x07801d49, 0x0a608009, 0x0c780880,
-	0x0aa18049, 0x0aa20089, 0x0aa640c9, 0x0a608109, 0x0c7806c0,
-	0x0c780000, 0x05801288, 0x0c780680, 0x07c01e8a, 0x05802288,
-	0x0540124a, 0x02009289, 0x0b0fe209, 0x0400128a, 0x0440224a,
-	0x07c01e89, 0x05401289, 0x0400128a, 0x0540124a, 0x02009289,
-	0x05401208, 0x0b003209, 0x07801e89, 0x0440128a, 0x0240a24a,
-	0x0c780200, 0x07c01eca, 0x0c000200, 0x06801e8c, 0x0cc00000,
-	0x00000000, 0x0c000480, 0x06801e8c, 0x0cc00000, 0x00000000,
-	0x05802348, 0x0740030d, 0x05801248, 0x0240a349, 0x0400130c,
-	0x0740030a, 0x054012c8, 0x0200b20b, 0x058022cb, 0x0240a24b,
-	0x0400130c, 0x0740030a, 0x0cc00000, 0x00000000, 0x05803288,
-	0x0540224a, 0x02009289, 0x0b0fe209, 0x0400128a, 0x0440224a,
-	0x07400309, 0x054012c8, 0x04000349, 0x0540224a, 0x02009289,
+	0x0a6f8009, 0x0cc00000, 0x00000000, 0x06411009, 0x091c1249,
+	0x0a6f8009, 0x00000000, 0x07800e09, 0x0ae0c049, 0x0c008200,
+	0x00000000, 0x06411009, 0x098093c9, 0x06011009, 0x08011c00,
+	0x08011e00, 0x06411009, 0x091e1249, 0x0a6f8009, 0x0cc00000,
+	0x00000000, 0x0a60fc08, 0x00000000, 0x08010e90, 0x0c781d00,
+	0x0800c0ff, 0x0780080b, 0x0c001d40, 0x06800049, 0x06047e08,
+	0x0aa1000b, 0x0c001e00, 0x06800049, 0x06047f08, 0x08048000,
+	0x0c0002c0, 0x0780250a, 0x06047c0c, 0x0780234a, 0x0a61400a,
+	0x08048020, 0x0c000140, 0x0780254a, 0x06047d0c, 0x0cc00000,
+	0x00000000, 0x0400034a, 0x06410c0e, 0x0980d1cd, 0x06010e0d,
+	0x0680000c, 0x0400034a, 0x0aa1c00d, 0x093e13ce, 0x0580130c,
+	0x097e130f, 0x0540138e, 0x0c7ffec0, 0x0440134d, 0x0680040d,
+	0x0240d28d, 0x0380c34c, 0x0aa4000b, 0x0400034a, 0x06410c0e,
+	0x0980d1cd, 0x06010e0d, 0x0400034a, 0x0aa1c00d, 0x093e13ce,
+	0x0580130c, 0x097e130f, 0x0540138e, 0x0c7ffec0, 0x0440134d,
+	0x0680040d, 0x0240d28d, 0x0380c34c, 0x0400034c, 0x0ae0c00a,
+	0x0cc00000, 0x00000000, 0x0680000e, 0x0680000f, 0x0900140d,
+	0x0aa1c010, 0x0c001040, 0x06800049, 0x09408388, 0x0c000f80,
+	0x06800049, 0x094083c8, 0x0920140d, 0x0aa44010, 0x0c000e40,
+	0x06800049, 0x09508388, 0x0c000d80, 0x06800049, 0x0c000400,
+	0x09121248, 0x0950a3c8, 0x0c000c40, 0x06800049, 0x09608388,
+	0x0c000b80, 0x06800049, 0x0c000200, 0x09121248, 0x0964a3c8,
+	0x0604810e, 0x0604810f, 0x0580134d, 0x0c7ff780, 0x0440128a,
+	0x090e1408, 0x0a816409, 0x0a62c009, 0x09101248, 0x0aa0c009,
+	0x0cc00000, 0x06805fc8, 0x090c1248, 0x0aa0c009, 0x0cc00000,
+	0x06804008, 0x0cc00000, 0x06801fc8, 0x09101248, 0x0a60c009,
+	0x0cc00000, 0x0680a008, 0x090c1248, 0x0a60c009, 0x0cc00000,
+	0x0680bfc8, 0x0cc00000, 0x0680e008, 0x0cc00000, 0x00000000,
+	0x00800000, 0x07800008, 0x0c7de1c0, 0x06030408, 0x06806008,
+	0x06010e08, 0x06410f08, 0x0befc0c8, 0x09118208, 0x0cc00000,
+	0x07400248, 0x0680e008, 0x06010e08, 0x06410f08, 0x0befc0c8,
+	0x09118208, 0x0cc00000, 0x07400248, 0x06410509, 0x06bfff89,
+	0x06030409, 0x00400000, 0x0be0c108, 0x0c7ffa40, 0x00000000,
+	0x08012104, 0x07800e09, 0x0ae0c049, 0x06411c22, 0x04000862,
+	0x0a26891f, 0x06011c21, 0x0a21481f, 0x0c005900, 0x00000000,
+	0x0a25411f, 0x09c1f15f, 0x07801fc9, 0x0aa48009, 0x08011e00,
+	0x0be42022, 0x06a907c9, 0x06012b09, 0x00000000, 0x00000000,
+	0x06412b09, 0x0c005840, 0x00000000, 0x06411009, 0x098093c9,
+	0x06011009, 0x06411009, 0x091e1249, 0x0a6f8009, 0x0c780bc0,
+	0x00000000, 0x0a2fa022, 0x06a907c9, 0x06012b09, 0x00000000,
+	0x00000000, 0x06412b09, 0x0c010c80, 0x00000000, 0x06411609,
+	0x093e1249, 0x0aa4c009, 0x06800008, 0x07c02948, 0x06411109,
+	0x07802708, 0x09446248, 0x06011109, 0x06411009, 0x09809389,
+	0x06011009, 0x06411e08, 0x0be22008, 0x068001df, 0x0c079940,
+	0x0978479f, 0x06420409, 0x09c09749, 0x0c780480, 0x06020409,
+	0x07803a48, 0x0aa34008, 0x0640d708, 0x0aa2c008, 0x00000000,
+	0x0c00eb00, 0x00000000, 0x07803a88, 0x0aa180c8, 0x0aa14108,
+	0x00000000, 0x0800c00a, 0x0c7fe7c0, 0x08007401, 0x0c7fe740,
+	0x0800c0ff, 0x0601161e, 0x07800e88, 0x09808788, 0x098087c8,
+	0x06012408, 0x0c017c00, 0x07800ea9, 0x06a00008, 0x06011408,
+	0x07801c48, 0x0aa0c008, 0x0c010180, 0x00000000, 0x09c1f09f,
+	0x07800e88, 0x04001208, 0x07c00e88, 0x07802948, 0x04001208,
+	0x07c02948, 0x0a21409f, 0x07802b09, 0x0b803248, 0x00000000,
+	0x09c1f05f, 0x07802b88, 0x0a618048, 0x04001208, 0x07801fc9,
+	0x0aa0c009, 0x00000000, 0x0981f15f, 0x07802a89, 0x0b817248,
+	0x07c02b88, 0x07802a08, 0x07c02b88, 0x0981f09f, 0x07800e88,
+	0x07800e09, 0x02008248, 0x07802b09, 0x02408248, 0x07c00e88,
+	0x07802bc8, 0x04001208, 0x07802ac9, 0x0b809248, 0x07c02bc8,
+	0x07801c48, 0x0aa0c008, 0x0c780740, 0x00000000, 0x06800048,
+	0x07c03a48, 0x0981f0df, 0x07802bc8, 0x04001208, 0x07802ac9,
+	0x0b80f248, 0x07802b88, 0x04001208, 0x07802a89, 0x0b80b248,
+	0x07800e09, 0x0b807248, 0x07802bc8, 0x04001208, 0x07800e49,
+	0x0b803248, 0x0c7800c0, 0x09c1f11f, 0x0981f11f, 0x0981f0df,
+	0x07802b9e, 0x07802bc8, 0x0958c788, 0x0978479f, 0x0cb80020,
+	0x00000000, 0x06800048, 0x07c02308, 0x07802988, 0x07801d0c,
+	0x0b41a308, 0x06801d89, 0x02009209, 0x0700024a, 0x07802a0b,
+	0x0200b28b, 0x07c02a0b, 0x07c02b8b, 0x07802a4b, 0x07c02bcb,
+	0x04001208, 0x0b808308, 0x07c02988, 0x07800e09, 0x07c02a89,
+	0x07802a0a, 0x02409289, 0x0c780ac0, 0x07c02b09, 0x04001249,
+	0x0700024a, 0x07c02b0a, 0x07802a8b, 0x0200b28b, 0x0c780900,
+	0x07c02a8b, 0x078029c8, 0x07801d4c, 0x0b802308, 0x0c7ff600,
+	0x06800008, 0x07c02988, 0x07c02b88, 0x07c02a08, 0x07801d89,
+	0x07c02b09, 0x07c02a89, 0x078029c8, 0x06801e89, 0x02009209,
+	0x0700024a, 0x07802a4b, 0x0200b28b, 0x07c02a4b, 0x07c02bcb,
+	0x04001208, 0x0b808308, 0x07c029c8, 0x07800e49, 0x07c02ac9,
+	0x07802a4a, 0x02409289, 0x0c780200, 0x07c02b49, 0x04001249,
+	0x0700024a, 0x07c02b4a, 0x07802acb, 0x0200b28b, 0x07c02acb,
+	0x07802a48, 0x07800e09, 0x0e000248, 0x00000000, 0x00000000,
+	0x07802a09, 0x0f000200, 0x02008248, 0x07c00e88, 0x0c7fe700,
+	0x04c177df, 0x07802b89, 0x07802a0a, 0x0400228a, 0x0b407289,
+	0x04402209, 0x0440128a, 0x07802a88, 0x0b403289, 0x04401208,
+	0x04401208, 0x0680c009, 0x02009209, 0x07400262, 0x0a21009f,
+	0x06800021, 0x0c7fbc40, 0x00000000, 0x07802b88, 0x0680c009,
+	0x02009209, 0x0c7fbb00, 0x07000261, 0x07802b89, 0x07802a0a,
+	0x0400228a, 0x0b407289, 0x04402209, 0x0440128a, 0x07802a88,
+	0x0b403289, 0x04401208, 0x04401208, 0x0680c009, 0x05801288,
+	0x02009289, 0x0700024a, 0x0a20c048, 0x0c7800c0, 0x094082a2,
+	0x095102a2, 0x0740024a, 0x0a21009f, 0x06800021, 0x0c7fb540,
+	0x00000000, 0x07802b88, 0x0680c009, 0x05801288, 0x02009289,
+	0x0700024a, 0x0a20c048, 0x0911084a, 0x0900884a, 0x0c7fb2c0,
+	0x00000000, 0x07802b89, 0x07802a0a, 0x0400228a, 0x0b407289,
+	0x04402209, 0x0440128a, 0x07802a88, 0x0b403289, 0x04401208,
+	0x04401208, 0x0680c009, 0x05802288, 0x02009289, 0x0700024a,
+	0x09002208, 0x0a60c008, 0x0c780240, 0x095842a2, 0x0a60c048,
+	0x0c780180, 0x095042a2, 0x0a60c088, 0x0c7800c0, 0x094842a2,
+	0x094042a2, 0x0740024a, 0x0a21009f, 0x06800021, 0x0c7fab40,
+	0x00000000, 0x07802b88, 0x0680c009, 0x05802288, 0x02009289,
+	0x0700024a, 0x09002208, 0x0aa1c008, 0x0918484a, 0x0aa14048,
+	0x0910484a, 0x0aa0c088, 0x0908484a, 0x0900484a, 0x0c7fa780,
+	0x00000000, 0x0c780080, 0x06800021, 0x0c7fa680, 0x00000000,
+	0x06808006, 0x0640d707, 0x0aa34007, 0x06410607, 0x0b003187,
+	0x0c780280, 0x00000000, 0x0681de27, 0x0c012f00, 0x04000a07,
+	0x0800c020, 0x08007401, 0x0640c006, 0x0a6fffc6, 0x00000000,
+	0x06412106, 0x090c1186, 0x0a6bc006, 0x0c7d83c0, 0x00000000,
+	0x06804009, 0x06012d09, 0x06800f8a, 0x08012e00, 0x00000000,
+	0x0d07ff8a, 0x00000000, 0x0cc00000, 0x00000000, 0x06804009,
+	0x06012c09, 0x06809009, 0x06012d09, 0x06800f8a, 0x06412e09,
+	0x0d07ffca, 0x06012e09, 0x0cc00000, 0x00000000, 0x06809009,
+	0x06012c09, 0x06804009, 0x06012d09, 0x06800f8a, 0x06412e09,
+	0x0d07ffca, 0x06012e09, 0x06411109, 0x07802708, 0x09446248,
+	0x06011109, 0x0cc00000, 0x00000000, 0x07800e08, 0x07801d09,
+	0x0a608009, 0x0c780880, 0x0aa18049, 0x0aa20089, 0x0aa640c9,
+	0x0a608109, 0x0c7806c0, 0x0c780000, 0x05801288, 0x0c780680,
+	0x07c01d8a, 0x05802288, 0x0540124a, 0x02009289, 0x0b0fe209,
+	0x0400128a, 0x0440224a, 0x07c01d89, 0x05401289, 0x0400128a,
+	0x0540124a, 0x02009289, 0x05401208, 0x0b003209, 0x07801d89,
+	0x0440128a, 0x0240a24a, 0x0c780200, 0x07c01dca, 0x0c000b40,
+	0x06801d8c, 0x0c780100, 0x00000000, 0x0c000dc0, 0x06801d8c,
+	0x07800e48, 0x07801d49, 0x0a608009, 0x0c780880, 0x0aa18049,
+	0x0aa20089, 0x0aa640c9, 0x0a608109, 0x0c7806c0, 0x0c780000,
+	0x05801288, 0x0c780680, 0x07c01e8a, 0x05802288, 0x0540124a,
+	0x02009289, 0x0b0fe209, 0x0400128a, 0x0440224a, 0x07c01e89,
+	0x05401289, 0x0400128a, 0x0540124a, 0x02009289, 0x05401208,
+	0x0b003209, 0x07801e89, 0x0440128a, 0x0240a24a, 0x0c780200,
+	0x07c01eca, 0x0c000200, 0x06801e8c, 0x0cc00000, 0x00000000,
+	0x0c000480, 0x06801e8c, 0x0cc00000, 0x00000000, 0x05802348,
+	0x0740030d, 0x05801248, 0x0240a349, 0x0400130c, 0x0740030a,
+	0x054012c8, 0x0200b20b, 0x058022cb, 0x0240a24b, 0x0400130c,
+	0x0740030a, 0x0cc00000, 0x00000000, 0x05803288, 0x0540224a,
+	0x02009289, 0x0b0fe209, 0x0400128a, 0x0440224a, 0x07400309,
+	0x054012c8, 0x04000349, 0x0540224a, 0x02009289, 0x0b0fe2c9,
+	0x0400128a, 0x0440224a, 0x0240a349, 0x0400130c, 0x0740030a,
+	0x054012c8, 0x0200b20b, 0x04000349, 0x0540224a, 0x02009289,
 	0x0b0fe2c9, 0x0400128a, 0x0440224a, 0x0240a349, 0x0400130c,
-	0x0740030a, 0x054012c8, 0x0200b20b, 0x04000349, 0x0540224a,
-	0x02009289, 0x0b0fe2c9, 0x0400128a, 0x0440224a, 0x0240a349,
-	0x0400130c, 0x0740030a, 0x054022c8, 0x04000349, 0x0540224a,
-	0x02009289, 0x0b0fe2c9, 0x0400128a, 0x0440224a, 0x0240a349,
-	0x0400130c, 0x0740030a, 0x0cc00000, 0x00000000, 0x0640c308,
-	0x02008308, 0x06035108, 0x06800808, 0x06035208, 0x06800149,
-	0x0680c00a, 0x0700024b, 0x0740028b, 0x0b6105c9, 0x04001249,
-	0x0c7fff00, 0x0400128a, 0x06a0c008, 0x06035008, 0x06435008,
-	0x0580f208, 0x0bef8048, 0x00000000, 0x06435308, 0x0900c208,
-	0x0a6f8008, 0x00000000, 0x0cc00000, 0x00000000, 0x0640c408,
-	0x02008308, 0x06035108, 0x06801408, 0x06035208, 0x06800609,
-	0x0680c00a, 0x0700024b, 0x0740028b, 0x0b611709, 0x04001249,
-	0x0c7fff00, 0x0400128a, 0x06a0c008, 0x06035008, 0x06435008,
-	0x0580f208, 0x0bef8048, 0x00000000, 0x06435308, 0x0900c208,
-	0x0a6f8008, 0x00000000, 0x0cc00000, 0x00000000, 0x0640c308,
-	0x02008308, 0x06035108, 0x06800808, 0x06035208, 0x06b0c008,
+	0x0740030a, 0x054022c8, 0x04000349, 0x0540224a, 0x02009289,
+	0x0b0fe2c9, 0x0400128a, 0x0440224a, 0x0240a349, 0x0400130c,
+	0x0740030a, 0x0cc00000, 0x00000000, 0x0640c308, 0x02008308,
+	0x06035108, 0x06800808, 0x06035208, 0x06800149, 0x0680c00a,
+	0x0700024b, 0x0740028b, 0x0b6105c9, 0x04001249, 0x0c7fff00,
+	0x0400128a, 0x06a0c008, 0x06035008, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008,
+	0x00000000, 0x0cc00000, 0x00000000, 0x0640c408, 0x02008308,
+	0x06035108, 0x06801408, 0x06035208, 0x06800609, 0x0680c00a,
+	0x0700024b, 0x0740028b, 0x0b611709, 0x04001249, 0x0c7fff00,
+	0x0400128a, 0x06a0c008, 0x06035008, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008,
+	0x00000000, 0x0cc00000, 0x00000000, 0x0640c308, 0x02008308,
+	0x06035108, 0x06800808, 0x06035208, 0x06b0c008, 0x06035008,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06800149,
+	0x0680c00a, 0x0700028b, 0x0740024b, 0x0b6105c9, 0x04001249,
+	0x0c7fff00, 0x0400128a, 0x0cc00000, 0x00000000, 0x0640c408,
+	0x02008308, 0x06035108, 0x06801408, 0x06035208, 0x06b0c008,
 	0x06035008, 0x06435008, 0x0580f208, 0x0bef8048, 0x00000000,
-	0x06800149, 0x0680c00a, 0x0700028b, 0x0740024b, 0x0b6105c9,
+	0x06800609, 0x0680c00a, 0x0700028b, 0x0740024b, 0x0b611709,
 	0x04001249, 0x0c7fff00, 0x0400128a, 0x0cc00000, 0x00000000,
-	0x0640c408, 0x02008308, 0x06035108, 0x06801408, 0x06035208,
-	0x06b0c008, 0x06035008, 0x06435008, 0x0580f208, 0x0bef8048,
-	0x00000000, 0x06800609, 0x0680c00a, 0x0700028b, 0x0740024b,
-	0x0b611709, 0x04001249, 0x0c7fff00, 0x0400128a, 0x0cc00000,
-	0x00000000, 0x0640c508, 0x02008308, 0x06035108, 0x06801467,
-	0x0c00a580, 0x06435128, 0x06800c08, 0x06035208, 0x06801749,
-	0x0680c00a, 0x0700024b, 0x0740028b, 0x0b6121c9, 0x04001249,
-	0x0c7fff00, 0x0400128a, 0x06a0c008, 0x06035008, 0x06435008,
-	0x0580f208, 0x0bef8048, 0x00000000, 0x06435308, 0x0900c208,
-	0x0a6f8008, 0x00000000, 0x07800f48, 0x0aa20008, 0x0540330c,
-	0x07801788, 0x0aa0c008, 0x06800008, 0x06900008, 0x0c000100,
-	0x0200c20c, 0x0cc00000, 0x00000000, 0x0680000d, 0x08070300,
-	0x0680c00b, 0x0680000a, 0x06470408, 0x06470409, 0x09508209,
-	0x074002c8, 0x040012cb, 0x0baeffca, 0x0400128a, 0x0aa3800d,
-	0x00000000, 0x06470508, 0x07c0fe88, 0x09210208, 0x07c0fec8,
-	0x06470608, 0x07c0ff08, 0x09210208, 0x07c0ff48, 0x06470708,
-	0x07c0ff88, 0x09210208, 0x07c0ffc8, 0x0640cd08, 0x02008308,
-	0x0540924d, 0x02008248, 0x06035108, 0x06804008, 0x06035208,
-	0x06a0c008, 0x06035008, 0x06435008, 0x0580f208, 0x0bef8048,
-	0x00000000, 0x0ba0c04d, 0x0cc00000, 0x00000000, 0x0c7ff640,
-	0x0400134d, 0x0640c508, 0x02008308, 0x06035108, 0x06801427,
-	0x0c009180, 0x06435128, 0x06800c08, 0x06035208, 0x06b0c008,
+	0x0640c508, 0x02008308, 0x06035108, 0x06801467, 0x0c00eb40,
+	0x06435128, 0x06800c08, 0x06035208, 0x06801749, 0x0680c00a,
+	0x0700024b, 0x0740028b, 0x0b6121c9, 0x04001249, 0x0c7fff00,
+	0x0400128a, 0x06a0c008, 0x06035008, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008,
+	0x00000000, 0x07800f48, 0x0aa20008, 0x0540330c, 0x07801788,
+	0x0aa0c008, 0x06800008, 0x06900008, 0x0c000100, 0x0200c20c,
+	0x0cc00000, 0x00000000, 0x0680000d, 0x08070300, 0x0680c00b,
+	0x0680000a, 0x06470408, 0x06470409, 0x09508209, 0x074002c8,
+	0x040012cb, 0x0baeffca, 0x0400128a, 0x0aa3800d, 0x00000000,
+	0x06470508, 0x07c0fe88, 0x09210208, 0x07c0fec8, 0x06470608,
+	0x07c0ff08, 0x09210208, 0x07c0ff48, 0x06470708, 0x07c0ff88,
+	0x09210208, 0x07c0ffc8, 0x0640cd08, 0x02008308, 0x0540924d,
+	0x02008248, 0x06035108, 0x06804008, 0x06035208, 0x06a0c008,
 	0x06035008, 0x06435008, 0x0580f208, 0x0bef8048, 0x00000000,
-	0x06801749, 0x0680c00a, 0x0700028b, 0x0740024b, 0x0b6121c9,
-	0x04001249, 0x0c7fff00, 0x0400128a, 0x0c000e00, 0x00000000,
-	0x07800f48, 0x0aa20008, 0x0540330c, 0x07801788, 0x0aa0c008,
-	0x06800008, 0x06900008, 0x0c000100, 0x0200c20c, 0x0cc00000,
-	0x00000000, 0x0680000d, 0x08070200, 0x0640cd08, 0x02008308,
-	0x0540924d, 0x02008248, 0x06035108, 0x06804008, 0x06035208,
-	0x06b0c008, 0x06035008, 0x06435008, 0x0580f208, 0x0bef8048,
-	0x00000000, 0x0680c00b, 0x0680000a, 0x070002c8, 0x040012cb,
-	0x06070408, 0x09108248, 0x06070409, 0x0baeffca, 0x0400128a,
-	0x0aa3800d, 0x00000000, 0x0780fe88, 0x0780fec9, 0x09610209,
-	0x06070508, 0x0780ff08, 0x0780ff49, 0x09610209, 0x06070608,
-	0x0780ff88, 0x0780ffc9, 0x09610209, 0x06070708, 0x0ba0c04d,
-	0x0cc00000, 0x00000000, 0x0c7ff640, 0x0400134d, 0x07801888,
-	0x07801a09, 0x09421209, 0x078019c9, 0x09441209, 0x07801c09,
-	0x09461209, 0x07800f09, 0x09483209, 0x07800ec9, 0x094e3209,
-	0x07800f89, 0x09741209, 0x07801a49, 0x09761209, 0x07800d49,
-	0x07801a8a, 0x02409289, 0x09782209, 0x06011708, 0x06412508,
-	0x07801009, 0x09401209, 0x078010c9, 0x09482209, 0x07801109,
-	0x094c2209, 0x07801049, 0x09504209, 0x07801089, 0x09584209,
-	0x06800cc9, 0x09706209, 0x078008c9, 0x09442209, 0x0aa18009,
-	0x0680018a, 0x04401249, 0x0340a24a, 0x0960420a, 0x09808048,
-	0x07800909, 0x097c2209, 0x0aa18009, 0x0680018a, 0x04401249,
-	0x0340a24a, 0x0968420a, 0x09808048, 0x06012508, 0x06470108,
-	0x07800f49, 0x09401209, 0x09421209, 0x09441209, 0x07800d49,
-	0x09482209, 0x06070108, 0x06470b08, 0x078008c9, 0x09402209,
-	0x07800909, 0x09482209, 0x09502209, 0x06070b08, 0x06440808,
-	0x078012c9, 0x09401209, 0x078019c9, 0x09421209, 0x06040808,
-	0x06440c08, 0x078008c9, 0x09402209, 0x07800909, 0x09442209,
-	0x06040c08, 0x0cc00000, 0x00000000, 0x07802508, 0x07c04408,
-	0x07802548, 0x07c04448, 0x07802348, 0x07c04488, 0x07802448,
-	0x07c044c8, 0x07802308, 0x07c04508, 0x078022c8, 0x07c04548,
-	0x07800848, 0x07c045c8, 0x07800888, 0x07c04608, 0x07800c88,
-	0x07c04648, 0x07800cc8, 0x07c04688, 0x07800948, 0x07c046c8,
-	0x078023c8, 0x07c04708, 0x07802608, 0x07c04748, 0x07802648,
-	0x07c04788, 0x07802188, 0x07c047c8, 0x07802688, 0x07c04808,
-	0x07800a88, 0x07c04848, 0x07802c88, 0x07c04888, 0x07801c48,
-	0x07801cc9, 0x05401249, 0x02c08248, 0x07c048c8, 0x07801d08,
-	0x07c04908, 0x07801d48, 0x07c04948, 0x07801d88, 0x07c04988,
-	0x07801dc8, 0x07c049c8, 0x07801e08, 0x07c04a08, 0x07801e48,
-	0x07c04a48, 0x07801e88, 0x07c04a88, 0x07801ec8, 0x07c04ac8,
-	0x07801f08, 0x07c04b08, 0x07801f48, 0x07c04b48, 0x078020c8,
-	0x07c04bc8, 0x07802108, 0x07c04c08, 0x07802848, 0x07c04c48,
-	0x07802888, 0x07c04c88, 0x07801ac8, 0x07c04cc8, 0x07801b08,
-	0x07c04d08, 0x07802248, 0x07c04d48, 0x078014c8, 0x07c04e08,
-	0x07801508, 0x07c04e48, 0x07801548, 0x07c04e88, 0x07801588,
-	0x07c04ec8, 0x078008c8, 0x07800909, 0x09484209, 0x07c04f08,
-	0x07801608, 0x07c05808, 0x07801648, 0x07c05848, 0x07801688,
-	0x07c05888, 0x078016c8, 0x07c058c8, 0x07801708, 0x07c05908,
-	0x07800808, 0x07c05948, 0x06800009, 0x07801148, 0x0a20c048,
-	0x07801008, 0x09809009, 0x0a20c048, 0x07801f88, 0x09809049,
-	0x0a20c048, 0x07802008, 0x09809089, 0x0a20c048, 0x07802048,
-	0x098090c9, 0x0a20c048, 0x07802088, 0x09809109, 0x0a20c048,
-	0x078027c8, 0x09809149, 0x0a20c048, 0x07802808, 0x09809189,
-	0x0a20c048, 0x07802488, 0x098091c9, 0x0a20c048, 0x078024c8,
-	0x09809209, 0x0a20c048, 0x078028c8, 0x09809249, 0x0a20c048,
-	0x00000000, 0x09809289, 0x07c04b89, 0x0680500a, 0x06802d48,
-	0x07000209, 0x07400289, 0x0400128a, 0x0baf7508, 0x04001208,
-	0x0640c108, 0x06035108, 0x06802008, 0x06035208, 0x06a04008,
+	0x0ba0c04d, 0x0cc00000, 0x00000000, 0x0c7ff640, 0x0400134d,
+	0x0640c508, 0x02008308, 0x06035108, 0x06801427, 0x0c00d740,
+	0x06435128, 0x06800c08, 0x06035208, 0x06b0c008, 0x06035008,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06801749,
+	0x0680c00a, 0x0700028b, 0x0740024b, 0x0b6121c9, 0x04001249,
+	0x0c7fff00, 0x0400128a, 0x0c000e00, 0x00000000, 0x07800f48,
+	0x0aa20008, 0x0540330c, 0x07801788, 0x0aa0c008, 0x06800008,
+	0x06900008, 0x0c000100, 0x0200c20c, 0x0cc00000, 0x00000000,
+	0x0680000d, 0x08070200, 0x0640cd08, 0x02008308, 0x0540924d,
+	0x02008248, 0x06035108, 0x06804008, 0x06035208, 0x06b0c008,
 	0x06035008, 0x06435008, 0x0580f208, 0x0bef8048, 0x00000000,
-	0x06435308, 0x0900c208, 0x0a6f8008, 0x00000000, 0x0cc00000,
-	0x00000000, 0x0800cf00, 0x0800c0ff, 0x06800009, 0x0680ffca,
-	0x07000248, 0x09808408, 0x0600cf08, 0x00000000, 0x0640cf08,
-	0x0a6fc008, 0x0b403289, 0x0c7ffe40, 0x04001249, 0x0cc00000,
-	0x00000000, 0x0680000a, 0x0680000b, 0x06804008, 0x07000209,
-	0x0580f209, 0x0be20048, 0x0580e209, 0x0a20c048, 0x0400128a,
-	0x040012cb, 0x06804008, 0x0bae040a, 0x02008288, 0x07c02c4b,
-	0x0cc00000, 0x00000000, 0x06800009, 0x07c02c49, 0x068003ca,
-	0x068043c8, 0x07400209, 0x0440128a, 0x0aef800a, 0x04401208,
-	0x06a00009, 0x07400209, 0x0cc00000, 0x00000000, 0x06800048,
-	0x07c02608, 0x07c02448, 0x0cc00000, 0x00000000, 0x06802d4d,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa10009, 0x07c02c89,
-	0x0c0003c0, 0x0780250c, 0x0a62c00b, 0x00000000, 0x06410c08,
-	0x08010e81, 0x093e1248, 0x0aa18009, 0x07802c89, 0x09809049,
-	0x07c02c89, 0x0c000100, 0x0780254c, 0x0cc00000, 0x00000000,
-	0x07802c48, 0x0b21c088, 0x06800049, 0x0b214108, 0x06800089,
-	0x0b20c208, 0x068000c9, 0x06800109, 0x0680080a, 0x0240a24a,
-	0x098091c9, 0x06410c08, 0x06010e09, 0x03808288, 0x07400348,
-	0x0400134d, 0x0aeec04c, 0x0440130c, 0x0cc00000, 0x00000000,
-	0x06460409, 0x09001289, 0x0aaf800a, 0x00000000, 0x0cc00000,
-	0x00000000, 0x07802b88, 0x0680d009, 0x02009209, 0x0700024d,
-	0x07802bc8, 0x0680ee09, 0x02009209, 0x0700024e, 0x0680000f,
-	0x0ac0338d, 0x06ee000f, 0x06ea000f, 0x06050a0f, 0x07802b88,
-	0x0b615e08, 0x0680d009, 0x02009209, 0x07802d0d, 0x0740024d,
-	0x07802bc8, 0x0b615108, 0x0680ee09, 0x02009209, 0x07802d0e,
-	0x0740024e, 0x0cc00000, 0x00000000, 0x07800863, 0x068003e4,
-	0x05408924, 0x0b813923, 0x078014e3, 0x054108e3, 0x07801525,
-	0x02c23963, 0x07801564, 0x05410924, 0x078015a5, 0x02c24964,
-	0x0aa28023, 0x0aa24024, 0x054059a3, 0x024268e6, 0x0ac06926,
-	0x00000000, 0x0800c080, 0x08007401, 0x0c780000, 0x00000000,
-	0x0cc00000, 0x00000000, 0x067f2f23, 0x0befc063, 0x0a20c0a3,
-	0x0c07f940, 0x00000000, 0x0640c023, 0x0a617fa3, 0x00000000,
-	0x06803ba7, 0x0c001d00, 0x04000a26, 0x0a6d7fe3, 0x00000000,
-	0x0640d223, 0x0be0c063, 0x0908c9a3, 0x06800026, 0x040019a6,
-	0x0aa10066, 0x068004a7, 0x0c001a40, 0x04000a26, 0x06410b23,
-	0x098230a3, 0x06010b23, 0x06412123, 0x0a2fc063, 0x00000000,
-	0x0d07fda6, 0x00000000, 0x06410c23, 0x06814027, 0x0c001740,
-	0x06410c28, 0x058089a3, 0x0aa18026, 0x06802824, 0x0aa10066,
-	0x06802624, 0x0c780140, 0x00000000, 0x06010e24, 0x00000000,
+	0x0680c00b, 0x0680000a, 0x070002c8, 0x040012cb, 0x06070408,
+	0x09108248, 0x06070409, 0x0baeffca, 0x0400128a, 0x0aa3800d,
+	0x00000000, 0x0780fe88, 0x0780fec9, 0x09610209, 0x06070508,
+	0x0780ff08, 0x0780ff49, 0x09610209, 0x06070608, 0x0780ff88,
+	0x0780ffc9, 0x09610209, 0x06070708, 0x0ba0c04d, 0x0cc00000,
+	0x00000000, 0x0c7ff640, 0x0400134d, 0x07801888, 0x07801a09,
+	0x09421209, 0x078019c9, 0x09441209, 0x07801c09, 0x09461209,
+	0x07800f09, 0x09483209, 0x07800ec9, 0x094e3209, 0x07800f89,
+	0x09741209, 0x07801a49, 0x09761209, 0x07800d49, 0x07801a8a,
+	0x02409289, 0x09782209, 0x06011708, 0x06412508, 0x07801009,
+	0x09401209, 0x078010c9, 0x09482209, 0x07801109, 0x094c2209,
+	0x07801049, 0x09504209, 0x07801089, 0x09584209, 0x06800cc9,
+	0x09706209, 0x078008c9, 0x09442209, 0x0aa18009, 0x0680018a,
+	0x04401249, 0x0340a24a, 0x0960420a, 0x09808048, 0x07800909,
+	0x097c2209, 0x0aa18009, 0x0680018a, 0x04401249, 0x0340a24a,
+	0x0968420a, 0x09808048, 0x06012508, 0x06470108, 0x07800f49,
+	0x09401209, 0x09421209, 0x09441209, 0x07800d49, 0x09482209,
+	0x06070108, 0x06470b08, 0x078008c9, 0x09402209, 0x07800909,
+	0x09482209, 0x09502209, 0x06070b08, 0x06440808, 0x078012c9,
+	0x09401209, 0x078019c9, 0x09421209, 0x06040808, 0x06440c08,
+	0x078008c9, 0x09402209, 0x07800909, 0x09442209, 0x06040c08,
+	0x0cc00000, 0x00000000, 0x07802508, 0x07c04408, 0x07802548,
+	0x07c04448, 0x07802348, 0x07c04488, 0x07802448, 0x07c044c8,
+	0x07802308, 0x07c04508, 0x078022c8, 0x07c04548, 0x07800848,
+	0x07c045c8, 0x07800888, 0x07c04608, 0x07800c88, 0x07c04648,
+	0x07800cc8, 0x07c04688, 0x07800948, 0x07c046c8, 0x078023c8,
+	0x07c04708, 0x07802608, 0x07c04748, 0x07802648, 0x07c04788,
+	0x07802188, 0x07c047c8, 0x07802688, 0x07c04808, 0x07800a88,
+	0x07c04848, 0x07802c88, 0x07c04888, 0x07801c48, 0x07801cc9,
+	0x05401249, 0x02c08248, 0x07c048c8, 0x07801d08, 0x07c04908,
+	0x07801d48, 0x07c04948, 0x07801d88, 0x07c04988, 0x07801dc8,
+	0x07c049c8, 0x07801e08, 0x07c04a08, 0x07801e48, 0x07c04a48,
+	0x07801e88, 0x07c04a88, 0x07801ec8, 0x07c04ac8, 0x07801f08,
+	0x07c04b08, 0x07801f48, 0x07c04b48, 0x078020c8, 0x07c04bc8,
+	0x07802108, 0x07c04c08, 0x07802848, 0x07c04c48, 0x07802888,
+	0x07c04c88, 0x07801ac8, 0x07c04cc8, 0x07801b08, 0x07c04d08,
+	0x07802248, 0x07c04d48, 0x078014c8, 0x07c04e08, 0x07801508,
+	0x07c04e48, 0x07801548, 0x07c04e88, 0x07801588, 0x07c04ec8,
+	0x078008c8, 0x07800909, 0x09484209, 0x07c04f08, 0x07801608,
+	0x07c05808, 0x07801648, 0x07c05848, 0x07801688, 0x07c05888,
+	0x078016c8, 0x07c058c8, 0x07801708, 0x07c05908, 0x07800808,
+	0x07c05948, 0x06800009, 0x07801148, 0x0a20c048, 0x07801008,
+	0x09809009, 0x0a20c048, 0x07801f88, 0x09809049, 0x0a20c048,
+	0x07802008, 0x09809089, 0x0a20c048, 0x07802048, 0x098090c9,
+	0x0a20c048, 0x07802088, 0x09809109, 0x0a20c048, 0x078027c8,
+	0x09809149, 0x0a20c048, 0x07802808, 0x09809189, 0x0a20c048,
+	0x07802488, 0x098091c9, 0x0a20c048, 0x078024c8, 0x09809209,
+	0x0a20c048, 0x078028c8, 0x09809249, 0x0a20c048, 0x00000000,
+	0x09809289, 0x07c04b89, 0x0680500a, 0x06802d48, 0x07000209,
+	0x07400289, 0x0400128a, 0x0baf7508, 0x04001208, 0x0640c108,
+	0x06035108, 0x06802008, 0x06035208, 0x06a04008, 0x06035008,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06435308,
+	0x0900c208, 0x0a6f8008, 0x00000000, 0x0cc00000, 0x00000000,
+	0x06460308, 0x093e1208, 0x0a6f8008, 0x00000000, 0x06420408,
+	0x09c08748, 0x06020408, 0x06460108, 0x0a216008, 0x00000000,
+	0x06460408, 0x0a2fc048, 0x00000000, 0x06460408, 0x06060408,
+	0x0cc00000, 0x00000000, 0x0800cf00, 0x0800c0ff, 0x06800009,
+	0x0680ffca, 0x07000248, 0x09808408, 0x0600cf08, 0x00000000,
+	0x0640cf08, 0x0a6fc008, 0x0b403289, 0x0c7ffe40, 0x04001249,
+	0x0cc00000, 0x00000000, 0x0680000a, 0x0680000b, 0x06804008,
+	0x07000209, 0x0580f209, 0x0be20048, 0x0580e209, 0x0a20c048,
+	0x0400128a, 0x040012cb, 0x06804008, 0x0bae040a, 0x02008288,
+	0x07c02c4b, 0x0cc00000, 0x00000000, 0x06800009, 0x07c02c49,
+	0x068003ca, 0x068043c8, 0x07400209, 0x0440128a, 0x0aef800a,
+	0x04401208, 0x06a00009, 0x07400209, 0x0cc00000, 0x00000000,
+	0x06800048, 0x07c02608, 0x07c02448, 0x0cc00000, 0x00000000,
+	0x06802d4d, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa10009,
+	0x07c02c89, 0x0c0003c0, 0x0780250c, 0x0a62c00b, 0x00000000,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa18009, 0x07802c89,
+	0x09809049, 0x07c02c89, 0x0c000100, 0x0780254c, 0x0cc00000,
+	0x00000000, 0x07802c48, 0x0b21c088, 0x06800049, 0x0b214108,
+	0x06800089, 0x0b20c208, 0x068000c9, 0x06800109, 0x0680080a,
+	0x0240a24a, 0x098091c9, 0x06410c08, 0x06010e09, 0x03808288,
+	0x07400348, 0x0400134d, 0x0aeec04c, 0x0440130c, 0x0cc00000,
+	0x00000000, 0x06460409, 0x09001289, 0x0aaf800a, 0x00000000,
+	0x0cc00000, 0x00000000, 0x07802b88, 0x0680d009, 0x02009209,
+	0x0700024d, 0x07802bc8, 0x0680ee09, 0x02009209, 0x0700024e,
+	0x0680000f, 0x0ac0338d, 0x06ee000f, 0x06ea000f, 0x06050a0f,
+	0x07802b88, 0x0b615e08, 0x0680d009, 0x02009209, 0x07802d0d,
+	0x0740024d, 0x07802bc8, 0x0b615108, 0x0680ee09, 0x02009209,
+	0x07802d0e, 0x0740024e, 0x0cc00000, 0x00000000, 0x07800863,
+	0x068003e4, 0x05408924, 0x0b813923, 0x078014e3, 0x054108e3,
+	0x07801525, 0x02c23963, 0x07801564, 0x05410924, 0x078015a5,
+	0x02c24964, 0x0aa28023, 0x0aa24024, 0x054059a3, 0x024268e6,
+	0x0ac06926, 0x00000000, 0x0800c080, 0x08007401, 0x0c780000,
+	0x00000000, 0x0cc00000, 0x00000000, 0x07803ae5, 0x0aa0c025,
+	0x0c783200, 0x00000000, 0x067f2f23, 0x0befc063, 0x0a20c0a3,
+	0x0c07f840, 0x00000000, 0x0640c023, 0x0a617fa3, 0x00000000,
+	0x06803ba7, 0x0c005d80, 0x04000a26, 0x0a6d7fe3, 0x00000000,
+	0x078038a3, 0x078038e6, 0x096108e6, 0x06410d26, 0x024268e6,
+	0x0640d723, 0x0aa3c023, 0x00000000, 0x068000e7, 0x04000a26,
+	0x0c005a00, 0x09610a23, 0x044018e3, 0x0b8088e6, 0x00000000,
+	0x0800c00e, 0x08007401, 0x0640c023, 0x0a6fffe3, 0x0c7ff800,
+	0x00000000, 0x0640d223, 0x0be0c063, 0x0908c9a3, 0x06800026,
+	0x040019a6, 0x0aa10066, 0x068004a7, 0x0c005580, 0x04000a26,
+	0x06410b23, 0x098230a3, 0x06010b23, 0x0640d724, 0x0aa48024,
+	0x06410625, 0x0680fa23, 0x06410624, 0x0a40e964, 0x0aef8023,
+	0x044018e3, 0x06808023, 0x0b40a8e4, 0x00000000, 0x0681de67,
+	0x0c005140, 0x04000a07, 0x0800c022, 0x08007401, 0x0640c023,
+	0x0a6fffe3, 0x00000000, 0x06412123, 0x0a2b0063, 0x00000000,
+	0x0d07f8e6, 0x00000000, 0x06410c23, 0x06814027, 0x0c004dc0,
+	0x04000a23, 0x058089a3, 0x0aa18026, 0x06802424, 0x0aa10066,
+	0x06802224, 0x0c780380, 0x00000000, 0x06010e24, 0x06802424,
+	0x06010e24, 0x06410823, 0x098233a3, 0x06010823, 0x09c233a3,
+	0x06010823, 0x06410c23, 0x06814067, 0x0c004900, 0x04000a23,
+	0x07803a65, 0x0aa18025, 0x07803aa5, 0x0a6080e5, 0x0c781bc0,
+	0x0a608125, 0x0c782400, 0x07803aa5, 0x092109a3, 0x069f8064,
+	0x0a80e926, 0x069f0064, 0x0a805926, 0x0aa08125, 0x0c780440,
+	0x0c780400, 0x00000000, 0x0640d224, 0x05814924, 0x0be0c064,
+	0x0c7802c0, 0x00000000, 0x0c7814c0, 0x06801065, 0x0a6dc125,
+	0x06802424, 0x06010e24, 0x06800424, 0x0d000024, 0x00000000,
 	0x06410c23, 0x092039a3, 0x07c04da6, 0x093269a3, 0x07c04de6,
-	0x06410d23, 0x06410b23, 0x0600d326, 0x06800067, 0x0c001240,
+	0x06410d23, 0x06410b23, 0x0600d326, 0x06802467, 0x0c003ec0,
 	0x04000a26, 0x0a6288a6, 0x00000000, 0x0640ce24, 0x0a21c0a4,
 	0x06411624, 0x093e1924, 0x0aa10024, 0x06440123, 0x0a2fc063,
 	0x00000000, 0x08012101, 0x0640d224, 0x0a60c926, 0x058108e4,
-	0x0a20c063, 0x0a214064, 0x00000000, 0x0800c009, 0x0c7fee00,
-	0x08007401, 0x0a6149e6, 0x05811924, 0x0a20c064, 0x0c780880,
-	0x068001e5, 0x0640d224, 0x0be580a4, 0x09042924, 0x0a60c0e4,
-	0x068003e3, 0x07c036a3, 0x06803c25, 0x078036a3, 0x0aa3c826,
-	0x0a25c063, 0x0aa34866, 0x0aa308a6, 0x0a2500a3, 0x0a24c123,
-	0x0aa24064, 0x0be18223, 0x0a20c0a4, 0x0b218566, 0x0c780380,
-	0x0aa08526, 0x0a6304e6, 0x098230e3, 0x07c036a3, 0x0aa24826,
-	0x06800065, 0x0aa1c866, 0x068000a5, 0x0aa148a6, 0x068000e5,
-	0x0b20c566, 0x06800125, 0x06803c25, 0x0ae1c566, 0x0a61bc25,
-	0x0640d224, 0x0928c8e4, 0x040018e3, 0x0968c923, 0x0600d224,
-	0x068000a7, 0x0c000180, 0x04000a25, 0x0600c025, 0x08030504,
-	0x0c7fe140, 0x00000000, 0x0600d128, 0x078036e8, 0x0aa18028,
-	0x00000000, 0x0600d027, 0x08007401, 0x0640d027, 0x0a6fc027,
-	0x00000000, 0x0cc00000, 0x00000000, 0x0600d128, 0x078036e8,
-	0x0aa54028, 0x00000000, 0x0640cf28, 0x06035128, 0x0680fc28,
-	0x06035228, 0x06a00028, 0x06035028, 0x06435028, 0x0580fa28,
-	0x0bef8068, 0x00000000, 0x06435328, 0x0900ca28, 0x0a6f8028,
-	0x00000000, 0x09827427, 0x0600d027, 0x08007401, 0x0640d027,
-	0x0a6fc027, 0x0cc00000, 0x00000000, 0x06810028, 0x06800008,
-	0x06410c27, 0x08010e90, 0x092109e7, 0x07400227, 0x0d07ff28,
-	0x04001208, 0x0cc00000, 0x00000000, 0x0aa54029, 0x04000a29,
-	0x0640d427, 0x090109e7, 0x0a411a27, 0x0640d427, 0x092029e7,
-	0x0a614067, 0x00000000, 0x0c07f500, 0x06800028, 0x0c780180,
-	0x0a6d80e7, 0x00000000, 0x0c07fa00, 0x00000000, 0x0c780040,
-	0x04000a29, 0x0600d428, 0x0c7ffbc0, 0x00000000, 0x0cc00000,
-	0x00000000, 0x07800848, 0x07800889, 0x09610209, 0x06012308,
-	0x06800208, 0x07800d49, 0x03408248, 0x06040608, 0x07800849,
-	0x0780088a, 0x0960f24a, 0x06040209, 0x07800e09, 0x07800e4a,
-	0x0960c24a, 0x06040309, 0x08040400, 0x0cc00000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x0a20c063, 0x0a214064, 0x00000000, 0x0800c009, 0x0c7fda00,
+	0x08007401, 0x0a61ca26, 0x05812964, 0x0be0c065, 0x0c780a40,
+	0x06803c25, 0x0c7809c0, 0x068010a5, 0x0a6149e6, 0x05811964,
+	0x0a20c065, 0x0c780880, 0x068001e5, 0x0640d224, 0x0be580a4,
+	0x09042924, 0x0a60c0e4, 0x068003e3, 0x07c036a3, 0x06803c25,
+	0x078036a3, 0x0aa3c826, 0x0a25c063, 0x0aa34866, 0x0aa308a6,
+	0x0a2500a3, 0x0a24c123, 0x0aa24064, 0x0be18223, 0x0a20c0a4,
+	0x0b218566, 0x0c780380, 0x0aa08526, 0x0a6304e6, 0x098230e3,
+	0x07c036a3, 0x0aa24826, 0x06800065, 0x0aa1c866, 0x068000a5,
+	0x0aa148a6, 0x068000e5, 0x0b20c566, 0x06800125, 0x06803c25,
+	0x0ae0c566, 0x0a60bc25, 0x00000000, 0x068000a7, 0x0c002d40,
+	0x04000a25, 0x0600c025, 0x08030504, 0x0c7fcc80, 0x00000000,
+	0x06801425, 0x092109a3, 0x069f8064, 0x0a40a926, 0x093269a3,
+	0x06802424, 0x06010e24, 0x06800424, 0x0d000024, 0x00000000,
+	0x06410c24, 0x093269a4, 0x06801465, 0x0aa38826, 0x06800064,
+	0x0aa30866, 0x068000a4, 0x0aa288a6, 0x068000e4, 0x0aa209e6,
+	0x068001e4, 0x0b218566, 0x06800124, 0x0aa11465, 0x06803c24,
+	0x0c7fdec0, 0x00000000, 0x0c000bc0, 0x00000000, 0x0600d324,
+	0x0600c025, 0x0c7fc440, 0x08007401, 0x0c7fdf40, 0x00000000,
+	0x092109a3, 0x069f0064, 0x0a8fc926, 0x069f8064, 0x0a404926,
+	0x093269a3, 0x0c7fdac0, 0x00000000, 0x0aa2c826, 0x06800064,
+	0x0aa24866, 0x068000a4, 0x0aa1c8a6, 0x068000e4, 0x0aa149e6,
+	0x068001e4, 0x0b20c566, 0x06800124, 0x06803c24, 0x0c000500,
+	0x00000000, 0x0600d324, 0x0800c050, 0x0c7fbd80, 0x08007401,
+	0x06806008, 0x07c03a08, 0x06800008, 0x07c03948, 0x0640d608,
+	0x09210248, 0x07c03909, 0x07c039c9, 0x09010248, 0x078039c8,
+	0x02009209, 0x07c03989, 0x0cc00000, 0x00000000, 0x07803948,
+	0x078039c9, 0x0780390a, 0x02409289, 0x09610248, 0x0600d609,
+	0x06806008, 0x07c03a08, 0x06800008, 0x07c03948, 0x07803909,
+	0x07c039c9, 0x0cc00000, 0x00000000, 0x06410c08, 0x06802209,
+	0x06010e09, 0x09308208, 0x0950820e, 0x0c000640, 0x0680000e,
+	0x06410b08, 0x09181208, 0x0aadc008, 0x00000000, 0x0c000d80,
+	0x00000000, 0x0cc00000, 0x00000000, 0x06410c08, 0x06802209,
+	0x06010e09, 0x09308208, 0x0950820e, 0x0c000340, 0x0680000e,
+	0x06410b08, 0x09181208, 0x0aadc008, 0x00000000, 0x0c000c80,
+	0x00000000, 0x0cc00000, 0x00000000, 0x0680394b, 0x0c780100,
+	0x0780390c, 0x068039cb, 0x0780398c, 0x0444030c, 0x07803a09,
+	0x07400248, 0x04001249, 0x0680680a, 0x0b817289, 0x00000000,
+	0x0640d509, 0x070002ca, 0x0ac1230a, 0x0540430a, 0x02009309,
+	0x06035109, 0x0400428a, 0x074002ca, 0x06800809, 0x06035209,
+	0x06a06009, 0x06035009, 0x06435009, 0x0580f249, 0x0bef8049,
+	0x00000000, 0x06435309, 0x0900c249, 0x0a6f8009, 0x00000000,
+	0x06806009, 0x0cc00000, 0x07c03a09, 0x06800008, 0x07803a09,
+	0x0680600a, 0x0a806289, 0x00000000, 0x0c07f600, 0x00000000,
+	0x0c7ffe80, 0x00000000, 0x0cc00000, 0x00000000, 0x06800008,
+	0x07803a09, 0x0680600a, 0x0a806289, 0x00000000, 0x0c07f400,
+	0x00000000, 0x0c7ffe80, 0x00000000, 0x0cc00000, 0x00000000,
+	0x0600d128, 0x078036e8, 0x0aa18028, 0x00000000, 0x0600d027,
+	0x08007401, 0x0640d027, 0x0a6fc027, 0x00000000, 0x0cc00000,
+	0x00000000, 0x0600d128, 0x078036e8, 0x0aa54028, 0x00000000,
+	0x0640cf28, 0x06035128, 0x0680fc28, 0x06035228, 0x06a00028,
+	0x06035028, 0x06435028, 0x0580fa28, 0x0bef8068, 0x00000000,
+	0x06435328, 0x0900ca28, 0x0a6f8028, 0x00000000, 0x09827427,
+	0x0600d027, 0x08007401, 0x0640d027, 0x0a6fc027, 0x0cc00000,
+	0x00000000, 0x06810028, 0x06800008, 0x06410c27, 0x08010e90,
+	0x092109e7, 0x07400227, 0x0d07ff28, 0x04001208, 0x0cc00000,
+	0x00000000, 0x0aa54029, 0x04000a29, 0x0640d427, 0x090109e7,
+	0x0a411a27, 0x0640d427, 0x092029e7, 0x0a614067, 0x00000000,
+	0x0c07f500, 0x06800028, 0x0c780180, 0x0a6d80e7, 0x00000000,
+	0x0c07fa00, 0x00000000, 0x0c780040, 0x04000a29, 0x0600d428,
+	0x0c7ffbc0, 0x00000000, 0x0cc00000, 0x00000000, 0x07800848,
+	0x07800889, 0x09610209, 0x06012308, 0x06800208, 0x07800d49,
+	0x03408248, 0x06040608, 0x07800849, 0x0780088a, 0x0960f24a,
+	0x06040209, 0x07800e09, 0x07800e4a, 0x0960c24a, 0x06040309,
+	0x08040400, 0x0cc00000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -802,8 +814,797 @@ const u32  vh265_mc[] __initconst = {
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+};
+
+const u32  vh265_mc_mmu[] __initconst = {
+	0x06814001, 0x06800000, 0x0d000001, 0x07400040, 0x0c000900,
+	0x00000000, 0x06bffe40, 0x07c00000, 0x06030400, 0x00400000,
+	0x0800c0ff, 0x0c035f40, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x0c7ffd80, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x0c7a7d80, 0x00000000, 0x0c7a2780,
+	0x06412108, 0x0c780d00, 0x00000000, 0x0cc00000, 0x00400000,
+	0x0640d323, 0x09008923, 0x058088e3, 0x07c03aa4, 0x07c03ae3,
+	0x06410d23, 0x09010923, 0x07c038a4, 0x09210923, 0x07c038e4,
+	0x0800c000, 0x08002515, 0x08002608, 0x0800271a, 0x06bfbb80,
+	0x06ffbfc0, 0x06070500, 0x06070600, 0x06070700, 0x06803fc0,
+	0x07c00140, 0x07c007c0, 0x07c01740, 0x0640d000, 0x07c036c0,
+	0x0640d200, 0x07c03640, 0x0640c108, 0x06035108, 0x06800408,
+	0x06035208, 0x06a04008, 0x06035008, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008,
+	0x00000000, 0x06800067, 0x0c03ae40, 0x0640d328, 0x0c039100,
+	0x00000000, 0x0cc00000, 0x00000000, 0x06bfff88, 0x06030408,
+	0x00400000, 0x0640c008, 0x0a618c08, 0x00000000, 0x0c0319c0,
+	0x00000000, 0x0c7a1380, 0x0800c0ff, 0x0aa0c048, 0x0c782040,
+	0x00000000, 0x06410c08, 0x08010e90, 0x09326208, 0x0aa0c808,
+	0x0c7a1140, 0x0800c0fe, 0x07803688, 0x09808008, 0x07c03688,
+	0x06410c08, 0x08010e90, 0x09384288, 0x09223248, 0x07c00189,
+	0x09201248, 0x07c001c9, 0x08010e90, 0x07800148, 0x0a805288,
+	0x07c0010a, 0x0aa0ffc8, 0x0c0294c0, 0x05407308, 0x0780010a,
+	0x07c0014a, 0x06410c08, 0x08010e88, 0x09305248, 0x07c00209,
+	0x06410c08, 0x08010e90, 0x09210248, 0x07c00249, 0x06410c08,
+	0x08010e90, 0x09210248, 0x07c00289, 0x06410c08, 0x08010e84,
+	0x09384248, 0x07c04f49, 0x08010e90, 0x08010e90, 0x08010e8c,
+	0x06410c08, 0x08010e88, 0x09308248, 0x07c002c9, 0x0780018b,
+	0x0aa6400b, 0x00000000, 0x06410c0a, 0x08010e90, 0x0aa5400b,
+	0x093e124a, 0x0aa30009, 0x06410c08, 0x08010e88, 0x06410c08,
+	0x08010e90, 0x06410c08, 0x08010e90, 0x06410c08, 0x08010e84,
+	0x08010e90, 0x08010e90, 0x08010e8c, 0x093c124a, 0x0aa0c009,
+	0x06410c08, 0x08010e88, 0x0540228a, 0x0c7ffb40, 0x044012cb,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0780018b, 0x0a60c009,
+	0x0680000a, 0x0780018a, 0x0ac0a2ca, 0x00000000, 0x0c01fe80,
+	0x06800309, 0x0c01fe00, 0x06800409, 0x0c01fd80, 0x06800509,
+	0x0c7ffe00, 0x0400128a, 0x08010e86, 0x06806008, 0x06010e08,
+	0x06410f08, 0x0befc0c8, 0x09118208, 0x0aa18008, 0x00000000,
+	0x06801c27, 0x0c039080, 0x04000a09, 0x0c780000, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0aa38009, 0x08010e90, 0x08010e90,
+	0x08010e90, 0x08010e90, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0aa0c009, 0x0c01f680, 0x06800049, 0x0c01f600, 0x06800049,
+	0x0aa04008, 0x08010e81, 0x07800148, 0x0aa0ffc8, 0x0c027b40,
+	0x05407308, 0x0c79f300, 0x0800c0ff, 0x0aa0c088, 0x0c78c3c0,
+	0x00000000, 0x06410c08, 0x08010e90, 0x09326208, 0x0aa0c848,
+	0x0c79f0c0, 0x0800c0fe, 0x07803688, 0x09808048, 0x07c03688,
+	0x06410c08, 0x08010e88, 0x09384288, 0x07c0060a, 0x09323248,
+	0x07c00649, 0x09301248, 0x07c00689, 0x07800148, 0x0a808288,
+	0x07c0010a, 0x0c027480, 0x05407308, 0x0780010a, 0x07c0014a,
+	0x0c028000, 0x0540730a, 0x06410c08, 0x08010e88, 0x09305248,
+	0x07c006c9, 0x06410c08, 0x08010e90, 0x09210248, 0x07c00709,
+	0x06410c08, 0x08010e90, 0x09210248, 0x07c00749, 0x06410c08,
+	0x08010e84, 0x08010e90, 0x08010e90, 0x08010e8c, 0x06410c08,
+	0x08010e88, 0x09308248, 0x07c00789, 0x0780064b, 0x0aa6400b,
+	0x00000000, 0x06410c0a, 0x08010e90, 0x0aa5400b, 0x093e124a,
+	0x0aa30009, 0x06410c08, 0x08010e88, 0x06410c08, 0x08010e90,
+	0x06410c08, 0x08010e90, 0x06410c08, 0x08010e84, 0x08010e90,
+	0x08010e90, 0x08010e8c, 0x093c124a, 0x0aa0c009, 0x06410c08,
+	0x08010e88, 0x0540228a, 0x0c7ffb40, 0x044012cb, 0x0c01e080,
+	0x06800049, 0x078007c9, 0x0a805209, 0x07c00108, 0x0aa0ffc9,
+	0x0c026c00, 0x05407309, 0x07800108, 0x07c007c8, 0x0c01de00,
+	0x06800809, 0x0c01dd80, 0x06800849, 0x0c01dd00, 0x06800889,
+	0x07800848, 0x07800889, 0x09610209, 0x06412309, 0x0a805209,
+	0x06460309, 0x093e1249, 0x0a6f8009, 0x00000000, 0x06012308,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa28009, 0x07c01609,
+	0x0c01d8c0, 0x06801649, 0x0c01d840, 0x06801689, 0x0c01d7c0,
+	0x068016c9, 0x0c01d740, 0x06801709, 0x0c01d6c0, 0x068008c9,
+	0x0c01d640, 0x06800909, 0x0c01d5c0, 0x06800949, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0780064b, 0x0a60c009, 0x0680000a,
+	0x0780064a, 0x0ac0a2ca, 0x00000000, 0x0c01d300, 0x06800989,
+	0x0c01d280, 0x06800a89, 0x0c01d200, 0x06800b89, 0x0c7ffe00,
+	0x0400128a, 0x0c01d100, 0x06800c89, 0x07800c89, 0x07c00d09,
+	0x0c01d000, 0x06800cc9, 0x07800c89, 0x07800cc8, 0x02009209,
+	0x07c00d49, 0x07800d48, 0x0a6300c8, 0x07800849, 0x0403f249,
+	0x05806249, 0x07c00e09, 0x07800889, 0x0403f249, 0x05806249,
+	0x07c00e49, 0x08040640, 0x0c780900, 0x06826ba0, 0x0a630088,
+	0x07800849, 0x0401f249, 0x05805249, 0x07c00e09, 0x07800889,
+	0x0401f249, 0x05805249, 0x07c00e49, 0x08040620, 0x0c780600,
+	0x06827120, 0x0a630048, 0x07800849, 0x0400f249, 0x05804249,
+	0x07c00e09, 0x07800889, 0x0400f249, 0x05804249, 0x07c00e49,
+	0x08040610, 0x0c780300, 0x06827960, 0x07800849, 0x04007249,
+	0x05803249, 0x07c00e09, 0x07800889, 0x04007249, 0x05803249,
+	0x07c00e49, 0x08040608, 0x068284a0, 0x07800e08, 0x07800e49,
+	0x0e000248, 0x00000000, 0x00000000, 0x06800009, 0x0f000200,
+	0x04401208, 0x0aa10008, 0x05801208, 0x0c7fff80, 0x04001249,
+	0x07c01449, 0x06460309, 0x093e1249, 0x0a6f8009, 0x00000000,
+	0x07800849, 0x0780088a, 0x0960f24a, 0x06040209, 0x07800e09,
+	0x07800e4a, 0x0960c24a, 0x06040309, 0x08040400, 0x0c01bc40,
+	0x06800049, 0x07800049, 0x07c00d89, 0x0c01bb40, 0x06800089,
+	0x07800049, 0x07800088, 0x02009209, 0x07c00dc9, 0x0c01b9c0,
+	0x06800ec9, 0x0c01b940, 0x06800f09, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa38009, 0x07c00f49, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa0c009, 0x0c001a80, 0x00000000, 0x078007c8,
+	0x0aa0c008, 0x068f000c, 0x069f000c, 0x0c025c00, 0x00000000,
+	0x06410c08, 0x08010e83, 0x093e1248, 0x07c00f89, 0x093c1248,
+	0x07c00fc9, 0x093a1248, 0x0aa58009, 0x06800009, 0x06410c08,
+	0x08010e88, 0x09384248, 0x04001249, 0x07c01049, 0x09304248,
+	0x04001249, 0x07c01089, 0x0c01b040, 0x068010c9, 0x0c01afc0,
+	0x06801109, 0x078010c9, 0x02008248, 0x07c01108, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x07c01149, 0x06800049, 0x07c01009,
+	0x0c01ad00, 0x06801189, 0x0680000e, 0x0780118f, 0x044013cf,
+	0x0aa1000f, 0x058013cf, 0x0c7fff80, 0x0400138e, 0x07c011ce,
+	0x0780118f, 0x0680000e, 0x0b4143ce, 0x00000000, 0x0480f20e,
+	0x05404208, 0x0680800d, 0x0200d20d, 0x0c002940, 0x00000000,
+	0x0480f20e, 0x0aa1c3c8, 0x00000000, 0x0400120e, 0x0b4043c8,
+	0x00000000, 0x0c780100, 0x00000000, 0x0c0049c0, 0x00000000,
+	0x0c7ffb80, 0x0400138e, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x07c01209, 0x0aa28009, 0x0c01a3c0, 0x06801249, 0x0aa1c008,
+	0x06410c08, 0x08010e89, 0x09308248, 0x092e1248, 0x0c7ffec0,
+	0x04401208, 0x06410c08, 0x08010e83, 0x093e1248, 0x07c01289,
+	0x093c1248, 0x07c012c9, 0x093a1248, 0x06800008, 0x07c014c8,
+	0x07c01508, 0x07c01548, 0x07c01588, 0x0aa0c009, 0x0c004b80,
+	0x00000000, 0x08010e81, 0x078007c8, 0x0aa0ffc8, 0x0c022a00,
+	0x05407308, 0x0c799b80, 0x0800c0ff, 0x068c8408, 0x06c41508,
+	0x06070508, 0x06070608, 0x06070708, 0x0680000b, 0x0680000a,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa08009, 0x0c780f00,
+	0x0c019900, 0x06800049, 0x0aa140cb, 0x0400e3ca, 0x0ba0c0ca,
+	0x0680038f, 0x068003cf, 0x0a60c00b, 0x0c780180, 0x0647050d,
+	0x0a60c04b, 0x0c7800c0, 0x0647060d, 0x0647070d, 0x0aa38008,
+	0x0400038f, 0x0aa300cb, 0x0680000e, 0x0240f20a, 0x0aa2410f,
+	0x0920438d, 0x0aa1c0cf, 0x0918438d, 0x0aa1408f, 0x0910438d,
+	0x0aa0c04f, 0x0908438d, 0x0900438d, 0x0a61c0cb, 0x0a60c00a,
+	0x0c7800c0, 0x0970434e, 0x0978434e, 0x0c780ec0, 0x0607070d,
+	0x0aa1c00a, 0x0aa2004a, 0x0aa2408a, 0x0aa280ca, 0x0aa2c10a,
+	0x0c7802c0, 0x0968434e, 0x0c780240, 0x0940434e, 0x0c7801c0,
+	0x0948434e, 0x0c780140, 0x0950434e, 0x0c7800c0, 0x0958434e,
+	0x0960434e, 0x0aa1000b, 0x0aa1404b, 0x0c7809c0, 0x0607070d,
+	0x0c780940, 0x0607050d, 0x0c7808c0, 0x0607060d, 0x0ba2c08b,
+	0x0680020c, 0x0c018b80, 0x06800049, 0x04008308, 0x0aa0c08b,
+	0x0680f808, 0x0680f988, 0x02008288, 0x06070208, 0x0607040c,
+	0x0aa1c00b, 0x0680e008, 0x0aa1404b, 0x06800008, 0x0aa0c08b,
+	0x06806008, 0x0680c008, 0x0680040e, 0x0aa1000b, 0x0540424a,
+	0x0680100e, 0x0540624a, 0x02008248, 0x06070208, 0x0680004d,
+	0x0c018580, 0x06800049, 0x0200c20c, 0x048ff30c, 0x0607040c,
+	0x0b8fb38d, 0x0400134d, 0x0ba0c0cb, 0x06800149, 0x06800049,
+	0x0b40324a, 0x0c7fe6c0, 0x0400128a, 0x0b60c0cb, 0x0c7fe5c0,
+	0x040012cb, 0x0cc00000, 0x00000000, 0x0aa1400e, 0x06800009,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0a608009, 0x0c781540,
+	0x07801189, 0x0a40624e, 0x0440144e, 0x0c017cc0, 0x06800049,
+	0x0c002500, 0x02411211, 0x0480f451, 0x05404451, 0x06808008,
+	0x02011211, 0x06800010, 0x06800012, 0x06410c08, 0x08010e81,
+	0x093e1288, 0x0c017980, 0x06800049, 0x0aa1000a, 0x040014c8,
+	0x06800009, 0x024134c9, 0x0b60c412, 0x06a0000b, 0x0700044b,
+	0x04001451, 0x04001492, 0x0200c2d3, 0x091e12cb, 0x0900e30c,
+	0x06410c08, 0x08010e81, 0x093e1288, 0x095c130a, 0x0a62000a,
+	0x06410c08, 0x08010e81, 0x093e1288, 0x0a61000a, 0x0a62400b,
+	0x0c7ffb80, 0x00000000, 0x0740034c, 0x0400134d, 0x04001410,
+	0x0a60c00b, 0x0c7ffa00, 0x00000000, 0x0b60c410, 0x06a00008,
+	0x07400348, 0x0ae08050, 0x0c780780, 0x0440134d, 0x07000351,
+	0x0900e451, 0x091a1491, 0x06900013, 0x0aa0c012, 0x02012453,
+	0x02412453, 0x0680004c, 0x0b41240c, 0x0241130d, 0x07000451,
+	0x0900e451, 0x091a12d1, 0x06900013, 0x0aa0c00b, 0x0200b453,
+	0x0240b453, 0x0b4072d2, 0x0241130d, 0x0400048b, 0x0700044b,
+	0x07000353, 0x0740034b, 0x07400453, 0x0c7ffc00, 0x0400130c,
+	0x0c7ff8c0, 0x04401410, 0x0cc00000, 0x00000000, 0x0c016880,
+	0x06800049, 0x0c016800, 0x06800089, 0x06800010, 0x0680000a,
+	0x0680000b, 0x0780004c, 0x0b41130b, 0x0c016640, 0x068000c9,
+	0x0240a20a, 0x0440128a, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0900e20a, 0x095c1209, 0x07400348, 0x0400134d, 0x04001410,
+	0x0bacc410, 0x040012cb, 0x0cc00000, 0x00000000, 0x0680000a,
+	0x0680000b, 0x0780008c, 0x0b41130b, 0x0c016140, 0x068000c9,
+	0x0200a20a, 0x0400128a, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0900e20a, 0x095c1209, 0x07400348, 0x0400134d, 0x04001410,
+	0x0bacc410, 0x040012cb, 0x0cc00000, 0x00000000, 0x06a00008,
+	0x07400348, 0x0cc00000, 0x00000000, 0x0580424e, 0x07c01489,
+	0x05409249, 0x0640c208, 0x02008248, 0x06035108, 0x06808008,
+	0x06035208, 0x06a08008, 0x06035008, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008,
+	0x00000000, 0x0cc00000, 0x00000000, 0x05804251, 0x07801488,
+	0x0a80e209, 0x07c01489, 0x05409249, 0x0640c208, 0x02008248,
+	0x06035108, 0x06808008, 0x06035208, 0x06b08008, 0x06035008,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x0cc00000,
+	0x00000000, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa34009,
+	0x00000000, 0x06410c08, 0x08010e88, 0x09308248, 0x07c01309,
+	0x0a61ffc9, 0x06410c08, 0x08010e90, 0x09210248, 0x06410c08,
+	0x08010e90, 0x09210248, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0aa0c009, 0x093c1248, 0x08010e81, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa34009, 0x0924e248, 0x07c04fc9, 0x09050248,
+	0x07c05989, 0x06410c08, 0x08010e85, 0x09361248, 0x0aa14009,
+	0x00000000, 0x08010e88, 0x00000000, 0x08010e90, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0aa14009, 0x0c014840, 0x06800089,
+	0x0c0147c0, 0x06800089, 0x06410c08, 0x08010e84, 0x093e1248,
+	0x093c1248, 0x093a1248, 0x07c015c9, 0x09381248, 0x0aa38009,
+	0x06410c08, 0x09118208, 0x0a60c008, 0x0cc00000, 0x00000000,
+	0x0c014400, 0x06801349, 0x0c014380, 0x06801389, 0x0c014300,
+	0x068013c9, 0x0c014280, 0x06801409, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa10009, 0x06410c08, 0x09018208, 0x0a608008,
+	0x0c7807c0, 0x06410c08, 0x08010e90, 0x09210248, 0x07c014c9,
+	0x06410c08, 0x08010e90, 0x09210248, 0x07c01509, 0x06410c08,
+	0x08010e90, 0x09210248, 0x07c01549, 0x06410c08, 0x08010e90,
+	0x09210248, 0x07c01589, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0aa10009, 0x0c013b00, 0x06800049, 0x04001208, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0aa10009, 0x0680004a, 0x0c000100,
+	0x0780064b, 0x0cc00000, 0x00000000, 0x0a60c00a, 0x0c7807c0,
+	0x00000000, 0x06410c08, 0x08010e82, 0x093c2248, 0x0aaec009,
+	0x06410c08, 0x08010e81, 0x093e1308, 0x0aa2400c, 0x06410c08,
+	0x08010e88, 0x09308248, 0x06410c08, 0x08010e8b, 0x09365248,
+	0x09341248, 0x092a5248, 0x06410c08, 0x08010e88, 0x09384248,
+	0x09304248, 0x0aa1000c, 0x06410c08, 0x08010e84, 0x09384248,
+	0x06410c08, 0x08010e8f, 0x09365248, 0x092c5248, 0x09225248,
+	0x0cc00000, 0x00000000, 0x0aa0c0c8, 0x0c783240, 0x00000000,
+	0x06410c08, 0x08010e90, 0x09326208, 0x0aa0c888, 0x0c792cc0,
+	0x0800c0fe, 0x07803688, 0x09808088, 0x07c03688, 0x0c012c80,
+	0x06800049, 0x07801749, 0x0a805209, 0x07c00108, 0x0aa0ffc9,
+	0x0c01c8c0, 0x05407309, 0x07800108, 0x07c01748, 0x0c012a00,
+	0x06801789, 0x078007ca, 0x0a806288, 0x07c00108, 0x0780010a,
+	0x07c007ca, 0x0c01c0c0, 0x0540730a, 0x0780060a, 0x07800148,
+	0x0a804288, 0x07c0014a, 0x0c01ba00, 0x0540730a, 0x06410c08,
+	0x08010e87, 0x093e1248, 0x07c017c9, 0x093c1248, 0x07c01809,
+	0x09363248, 0x07c01849, 0x09341248, 0x07c01889, 0x09321248,
+	0x07c018c9, 0x0c012340, 0x06801909, 0x04001208, 0x07c01908,
+	0x0c012240, 0x06801949, 0x04001208, 0x07c01948, 0x0c012300,
+	0x06801989, 0x0401a208, 0x07c01988, 0x06410c08, 0x08010e83,
+	0x093e1248, 0x07c019c9, 0x093c1248, 0x07c01a09, 0x093a1248,
+	0x07c01a49, 0x0aa10009, 0x06800008, 0x0c011dc0, 0x06801a89,
+	0x07c01a88, 0x0c011ec0, 0x06801ac9, 0x0c011e40, 0x06801b09,
+	0x06410c08, 0x08010e86, 0x093e1248, 0x07c01b49, 0x093c1248,
+	0x07c01b89, 0x093a1248, 0x07c01bc9, 0x09381248, 0x07c01c09,
+	0x09361248, 0x07c01c49, 0x09341248, 0x07c01fc9, 0x0aa0c009,
+	0x0c017640, 0x00000000, 0x06800048, 0x07c01f88, 0x07801c89,
+	0x07801c48, 0x02c09209, 0x07c01c89, 0x0a608008, 0x0c780a80,
+	0x0c0115c0, 0x06801d09, 0x07800e08, 0x07c01d88, 0x0c0114c0,
+	0x06801d49, 0x07800e48, 0x07c01e88, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x07c01cc9, 0x0aa14009, 0x0c0178c0, 0x00000000,
+	0x0c780580, 0x00000000, 0x07801d0b, 0x0ae0010b, 0x0680000a,
+	0x0b4072ca, 0x0c011080, 0x0407624a, 0x04001208, 0x07400248,
+	0x0c7ffec0, 0x0400128a, 0x07801d4b, 0x0ae0010b, 0x0680000a,
+	0x0b4072ca, 0x0c010e00, 0x0407a24a, 0x04001208, 0x07400248,
+	0x0c7ffec0, 0x0400128a, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x07c01f89, 0x06410c08, 0x08010e82, 0x093e1248, 0x07c02009,
+	0x093c1248, 0x0a618009, 0x07c02049, 0x07c02089, 0x07c020c9,
+	0x0c780340, 0x07c02109, 0x06410c08, 0x08010e82, 0x093e1248,
+	0x07c02049, 0x093c1248, 0x0a618009, 0x07c02089, 0x0c0108c0,
+	0x068020c9, 0x0c010840, 0x06802109, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0a628009, 0x07800f48, 0x0aa28008, 0x07801788,
+	0x0aa0c008, 0x068f000c, 0x069f000c, 0x0c01be00, 0x00000000,
+	0x0c7800c0, 0x0c0766c0, 0x00000000, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x07c02149, 0x0c010140, 0x06802189, 0x04002208,
+	0x07c02188, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c021c9,
+	0x08010e81, 0x0c01c440, 0x00000000, 0x07801748, 0x0aa0ffc8,
+	0x0c019bc0, 0x05407308, 0x0c78fc80, 0x0800c0ff, 0x0680040d,
+	0x0aa0c1c8, 0x0c781380, 0x00000000, 0x0640d20e, 0x0581338e,
+	0x0a21804e, 0x00000000, 0x0c027b80, 0x0680008e, 0x0c78f980,
+	0x0800c0ff, 0x08010e90, 0x06803fcb, 0x06800009, 0x06410c08,
+	0x08010e88, 0x09308208, 0x02009209, 0x0a8fc2c8, 0x0680000a,
+	0x06410c08, 0x08010e88, 0x09308208, 0x0200a20a, 0x0a8fc2c8,
+	0x00000000, 0x06801027, 0x0c028c40, 0x04000a09, 0x06801067,
+	0x0c028b80, 0x04000a0a, 0x0440134d, 0x0aa0800d, 0x0a60800a,
+	0x0c780a80, 0x0aa6c049, 0x0aa46249, 0x00000000, 0x06800009,
+	0x0aa9000a, 0x00000000, 0x06410c08, 0x08010e88, 0x06801127,
+	0x0c0287c0, 0x04000a08, 0x0a81e248, 0x04000248, 0x05808208,
+	0x0aa6c008, 0x0aa68048, 0x0c7ffd00, 0x0440128a, 0x0961024a,
+	0x0600d309, 0x0800c00c, 0x08007401, 0x0640c00a, 0x0a6fc34a,
+	0x00000000, 0x0c7ff3c0, 0x00000000, 0x078015c9, 0x0a22c049,
+	0x00000000, 0x06410c08, 0x08010e87, 0x09327208, 0x07c04f88,
+	0x068010a7, 0x0c028140, 0x04000a08, 0x08010e81, 0x0440128a,
+	0x0c7ff740, 0x00000000, 0x0c78e880, 0x0800c0ff, 0x0aa0d088,
+	0x0c780380, 0x00000000, 0x07803a89, 0x0aa1c0c9, 0x0aa18109,
+	0x00000000, 0x0c026b80, 0x068000ce, 0x0c780100, 0x00000000,
+	0x0c0266c0, 0x068000ce, 0x0c78e4c0, 0x0800c0ff, 0x0aa0d048,
+	0x0c780180, 0x00000000, 0x0c026500, 0x0680004e, 0x0c78e300,
+	0x0800c0ff, 0x0aa0c108, 0x0c787800, 0x00000000, 0x0c028480,
+	0x069fffa9, 0x06410c08, 0x08010e90, 0x09326208, 0x0b210548,
+	0x07c02208, 0x0c78e000, 0x0800c0fe, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x07c02249, 0x07802208, 0x0ba1c408, 0x06800009,
+	0x0ae14548, 0x06800009, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x07c02289, 0x0c00dd40, 0x06800049, 0x07801749, 0x0a818248,
+	0x07c00108, 0x0a64bfc9, 0x00000000, 0x0c016ec0, 0x0680000c,
+	0x0c017380, 0x0680000c, 0x0c019500, 0x00000000, 0x0680000c,
+	0x07c00e8c, 0x0c028100, 0x00000000, 0x0640d70c, 0x0aa1400c,
+	0x06803fcc, 0x07c0148c, 0x0c0780c0, 0x06800011, 0x07800108,
+	0x07c01748, 0x0c0188c0, 0x05407308, 0x07801788, 0x078007c9,
+	0x0a806248, 0x07c00108, 0x07800109, 0x07c007c9, 0x0c016d80,
+	0x05407309, 0x0780060a, 0x07800148, 0x0a804288, 0x07c0014a,
+	0x0c0166c0, 0x0540730a, 0x07802248, 0x06800009, 0x0aa10008,
+	0x07c02309, 0x0c780440, 0x07c022c9, 0x078017c8, 0x0aa14008,
+	0x06800009, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c02309,
+	0x07801449, 0x06410c08, 0x0680080a, 0x0240a24a, 0x098091c9,
+	0x06010e09, 0x03808288, 0x07c022c8, 0x07802308, 0x0aa0c008,
+	0x0c784d00, 0x00000000, 0x0c01dc40, 0x00000000, 0x07801848,
+	0x0aa0c008, 0x098081c8, 0x06010e08, 0x0c00cb40, 0x06802349,
+	0x07801808, 0x0aa14008, 0x06800049, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x07c02389, 0x07802209, 0x0aa084c9, 0x0a610509,
+	0x06800008, 0x0c7818c0, 0x07c023c8, 0x06410c08, 0x07800949,
+	0x04004249, 0x0680080a, 0x0240a24a, 0x098091c9, 0x06010e09,
+	0x03808288, 0x07c023c8, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0a614009, 0x0680400d, 0x0c0744c0, 0x0780118e, 0x0c780600,
+	0x078011c9, 0x06410c08, 0x068007ca, 0x0240a24a, 0x098091c9,
+	0x06010e09, 0x03808288, 0x05801208, 0x07c02408, 0x0c0769c0,
+	0x04000448, 0x0480f211, 0x05404208, 0x06808009, 0x02009209,
+	0x0680400d, 0x06800008, 0x0700024a, 0x0740034a, 0x0400134d,
+	0x04001208, 0x0baf0408, 0x04001249, 0x07801208, 0x0a608008,
+	0x0c780b80, 0x0780124a, 0x0aa1400a, 0x0680000b, 0x0c00bc00,
+	0x06800049, 0x040002c8, 0x0c00bb40, 0x06800049, 0x0200c20b,
+	0x0a60800c, 0x0c7808c0, 0x0ac0f2cc, 0x07801248, 0x0ba60048,
+	0x07801248, 0x0b21c088, 0x06802049, 0x0b214108, 0x06802089,
+	0x0b20c208, 0x068020c9, 0x06802109, 0x06410c08, 0x06010e09,
+	0x0c780340, 0x00000000, 0x06410c08, 0x07800949, 0x04004249,
+	0x0680080a, 0x0240a24a, 0x098091c9, 0x06010e09, 0x03808288,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa0c009, 0x0c00b280, 0x06800049, 0x0c7ff780,
+	0x0440130c, 0x0c01ba00, 0x00000000, 0x07801288, 0x0aa14008,
+	0x06800009, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c02449,
+	0x07800fc8, 0x0a610008, 0x07c02488, 0x0c780200, 0x07c024c8,
+	0x06410c08, 0x08010e82, 0x093e1248, 0x07c02489, 0x093c1248,
+	0x07c024c9, 0x0780234b, 0x0a60c08b, 0x0c781700, 0x00000000,
+	0x0641170a, 0x06410c08, 0x08010e81, 0x093e1248, 0x0a628009,
+	0x07801909, 0x09546289, 0x07c02509, 0x0a60c00b, 0x06800009,
+	0x07801949, 0x09606289, 0x0c7803c0, 0x07c02549, 0x0c00a800,
+	0x06802509, 0x07802509, 0x04001249, 0x09546289, 0x07c02509,
+	0x0aa1c04b, 0x0c00a640, 0x06802549, 0x07802549, 0x04001249,
+	0x09606289, 0x07c02549, 0x0601170a, 0x06800009, 0x07c02c89,
+	0x07802149, 0x0aa14009, 0x07802c49, 0x0b20c049, 0x0c01b3c0,
+	0x00000000, 0x0a61400b, 0x06800009, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0641170a, 0x096c1289, 0x0601170a, 0x07c02589,
+	0x078018c9, 0x0aa14009, 0x06800009, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x07c025c9, 0x06411008, 0x09581209, 0x06011008,
+	0x07802449, 0x0aa48009, 0x0a61400b, 0x06800049, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x07c02609, 0x0aa1808b, 0x0aa0c009,
+	0x06802549, 0x06802509, 0x07000249, 0x0ae10049, 0x06800009,
+	0x0c780100, 0x07c02649, 0x0c009980, 0x06802649, 0x0aa0c04b,
+	0x07801b89, 0x07801bc9, 0x06047b09, 0x08047c00, 0x0aa10009,
+	0x08047d00, 0x0c007940, 0x00000000, 0x0c0096c0, 0x06802689,
+	0x06800149, 0x02409209, 0x06411708, 0x096e3209, 0x06011708,
+	0x0c0096c0, 0x068026c9, 0x07801988, 0x079026c9, 0x02008248,
+	0x07c02708, 0x07802349, 0x09446248, 0x078024c8, 0x09501248,
+	0x07802488, 0x09521248, 0x07800d08, 0x09542248, 0x07800d48,
+	0x09582248, 0x07800d88, 0x095c2248, 0x07800dc8, 0x09602248,
+	0x07801ac8, 0x09647248, 0x07801b08, 0x09727248, 0x06011109,
+	0x06411009, 0x09809389, 0x06011009, 0x07801b48, 0x0aa3c008,
+	0x0c008f40, 0x06802749, 0x0c008ec0, 0x06802789, 0x06411109,
+	0x07801ac8, 0x0780274a, 0x02008288, 0x09647248, 0x07801b08,
+	0x0780278a, 0x02008288, 0x09727248, 0x06011109, 0x07802048,
+	0x0aa14008, 0x06800009, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x07c027c9, 0x0a620009, 0x07802089, 0x07c02809, 0x078020c9,
+	0x07c02849, 0x07802109, 0x0c7802c0, 0x07c02889, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0a618009, 0x07c02809, 0x0c0086c0,
+	0x06802849, 0x0c008640, 0x06802889, 0x07802008, 0x0aa34008,
+	0x06800009, 0x07802488, 0x0a61c008, 0x078024c8, 0x0a614008,
+	0x07802808, 0x0aa0c008, 0x0c780140, 0x06800009, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x07c028c9, 0x07801c48, 0x0a610008,
+	0x07801fc8, 0x0a608008, 0x0c780440, 0x0c007f00, 0x06802909,
+	0x0780290b, 0x0aa3400b, 0x0c007e00, 0x06800049, 0x04001308,
+	0x0680080a, 0x0240a30a, 0x0980c1cc, 0x06410c08, 0x06010e0c,
+	0x03808288, 0x07c00048, 0x0aef004b, 0x044012cb, 0x078021c8,
+	0x0aa20008, 0x0c007a80, 0x06800049, 0x0aa14008, 0x00000000,
+	0x08010e88, 0x0c7fff40, 0x04401208, 0x0c0151c0, 0x00000000,
+	0x0640ce09, 0x0a240089, 0x06460308, 0x093e1208, 0x0a6f8008,
+	0x00000000, 0x06420408, 0x09c08748, 0x06020408, 0x06460108,
+	0x0a216008, 0x00000000, 0x06460408, 0x0a2fc048, 0x00000000,
+	0x06460408, 0x06060408, 0x07802248, 0x0aa28008, 0x00000000,
+	0x06460408, 0x09808708, 0x06060408, 0x06400408, 0x09808508,
+	0x09808588, 0x06000408, 0x08000400, 0x0c021300, 0x069fffe9,
+	0x0640d208, 0x0a230208, 0x07803688, 0x0be20208, 0x078022c9,
+	0x0a60c009, 0x07802349, 0x0aa10089, 0x00000000, 0x0c786d80,
+	0x0800c0ff, 0x098080c8, 0x07c03688, 0x07803a89, 0x0aa100c9,
+	0x0aa0c109, 0x0c01e9c0, 0x00000000, 0x0800c008, 0x08007401,
+	0x0c786ac0, 0x00000000, 0x0aa0c148, 0x0c784bc0, 0x00000000,
+	0x0c020c40, 0x069fff69, 0x08010e81, 0x06812008, 0x06010e08,
+	0x00000000, 0x08010e00, 0x07802308, 0x0a60c008, 0x06800008,
+	0x07c02948, 0x07802248, 0x0aa58008, 0x06800008, 0x07c02b88,
+	0x07c02bc8, 0x07c00e88, 0x07c02988, 0x07c029c8, 0x07c02a08,
+	0x07c02a48, 0x07801c49, 0x0aa0c009, 0x07800e08, 0x07801d88,
+	0x07c02a88, 0x07c02b08, 0x0aa0c009, 0x07800e48, 0x07801e88,
+	0x07c02ac8, 0x07c02b48, 0x0c780280, 0x068001df, 0x078022c8,
+	0x07800e89, 0x0a806248, 0x06800827, 0x0c01f740, 0x078022e8,
+	0x0c785f80, 0x0800c0ff, 0x07802308, 0x0a61c008, 0x00000000,
+	0x068001df, 0x07802b89, 0x07802bc8, 0x09508248, 0x07c02d09,
+	0x07802b89, 0x0a614049, 0x07801fc9, 0x0aa0c009, 0x00000000,
+	0x0981f15f, 0x07802b89, 0x07802bc8, 0x0958c248, 0x0978425f,
+	0x06011609, 0x0c0006c0, 0x00000000, 0x07800e88, 0x09808788,
+	0x098087c8, 0x06012408, 0x0c01fb80, 0x07800ea9, 0x07800e88,
+	0x0a638008, 0x06400408, 0x09808688, 0x06000408, 0x09c08688,
+	0x06000408, 0x06810008, 0x07c037c8, 0x06800008, 0x07c03808,
+	0x0c017fc0, 0x00000000, 0x0c018680, 0x00000000, 0x06a00008,
+	0x06011408, 0x0c786f80, 0x00000000, 0x07802a89, 0x07c02cc9,
+	0x07802bc9, 0x07802a4a, 0x0a40b289, 0x0680000c, 0x07802b8b,
+	0x07802a0a, 0x0a40728b, 0x0680000c, 0x0a614009, 0x0680008c,
+	0x0a60c00a, 0x0680008c, 0x068000cc, 0x07802308, 0x09441308,
+	0x06460109, 0x094a324c, 0x06060109, 0x06420109, 0x0944324c,
+	0x07802348, 0x09402248, 0x07800d48, 0x04003208, 0x09604248,
+	0x07800d08, 0x04003208, 0x09684248, 0x06020109, 0x07801c88,
+	0x06424c09, 0x09809009, 0x0aa10008, 0x09809049, 0x09c09009,
+	0x09c09049, 0x06024c09, 0x06460109, 0x0aa0c008, 0x098097c9,
+	0x09c097c9, 0x06060109, 0x07800848, 0x07800889, 0x09610209,
+	0x06020508, 0x07802a08, 0x07802a49, 0x09610209, 0x06020708,
+	0x06060708, 0x07802b08, 0x07802b49, 0x09610209, 0x06020808,
+	0x06060808, 0x07800e08, 0x04401208, 0x07800e49, 0x04401249,
+	0x09610209, 0x06020608, 0x06800048, 0x0541f208, 0x06020408,
+	0x06450a08, 0x09005208, 0x0a6f8008, 0x06800008, 0x07801c49,
+	0x0a60c009, 0x06f00008, 0x06d00008, 0x06050a08, 0x06450108,
+	0x078008c9, 0x09602209, 0x07800909, 0x09642209, 0x06050108,
+	0x07802a08, 0x07802a49, 0x0960a209, 0x07801c49, 0x097e1209,
+	0x06050608, 0x07802b0a, 0x07802b49, 0x0960a289, 0x0605070a,
+	0x09c087c8, 0x07802b8a, 0x07802bc9, 0x0960a289, 0x0a40c288,
+	0x00000000, 0x098087c8, 0x07802a09, 0x07802a4a, 0x0960a24a,
+	0x0a618009, 0x00000000, 0x06450009, 0x09809009, 0x09809049,
+	0x06050009, 0x06050808, 0x07802bc9, 0x07802a4a, 0x0a404289,
+	0x07802b89, 0x07802a0a, 0x0a802289, 0x0c780740, 0x0640c908,
+	0x0e000248, 0x0640ca0a, 0x00000000, 0x0f000240, 0x0200a24a,
+	0x0606110a, 0x0606150a, 0x0606140a, 0x04020208, 0x07802bc9,
+	0x0e000248, 0x0640cc0a, 0x0640cb0c, 0x0f000340, 0x07802988,
+	0x0e000308, 0x0200b34a, 0x0402028b, 0x00000000, 0x0f000240,
+	0x0200a24a, 0x0606120a, 0x0606160a, 0x02409309, 0x0200b24b,
+	0x0606130b, 0x0606170b, 0x06460408, 0x06060408, 0x06800048,
+	0x0541f208, 0x06060408, 0x07801c48, 0x06040508, 0x07802b08,
+	0x07802b49, 0x09610209, 0x06040308, 0x07802a08, 0x07802a49,
+	0x09610209, 0x06040408, 0x07802308, 0x0a638008, 0x06804808,
+	0x06043008, 0x06443108, 0x0900a248, 0x0a6f0009, 0x091e5248,
+	0x0a6e8009, 0x00000000, 0x06440008, 0x09808008, 0x06040008,
+	0x09c08008, 0x06040008, 0x08040701, 0x07802308, 0x0aa4c008,
+	0x07802b88, 0x0a614008, 0x07801fc9, 0x0aa0c009, 0x0c008a00,
+	0x00000000, 0x06411009, 0x091c1249, 0x0a6f8009, 0x00000000,
+	0x06411009, 0x098093c9, 0x06011009, 0x06411009, 0x091e1249,
+	0x0a6f8009, 0x0cc00000, 0x00000000, 0x06411009, 0x091c1249,
+	0x0a6f8009, 0x00000000, 0x07800e09, 0x0ae0c049, 0x0c008280,
+	0x00000000, 0x06411009, 0x098093c9, 0x06011009, 0x08011c00,
+	0x08011e00, 0x06411009, 0x091e1249, 0x0a6f8009, 0x0cc00000,
+	0x00000000, 0x0a60fc08, 0x00000000, 0x08010e90, 0x0c781d80,
+	0x0800c0ff, 0x0780080b, 0x0c001dc0, 0x06800049, 0x06047e08,
+	0x0aa1000b, 0x0c001e80, 0x06800049, 0x06047f08, 0x08048000,
+	0x0c0002c0, 0x0780250a, 0x06047c0c, 0x0780234a, 0x0a61400a,
+	0x08048020, 0x0c000140, 0x0780254a, 0x06047d0c, 0x0cc00000,
+	0x00000000, 0x0400034a, 0x06410c0e, 0x0980d1cd, 0x06010e0d,
+	0x0680000c, 0x0400034a, 0x0aa1c00d, 0x093e13ce, 0x0580130c,
+	0x097e130f, 0x0540138e, 0x0c7ffec0, 0x0440134d, 0x0680040d,
+	0x0240d28d, 0x0380c34c, 0x0aa4000b, 0x0400034a, 0x06410c0e,
+	0x0980d1cd, 0x06010e0d, 0x0400034a, 0x0aa1c00d, 0x093e13ce,
+	0x0580130c, 0x097e130f, 0x0540138e, 0x0c7ffec0, 0x0440134d,
+	0x0680040d, 0x0240d28d, 0x0380c34c, 0x0400034c, 0x0ae0c00a,
+	0x0cc00000, 0x00000000, 0x0680000e, 0x0680000f, 0x0900140d,
+	0x0aa1c010, 0x0c0010c0, 0x06800049, 0x09408388, 0x0c001000,
+	0x06800049, 0x094083c8, 0x0920140d, 0x0aa44010, 0x0c000ec0,
+	0x06800049, 0x09508388, 0x0c000e00, 0x06800049, 0x0c000400,
+	0x09121248, 0x0950a3c8, 0x0c000cc0, 0x06800049, 0x09608388,
+	0x0c000c00, 0x06800049, 0x0c000200, 0x09121248, 0x0964a3c8,
+	0x0604810e, 0x0604810f, 0x0580134d, 0x0c7ff780, 0x0440128a,
+	0x090e1408, 0x0a816409, 0x0a62c009, 0x09101248, 0x0aa0c009,
+	0x0cc00000, 0x06805fc8, 0x090c1248, 0x0aa0c009, 0x0cc00000,
+	0x06804008, 0x0cc00000, 0x06801fc8, 0x09101248, 0x0a60c009,
+	0x0cc00000, 0x0680a008, 0x090c1248, 0x0a60c009, 0x0cc00000,
+	0x0680bfc8, 0x0cc00000, 0x0680e008, 0x0cc00000, 0x00000000,
+	0x0c013200, 0x00000000, 0x00800000, 0x07800008, 0x0c7ddd80,
+	0x06030408, 0x06806008, 0x06010e08, 0x06410f08, 0x0befc0c8,
+	0x09118208, 0x0cc00000, 0x07400248, 0x0680e008, 0x06010e08,
+	0x06410f08, 0x0befc0c8, 0x09118208, 0x0cc00000, 0x07400248,
+	0x06410509, 0x06bfff89, 0x06030409, 0x00400000, 0x0be0c108,
+	0x0c7ff9c0, 0x00000000, 0x08012104, 0x07800e09, 0x0ae0c049,
+	0x06411c22, 0x04000862, 0x0a26891f, 0x06011c21, 0x0a21481f,
+	0x0c005900, 0x00000000, 0x0a25411f, 0x09c1f15f, 0x07801fc9,
+	0x0aa48009, 0x08011e00, 0x0be42022, 0x06a907c9, 0x06012b09,
+	0x00000000, 0x00000000, 0x06412b09, 0x0c005840, 0x00000000,
+	0x06411009, 0x098093c9, 0x06011009, 0x06411009, 0x091e1249,
+	0x0a6f8009, 0x0c780bc0, 0x00000000, 0x0a2fa022, 0x06a907c9,
+	0x06012b09, 0x00000000, 0x00000000, 0x06412b09, 0x0c010c80,
+	0x00000000, 0x06411609, 0x093e1249, 0x0aa4c009, 0x06800008,
+	0x07c02948, 0x06411109, 0x07802708, 0x09446248, 0x06011109,
+	0x06411009, 0x09809389, 0x06011009, 0x06411e08, 0x0be22008,
+	0x068001df, 0x0c0798c0, 0x0978479f, 0x06420409, 0x09c09749,
+	0x0c780480, 0x06020409, 0x07803a48, 0x0aa34008, 0x0640d708,
+	0x0aa2c008, 0x00000000, 0x0c00eb00, 0x00000000, 0x07803a88,
+	0x0aa180c8, 0x0aa14108, 0x00000000, 0x0800c00a, 0x0c7fe740,
+	0x08007401, 0x0c7fe6c0, 0x0800c0ff, 0x0601161e, 0x07800e88,
+	0x09808788, 0x098087c8, 0x06012408, 0x0c018840, 0x07800ea9,
+	0x06a00008, 0x06011408, 0x07801c48, 0x0aa0c008, 0x0c010180,
+	0x00000000, 0x09c1f09f, 0x07800e88, 0x04001208, 0x07c00e88,
+	0x07802948, 0x04001208, 0x07c02948, 0x0a21409f, 0x07802b09,
+	0x0b803248, 0x00000000, 0x09c1f05f, 0x07802b88, 0x0a618048,
+	0x04001208, 0x07801fc9, 0x0aa0c009, 0x00000000, 0x0981f15f,
+	0x07802a89, 0x0b817248, 0x07c02b88, 0x07802a08, 0x07c02b88,
+	0x0981f09f, 0x07800e88, 0x07800e09, 0x02008248, 0x07802b09,
+	0x02408248, 0x07c00e88, 0x07802bc8, 0x04001208, 0x07802ac9,
+	0x0b809248, 0x07c02bc8, 0x07801c48, 0x0aa0c008, 0x0c780740,
+	0x00000000, 0x06800048, 0x07c03a48, 0x0981f0df, 0x07802bc8,
+	0x04001208, 0x07802ac9, 0x0b80f248, 0x07802b88, 0x04001208,
+	0x07802a89, 0x0b80b248, 0x07800e09, 0x0b807248, 0x07802bc8,
+	0x04001208, 0x07800e49, 0x0b803248, 0x0c7800c0, 0x09c1f11f,
+	0x0981f11f, 0x0981f0df, 0x07802b9e, 0x07802bc8, 0x0958c788,
+	0x0978479f, 0x0cb80020, 0x00000000, 0x06800048, 0x07c02308,
+	0x07802988, 0x07801d0c, 0x0b41a308, 0x06801d89, 0x02009209,
+	0x0700024a, 0x07802a0b, 0x0200b28b, 0x07c02a0b, 0x07c02b8b,
+	0x07802a4b, 0x07c02bcb, 0x04001208, 0x0b808308, 0x07c02988,
+	0x07800e09, 0x07c02a89, 0x07802a0a, 0x02409289, 0x0c780ac0,
+	0x07c02b09, 0x04001249, 0x0700024a, 0x07c02b0a, 0x07802a8b,
+	0x0200b28b, 0x0c780900, 0x07c02a8b, 0x078029c8, 0x07801d4c,
+	0x0b802308, 0x0c7ff600, 0x06800008, 0x07c02988, 0x07c02b88,
+	0x07c02a08, 0x07801d89, 0x07c02b09, 0x07c02a89, 0x078029c8,
+	0x06801e89, 0x02009209, 0x0700024a, 0x07802a4b, 0x0200b28b,
+	0x07c02a4b, 0x07c02bcb, 0x04001208, 0x0b808308, 0x07c029c8,
+	0x07800e49, 0x07c02ac9, 0x07802a4a, 0x02409289, 0x0c780200,
+	0x07c02b49, 0x04001249, 0x0700024a, 0x07c02b4a, 0x07802acb,
+	0x0200b28b, 0x07c02acb, 0x07802a48, 0x07800e09, 0x0e000248,
+	0x00000000, 0x00000000, 0x07802a09, 0x0f000200, 0x02008248,
+	0x07c00e88, 0x0c7fe700, 0x04c177df, 0x07802b89, 0x07802a0a,
+	0x0400228a, 0x0b407289, 0x04402209, 0x0440128a, 0x07802a88,
+	0x0b403289, 0x04401208, 0x04401208, 0x0680c009, 0x02009209,
+	0x07400262, 0x0a21009f, 0x06800021, 0x0c7fbbc0, 0x00000000,
+	0x07802b88, 0x0680c009, 0x02009209, 0x0c7fba80, 0x07000261,
+	0x07802b89, 0x07802a0a, 0x0400228a, 0x0b407289, 0x04402209,
+	0x0440128a, 0x07802a88, 0x0b403289, 0x04401208, 0x04401208,
+	0x0680c009, 0x05801288, 0x02009289, 0x0700024a, 0x0a20c048,
+	0x0c7800c0, 0x094082a2, 0x095102a2, 0x0740024a, 0x0a21009f,
+	0x06800021, 0x0c7fb4c0, 0x00000000, 0x07802b88, 0x0680c009,
+	0x05801288, 0x02009289, 0x0700024a, 0x0a20c048, 0x0911084a,
+	0x0900884a, 0x0c7fb240, 0x00000000, 0x07802b89, 0x07802a0a,
+	0x0400228a, 0x0b407289, 0x04402209, 0x0440128a, 0x07802a88,
+	0x0b403289, 0x04401208, 0x04401208, 0x0680c009, 0x05802288,
+	0x02009289, 0x0700024a, 0x09002208, 0x0a60c008, 0x0c780240,
+	0x095842a2, 0x0a60c048, 0x0c780180, 0x095042a2, 0x0a60c088,
+	0x0c7800c0, 0x094842a2, 0x094042a2, 0x0740024a, 0x0a21009f,
+	0x06800021, 0x0c7faac0, 0x00000000, 0x07802b88, 0x0680c009,
+	0x05802288, 0x02009289, 0x0700024a, 0x09002208, 0x0aa1c008,
+	0x0918484a, 0x0aa14048, 0x0910484a, 0x0aa0c088, 0x0908484a,
+	0x0900484a, 0x0c7fa700, 0x00000000, 0x0c780080, 0x06800021,
+	0x0c7fa600, 0x00000000, 0x06808006, 0x0640d707, 0x0aa34007,
+	0x06410607, 0x0b003187, 0x0c780280, 0x00000000, 0x0681de27,
+	0x0c013b40, 0x04000a07, 0x0800c020, 0x08007401, 0x0640c006,
+	0x0a6fffc6, 0x00000000, 0x06412106, 0x090c1186, 0x0a6bc006,
+	0x0c7d7f80, 0x00000000, 0x06804009, 0x06012d09, 0x06800f8a,
+	0x08012e00, 0x00000000, 0x0d07ff8a, 0x00000000, 0x0cc00000,
+	0x00000000, 0x06804009, 0x06012c09, 0x06809009, 0x06012d09,
+	0x06800f8a, 0x06412e09, 0x0d07ffca, 0x06012e09, 0x0cc00000,
+	0x00000000, 0x06809009, 0x06012c09, 0x06804009, 0x06012d09,
+	0x06800f8a, 0x06412e09, 0x0d07ffca, 0x06012e09, 0x06411109,
+	0x07802708, 0x09446248, 0x06011109, 0x0cc00000, 0x00000000,
+	0x07800e08, 0x07801d09, 0x0a608009, 0x0c780880, 0x0aa18049,
+	0x0aa20089, 0x0aa640c9, 0x0a608109, 0x0c7806c0, 0x0c780000,
+	0x05801288, 0x0c780680, 0x07c01d8a, 0x05802288, 0x0540124a,
+	0x02009289, 0x0b0fe209, 0x0400128a, 0x0440224a, 0x07c01d89,
+	0x05401289, 0x0400128a, 0x0540124a, 0x02009289, 0x05401208,
+	0x0b003209, 0x07801d89, 0x0440128a, 0x0240a24a, 0x0c780200,
+	0x07c01dca, 0x0c000b40, 0x06801d8c, 0x0c780100, 0x00000000,
+	0x0c000dc0, 0x06801d8c, 0x07800e48, 0x07801d49, 0x0a608009,
+	0x0c780880, 0x0aa18049, 0x0aa20089, 0x0aa640c9, 0x0a608109,
+	0x0c7806c0, 0x0c780000, 0x05801288, 0x0c780680, 0x07c01e8a,
+	0x05802288, 0x0540124a, 0x02009289, 0x0b0fe209, 0x0400128a,
+	0x0440224a, 0x07c01e89, 0x05401289, 0x0400128a, 0x0540124a,
+	0x02009289, 0x05401208, 0x0b003209, 0x07801e89, 0x0440128a,
+	0x0240a24a, 0x0c780200, 0x07c01eca, 0x0c000200, 0x06801e8c,
+	0x0cc00000, 0x00000000, 0x0c000480, 0x06801e8c, 0x0cc00000,
+	0x00000000, 0x05802348, 0x0740030d, 0x05801248, 0x0240a349,
+	0x0400130c, 0x0740030a, 0x054012c8, 0x0200b20b, 0x058022cb,
+	0x0240a24b, 0x0400130c, 0x0740030a, 0x0cc00000, 0x00000000,
+	0x05803288, 0x0540224a, 0x02009289, 0x0b0fe209, 0x0400128a,
+	0x0440224a, 0x07400309, 0x054012c8, 0x04000349, 0x0540224a,
+	0x02009289, 0x0b0fe2c9, 0x0400128a, 0x0440224a, 0x0240a349,
+	0x0400130c, 0x0740030a, 0x054012c8, 0x0200b20b, 0x04000349,
+	0x0540224a, 0x02009289, 0x0b0fe2c9, 0x0400128a, 0x0440224a,
+	0x0240a349, 0x0400130c, 0x0740030a, 0x054022c8, 0x04000349,
+	0x0540224a, 0x02009289, 0x0b0fe2c9, 0x0400128a, 0x0440224a,
+	0x0240a349, 0x0400130c, 0x0740030a, 0x0cc00000, 0x00000000,
+	0x0640c308, 0x02008308, 0x06035108, 0x06800808, 0x06035208,
+	0x06800149, 0x0680c00a, 0x0700024b, 0x0740028b, 0x0b6105c9,
+	0x04001249, 0x0c7fff00, 0x0400128a, 0x06a0c008, 0x06035008,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06435308,
+	0x0900c208, 0x0a6f8008, 0x00000000, 0x0cc00000, 0x00000000,
+	0x0640c408, 0x02008308, 0x06035108, 0x06801408, 0x06035208,
+	0x06800609, 0x0680c00a, 0x0700024b, 0x0740028b, 0x0b611709,
+	0x04001249, 0x0c7fff00, 0x0400128a, 0x06a0c008, 0x06035008,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06435308,
+	0x0900c208, 0x0a6f8008, 0x00000000, 0x0cc00000, 0x00000000,
+	0x0640c308, 0x02008308, 0x06035108, 0x06800808, 0x06035208,
+	0x06b0c008, 0x06035008, 0x06435008, 0x0580f208, 0x0bef8048,
+	0x00000000, 0x06800149, 0x0680c00a, 0x0700028b, 0x0740024b,
+	0x0b6105c9, 0x04001249, 0x0c7fff00, 0x0400128a, 0x0cc00000,
+	0x00000000, 0x0640c408, 0x02008308, 0x06035108, 0x06801408,
+	0x06035208, 0x06b0c008, 0x06035008, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x06800609, 0x0680c00a, 0x0700028b,
+	0x0740024b, 0x0b611709, 0x04001249, 0x0c7fff00, 0x0400128a,
+	0x0cc00000, 0x00000000, 0x0640c508, 0x02008308, 0x06035108,
+	0x06801467, 0x0c00f780, 0x06435128, 0x06800c08, 0x06035208,
+	0x06801749, 0x0680c00a, 0x0700024b, 0x0740028b, 0x0b6121c9,
+	0x04001249, 0x0c7fff00, 0x0400128a, 0x06a0c008, 0x06035008,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06435308,
+	0x0900c208, 0x0a6f8008, 0x00000000, 0x07800f48, 0x0aa20008,
+	0x0540330c, 0x07801788, 0x0aa0c008, 0x06800008, 0x06900008,
+	0x0c000100, 0x0200c20c, 0x0cc00000, 0x00000000, 0x0680000d,
+	0x08070300, 0x0680c00b, 0x0680000a, 0x06470408, 0x06470409,
+	0x09508209, 0x074002c8, 0x040012cb, 0x0baeffca, 0x0400128a,
+	0x0aa3800d, 0x00000000, 0x06470508, 0x07c0fe88, 0x09210208,
+	0x07c0fec8, 0x06470608, 0x07c0ff08, 0x09210208, 0x07c0ff48,
+	0x06470708, 0x07c0ff88, 0x09210208, 0x07c0ffc8, 0x0640cd08,
+	0x02008308, 0x0540924d, 0x02008248, 0x06035108, 0x06804008,
+	0x06035208, 0x06a0c008, 0x06035008, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x0ba0c04d, 0x0cc00000, 0x00000000,
+	0x0c7ff640, 0x0400134d, 0x0640c508, 0x02008308, 0x06035108,
+	0x06801427, 0x0c00e380, 0x06435128, 0x06800c08, 0x06035208,
+	0x06b0c008, 0x06035008, 0x06435008, 0x0580f208, 0x0bef8048,
+	0x00000000, 0x06801749, 0x0680c00a, 0x0700028b, 0x0740024b,
+	0x0b6121c9, 0x04001249, 0x0c7fff00, 0x0400128a, 0x0c000e00,
+	0x00000000, 0x07800f48, 0x0aa20008, 0x0540330c, 0x07801788,
+	0x0aa0c008, 0x06800008, 0x06900008, 0x0c000100, 0x0200c20c,
+	0x0cc00000, 0x00000000, 0x0680000d, 0x08070200, 0x0640cd08,
+	0x02008308, 0x0540924d, 0x02008248, 0x06035108, 0x06804008,
+	0x06035208, 0x06b0c008, 0x06035008, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x0680c00b, 0x0680000a, 0x070002c8,
+	0x040012cb, 0x06070408, 0x09108248, 0x06070409, 0x0baeffca,
+	0x0400128a, 0x0aa3800d, 0x00000000, 0x0780fe88, 0x0780fec9,
+	0x09610209, 0x06070508, 0x0780ff08, 0x0780ff49, 0x09610209,
+	0x06070608, 0x0780ff88, 0x0780ffc9, 0x09610209, 0x06070708,
+	0x0ba0c04d, 0x0cc00000, 0x00000000, 0x0c7ff640, 0x0400134d,
+	0x07801888, 0x07801a09, 0x09421209, 0x078019c9, 0x09441209,
+	0x07801c09, 0x09461209, 0x07800f09, 0x09483209, 0x07800ec9,
+	0x094e3209, 0x07800f89, 0x09741209, 0x07801a49, 0x09761209,
+	0x07800d49, 0x07801a8a, 0x02409289, 0x09782209, 0x06011708,
+	0x06412508, 0x07801009, 0x09401209, 0x078010c9, 0x09482209,
+	0x07801109, 0x094c2209, 0x07801049, 0x09504209, 0x07801089,
+	0x09584209, 0x06800cc9, 0x09706209, 0x078008c9, 0x09442209,
+	0x0aa18009, 0x0680018a, 0x04401249, 0x0340a24a, 0x0960420a,
+	0x09808048, 0x07800909, 0x097c2209, 0x0aa18009, 0x0680018a,
+	0x04401249, 0x0340a24a, 0x0968420a, 0x09808048, 0x06012508,
+	0x06470108, 0x07800f49, 0x09401209, 0x09421209, 0x09441209,
+	0x07800d49, 0x09482209, 0x06070108, 0x06470b08, 0x078008c9,
+	0x09402209, 0x07800909, 0x09482209, 0x09502209, 0x06070b08,
+	0x06440808, 0x078012c9, 0x09401209, 0x078019c9, 0x09421209,
+	0x06040808, 0x06440c08, 0x078008c9, 0x09402209, 0x07800909,
+	0x09442209, 0x06040c08, 0x0cc00000, 0x00000000, 0x07802508,
+	0x07c04408, 0x07802548, 0x07c04448, 0x07802348, 0x07c04488,
+	0x07802448, 0x07c044c8, 0x07802308, 0x07c04508, 0x078022c8,
+	0x07c04548, 0x07800848, 0x07c045c8, 0x07800888, 0x07c04608,
+	0x07800c88, 0x07c04648, 0x07800cc8, 0x07c04688, 0x07800948,
+	0x07c046c8, 0x078023c8, 0x07c04708, 0x07802608, 0x07c04748,
+	0x07802648, 0x07c04788, 0x07802188, 0x07c047c8, 0x07802688,
+	0x07c04808, 0x07800a88, 0x07c04848, 0x07802c88, 0x07c04888,
+	0x07801c48, 0x07801cc9, 0x05401249, 0x02c08248, 0x07c048c8,
+	0x07801d08, 0x07c04908, 0x07801d48, 0x07c04948, 0x07801d88,
+	0x07c04988, 0x07801dc8, 0x07c049c8, 0x07801e08, 0x07c04a08,
+	0x07801e48, 0x07c04a48, 0x07801e88, 0x07c04a88, 0x07801ec8,
+	0x07c04ac8, 0x07801f08, 0x07c04b08, 0x07801f48, 0x07c04b48,
+	0x078020c8, 0x07c04bc8, 0x07802108, 0x07c04c08, 0x07802848,
+	0x07c04c48, 0x07802888, 0x07c04c88, 0x07801ac8, 0x07c04cc8,
+	0x07801b08, 0x07c04d08, 0x07802248, 0x07c04d48, 0x078014c8,
+	0x07c04e08, 0x07801508, 0x07c04e48, 0x07801548, 0x07c04e88,
+	0x07801588, 0x07c04ec8, 0x078008c8, 0x07800909, 0x09484209,
+	0x07c04f08, 0x07801608, 0x07c05808, 0x07801648, 0x07c05848,
+	0x07801688, 0x07c05888, 0x078016c8, 0x07c058c8, 0x07801708,
+	0x07c05908, 0x07800808, 0x07c05948, 0x06800009, 0x07801148,
+	0x0a20c048, 0x07801008, 0x09809009, 0x0a20c048, 0x07801f88,
+	0x09809049, 0x0a20c048, 0x07802008, 0x09809089, 0x0a20c048,
+	0x07802048, 0x098090c9, 0x0a20c048, 0x07802088, 0x09809109,
+	0x0a20c048, 0x078027c8, 0x09809149, 0x0a20c048, 0x07802808,
+	0x09809189, 0x0a20c048, 0x07802488, 0x098091c9, 0x0a20c048,
+	0x078024c8, 0x09809209, 0x0a20c048, 0x078028c8, 0x09809249,
+	0x0a20c048, 0x00000000, 0x09809289, 0x07c04b89, 0x0680500a,
+	0x06802d48, 0x07000209, 0x07400289, 0x0400128a, 0x0baf7508,
+	0x04001208, 0x0640c108, 0x06035108, 0x06802008, 0x06035208,
+	0x06a04008, 0x06035008, 0x06435008, 0x0580f208, 0x0bef8048,
+	0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008, 0x00000000,
+	0x0cc00000, 0x00000000, 0x06460308, 0x093e1208, 0x0a6f8008,
+	0x00000000, 0x06420408, 0x09c08748, 0x06020408, 0x06460108,
+	0x0a216008, 0x00000000, 0x06460408, 0x0a2fc048, 0x00000000,
+	0x06460408, 0x06060408, 0x0cc00000, 0x00000000, 0x0800cf00,
+	0x0800c0ff, 0x06800009, 0x0680ffca, 0x07000248, 0x09808408,
+	0x0600cf08, 0x00000000, 0x0640cf08, 0x0a6fc008, 0x0b403289,
+	0x0c7ffe40, 0x04001249, 0x0cc00000, 0x00000000, 0x0680000a,
+	0x0680000b, 0x06804008, 0x07000209, 0x0580f209, 0x0be20048,
+	0x0580e209, 0x0a20c048, 0x0400128a, 0x040012cb, 0x06804008,
+	0x0bae040a, 0x02008288, 0x07c02c4b, 0x0cc00000, 0x00000000,
+	0x06800009, 0x07c02c49, 0x068003ca, 0x068043c8, 0x07400209,
+	0x0440128a, 0x0aef800a, 0x04401208, 0x06a00009, 0x07400209,
+	0x0cc00000, 0x00000000, 0x06800048, 0x07c02608, 0x07c02448,
+	0x0cc00000, 0x00000000, 0x06802d4d, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa10009, 0x07c02c89, 0x0c0003c0, 0x0780250c,
+	0x0a62c00b, 0x00000000, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0aa18009, 0x07802c89, 0x09809049, 0x07c02c89, 0x0c000100,
+	0x0780254c, 0x0cc00000, 0x00000000, 0x07802c48, 0x0b21c088,
+	0x06800049, 0x0b214108, 0x06800089, 0x0b20c208, 0x068000c9,
+	0x06800109, 0x0680080a, 0x0240a24a, 0x098091c9, 0x06410c08,
+	0x06010e09, 0x03808288, 0x07400348, 0x0400134d, 0x0aeec04c,
+	0x0440130c, 0x0cc00000, 0x00000000, 0x06460409, 0x09001289,
+	0x0aaf800a, 0x00000000, 0x0cc00000, 0x00000000, 0x07802b88,
+	0x0680d009, 0x02009209, 0x0700024d, 0x07802bc8, 0x0680ee09,
+	0x02009209, 0x0700024e, 0x0680000f, 0x0ac0338d, 0x06ee000f,
+	0x06ea000f, 0x06050a0f, 0x07802b88, 0x0b615e08, 0x0680d009,
+	0x02009209, 0x07802d0d, 0x0740024d, 0x07802bc8, 0x0b615108,
+	0x0680ee09, 0x02009209, 0x07802d0e, 0x0740024e, 0x0cc00000,
+	0x00000000, 0x07800863, 0x068003e4, 0x05408924, 0x0b813923,
+	0x078014e3, 0x054108e3, 0x07801525, 0x02c23963, 0x07801564,
+	0x05410924, 0x078015a5, 0x02c24964, 0x0aa28023, 0x0aa24024,
+	0x054059a3, 0x024268e6, 0x0ac06926, 0x00000000, 0x0800c080,
+	0x08007401, 0x0c780000, 0x00000000, 0x0cc00000, 0x00000000,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x0640c708,
+	0x07803809, 0x05408249, 0x02008248, 0x06035108, 0x08035280,
+	0x06bd0008, 0x06035008, 0x07803809, 0x04001249, 0x07c03809,
+	0x06810009, 0x07c037c9, 0x06462308, 0x09808288, 0x06062308,
+	0x06462d08, 0x09808048, 0x06062d08, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x0cc00000, 0x00000000, 0x06463908,
+	0x09105248, 0x0aa40009, 0x078037ca, 0x07000288, 0x0400128a,
+	0x0700028b, 0x0961020b, 0x06063808, 0x0400128a, 0x07c037ca,
+	0x06812008, 0x0b8f620a, 0x04401249, 0x0c07f540, 0x00000000,
+	0x0c7ffc00, 0x00000000, 0x0cc00000, 0x00000000, 0x07803ae5,
+	0x0aa0c025, 0x0c783200, 0x00000000, 0x067f2f23, 0x0befc063,
+	0x0a20c0a3, 0x0c07ec00, 0x00000000, 0x0640c023, 0x0a617fa3,
+	0x00000000, 0x06803ba7, 0x0c005d80, 0x04000a26, 0x0a6d7fe3,
+	0x00000000, 0x078038a3, 0x078038e6, 0x096108e6, 0x06410d26,
+	0x024268e6, 0x0640d723, 0x0aa3c023, 0x00000000, 0x068000e7,
+	0x04000a26, 0x0c005a00, 0x09610a23, 0x044018e3, 0x0b8088e6,
+	0x00000000, 0x0800c00e, 0x08007401, 0x0640c023, 0x0a6fffe3,
+	0x0c7ff800, 0x00000000, 0x0640d223, 0x0be0c063, 0x0908c9a3,
+	0x06800026, 0x040019a6, 0x0aa10066, 0x068004a7, 0x0c005580,
+	0x04000a26, 0x06410b23, 0x098230a3, 0x06010b23, 0x0640d724,
+	0x0aa48024, 0x06410625, 0x0680fa23, 0x06410624, 0x0a40e964,
+	0x0aef8023, 0x044018e3, 0x06808023, 0x0b40a8e4, 0x00000000,
+	0x0681de67, 0x0c005140, 0x04000a07, 0x0800c022, 0x08007401,
+	0x0640c023, 0x0a6fffe3, 0x00000000, 0x06412123, 0x0a2b0063,
+	0x00000000, 0x0d07f8e6, 0x00000000, 0x06410c23, 0x06814027,
+	0x0c004dc0, 0x04000a23, 0x058089a3, 0x0aa18026, 0x06802424,
+	0x0aa10066, 0x06802224, 0x0c780380, 0x00000000, 0x06010e24,
+	0x06802424, 0x06010e24, 0x06410823, 0x098233a3, 0x06010823,
+	0x09c233a3, 0x06010823, 0x06410c23, 0x06814067, 0x0c004900,
+	0x04000a23, 0x07803a65, 0x0aa18025, 0x07803aa5, 0x0a6080e5,
+	0x0c781bc0, 0x0a608125, 0x0c782400, 0x07803aa5, 0x092109a3,
+	0x069f8064, 0x0a80e926, 0x069f0064, 0x0a805926, 0x0aa08125,
+	0x0c780440, 0x0c780400, 0x00000000, 0x0640d224, 0x05814924,
+	0x0be0c064, 0x0c7802c0, 0x00000000, 0x0c7814c0, 0x06801065,
+	0x0a6dc125, 0x06802424, 0x06010e24, 0x06800424, 0x0d000024,
+	0x00000000, 0x06410c23, 0x092039a3, 0x07c04da6, 0x093269a3,
+	0x07c04de6, 0x06410d23, 0x06410b23, 0x0600d326, 0x06802467,
+	0x0c003ec0, 0x04000a26, 0x0a6288a6, 0x00000000, 0x0640ce24,
+	0x0a21c0a4, 0x06411624, 0x093e1924, 0x0aa10024, 0x06440123,
+	0x0a2fc063, 0x00000000, 0x08012101, 0x0640d224, 0x0a60c926,
+	0x058108e4, 0x0a20c063, 0x0a214064, 0x00000000, 0x0800c009,
+	0x0c7fda00, 0x08007401, 0x0a61ca26, 0x05812964, 0x0be0c065,
+	0x0c780a40, 0x06803c25, 0x0c7809c0, 0x068010a5, 0x0a6149e6,
+	0x05811964, 0x0a20c065, 0x0c780880, 0x068001e5, 0x0640d224,
+	0x0be580a4, 0x09042924, 0x0a60c0e4, 0x068003e3, 0x07c036a3,
+	0x06803c25, 0x078036a3, 0x0aa3c826, 0x0a25c063, 0x0aa34866,
+	0x0aa308a6, 0x0a2500a3, 0x0a24c123, 0x0aa24064, 0x0be18223,
+	0x0a20c0a4, 0x0b218566, 0x0c780380, 0x0aa08526, 0x0a6304e6,
+	0x098230e3, 0x07c036a3, 0x0aa24826, 0x06800065, 0x0aa1c866,
+	0x068000a5, 0x0aa148a6, 0x068000e5, 0x0b20c566, 0x06800125,
+	0x06803c25, 0x0ae0c566, 0x0a60bc25, 0x00000000, 0x068000a7,
+	0x0c002d40, 0x04000a25, 0x0600c025, 0x08030504, 0x0c7fcc80,
+	0x00000000, 0x06801425, 0x092109a3, 0x069f8064, 0x0a40a926,
+	0x093269a3, 0x06802424, 0x06010e24, 0x06800424, 0x0d000024,
+	0x00000000, 0x06410c24, 0x093269a4, 0x06801465, 0x0aa38826,
+	0x06800064, 0x0aa30866, 0x068000a4, 0x0aa288a6, 0x068000e4,
+	0x0aa209e6, 0x068001e4, 0x0b218566, 0x06800124, 0x0aa11465,
+	0x06803c24, 0x0c7fdec0, 0x00000000, 0x0c000bc0, 0x00000000,
+	0x0600d324, 0x0600c025, 0x0c7fc440, 0x08007401, 0x0c7fdf40,
+	0x00000000, 0x092109a3, 0x069f0064, 0x0a8fc926, 0x069f8064,
+	0x0a404926, 0x093269a3, 0x0c7fdac0, 0x00000000, 0x0aa2c826,
+	0x06800064, 0x0aa24866, 0x068000a4, 0x0aa1c8a6, 0x068000e4,
+	0x0aa149e6, 0x068001e4, 0x0b20c566, 0x06800124, 0x06803c24,
+	0x0c000500, 0x00000000, 0x0600d324, 0x0800c050, 0x0c7fbd80,
+	0x08007401, 0x06806008, 0x07c03a08, 0x06800008, 0x07c03948,
+	0x0640d608, 0x09210248, 0x07c03909, 0x07c039c9, 0x09010248,
+	0x078039c8, 0x02009209, 0x07c03989, 0x0cc00000, 0x00000000,
+	0x07803948, 0x078039c9, 0x0780390a, 0x02409289, 0x09610248,
+	0x0600d609, 0x06806008, 0x07c03a08, 0x06800008, 0x07c03948,
+	0x07803909, 0x07c039c9, 0x0cc00000, 0x00000000, 0x06410c08,
+	0x06802209, 0x06010e09, 0x09308208, 0x0950820e, 0x0c000640,
+	0x0680000e, 0x06410b08, 0x09181208, 0x0aadc008, 0x00000000,
+	0x0c000d80, 0x00000000, 0x0cc00000, 0x00000000, 0x06410c08,
+	0x06802209, 0x06010e09, 0x09308208, 0x0950820e, 0x0c000340,
+	0x0680000e, 0x06410b08, 0x09181208, 0x0aadc008, 0x00000000,
+	0x0c000c80, 0x00000000, 0x0cc00000, 0x00000000, 0x0680394b,
+	0x0c780100, 0x0780390c, 0x068039cb, 0x0780398c, 0x0444030c,
+	0x07803a09, 0x07400248, 0x04001249, 0x0680680a, 0x0b817289,
+	0x00000000, 0x0640d509, 0x070002ca, 0x0ac1230a, 0x0540430a,
+	0x02009309, 0x06035109, 0x0400428a, 0x074002ca, 0x06800809,
+	0x06035209, 0x06a06009, 0x06035009, 0x06435009, 0x0580f249,
+	0x0bef8049, 0x00000000, 0x06435309, 0x0900c249, 0x0a6f8009,
+	0x00000000, 0x06806009, 0x0cc00000, 0x07c03a09, 0x06800008,
+	0x07803a09, 0x0680600a, 0x0a806289, 0x00000000, 0x0c07f600,
+	0x00000000, 0x0c7ffe80, 0x00000000, 0x0cc00000, 0x00000000,
+	0x06800008, 0x07803a09, 0x0680600a, 0x0a806289, 0x00000000,
+	0x0c07f400, 0x00000000, 0x0c7ffe80, 0x00000000, 0x0cc00000,
+	0x00000000, 0x0600d128, 0x078036e8, 0x0aa18028, 0x00000000,
+	0x0600d027, 0x08007401, 0x0640d027, 0x0a6fc027, 0x00000000,
+	0x0cc00000, 0x00000000, 0x0600d128, 0x078036e8, 0x0aa54028,
+	0x00000000, 0x0640cf28, 0x06035128, 0x0680fc28, 0x06035228,
+	0x06a00028, 0x06035028, 0x06435028, 0x0580fa28, 0x0bef8068,
+	0x00000000, 0x06435328, 0x0900ca28, 0x0a6f8028, 0x00000000,
+	0x09827427, 0x0600d027, 0x08007401, 0x0640d027, 0x0a6fc027,
+	0x0cc00000, 0x00000000, 0x06810028, 0x06800008, 0x06410c27,
+	0x08010e90, 0x092109e7, 0x07400227, 0x0d07ff28, 0x04001208,
+	0x0cc00000, 0x00000000, 0x0aa54029, 0x04000a29, 0x0640d427,
+	0x090109e7, 0x0a411a27, 0x0640d427, 0x092029e7, 0x0a614067,
+	0x00000000, 0x0c07f500, 0x06800028, 0x0c780180, 0x0a6d80e7,
+	0x00000000, 0x0c07fa00, 0x00000000, 0x0c780040, 0x04000a29,
+	0x0600d428, 0x0c7ffbc0, 0x00000000, 0x0cc00000, 0x00000000,
+	0x07800848, 0x07800889, 0x09610209, 0x06012308, 0x06800208,
+	0x07800d49, 0x03408248, 0x06040608, 0x07800849, 0x0780088a,
+	0x0960f24a, 0x06040209, 0x07800e09, 0x07800e4a, 0x0960c24a,
+	0x06040309, 0x08040400, 0x0cc00000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -813,786 +1614,20 @@ const u32  vh265_mc[] __initconst = {
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000
 };
 
-
 #define FOR_VFORMAT VFORMAT_HEVC
 
+
+#define FOR_CPUS_MMU {	MESON_CPU_MAJOR_ID_GXL, \
+						MESON_CPU_MAJOR_ID_GXM, \
+						MESON_CPU_MAJOR_ID_TXL, 0}
+
 #define REG_FIRMWARE_ALL()\
+	do {\
 		DEF_FIRMWARE_VER(vh265_mc, VERSTR);\
-
+		DEF_FIRMWARE_FOR_CPUS_TYPE_VER(FOR_CPUS_MMU, \
+		FOR_VFORMAT, vh265_mc_mmu, VERSTR_MMU);\
+	} while (0)
 INIT_DEF_FIRMWARE();
 
diff --git a/drivers/amlogic/amports/arch/ucode/mjpeg/vmjpeg_mc.c b/drivers/amlogic/amports/arch/ucode/mjpeg/vmjpeg_mc.c
index fc84738..2d2a2fe 100644
--- a/drivers/amlogic/amports/arch/ucode/mjpeg/vmjpeg_mc.c
+++ b/drivers/amlogic/amports/arch/ucode/mjpeg/vmjpeg_mc.c
@@ -240,10 +240,229 @@ static const u32 vmjpeg_mc[] __initconst = {
 	0x0649ce28, 0x0a6f4028, 0x00000000, 0x0cc00000, 0x00000000
 };
 
+static const u32 vmmjpeg_mc[] __initconst = {
+	0x00000000, 0x00000000, 0x06801801, 0x06800000, 0x0d000001,
+	0x07400040, 0x0680c000, 0x060c2900, 0x06800000, 0x060c0800,
+	0x080c0002, 0x06bfbfc0, 0x06030400, 0x0809c900, 0x0809c800,
+	0x0c010340, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x0649c00c, 0x07c0118c,
+	0x0649c10c, 0x0c780980, 0x00400000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000,
+	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0cc00000, 0x00400000, 0x0c780640, 0x064c0007,
+	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x00000000, 0x00000000, 0x0cc00000, 0x00400000,
+	0x00000000, 0x00000000, 0x0cc00000, 0x00400000, 0x04807410,
+	0x0aafc010, 0x0649c810, 0x0c00f5c0, 0x00800000, 0x0c7ffec0,
+	0x00400000, 0x0c7ffdc0, 0x080c0000, 0x0be0c807, 0x0bef4047,
+	0x0c7ffcc0, 0x09c09147, 0x060c0009, 0x0c00f540, 0x0680020f,
+	0x040001cf, 0x0aaf7fc7, 0x0aa27607, 0x0aa0f647, 0x0c783280,
+	0x00000000, 0x06800007, 0x07c00c07, 0x080c0800, 0x0c7866c0,
+	0x00000000, 0x0c00f200, 0x0680020f, 0x0400020f, 0x0a653fc8,
+	0x07800c08, 0x0a61c048, 0x00000000, 0x06800048, 0x07c00648,
+	0x06800448, 0x0c780100, 0x07c00c08, 0x06800048, 0x07c00c08,
+	0x06bfffc8, 0x07c01048, 0x06800008, 0x07c01008, 0x0c00ed80,
+	0x0680020f, 0x040001cf, 0x0c7ff840, 0x00000000, 0x0c786080,
+	0x00000000, 0x07800c48, 0x0aa08388, 0x0c783240, 0x06905589,
+	0x0c00eac0, 0x0680040f, 0x040001cf, 0x04402208, 0x07c00c48,
+	0x0a4f9247, 0x06924c49, 0x0c00e900, 0x0680040f, 0x040001cf,
+	0x04402208, 0x07c00c48, 0x0a4f2247, 0x0c00e780, 0x0680020f,
+	0x040001cf, 0x04401208, 0x07c00c48, 0x0aa10047, 0x0aa1c087,
+	0x0c7ffa80, 0x00000000, 0x068003c7, 0x07c011c7, 0x0c7ff980,
+	0x00000000, 0x06800387, 0x07c011c7, 0x0c7ff880, 0x00000000,
+	0x07800c48, 0x0aa08a08, 0x0c7810c0, 0x0c00e280, 0x0680040f,
+	0x040001cf, 0x04402208, 0x07c00c48, 0x0aa08007, 0x0c780f00,
+	0x0c00e0c0, 0x0680040f, 0x040001cf, 0x04402208, 0x07c00c48,
+	0x0aa08007, 0x0c780d40, 0x069b5a89, 0x0c00dec0, 0x0680040f,
+	0x040001cf, 0x04402208, 0x07c00c48, 0x0a42e247, 0x0c00dd40,
+	0x0680040f, 0x040001cf, 0x04402208, 0x07c00c48, 0x069c19c9,
+	0x0a808247, 0x069c1889, 0x0a803247, 0x0c780900, 0x00000000,
+	0x06800049, 0x0c780100, 0x07c01209, 0x06800009, 0x07c01209,
+	0x0c00d940, 0x0680040f, 0x040001cf, 0x0c00d880, 0x0680040f,
+	0x040001cf, 0x0c00d7c0, 0x0680040f, 0x040001cf, 0x0c00d700,
+	0x0680040f, 0x040001cf, 0x0c00d640, 0x0680040f, 0x040001cf,
+	0x0440a208, 0x07c00c48, 0x0a63c007, 0x068001c7, 0x0c00d480,
+	0x0680040f, 0x040001cf, 0x04402208, 0x07c00c48, 0x0a620007,
+	0x068001c7, 0x078011c7, 0x0aa141c7, 0x06800187, 0x06800009,
+	0x0c7818c0, 0x07c01209, 0x07c011c7, 0x0c781800, 0x00000000,
+	0x0c7fde80, 0x00000000, 0x07800c49, 0x0a614009, 0x00000000,
+	0x06800009, 0x0c784340, 0x07c00c09, 0x07800c08, 0x09808048,
+	0x07c00c08, 0x0b60d049, 0x0c780a40, 0x00000000, 0x00000000,
+	0x0c00ccc0, 0x0680020f, 0x0400020f, 0x07c00c88, 0x06800007,
+	0x06c00047, 0x060e0207, 0x06800007, 0x06c00047, 0x060e0207,
+	0x06b63fca, 0x06c0000a, 0x0be383c8, 0x06800808, 0x0c00c940,
+	0x0680040f, 0x040001cf, 0x090101c7, 0x0a403287, 0x0c7ff780,
+	0x00000000, 0x0d07fe48, 0x060e0207, 0x04441249, 0x0c7ff900,
+	0x07c00c49, 0x0c00c640, 0x0680040f, 0x040001cf, 0x090101c7,
+	0x0a403287, 0x0c7ff480, 0x00000000, 0x0d07fe48, 0x060e0307,
+	0x04441249, 0x0c7ff600, 0x07c00c49, 0x0aa0c009, 0x0c00b400,
+	0x060c2009, 0x0c7836c0, 0x00000000, 0x06800007, 0x0c783600,
+	0x07c00c07, 0x07800c08, 0x0a2e8048, 0x07800648, 0x0aa0c008,
+	0x07800c08, 0x0a2e0408, 0x048f8207, 0x0a617408, 0x07800c08,
+	0x0a2d0208, 0x0c785f80, 0x00000000, 0x0c00be40, 0x0680040f,
+	0x0400020f, 0x0b2b8088, 0x04402208, 0x07c00c48, 0x0aaac007,
+	0x0aa6f007, 0x0aa43747, 0x046db207, 0x0c57ebc0, 0x046c4207,
+	0x0c503300, 0x046da207, 0x0c504d00, 0x046e1207, 0x0c57d700,
+	0x00000000, 0x046e0207, 0x0c57cdc0, 0x00000000, 0x07800c48,
+	0x0c782d00, 0x00000000, 0x07800c49, 0x0aa0c089, 0x0c7ff480,
+	0x00000000, 0x0c00b740, 0x0680040f, 0x0400020f, 0x07c01048,
+	0x0c782a80, 0x07c01008, 0x083f00c0, 0x083f0000, 0x0c00b540,
+	0x0680020f, 0x040001cf, 0x0c00b480, 0x0680040f, 0x0400020f,
+	0x0c00b3c0, 0x0680040f, 0x040001cf, 0x0649c209, 0x0908b249,
+	0x0aa18009, 0x0b005248, 0x00000000, 0x06800009, 0x0c7825c0,
+	0x07c00c09, 0x078011c9, 0x0a220109, 0x0649c209, 0x0908b249,
+	0x0aa40009, 0x0a80e209, 0x06800009, 0x0c780340, 0x00000000,
+	0x0be2c209, 0x0649c209, 0x0908b249, 0x05801249, 0x0a406209,
+	0x06800009, 0x078011c9, 0x0a20c049, 0x068000c9, 0x06800089,
+	0x07c011c9, 0x07c004c7, 0x07c00508, 0x06800009, 0x07c005c9,
+	0x07c00589, 0x07c00549, 0x07800989, 0x0480f249, 0x05404249,
+	0x0609c309, 0x07800c49, 0x0400f1c7, 0x058041c7, 0x064c5108,
+	0x064c4612, 0x064c4207, 0x064c400a, 0x02407287, 0x040081c7,
+	0x0580a1c7, 0x0e000207, 0x02412292, 0x00000000, 0x00000000,
+	0x0f0001c0, 0x0f010200, 0x097081c8, 0x0540a1c7, 0x02007487,
+	0x064c4308, 0x02407207, 0x07c01487, 0x058101c7, 0x07c014c7,
+	0x078004c7, 0x07800508, 0x040071c7, 0x058031c7, 0x060c0907,
+	0x07c00607, 0x07c002c7, 0x04007208, 0x05803208, 0x07c00308,
+	0x0c00a100, 0x0680020f, 0x040001cf, 0x0aa180c7, 0x00000000,
+	0x06800007, 0x07c00c07, 0x0c781380, 0x00000000, 0x0aa0c3c9,
+	0x0c781140, 0x00000000, 0x0c009e00, 0x0680020f, 0x040001cf,
+	0x07c00cc7, 0x0c009d00, 0x0680010f, 0x040001cf, 0x07c00d07,
+	0x0aa28047, 0x06800049, 0x0a600087, 0x06800089, 0x078002c8,
+	0x04001208, 0x05801208, 0x07c002c8, 0x05401208, 0x07c00608,
+	0x0c009980, 0x0680010f, 0x040001cf, 0x07c00d47, 0x0aa1c047,
+	0x0a600087, 0x07800308, 0x04001208, 0x05801208, 0x07c00308,
+	0x05401249, 0x07c00409, 0x0c009680, 0x0680020f, 0x040001cf,
+	0x07c00d87, 0x0c009580, 0x0680020f, 0x040001cf, 0x07c00dc7,
+	0x0c009480, 0x0680010f, 0x040001cf, 0x07c00e07, 0x0c009380,
+	0x0680010f, 0x040001cf, 0x07c00e47, 0x0c009280, 0x0680020f,
+	0x040001cf, 0x07c00e87, 0x0c009180, 0x0680020f, 0x040001cf,
+	0x07c00ec7, 0x0c009080, 0x0680010f, 0x040001cf, 0x07c00f07,
+	0x0c008f80, 0x0680010f, 0x040001cf, 0x07c00f47, 0x0c008e80,
+	0x0680020f, 0x040001cf, 0x07c00f87, 0x0c780140, 0x0aa10009,
+	0x060c2009, 0x0c007dc0, 0x00000000, 0x0c780080, 0x00000000,
+	0x07800c07, 0x0a220047, 0x080c0800, 0x0c008b00, 0x0680020f,
+	0x040001cf, 0x0a6f7fc7, 0x0c7f94c0, 0x00000000, 0x080c0002,
+	0x0c7f9000, 0x00000000, 0x0c7819c0, 0x00000000, 0x07800c09,
+	0x09809089, 0x07c00c09, 0x07800c49, 0x0bae8449, 0x00000000,
+	0x0c0086c0, 0x0680020f, 0x0400020f, 0x04401249, 0x0a20bc08,
+	0x0c780a00, 0x0480f208, 0x0aa0c008, 0x0aa14048, 0x0c7ffbc0,
+	0x06801804, 0x0c780100, 0x06801c06, 0x06802404, 0x06802806,
+	0x06800005, 0x06800007, 0x0680040a, 0x07400187, 0x04001186,
+	0x0c0081c0, 0x0680020f, 0x0400020f, 0x02007207, 0x02005205,
+	0x05401145, 0x0340b285, 0x058022cb, 0x0740010b, 0x0d07fd4a,
+	0x04001104, 0x04410249, 0x0b22c007, 0x0b80a1c9, 0x024091c9,
+	0x0c007e00, 0x0680020f, 0x0400020f, 0x07400188, 0x0d07ff07,
+	0x04001186, 0x0c7ff540, 0x00000000, 0x0c780d00, 0x00000000,
+	0x0480f208, 0x0aa14008, 0x0aa1c048, 0x06800007, 0x0c7feec0,
+	0x07c00c07, 0x06800004, 0x0c780100, 0x06803406, 0x06800044,
+	0x06805806, 0x060c2104, 0x06800005, 0x06800007, 0x0680040a,
+	0x0c0077c0, 0x0680020f, 0x0400020f, 0x02007207, 0x0ba0c08a,
+	0x00000000, 0x060c2607, 0x02005205, 0x05401145, 0x0340b285,
+	0x058022cb, 0x0ba0c08a, 0x00000000, 0x060c220b, 0x0d07fc8a,
+	0x00000000, 0x04410249, 0x0b8121c9, 0x024091c9, 0x0b220047,
+	0x05801107, 0x0c007280, 0x0680040f, 0x0400020f, 0x07400188,
+	0x0d07ff04, 0x04001186, 0x0a21c047, 0x00000000, 0x0c007080,
+	0x0680020f, 0x0400020f, 0x05408208, 0x07400188, 0x0c7fe800,
+	0x0aa0c009, 0x0c005fc0, 0x060c2009, 0x0c7fe280, 0x00000000,
+	0x07800c09, 0x098090c9, 0x07c00c09, 0x07801209, 0x0aa0c049,
+	0x06800009, 0x06801009, 0x060c0809, 0x07800c49, 0x0c006b80,
+	0x0680020f, 0x0400020f, 0x04401249, 0x0b2140c8, 0x00000000,
+	0x06800007, 0x0c7fde00, 0x07c00c07, 0x07c00108, 0x06800146,
+	0x0c0068c0, 0x0680020f, 0x040001cf, 0x07800d8a, 0x07800cc4,
+	0x0a808107, 0x07800405, 0x07800e8a, 0x07800dc4, 0x0a804107,
+	0x06810045, 0x06814045, 0x07800f8a, 0x0958414a, 0x07400185,
+	0x04001186, 0x0c0064c0, 0x0680020f, 0x040001cf, 0x07400187,
+	0x04402249, 0x0d07fac8, 0x04001186, 0x0c006300, 0x0680040f,
+	0x040001cf, 0x0c006240, 0x0680020f, 0x040001cf, 0x04403249,
+	0x0aa0c009, 0x0c005200, 0x060c2009, 0x080c0a10, 0x080c2c01,
+	0x06800004, 0x07c00004, 0x07c00044, 0x080c2a00, 0x06800004,
+	0x098047c4, 0x060c2d04, 0x098043c4, 0x060c2f04, 0x06800004,
+	0x07c00084, 0x07800084, 0x07800146, 0x0aa1c004, 0x07800185,
+	0x078001c6, 0x0aa10044, 0x07800205, 0x07800246, 0x07800285,
+	0x09184106, 0x0aa0c004, 0x0680050a, 0x0680070a, 0x09104106,
+	0x0ba0c104, 0x060c2a04, 0x04403104, 0x07c00484, 0x09003106,
+	0x07c00444, 0x09084105, 0x0aa0c004, 0x06801806, 0x06802406,
+	0x07c00386, 0x09004105, 0x060c2104, 0x0aa0c004, 0x06803404,
+	0x06805804, 0x07c003c4, 0x06800004, 0x07c00344, 0x07800384,
+	0x064c2a07, 0x04004144, 0x07000146, 0x0b82c187, 0x04006144,
+	0x07000146, 0x0b823187, 0x04007144, 0x07000146, 0x0b838187,
+	0x068001c6, 0x04008144, 0x07000146, 0x0b834187, 0x06800206,
+	0x04009144, 0x07000146, 0x0b830187, 0x06800246, 0x0400a144,
+	0x07000146, 0x0b82c187, 0x06800286, 0x0400b144, 0x07000146,
+	0x0b828187, 0x068002c6, 0x0400c144, 0x07000146, 0x0b824187,
+	0x06800306, 0x0400d144, 0x07000146, 0x0b820187, 0x06800346,
+	0x0400e144, 0x07000146, 0x0b81c187, 0x06800386, 0x0c780680,
+	0x068003c6, 0x04005144, 0x07000146, 0x0b816187, 0x06800146,
+	0x0c780500, 0x06800186, 0x04002144, 0x07000146, 0x0b807187,
+	0x04003144, 0x07000146, 0x0b80d187, 0x068000c6, 0x0c7802c0,
+	0x06800106, 0x04001144, 0x07000146, 0x0b407187, 0x06800086,
+	0x07000106, 0x0b404187, 0x06800046, 0x0c780080, 0x06800006,
+	0x04001206, 0x0c004440, 0x040003c8, 0x040001cf, 0x0aa20006,
+	0x02005184, 0x04401145, 0x07000145, 0x068003c8, 0x02408188,
+	0x03805205, 0x02407147, 0x04010104, 0x02006184, 0x07000186,
+	0x020061c6, 0x04010104, 0x02006184, 0x07000186, 0x064c2404,
+	0x00000000, 0x0a20c3c4, 0x0c7fff40, 0x00000000, 0x060c2306,
+	0x060e000a, 0x078003c9, 0x064c2503, 0x0a2fe003, 0x0a211003,
+	0x09005103, 0x0c780240, 0x00000000, 0x09127203, 0x02008209,
+	0x07000208, 0x060c2708, 0x0f8001c4, 0x0c7ffd40, 0x080c2440,
+	0x078005c4, 0x0be14044, 0x00000000, 0x04c01104, 0x0c002d40,
+	0x07c005c4, 0x06800045, 0x07800007, 0x07800048, 0x07800484,
+	0x0a670004, 0x07800d06, 0x0aa18046, 0x07800346, 0x054011c7,
+	0x04801186, 0x02c07187, 0x0c780240, 0x07800d46, 0x0aa3c046,
+	0x07800346, 0x05401208, 0x04801186, 0x09461146, 0x02c08188,
+	0x0c780240, 0x07800d46, 0x0aa1c046, 0x00000000, 0x05401208,
+	0x07800346, 0x09021186, 0x09461146, 0x02c08188, 0x0649c306,
+	0x09104186, 0x0c780340, 0x094c4146, 0x0649c306, 0x07800d0a,
+	0x0a60c04a, 0x09142246, 0x04001249, 0x09502149, 0x07800d4a,
+	0x0a60c04a, 0x09102246, 0x04001249, 0x094c2149, 0x0aa0c007,
+	0x0c780140, 0x09482144, 0x09805045, 0x0c780080, 0x09482144,
+	0x06491e06, 0x0befc146, 0x00000000, 0x06091c07, 0x06091d08,
+	0x06091b05, 0x07800606, 0x0aa14004, 0x07800d08, 0x0aa0c048,
+	0x00000000, 0x05801186, 0x040011c7, 0x0b807187, 0x09805285,
+	0x06491e06, 0x0befc146, 0x00000000, 0x06091c07, 0x06091b05,
+	0x080c2480, 0x07800344, 0x04001104, 0x07800445, 0x0b403144,
+	0x0c7fd180, 0x07c00344, 0x07800084, 0x04001104, 0x07800105,
+	0x0b403144, 0x0c7fc7c0, 0x07c00084, 0x07800004, 0x04001104,
+	0x078002c5, 0x0b813144, 0x07c00004, 0x06800004, 0x07c00004,
+	0x07800044, 0x04001104, 0x0c002000, 0x00000000, 0x07800547,
+	0x07800d46, 0x02007187, 0x07c00547, 0x07800305, 0x0b40f144,
+	0x07c00044, 0x0ba10207, 0x00000000, 0x06800004, 0x07c00544,
+	0x07801004, 0x0aa0c004, 0x0aa10044, 0x04401104, 0x0c7fc040,
+	0x07c01004, 0x07801044, 0x0c7f93c0, 0x07c01004, 0x06800104,
+	0x07c005c4, 0x064c2404, 0x0befc3c4, 0x00000000, 0x0803ffa5,
+	0x06491e04, 0x0befc184, 0x00000000, 0x08091007, 0x00000000,
+	0x00000000, 0x08091000, 0x080c0800, 0x06800004, 0x07c00c04,
+	0x0480710c, 0x0780098d, 0x0480134d, 0x0946110d, 0x0649c20d,
+	0x091e134d, 0x0aa1000d, 0x078011cd, 0x0480334d, 0x0aa540cd,
+	0x078011cd, 0x0480f34d, 0x0948410d, 0x07801488, 0x078014c7,
+	0x09610207, 0x0609ca08, 0x0609c904, 0x08007401, 0x00800000,
+	0x0c7fffc0, 0x0c001140, 0x00000000, 0x0649c904, 0x0a6ec004,
+	0x00000000, 0x07801184, 0x04403104, 0x07c01184, 0x0580330c,
+	0x0c000f00, 0x00000000, 0x0aaf800c, 0x00000000, 0x0649c204,
+	0x0480f104, 0x07c00984, 0x0c7f83c0, 0x00000000, 0x064c2908,
+	0x09808288, 0x060c2908, 0x00000000, 0x0c000bc0, 0x00000000,
+	0x064c2908, 0x09141208, 0x0a6f0008, 0x0cc00000, 0x00000000,
+	0x048071cc, 0x044011c7, 0x054011c7, 0x06801288, 0x07000207,
+	0x04001208, 0x07000208, 0x09610207, 0x06092d08, 0x078011c8,
+	0x0aa28388, 0x0aa103c8, 0x078011c8, 0x04803208, 0x0a618088,
+	0x06492d08, 0x06830307, 0x06c00307, 0x020081c8, 0x06092d08,
+	0x06802a87, 0x06092107, 0x08091600, 0x08091700, 0x078004c7,
+	0x06091407, 0x078004c7, 0x06091207, 0x07800507, 0x06091307,
+	0x0649c308, 0x09102208, 0x03807207, 0x06091507, 0x06a04007,
+	0x0649c308, 0x048ff208, 0x02c07207, 0x0cc00000, 0x06091107,
+	0x0cc00000, 0x00000000, 0x0649c400, 0x05810040, 0x09010000,
+	0x07c01281, 0x07c012c0, 0x0cc00000, 0x00000000, 0x0c07fdc0,
+	0x00000000, 0x064c4711, 0x0b2f6011, 0x00000000, 0x0cc00000,
+	0x0f8003cf, 0x0609ce28, 0x0c07fbc0, 0x00000000, 0x0649ce28,
+	0x0a6f4028, 0x00000000, 0x0cc00000, 0x00000000, 0x00000000
+};
+
 #define FOR_VFORMAT VFORMAT_MJPEG
 
 #define REG_FIRMWARE_ALL()\
 		DEF_FIRMWARE_VER(vmjpeg_mc, VERSTR);\
+		DEF_FIRMWARE_VER(vmmjpeg_mc, VERSTR);\
 
 INIT_DEF_FIRMWARE();
 
diff --git a/drivers/amlogic/amports/arch/ucode/mpeg12/vmpeg12_mc.c b/drivers/amlogic/amports/arch/ucode/mpeg12/vmpeg12_mc.c
index 7927bbf..5be9267 100644
--- a/drivers/amlogic/amports/arch/ucode/mpeg12/vmpeg12_mc.c
+++ b/drivers/amlogic/amports/arch/ucode/mpeg12/vmpeg12_mc.c
@@ -19,1799 +19,368 @@
 
 #define VERSTR "00000"
 const u32 vmpeg12_mc[] __initconst = {
-	0x680f801,
-	0x6800000,
-	0xd000001,
-	0x7400040,
-	0xc011080,
-	0x0000000,
-	0x80c0002,
-	0x80c2900,
-	0x6bffc00,
-	0x7c00440,
-	0x6030400,
-	0x0400000,
-	0xc012dc0,
-	0x0000000,
-	0x0000000,
-	0x0000000,
-	0x0000000,
-	0x0000000,
-	0x0000000,
-	0xc7ffe40,
-	0x0000000,
-	0x0000000,
-	0x0000000,
-	0x0000000,
-	0x0000000,
-	0x0000000,
-	0x0000000,
-	0x0000000,
-	0x0000000,
-	0x0000000,
-	0x0000000,
-	0x0000000,
-	0xc795d80,
-	0x0000000,
-	0xc7919c0,
-	0x0000000,
-	0xc780480,
-	0x64c0007,
-	0xc7921c0,
-	0x0000000,
-	0xc79a900,
-	0x0000000,
-	0xc791740,
-	0x0000000,
-	0xcc00000,
-	0x0400000,
-	0xcc00000,
-	0x0400000,
-	0xcc00000,
-	0x0400000,
-	0x0800000,
-	0x7800449,
-	0xc7fff00,
-	0x6030409,
-	0x6bffd89,
-	0x6030409,
-	0x0400000,
-	0xa2e4047,
-	0x64c4609,
-	0x6802008,
-	0x64c4309,
-	0xac05209,
-	0x6800008,
-	0x6800048,
-	0xc7ffc80,
-	0x7c00e88,
-	0x7c00e88,
-	0x78001c9,
-	0xaa14009,
-	0xa608049,
-	0xc78d400,
-	0xa608089,
-	0xc78c4c0,
-	0xa214807,
-	0xc783c00,
-	0x0000000,
-	0xc78fbc0,
-	0x0000000,
-	0x7800787,
-	0xb6f7fc7,
-	0x7c00047,
-	0x7800747,
-	0x64c2908,
-	0xbee4808,
-	0x7c00007,
-	0x80c2841,
-	0x7800188,
-	0x64c2807,
-	0xa2fc047,
-	0x5801347,
-	0xa61400d,
-	0x0000000,
-	0x80c2800,
-	0xc7ff540,
-	0x80c0002,
-	0xaa0c008,
-	0xc780840,
-	0x0000000,
-	0xaa0c04d,
-	0xc78f600,
-	0x0000000,
-	0x80c2802,
-	0x64c2807,
-	0xa2fc047,
-	0x58011c7,
-	0x7c00607,
-	0x80c2800,
-	0x7800688,
-	0xa60c008,
-	0x6800008,
-	0xfc01200,
-	0x7c006c8,
-	0x94a11c8,
-	0xa210407,
-	0x60c2c07,
-	0xfc05200,
-	0x60c0a08,
-	0x7800708,
-	0xaa10008,
-	0x80c2800,
-	0xc780dc0,
-	0x0000000,
-	0x80c2a00,
-	0xc014800,
-	0x80c0004,
-	0xc016500,
-	0x0000000,
-	0xc7fecc0,
-	0x0000000,
-	0x6800009,
-	0x7c03e49,
-	0xaa2404d,
-	0x6800008,
-	0x7800588,
-	0xa614008,
-	0xc011880,
-	0x80c2c00,
-	0xc7ffe00,
-	0x440134d,
-	0x6800008,
-	0x7c00588,
-	0x80c2802,
-	0x64c2807,
-	0xa2fc047,
-	0x58011c7,
-	0x7c00607,
-	0x6800009,
-	0x7800688,
-	0xaa30048,
-	0xa21c307,
-	0x80c2800,
-	0xfc02280,
-	0xa61000a,
-	0x7c0064a,
-	0xc7fe600,
-	0x80c0002,
-	0xaa10088,
-	0xa20c0c7,
-	0x0000000,
-	0xfc01240,
-	0x7c006c9,
-	0x4000287,
-	0x94a1289,
-	0x7800649,
-	0x94c2289,
-	0x60c2c0a,
-	0xa210407,
-	0x80c2800,
-	0xfc05200,
-	0x60c0a08,
-	0xa24c047,
-	0x7800708,
-	0xa60c008,
-	0xc781000,
-	0x80c2800,
-	0x78004c8,
-	0xaa0c0c8,
-	0x6800088,
-	0x6800048,
-	0x64c2c09,
-	0x94c2248,
-	0x60c2c09,
-	0x80c2a00,
-	0xc013900,
-	0x80c0000,
-	0xc015600,
-	0x0000000,
-	0xc7fddc0,
-	0x0000000,
-	0x7800008,
-	0x7c06108,
-	0x80c2800,
-	0x80c2a00,
-	0xc013700,
-	0x80c0000,
-	0x0000000,
-	0x64c2908,
-	0x0000000,
-	0xbe42008,
-	0x0000000,
-	0x64c0008,
-	0x4841208,
-	0xa6e5048,
-	0x7800008,
-	0xa620008,
-	0x4401208,
-	0x7800049,
-	0xaa14009,
-	0x6800008,
-	0x4401249,
-	0x7c00049,
-	0x7806188,
-	0xc7fd780,
-	0x7c00008,
-	0x64c1008,
-	0x7c03c08,
-	0x64c1108,
-	0x7c03c48,
-	0x64c1208,
-	0x7c03c88,
-	0x64c1308,
-	0x7c03cc8,
-	0x64c1408,
-	0x7c03d08,
-	0x64c1508,
-	0x7c03d48,
-	0x64c1608,
-	0x7c03d88,
-	0x64c1708,
-	0x7c03dc8,
-	0x7c0f808,
-	0xc0132c0,
-	0x0000000,
-	0xc015580,
-	0x0000000,
-	0xc7fd1c0,
-	0x0000000,
-	0x80c2a00,
-	0xc012b40,
-	0x80c0004,
-	0xc014840,
-	0x0000000,
-	0xc7fd000,
-	0x0000000,
-	0x0000000,
-	0xc78d180,
-	0x0000000,
-	0x683ffc8,
-	0x7c00748,
-	0x78013c8,
-	0x9808008,
-	0x7c013c8,
-	0x649cc09,
-	0x4001249,
-	0x609cc09,
-	0x6807fc9,
-	0xaa18009,
-	0x6494707,
-	0x91081c7,
-	0x7800008,
-	0xa4fc207,
-	0x4401249,
-	0xc000100,
-	0x0000000,
-	0xc780d40,
-	0x0000000,
-	0x64e0008,
-	0x83f0040,
-	0x83f0000,
-	0x6490b07,
-	0x9807007,
-	0x9807087,
-	0x98073c7,
-	0x6090b07,
-	0x9c07007,
-	0x9c07087,
-	0x9c073c7,
-	0x6090b07,
-	0x683ffc9,
-	0x6498f07,
-	0xaa0c009,
-	0xa6f8007,
-	0x4401249,
-	0x6498e07,
-	0x9807007,
-	0x9807607,
-	0x9807647,
-	0x9807687,
-	0x9807747,
-	0x6098e07,
-	0x9c07007,
-	0x9c07607,
-	0x9c07647,
-	0x9c07687,
-	0x9c07747,
-	0x6098e07,
-	0x64c0007,
-	0x9c07187,
-	0x9807207,
-	0x60c0007,
-	0x64c0807,
-	0x9807347,
-	0x60c0807,
-	0x83f0040,
-	0x83f0000,
-	0x8090b65,
-	0x0000000,
-	0x8090b60,
-	0xcc00000,
-	0x60e0008,
-	0xc7967c0,
-	0x0000000,
-	0xc78c0c0,
-	0x0000000,
-	0xa20d007,
-	0xc7fef00,
-	0x0000000,
-	0xfc081c0,
-	0x46b3207,
-	0xc502280,
-	0x7803e89,
-	0xaadc009,
-	0x46b8207,
-	0xc57fcc0,
-	0x46b5207,
-	0xc503440,
-	0x4600207,
-	0xc5067c0,
-	0x46b2207,
-	0xc504940,
-	0x46b7207,
-	0xc505cc0,
-	0x7800888,
-	0xaaac008,
-	0x7800788,
-	0xaaa7fc8,
-	0x7801688,
-	0xac0d207,
-	0xa807207,
-	0x6800048,
-	0x7c018c8,
-	0x78013c8,
-	0x9808008,
-	0xc78b900,
-	0x7c013c8,
-	0x78018c8,
-	0xaa10008,
-	0x6800008,
-	0xc78b7c0,
-	0x7c018c8,
-	0x7c01687,
-	0x78000c8,
-	0xacd8207,
-	0x4401207,
-	0x7800049,
-	0xa804209,
-	0x78013c9,
-	0x9809009,
-	0x7c013c9,
-	0x7c06088,
-	0xfc05200,
-	0x7c060c8,
-	0xfc01200,
-	0xaa0c008,
-	0xc7fff80,
-	0xfc08200,
-	0x80c2841,
-	0x7800188,
-	0x64c2807,
-	0xa2fc047,
-	0x5801347,
-	0xa60c00d,
-	0xc78b1c0,
-	0x0000000,
-	0x44011cd,
-	0x7800009,
-	0xa8041c9,
-	0x78013c9,
-	0x9809009,
-	0x7c013c9,
-	0x7c06047,
-	0x7800748,
-	0xa405207,
-	0x7806087,
-	0x7800788,
-	0xa402207,
-	0xc780e00,
-	0x7800007,
-	0x7806108,
-	0xb403207,
-	0x2408207,
-	0x7800008,
-	0xb214008,
-	0x6800047,
-	0xae0c288,
-	0x6800287,
-	0x40001c8,
-	0x7800008,
-	0xb4031c8,
-	0x24081c8,
-	0x6800008,
-	0xc00f580,
-	0x0000000,
-	0x7800047,
-	0x7806088,
-	0xaa68008,
-	0xb819207,
-	0xac06207,
-	0x7800007,
-	0x7806048,
-	0xb815207,
-	0xaa08007,
-	0xb013207,
-	0x6807807,
-	0x6800008,
-	0x6808009,
-	0x20091c9,
-	0xd07ff87,
-	0x7400248,
-	0x7806047,
-	0x440a1c7,
-	0xb624007,
-	0x7806088,
-	0x4401208,
-	0x7c00048,
-	0x7800088,
-	0x2008207,
-	0xba0c008,
-	0x6800007,
-	0x40001c8,
-	0x7c00007,
-	0x7800047,
-	0x7806088,
-	0xac09207,
-	0xb804207,
-	0x7800007,
-	0x7806048,
-	0xb405207,
-	0xc00dcc0,
-	0x0000000,
-	0xc7ffdc0,
-	0x0000000,
-	0x6800048,
-	0x7c00588,
-	0x80c2c00,
-	0x64c0108,
-	0x9809048,
-	0x60c0109,
-	0x60c0108,
-	0x7806048,
-	0x7c00008,
-	0x7806088,
-	0x7c00048,
-	0x78060c8,
-	0x60c0a08,
-	0xc7fa600,
-	0x0000000,
-	0x6a00007,
-	0x7c00d07,
-	0x7c03e87,
-	0xfc0c1c0,
-	0x609c607,
-	0xfc0c200,
-	0x609c708,
-	0x400f1c7,
-	0x58041c7,
-	0x60c0907,
-	0x7c00087,
-	0x4401247,
-	0x7c06189,
-	0x400f208,
-	0x5804208,
-	0x7c000c8,
-	0x9508207,
-	0xfc041c0,
-	0xfc04200,
-	0x7c00108,
-	0x5404208,
-	0x2c07207,
-	0x609c407,
-	0xfc101c0,
-	0xfc0f1c0,
-	0x6800009,
-	0x7c03e09,
-	0x64e0009,
-	0xa2fc089,
-	0x6800008,
-	0xa22c047,
-	0x6800807,
-	0x6800009,
-	0x6c00049,
-	0x60e0209,
-	0xfc10240,
-	0x60e0209,
-	0x44011c7,
-	0xaef4007,
-	0x0000000,
-	0x4c10208,
-	0xfc011c0,
-	0xa22c047,
-	0x6800807,
-	0x6800009,
-	0x6c00049,
-	0x60e0209,
-	0xfc10240,
-	0x60e0309,
-	0x44011c7,
-	0xaef4007,
-	0x0000000,
-	0x4c08208,
-	0xc788f40,
-	0x60e0008,
-	0x6840047,
-	0x60c0107,
-	0x649c409,
-	0x98097c9,
-	0xfc081c0,
-	0xfc011c0,
-	0x9601247,
-	0xfc021c0,
-	0xfc021c0,
-	0x9702247,
-	0xfc021c0,
-	0x9742247,
-	0xfc0d1c0,
-	0xfc091c0,
-	0xfc021c0,
-	0x9622247,
-	0xfc051c0,
-	0x9665247,
-	0xc788a40,
-	0x609c409,
-	0xc7889c0,
-	0xfc041c0,
-	0xfc041c0,
-	0xaaa4047,
-	0xaa181c7,
-	0xa63c0c7,
-	0x64e0008,
-	0xfc011c0,
-	0xc7ff2c0,
-	0x0000000,
-	0xfc101c0,
-	0x7c00487,
-	0x58041c7,
-	0x7800d08,
-	0x940c207,
-	0x7c00d08,
-	0x7800e47,
-	0x405b1c7,
-	0xc788540,
-	0x74001c8,
-	0xa6b0207,
-	0x0000000,
-	0xfc101c0,
-	0x60c0207,
-	0xfc0c1c0,
-	0x60c0307,
-	0x9102247,
-	0x7c004c9,
-	0x7c06309,
-	0x7803e08,
-	0x649070b,
-	0x980b0cb,
-	0xa6140c9,
-	0x5001308,
-	0x680000c,
-	0x6800008,
-	0x9c0b0cb,
-	0x7c03e0c,
-	0x78004ca,
-	0xaa140ca,
-	0x300a30a,
-	0x500128a,
-	0x94e11ca,
-	0x60c0307,
-	0xa614048,
-	0x780018a,
-	0xa60c04a,
-	0x0000000,
-	0x980b10b,
-	0x609070b,
-	0xa6200c9,
-	0x6800088,
-	0xa215007,
-	0x6800089,
-	0x7c00649,
-	0xc7800c0,
-	0x6800048,
-	0x6800008,
-	0x7c00688,
-	0x90a1207,
-	0x7c00708,
-	0xfc01240,
-	0x7c00549,
-	0x7800d08,
-	0x95e1209,
-	0x9021247,
-	0x95c1209,
-	0x90e1247,
-	0x95a1209,
-	0x78004c9,
-	0xaa0c0c9,
-	0x6800049,
-	0x6800009,
-	0x9581209,
-	0x7c00d08,
-	0x7800e49,
-	0x405b249,
-	0x7400248,
-	0x90e1247,
-	0x7c00509,
-	0xc7875c0,
-	0x0000000,
-	0x6806349,
-	0x6800007,
-	0x6801c88,
-	0x7400247,
-	0xd07ffc8,
-	0x4001249,
-	0xcc00000,
-	0x0000000,
-	0x649c907,
-	0xbefffc7,
-	0x0000000,
-	0xc07fd40,
-	0x0000000,
-	0x6806349,
-	0x6800008,
-	0x680000a,
-	0x64c2a07,
-	0xa618007,
-	0x0000000,
-	0x64c3607,
-	0x58081c7,
-	0xaa3c047,
-	0x0000000,
-	0xfc081c0,
-	0xbe18048,
-	0x0000000,
-	0x4000287,
-	0x7400247,
-	0xc780140,
-	0x0000000,
-	0x95081ca,
-	0x7400247,
-	0x4001249,
-	0x4001208,
-	0xb2bb888,
-	0x0000000,
-	0x7806287,
-	0x40011c7,
-	0x7c06287,
-	0x649cb0a,
-	0x6850008,
-	0x240a20a,
-	0x603510a,
-	0x6806247,
-	0x24091c9,
-	0x4003249,
-	0x5802249,
-	0x5402249,
-	0x6035209,
-	0x7806247,
-	0x200a287,
-	0x240b1c8,
-	0x5401249,
-	0x4007249,
-	0x5803249,
-	0x5403249,
-	0x7c06249,
-	0x20071c9,
-	0xb405207,
-	0x6800008,
-	0x4000207,
-	0x603510a,
-	0x7c06248,
-	0x6a06249,
-	0x6035009,
-	0x6435009,
-	0x580f249,
-	0xbef8049,
-	0xa62c008,
-	0xc07eec0,
-	0x0000000,
-	0x603510a,
-	0x58012cb,
-	0x603520b,
-	0x6a06349,
-	0x6035009,
-	0x6435009,
-	0x580f249,
-	0xbef8049,
-	0x6803f87,
-	0x7806248,
-	0x9610207,
-	0x609c908,
-	0x8007401,
-	0x649c907,
-	0xbefffc7,
-	0x0000000,
-	0xc7809c0,
-	0x7800207,
-	0xa608007,
-	0xc780780,
-	0x44011c7,
-	0xaa0c087,
-	0x7800289,
-	0x7800309,
-	0xae380c9,
-	0x0000000,
-	0x405b1c9,
-	0x70001c7,
-	0x609c507,
-	0x403b1c9,
-	0x70001c8,
-	0x40081c7,
-	0x70001c7,
-	0x9610207,
-	0x609cd08,
-	0x4001249,
-	0x609c909,
-	0x8007401,
-	0x78002c9,
-	0xae281c9,
-	0x0000000,
-	0x649c907,
-	0xa6fc007,
-	0x405b1c9,
-	0x70001c7,
-	0x609c507,
-	0x4001249,
-	0x609c909,
-	0x8007401,
-	0x6803fc9,
-	0x7c00289,
-	0x7c002c9,
-	0x7c00309,
-	0x6800009,
-	0x7c00209,
-	0xc7855c0,
-	0x0000000,
-	0x7800889,
-	0xa608009,
-	0xc780700,
-	0x7800789,
-	0xaa0ffc9,
-	0xc0089c0,
-	0x0000000,
-	0x7800889,
-	0xaa58009,
-	0x683ffc9,
-	0xaa1c009,
-	0x6494707,
-	0x91081c7,
-	0x7806188,
-	0xaa40008,
-	0xa4fb207,
-	0x4401249,
-	0x683ffc8,
-	0x649bb07,
-	0x900c1c7,
-	0xaa10007,
-	0xaa0c008,
-	0xc7fff00,
-	0x4401208,
-	0x649bc07,
-	0x93e11c7,
-	0xa2f8047,
-	0x0000000,
-	0xc078200,
-	0x0000000,
-	0x6800007,
-	0x7c01687,
-	0x7c018c7,
-	0x64c5108,
-	0x64c4609,
-	0x64c4207,
-	0x64c400a,
-	0x2407287,
-	0x40081c7,
-	0x580a1c7,
-	0xe000207,
-	0x2409289,
-	0x0000000,
-	0x0000000,
-	0xf0001c0,
-	0xf010200,
-	0x97081c8,
-	0x540a1c7,
-	0x2007247,
-	0x64c4308,
-	0x2407207,
-	0x7c012c7,
-	0x58101c7,
-	0x7c01307,
-	0xc00c780,
-	0x0000000,
-	0xfc0a1c0,
-	0x7c062c7,
-	0xfc031c0,
-	0x78062c8,
-	0x9543207,
-	0x7c062c8,
-	0xba08047,
-	0xb20c0c7,
-	0xc7fef80,
-	0x0000000,
-	0x44011c7,
-	0x7c00187,
-	0x60c0407,
-	0x6800008,
-	0x9808048,
-	0xa234088,
-	0x6800049,
-	0x7800848,
-	0xb628088,
-	0xaa10087,
-	0xaa18007,
-	0xa614008,
-	0x0000000,
-	0x6800009,
-	0xc784140,
-	0x7c00889,
-	0x4001208,
-	0x7c00848,
-	0x7c00889,
-	0xaa48007,
-	0x6800009,
-	0x64c040a,
-	0xfc10200,
-	0xfc01200,
-	0x94a1288,
-	0xfc03200,
-	0x9503248,
-	0x9583248,
-	0xa61c087,
-	0x9583248,
-	0xfc01200,
-	0x9481288,
-	0xfc03200,
-	0x9403248,
-	0x9483248,
-	0x60c0209,
-	0x60c040a,
-	0x6800008,
-	0x7c003c8,
-	0x7800088,
-	0x5404208,
-	0x78000c9,
-	0x5404249,
-	0x9610248,
-	0x6090809,
-	0x6804008,
-	0x6090708,
-	0x7803e07,
-	0x46011c7,
-	0xc503780,
-	0x0000000,
-	0x649c909,
-	0xaa10009,
-	0x6800087,
-	0xc7f3500,
-	0x7c001c7,
-	0x7800207,
-	0xa608007,
-	0xc780d00,
-	0x44011c7,
-	0xaa0c087,
-	0x7800289,
-	0x7800309,
-	0xb2081c9,
-	0xc780b80,
-	0x0000000,
-	0x78013c8,
-	0x7800207,
-	0x44011c7,
-	0xa610087,
-	0x0000000,
-	0xbe38148,
-	0xc780380,
-	0xbe100c8,
-	0x9808088,
-	0x9c08088,
-	0xc780180,
-	0xbe14048,
-	0x9808048,
-	0xa60c007,
-	0x0000000,
-	0x9c08048,
-	0x7c013c8,
-	0xa20c0c8,
-	0x0000000,
-	0x98073c7,
-	0x7800e48,
-	0x4050208,
-	0x7400207,
-	0x78013c8,
-	0x9c08008,
-	0x7c013c8,
-	0x405b1c9,
-	0x70001c7,
-	0x4050209,
-	0x7000208,
-	0x5410208,
-	0x2c07207,
-	0x609c507,
-	0x403b1c9,
-	0x70001c8,
-	0x40081c7,
-	0x70001c7,
-	0x9610207,
-	0x609cd08,
-	0x4001249,
-	0x609c909,
-	0x8007401,
-	0x6800009,
-	0x7c00209,
-	0x6800009,
-	0x7c001c9,
-	0x7800247,
-	0x2c07247,
-	0x780090a,
-	0x78008e1,
-	0xbe0c047,
-	0xc780880,
-	0x6800008,
-	0x780098a,
-	0x7800961,
-	0xa278087,
-	0x6800048,
-	0x7800a0a,
-	0x78009e1,
-	0xa268107,
-	0x6800088,
-	0x7800a8a,
-	0x7800a61,
-	0xa258207,
-	0x68000c8,
-	0x7800b0a,
-	0x7800ae1,
-	0xa248407,
-	0x6800108,
-	0x7800b8a,
-	0x7800b61,
-	0xa238807,
-	0x6800148,
-	0x7800c4a,
-	0x7800c21,
-	0xa229007,
-	0x6800188,
-	0x7800cca,
-	0x7800ca1,
-	0xa21a007,
-	0x68001c8,
-	0x809ce01,
-	0x6800047,
-	0xc7f1d40,
-	0x7c001c7,
-	0x96102a1,
-	0x7800387,
-	0x90041c7,
-	0xa8061c8,
-	0x7800187,
-	0xa620087,
-	0x7800387,
-	0x90841c7,
-	0xa4051c8,
-	0x6800047,
-	0x3407207,
-	0xc7ff380,
-	0x2c091c9,
-	0x809ce00,
-	0x6800047,
-	0x7800349,
-	0xa60c008,
-	0xc780600,
-	0x9401247,
-	0xa60c048,
-	0xc780540,
-	0x9481247,
-	0xa60c088,
-	0xc780480,
-	0x9501247,
-	0xa60c0c8,
-	0xc7803c0,
-	0x9581247,
-	0x7801609,
-	0xa60c108,
-	0xc780240,
-	0x9401247,
-	0xa60c148,
-	0xc780180,
-	0x9481247,
-	0xa60c188,
-	0xc7800c0,
-	0x9501247,
-	0x9581247,
-	0xc7800c0,
-	0x7c01609,
-	0x7c00349,
-	0x7800d09,
-	0x405b1c8,
-	0x7c00e48,
-	0x74001c9,
-	0x78012c9,
-	0x403b1c8,
-	0x74001c9,
-	0x7801309,
-	0x40081c7,
-	0x74001c9,
-	0x6800047,
-	0x3407207,
-	0x7800249,
-	0x2c091c9,
-	0x7c00249,
-	0x609b20a,
-	0x609920a,
-	0x7800187,
-	0x4001247,
-	0x7c00209,
-	0xa608087,
-	0xc780340,
-	0x78002c7,
-	0x7c00307,
-	0x7c002c8,
-	0x6499109,
-	0x6099009,
-	0x7800389,
-	0x5404249,
-	0x9404248,
-	0x7c00389,
-	0x609910a,
-	0xc7800c0,
-	0x0000000,
-	0x7c00288,
-	0x8098002,
-	0x78004ce,
-	0xa64c0ce,
-	0x0000000,
-	0x6499011,
-	0x54103d1,
-	0x581040f,
-	0x2c0f40f,
-	0x609810f,
-	0x6499111,
-	0x54103d1,
-	0x581040f,
-	0x2c0f40f,
-	0x609820f,
-	0x80980f0,
-	0x78004ce,
-	0xaa6c0ce,
-	0x0000000,
-	0x80980f4,
-	0xc780600,
-	0x0000000,
-	0x7803e0e,
-	0xaab800e,
-	0x0000000,
-	0x6499011,
-	0x54103d1,
-	0x649b110,
-	0x5410410,
-	0x78004ce,
-	0xa61404e,
-	0x0000000,
-	0x58103cf,
-	0xc7800c0,
-	0x0000000,
-	0x5810410,
-	0x2c0f40f,
-	0x609810f,
-	0x6499111,
-	0x54103d1,
-	0x581040f,
-	0x2c0f40f,
-	0x609820f,
-	0x80980f4,
-	0x6800009,
-	0x7c00009,
-	0xc780080,
-	0x7c00049,
-	0x64c0009,
-	0xa2fc049,
-	0x0000000,
-	0x64c3a09,
-	0x9006249,
-	0xaaec649,
-	0x0000000,
-	0x80c2800,
-	0x80c0002,
-	0xc7efb80,
-	0x0000000,
-	0xc0011c0,
-	0x0000000,
-	0x8011f00,
-	0x8002515,
-	0x8002605,
-	0x8002708,
-	0x8002801,
-	0x8002a09,
-	0x8007601,
-	0x649c003,
-	0x7c00903,
-	0x58100c3,
-	0x7c008c3,
-	0x649c103,
-	0x7c00983,
-	0x58100c3,
-	0x7c00943,
-	0x649c203,
-	0x7c00a03,
-	0x58100c3,
-	0x7c009c3,
-	0x649c303,
-	0x7c00a83,
-	0x58100c3,
-	0x7c00a43,
-	0x649c403,
-	0x7c00b03,
-	0x58100c3,
-	0x7c00ac3,
-	0x649c503,
-	0x7c00b83,
-	0x58100c3,
-	0x7c00b43,
-	0x649c603,
-	0x7c00c43,
-	0x58100c3,
-	0x7c00c03,
-	0x649c703,
-	0x7c00cc3,
-	0x58100c3,
-	0x7c00c83,
-	0x6498e03,
-	0x98037c3,
-	0x6098e03,
-	0x649ca07,
-	0xaa48007,
-	0x0000000,
-	0x9010207,
-	0x92101c7,
-	0x609c607,
-	0x609c708,
-	0x400f1c7,
-	0x58041c7,
-	0x60c0907,
-	0x7c00087,
-	0x4401247,
-	0x7c06189,
-	0x400f208,
-	0x5804208,
-	0x7c000c8,
-	0x9508207,
-	0x6800007,
-	0x7c00d07,
-	0xcc00000,
-	0x0000000,
-	0xc7eea40,
-	0x0000000,
-	0xcc00000,
-	0x0400000,
-	0xc7ee940,
-	0x0000000,
-	0x684001f,
-	0x60c011f,
-	0x64c001f,
-	0x9c1f19f,
-	0x981f21f,
-	0x60c001f,
-	0x680001f,
-	0x7c0021f,
-	0x7c0025f,
-	0x7c001df,
-	0x7c0041f,
-	0x7c0085f,
-	0x7c0089f,
-	0x6803fe0,
-	0x7c002a0,
-	0x7c002e0,
-	0x7c00320,
-	0x7c003a0,
-	0x68000a0,
-	0x7c00660,
-	0x6800060,
-	0x7c006a0,
-	0x6800020,
-	0x7c00720,
-	0x68000e0,
-	0x7c004e0,
-	0x6804020,
-	0x7c06020,
-	0xcc00000,
-	0x0000000,
-	0xc7ff800,
-	0x0000000,
-	0x78003de,
-	0x400179e,
-	0x7c003de,
-	0x649ce1e,
-	0xa63801e,
-	0x64c411e,
-	0x64c4322,
-	0x968c7a2,
-	0xa40a8de,
-	0x40008de,
-	0x780165e,
-	0x400179e,
-	0x7c0165e,
-	0xa61c21e,
-	0x0000000,
-	0x809cf01,
-	0xc780000,
-	0x0000000,
-	0x680001e,
-	0x7c0165e,
-	0xcc00000,
-	0x0400000,
-	0x649c828,
-	0xaa68028,
-	0xa20e028,
-	0xc7805c0,
-	0x7c00428,
-	0xaa3c068,
-	0x6bfffa9,
-	0xaa340a8,
-	0x6bfff69,
-	0xaa2c0e8,
-	0x6bffee9,
-	0xaa24128,
-	0x6bffde9,
-	0xaa1c168,
-	0x6bffbe9,
-	0xaa141a8,
-	0x6bff7e9,
-	0xaa0c1e8,
-	0x6bfefe9,
-	0x6bfdfe9,
-	0x0800000,
-	0x809ce00,
-	0x7800268,
-	0x2828a68,
-	0x7c00268,
-	0x0400000,
-	0x809c800,
-	0x78001e8,
-	0xa618028,
-	0x7800ea8,
-	0xaa18028,
-	0x6802028,
-	0x64c4329,
-	0xb003a29,
-	0x6800128,
-	0x6030528,
-	0xcc00000,
-	0x0000000,
-	0x7800189,
-	0xaa0c089,
-	0x6800208,
-	0x7c00608,
-	0x78004c8,
-	0xaa0c0c8,
-	0x6800088,
-	0x6800048,
-	0x7c00648,
-	0xaa10089,
-	0x6800008,
-	0x7c03c08,
-	0x7c03c48,
-	0x7c0f808,
-	0x6800048,
-	0x7c03e48,
-	0x7800188,
-	0xa614048,
-	0xc004a00,
-	0x0000000,
-	0xc780100,
-	0x0000000,
-	0xc005000,
-	0x0000000,
-	0xc002c40,
-	0x0000000,
-	0x7800009,
-	0x4001249,
-	0x7c00009,
-	0x7800088,
-	0xb809209,
-	0x6800009,
-	0x7c00009,
-	0x7800048,
-	0x4001208,
-	0x78000c9,
-	0xb803248,
-	0x7c00048,
-	0x680008d,
-	0xcc00000,
-	0x0000000,
-	0x7800007,
-	0x7806108,
-	0xb403207,
-	0x2408207,
-	0x7800008,
-	0xb214008,
-	0x6800047,
-	0xae0c288,
-	0x6800287,
-	0x40001c8,
-	0x7800008,
-	0xb4031c8,
-	0x24081c8,
-	0x6800008,
-	0xc0011c0,
-	0x0000000,
-	0x7800787,
-	0xa60bfc7,
-	0xcc00000,
-	0xc000100,
-	0x0000000,
-	0xc7ffec0,
-	0x0000000,
-	0x78004c8,
-	0xaa0c0c8,
-	0x6800088,
-	0x6800048,
-	0x7c00648,
-	0x7800009,
-	0x5402249,
-	0x6808008,
-	0x2009209,
-	0x7100248,
-	0x90011c8,
-	0x5c01208,
-	0x7c03c48,
-	0x4001249,
-	0x7100248,
-	0x7c03c08,
-	0x4001249,
-	0x7100248,
-	0x90012c8,
-	0x5c01208,
-	0x7c03d48,
-	0x4001249,
-	0x7100248,
-	0x7c03d08,
-	0x54022cb,
-	0x94612c7,
-	0xa60c30b,
-	0xc780240,
-	0x680020b,
-	0xa61c00b,
-	0x6800008,
-	0x7c03c48,
-	0x7c03c08,
-	0x7c03d48,
-	0x7c03d08,
-	0x680020b,
-	0x7c0060b,
-	0x7c0f808,
-	0x6800048,
-	0x7c03e48,
-	0xc003b80,
-	0x0000000,
-	0xc0017c0,
-	0x0000000,
-	0x7800009,
-	0x4001249,
-	0x7c00009,
-	0x7800088,
-	0xb80c209,
-	0x6800009,
-	0x7c00009,
-	0x7800048,
-	0x4001208,
-	0x78000c9,
-	0xb806248,
-	0x7c00048,
-	0x6800009,
-	0x7c00049,
-	0x6803fc9,
-	0x7c00789,
-	0xcc00000,
-	0x0000000,
-	0x7800189,
-	0xa640009,
-	0x7800049,
-	0x540a249,
-	0x649cb07,
-	0x20091c9,
-	0x6035109,
-	0x7800089,
-	0x5402249,
-	0x6035209,
-	0x6b08009,
-	0x6035009,
-	0x6435009,
-	0x580f249,
-	0xbef8049,
-	0xcc00000,
-	0x7c00008,
-	0x7906149,
-	0xb403209,
-	0xcc00000,
-	0x7c00008,
-	0x44011c9,
-	0x7c06147,
-	0x5402249,
-	0x6808007,
-	0x20091c9,
-	0x7806007,
-	0x680400b,
-	0xac032c7,
-	0x44041c7,
-	0x6805f07,
-	0x7c06007,
-	0x70001cb,
-	0x740024b,
-	0x40011c7,
-	0x4001249,
-	0x70001cb,
-	0x740024b,
-	0x40011c7,
-	0x4001249,
-	0x70001cb,
-	0x740024b,
-	0x40011c7,
-	0x4001249,
-	0x70001cb,
-	0xc7ff4c0,
-	0x740024b,
-	0x64c4414,
-	0x9101514,
-	0xa6f8014,
-	0xc7ea5c0,
-	0x0000000,
-	0xc0005c0,
-	0x0000000,
-	0x7800007,
-	0x40011c7,
-	0x7c00747,
-	0x7800049,
-	0x7800088,
-	0xb403207,
-	0xcc00000,
-	0x7c00789,
-	0x6800008,
-	0x7c00748,
-	0x4001209,
-	0x78000c9,
-	0xb403248,
-	0xcc00000,
-	0x7c00788,
-	0x6411f08,
-	0x4001208,
-	0x6011f08,
-	0x6803fc8,
-	0xcc00000,
-	0x7c00788,
-	0x7800009,
-	0x7c06149,
-	0x6808008,
-	0x5402249,
-	0x2008248,
-	0x7806007,
-	0x7000209,
-	0x74001c9,
-	0x4001208,
-	0x40011c7,
-	0x7000209,
-	0x74001c9,
-	0x4001208,
-	0x40011c7,
-	0x7000209,
-	0x74001c9,
-	0x4001208,
-	0x40011c7,
-	0x7000209,
-	0x74001c9,
-	0x4403208,
-	0x40011c7,
-	0x9c071c7,
-	0x7c06007,
-	0x7800607,
-	0xbe4c047,
-	0x7903c49,
-	0x5401249,
-	0x90612c7,
-	0x940124b,
-	0x7400209,
-	0x4001208,
-	0x7903c09,
-	0x7400209,
-	0x4001208,
-	0x7903d49,
-	0x5401249,
-	0x90412c7,
-	0x940124b,
-	0x7400209,
-	0x4001208,
-	0x7903d09,
-	0xc780840,
-	0x7400209,
-	0x7800009,
-	0xa610009,
-	0x44041c8,
-	0xc780700,
-	0x0000000,
-	0x780618b,
-	0xb4102c9,
-	0x70001c9,
-	0x7400209,
-	0x40011c7,
-	0x4001208,
-	0x70001c9,
-	0x7400209,
-	0x40011c7,
-	0x4001208,
-	0x70001c9,
-	0x7400209,
-	0x40011c7,
-	0x4001208,
-	0x70001c9,
-	0xc7802c0,
-	0x7400209,
-	0x6800049,
-	0x7400209,
-	0x4001208,
-	0x6800009,
-	0x7400209,
-	0x4001208,
-	0x7400209,
-	0x4001208,
-	0x7400209,
-	0x7800189,
-	0xa644049,
-	0x7800009,
-	0x7806188,
-	0xb80e209,
-	0x7800049,
-	0x540a249,
-	0x649cb08,
-	0x2009209,
-	0x6035109,
-	0x7800089,
-	0x5402249,
-	0x6035209,
-	0x6a08009,
-	0x6035009,
-	0x6435009,
-	0x580f249,
-	0xbef8049,
-	0xcc00000,
-	0x0000000,
-	0x6490604,
-	0xaefcc04,
-	0x0000000,
-	0x7800004,
-	0x7800045,
-	0x9508144,
-	0x6800084,
-	0x6c00004,
-	0x78004c6,
-	0x4001186,
-	0x9562106,
-	0x6090604,
-	0x6090605,
-	0x6881044,
-	0x9562106,
-	0x6090604,
-	0xcc00000,
-	0x0000000,
-	0x6490604,
-	0xaefcc04,
-	0x0000000,
-	0x7800004,
-	0x7800045,
-	0x9508144,
-	0x6900184,
-	0x6c00004,
-	0x78004c6,
-	0x4001186,
-	0x9562106,
-	0x6090604,
-	0x6090605,
-	0x8090600,
-	0x6800004,
-	0x95e2106,
-	0x6090604,
-	0x6985144,
-	0x6c00004,
-	0x9562106,
-	0x6090604,
-	0xcc00000,
-	0x0000000,
-	0x6800007,
-	0x7c06107,
-	0x7c00747,
-	0xcc00000,
-	0x7c00787,
-	0x6490604,
-	0xaefcc04,
-	0x0000000,
-	0x680000a,
-	0x7800004,
-	0x7800049,
-	0x9508244,
-	0x6800087,
-	0x7803e44,
-	0xa60c044,
-	0x6c00007,
-	0x9807087,
-	0x7800606,
-	0xbe10106,
-	0x0000000,
-	0xc780140,
-	0x9807387,
-	0xa20c206,
-	0x98073c7,
-	0x9807387,
-	0x7800645,
-	0x78004cb,
-	0xa67c0cb,
-	0xa208306,
-	0xa618085,
-	0x6800008,
-	0xc000e40,
-	0x0000000,
-	0xc780d40,
-	0x0000000,
-	0x680000a,
-	0xa6180c5,
-	0x780018c,
-	0xa61404c,
-	0x0000000,
-	0xc7800c0,
-	0x9807407,
-	0xa638045,
-	0x6800084,
-	0x95621c4,
-	0x6800044,
-	0x94a31c4,
-	0xc000a40,
-	0x6800088,
-	0x68000c4,
-	0x95621c4,
-	0x9c07047,
-	0xc000900,
-	0x68000c8,
-	0xc780800,
-	0x0000000,
-	0xc780000,
-	0x0000000,
-	0xaa0c04b,
-	0x6800084,
-	0x68000c4,
-	0x95621c4,
-	0xa208306,
-	0xa614045,
-	0xc000600,
-	0x6800008,
-	0xc780500,
-	0x0000000,
-	0xa6240c5,
-	0x780018c,
-	0xa62004c,
-	0x0000000,
-	0x6800008,
-	0xc0003c0,
-	0x9807407,
-	0xc7802c0,
-	0x0000000,
-	0xa6ac085,
-	0x6800044,
-	0x94a31c4,
-	0xc000200,
-	0x6800088,
-	0x9807107,
-	0x9c07047,
-	0xc000100,
-	0x68000c8,
-	0xcc00000,
-	0x0000000,
-	0x680000b,
-	0x6c0004b,
-	0xaa0c0c8,
-	0x6090607,
-	0x6090609,
-	0x91c2187,
-	0xaa5c086,
-	0x7803c04,
-	0xa6180c8,
-	0x7803c45,
-	0xa8042c7,
-	0x0000000,
-	0x7803c84,
-	0x7803cc5,
-	0x6090604,
-	0x9181107,
-	0x91e1245,
-	0x2809244,
-	0x7803e4c,
-	0xaa1004c,
-	0xa0042c7,
-	0x0000000,
-	0x68000c6,
-	0x9161247,
-	0x3405285,
-	0x9601144,
-	0x95e1149,
-	0xaa5c046,
-	0x6090605,
-	0x7803d04,
-	0xa6100c8,
-	0x7803d45,
-	0x7803d84,
-	0x7803dc5,
-	0x6090604,
-	0x9181107,
-	0x91e1245,
-	0x2809244,
-	0x7803e4c,
-	0xaa1804c,
-	0xa0062c7,
-	0x0000000,
-	0x9161247,
-	0xc7800c0,
-	0x5001249,
-	0x9161247,
-	0x3405285,
-	0x9601144,
-	0x95e1149,
-	0x6090605,
-	0x9804347,
-	0x9804204,
-	0x9804184,
-	0xaa0c088,
-	0x9c04044,
-	0x9804004,
-	0xcc00000,
-	0x6090604,
-	0xc7e5900,
-	0x0000000,
-	0x609c42d,
-	0x0000000,
-	0x649c42d,
-	0xa6f802d,
-	0x0000000,
-	0xcc00000,
-	0x0000000,
-	0xfc09200,
-	0xfc101c0,
-	0x78061c9,
-	0x780620b,
-	0x7c061c7,
-	0x7c06208,
-	0x5410208,
-	0x2c081c8,
-	0x54102cb,
-	0x2c0b24b,
-	0xa60800b,
-	0xc7808c0,
-	0x9265248,
-	0x5406289,
-	0x5402249,
-	0x240a24a,
-	0x91a6248,
-	0x2009289,
-	0x5406289,
-	0x5402249,
-	0x240a24a,
-	0x90c6248,
-	0x2008289,
-	0x926524b,
-	0x5406289,
-	0x5402249,
-	0x240a24a,
-	0x91a624b,
-	0x2009289,
-	0x5406289,
-	0x5402249,
-	0x240a24a,
-	0x90c624b,
-	0x200b289,
-	0xb8052c8,
-	0x24082c8,
-	0x6800207,
-	0xb4021c8,
-	0xc780200,
-	0x6800007,
-	0x7c00847,
-	0x7c00887,
-	0x6800008,
-	0x7c061c8, 0x7c06208, 0x0000000, 0xc7f4e00, 0xfc071c0, 0x0000000
+	0x0680f801, 0x06800000, 0x0d000001, 0x07400040, 0x0c011080,
+	0x00000000, 0x080c0002, 0x080c2900, 0x06bffc00, 0x07c00440,
+	0x06030400, 0x00400000, 0x0c012e80, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0c7ffe40,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x0c795e40, 0x00000000, 0x0c7919c0,
+	0x00000000, 0x0c780480, 0x064c0007, 0x0c7921c0, 0x00000000,
+	0x0c79a9c0, 0x00000000, 0x0c791740, 0x00000000, 0x0cc00000,
+	0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000,
+	0x00800000, 0x07800449, 0x0c7fff00, 0x06030409, 0x06bffd89,
+	0x06030409, 0x00400000, 0x0a2e4047, 0x064c4609, 0x06802008,
+	0x064c4309, 0x0b405209, 0x06800008, 0x06800048, 0x0c7ffc80,
+	0x07c00e88, 0x07c00e88, 0x078001c9, 0x0aa14009, 0x0a608049,
+	0x0c78d400, 0x0a608089, 0x0c78c4c0, 0x0a214807, 0x0c783c00,
+	0x00000000, 0x0c78fbc0, 0x00000000, 0x07800787, 0x0b6f7fc7,
+	0x07c00047, 0x07800747, 0x064c2908, 0x0bee4808, 0x07c00007,
+	0x080c2841, 0x07800188, 0x064c2807, 0x0a2fc047, 0x05801347,
+	0x0a61400d, 0x00000000, 0x080c2800, 0x0c7ff540, 0x080c0002,
+	0x0aa0c008, 0x0c780840, 0x00000000, 0x0aa0c04d, 0x0c78f600,
+	0x00000000, 0x080c2802, 0x064c2807, 0x0a2fc047, 0x058011c7,
+	0x07c00607, 0x080c2800, 0x07800688, 0x0a60c008, 0x06800008,
+	0x0fc01200, 0x07c006c8, 0x094a11c8, 0x0a210407, 0x060c2c07,
+	0x0fc05200, 0x060c0a08, 0x07800708, 0x0aa10008, 0x080c2800,
+	0x0c780dc0, 0x00000000, 0x080c2a00, 0x0c0148c0, 0x080c0004,
+	0x0c0165c0, 0x00000000, 0x0c7fecc0, 0x00000000, 0x06800009,
+	0x07c03e49, 0x0aa2404d, 0x06800008, 0x07800588, 0x0a614008,
+	0x0c011940, 0x080c2c00, 0x0c7ffe00, 0x0440134d, 0x06800008,
+	0x07c00588, 0x080c2802, 0x064c2807, 0x0a2fc047, 0x058011c7,
+	0x07c00607, 0x06800009, 0x07800688, 0x0aa30048, 0x0a21c307,
+	0x080c2800, 0x0fc02280, 0x0a61000a, 0x07c0064a, 0x0c7fe600,
+	0x080c0002, 0x0aa10088, 0x0a20c0c7, 0x00000000, 0x0fc01240,
+	0x07c006c9, 0x04000287, 0x094a1289, 0x07800649, 0x094c2289,
+	0x060c2c0a, 0x0a210407, 0x080c2800, 0x0fc05200, 0x060c0a08,
+	0x0a24c047, 0x07800708, 0x0a60c008, 0x0c781000, 0x080c2800,
+	0x078004c8, 0x0aa0c0c8, 0x06800088, 0x06800048, 0x064c2c09,
+	0x094c2248, 0x060c2c09, 0x080c2a00, 0x0c0139c0, 0x080c0000,
+	0x0c0156c0, 0x00000000, 0x0c7fddc0, 0x00000000, 0x07800008,
+	0x07c06108, 0x080c2800, 0x080c2a00, 0x0c0137c0, 0x080c0000,
+	0x00000000, 0x064c2908, 0x00000000, 0x0be42008, 0x00000000,
+	0x064c0008, 0x04841208, 0x0a6e5048, 0x07800008, 0x0a620008,
+	0x04401208, 0x07800049, 0x0aa14009, 0x06800008, 0x04401249,
+	0x07c00049, 0x07806188, 0x0c7fd780, 0x07c00008, 0x064c1008,
+	0x07c03c08, 0x064c1108, 0x07c03c48, 0x064c1208, 0x07c03c88,
+	0x064c1308, 0x07c03cc8, 0x064c1408, 0x07c03d08, 0x064c1508,
+	0x07c03d48, 0x064c1608, 0x07c03d88, 0x064c1708, 0x07c03dc8,
+	0x07c0f808, 0x0c013380, 0x00000000, 0x0c015640, 0x00000000,
+	0x0c7fd1c0, 0x00000000, 0x080c2a00, 0x0c012c00, 0x080c0004,
+	0x0c014900, 0x00000000, 0x0c7fd000, 0x00000000, 0x00000000,
+	0x0c78d180, 0x00000000, 0x0683ffc8, 0x07c00748, 0x078013c8,
+	0x09808008, 0x07c013c8, 0x0649cc09, 0x04001249, 0x0609cc09,
+	0x06807fc9, 0x0aa18009, 0x06494707, 0x091081c7, 0x07800008,
+	0x0a4fc207, 0x04401249, 0x0c000100, 0x00000000, 0x0c780d40,
+	0x00000000, 0x064e0008, 0x083f0040, 0x083f0000, 0x06490b07,
+	0x09807007, 0x09807087, 0x098073c7, 0x06090b07, 0x09c07007,
+	0x09c07087, 0x09c073c7, 0x06090b07, 0x0683ffc9, 0x06498f07,
+	0x0aa0c009, 0x0a6f8007, 0x04401249, 0x06498e07, 0x09807007,
+	0x09807607, 0x09807647, 0x09807687, 0x09807747, 0x06098e07,
+	0x09c07007, 0x09c07607, 0x09c07647, 0x09c07687, 0x09c07747,
+	0x06098e07, 0x064c0007, 0x09c07187, 0x09807207, 0x060c0007,
+	0x064c0807, 0x09807347, 0x060c0807, 0x083f0040, 0x083f0000,
+	0x08090b65, 0x00000000, 0x08090b60, 0x0cc00000, 0x060e0008,
+	0x0c796880, 0x00000000, 0x0c78c0c0, 0x00000000, 0x0a20d007,
+	0x0c7fef00, 0x00000000, 0x0fc081c0, 0x046b3207, 0x0c502280,
+	0x07803e89, 0x0aadc009, 0x046b8207, 0x0c57fcc0, 0x046b5207,
+	0x0c503440, 0x04600207, 0x0c5067c0, 0x046b2207, 0x0c504940,
+	0x046b7207, 0x0c505cc0, 0x07800888, 0x0aaac008, 0x07800788,
+	0x0aaa7fc8, 0x07801688, 0x0ac0d207, 0x0a807207, 0x06800048,
+	0x07c018c8, 0x078013c8, 0x09808008, 0x0c78b900, 0x07c013c8,
+	0x078018c8, 0x0aa10008, 0x06800008, 0x0c78b7c0, 0x07c018c8,
+	0x07c01687, 0x078000c8, 0x0acd8207, 0x04401207, 0x07800049,
+	0x0a804209, 0x078013c9, 0x09809009, 0x07c013c9, 0x07c06088,
+	0x0fc05200, 0x07c060c8, 0x0fc01200, 0x0aa0c008, 0x0c7fff80,
+	0x0fc08200, 0x080c2841, 0x07800188, 0x064c2807, 0x0a2fc047,
+	0x05801347, 0x0a60c00d, 0x0c78b1c0, 0x00000000, 0x044011cd,
+	0x07800009, 0x0a8041c9, 0x078013c9, 0x09809009, 0x07c013c9,
+	0x07c06047, 0x07800748, 0x0a405207, 0x07806087, 0x07800788,
+	0x0a402207, 0x0c780e00, 0x07800007, 0x07806108, 0x0b403207,
+	0x02408207, 0x07800008, 0x0b214008, 0x06800047, 0x0ae0c288,
+	0x06800287, 0x040001c8, 0x07800008, 0x0b4031c8, 0x024081c8,
+	0x06800008, 0x0c00f640, 0x00000000, 0x07800047, 0x07806088,
+	0x0aa68008, 0x0b819207, 0x0ac06207, 0x07800007, 0x07806048,
+	0x0b815207, 0x0aa08007, 0x0b013207, 0x06807807, 0x06800008,
+	0x06808009, 0x020091c9, 0x0d07ff87, 0x07400248, 0x07806047,
+	0x0440a1c7, 0x0b624007, 0x07806088, 0x04401208, 0x07c00048,
+	0x07800088, 0x02008207, 0x0ba0c008, 0x06800007, 0x040001c8,
+	0x07c00007, 0x07800047, 0x07806088, 0x0ac09207, 0x0b804207,
+	0x07800007, 0x07806048, 0x0b405207, 0x0c00dd80, 0x00000000,
+	0x0c7ffdc0, 0x00000000, 0x06800048, 0x07c00588, 0x080c2c00,
+	0x064c0108, 0x09809048, 0x060c0109, 0x060c0108, 0x07806048,
+	0x07c00008, 0x07806088, 0x07c00048, 0x078060c8, 0x060c0a08,
+	0x0c7fa600, 0x00000000, 0x06a00007, 0x07c00d07, 0x07c03e87,
+	0x0fc0c1c0, 0x0609c607, 0x0fc0c200, 0x0609c708, 0x0400f1c7,
+	0x058041c7, 0x060c0907, 0x07c00087, 0x04401247, 0x07c06189,
+	0x0400f208, 0x05804208, 0x07c000c8, 0x09508207, 0x0fc041c0,
+	0x0fc04200, 0x07c00108, 0x05404208, 0x02c07207, 0x0609c407,
+	0x0fc101c0, 0x0fc0f1c0, 0x06800009, 0x07c03e09, 0x064e0009,
+	0x0a2fc089, 0x06800008, 0x0a22c047, 0x06800807, 0x06800009,
+	0x06c00049, 0x060e0209, 0x0fc10240, 0x060e0209, 0x044011c7,
+	0x0aef4007, 0x00000000, 0x04c10208, 0x0fc011c0, 0x0a22c047,
+	0x06800807, 0x06800009, 0x06c00049, 0x060e0209, 0x0fc10240,
+	0x060e0309, 0x044011c7, 0x0aef4007, 0x00000000, 0x04c08208,
+	0x0c788f40, 0x060e0008, 0x06840047, 0x060c0107, 0x0649c409,
+	0x098097c9, 0x0fc081c0, 0x0fc011c0, 0x09601247, 0x0fc021c0,
+	0x0fc021c0, 0x09702247, 0x0fc021c0, 0x09742247, 0x0fc0d1c0,
+	0x0fc091c0, 0x0fc021c0, 0x09622247, 0x0fc051c0, 0x09665247,
+	0x0c788a40, 0x0609c409, 0x0c7889c0, 0x0fc041c0, 0x0fc041c0,
+	0x0aaa4047, 0x0aa181c7, 0x0a63c0c7, 0x064e0008, 0x0fc011c0,
+	0x0c7ff2c0, 0x00000000, 0x0fc101c0, 0x07c00487, 0x058041c7,
+	0x07800d08, 0x0940c207, 0x07c00d08, 0x07800e47, 0x0405b1c7,
+	0x0c788540, 0x074001c8, 0x0a6b0207, 0x00000000, 0x0fc101c0,
+	0x060c0207, 0x0fc0c1c0, 0x060c0307, 0x09102247, 0x07c004c9,
+	0x07c06309, 0x07803e08, 0x0649070b, 0x0980b0cb, 0x0a6140c9,
+	0x05001308, 0x0680000c, 0x06800008, 0x09c0b0cb, 0x07c03e0c,
+	0x078004ca, 0x0aa140ca, 0x0300a30a, 0x0500128a, 0x094e11ca,
+	0x060c0307, 0x0a614048, 0x0780018a, 0x0a60c04a, 0x00000000,
+	0x0980b10b, 0x0609070b, 0x0a6200c9, 0x06800088, 0x0a215007,
+	0x06800089, 0x07c00649, 0x0c7800c0, 0x06800048, 0x06800008,
+	0x07c00688, 0x090a1207, 0x07c00708, 0x0fc01240, 0x07c00549,
+	0x07800d08, 0x095e1209, 0x09021247, 0x095c1209, 0x090e1247,
+	0x095a1209, 0x078004c9, 0x0aa0c0c9, 0x06800049, 0x06800009,
+	0x09581209, 0x07c00d08, 0x07800e49, 0x0405b249, 0x07400248,
+	0x090e1247, 0x07c00509, 0x0c7875c0, 0x00000000, 0x06806349,
+	0x06800007, 0x06801c88, 0x07400247, 0x0d07ffc8, 0x04001249,
+	0x0cc00000, 0x00000000, 0x0649c907, 0x0befffc7, 0x00000000,
+	0x0c07fd40, 0x00000000, 0x06806349, 0x06800008, 0x0680000a,
+	0x064c2a07, 0x0a618007, 0x00000000, 0x064c3607, 0x058081c7,
+	0x0aa3c047, 0x00000000, 0x0fc081c0, 0x0be18048, 0x00000000,
+	0x04000287, 0x07400247, 0x0c780140, 0x00000000, 0x095081ca,
+	0x07400247, 0x04001249, 0x04001208, 0x0b2bb888, 0x00000000,
+	0x07806287, 0x040011c7, 0x07c06287, 0x0649cb0a, 0x06850008,
+	0x0240a20a, 0x0603510a, 0x06806247, 0x024091c9, 0x04003249,
+	0x05802249, 0x05402249, 0x06035209, 0x07806247, 0x0200a287,
+	0x0240b1c8, 0x05401249, 0x04007249, 0x05803249, 0x05403249,
+	0x07c06249, 0x020071c9, 0x0b405207, 0x06800008, 0x04000207,
+	0x0603510a, 0x07c06248, 0x06a06249, 0x06035009, 0x06435009,
+	0x0580f249, 0x0bef8049, 0x0a62c008, 0x0c07eec0, 0x00000000,
+	0x0603510a, 0x058012cb, 0x0603520b, 0x06a06349, 0x06035009,
+	0x06435009, 0x0580f249, 0x0bef8049, 0x06803f87, 0x07806248,
+	0x09610207, 0x0609c908, 0x08007401, 0x0649c907, 0x0befffc7,
+	0x00000000, 0x0c7809c0, 0x07800207, 0x0a608007, 0x0c780780,
+	0x044011c7, 0x0aa0c087, 0x07800289, 0x07800309, 0x0ae380c9,
+	0x00000000, 0x0405b1c9, 0x070001c7, 0x0609c507, 0x0403b1c9,
+	0x070001c8, 0x040081c7, 0x070001c7, 0x09610207, 0x0609cd08,
+	0x04001249, 0x0609c909, 0x08007401, 0x078002c9, 0x0ae281c9,
+	0x00000000, 0x0649c907, 0x0a6fc007, 0x0405b1c9, 0x070001c7,
+	0x0609c507, 0x04001249, 0x0609c909, 0x08007401, 0x06803fc9,
+	0x07c00289, 0x07c002c9, 0x07c00309, 0x06800009, 0x07c00209,
+	0x0c7855c0, 0x00000000, 0x07800889, 0x0a608009, 0x0c780700,
+	0x07800789, 0x0aa0ffc9, 0x0c008a80, 0x00000000, 0x07800889,
+	0x0aa58009, 0x0683ffc9, 0x0aa1c009, 0x06494707, 0x091081c7,
+	0x07806188, 0x0aa40008, 0x0a4fb207, 0x04401249, 0x0683ffc8,
+	0x0649bb07, 0x0900c1c7, 0x0aa10007, 0x0aa0c008, 0x0c7fff00,
+	0x04401208, 0x0649bc07, 0x093e11c7, 0x0a2f8047, 0x00000000,
+	0x0c078200, 0x00000000, 0x06800007, 0x07c01687, 0x07c018c7,
+	0x064c5108, 0x064c4609, 0x064c4207, 0x064c400a, 0x02407287,
+	0x040081c7, 0x0580a1c7, 0x0e000207, 0x02409289, 0x00000000,
+	0x00000000, 0x0f0001c0, 0x0f010200, 0x097081c8, 0x0540a1c7,
+	0x02007247, 0x064c4308, 0x02407207, 0x07c012c7, 0x058101c7,
+	0x07c01307, 0x0c00c840, 0x00000000, 0x0fc0a1c0, 0x07c062c7,
+	0x0fc031c0, 0x078062c8, 0x09543207, 0x07c062c8, 0x0ba08047,
+	0x0b20c0c7, 0x0c7fef80, 0x00000000, 0x044011c7, 0x07c00187,
+	0x060c0407, 0x06800008, 0x09808048, 0x0a234088, 0x06800049,
+	0x07800848, 0x0b628088, 0x0aa10087, 0x0aa18007, 0x0a614008,
+	0x00000000, 0x06800009, 0x0c784140, 0x07c00889, 0x04001208,
+	0x07c00848, 0x07c00889, 0x0aa48007, 0x06800009, 0x064c040a,
+	0x0fc10200, 0x0fc01200, 0x094a1288, 0x0fc03200, 0x09503248,
+	0x09583248, 0x0a61c087, 0x09583248, 0x0fc01200, 0x09481288,
+	0x0fc03200, 0x09403248, 0x09483248, 0x060c0209, 0x060c040a,
+	0x06800008, 0x07c003c8, 0x07800088, 0x05404208, 0x078000c9,
+	0x05404249, 0x09610248, 0x06090809, 0x06804008, 0x06090708,
+	0x07803e07, 0x046011c7, 0x0c503780, 0x00000000, 0x0649c909,
+	0x0aa10009, 0x06800087, 0x0c7f3500, 0x07c001c7, 0x07800207,
+	0x0a608007, 0x0c780d00, 0x044011c7, 0x0aa0c087, 0x07800289,
+	0x07800309, 0x0b2081c9, 0x0c780b80, 0x00000000, 0x078013c8,
+	0x07800207, 0x044011c7, 0x0a610087, 0x00000000, 0x0be38148,
+	0x0c780380, 0x0be100c8, 0x09808088, 0x09c08088, 0x0c780180,
+	0x0be14048, 0x09808048, 0x0a60c007, 0x00000000, 0x09c08048,
+	0x07c013c8, 0x0a20c0c8, 0x00000000, 0x098073c7, 0x07800e48,
+	0x04050208, 0x07400207, 0x078013c8, 0x09c08008, 0x07c013c8,
+	0x0405b1c9, 0x070001c7, 0x04050209, 0x07000208, 0x05410208,
+	0x02c07207, 0x0609c507, 0x0403b1c9, 0x070001c8, 0x040081c7,
+	0x070001c7, 0x09610207, 0x0609cd08, 0x04001249, 0x0609c909,
+	0x08007401, 0x06800009, 0x07c00209, 0x06800009, 0x07c001c9,
+	0x07800247, 0x02c07247, 0x0780090a, 0x078008e1, 0x0be0c047,
+	0x0c780880, 0x06800008, 0x0780098a, 0x07800961, 0x0a278087,
+	0x06800048, 0x07800a0a, 0x078009e1, 0x0a268107, 0x06800088,
+	0x07800a8a, 0x07800a61, 0x0a258207, 0x068000c8, 0x07800b0a,
+	0x07800ae1, 0x0a248407, 0x06800108, 0x07800b8a, 0x07800b61,
+	0x0a238807, 0x06800148, 0x07800c4a, 0x07800c21, 0x0a229007,
+	0x06800188, 0x07800cca, 0x07800ca1, 0x0a21a007, 0x068001c8,
+	0x0809ce01, 0x06800047, 0x0c7f1d40, 0x07c001c7, 0x096102a1,
+	0x07800387, 0x090041c7, 0x0a8061c8, 0x07800187, 0x0a620087,
+	0x07800387, 0x090841c7, 0x0a4051c8, 0x06800047, 0x03407207,
+	0x0c7ff380, 0x02c091c9, 0x0809ce00, 0x06800047, 0x07800349,
+	0x0a60c008, 0x0c780600, 0x09401247, 0x0a60c048, 0x0c780540,
+	0x09481247, 0x0a60c088, 0x0c780480, 0x09501247, 0x0a60c0c8,
+	0x0c7803c0, 0x09581247, 0x07801609, 0x0a60c108, 0x0c780240,
+	0x09401247, 0x0a60c148, 0x0c780180, 0x09481247, 0x0a60c188,
+	0x0c7800c0, 0x09501247, 0x09581247, 0x0c7800c0, 0x07c01609,
+	0x07c00349, 0x07800d09, 0x0405b1c8, 0x07c00e48, 0x074001c9,
+	0x078012c9, 0x0403b1c8, 0x074001c9, 0x07801309, 0x040081c7,
+	0x074001c9, 0x06800047, 0x03407207, 0x07800249, 0x02c091c9,
+	0x07c00249, 0x0609b20a, 0x0609920a, 0x07800187, 0x04001247,
+	0x07c00209, 0x0a608087, 0x0c780340, 0x078002c7, 0x07c00307,
+	0x07c002c8, 0x06499109, 0x06099009, 0x07800389, 0x05404249,
+	0x09404248, 0x07c00389, 0x0609910a, 0x0c7800c0, 0x00000000,
+	0x07c00288, 0x08098002, 0x078004ce, 0x0a64c0ce, 0x00000000,
+	0x06499011, 0x054103d1, 0x0581040f, 0x02c0f40f, 0x0609810f,
+	0x06499111, 0x054103d1, 0x0581040f, 0x02c0f40f, 0x0609820f,
+	0x080980f0, 0x078004ce, 0x0aa6c0ce, 0x00000000, 0x080980f4,
+	0x0c780600, 0x00000000, 0x07803e0e, 0x0aab800e, 0x00000000,
+	0x06499011, 0x054103d1, 0x0649b110, 0x05410410, 0x078004ce,
+	0x0a61404e, 0x00000000, 0x058103cf, 0x0c7800c0, 0x00000000,
+	0x05810410, 0x02c0f40f, 0x0609810f, 0x06499111, 0x054103d1,
+	0x0581040f, 0x02c0f40f, 0x0609820f, 0x080980f4, 0x06800009,
+	0x07c00009, 0x0c780080, 0x07c00049, 0x064c0009, 0x0a2fc049,
+	0x00000000, 0x064c3a09, 0x09006249, 0x0aaec649, 0x00000000,
+	0x080c2800, 0x080c0002, 0x0c7efb80, 0x00000000, 0x0c0011c0,
+	0x00000000, 0x08011f00, 0x08002515, 0x08002605, 0x08002708,
+	0x08002801, 0x08002a09, 0x08007601, 0x0649c003, 0x07c00903,
+	0x058100c3, 0x07c008c3, 0x0649c103, 0x07c00983, 0x058100c3,
+	0x07c00943, 0x0649c203, 0x07c00a03, 0x058100c3, 0x07c009c3,
+	0x0649c303, 0x07c00a83, 0x058100c3, 0x07c00a43, 0x0649c403,
+	0x07c00b03, 0x058100c3, 0x07c00ac3, 0x0649c503, 0x07c00b83,
+	0x058100c3, 0x07c00b43, 0x0649c603, 0x07c00c43, 0x058100c3,
+	0x07c00c03, 0x0649c703, 0x07c00cc3, 0x058100c3, 0x07c00c83,
+	0x06498e03, 0x098037c3, 0x06098e03, 0x0649ca07, 0x0aa48007,
+	0x00000000, 0x09010207, 0x092101c7, 0x0609c607, 0x0609c708,
+	0x0400f1c7, 0x058041c7, 0x060c0907, 0x07c00087, 0x04401247,
+	0x07c06189, 0x0400f208, 0x05804208, 0x07c000c8, 0x09508207,
+	0x06800007, 0x07c00d07, 0x0cc00000, 0x00000000, 0x0c7eea40,
+	0x00000000, 0x0cc00000, 0x00400000, 0x0c7ee940, 0x00000000,
+	0x0684001f, 0x060c011f, 0x064c001f, 0x09c1f19f, 0x0981f21f,
+	0x060c001f, 0x0680001f, 0x07c0021f, 0x07c0025f, 0x07c001df,
+	0x07c0041f, 0x07c0085f, 0x07c0089f, 0x06803fe0, 0x07c002a0,
+	0x07c002e0, 0x07c00320, 0x07c003a0, 0x068000a0, 0x07c00660,
+	0x06800060, 0x07c006a0, 0x06800020, 0x07c00720, 0x068000e0,
+	0x07c004e0, 0x06804020, 0x07c06020, 0x0cc00000, 0x00000000,
+	0x0c7ff800, 0x00000000, 0x078003de, 0x0400179e, 0x07c003de,
+	0x0649ce1e, 0x0a64401e, 0x064c411e, 0x064c4322, 0x0968c7a2,
+	0x0a40d8de, 0x040008de, 0x064c471e, 0x0ba2a01e, 0x0ba26022,
+	0x0780165e, 0x0400179e, 0x07c0165e, 0x0a61c21e, 0x00000000,
+	0x0809cf01, 0x0c780000, 0x00000000, 0x0680001e, 0x07c0165e,
+	0x0cc00000, 0x00400000, 0x0649c828, 0x0aa68028, 0x0a20e028,
+	0x0c7805c0, 0x07c00428, 0x0aa3c068, 0x06bfffa9, 0x0aa340a8,
+	0x06bfff69, 0x0aa2c0e8, 0x06bffee9, 0x0aa24128, 0x06bffde9,
+	0x0aa1c168, 0x06bffbe9, 0x0aa141a8, 0x06bff7e9, 0x0aa0c1e8,
+	0x06bfefe9, 0x06bfdfe9, 0x00800000, 0x0809ce00, 0x07800268,
+	0x02828a68, 0x07c00268, 0x00400000, 0x0809c800, 0x078001e8,
+	0x0a618028, 0x07800ea8, 0x0aa18028, 0x06802028, 0x064c4329,
+	0x0b003a29, 0x06800128, 0x06030528, 0x0cc00000, 0x00000000,
+	0x07800189, 0x0aa0c089, 0x06800208, 0x07c00608, 0x078004c8,
+	0x0aa0c0c8, 0x06800088, 0x06800048, 0x07c00648, 0x0aa10089,
+	0x06800008, 0x07c03c08, 0x07c03c48, 0x07c0f808, 0x06800048,
+	0x07c03e48, 0x07800188, 0x0a614048, 0x0c004a00, 0x00000000,
+	0x0c780100, 0x00000000, 0x0c005000, 0x00000000, 0x0c002c40,
+	0x00000000, 0x07800009, 0x04001249, 0x07c00009, 0x07800088,
+	0x0b809209, 0x06800009, 0x07c00009, 0x07800048, 0x04001208,
+	0x078000c9, 0x0b803248, 0x07c00048, 0x0680008d, 0x0cc00000,
+	0x00000000, 0x07800007, 0x07806108, 0x0b403207, 0x02408207,
+	0x07800008, 0x0b214008, 0x06800047, 0x0ae0c288, 0x06800287,
+	0x040001c8, 0x07800008, 0x0b4031c8, 0x024081c8, 0x06800008,
+	0x0c0011c0, 0x00000000, 0x07800787, 0x0a60bfc7, 0x0cc00000,
+	0x0c000100, 0x00000000, 0x0c7ffec0, 0x00000000, 0x078004c8,
+	0x0aa0c0c8, 0x06800088, 0x06800048, 0x07c00648, 0x07800009,
+	0x05402249, 0x06808008, 0x02009209, 0x07100248, 0x090011c8,
+	0x05c01208, 0x07c03c48, 0x04001249, 0x07100248, 0x07c03c08,
+	0x04001249, 0x07100248, 0x090012c8, 0x05c01208, 0x07c03d48,
+	0x04001249, 0x07100248, 0x07c03d08, 0x054022cb, 0x094612c7,
+	0x0a60c30b, 0x0c780240, 0x0680020b, 0x0a61c00b, 0x06800008,
+	0x07c03c48, 0x07c03c08, 0x07c03d48, 0x07c03d08, 0x0680020b,
+	0x07c0060b, 0x07c0f808, 0x06800048, 0x07c03e48, 0x0c003b80,
+	0x00000000, 0x0c0017c0, 0x00000000, 0x07800009, 0x04001249,
+	0x07c00009, 0x07800088, 0x0b80c209, 0x06800009, 0x07c00009,
+	0x07800048, 0x04001208, 0x078000c9, 0x0b806248, 0x07c00048,
+	0x06800009, 0x07c00049, 0x06803fc9, 0x07c00789, 0x0cc00000,
+	0x00000000, 0x07800189, 0x0a640009, 0x07800049, 0x0540a249,
+	0x0649cb07, 0x020091c9, 0x06035109, 0x07800089, 0x05402249,
+	0x06035209, 0x06b08009, 0x06035009, 0x06435009, 0x0580f249,
+	0x0bef8049, 0x0cc00000, 0x07c00008, 0x07906149, 0x0b403209,
+	0x0cc00000, 0x07c00008, 0x044011c9, 0x07c06147, 0x05402249,
+	0x06808007, 0x020091c9, 0x07806007, 0x0680400b, 0x0ac032c7,
+	0x044041c7, 0x06805f07, 0x07c06007, 0x070001cb, 0x0740024b,
+	0x040011c7, 0x04001249, 0x070001cb, 0x0740024b, 0x040011c7,
+	0x04001249, 0x070001cb, 0x0740024b, 0x040011c7, 0x04001249,
+	0x070001cb, 0x0c7ff4c0, 0x0740024b, 0x064c4414, 0x09101514,
+	0x0a6f8014, 0x0c7ea500, 0x00000000, 0x0c0005c0, 0x00000000,
+	0x07800007, 0x040011c7, 0x07c00747, 0x07800049, 0x07800088,
+	0x0b403207, 0x0cc00000, 0x07c00789, 0x06800008, 0x07c00748,
+	0x04001209, 0x078000c9, 0x0b403248, 0x0cc00000, 0x07c00788,
+	0x06411f08, 0x04001208, 0x06011f08, 0x06803fc8, 0x0cc00000,
+	0x07c00788, 0x07800009, 0x07c06149, 0x06808008, 0x05402249,
+	0x02008248, 0x07806007, 0x07000209, 0x074001c9, 0x04001208,
+	0x040011c7, 0x07000209, 0x074001c9, 0x04001208, 0x040011c7,
+	0x07000209, 0x074001c9, 0x04001208, 0x040011c7, 0x07000209,
+	0x074001c9, 0x04403208, 0x040011c7, 0x09c071c7, 0x07c06007,
+	0x07800607, 0x0be4c047, 0x07903c49, 0x05401249, 0x090612c7,
+	0x0940124b, 0x07400209, 0x04001208, 0x07903c09, 0x07400209,
+	0x04001208, 0x07903d49, 0x05401249, 0x090412c7, 0x0940124b,
+	0x07400209, 0x04001208, 0x07903d09, 0x0c780840, 0x07400209,
+	0x07800009, 0x0a610009, 0x044041c8, 0x0c780700, 0x00000000,
+	0x0780618b, 0x0b4102c9, 0x070001c9, 0x07400209, 0x040011c7,
+	0x04001208, 0x070001c9, 0x07400209, 0x040011c7, 0x04001208,
+	0x070001c9, 0x07400209, 0x040011c7, 0x04001208, 0x070001c9,
+	0x0c7802c0, 0x07400209, 0x06800049, 0x07400209, 0x04001208,
+	0x06800009, 0x07400209, 0x04001208, 0x07400209, 0x04001208,
+	0x07400209, 0x07800189, 0x0a644049, 0x07800009, 0x07806188,
+	0x0b80e209, 0x07800049, 0x0540a249, 0x0649cb08, 0x02009209,
+	0x06035109, 0x07800089, 0x05402249, 0x06035209, 0x06a08009,
+	0x06035009, 0x06435009, 0x0580f249, 0x0bef8049, 0x0cc00000,
+	0x00000000, 0x06490604, 0x0aefcc04, 0x00000000, 0x07800004,
+	0x07800045, 0x09508144, 0x06800084, 0x06c00004, 0x078004c6,
+	0x04001186, 0x09562106, 0x06090604, 0x06090605, 0x06881044,
+	0x09562106, 0x06090604, 0x0cc00000, 0x00000000, 0x06490604,
+	0x0aefcc04, 0x00000000, 0x07800004, 0x07800045, 0x09508144,
+	0x06900184, 0x06c00004, 0x078004c6, 0x04001186, 0x09562106,
+	0x06090604, 0x06090605, 0x08090600, 0x06800004, 0x095e2106,
+	0x06090604, 0x06985144, 0x06c00004, 0x09562106, 0x06090604,
+	0x0cc00000, 0x00000000, 0x06800007, 0x07c06107, 0x07c00747,
+	0x0cc00000, 0x07c00787, 0x06490604, 0x0aefcc04, 0x00000000,
+	0x0680000a, 0x07800004, 0x07800049, 0x09508244, 0x06800087,
+	0x07803e44, 0x0a60c044, 0x06c00007, 0x09807087, 0x07800606,
+	0x0be10106, 0x00000000, 0x0c780140, 0x09807387, 0x0a20c206,
+	0x098073c7, 0x09807387, 0x07800645, 0x078004cb, 0x0a67c0cb,
+	0x0a208306, 0x0a618085, 0x06800008, 0x0c000e40, 0x00000000,
+	0x0c780d40, 0x00000000, 0x0680000a, 0x0a6180c5, 0x0780018c,
+	0x0a61404c, 0x00000000, 0x0c7800c0, 0x09807407, 0x0a638045,
+	0x06800084, 0x095621c4, 0x06800044, 0x094a31c4, 0x0c000a40,
+	0x06800088, 0x068000c4, 0x095621c4, 0x09c07047, 0x0c000900,
+	0x068000c8, 0x0c780800, 0x00000000, 0x0c780000, 0x00000000,
+	0x0aa0c04b, 0x06800084, 0x068000c4, 0x095621c4, 0x0a208306,
+	0x0a614045, 0x0c000600, 0x06800008, 0x0c780500, 0x00000000,
+	0x0a6240c5, 0x0780018c, 0x0a62004c, 0x00000000, 0x06800008,
+	0x0c0003c0, 0x09807407, 0x0c7802c0, 0x00000000, 0x0a6ac085,
+	0x06800044, 0x094a31c4, 0x0c000200, 0x06800088, 0x09807107,
+	0x09c07047, 0x0c000100, 0x068000c8, 0x0cc00000, 0x00000000,
+	0x0680000b, 0x06c0004b, 0x0aa0c0c8, 0x06090607, 0x06090609,
+	0x091c2187, 0x0aa5c086, 0x07803c04, 0x0a6180c8, 0x07803c45,
+	0x0a8042c7, 0x00000000, 0x07803c84, 0x07803cc5, 0x06090604,
+	0x09181107, 0x091e1245, 0x02809244, 0x07803e4c, 0x0aa1004c,
+	0x0a0042c7, 0x00000000, 0x068000c6, 0x09161247, 0x03405285,
+	0x09601144, 0x095e1149, 0x0aa5c046, 0x06090605, 0x07803d04,
+	0x0a6100c8, 0x07803d45, 0x07803d84, 0x07803dc5, 0x06090604,
+	0x09181107, 0x091e1245, 0x02809244, 0x07803e4c, 0x0aa1804c,
+	0x0a0062c7, 0x00000000, 0x09161247, 0x0c7800c0, 0x05001249,
+	0x09161247, 0x03405285, 0x09601144, 0x095e1149, 0x06090605,
+	0x09804347, 0x09804204, 0x09804184, 0x0aa0c088, 0x09c04044,
+	0x09804004, 0x0cc00000, 0x06090604, 0x0c7e5840, 0x00000000,
+	0x0609c42d, 0x00000000, 0x0649c42d, 0x0a6f802d, 0x00000000,
+	0x0cc00000, 0x00000000, 0x0fc09200, 0x0fc101c0, 0x078061c9,
+	0x0780620b, 0x07c061c7, 0x07c06208, 0x05410208, 0x02c081c8,
+	0x054102cb, 0x02c0b24b, 0x0fc021c0, 0x0be10047, 0x0c780940,
+	0x0a60800b, 0x0c7808c0, 0x09265248, 0x05406289, 0x05402249,
+	0x0240a24a, 0x091a6248, 0x02009289, 0x05406289, 0x05402249,
+	0x0240a24a, 0x090c6248, 0x02008289, 0x0926524b, 0x05406289,
+	0x05402249, 0x0240a24a, 0x091a624b, 0x02009289, 0x05406289,
+	0x05402249, 0x0240a24a, 0x090c624b, 0x0200b289, 0x0b8052c8,
+	0x024082c8, 0x06800207, 0x0b4021c8, 0x0c780200, 0x06800007,
+	0x07c00847, 0x07c00887, 0x06800008, 0x07c061c8, 0x07c06208,
+	0x00000000, 0x0c7f4c80, 0x0fc071c0
+
 };
 
 
diff --git a/drivers/amlogic/amports/arch/ucode/mpeg4/vmpeg4_mc.c b/drivers/amlogic/amports/arch/ucode/mpeg4/vmpeg4_mc.c
index 9536c0c..7a00a86 100644
--- a/drivers/amlogic/amports/arch/ucode/mpeg4/vmpeg4_mc.c
+++ b/drivers/amlogic/amports/arch/ucode/mpeg4/vmpeg4_mc.c
@@ -20,476 +20,476 @@
 #define VERSTR "00000"
 
 const u32 vmpeg4_mc_4[] __initconst = {
-	0x0680c001, 0x06800000, 0x0d000001, 0x07400040, 0x0c014d40,
+	0x0680c001, 0x06800000, 0x0d000001, 0x07400040, 0x0c014f40,
 	0x00000000, 0x00000000, 0x00000000, 0x080c0002, 0x080c2901,
-	0x06bfde80, 0x07c017c0, 0x06030400, 0x00400000, 0x0c01a400,
+	0x06bfde80, 0x07c017c0, 0x06030400, 0x00400000, 0x0c01a600,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x0c7ffe80, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x0c780400, 0x04001965, 0x0cc00000,
-	0x00400000, 0x0c7804c0, 0x064c0007, 0x0c79ab00, 0x06800025,
+	0x00400000, 0x0c7804c0, 0x064c0007, 0x0c79ad00, 0x06800025,
 	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
-	0x00400000, 0x0c79f800, 0x06800025, 0x0cc00000, 0x00400000,
+	0x00400000, 0x0c79fa00, 0x06800025, 0x0cc00000, 0x00400000,
 	0x06800025, 0x00800000, 0x078017c9, 0x0c7ffec0, 0x06030409,
-	0x078001c9, 0x0aa0c009, 0x0c790940, 0x00000000, 0x06bfdd89,
+	0x078001c9, 0x0aa0c009, 0x0c790980, 0x00000000, 0x06bfdd89,
 	0x06030409, 0x00400000, 0x07801509, 0x0aa2c109, 0x07c0151f,
-	0x0a2c4047, 0x06800025, 0x0aa14009, 0x0a608049, 0x0c791300,
-	0x0a608089, 0x0c7905c0, 0x0a240807, 0x0c789400, 0x00000000,
+	0x0a2c4047, 0x06800025, 0x0aa14009, 0x0a608049, 0x0c791500,
+	0x0a608089, 0x0c790600, 0x0a240807, 0x0c789440, 0x00000000,
 	0x0683ffc8, 0x0ba20048, 0x064c0007, 0x0a2f8047, 0x04401208,
 	0x064c3a07, 0x090061c7, 0x0aae8647, 0x00000000, 0x06800007,
-	0x0c017b00, 0x07c003c7, 0x0c7934c0, 0x0bec9007, 0x078003c7,
+	0x0c017d00, 0x07c003c7, 0x0c7936c0, 0x0bec9007, 0x078003c7,
 	0x0a6fc007, 0x07800007, 0x07800988, 0x0b822207, 0x06800007,
 	0x07c00007, 0x0a628060, 0x06a00008, 0x06e00008, 0x06431e09,
 	0x0befc049, 0x00000000, 0x080c24a0, 0x060c2208, 0x0c780300,
 	0x060c2208, 0x0a6280a0, 0x00000000, 0x06431e09, 0x0befc049,
 	0x00000000, 0x080c24c0, 0x080c2200, 0x080c2200, 0x080c2200,
 	0x080c2200, 0x078016c8, 0x04001208, 0x078009c9, 0x0b80a248,
-	0x07c016c8, 0x0c020f00, 0x00000000, 0x078003c7, 0x0a6fc007,
-	0x0c792b40, 0x00000000, 0x06431e09, 0x0befc049, 0x07800347,
-	0x0aa0c007, 0x0c780880, 0x00000000, 0x064c1d07, 0x09227207,
-	0x0a678008, 0x064c2a08, 0x064c3607, 0x091081c7, 0x095101c8,
-	0x064c3b08, 0x09103248, 0x04001209, 0x03807207, 0x0900f207,
-	0x0a650008, 0x0580f1c7, 0x06800048, 0x05407208, 0x03808248,
-	0x04401208, 0x0a40e207, 0x064c1d07, 0x0a60c009, 0x00000000,
-	0x054081c7, 0x06800009, 0x09201207, 0x0a610008, 0x054011c7,
-	0x0c7fff40, 0x04001249, 0x060c0e09, 0x0c021300, 0x00000000,
-	0x0aa080a0, 0x0c780f40, 0x078003c7, 0x0a6fc007, 0x07801bc8,
-	0x0a63c008, 0x078004c8, 0x0a634348, 0x06800107, 0x07c003c7,
-	0x08030580, 0x068003c9, 0x07c00149, 0x06800007, 0x0c019080,
-	0x07c01d07, 0x07800007, 0x040011c7, 0x0c7fe880, 0x07c00007,
-	0x0c793040, 0x078003c7, 0x0a6fc007, 0x078005c7, 0x0ba0c087,
-	0x06800007, 0x06800047, 0x07c01fc7, 0x07800787, 0x0aa180c7,
-	0x06810007, 0x060e0907, 0x060e0a07, 0x0c780440, 0x060e0b07,
-	0x07800507, 0x0aa0c007, 0x068000c8, 0x068003c8, 0x060e1408,
-	0x064e1507, 0x060e0907, 0x04003208, 0x060e1408, 0x064e1507,
-	0x060e0a07, 0x04003208, 0x060e1408, 0x064e1507, 0x060e0b07,
-	0x0683ffc7, 0x080e1418, 0x060e1507, 0x080e141b, 0x060e1507,
-	0x080e141e, 0x060e1507, 0x080e1421, 0x0c01f580, 0x060e1507,
-	0x0c7855c0, 0x00000000, 0x0aa6c020, 0x00000000, 0x0fc011c0,
-	0x0aa64007, 0x080c2803, 0x06800347, 0x07c00147, 0x06431e07,
-	0x0befc047, 0x00000000, 0x080c24a0, 0x060c2224, 0x060c2224,
-	0x06800007, 0x07c01d07, 0x06800025, 0x064c3c07, 0x091011c7,
-	0x0ae1c225, 0x0aaf8007, 0x064c3c07, 0x091011c7, 0x0aae8007,
-	0x0c7ff000, 0x080c2800, 0x0c7fd380, 0x00000000, 0x080c2801,
-	0x064c2807, 0x0a2fc047, 0x064c0008, 0x0a209008, 0x0c7fd1c0,
-	0x058011c7, 0x09004207, 0x07c00148, 0x090821c7, 0x07c00187,
-	0x0aa140c8, 0x080c2800, 0x0aa0c108, 0x0c781940, 0x00000000,
-	0x0fc011c0, 0x0540e1c7, 0x060c2d07, 0x080c2802, 0x064c2807,
-	0x0a2fc047, 0x058011c7, 0x07800188, 0x09444207, 0x07c01388,
-	0x07800148, 0x0a644108, 0x080c2800, 0x0fc021c0, 0x0b61c087,
-	0x07800109, 0x024091c9, 0x0b620089, 0x04401249, 0x0c780180,
-	0x06800049, 0x020091c9, 0x0b20c809, 0x04401249, 0x068007c9,
-	0x07c00109, 0x0c013240, 0x040001c9, 0x07801fcb, 0x0aa1400b,
-	0x078005c9, 0x0b60c089, 0x0c0048c0, 0x00000000, 0x068fdfca,
+	0x07c016c8, 0x0c021100, 0x00000000, 0x078003c7, 0x0a6fc007,
+	0x0c792d40, 0x00000000, 0x06431e09, 0x0befc049, 0x0a64c0a0,
+	0x078003c7, 0x0a6fc007, 0x07801bc8, 0x0a63c008, 0x078004c8,
+	0x0a634348, 0x06800107, 0x07c003c7, 0x08030580, 0x068003c9,
+	0x07c00149, 0x06800007, 0x0c019bc0, 0x07c01d07, 0x07800007,
+	0x040011c7, 0x0c7ff1c0, 0x07c00007, 0x07800347, 0x0aa0c007,
+	0x0c780880, 0x00000000, 0x064c1d07, 0x09227207, 0x0a678008,
+	0x064c2a08, 0x064c3607, 0x091081c7, 0x095101c8, 0x064c3b08,
+	0x09103248, 0x04001209, 0x03807207, 0x0900f207, 0x0a650008,
+	0x0580f1c7, 0x06800048, 0x05407208, 0x03808248, 0x04401208,
+	0x0a40e207, 0x064c1d07, 0x0a60c009, 0x00000000, 0x054081c7,
+	0x06800009, 0x09201207, 0x0a610008, 0x054011c7, 0x0c7fff40,
+	0x04001249, 0x060c0e09, 0x0c021040, 0x00000000, 0x0aa080a0,
+	0x0c780ac0, 0x0c793200, 0x078003c7, 0x0a6fc007, 0x078005c7,
+	0x0ba0c087, 0x06800007, 0x06800047, 0x07c01fc7, 0x07800787,
+	0x0aa180c7, 0x06810007, 0x060e0907, 0x060e0a07, 0x0c780440,
+	0x060e0b07, 0x07800507, 0x0aa0c007, 0x068000c8, 0x068003c8,
+	0x060e1408, 0x064e1507, 0x060e0907, 0x04003208, 0x060e1408,
+	0x064e1507, 0x060e0a07, 0x04003208, 0x060e1408, 0x064e1507,
+	0x060e0b07, 0x0683ffc7, 0x080e1418, 0x060e1507, 0x080e141b,
+	0x060e1507, 0x080e141e, 0x060e1507, 0x080e1421, 0x0c01f740,
+	0x060e1507, 0x0c7855c0, 0x00000000, 0x0aa6c020, 0x00000000,
+	0x0fc011c0, 0x0aa64007, 0x080c2803, 0x06800347, 0x07c00147,
+	0x06431e07, 0x0befc047, 0x00000000, 0x080c24a0, 0x060c2224,
+	0x060c2224, 0x06800007, 0x07c01d07, 0x06800025, 0x064c3c07,
+	0x091011c7, 0x0ae1c225, 0x0aaf8007, 0x064c3c07, 0x091011c7,
+	0x0aae8007, 0x0c7ff000, 0x080c2800, 0x0c7fd340, 0x00000000,
+	0x080c2801, 0x064c2807, 0x0a2fc047, 0x064c0008, 0x0a209008,
+	0x0c7fd180, 0x058011c7, 0x09004207, 0x07c00148, 0x090821c7,
+	0x07c00187, 0x0aa140c8, 0x080c2800, 0x0aa0c108, 0x0c781940,
+	0x00000000, 0x0fc011c0, 0x0540e1c7, 0x060c2d07, 0x080c2802,
+	0x064c2807, 0x0a2fc047, 0x058011c7, 0x07800188, 0x09444207,
+	0x07c01388, 0x07800148, 0x0a644108, 0x080c2800, 0x0fc021c0,
+	0x0b61c087, 0x07800109, 0x024091c9, 0x0b620089, 0x04401249,
+	0x0c780180, 0x06800049, 0x020091c9, 0x0b20c809, 0x04401249,
+	0x068007c9, 0x07c00109, 0x0c013400, 0x040001c9, 0x07801fcb,
+	0x0aa1400b, 0x078005c9, 0x0b60c089, 0x0c0048c0, 0x00000000,
+	0x068fdfca, 0x06feffca, 0x064e0408, 0x02808288, 0x078005ca,
+	0x0ba0c08a, 0x064c0909, 0x098083c8, 0x0ac0424a, 0x0780000a,
+	0x0a60c00a, 0x0400128a, 0x09808388, 0x0b80324a, 0x00000000,
+	0x098081c8, 0x07808007, 0x09605207, 0x07800007, 0x06808049,
+	0x02007247, 0x070001c7, 0x096a5207, 0x060e0408, 0x091e1248,
+	0x07c01fc9, 0x07801388, 0x060c2b08, 0x06880008, 0x098083c8,
+	0x07800507, 0x07801989, 0x0a610049, 0x09581207, 0x09808408,
+	0x098083c8, 0x060e0508, 0x06800009, 0x07800bc8, 0x09541248,
+	0x060c2a09, 0x07801c07, 0x0aa1c007, 0x080c2c03, 0x0fc011c0,
+	0x07c01cc7, 0x068000c9, 0x094a1247, 0x060c2c09, 0x0c01d6c0,
+	0x00000000, 0x080c0080, 0x0c015e80, 0x00000000, 0x080c24a0,
+	0x080c2200, 0x080c2200, 0x07800007, 0x040011c7, 0x07c00007,
+	0x07800147, 0x0c013400, 0x07c00447, 0x0c7fb080, 0x00000000,
+	0x0a60c0e0, 0x06800007, 0x0fc011c0, 0x07c01707, 0x080c2802,
+	0x064c2807, 0x0a2fc047, 0x058011c7, 0x068003c8, 0x024071c8,
+	0x07800188, 0x09444207, 0x07c01388, 0x07800148, 0x0a644048,
+	0x080c2800, 0x0fc021c0, 0x0b61c087, 0x07800109, 0x024091c9,
+	0x0b620089, 0x04401249, 0x0c780180, 0x06800049, 0x020091c9,
+	0x0b20c809, 0x04401249, 0x068007c9, 0x07c00109, 0x0c011a80,
+	0x040001c9, 0x07801388, 0x060c2b08, 0x07801c07, 0x0a60c007,
+	0x0c7806c0, 0x06800009, 0x0aa10008, 0x080c2800, 0x0fc011c0,
+	0x07c01cc7, 0x07800148, 0x0aa14088, 0x06800009, 0x0aa0c148,
+	0x07800489, 0x0fc01240, 0x07c01d09, 0x0aa38009, 0x0aa34148,
+	0x0aa201c8, 0x00000000, 0x0fc011c0, 0x07c01d47, 0x0fc011c0,
+	0x07c01d87, 0x0a618188, 0x00000000, 0x0fc011c0, 0x07c01dc7,
+	0x0fc011c0, 0x07c01e07, 0x07800148, 0x09501209, 0x07801709,
+	0x09521209, 0x060c2108, 0x07801cc8, 0x05405208, 0x060c2c08,
+	0x06880008, 0x07801989, 0x0aa0c049, 0x07800507, 0x098083c8,
+	0x09581207, 0x060e0508, 0x06800009, 0x07800bc8, 0x09541248,
+	0x060c2a09, 0x064c2408, 0x0befc3c8, 0x078003c8, 0x0a6fc008,
+	0x00000000, 0x080c0080, 0x0aa080a0, 0x0c7812c0, 0x080c2110,
+	0x07800147, 0x0aa38147, 0x078004c7, 0x07c00387, 0x07800487,
+	0x07c00247, 0x07801107, 0x07c01787, 0x06800107, 0x07c003c7,
+	0x08030580, 0x064c2407, 0x0befc3c7, 0x0c780b80, 0x080c2130,
+	0x064c2407, 0x0befc3c7, 0x078004c8, 0x080e1401, 0x080c2440,
+	0x064e1507, 0x0aa400c8, 0x0aa54088, 0x060c2207, 0x07800487,
+	0x0aa28007, 0x07801107, 0x064e1508, 0x060c2208, 0x07801c48,
+	0x094411c8, 0x068010c8, 0x09503207, 0x0c780440, 0x060c2108,
+	0x0c7803c0, 0x080c2141, 0x080c2200, 0x080c2200, 0x080c2200,
+	0x080c2200, 0x0c780240, 0x080c2141, 0x064e1507, 0x060c2207,
+	0x064e1507, 0x060c2207, 0x064e1507, 0x060c2207, 0x080c2147,
+	0x078004c7, 0x07c00387, 0x07800487, 0x07c00247, 0x07801107,
+	0x07c01787, 0x06800107, 0x07c003c7, 0x08030580, 0x064c2407,
+	0x0befc3c7, 0x00000000, 0x07800147, 0x0aa10147, 0x0c013c40,
+	0x00000000, 0x0c7800c0, 0x0c016280, 0x00000000, 0x07800007,
+	0x040011c7, 0x0c7f87c0, 0x07c00007, 0x07801fcb, 0x0aa1400b,
+	0x078005c9, 0x0b60c089, 0x0c000e40, 0x00000000, 0x068fdfca,
 	0x06feffca, 0x064e0408, 0x02808288, 0x078005ca, 0x0ba0c08a,
 	0x064c0909, 0x098083c8, 0x0ac0424a, 0x0780000a, 0x0a60c00a,
 	0x0400128a, 0x09808388, 0x0b80324a, 0x00000000, 0x098081c8,
-	0x07808007, 0x09605207, 0x07800007, 0x06808049, 0x02007247,
-	0x070001c7, 0x096a5207, 0x060e0408, 0x091e1248, 0x07c01fc9,
-	0x07801388, 0x060c2b08, 0x06880008, 0x098083c8, 0x07800507,
-	0x07801989, 0x0a610049, 0x09581207, 0x09808408, 0x098083c8,
-	0x060e0508, 0x06800009, 0x07800bc8, 0x09541248, 0x060c2a09,
-	0x07801c07, 0x0aa1c007, 0x080c2c03, 0x0fc011c0, 0x07c01cc7,
-	0x068000c9, 0x094a1247, 0x060c2c09, 0x0c01d500, 0x00000000,
-	0x080c0080, 0x0c015cc0, 0x00000000, 0x080c24a0, 0x080c2200,
-	0x080c2200, 0x07800007, 0x040011c7, 0x07c00007, 0x07800147,
-	0x0c013240, 0x07c00447, 0x0c7fb0c0, 0x00000000, 0x0a60c0e0,
-	0x06800007, 0x0fc011c0, 0x07c01707, 0x080c2802, 0x064c2807,
-	0x0a2fc047, 0x058011c7, 0x068003c8, 0x024071c8, 0x07800188,
-	0x09444207, 0x07c01388, 0x07800148, 0x0a644048, 0x080c2800,
-	0x0fc021c0, 0x0b61c087, 0x07800109, 0x024091c9, 0x0b620089,
-	0x04401249, 0x0c780180, 0x06800049, 0x020091c9, 0x0b20c809,
-	0x04401249, 0x068007c9, 0x07c00109, 0x0c0118c0, 0x040001c9,
-	0x07801388, 0x060c2b08, 0x07801c07, 0x0a60c007, 0x0c7806c0,
-	0x06800009, 0x0aa10008, 0x080c2800, 0x0fc011c0, 0x07c01cc7,
-	0x07800148, 0x0aa14088, 0x06800009, 0x0aa0c148, 0x07800489,
-	0x0fc01240, 0x07c01d09, 0x0aa38009, 0x0aa34148, 0x0aa201c8,
-	0x00000000, 0x0fc011c0, 0x07c01d47, 0x0fc011c0, 0x07c01d87,
-	0x0a618188, 0x00000000, 0x0fc011c0, 0x07c01dc7, 0x0fc011c0,
-	0x07c01e07, 0x07800148, 0x09501209, 0x07801709, 0x09521209,
-	0x060c2108, 0x07801cc8, 0x05405208, 0x060c2c08, 0x06880008,
-	0x07801989, 0x0aa0c049, 0x07800507, 0x098083c8, 0x09581207,
-	0x060e0508, 0x06800009, 0x07800bc8, 0x09541248, 0x060c2a09,
-	0x064c2408, 0x0befc3c8, 0x078003c8, 0x0a6fc008, 0x00000000,
-	0x080c0080, 0x0aa080a0, 0x0c7812c0, 0x080c2110, 0x07800147,
-	0x0aa38147, 0x078004c7, 0x07c00387, 0x07800487, 0x07c00247,
-	0x07801107, 0x07c01787, 0x06800107, 0x07c003c7, 0x08030580,
-	0x064c2407, 0x0befc3c7, 0x0c780b80, 0x080c2130, 0x064c2407,
-	0x0befc3c7, 0x078004c8, 0x080e1401, 0x080c2440, 0x064e1507,
-	0x0aa400c8, 0x0aa54088, 0x060c2207, 0x07800487, 0x0aa28007,
-	0x07801107, 0x064e1508, 0x060c2208, 0x07801c48, 0x094411c8,
-	0x068010c8, 0x09503207, 0x0c780440, 0x060c2108, 0x0c7803c0,
-	0x080c2141, 0x080c2200, 0x080c2200, 0x080c2200, 0x080c2200,
-	0x0c780240, 0x080c2141, 0x064e1507, 0x060c2207, 0x064e1507,
-	0x060c2207, 0x064e1507, 0x060c2207, 0x080c2147, 0x078004c7,
-	0x07c00387, 0x07800487, 0x07c00247, 0x07801107, 0x07c01787,
-	0x06800107, 0x07c003c7, 0x08030580, 0x064c2407, 0x0befc3c7,
-	0x00000000, 0x07800147, 0x0aa10147, 0x0c013a80, 0x00000000,
-	0x0c7800c0, 0x0c0160c0, 0x00000000, 0x07800007, 0x040011c7,
-	0x0c7f8800, 0x07c00007, 0x07801fcb, 0x0aa1400b, 0x078005c9,
-	0x0b60c089, 0x0c000e40, 0x00000000, 0x068fdfca, 0x06feffca,
-	0x064e0408, 0x02808288, 0x078005ca, 0x0ba0c08a, 0x064c0909,
-	0x098083c8, 0x0ac0424a, 0x0780000a, 0x0a60c00a, 0x0400128a,
-	0x09808388, 0x0b80324a, 0x00000000, 0x098081c8, 0x060e0408,
-	0x091e1248, 0x07c01fc9, 0x0c01a200, 0x00000000, 0x064c2407,
-	0x0befc3c7, 0x078003c7, 0x0a6fc007, 0x00000000, 0x080c2130,
-	0x080c2800, 0x064c2408, 0x0befc3c8, 0x0c012f40, 0x00000000,
-	0x07800007, 0x040011c7, 0x07c00007, 0x07801d08, 0x07801d47,
-	0x09421207, 0x07801d87, 0x09441207, 0x07c00308, 0x07800148,
-	0x0aa0c348, 0x07c00448, 0x0c7f7b00, 0x078003c7, 0x0a6fc007,
-	0x00000000, 0x080c24e0, 0x064c2207, 0x064c2208, 0x080c24c0,
-	0x060c2207, 0x0c7f8280, 0x060c2208, 0x0780044b, 0x0aa3834b,
-	0x00000000, 0x069fffc9, 0x04401249, 0x0aa1c009, 0x00000000,
-	0x064e160b, 0x090102cb, 0x0aaec00b, 0x0c780140, 0x00000000,
-	0x0809d501, 0x0c7fffc0, 0x00000000, 0x0681000b, 0x060e090b,
-	0x060e0a0b, 0x0cc00000, 0x060e0b0b, 0x064e0009, 0x064e0e0b,
-	0x064e0c0c, 0x083f0040, 0x083f0000, 0x0680020d, 0x0d00000d,
-	0x00000000, 0x060e0009, 0x060e0e0b, 0x0cc00000, 0x060e0c0c,
-	0x0683ffc9, 0x0aa18009, 0x0649470a, 0x0910828a, 0x07800008,
-	0x0a4fc20a, 0x04401249, 0x0cc00000, 0x00000000, 0x0c07fac0,
-	0x00000000, 0x06490b09, 0x09809009, 0x09809089, 0x06090b09,
-	0x09c09009, 0x09c09089, 0x06090b09, 0x08095007, 0x08095000,
-	0x0683ffc9, 0x06498f0a, 0x0aa0c009, 0x0a6f800a, 0x04401249,
-	0x06498e0a, 0x0980a00a, 0x068007c9, 0x09705289, 0x06098e0a,
-	0x06800009, 0x09705289, 0x09c0a00a, 0x06098e0a, 0x0681f409,
-	0x04601249, 0x0c4fffc0, 0x00000000, 0x0cc00000, 0x00000000,
-	0x0a241007, 0x0c07f5c0, 0x00000000, 0x064c000a, 0x09c0a18a,
-	0x0980a20a, 0x0980a00a, 0x060c000a, 0x064c080a, 0x0980a34a,
-	0x060c080a, 0x0c07f580, 0x00000000, 0x080e1600, 0x0680000a,
-	0x07c003ca, 0x0fc081c0, 0x0b2247c7, 0x0b230bc7, 0x0aa22c87,
-	0x0a60ad87, 0x0c783180, 0x0a60ec47, 0x06800047, 0x07c001c7,
-	0x0c789e00, 0x0c789dc0, 0x0c789d80, 0x00000000, 0x00000000,
-	0x0fc0a1c0, 0x06800048, 0x0a210047, 0x06800047, 0x0fc041c0,
-	0x0fc03200, 0x07c01807, 0x07c01848, 0x0fc041c0, 0x0609c507,
-	0x0a6103c7, 0x07c01887, 0x0fc101c0, 0x0609c507, 0x0fc011c0,
-	0x0aa30007, 0x00000000, 0x0fc021c0, 0x07c018c7, 0x0fc021c0,
-	0x0a21c047, 0x00000000, 0x0fc101c0, 0x0fc101c0, 0x0fc101c0,
-	0x0fc0f1c0, 0x0fc101c0, 0x0fc021c0, 0x0aa0c007, 0x0c7f5dc0,
-	0x00000000, 0x0fc011c0, 0x0fc101c0, 0x07c01907, 0x0649c308,
-	0x09410207, 0x0609c308, 0x0b220087, 0x06800048, 0x06800008,
-	0x06800049, 0x0b004247, 0x05401249, 0x0c7fff80, 0x04001208,
-	0x07c01408, 0x0fc021c0, 0x0a21c047, 0x07801407, 0x0f8001c7,
-	0x07c01447, 0x0649c309, 0x09610247, 0x0609c309, 0x0fc011c0,
-	0x0fc0d1c0, 0x0fc01240, 0x0fc0d200, 0x0fc01240, 0x0401f287,
-	0x0580528a, 0x0403e247, 0x05806249, 0x09610289, 0x04000287,
-	0x0649c709, 0x09610247, 0x0609c709, 0x0400f1c7, 0x058041c7,
-	0x060c0907, 0x07c00987, 0x04401247, 0x07c00609, 0x0961020a,
-	0x06090808, 0x06c00008, 0x0649c707, 0x094101c8, 0x0609c707,
-	0x0400f208, 0x05804208, 0x07c009c8, 0x0fc011c0, 0x07c01c07,
-	0x06800007, 0x07c01d07, 0x060c0307, 0x0fc011c0, 0x0aa14007,
-	0x07801807, 0x0a610047, 0x0c780100, 0x0fc011c0, 0x0c7fefc0,
-	0x0fc021c0, 0x07c01947, 0x0aa10007, 0x0a6f0087, 0x00000000,
-	0x0fc091c0, 0x07c01e47, 0x0fc011c0, 0x0a6dc007, 0x0fc011c0,
-	0x0a608007, 0x0c780c80, 0x07c01987, 0x06800008, 0x0fc011c0,
-	0x0aa58007, 0x00000000, 0x06490907, 0x0befc047, 0x06801007,
-	0x0fc08240, 0x0aa20009, 0x044011c7, 0x0fc08280, 0x0aa1c00a,
-	0x09508289, 0x0d07fe87, 0x060e020a, 0x0c780200, 0x0c7800c0,
-	0x0950828a, 0x09408289, 0x040011c7, 0x058011c7, 0x0d000007,
-	0x060e020a, 0x04c10208, 0x0fc011c0, 0x0aa58007, 0x06801007,
-	0x06490907, 0x0befc047, 0x06801007, 0x0fc08240, 0x0aa20009,
-	0x044011c7, 0x0fc08280, 0x0aa1c00a, 0x09508289, 0x0d07fe87,
-	0x060e030a, 0x0c780200, 0x0c7800c0, 0x0950828a, 0x09408289,
-	0x040011c7, 0x058011c7, 0x0d000007, 0x060e030a, 0x04c08208,
-	0x060e0008, 0x07801807, 0x0aa18047, 0x00000000, 0x0fc011c0,
-	0x0540b1c7, 0x09807007, 0x060c0107, 0x0fc011c0, 0x0aa60007,
-	0x0fc011c0, 0x07c00347, 0x0aa0c047, 0x0c0160c0, 0x00000000,
-	0x0fc011c0, 0x0a20c047, 0x00000000, 0x0fc011c0, 0x07801807,
-	0x06800008, 0x0aa18047, 0x06800007, 0x0fc011c0, 0x0a624007,
-	0x0fc01200, 0x0a61c008, 0x07c01a07, 0x07c01a48, 0x0fc011c0,
-	0x046011c7, 0x0c57e900, 0x0c786e00, 0x0c7fd840, 0x064c5126,
-	0x064c4627, 0x07800708, 0x05410208, 0x078006c9, 0x02008248,
-	0x0580a208, 0x0e000988, 0x00000000, 0x00000000, 0x00000000,
-	0x0f000200, 0x0f010980, 0x09708226, 0x0540a208, 0x020089c8,
-	0x064c4326, 0x02408988, 0x064c4026, 0x02408988, 0x07c00b48,
-	0x05810208, 0x07c00b88, 0x06800007, 0x07c00007, 0x07c01707,
-	0x07c00507, 0x07c016c7, 0x06800047, 0x07c00587, 0x07800607,
-	0x040021c7, 0x07c005c7, 0x0fc02800, 0x06800023, 0x06800024,
-	0x0aa1c0a0, 0x068ae008, 0x068ac008, 0x0a60c0e0, 0x06800009,
-	0x06800049, 0x07c01bc9, 0x07c00288, 0x06800008, 0x0fc011c0,
-	0x0aa0c007, 0x0c7fff80, 0x04001208, 0x07c01a88, 0x0fc011c0,
-	0x07801409, 0x0a66c009, 0x00000000, 0x064c2a0a, 0x064c360b,
-	0x0901028a, 0x0540828a, 0x058082cb, 0x0940828b, 0x06800009,
-	0x0ae483c9, 0x0540128a, 0x0aa18060, 0x04001249, 0x092652ca,
-	0x0481f2cb, 0x0aa1860b, 0x0c7ffe40, 0x092462ca, 0x048372cb,
-	0x0aa08c0b, 0x0c7ffd40, 0x0649ce07, 0x0683e908, 0x0a403207,
-	0x0bac43c9, 0x00000000, 0x07c01409, 0x0f8001c9, 0x07c01ac7,
-	0x0a6240a0, 0x07801088, 0x0b814207, 0x02407207, 0x07801908,
-	0x0c780440, 0x02407207, 0x0c7fc200, 0x00000000, 0x07801a88,
-	0x0ae14048, 0x0aa10008, 0x07801088, 0x07801909, 0x02007247,
-	0x02407207, 0x07801ac8, 0x07c01088, 0x06800008, 0x07c01008,
-	0x0c780540, 0x07c010c7, 0x07801008, 0x04001208, 0x0ae44048,
-	0x07c01008, 0x078010c9, 0x02007247, 0x0b21c007, 0x0b406247,
-	0x0b406247, 0x00000000, 0x024091c9, 0x0c7fff40, 0x04080208,
-	0x0c7f18c0, 0x058011c7, 0x0b403247, 0x00000000, 0x04080208,
-	0x07c01008, 0x090071c8, 0x090e7208, 0x09545207, 0x060e0708,
-	0x07800047, 0x0b624087, 0x0aa180a0, 0x0aa08020, 0x0aa10007,
-	0x040011c7, 0x0c780100, 0x07c00047, 0x0c784c00, 0x00000000,
-	0x0fc011c0, 0x0fc011c0, 0x0a620007, 0x078013c8, 0x0aa0c088,
-	0x07800fc8, 0x04001208, 0x07c00fc8, 0x0c784980, 0x00000000,
-	0x07c013e0, 0x0aa0c0e0, 0x0a60c060, 0x06800007, 0x0fc011c0,
-	0x07c01b07, 0x0fc031c0, 0x07c000c7, 0x07801c07, 0x0aa20007,
-	0x00000000, 0x0fc011c0, 0x07c01c47, 0x0fc011c0, 0x07c01c87,
-	0x054021c7, 0x060c0307, 0x0a6740e0, 0x07801e47, 0x0aa6c007,
-	0x09066207, 0x0aa08088, 0x0c7fae00, 0x0c00a780, 0x06801ec8,
-	0x07901ee3, 0x06801409, 0x09510263, 0x060c2109, 0x0c00a600,
-	0x06801f08, 0x07901f08, 0x06801809, 0x09510248, 0x060c2109,
-	0x096108c8, 0x0c00a440, 0x06801f48, 0x0c00a3c0, 0x06801f88,
-	0x05401923, 0x09c24424, 0x0942f923, 0x0a20c047, 0x0c7fa880,
-	0x00000000, 0x0fc051c0, 0x0c006f00, 0x07c00107, 0x0c006c40,
-	0x00000000, 0x0a6180a0, 0x078003c7, 0x0a6fc007, 0x06800107,
-	0x07c003c7, 0x08030580, 0x0aa28020, 0x06800048, 0x0a6100a0,
-	0x0fc03200, 0x0fc03240, 0x07c01b89, 0x07c01b48, 0x09503248,
-	0x09809149, 0x060c2109, 0x060c0e08, 0x06800025, 0x06490908,
-	0x0ae10225, 0x00000000, 0x0bef4048, 0x0c780080, 0x0c7efe80,
-	0x0683ffc7, 0x0649bb08, 0x0900c208, 0x0aa10008, 0x0aa0c007,
-	0x0c7fff00, 0x044011c7, 0x06490b07, 0x09807007, 0x06090b07,
-	0x06090b07, 0x09c07007, 0x06090b07, 0x0649c909, 0x0aa10009,
-	0x06800087, 0x0c7ef440, 0x07c01507, 0x07801487, 0x0a608007,
-	0x0c780b00, 0x044011c7, 0x0aa0c087, 0x07801549, 0x078015c9,
-	0x0b20c1c9, 0x00000000, 0x0c780940, 0x07800fc8, 0x0609ca08,
+	0x060e0408, 0x091e1248, 0x07c01fc9, 0x0c01a3c0, 0x00000000,
+	0x064c2407, 0x0befc3c7, 0x078003c7, 0x0a6fc007, 0x00000000,
+	0x080c2130, 0x080c2800, 0x064c2408, 0x0befc3c8, 0x0c013100,
+	0x00000000, 0x07800007, 0x040011c7, 0x07c00007, 0x07801d08,
+	0x07801d47, 0x09421207, 0x07801d87, 0x09441207, 0x07c00308,
+	0x07800148, 0x0aa0c348, 0x07c00448, 0x0c7f7ac0, 0x078003c7,
+	0x0a6fc007, 0x00000000, 0x080c24e0, 0x064c2207, 0x064c2208,
+	0x080c24c0, 0x060c2207, 0x0c7f8240, 0x060c2208, 0x0780044b,
+	0x0aa3834b, 0x00000000, 0x069fffc9, 0x04401249, 0x0aa1c009,
+	0x00000000, 0x064e160b, 0x090102cb, 0x0aaec00b, 0x0c780140,
+	0x00000000, 0x0809d501, 0x0c7fffc0, 0x00000000, 0x0681000b,
+	0x060e090b, 0x060e0a0b, 0x0cc00000, 0x060e0b0b, 0x064e0009,
+	0x064e0e0b, 0x064e0c0c, 0x083f0040, 0x083f0000, 0x0680020d,
+	0x0d00000d, 0x00000000, 0x060e0009, 0x060e0e0b, 0x0cc00000,
+	0x060e0c0c, 0x0683ffc9, 0x0aa18009, 0x0649470a, 0x0910828a,
+	0x07800008, 0x0a4fc20a, 0x04401249, 0x0cc00000, 0x00000000,
+	0x0c07fac0, 0x00000000, 0x06490b09, 0x09809009, 0x09809089,
+	0x06090b09, 0x09c09009, 0x09c09089, 0x06090b09, 0x08095007,
+	0x08095000, 0x0683ffc9, 0x06498f0a, 0x0aa0c009, 0x0a6f800a,
+	0x04401249, 0x06498e0a, 0x0980a00a, 0x068007c9, 0x09705289,
+	0x06098e0a, 0x06800009, 0x09705289, 0x09c0a00a, 0x06098e0a,
+	0x0681f409, 0x04601249, 0x0c4fffc0, 0x00000000, 0x0cc00000,
+	0x00000000, 0x0a241007, 0x0c07f5c0, 0x00000000, 0x064c000a,
+	0x09c0a18a, 0x0980a20a, 0x0980a00a, 0x060c000a, 0x064c080a,
+	0x0980a34a, 0x060c080a, 0x0c07f580, 0x00000000, 0x080e1600,
+	0x0680000a, 0x07c003ca, 0x0fc081c0, 0x0b2247c7, 0x0b230bc7,
+	0x0aa22c87, 0x0a60ad87, 0x0c783180, 0x0a60ec47, 0x06800047,
+	0x07c001c7, 0x0c789fc0, 0x0c789f80, 0x0c789f40, 0x00000000,
+	0x00000000, 0x0fc0a1c0, 0x06800048, 0x0a210047, 0x06800047,
+	0x0fc041c0, 0x0fc03200, 0x07c01807, 0x07c01848, 0x0fc041c0,
+	0x0609c507, 0x0a6103c7, 0x07c01887, 0x0fc101c0, 0x0609c507,
+	0x0fc011c0, 0x0aa30007, 0x00000000, 0x0fc021c0, 0x07c018c7,
+	0x0fc021c0, 0x0a21c047, 0x00000000, 0x0fc101c0, 0x0fc101c0,
+	0x0fc101c0, 0x0fc0f1c0, 0x0fc101c0, 0x0fc021c0, 0x0aa0c007,
+	0x0c7f5d80, 0x00000000, 0x0fc011c0, 0x0fc101c0, 0x07c01907,
+	0x0649c308, 0x09410207, 0x0609c308, 0x0b220087, 0x06800048,
+	0x06800008, 0x06800049, 0x0b004247, 0x05401249, 0x0c7fff80,
+	0x04001208, 0x07c01408, 0x0fc021c0, 0x0a21c047, 0x07801407,
+	0x0f8001c7, 0x07c01447, 0x0649c309, 0x09610247, 0x0609c309,
+	0x0fc011c0, 0x0fc0d1c0, 0x0fc01240, 0x0fc0d200, 0x0fc01240,
+	0x0401f287, 0x0580528a, 0x0403e247, 0x05806249, 0x09610289,
+	0x04000287, 0x0649c709, 0x09610247, 0x0609c709, 0x0400f1c7,
+	0x058041c7, 0x060c0907, 0x07c00987, 0x04401247, 0x07c00609,
+	0x0961020a, 0x06090808, 0x06c00008, 0x0649c707, 0x094101c8,
+	0x0609c707, 0x0400f208, 0x05804208, 0x07c009c8, 0x0fc011c0,
+	0x07c01c07, 0x06800007, 0x07c01d07, 0x060c0307, 0x0fc011c0,
+	0x0aa14007, 0x07801807, 0x0a610047, 0x0c780100, 0x0fc011c0,
+	0x0c7fefc0, 0x0fc021c0, 0x07c01947, 0x0aa10007, 0x0a6f0087,
+	0x00000000, 0x0fc091c0, 0x07c01e47, 0x0fc011c0, 0x0a6dc007,
+	0x0fc011c0, 0x0a608007, 0x0c780c80, 0x07c01987, 0x06800008,
+	0x0fc011c0, 0x0aa58007, 0x00000000, 0x06490907, 0x0befc047,
+	0x06801007, 0x0fc08240, 0x0aa20009, 0x044011c7, 0x0fc08280,
+	0x0aa1c00a, 0x09508289, 0x0d07fe87, 0x060e020a, 0x0c780200,
+	0x0c7800c0, 0x0950828a, 0x09408289, 0x040011c7, 0x058011c7,
+	0x0d000007, 0x060e020a, 0x04c10208, 0x0fc011c0, 0x0aa58007,
+	0x06801007, 0x06490907, 0x0befc047, 0x06801007, 0x0fc08240,
+	0x0aa20009, 0x044011c7, 0x0fc08280, 0x0aa1c00a, 0x09508289,
+	0x0d07fe87, 0x060e030a, 0x0c780200, 0x0c7800c0, 0x0950828a,
+	0x09408289, 0x040011c7, 0x058011c7, 0x0d000007, 0x060e030a,
+	0x04c08208, 0x060e0008, 0x07801807, 0x0aa18047, 0x00000000,
+	0x0fc011c0, 0x0540b1c7, 0x09807007, 0x060c0107, 0x0fc011c0,
+	0x0aa60007, 0x0fc011c0, 0x07c00347, 0x0aa0c047, 0x0c016280,
+	0x00000000, 0x0fc011c0, 0x0a20c047, 0x00000000, 0x0fc011c0,
+	0x07801807, 0x06800008, 0x0aa18047, 0x06800007, 0x0fc011c0,
+	0x0a624007, 0x0fc01200, 0x0a61c008, 0x07c01a07, 0x07c01a48,
+	0x0fc011c0, 0x046011c7, 0x0c57e900, 0x0c786fc0, 0x0c7fd840,
+	0x064c5126, 0x064c4627, 0x07800708, 0x05410208, 0x078006c9,
+	0x02008248, 0x0580a208, 0x0e000988, 0x00000000, 0x00000000,
+	0x00000000, 0x0f000200, 0x0f010980, 0x09708226, 0x0540a208,
+	0x020089c8, 0x064c4326, 0x02408988, 0x064c4026, 0x02408988,
+	0x07c00b48, 0x05810208, 0x07c00b88, 0x06800007, 0x07c00007,
+	0x07c01707, 0x07c00507, 0x07c016c7, 0x06800047, 0x07c00587,
+	0x07800607, 0x040021c7, 0x07c005c7, 0x0fc02800, 0x06800023,
+	0x06800024, 0x0aa1c0a0, 0x068ae008, 0x068ac008, 0x0a60c0e0,
+	0x06800009, 0x06800049, 0x07c01bc9, 0x07c00288, 0x06800008,
+	0x0fc011c0, 0x0aa0c007, 0x0c7fff80, 0x04001208, 0x07c01a88,
+	0x0fc011c0, 0x07801409, 0x0a66c009, 0x00000000, 0x064c2a0a,
+	0x064c360b, 0x0901028a, 0x0540828a, 0x058082cb, 0x0940828b,
+	0x06800009, 0x0ae483c9, 0x0540128a, 0x0aa18060, 0x04001249,
+	0x092652ca, 0x0481f2cb, 0x0aa1860b, 0x0c7ffe40, 0x092462ca,
+	0x048372cb, 0x0aa08c0b, 0x0c7ffd40, 0x0649ce07, 0x0683e908,
+	0x0a403207, 0x0bac43c9, 0x00000000, 0x07c01409, 0x0f8001c9,
+	0x07c01ac7, 0x0a6240a0, 0x07801088, 0x0b814207, 0x02407207,
+	0x07801908, 0x0c780440, 0x02407207, 0x0c7fc200, 0x00000000,
+	0x07801a88, 0x0ae14048, 0x0aa10008, 0x07801088, 0x07801909,
+	0x02007247, 0x02407207, 0x07801ac8, 0x07c01088, 0x06800008,
+	0x07c01008, 0x0c780540, 0x07c010c7, 0x07801008, 0x04001208,
+	0x0ae44048, 0x07c01008, 0x078010c9, 0x02007247, 0x0b21c007,
+	0x0b406247, 0x0b406247, 0x00000000, 0x024091c9, 0x0c7fff40,
+	0x04080208, 0x0c7f1880, 0x058011c7, 0x0b403247, 0x00000000,
+	0x04080208, 0x07c01008, 0x090071c8, 0x090e7208, 0x09545207,
+	0x060e0708, 0x07800047, 0x0b624087, 0x0aa180a0, 0x0aa08020,
+	0x0aa10007, 0x040011c7, 0x0c780100, 0x07c00047, 0x0c784dc0,
+	0x00000000, 0x0fc011c0, 0x0fc011c0, 0x0a620007, 0x078013c8,
+	0x0aa0c088, 0x07800fc8, 0x04001208, 0x07c00fc8, 0x0c784b40,
+	0x00000000, 0x07c013e0, 0x0aa0c0e0, 0x0a60c060, 0x06800007,
+	0x0fc011c0, 0x07c01b07, 0x0fc031c0, 0x07c000c7, 0x07801c07,
+	0x0aa20007, 0x00000000, 0x0fc011c0, 0x07c01c47, 0x0fc011c0,
+	0x07c01c87, 0x054021c7, 0x060c0307, 0x0a6740e0, 0x07801e47,
+	0x0aa6c007, 0x09066207, 0x0aa08088, 0x0c7fae00, 0x0c00a940,
+	0x06801ec8, 0x07901ee3, 0x06801409, 0x09510263, 0x060c2109,
+	0x0c00a7c0, 0x06801f08, 0x07901f08, 0x06801809, 0x09510248,
+	0x060c2109, 0x096108c8, 0x0c00a600, 0x06801f48, 0x0c00a580,
+	0x06801f88, 0x05401923, 0x09c24424, 0x0942f923, 0x0a20c047,
+	0x0c7fa880, 0x00000000, 0x0fc051c0, 0x0c0070c0, 0x07c00107,
+	0x0c006e00, 0x00000000, 0x0a6180a0, 0x078003c7, 0x0a6fc007,
+	0x06800107, 0x07c003c7, 0x08030580, 0x0aa28020, 0x06800048,
+	0x0a6100a0, 0x0fc03200, 0x0fc03240, 0x07c01b89, 0x07c01b48,
+	0x09503248, 0x09809149, 0x060c2109, 0x060c0e08, 0x06800025,
+	0x06490908, 0x0ae10225, 0x00000000, 0x0bef4048, 0x0c780080,
+	0x0c7efe40, 0x0683ffc7, 0x0649bb08, 0x0900c208, 0x0aa10008,
+	0x0aa0c007, 0x0c7fff00, 0x044011c7, 0x06490b07, 0x09807007,
+	0x06090b07, 0x06090b07, 0x09c07007, 0x06090b07, 0x0649c909,
+	0x0aa10009, 0x06800087, 0x0c7ef400, 0x07c01507, 0x07800047,
+	0x0ae0c047, 0x078001c7, 0x0aa20047, 0x07801487, 0x0a608007,
+	0x0c780bc0, 0x044011c7, 0x0aa0c087, 0x07801549, 0x078015c9,
+	0x0b20c1c9, 0x00000000, 0x0c780a00, 0x07800fc8, 0x0609ca08,
 	0x07c00fdf, 0x0680420a, 0x02007289, 0x070001c7, 0x054101c7,
 	0x0680400a, 0x02008289, 0x07000208, 0x094101c8, 0x0609cc07,
 	0x0680444a, 0x02007289, 0x070001c7, 0x0609cb07, 0x06804a4a,
 	0x02008289, 0x07000208, 0x09464248, 0x07801c08, 0x094e1248,
 	0x09809209, 0x0609c909, 0x08007401, 0x06800009, 0x07c01489,
-	0x078001c9, 0x0aa20009, 0x0ae00049, 0x06800089, 0x07c001c9,
-	0x0649c909, 0x0a6fc009, 0x0c7ff780, 0x07801589, 0x06800009,
-	0x07c01509, 0x078014c7, 0x02c07247, 0x0780464a, 0x07804688,
-	0x09610288, 0x0be0c047, 0x0c780a80, 0x06800008, 0x078046ca,
-	0x07804708, 0x09610288, 0x0be0c087, 0x0c780900, 0x06800048,
-	0x0780474a, 0x07804788, 0x09610288, 0x0a27c107, 0x06800088,
-	0x078047ca, 0x07804808, 0x09610288, 0x0a268207, 0x068000c8,
-	0x0780484a, 0x07804888, 0x09610288, 0x0a254407, 0x06800108,
-	0x078048ca, 0x07804908, 0x09610288, 0x0a240807, 0x06800148,
-	0x0780494a, 0x07804988, 0x09610288, 0x0a22d007, 0x06800188,
-	0x078049ca, 0x07804a08, 0x09610288, 0x0a21a007, 0x068001c8,
-	0x0809cd11, 0x06800047, 0x0c7edc40, 0x07c01507, 0x0809cd00,
-	0x07801607, 0x090041c7, 0x0a8051c8, 0x0a6200a0, 0x07801607,
-	0x090841c7, 0x0a4051c8, 0x06800047, 0x03407207, 0x0c7ff180,
-	0x02c091c9, 0x07800b47, 0x0680400f, 0x020093c8, 0x07400247,
-	0x07800b87, 0x04008249, 0x07400247, 0x0680444f, 0x020073c8,
-	0x07801ac9, 0x074001c9, 0x07801c47, 0x054031c7, 0x02c07807,
-	0x06804a4f, 0x020093c8, 0x07400247, 0x06800047, 0x03407207,
-	0x078014c9, 0x02c091c9, 0x07c014c9, 0x0609b20a, 0x04001260,
-	0x07c01489, 0x0a6080a0, 0x0c780340, 0x07801587, 0x07c015c7,
-	0x07c01588, 0x06499109, 0x06099009, 0x07801609, 0x05404249,
-	0x09404248, 0x07c01609, 0x0609910a, 0x0c7800c0, 0x00000000,
-	0x07c01548, 0x08098002, 0x07801c07, 0x0aa64047, 0x00000000,
-	0x07801d07, 0x0aa58047, 0x00000000, 0x06499008, 0x05410208,
-	0x058103c8, 0x02c083c8, 0x06098108, 0x06499108, 0x05410208,
-	0x058103c8, 0x02c083c8, 0x06098208, 0x080980f0, 0x07801c07,
-	0x0aa6c007, 0x00000000, 0x07801d07, 0x0aa60007, 0x00000000,
-	0x080980f4, 0x0c780540, 0x00000000, 0x06499008, 0x05410208,
-	0x0649b10f, 0x054103cf, 0x07801c47, 0x0a614047, 0x00000000,
-	0x05810208, 0x0c7800c0, 0x00000000, 0x058103cf, 0x02c083c8,
+	0x078001c9, 0x0aa2c009, 0x07800047, 0x0ae08047, 0x0c7fff80,
+	0x0aef4049, 0x06800089, 0x07c001c9, 0x0649c909, 0x0a6fc009,
+	0x0c7ff6c0, 0x07801589, 0x06800009, 0x07c01509, 0x078014c7,
+	0x02c07247, 0x0780464a, 0x07804688, 0x09610288, 0x0be0c047,
+	0x0c780a80, 0x06800008, 0x078046ca, 0x07804708, 0x09610288,
+	0x0be0c087, 0x0c780900, 0x06800048, 0x0780474a, 0x07804788,
+	0x09610288, 0x0a27c107, 0x06800088, 0x078047ca, 0x07804808,
+	0x09610288, 0x0a268207, 0x068000c8, 0x0780484a, 0x07804888,
+	0x09610288, 0x0a254407, 0x06800108, 0x078048ca, 0x07804908,
+	0x09610288, 0x0a240807, 0x06800148, 0x0780494a, 0x07804988,
+	0x09610288, 0x0a22d007, 0x06800188, 0x078049ca, 0x07804a08,
+	0x09610288, 0x0a21a007, 0x068001c8, 0x0809cd11, 0x06800047,
+	0x0c7eda40, 0x07c01507, 0x0809cd00, 0x07801607, 0x090041c7,
+	0x0a8051c8, 0x0a6200a0, 0x07801607, 0x090841c7, 0x0a4051c8,
+	0x06800047, 0x03407207, 0x0c7ff180, 0x02c091c9, 0x07800b47,
+	0x0680400f, 0x020093c8, 0x07400247, 0x07800b87, 0x04008249,
+	0x07400247, 0x0680444f, 0x020073c8, 0x07801ac9, 0x074001c9,
+	0x07801c47, 0x054031c7, 0x02c07807, 0x06804a4f, 0x020093c8,
+	0x07400247, 0x06800047, 0x03407207, 0x078014c9, 0x02c091c9,
+	0x07c014c9, 0x0609b20a, 0x04001260, 0x07c01489, 0x0a6080a0,
+	0x0c780340, 0x07801587, 0x07c015c7, 0x07c01588, 0x06499109,
+	0x06099009, 0x07801609, 0x05404249, 0x09404248, 0x07c01609,
+	0x0609910a, 0x0c7800c0, 0x00000000, 0x07c01548, 0x08098002,
+	0x07801c07, 0x0aa64047, 0x00000000, 0x07801d07, 0x0aa58047,
+	0x00000000, 0x06499008, 0x05410208, 0x058103c8, 0x02c083c8,
 	0x06098108, 0x06499108, 0x05410208, 0x058103c8, 0x02c083c8,
-	0x06098208, 0x080980f4, 0x07801b07, 0x06800048, 0x09421207,
-	0x0c7ed640, 0x06090708, 0x06800025, 0x0ae20225, 0x064c0007,
-	0x0a2f8047, 0x00000000, 0x064c3a07, 0x090061c7, 0x0aae8647,
-	0x0c7800c0, 0x0c7ec5c0, 0x00000000, 0x080c2800, 0x080c0002,
-	0x0c7ebec0, 0x00000000, 0x0649c007, 0x07c04647, 0x058101c7,
-	0x07c04687, 0x0649c107, 0x07c046c7, 0x058101c7, 0x07c04707,
-	0x0649c207, 0x07c04747, 0x058101c7, 0x07c04787, 0x0649c307,
-	0x07c047c7, 0x058101c7, 0x07c04807, 0x0649d007, 0x07c04847,
-	0x058101c7, 0x07c04887, 0x0649d107, 0x07c048c7, 0x058101c7,
-	0x07c04907, 0x0649d207, 0x07c04947, 0x058101c7, 0x07c04987,
-	0x0649d307, 0x07c049c7, 0x058101c7, 0x07c04a07, 0x0c004280,
-	0x06800025, 0x08002501, 0x08002605, 0x08002708, 0x08002815,
-	0x08002c14, 0x08002a09, 0x08002b17, 0x06830002, 0x06032602,
-	0x08032261, 0x08032101, 0x0cc00000, 0x00000000, 0x080c2804,
-	0x064c2807, 0x0a2fc047, 0x05801207, 0x080c2800, 0x0aa14008,
-	0x0b21004a, 0x044011ca, 0x0f8001c7, 0x094e9207, 0x0cc00000,
-	0x07400248, 0x080c2804, 0x064c2807, 0x0a2fc047, 0x05801207,
-	0x0cc00000, 0x07400248, 0x0fc011c0, 0x0a608007, 0x0c780ec0,
-	0x06800247, 0x07c00147, 0x07800488, 0x095011c8, 0x060c2107,
-	0x080e1401, 0x080c2440, 0x064e1507, 0x078004c8, 0x0aa400c8,
-	0x0aa54088, 0x060c2207, 0x07800487, 0x0aa28007, 0x07801107,
-	0x064e1508, 0x060c2208, 0x07801c48, 0x094411c8, 0x068010c8,
-	0x09503207, 0x0c780440, 0x060c2108, 0x0c7803c0, 0x080c2141,
-	0x080c2200, 0x080c2200, 0x080c2200, 0x080c2200, 0x0c780240,
-	0x080c2141, 0x064e1507, 0x060c2207, 0x064e1507, 0x060c2207,
-	0x064e1507, 0x060c2207, 0x080c2147, 0x064c2407, 0x0befc3c7,
-	0x078004c7, 0x07c00387, 0x07800487, 0x07c00247, 0x07801107,
-	0x07c01787, 0x06800107, 0x07c003c7, 0x0c007900, 0x00000000,
-	0x08030580, 0x07800007, 0x040011c7, 0x07c00007, 0x06431e07,
-	0x0befc047, 0x0c7ea900, 0x00000000, 0x0fc01200, 0x0fc011c0,
-	0x0aa28047, 0x06800147, 0x0fc011c0, 0x0aa1c047, 0x06800187,
-	0x0fc011c0, 0x0aa10047, 0x068001c7, 0x0fc011c0, 0x06800207,
-	0x07c00147, 0x0a60c008, 0x06800007, 0x0fc061c0, 0x07c01387,
-	0x07800147, 0x0aa4c147, 0x07801387, 0x0aa44007, 0x00000000,
-	0x0fc011c0, 0x0aa38007, 0x07800108, 0x0fc011c0, 0x0aa14007,
-	0x0b21c748, 0x04002208, 0x0c780140, 0x068007c8, 0x0b60c0c8,
-	0x04402208, 0x06800048, 0x07c00108, 0x0c0005c0, 0x040001c8,
-	0x0c7eed00, 0x00000000, 0x06a00007, 0x06e00007, 0x080c24a0,
-	0x060c2207, 0x060c2207, 0x060c2207, 0x060c2207, 0x060c2207,
-	0x0cc00000, 0x060c2207, 0x07801988, 0x094c11c8, 0x0c07fd00,
-	0x060e0407, 0x06800007, 0x07c01cc7, 0x07c00907, 0x0cc00000,
-	0x07c00947, 0x060c0a07, 0x078000c8, 0x0aa24008, 0x06800009,
-	0x0aa1c1c8, 0x06800049, 0x05401247, 0x0400b249, 0x0b403247,
-	0x06800049, 0x06800009, 0x07c00bc9, 0x0b218107, 0x0ae08207,
-	0x0c780380, 0x0b214607, 0x0c780180, 0x00000000, 0x0c780480,
-	0x06820207, 0x0c780240, 0x00000000, 0x05401207, 0x04410208,
-	0x044061c7, 0x054081c7, 0x0c780280, 0x094081c8, 0x0c7800c0,
-	0x0c7800c0, 0x04008207, 0x05401207, 0x0400d1c7, 0x054071c7,
-	0x0c780080, 0x094081c8, 0x07c002c7, 0x06b00008, 0x064c2d09,
-	0x09610248, 0x060c2d09, 0x09610208, 0x060c2f08, 0x07801988,
-	0x094c11c8, 0x0cc00000, 0x060e0407, 0x0680000e, 0x0aa4c00f,
-	0x0ae1400f, 0x0400038f, 0x06bfffce, 0x0300e38f, 0x0400138e,
-	0x0900434e, 0x0b21408d, 0x06800007, 0x0b20c34d, 0x06800047,
-	0x06800087, 0x05c0438e, 0x0540138e, 0x0200e1ce, 0x0ae1000f,
-	0x06bfffcd, 0x0300e34e, 0x0400138e, 0x0cc00000, 0x040003ce,
-	0x07800007, 0x0ae10007, 0x07800109, 0x07800988, 0x02007207,
-	0x044011c7, 0x06808048, 0x02007207, 0x074001c9, 0x0cc00000,
-	0x07c08009, 0x0681f409, 0x04401249, 0x0aefc009, 0x00000000,
-	0x083f0040, 0x083f0000, 0x08090b65, 0x00000000, 0x08090b60,
-	0x06498e07, 0x09807007, 0x068007c9, 0x097051c9, 0x06098e07,
-	0x0681f409, 0x04601249, 0x0c4fffc0, 0x00000000, 0x06800009,
-	0x097051c9, 0x09c07007, 0x06098e07, 0x064c0007, 0x09c07187,
-	0x09807207, 0x060c0007, 0x064c0807, 0x09807347, 0x060c0807,
-	0x083f0040, 0x083f0000, 0x08090b65, 0x0cc00000, 0x08090b60,
-	0x0680001f, 0x07c0149f, 0x07c014df, 0x07c0151f, 0x064c091f,
-	0x07c0175f, 0x07c0005f, 0x06800020, 0x06803fc2, 0x07c01542,
-	0x07c01582, 0x07c015c2, 0x07c01602, 0x060c091f, 0x080c0101,
-	0x080c2901, 0x06840442, 0x060c2e02, 0x064c4027, 0x064c4226,
-	0x024269e6, 0x040089a6, 0x07c006e6, 0x058109a6, 0x07c00726,
-	0x0649cf31, 0x0809c500, 0x0649c707, 0x0aa6c007, 0x09010207,
-	0x092101c7, 0x0401f287, 0x0580528a, 0x0403e247, 0x05806249,
-	0x09610289, 0x04000287, 0x0649c709, 0x09610247, 0x0609c709,
-	0x0400f1c7, 0x058041c7, 0x060c0907, 0x07c00987, 0x04401247,
-	0x07c00609, 0x0961020a, 0x06090808, 0x06c00008, 0x0649c707,
-	0x094101c8, 0x0609c707, 0x0400f208, 0x05804208, 0x07c009c8,
-	0x0809c300, 0x0809cb00, 0x0cc00000, 0x00000000, 0x0649c803,
-	0x0aa14003, 0x078014c2, 0x028020c2, 0x07c014c2, 0x0809c800,
-	0x07801502, 0x0aa0c002, 0x06800102, 0x06030502, 0x064c0002,
-	0x0be14042, 0x0ba1d025, 0x06800102, 0x07c01502, 0x08030504,
-	0x06800025, 0x0cc00000, 0x00000000, 0x078001c2, 0x0aa1c002,
-	0x078016c2, 0x078009c3, 0x0a4040c2, 0x00000000, 0x06800102,
-	0x06030502, 0x0cc00000, 0x00000000, 0x0fc02240, 0x0aa4c009,
-	0x0680000a, 0x0b6180c9, 0x0680010a, 0x0fc01280, 0x09422289,
-	0x0c780140, 0x0440128a, 0x0fc01240, 0x0a6fc009, 0x0400128a,
-	0x06800049, 0x03409289, 0x05801249, 0x0f80028a, 0x0b40424a,
-	0x05401249, 0x04401249, 0x0240a24a, 0x0740020a, 0x0cc00000,
-	0x0fc01240, 0x064c441a, 0x0912169a, 0x0aaf801a, 0x0c7e56c0,
-	0x00000000, 0x06490628, 0x0aefcc28, 0x00000000, 0x07800028,
-	0x078016e9, 0x09508a68, 0x068000a8, 0x06c00028, 0x06090628,
-	0x06090629, 0x06881068, 0x06090628, 0x0cc00000, 0x00000000,
-	0x06490628, 0x0aefcc28, 0x06c00028, 0x069001a8, 0x069fffea,
-	0x06090628, 0x06090629, 0x05401a23, 0x06090628, 0x09210a23,
-	0x05401a28, 0x02828aa8, 0x06090628, 0x06985168, 0x0c782700,
-	0x06090628, 0x078003e8, 0x0a6fc028, 0x07800028, 0x078016e9,
-	0x06800030, 0x09508a68, 0x0780016b, 0x07801d2a, 0x04601aaa,
-	0x0c500ec0, 0x0aa4802b, 0x0690002a, 0x0aa4006b, 0x0aa8c36b,
-	0x0aa883eb, 0x0aa3422b, 0x00000000, 0x06a0002a, 0x0aa281eb,
-	0x06c0002a, 0x06b0002a, 0x0aa1c1ab, 0x06c0002a, 0x04602aeb,
-	0x0c500980, 0x0690002a, 0x0c7e4f00, 0x00000000, 0x06490628,
-	0x0aefcc28, 0x068000a8, 0x02c28aa8, 0x09441a30, 0x06090628,
-	0x06090629, 0x069fffeb, 0x06900028, 0x0a00ca2a, 0x080c2400,
-	0x080e1424, 0x064c2228, 0x060e1528, 0x060e1528, 0x060e1528,
-	0x060e1528, 0x09210a68, 0x06090628, 0x02828ae9, 0x06090628,
-	0x06a00028, 0x0a007a2a, 0x080c2440, 0x064c2228, 0x09210a68,
-	0x06090628, 0x02828ae9, 0x06090628, 0x0688d068, 0x02c28aa8,
-	0x09441a30, 0x0c781780, 0x06090628, 0x09441ab0, 0x06031f2a,
-	0x0680016b, 0x09510ae9, 0x0c781600, 0x06031e2b, 0x0aa241eb,
-	0x06a0002a, 0x0aa1c1ab, 0x06b0002a, 0x0aa1416b, 0x0aa1026b,
-	0x06800070, 0x0690002a, 0x06800030, 0x06490628, 0x0aefcc28,
-	0x06c0002a, 0x068408a8, 0x02c28aa8, 0x09441a30, 0x06090628,
-	0x06090629, 0x069fffec, 0x06900028, 0x0a00ba2a, 0x080c2400,
-	0x064c222e, 0x0609062e, 0x09210a2e, 0x09c28068, 0x02828b28,
-	0x09828428, 0x07801d6d, 0x095e1a2d, 0x06090628, 0x06a00028,
-	0x0a00ba2a, 0x080c2440, 0x064c2228, 0x06090628, 0x09210a28,
-	0x09c28068, 0x02828b28, 0x09828428, 0x07801ded, 0x095e1a2d,
-	0x06090628, 0x068c5828, 0x02c28aa8, 0x09441a30, 0x06090628,
-	0x06860828, 0x02c28aa8, 0x09441a30, 0x06090628, 0x06900028,
-	0x0a00ba2a, 0x080c2410, 0x064c222f, 0x0609062f, 0x09210a2f,
-	0x09c28068, 0x02828b28, 0x09828428, 0x07801dad, 0x095e1a2d,
-	0x06090628, 0x06a00028, 0x0a00ba2a, 0x080c2450, 0x064c2228,
-	0x06090628, 0x09210a28, 0x09c28068, 0x02828b28, 0x09828428,
-	0x07801e2d, 0x095e1a2d, 0x06090628, 0x068ed868, 0x02c28aa8,
-	0x09441a30, 0x06090628, 0x080c24a0, 0x080e1424, 0x064c2228,
-	0x060e152e, 0x060e152f, 0x060e1528, 0x0c780080, 0x060e1528,
-	0x0cc00000, 0x00000000, 0x07800028, 0x078016e9, 0x06800030,
-	0x09508a68, 0x0780016b, 0x0780026a, 0x04601aaa, 0x0c500c00,
-	0x0aa1416b, 0x00000000, 0x06800070, 0x0a61826b, 0x00000000,
-	0x078003a8, 0x04602a28, 0x0c500840, 0x0c7800c0, 0x0c780000,
-	0x00000000, 0x06490628, 0x0aefcc28, 0x06b000a8, 0x09441a30,
-	0x06090628, 0x06090629, 0x069fffeb, 0x06900028, 0x080c2400,
-	0x080e1424, 0x064c2228, 0x060e1528, 0x060e1528, 0x060e1528,
-	0x060e1528, 0x09210a68, 0x06090628, 0x02828ae9, 0x06090628,
+	0x06098208, 0x080980f0, 0x07801c07, 0x0aa6c007, 0x00000000,
+	0x07801d07, 0x0aa60007, 0x00000000, 0x080980f4, 0x0c780540,
+	0x00000000, 0x06499008, 0x05410208, 0x0649b10f, 0x054103cf,
+	0x07801c47, 0x0a614047, 0x00000000, 0x05810208, 0x0c7800c0,
+	0x00000000, 0x058103cf, 0x02c083c8, 0x06098108, 0x06499108,
+	0x05410208, 0x058103c8, 0x02c083c8, 0x06098208, 0x080980f4,
+	0x07801b07, 0x06800048, 0x09421207, 0x0c7ed440, 0x06090708,
+	0x06800025, 0x0ae20225, 0x064c0007, 0x0a2f8047, 0x00000000,
+	0x064c3a07, 0x090061c7, 0x0aae8647, 0x0c7800c0, 0x0c7ec3c0,
+	0x00000000, 0x080c2800, 0x080c0002, 0x0c7ebcc0, 0x00000000,
+	0x0649c007, 0x07c04647, 0x058101c7, 0x07c04687, 0x0649c107,
+	0x07c046c7, 0x058101c7, 0x07c04707, 0x0649c207, 0x07c04747,
+	0x058101c7, 0x07c04787, 0x0649c307, 0x07c047c7, 0x058101c7,
+	0x07c04807, 0x0649d007, 0x07c04847, 0x058101c7, 0x07c04887,
+	0x0649d107, 0x07c048c7, 0x058101c7, 0x07c04907, 0x0649d207,
+	0x07c04947, 0x058101c7, 0x07c04987, 0x0649d307, 0x07c049c7,
+	0x058101c7, 0x07c04a07, 0x0c004280, 0x06800025, 0x08002501,
+	0x08002605, 0x08002708, 0x08002815, 0x08002c14, 0x08002a09,
+	0x08002b17, 0x06830002, 0x06032602, 0x08032261, 0x08032101,
+	0x0cc00000, 0x00000000, 0x080c2804, 0x064c2807, 0x0a2fc047,
+	0x05801207, 0x080c2800, 0x0aa14008, 0x0b21004a, 0x044011ca,
+	0x0f8001c7, 0x094e9207, 0x0cc00000, 0x07400248, 0x080c2804,
+	0x064c2807, 0x0a2fc047, 0x05801207, 0x0cc00000, 0x07400248,
+	0x0fc011c0, 0x0a608007, 0x0c780ec0, 0x06800247, 0x07c00147,
+	0x07800488, 0x095011c8, 0x060c2107, 0x080e1401, 0x080c2440,
+	0x064e1507, 0x078004c8, 0x0aa400c8, 0x0aa54088, 0x060c2207,
+	0x07800487, 0x0aa28007, 0x07801107, 0x064e1508, 0x060c2208,
+	0x07801c48, 0x094411c8, 0x068010c8, 0x09503207, 0x0c780440,
+	0x060c2108, 0x0c7803c0, 0x080c2141, 0x080c2200, 0x080c2200,
+	0x080c2200, 0x080c2200, 0x0c780240, 0x080c2141, 0x064e1507,
+	0x060c2207, 0x064e1507, 0x060c2207, 0x064e1507, 0x060c2207,
+	0x080c2147, 0x064c2407, 0x0befc3c7, 0x078004c7, 0x07c00387,
+	0x07800487, 0x07c00247, 0x07801107, 0x07c01787, 0x06800107,
+	0x07c003c7, 0x0c007900, 0x00000000, 0x08030580, 0x07800007,
+	0x040011c7, 0x07c00007, 0x06431e07, 0x0befc047, 0x0c7ea700,
+	0x00000000, 0x0fc01200, 0x0fc011c0, 0x0aa28047, 0x06800147,
+	0x0fc011c0, 0x0aa1c047, 0x06800187, 0x0fc011c0, 0x0aa10047,
+	0x068001c7, 0x0fc011c0, 0x06800207, 0x07c00147, 0x0a60c008,
+	0x06800007, 0x0fc061c0, 0x07c01387, 0x07800147, 0x0aa4c147,
+	0x07801387, 0x0aa44007, 0x00000000, 0x0fc011c0, 0x0aa38007,
+	0x07800108, 0x0fc011c0, 0x0aa14007, 0x0b21c748, 0x04002208,
+	0x0c780140, 0x068007c8, 0x0b60c0c8, 0x04402208, 0x06800048,
+	0x07c00108, 0x0c0005c0, 0x040001c8, 0x0c7eeb40, 0x00000000,
+	0x06a00007, 0x06e00007, 0x080c24a0, 0x060c2207, 0x060c2207,
+	0x060c2207, 0x060c2207, 0x060c2207, 0x0cc00000, 0x060c2207,
+	0x07801988, 0x094c11c8, 0x0c07fd00, 0x060e0407, 0x06800007,
+	0x07c01cc7, 0x07c00907, 0x0cc00000, 0x07c00947, 0x060c0a07,
+	0x078000c8, 0x0aa24008, 0x06800009, 0x0aa1c1c8, 0x06800049,
+	0x05401247, 0x0400b249, 0x0b403247, 0x06800049, 0x06800009,
+	0x07c00bc9, 0x0b218107, 0x0ae08207, 0x0c780380, 0x0b214607,
+	0x0c780180, 0x00000000, 0x0c780480, 0x06820207, 0x0c780240,
+	0x00000000, 0x05401207, 0x04410208, 0x044061c7, 0x054081c7,
+	0x0c780280, 0x094081c8, 0x0c7800c0, 0x0c7800c0, 0x04008207,
+	0x05401207, 0x0400d1c7, 0x054071c7, 0x0c780080, 0x094081c8,
+	0x07c002c7, 0x06b00008, 0x064c2d09, 0x09610248, 0x060c2d09,
+	0x09610208, 0x060c2f08, 0x07801988, 0x094c11c8, 0x0cc00000,
+	0x060e0407, 0x0680000e, 0x0aa4c00f, 0x0ae1400f, 0x0400038f,
+	0x06bfffce, 0x0300e38f, 0x0400138e, 0x0900434e, 0x0b21408d,
+	0x06800007, 0x0b20c34d, 0x06800047, 0x06800087, 0x05c0438e,
+	0x0540138e, 0x0200e1ce, 0x0ae1000f, 0x06bfffcd, 0x0300e34e,
+	0x0400138e, 0x0cc00000, 0x040003ce, 0x07800007, 0x0ae10007,
+	0x07800109, 0x07800988, 0x02007207, 0x044011c7, 0x06808048,
+	0x02007207, 0x074001c9, 0x0cc00000, 0x07c08009, 0x0681f409,
+	0x04401249, 0x0aefc009, 0x00000000, 0x083f0040, 0x083f0000,
+	0x08090b65, 0x00000000, 0x08090b60, 0x06498e07, 0x09807007,
+	0x068007c9, 0x097051c9, 0x06098e07, 0x0681f409, 0x04601249,
+	0x0c4fffc0, 0x00000000, 0x06800009, 0x097051c9, 0x09c07007,
+	0x06098e07, 0x064c0007, 0x09c07187, 0x09807207, 0x060c0007,
+	0x064c0807, 0x09807347, 0x060c0807, 0x083f0040, 0x083f0000,
+	0x08090b65, 0x0cc00000, 0x08090b60, 0x0680001f, 0x07c0149f,
+	0x07c014df, 0x07c0151f, 0x064c091f, 0x07c0175f, 0x07c0005f,
+	0x06800020, 0x06803fc2, 0x07c01542, 0x07c01582, 0x07c015c2,
+	0x07c01602, 0x060c091f, 0x080c0101, 0x080c2901, 0x06840442,
+	0x060c2e02, 0x064c4027, 0x064c4226, 0x024269e6, 0x040089a6,
+	0x07c006e6, 0x058109a6, 0x07c00726, 0x0649cf31, 0x0809c500,
+	0x0649c707, 0x0aa6c007, 0x09010207, 0x092101c7, 0x0401f287,
+	0x0580528a, 0x0403e247, 0x05806249, 0x09610289, 0x04000287,
+	0x0649c709, 0x09610247, 0x0609c709, 0x0400f1c7, 0x058041c7,
+	0x060c0907, 0x07c00987, 0x04401247, 0x07c00609, 0x0961020a,
+	0x06090808, 0x06c00008, 0x0649c707, 0x094101c8, 0x0609c707,
+	0x0400f208, 0x05804208, 0x07c009c8, 0x0809c300, 0x0809cb00,
+	0x0cc00000, 0x00000000, 0x0649c803, 0x0aa14003, 0x078014c2,
+	0x028020c2, 0x07c014c2, 0x0809c800, 0x07801502, 0x0aa0c002,
+	0x06800102, 0x06030502, 0x064c0002, 0x0be14042, 0x0ba1d025,
+	0x06800102, 0x07c01502, 0x08030504, 0x06800025, 0x0cc00000,
+	0x00000000, 0x078001c2, 0x0aa1c002, 0x078016c2, 0x078009c3,
+	0x0a4040c2, 0x00000000, 0x06800102, 0x06030502, 0x0cc00000,
+	0x00000000, 0x0fc02240, 0x0aa4c009, 0x0680000a, 0x0b6180c9,
+	0x0680010a, 0x0fc01280, 0x09422289, 0x0c780140, 0x0440128a,
+	0x0fc01240, 0x0a6fc009, 0x0400128a, 0x06800049, 0x03409289,
+	0x05801249, 0x0f80028a, 0x0b40424a, 0x05401249, 0x04401249,
+	0x0240a24a, 0x0740020a, 0x0cc00000, 0x0fc01240, 0x064c441a,
+	0x0912169a, 0x0aaf801a, 0x0c7e54c0, 0x00000000, 0x06490628,
+	0x0aefcc28, 0x00000000, 0x07800028, 0x078016e9, 0x09508a68,
+	0x068000a8, 0x06c00028, 0x06090628, 0x06090629, 0x06881068,
+	0x06090628, 0x0cc00000, 0x00000000, 0x06490628, 0x0aefcc28,
+	0x06c00028, 0x069001a8, 0x069fffea, 0x06090628, 0x06090629,
+	0x05401a23, 0x06090628, 0x09210a23, 0x05401a28, 0x02828aa8,
+	0x06090628, 0x06985168, 0x0c782700, 0x06090628, 0x078003e8,
+	0x0a6fc028, 0x07800028, 0x078016e9, 0x06800030, 0x09508a68,
+	0x0780016b, 0x07801d2a, 0x04601aaa, 0x0c500ec0, 0x0aa4802b,
+	0x0690002a, 0x0aa4006b, 0x0aa8c36b, 0x0aa883eb, 0x0aa3422b,
+	0x00000000, 0x06a0002a, 0x0aa281eb, 0x06c0002a, 0x06b0002a,
+	0x0aa1c1ab, 0x06c0002a, 0x04602aeb, 0x0c500980, 0x0690002a,
+	0x0c7e4d00, 0x00000000, 0x06490628, 0x0aefcc28, 0x068000a8,
+	0x02c28aa8, 0x09441a30, 0x06090628, 0x06090629, 0x069fffeb,
+	0x06900028, 0x0a00ca2a, 0x080c2400, 0x080e1424, 0x064c2228,
+	0x060e1528, 0x060e1528, 0x060e1528, 0x060e1528, 0x09210a68,
+	0x06090628, 0x02828ae9, 0x06090628, 0x06a00028, 0x0a007a2a,
 	0x080c2440, 0x064c2228, 0x09210a68, 0x06090628, 0x02828ae9,
-	0x06090628, 0x06b8d068, 0x09441a30, 0x0c781340, 0x06090628,
-	0x06b0002a, 0x09441ab0, 0x06031f2a, 0x0680016b, 0x09510ae9,
-	0x0c781180, 0x06031e2b, 0x0aa1416b, 0x0aa1026b, 0x06800070,
-	0x0c7ff5c0, 0x00000000, 0x06490628, 0x0aefcc28, 0x06b408a8,
-	0x09441a30, 0x06090628, 0x06090629, 0x069fffec, 0x06900028,
-	0x080c2400, 0x064c222e, 0x0609062e, 0x09210a2e, 0x09c28068,
-	0x02828b28, 0x09828428, 0x078017ad, 0x095e1a2d, 0x06090628,
-	0x080c2440, 0x064c2228, 0x06090628, 0x09210a28, 0x09c28068,
-	0x02828b28, 0x09828428, 0x06090628, 0x06bc5828, 0x09441a30,
-	0x06090628, 0x06b60828, 0x09441a30, 0x06090628, 0x06900028,
-	0x080c2410, 0x064c222f, 0x0609062f, 0x09210a2f, 0x09c28068,
-	0x02828b28, 0x09828428, 0x078017ad, 0x05801b6d, 0x095e1a2d,
-	0x06090628, 0x080c2450, 0x064c2228, 0x06090628, 0x09210a28,
-	0x09c28068, 0x02828b28, 0x09828428, 0x098283e8, 0x06090628,
-	0x06bed868, 0x09441a30, 0x06090628, 0x080c24a0, 0x080e1424,
-	0x064c2228, 0x060e152e, 0x060e152f, 0x060e1528, 0x060e1528,
-	0x0cc00000, 0x00000000, 0x064e1215, 0x091e1555, 0x0a208055,
-	0x0c782300, 0x0649d915, 0x0900c555, 0x0a6f8015, 0x00000000,
-	0x078003d5, 0x0aa08055, 0x0c780940, 0x07800596, 0x0aa1c016,
-	0x04401596, 0x07c00596, 0x078005d6, 0x04401596, 0x0c7814c0,
-	0x07c005d6, 0x07800916, 0x07800295, 0x05408555, 0x02015595,
-	0x04003596, 0x07c00916, 0x05404595, 0x02016c56, 0x060e1316,
-	0x07800517, 0x0aa0c017, 0x06a16016, 0x06a16196, 0x07c00416,
-	0x069fffd7, 0x044015d7, 0x0aa1c017, 0x00000000, 0x064e1615,
-	0x09010555, 0x0aaec015, 0x04401555, 0x060e1615, 0x06c00016,
-	0x060e1216, 0x06800095, 0x0c781880, 0x07c003d5, 0x0a660095,
-	0x078005d6, 0x0aa18016, 0x04401596, 0x0b210056, 0x07c005d6,
-	0x0c780bc0, 0x00000000, 0x07800956, 0x07800295, 0x05408555,
-	0x02015595, 0x04003596, 0x07c00956, 0x05404595, 0x02016c56,
-	0x060e1316, 0x07800415, 0x09c151d5, 0x06c00015, 0x060e1215,
-	0x068000d5, 0x0c781280, 0x07c003d5, 0x0aa080d5, 0x0c780700,
-	0x07800516, 0x0aa0c016, 0x06800017, 0x06800317, 0x060e1417,
-	0x07800795, 0x07c00755, 0x0683ffd5, 0x064e1516, 0x0900c5d6,
-	0x0a40b5d5, 0x091845d6, 0x07c00797, 0x064e1516, 0x064e1516,
-	0x064e1516, 0x080c24e0, 0x060c2216, 0x064e1516, 0x0c780200,
-	0x060c2216, 0x068000d6, 0x07c00796, 0x06800016, 0x080c24e0,
-	0x060c2216, 0x060c2216, 0x0aa080a0, 0x0c780a00, 0x078003d5,
-	0x0a644115, 0x07800956, 0x068ac015, 0x05408555, 0x02015595,
-	0x04003596, 0x07c00956, 0x05404595, 0x02016c56, 0x060e1316,
-	0x06a16015, 0x09c151d5, 0x06c00015, 0x060e1215, 0x06800195,
-	0x0c780640, 0x07c003d5, 0x0aa0c195, 0x0c780500, 0x00000000,
-	0x06431e18, 0x0befc058, 0x064e1418, 0x080e1400, 0x064e1516,
-	0x0683ffd5, 0x0900c5d6, 0x09203656, 0x0a8045d5, 0x091845d6,
-	0x068000d7, 0x06800019, 0x07c004d7, 0x090015d9, 0x07c00497,
-	0x090225d9, 0x07c01117, 0x060e1418, 0x06800015, 0x07c003d5,
-	0x0cc00000, 0x00400000, 0x06800047, 0x07c003c7, 0x07800507,
-	0x050011c7, 0x07c00507, 0x064e1608, 0x09010208, 0x04001208,
-	0x060e1608, 0x0aa0c007, 0x06800008, 0x06800308, 0x060e1408,
-	0x06b7ffc7, 0x06c00007, 0x060e1507, 0x060e1524, 0x060e1524,
-	0x060e1524, 0x060e1524, 0x0cc00000, 0x08030580, 0x078003c7,
-	0x0a6fc007, 0x07800447, 0x0aa0c0c7, 0x0aa98347, 0x0a638107,
-	0x07800507, 0x050011c7, 0x07c00507, 0x06800047, 0x07c003c7,
-	0x080c24e0, 0x064c2207, 0x064c2208, 0x080c24c0, 0x060c2207,
-	0x060c2208, 0x0cc00000, 0x08030580, 0x06800047, 0x07c003c7,
-	0x07800507, 0x050011c7, 0x07c00507, 0x080e1424, 0x064e1509,
-	0x064e150a, 0x064e150b, 0x064e150c, 0x0aa0c007, 0x06800008,
-	0x06800308, 0x060e1408, 0x0683ffc7, 0x07800448, 0x095841c8,
-	0x07800308, 0x096031c8, 0x060e1507, 0x060e1509, 0x060e150a,
-	0x060e150b, 0x060e150c, 0x0cc00000, 0x08030580, 0x07800987,
-	0x078009c8, 0x06800009, 0x0d000008, 0x020091c9, 0x04401249,
-	0x06800047, 0x0ba10089, 0x05801249, 0x0c7fff80, 0x040011c7,
-	0x0cc00000, 0x07c00687, 0x06800208, 0x064c3b07, 0x091031c7,
-	0x024071c8, 0x0f8001c7, 0x0fc0f1c0, 0x064c0e07, 0x040011c7,
-	0x0f8001c7, 0x07800687, 0x0f8001c7, 0x0fc051c0, 0x0c073d80,
-	0x07c00107, 0x0fc011c0, 0x0aa0c007, 0x0c000640, 0x00000000,
-	0x078002c7, 0x07801988, 0x094c11c8, 0x0c073680, 0x060e0407,
-	0x06800007, 0x07c01cc7, 0x078005c7, 0x0b210087, 0x07800988,
-	0x04002208, 0x024081c8, 0x07800947, 0x04401208, 0x02007207,
-	0x05401208, 0x02007207, 0x07c00947, 0x07800987, 0x040011c7,
-	0x07c005c7, 0x0cc00000, 0x00000000, 0x0fc011c0, 0x0a600007,
-	0x0fc011c0, 0x07801408, 0x0f8001c8, 0x0fc011c0, 0x0fc021c0,
-	0x0fc03200, 0x0aa10007, 0x0aa0c047, 0x0fc03200, 0x0fc03200,
-	0x0cc00000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x06090628, 0x0688d068, 0x02c28aa8, 0x09441a30, 0x0c781780,
+	0x06090628, 0x09441ab0, 0x06031f2a, 0x0680016b, 0x09510ae9,
+	0x0c781600, 0x06031e2b, 0x0aa241eb, 0x06a0002a, 0x0aa1c1ab,
+	0x06b0002a, 0x0aa1416b, 0x0aa1026b, 0x06800070, 0x0690002a,
+	0x06800030, 0x06490628, 0x0aefcc28, 0x06c0002a, 0x068408a8,
+	0x02c28aa8, 0x09441a30, 0x06090628, 0x06090629, 0x069fffec,
+	0x06900028, 0x0a00ba2a, 0x080c2400, 0x064c222e, 0x0609062e,
+	0x09210a2e, 0x09c28068, 0x02828b28, 0x09828428, 0x07801d6d,
+	0x095e1a2d, 0x06090628, 0x06a00028, 0x0a00ba2a, 0x080c2440,
+	0x064c2228, 0x06090628, 0x09210a28, 0x09c28068, 0x02828b28,
+	0x09828428, 0x07801ded, 0x095e1a2d, 0x06090628, 0x068c5828,
+	0x02c28aa8, 0x09441a30, 0x06090628, 0x06860828, 0x02c28aa8,
+	0x09441a30, 0x06090628, 0x06900028, 0x0a00ba2a, 0x080c2410,
+	0x064c222f, 0x0609062f, 0x09210a2f, 0x09c28068, 0x02828b28,
+	0x09828428, 0x07801dad, 0x095e1a2d, 0x06090628, 0x06a00028,
+	0x0a00ba2a, 0x080c2450, 0x064c2228, 0x06090628, 0x09210a28,
+	0x09c28068, 0x02828b28, 0x09828428, 0x07801e2d, 0x095e1a2d,
+	0x06090628, 0x068ed868, 0x02c28aa8, 0x09441a30, 0x06090628,
+	0x080c24a0, 0x080e1424, 0x064c2228, 0x060e152e, 0x060e152f,
+	0x060e1528, 0x0c780080, 0x060e1528, 0x0cc00000, 0x00000000,
+	0x07800028, 0x078016e9, 0x06800030, 0x09508a68, 0x0780016b,
+	0x0780026a, 0x04601aaa, 0x0c500c00, 0x0aa1416b, 0x00000000,
+	0x06800070, 0x0a61826b, 0x00000000, 0x078003a8, 0x04602a28,
+	0x0c500840, 0x0c7800c0, 0x0c780000, 0x00000000, 0x06490628,
+	0x0aefcc28, 0x06b000a8, 0x09441a30, 0x06090628, 0x06090629,
+	0x069fffeb, 0x06900028, 0x080c2400, 0x080e1424, 0x064c2228,
+	0x060e1528, 0x060e1528, 0x060e1528, 0x060e1528, 0x09210a68,
+	0x06090628, 0x02828ae9, 0x06090628, 0x080c2440, 0x064c2228,
+	0x09210a68, 0x06090628, 0x02828ae9, 0x06090628, 0x06b8d068,
+	0x09441a30, 0x0c781340, 0x06090628, 0x06b0002a, 0x09441ab0,
+	0x06031f2a, 0x0680016b, 0x09510ae9, 0x0c781180, 0x06031e2b,
+	0x0aa1416b, 0x0aa1026b, 0x06800070, 0x0c7ff5c0, 0x00000000,
+	0x06490628, 0x0aefcc28, 0x06b408a8, 0x09441a30, 0x06090628,
+	0x06090629, 0x069fffec, 0x06900028, 0x080c2400, 0x064c222e,
+	0x0609062e, 0x09210a2e, 0x09c28068, 0x02828b28, 0x09828428,
+	0x078017ad, 0x095e1a2d, 0x06090628, 0x080c2440, 0x064c2228,
+	0x06090628, 0x09210a28, 0x09c28068, 0x02828b28, 0x09828428,
+	0x06090628, 0x06bc5828, 0x09441a30, 0x06090628, 0x06b60828,
+	0x09441a30, 0x06090628, 0x06900028, 0x080c2410, 0x064c222f,
+	0x0609062f, 0x09210a2f, 0x09c28068, 0x02828b28, 0x09828428,
+	0x078017ad, 0x05801b6d, 0x095e1a2d, 0x06090628, 0x080c2450,
+	0x064c2228, 0x06090628, 0x09210a28, 0x09c28068, 0x02828b28,
+	0x09828428, 0x098283e8, 0x06090628, 0x06bed868, 0x09441a30,
+	0x06090628, 0x080c24a0, 0x080e1424, 0x064c2228, 0x060e152e,
+	0x060e152f, 0x060e1528, 0x060e1528, 0x0cc00000, 0x00000000,
+	0x064e1215, 0x091e1555, 0x0a208055, 0x0c782300, 0x0649d915,
+	0x0900c555, 0x0a6f8015, 0x00000000, 0x078003d5, 0x0aa08055,
+	0x0c780940, 0x07800596, 0x0aa1c016, 0x04401596, 0x07c00596,
+	0x078005d6, 0x04401596, 0x0c7814c0, 0x07c005d6, 0x07800916,
+	0x07800295, 0x05408555, 0x02015595, 0x04003596, 0x07c00916,
+	0x05404595, 0x02016c56, 0x060e1316, 0x07800517, 0x0aa0c017,
+	0x06a16016, 0x06a16196, 0x07c00416, 0x069fffd7, 0x044015d7,
+	0x0aa1c017, 0x00000000, 0x064e1615, 0x09010555, 0x0aaec015,
+	0x04401555, 0x060e1615, 0x06c00016, 0x060e1216, 0x06800095,
+	0x0c781880, 0x07c003d5, 0x0a660095, 0x078005d6, 0x0aa18016,
+	0x04401596, 0x0b210056, 0x07c005d6, 0x0c780bc0, 0x00000000,
+	0x07800956, 0x07800295, 0x05408555, 0x02015595, 0x04003596,
+	0x07c00956, 0x05404595, 0x02016c56, 0x060e1316, 0x07800415,
+	0x09c151d5, 0x06c00015, 0x060e1215, 0x068000d5, 0x0c781280,
+	0x07c003d5, 0x0aa080d5, 0x0c780700, 0x07800516, 0x0aa0c016,
+	0x06800017, 0x06800317, 0x060e1417, 0x07800795, 0x07c00755,
+	0x0683ffd5, 0x064e1516, 0x0900c5d6, 0x0a40b5d5, 0x091845d6,
+	0x07c00797, 0x064e1516, 0x064e1516, 0x064e1516, 0x080c24e0,
+	0x060c2216, 0x064e1516, 0x0c780200, 0x060c2216, 0x068000d6,
+	0x07c00796, 0x06800016, 0x080c24e0, 0x060c2216, 0x060c2216,
+	0x0aa080a0, 0x0c780a00, 0x078003d5, 0x0a644115, 0x07800956,
+	0x068ac015, 0x05408555, 0x02015595, 0x04003596, 0x07c00956,
+	0x05404595, 0x02016c56, 0x060e1316, 0x06a16015, 0x09c151d5,
+	0x06c00015, 0x060e1215, 0x06800195, 0x0c780640, 0x07c003d5,
+	0x0aa0c195, 0x0c780500, 0x00000000, 0x06431e18, 0x0befc058,
+	0x064e1418, 0x080e1400, 0x064e1516, 0x0683ffd5, 0x0900c5d6,
+	0x09203656, 0x0a8045d5, 0x091845d6, 0x068000d7, 0x06800019,
+	0x07c004d7, 0x090015d9, 0x07c00497, 0x090225d9, 0x07c01117,
+	0x060e1418, 0x06800015, 0x07c003d5, 0x0cc00000, 0x00400000,
+	0x06800047, 0x07c003c7, 0x07800507, 0x050011c7, 0x07c00507,
+	0x064e1608, 0x09010208, 0x04001208, 0x060e1608, 0x0aa0c007,
+	0x06800008, 0x06800308, 0x060e1408, 0x06b7ffc7, 0x06c00007,
+	0x060e1507, 0x060e1524, 0x060e1524, 0x060e1524, 0x060e1524,
+	0x0cc00000, 0x08030580, 0x078003c7, 0x0a6fc007, 0x07800447,
+	0x0aa0c0c7, 0x0aa98347, 0x0a638107, 0x07800507, 0x050011c7,
+	0x07c00507, 0x06800047, 0x07c003c7, 0x080c24e0, 0x064c2207,
+	0x064c2208, 0x080c24c0, 0x060c2207, 0x060c2208, 0x0cc00000,
+	0x08030580, 0x06800047, 0x07c003c7, 0x07800507, 0x050011c7,
+	0x07c00507, 0x080e1424, 0x064e1509, 0x064e150a, 0x064e150b,
+	0x064e150c, 0x0aa0c007, 0x06800008, 0x06800308, 0x060e1408,
+	0x0683ffc7, 0x07800448, 0x095841c8, 0x07800308, 0x096031c8,
+	0x060e1507, 0x060e1509, 0x060e150a, 0x060e150b, 0x060e150c,
+	0x0cc00000, 0x08030580, 0x07800987, 0x078009c8, 0x06800009,
+	0x0d000008, 0x020091c9, 0x04401249, 0x06800047, 0x0ba10089,
+	0x05801249, 0x0c7fff80, 0x040011c7, 0x0cc00000, 0x07c00687,
+	0x06800208, 0x064c3b07, 0x091031c7, 0x024071c8, 0x0f8001c7,
+	0x0fc0f1c0, 0x064c0e07, 0x040011c7, 0x0f8001c7, 0x07800687,
+	0x0f8001c7, 0x0fc051c0, 0x0c073d80, 0x07c00107, 0x0fc011c0,
+	0x0aa0c007, 0x0c000640, 0x00000000, 0x078002c7, 0x07801988,
+	0x094c11c8, 0x0c073680, 0x060e0407, 0x06800007, 0x07c01cc7,
+	0x078005c7, 0x0b210087, 0x07800988, 0x04002208, 0x024081c8,
+	0x07800947, 0x04401208, 0x02007207, 0x05401208, 0x02007207,
+	0x07c00947, 0x07800987, 0x040011c7, 0x07c005c7, 0x0cc00000,
+	0x00000000, 0x0fc011c0, 0x0a600007, 0x0fc011c0, 0x07801408,
+	0x0f8001c8, 0x0fc011c0, 0x0fc021c0, 0x0fc03200, 0x0aa10007,
+	0x0aa0c047, 0x0fc03200, 0x0fc03200, 0x0cc00000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -663,476 +663,476 @@ const u32 vmpeg4_mc_4[] __initconst = {
 };
 
 const u32 __initconst vmpeg4_mc_5[] = {
-	0x0680c001, 0x06800000, 0x0d000001, 0x07400040, 0x0c014d40,
+	0x0680c001, 0x06800000, 0x0d000001, 0x07400040, 0x0c014f40,
 	0x00000000, 0x00000000, 0x00000000, 0x080c0002, 0x080c2901,
-	0x06bfde80, 0x07c017c0, 0x06030400, 0x00400000, 0x0c01a400,
+	0x06bfde80, 0x07c017c0, 0x06030400, 0x00400000, 0x0c01a600,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x0c7ffe80, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x0c780400, 0x04001965, 0x0cc00000,
-	0x00400000, 0x0c7804c0, 0x064c0007, 0x0c79ab00, 0x06800025,
+	0x00400000, 0x0c7804c0, 0x064c0007, 0x0c79ad00, 0x06800025,
 	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
-	0x00400000, 0x0c79f800, 0x06800025, 0x0cc00000, 0x00400000,
+	0x00400000, 0x0c79fa00, 0x06800025, 0x0cc00000, 0x00400000,
 	0x06800025, 0x00800000, 0x078017c9, 0x0c7ffec0, 0x06030409,
-	0x078001c9, 0x0aa0c009, 0x0c790940, 0x00000000, 0x06bfdd89,
+	0x078001c9, 0x0aa0c009, 0x0c790980, 0x00000000, 0x06bfdd89,
 	0x06030409, 0x00400000, 0x07801509, 0x0aa2c109, 0x07c0151f,
-	0x0a2c4047, 0x06800025, 0x0aa14009, 0x0a608049, 0x0c791300,
-	0x0a608089, 0x0c7905c0, 0x0a240807, 0x0c789400, 0x00000000,
+	0x0a2c4047, 0x06800025, 0x0aa14009, 0x0a608049, 0x0c791500,
+	0x0a608089, 0x0c790600, 0x0a240807, 0x0c789440, 0x00000000,
 	0x0683ffc8, 0x0ba20048, 0x064c0007, 0x0a2f8047, 0x04401208,
 	0x064c3a07, 0x090061c7, 0x0aae8647, 0x00000000, 0x06800007,
-	0x0c017b00, 0x07c003c7, 0x0c7934c0, 0x0bec9007, 0x078003c7,
+	0x0c017d00, 0x07c003c7, 0x0c7936c0, 0x0bec9007, 0x078003c7,
 	0x0a6fc007, 0x07800007, 0x07800988, 0x0b822207, 0x06800007,
 	0x07c00007, 0x0a628060, 0x06a00008, 0x06e00008, 0x06431e09,
 	0x0befc049, 0x00000000, 0x080c24a0, 0x060c2208, 0x0c780300,
 	0x060c2208, 0x0a6280a0, 0x00000000, 0x06431e09, 0x0befc049,
 	0x00000000, 0x080c24c0, 0x080c2200, 0x080c2200, 0x080c2200,
 	0x080c2200, 0x078016c8, 0x04001208, 0x078009c9, 0x0b80a248,
-	0x07c016c8, 0x0c020f00, 0x00000000, 0x078003c7, 0x0a6fc007,
-	0x0c792b40, 0x00000000, 0x06431e09, 0x0befc049, 0x07800347,
-	0x0aa0c007, 0x0c780880, 0x00000000, 0x064c1d07, 0x09227207,
-	0x0a678008, 0x064c2a08, 0x064c3607, 0x091081c7, 0x095101c8,
-	0x064c3b08, 0x09103248, 0x04001209, 0x03807207, 0x0900f207,
-	0x0a650008, 0x0580f1c7, 0x06800048, 0x05407208, 0x03808248,
-	0x04401208, 0x0a40e207, 0x064c1d07, 0x0a60c009, 0x00000000,
-	0x054081c7, 0x06800009, 0x09201207, 0x0a610008, 0x054011c7,
-	0x0c7fff40, 0x04001249, 0x060c0e09, 0x0c021300, 0x00000000,
-	0x0aa080a0, 0x0c780f40, 0x078003c7, 0x0a6fc007, 0x07801bc8,
-	0x0a63c008, 0x078004c8, 0x0a634348, 0x06800107, 0x07c003c7,
-	0x08030580, 0x068003c9, 0x07c00149, 0x06800007, 0x0c019080,
-	0x07c01d07, 0x07800007, 0x040011c7, 0x0c7fe880, 0x07c00007,
-	0x0c793040, 0x078003c7, 0x0a6fc007, 0x078005c7, 0x0ba0c087,
-	0x06800007, 0x06800047, 0x07c01fc7, 0x07800787, 0x0aa180c7,
-	0x06810007, 0x060e0907, 0x060e0a07, 0x0c780440, 0x060e0b07,
-	0x07800507, 0x0aa0c007, 0x068000c8, 0x068003c8, 0x060e1408,
-	0x064e1507, 0x060e0907, 0x04003208, 0x060e1408, 0x064e1507,
-	0x060e0a07, 0x04003208, 0x060e1408, 0x064e1507, 0x060e0b07,
-	0x0683ffc7, 0x080e1418, 0x060e1507, 0x080e141b, 0x060e1507,
-	0x080e141e, 0x060e1507, 0x080e1421, 0x0c01f580, 0x060e1507,
-	0x0c7855c0, 0x00000000, 0x0aa6c020, 0x00000000, 0x0fc011c0,
-	0x0aa64007, 0x080c2803, 0x06800347, 0x07c00147, 0x06431e07,
-	0x0befc047, 0x00000000, 0x080c24a0, 0x060c2224, 0x060c2224,
-	0x06800007, 0x07c01d07, 0x06800025, 0x064c3c07, 0x091011c7,
-	0x0ae1c225, 0x0aaf8007, 0x064c3c07, 0x091011c7, 0x0aae8007,
-	0x0c7ff000, 0x080c2800, 0x0c7fd380, 0x00000000, 0x080c2801,
-	0x064c2807, 0x0a2fc047, 0x064c0008, 0x0a209008, 0x0c7fd1c0,
-	0x058011c7, 0x09004207, 0x07c00148, 0x090821c7, 0x07c00187,
-	0x0aa140c8, 0x080c2800, 0x0aa0c108, 0x0c781940, 0x00000000,
-	0x0fc011c0, 0x0540e1c7, 0x060c2d07, 0x080c2802, 0x064c2807,
-	0x0a2fc047, 0x058011c7, 0x07800188, 0x09444207, 0x07c01388,
-	0x07800148, 0x0a644108, 0x080c2800, 0x0fc021c0, 0x0b61c087,
-	0x07800109, 0x024091c9, 0x0b620089, 0x04401249, 0x0c780180,
-	0x06800049, 0x020091c9, 0x0b20c809, 0x04401249, 0x068007c9,
-	0x07c00109, 0x0c013240, 0x040001c9, 0x07801fcb, 0x0aa1400b,
-	0x078005c9, 0x0b60c089, 0x0c0048c0, 0x00000000, 0x068fdfca,
+	0x07c016c8, 0x0c021100, 0x00000000, 0x078003c7, 0x0a6fc007,
+	0x0c792d40, 0x00000000, 0x06431e09, 0x0befc049, 0x0a64c0a0,
+	0x078003c7, 0x0a6fc007, 0x07801bc8, 0x0a63c008, 0x078004c8,
+	0x0a634348, 0x06800107, 0x07c003c7, 0x08030580, 0x068003c9,
+	0x07c00149, 0x06800007, 0x0c019bc0, 0x07c01d07, 0x07800007,
+	0x040011c7, 0x0c7ff1c0, 0x07c00007, 0x07800347, 0x0aa0c007,
+	0x0c780880, 0x00000000, 0x064c1d07, 0x09227207, 0x0a678008,
+	0x064c2a08, 0x064c3607, 0x091081c7, 0x095101c8, 0x064c3b08,
+	0x09103248, 0x04001209, 0x03807207, 0x0900f207, 0x0a650008,
+	0x0580f1c7, 0x06800048, 0x05407208, 0x03808248, 0x04401208,
+	0x0a40e207, 0x064c1d07, 0x0a60c009, 0x00000000, 0x054081c7,
+	0x06800009, 0x09201207, 0x0a610008, 0x054011c7, 0x0c7fff40,
+	0x04001249, 0x060c0e09, 0x0c021040, 0x00000000, 0x0aa080a0,
+	0x0c780ac0, 0x0c793200, 0x078003c7, 0x0a6fc007, 0x078005c7,
+	0x0ba0c087, 0x06800007, 0x06800047, 0x07c01fc7, 0x07800787,
+	0x0aa180c7, 0x06810007, 0x060e0907, 0x060e0a07, 0x0c780440,
+	0x060e0b07, 0x07800507, 0x0aa0c007, 0x068000c8, 0x068003c8,
+	0x060e1408, 0x064e1507, 0x060e0907, 0x04003208, 0x060e1408,
+	0x064e1507, 0x060e0a07, 0x04003208, 0x060e1408, 0x064e1507,
+	0x060e0b07, 0x0683ffc7, 0x080e1418, 0x060e1507, 0x080e141b,
+	0x060e1507, 0x080e141e, 0x060e1507, 0x080e1421, 0x0c01f740,
+	0x060e1507, 0x0c7855c0, 0x00000000, 0x0aa6c020, 0x00000000,
+	0x0fc011c0, 0x0aa64007, 0x080c2803, 0x06800347, 0x07c00147,
+	0x06431e07, 0x0befc047, 0x00000000, 0x080c24a0, 0x060c2224,
+	0x060c2224, 0x06800007, 0x07c01d07, 0x06800025, 0x064c3c07,
+	0x091011c7, 0x0ae1c225, 0x0aaf8007, 0x064c3c07, 0x091011c7,
+	0x0aae8007, 0x0c7ff000, 0x080c2800, 0x0c7fd340, 0x00000000,
+	0x080c2801, 0x064c2807, 0x0a2fc047, 0x064c0008, 0x0a209008,
+	0x0c7fd180, 0x058011c7, 0x09004207, 0x07c00148, 0x090821c7,
+	0x07c00187, 0x0aa140c8, 0x080c2800, 0x0aa0c108, 0x0c781940,
+	0x00000000, 0x0fc011c0, 0x0540e1c7, 0x060c2d07, 0x080c2802,
+	0x064c2807, 0x0a2fc047, 0x058011c7, 0x07800188, 0x09444207,
+	0x07c01388, 0x07800148, 0x0a644108, 0x080c2800, 0x0fc021c0,
+	0x0b61c087, 0x07800109, 0x024091c9, 0x0b620089, 0x04401249,
+	0x0c780180, 0x06800049, 0x020091c9, 0x0b20c809, 0x04401249,
+	0x068007c9, 0x07c00109, 0x0c013400, 0x040001c9, 0x07801fcb,
+	0x0aa1400b, 0x078005c9, 0x0b60c089, 0x0c0048c0, 0x00000000,
+	0x068fdfca, 0x06feffca, 0x064e0408, 0x02808288, 0x078005ca,
+	0x0ba0c08a, 0x064c0909, 0x098083c8, 0x0ac0424a, 0x0780000a,
+	0x0a60c00a, 0x0400128a, 0x09808388, 0x0b80324a, 0x00000000,
+	0x098081c8, 0x07808007, 0x09605207, 0x07800007, 0x06808049,
+	0x02007247, 0x070001c7, 0x096a5207, 0x060e0408, 0x091e1248,
+	0x07c01fc9, 0x07801388, 0x060c2b08, 0x06880008, 0x098083c8,
+	0x07800507, 0x07801989, 0x0a610049, 0x09581207, 0x09808408,
+	0x098083c8, 0x060e0508, 0x06800009, 0x07800bc8, 0x09541248,
+	0x060c2a09, 0x07801c07, 0x0aa1c007, 0x080c2c03, 0x0fc011c0,
+	0x07c01cc7, 0x068000c9, 0x094a1247, 0x060c2c09, 0x0c01d6c0,
+	0x00000000, 0x080c0080, 0x0c015e80, 0x00000000, 0x080c24a0,
+	0x080c2200, 0x080c2200, 0x07800007, 0x040011c7, 0x07c00007,
+	0x07800147, 0x0c013400, 0x07c00447, 0x0c7fb080, 0x00000000,
+	0x0a60c0e0, 0x06800007, 0x0fc011c0, 0x07c01707, 0x080c2802,
+	0x064c2807, 0x0a2fc047, 0x058011c7, 0x068003c8, 0x024071c8,
+	0x07800188, 0x09444207, 0x07c01388, 0x07800148, 0x0a644048,
+	0x080c2800, 0x0fc021c0, 0x0b61c087, 0x07800109, 0x024091c9,
+	0x0b620089, 0x04401249, 0x0c780180, 0x06800049, 0x020091c9,
+	0x0b20c809, 0x04401249, 0x068007c9, 0x07c00109, 0x0c011a80,
+	0x040001c9, 0x07801388, 0x060c2b08, 0x07801c07, 0x0a60c007,
+	0x0c7806c0, 0x06800009, 0x0aa10008, 0x080c2800, 0x0fc011c0,
+	0x07c01cc7, 0x07800148, 0x0aa14088, 0x06800009, 0x0aa0c148,
+	0x07800489, 0x0fc01240, 0x07c01d09, 0x0aa38009, 0x0aa34148,
+	0x0aa201c8, 0x00000000, 0x0fc011c0, 0x07c01d47, 0x0fc011c0,
+	0x07c01d87, 0x0a618188, 0x00000000, 0x0fc011c0, 0x07c01dc7,
+	0x0fc011c0, 0x07c01e07, 0x07800148, 0x09501209, 0x07801709,
+	0x09521209, 0x060c2108, 0x07801cc8, 0x05405208, 0x060c2c08,
+	0x06880008, 0x07801989, 0x0aa0c049, 0x07800507, 0x098083c8,
+	0x09581207, 0x060e0508, 0x06800009, 0x07800bc8, 0x09541248,
+	0x060c2a09, 0x064c2408, 0x0befc3c8, 0x078003c8, 0x0a6fc008,
+	0x00000000, 0x080c0080, 0x0aa080a0, 0x0c7812c0, 0x080c2110,
+	0x07800147, 0x0aa38147, 0x078004c7, 0x07c00387, 0x07800487,
+	0x07c00247, 0x07801107, 0x07c01787, 0x06800107, 0x07c003c7,
+	0x08030580, 0x064c2407, 0x0befc3c7, 0x0c780b80, 0x080c2130,
+	0x064c2407, 0x0befc3c7, 0x078004c8, 0x080e1401, 0x080c2440,
+	0x064e1507, 0x0aa400c8, 0x0aa54088, 0x060c2207, 0x07800487,
+	0x0aa28007, 0x07801107, 0x064e1508, 0x060c2208, 0x07801c48,
+	0x094411c8, 0x068010c8, 0x09503207, 0x0c780440, 0x060c2108,
+	0x0c7803c0, 0x080c2141, 0x080c2200, 0x080c2200, 0x080c2200,
+	0x080c2200, 0x0c780240, 0x080c2141, 0x064e1507, 0x060c2207,
+	0x064e1507, 0x060c2207, 0x064e1507, 0x060c2207, 0x080c2147,
+	0x078004c7, 0x07c00387, 0x07800487, 0x07c00247, 0x07801107,
+	0x07c01787, 0x06800107, 0x07c003c7, 0x08030580, 0x064c2407,
+	0x0befc3c7, 0x00000000, 0x07800147, 0x0aa10147, 0x0c013c40,
+	0x00000000, 0x0c7800c0, 0x0c016280, 0x00000000, 0x07800007,
+	0x040011c7, 0x0c7f87c0, 0x07c00007, 0x07801fcb, 0x0aa1400b,
+	0x078005c9, 0x0b60c089, 0x0c000e40, 0x00000000, 0x068fdfca,
 	0x06feffca, 0x064e0408, 0x02808288, 0x078005ca, 0x0ba0c08a,
 	0x064c0909, 0x098083c8, 0x0ac0424a, 0x0780000a, 0x0a60c00a,
 	0x0400128a, 0x09808388, 0x0b80324a, 0x00000000, 0x098081c8,
-	0x07808007, 0x09605207, 0x07800007, 0x06808049, 0x02007247,
-	0x070001c7, 0x096a5207, 0x060e0408, 0x091e1248, 0x07c01fc9,
-	0x07801388, 0x060c2b08, 0x06880008, 0x098083c8, 0x07800507,
-	0x07801989, 0x0a610049, 0x09581207, 0x09808408, 0x098083c8,
-	0x060e0508, 0x06800009, 0x07800bc8, 0x09541248, 0x060c2a09,
-	0x07801c07, 0x0aa1c007, 0x080c2c03, 0x0fc011c0, 0x07c01cc7,
-	0x068000c9, 0x094a1247, 0x060c2c09, 0x0c01d500, 0x00000000,
-	0x080c0080, 0x0c015cc0, 0x00000000, 0x080c24a0, 0x080c2200,
-	0x080c2200, 0x07800007, 0x040011c7, 0x07c00007, 0x07800147,
-	0x0c013240, 0x07c00447, 0x0c7fb0c0, 0x00000000, 0x0a60c0e0,
-	0x06800007, 0x0fc011c0, 0x07c01707, 0x080c2802, 0x064c2807,
-	0x0a2fc047, 0x058011c7, 0x068003c8, 0x024071c8, 0x07800188,
-	0x09444207, 0x07c01388, 0x07800148, 0x0a644048, 0x080c2800,
-	0x0fc021c0, 0x0b61c087, 0x07800109, 0x024091c9, 0x0b620089,
-	0x04401249, 0x0c780180, 0x06800049, 0x020091c9, 0x0b20c809,
-	0x04401249, 0x068007c9, 0x07c00109, 0x0c0118c0, 0x040001c9,
-	0x07801388, 0x060c2b08, 0x07801c07, 0x0a60c007, 0x0c7806c0,
-	0x06800009, 0x0aa10008, 0x080c2800, 0x0fc011c0, 0x07c01cc7,
-	0x07800148, 0x0aa14088, 0x06800009, 0x0aa0c148, 0x07800489,
-	0x0fc01240, 0x07c01d09, 0x0aa38009, 0x0aa34148, 0x0aa201c8,
-	0x00000000, 0x0fc011c0, 0x07c01d47, 0x0fc011c0, 0x07c01d87,
-	0x0a618188, 0x00000000, 0x0fc011c0, 0x07c01dc7, 0x0fc011c0,
-	0x07c01e07, 0x07800148, 0x09501209, 0x07801709, 0x09521209,
-	0x060c2108, 0x07801cc8, 0x05405208, 0x060c2c08, 0x06880008,
-	0x07801989, 0x0aa0c049, 0x07800507, 0x098083c8, 0x09581207,
-	0x060e0508, 0x06800009, 0x07800bc8, 0x09541248, 0x060c2a09,
-	0x064c2408, 0x0befc3c8, 0x078003c8, 0x0a6fc008, 0x00000000,
-	0x080c0080, 0x0aa080a0, 0x0c7812c0, 0x080c2110, 0x07800147,
-	0x0aa38147, 0x078004c7, 0x07c00387, 0x07800487, 0x07c00247,
-	0x07801107, 0x07c01787, 0x06800107, 0x07c003c7, 0x08030580,
-	0x064c2407, 0x0befc3c7, 0x0c780b80, 0x080c2130, 0x064c2407,
-	0x0befc3c7, 0x078004c8, 0x080e1401, 0x080c2440, 0x064e1507,
-	0x0aa400c8, 0x0aa54088, 0x060c2207, 0x07800487, 0x0aa28007,
-	0x07801107, 0x064e1508, 0x060c2208, 0x07801c48, 0x094411c8,
-	0x068010c8, 0x09503207, 0x0c780440, 0x060c2108, 0x0c7803c0,
-	0x080c2141, 0x080c2200, 0x080c2200, 0x080c2200, 0x080c2200,
-	0x0c780240, 0x080c2141, 0x064e1507, 0x060c2207, 0x064e1507,
-	0x060c2207, 0x064e1507, 0x060c2207, 0x080c2147, 0x078004c7,
-	0x07c00387, 0x07800487, 0x07c00247, 0x07801107, 0x07c01787,
-	0x06800107, 0x07c003c7, 0x08030580, 0x064c2407, 0x0befc3c7,
-	0x00000000, 0x07800147, 0x0aa10147, 0x0c013a80, 0x00000000,
-	0x0c7800c0, 0x0c0160c0, 0x00000000, 0x07800007, 0x040011c7,
-	0x0c7f8800, 0x07c00007, 0x07801fcb, 0x0aa1400b, 0x078005c9,
-	0x0b60c089, 0x0c000e40, 0x00000000, 0x068fdfca, 0x06feffca,
-	0x064e0408, 0x02808288, 0x078005ca, 0x0ba0c08a, 0x064c0909,
-	0x098083c8, 0x0ac0424a, 0x0780000a, 0x0a60c00a, 0x0400128a,
-	0x09808388, 0x0b80324a, 0x00000000, 0x098081c8, 0x060e0408,
-	0x091e1248, 0x07c01fc9, 0x0c01a200, 0x00000000, 0x064c2407,
-	0x0befc3c7, 0x078003c7, 0x0a6fc007, 0x00000000, 0x080c2130,
-	0x080c2800, 0x064c2408, 0x0befc3c8, 0x0c012f40, 0x00000000,
-	0x07800007, 0x040011c7, 0x07c00007, 0x07801d08, 0x07801d47,
-	0x09421207, 0x07801d87, 0x09441207, 0x07c00308, 0x07800148,
-	0x0aa0c348, 0x07c00448, 0x0c7f7b00, 0x078003c7, 0x0a6fc007,
-	0x00000000, 0x080c24e0, 0x064c2207, 0x064c2208, 0x080c24c0,
-	0x060c2207, 0x0c7f8280, 0x060c2208, 0x0780044b, 0x0aa3834b,
-	0x00000000, 0x069fffc9, 0x04401249, 0x0aa1c009, 0x00000000,
-	0x064e160b, 0x090102cb, 0x0aaec00b, 0x0c780140, 0x00000000,
-	0x0809d501, 0x0c7fffc0, 0x00000000, 0x0681000b, 0x060e090b,
-	0x060e0a0b, 0x0cc00000, 0x060e0b0b, 0x064e0009, 0x064e0e0b,
-	0x064e0c0c, 0x083f0040, 0x083f0000, 0x0680020d, 0x0d00000d,
-	0x00000000, 0x060e0009, 0x060e0e0b, 0x0cc00000, 0x060e0c0c,
-	0x0683ffc9, 0x0aa18009, 0x0649470a, 0x0910828a, 0x07800008,
-	0x0a4fc20a, 0x04401249, 0x0cc00000, 0x00000000, 0x0c07fac0,
-	0x00000000, 0x06490b09, 0x09809009, 0x09809089, 0x06090b09,
-	0x09c09009, 0x09c09089, 0x06090b09, 0x08095007, 0x08095000,
-	0x0683ffc9, 0x06498f0a, 0x0aa0c009, 0x0a6f800a, 0x04401249,
-	0x06498e0a, 0x0980a00a, 0x068007c9, 0x09705289, 0x06098e0a,
-	0x06800009, 0x09705289, 0x09c0a00a, 0x06098e0a, 0x0681f409,
-	0x04601249, 0x0c4fffc0, 0x00000000, 0x0cc00000, 0x00000000,
-	0x0a241007, 0x0c07f5c0, 0x00000000, 0x064c000a, 0x09c0a18a,
-	0x0980a20a, 0x0980a00a, 0x060c000a, 0x064c080a, 0x0980a34a,
-	0x060c080a, 0x0c07f580, 0x00000000, 0x080e1600, 0x0680000a,
-	0x07c003ca, 0x0fc081c0, 0x0b2247c7, 0x0b230bc7, 0x0aa22c87,
-	0x0a60ad87, 0x0c783180, 0x0a60ec47, 0x06800047, 0x07c001c7,
-	0x0c789e00, 0x0c789dc0, 0x0c789d80, 0x00000000, 0x00000000,
-	0x0fc0a1c0, 0x06800048, 0x0a210047, 0x06800047, 0x0fc041c0,
-	0x0fc03200, 0x07c01807, 0x07c01848, 0x0fc041c0, 0x0609c507,
-	0x0a6103c7, 0x07c01887, 0x0fc101c0, 0x0609c507, 0x0fc011c0,
-	0x0aa30007, 0x00000000, 0x0fc021c0, 0x07c018c7, 0x0fc021c0,
-	0x0a21c047, 0x00000000, 0x0fc101c0, 0x0fc101c0, 0x0fc101c0,
-	0x0fc0f1c0, 0x0fc101c0, 0x0fc021c0, 0x0aa0c007, 0x0c7f5dc0,
-	0x00000000, 0x0fc011c0, 0x0fc101c0, 0x07c01907, 0x0649c308,
-	0x09410207, 0x0609c308, 0x0b220087, 0x06800048, 0x06800008,
-	0x06800049, 0x0b004247, 0x05401249, 0x0c7fff80, 0x04001208,
-	0x07c01408, 0x0fc021c0, 0x0a21c047, 0x07801407, 0x0f8001c7,
-	0x07c01447, 0x0649c309, 0x09610247, 0x0609c309, 0x0fc011c0,
-	0x0fc0d1c0, 0x0fc01240, 0x0fc0d200, 0x0fc01240, 0x0401f287,
-	0x0580528a, 0x0403e247, 0x05806249, 0x09610289, 0x0649c709,
-	0x09610247, 0x0609c709, 0x0400f1c7, 0x058041c7, 0x060c0907,
-	0x07c00987, 0x04401247, 0x07c00609, 0x05404287, 0x0649c707,
-	0x094101c8, 0x0609c707, 0x0400f208, 0x05804208, 0x07c009c8,
-	0x05404208, 0x0961020a, 0x06090808, 0x0fc011c0, 0x07c01c07,
-	0x06800007, 0x07c01d07, 0x060c0307, 0x0fc011c0, 0x0aa14007,
-	0x07801807, 0x0a610047, 0x0c780100, 0x0fc011c0, 0x0c7fefc0,
-	0x0fc021c0, 0x07c01947, 0x0aa10007, 0x0a6f0087, 0x00000000,
-	0x0fc091c0, 0x07c01e47, 0x0fc011c0, 0x0a6dc007, 0x0fc011c0,
-	0x0a608007, 0x0c780c80, 0x07c01987, 0x06800008, 0x0fc011c0,
-	0x0aa58007, 0x00000000, 0x06490907, 0x0befc047, 0x06801007,
-	0x0fc08240, 0x0aa20009, 0x044011c7, 0x0fc08280, 0x0aa1c00a,
-	0x09508289, 0x0d07fe87, 0x060e020a, 0x0c780200, 0x0c7800c0,
-	0x0950828a, 0x09408289, 0x040011c7, 0x058011c7, 0x0d000007,
-	0x060e020a, 0x04c10208, 0x0fc011c0, 0x0aa58007, 0x06801007,
-	0x06490907, 0x0befc047, 0x06801007, 0x0fc08240, 0x0aa20009,
-	0x044011c7, 0x0fc08280, 0x0aa1c00a, 0x09508289, 0x0d07fe87,
-	0x060e030a, 0x0c780200, 0x0c7800c0, 0x0950828a, 0x09408289,
-	0x040011c7, 0x058011c7, 0x0d000007, 0x060e030a, 0x04c08208,
-	0x060e0008, 0x07801807, 0x0aa18047, 0x00000000, 0x0fc011c0,
-	0x0540b1c7, 0x09807007, 0x060c0107, 0x0fc011c0, 0x0aa60007,
-	0x0fc011c0, 0x07c00347, 0x0aa0c047, 0x0c0160c0, 0x00000000,
-	0x0fc011c0, 0x0a20c047, 0x00000000, 0x0fc011c0, 0x07801807,
-	0x06800008, 0x0aa18047, 0x06800007, 0x0fc011c0, 0x0a624007,
-	0x0fc01200, 0x0a61c008, 0x07c01a07, 0x07c01a48, 0x0fc011c0,
-	0x046011c7, 0x0c57e900, 0x0c786e00, 0x0c7fd840, 0x064c5126,
-	0x064c4627, 0x07800708, 0x05410208, 0x078006c9, 0x02008248,
-	0x0580a208, 0x0e000988, 0x00000000, 0x00000000, 0x00000000,
-	0x0f000200, 0x0f010980, 0x09708226, 0x0540a208, 0x020089c8,
-	0x064c4326, 0x02408988, 0x064c4026, 0x02408988, 0x07c00b48,
-	0x05810208, 0x07c00b88, 0x06800007, 0x07c00007, 0x07c01707,
-	0x07c00507, 0x07c016c7, 0x06800047, 0x07c00587, 0x07800607,
-	0x040021c7, 0x07c005c7, 0x0fc02800, 0x06800023, 0x06800024,
-	0x0aa1c0a0, 0x068ae008, 0x068ac008, 0x0a60c0e0, 0x06800009,
-	0x06800049, 0x07c01bc9, 0x07c00288, 0x06800008, 0x0fc011c0,
-	0x0aa0c007, 0x0c7fff80, 0x04001208, 0x07c01a88, 0x0fc011c0,
-	0x07801409, 0x0a66c009, 0x00000000, 0x064c2a0a, 0x064c360b,
-	0x0901028a, 0x0540828a, 0x058082cb, 0x0940828b, 0x06800009,
-	0x0ae483c9, 0x0540128a, 0x0aa18060, 0x04001249, 0x092652ca,
-	0x0481f2cb, 0x0aa1860b, 0x0c7ffe40, 0x092462ca, 0x048372cb,
-	0x0aa08c0b, 0x0c7ffd40, 0x0649ce07, 0x0683e908, 0x0a403207,
-	0x0bac43c9, 0x00000000, 0x07c01409, 0x0f8001c9, 0x07c01ac7,
-	0x0a6240a0, 0x07801088, 0x0b814207, 0x02407207, 0x07801908,
-	0x0c780440, 0x02407207, 0x0c7fc200, 0x00000000, 0x07801a88,
-	0x0ae14048, 0x0aa10008, 0x07801088, 0x07801909, 0x02007247,
-	0x02407207, 0x07801ac8, 0x07c01088, 0x06800008, 0x07c01008,
-	0x0c780540, 0x07c010c7, 0x07801008, 0x04001208, 0x0ae44048,
-	0x07c01008, 0x078010c9, 0x02007247, 0x0b21c007, 0x0b406247,
-	0x0b406247, 0x00000000, 0x024091c9, 0x0c7fff40, 0x04080208,
-	0x0c7f18c0, 0x058011c7, 0x0b403247, 0x00000000, 0x04080208,
-	0x07c01008, 0x090071c8, 0x090e7208, 0x09545207, 0x060e0708,
-	0x07800047, 0x0b624087, 0x0aa180a0, 0x0aa08020, 0x0aa10007,
-	0x040011c7, 0x0c780100, 0x07c00047, 0x0c784c00, 0x00000000,
-	0x0fc011c0, 0x0fc011c0, 0x0a620007, 0x078013c8, 0x0aa0c088,
-	0x07800fc8, 0x04001208, 0x07c00fc8, 0x0c784980, 0x00000000,
-	0x07c013e0, 0x0aa0c0e0, 0x0a60c060, 0x06800007, 0x0fc011c0,
-	0x07c01b07, 0x0fc031c0, 0x07c000c7, 0x07801c07, 0x0aa20007,
-	0x00000000, 0x0fc011c0, 0x07c01c47, 0x0fc011c0, 0x07c01c87,
-	0x054021c7, 0x060c0307, 0x0a6740e0, 0x07801e47, 0x0aa6c007,
-	0x09066207, 0x0aa08088, 0x0c7fae00, 0x0c00a780, 0x06801ec8,
-	0x07901ee3, 0x06801409, 0x09510263, 0x060c2109, 0x0c00a600,
-	0x06801f08, 0x07901f08, 0x06801809, 0x09510248, 0x060c2109,
-	0x096108c8, 0x0c00a440, 0x06801f48, 0x0c00a3c0, 0x06801f88,
-	0x05401923, 0x09c24424, 0x0942f923, 0x0a20c047, 0x0c7fa880,
-	0x00000000, 0x0fc051c0, 0x0c006f00, 0x07c00107, 0x0c006c40,
-	0x00000000, 0x0a6180a0, 0x078003c7, 0x0a6fc007, 0x06800107,
-	0x07c003c7, 0x08030580, 0x0aa28020, 0x06800048, 0x0a6100a0,
-	0x0fc03200, 0x0fc03240, 0x07c01b89, 0x07c01b48, 0x09503248,
-	0x09809149, 0x060c2109, 0x060c0e08, 0x06800025, 0x06490908,
-	0x0ae10225, 0x00000000, 0x0bef4048, 0x0c780080, 0x0c7efe80,
-	0x0683ffc7, 0x0649bb08, 0x0900c208, 0x0aa10008, 0x0aa0c007,
-	0x0c7fff00, 0x044011c7, 0x06490b07, 0x09807007, 0x06090b07,
-	0x06090b07, 0x09c07007, 0x06090b07, 0x0649c909, 0x0aa10009,
-	0x06800087, 0x0c7ef440, 0x07c01507, 0x07801487, 0x0a608007,
-	0x0c780b00, 0x044011c7, 0x0aa0c087, 0x07801549, 0x078015c9,
-	0x0b20c1c9, 0x00000000, 0x0c780940, 0x07800fc8, 0x0609ca08,
+	0x060e0408, 0x091e1248, 0x07c01fc9, 0x0c01a3c0, 0x00000000,
+	0x064c2407, 0x0befc3c7, 0x078003c7, 0x0a6fc007, 0x00000000,
+	0x080c2130, 0x080c2800, 0x064c2408, 0x0befc3c8, 0x0c013100,
+	0x00000000, 0x07800007, 0x040011c7, 0x07c00007, 0x07801d08,
+	0x07801d47, 0x09421207, 0x07801d87, 0x09441207, 0x07c00308,
+	0x07800148, 0x0aa0c348, 0x07c00448, 0x0c7f7ac0, 0x078003c7,
+	0x0a6fc007, 0x00000000, 0x080c24e0, 0x064c2207, 0x064c2208,
+	0x080c24c0, 0x060c2207, 0x0c7f8240, 0x060c2208, 0x0780044b,
+	0x0aa3834b, 0x00000000, 0x069fffc9, 0x04401249, 0x0aa1c009,
+	0x00000000, 0x064e160b, 0x090102cb, 0x0aaec00b, 0x0c780140,
+	0x00000000, 0x0809d501, 0x0c7fffc0, 0x00000000, 0x0681000b,
+	0x060e090b, 0x060e0a0b, 0x0cc00000, 0x060e0b0b, 0x064e0009,
+	0x064e0e0b, 0x064e0c0c, 0x083f0040, 0x083f0000, 0x0680020d,
+	0x0d00000d, 0x00000000, 0x060e0009, 0x060e0e0b, 0x0cc00000,
+	0x060e0c0c, 0x0683ffc9, 0x0aa18009, 0x0649470a, 0x0910828a,
+	0x07800008, 0x0a4fc20a, 0x04401249, 0x0cc00000, 0x00000000,
+	0x0c07fac0, 0x00000000, 0x06490b09, 0x09809009, 0x09809089,
+	0x06090b09, 0x09c09009, 0x09c09089, 0x06090b09, 0x08095007,
+	0x08095000, 0x0683ffc9, 0x06498f0a, 0x0aa0c009, 0x0a6f800a,
+	0x04401249, 0x06498e0a, 0x0980a00a, 0x068007c9, 0x09705289,
+	0x06098e0a, 0x06800009, 0x09705289, 0x09c0a00a, 0x06098e0a,
+	0x0681f409, 0x04601249, 0x0c4fffc0, 0x00000000, 0x0cc00000,
+	0x00000000, 0x0a241007, 0x0c07f5c0, 0x00000000, 0x064c000a,
+	0x09c0a18a, 0x0980a20a, 0x0980a00a, 0x060c000a, 0x064c080a,
+	0x0980a34a, 0x060c080a, 0x0c07f580, 0x00000000, 0x080e1600,
+	0x0680000a, 0x07c003ca, 0x0fc081c0, 0x0b2247c7, 0x0b230bc7,
+	0x0aa22c87, 0x0a60ad87, 0x0c783180, 0x0a60ec47, 0x06800047,
+	0x07c001c7, 0x0c789fc0, 0x0c789f80, 0x0c789f40, 0x00000000,
+	0x00000000, 0x0fc0a1c0, 0x06800048, 0x0a210047, 0x06800047,
+	0x0fc041c0, 0x0fc03200, 0x07c01807, 0x07c01848, 0x0fc041c0,
+	0x0609c507, 0x0a6103c7, 0x07c01887, 0x0fc101c0, 0x0609c507,
+	0x0fc011c0, 0x0aa30007, 0x00000000, 0x0fc021c0, 0x07c018c7,
+	0x0fc021c0, 0x0a21c047, 0x00000000, 0x0fc101c0, 0x0fc101c0,
+	0x0fc101c0, 0x0fc0f1c0, 0x0fc101c0, 0x0fc021c0, 0x0aa0c007,
+	0x0c7f5d80, 0x00000000, 0x0fc011c0, 0x0fc101c0, 0x07c01907,
+	0x0649c308, 0x09410207, 0x0609c308, 0x0b220087, 0x06800048,
+	0x06800008, 0x06800049, 0x0b004247, 0x05401249, 0x0c7fff80,
+	0x04001208, 0x07c01408, 0x0fc021c0, 0x0a21c047, 0x07801407,
+	0x0f8001c7, 0x07c01447, 0x0649c309, 0x09610247, 0x0609c309,
+	0x0fc011c0, 0x0fc0d1c0, 0x0fc01240, 0x0fc0d200, 0x0fc01240,
+	0x0401f287, 0x0580528a, 0x0403e247, 0x05806249, 0x09610289,
+	0x0649c709, 0x09610247, 0x0609c709, 0x0400f1c7, 0x058041c7,
+	0x060c0907, 0x07c00987, 0x04401247, 0x07c00609, 0x05404287,
+	0x0649c707, 0x094101c8, 0x0609c707, 0x0400f208, 0x05804208,
+	0x07c009c8, 0x05404208, 0x0961020a, 0x06090808, 0x0fc011c0,
+	0x07c01c07, 0x06800007, 0x07c01d07, 0x060c0307, 0x0fc011c0,
+	0x0aa14007, 0x07801807, 0x0a610047, 0x0c780100, 0x0fc011c0,
+	0x0c7fefc0, 0x0fc021c0, 0x07c01947, 0x0aa10007, 0x0a6f0087,
+	0x00000000, 0x0fc091c0, 0x07c01e47, 0x0fc011c0, 0x0a6dc007,
+	0x0fc011c0, 0x0a608007, 0x0c780c80, 0x07c01987, 0x06800008,
+	0x0fc011c0, 0x0aa58007, 0x00000000, 0x06490907, 0x0befc047,
+	0x06801007, 0x0fc08240, 0x0aa20009, 0x044011c7, 0x0fc08280,
+	0x0aa1c00a, 0x09508289, 0x0d07fe87, 0x060e020a, 0x0c780200,
+	0x0c7800c0, 0x0950828a, 0x09408289, 0x040011c7, 0x058011c7,
+	0x0d000007, 0x060e020a, 0x04c10208, 0x0fc011c0, 0x0aa58007,
+	0x06801007, 0x06490907, 0x0befc047, 0x06801007, 0x0fc08240,
+	0x0aa20009, 0x044011c7, 0x0fc08280, 0x0aa1c00a, 0x09508289,
+	0x0d07fe87, 0x060e030a, 0x0c780200, 0x0c7800c0, 0x0950828a,
+	0x09408289, 0x040011c7, 0x058011c7, 0x0d000007, 0x060e030a,
+	0x04c08208, 0x060e0008, 0x07801807, 0x0aa18047, 0x00000000,
+	0x0fc011c0, 0x0540b1c7, 0x09807007, 0x060c0107, 0x0fc011c0,
+	0x0aa60007, 0x0fc011c0, 0x07c00347, 0x0aa0c047, 0x0c016280,
+	0x00000000, 0x0fc011c0, 0x0a20c047, 0x00000000, 0x0fc011c0,
+	0x07801807, 0x06800008, 0x0aa18047, 0x06800007, 0x0fc011c0,
+	0x0a624007, 0x0fc01200, 0x0a61c008, 0x07c01a07, 0x07c01a48,
+	0x0fc011c0, 0x046011c7, 0x0c57e900, 0x0c786fc0, 0x0c7fd840,
+	0x064c5126, 0x064c4627, 0x07800708, 0x05410208, 0x078006c9,
+	0x02008248, 0x0580a208, 0x0e000988, 0x00000000, 0x00000000,
+	0x00000000, 0x0f000200, 0x0f010980, 0x09708226, 0x0540a208,
+	0x020089c8, 0x064c4326, 0x02408988, 0x064c4026, 0x02408988,
+	0x07c00b48, 0x05810208, 0x07c00b88, 0x06800007, 0x07c00007,
+	0x07c01707, 0x07c00507, 0x07c016c7, 0x06800047, 0x07c00587,
+	0x07800607, 0x040021c7, 0x07c005c7, 0x0fc02800, 0x06800023,
+	0x06800024, 0x0aa1c0a0, 0x068ae008, 0x068ac008, 0x0a60c0e0,
+	0x06800009, 0x06800049, 0x07c01bc9, 0x07c00288, 0x06800008,
+	0x0fc011c0, 0x0aa0c007, 0x0c7fff80, 0x04001208, 0x07c01a88,
+	0x0fc011c0, 0x07801409, 0x0a66c009, 0x00000000, 0x064c2a0a,
+	0x064c360b, 0x0901028a, 0x0540828a, 0x058082cb, 0x0940828b,
+	0x06800009, 0x0ae483c9, 0x0540128a, 0x0aa18060, 0x04001249,
+	0x092652ca, 0x0481f2cb, 0x0aa1860b, 0x0c7ffe40, 0x092462ca,
+	0x048372cb, 0x0aa08c0b, 0x0c7ffd40, 0x0649ce07, 0x0683e908,
+	0x0a403207, 0x0bac43c9, 0x00000000, 0x07c01409, 0x0f8001c9,
+	0x07c01ac7, 0x0a6240a0, 0x07801088, 0x0b814207, 0x02407207,
+	0x07801908, 0x0c780440, 0x02407207, 0x0c7fc200, 0x00000000,
+	0x07801a88, 0x0ae14048, 0x0aa10008, 0x07801088, 0x07801909,
+	0x02007247, 0x02407207, 0x07801ac8, 0x07c01088, 0x06800008,
+	0x07c01008, 0x0c780540, 0x07c010c7, 0x07801008, 0x04001208,
+	0x0ae44048, 0x07c01008, 0x078010c9, 0x02007247, 0x0b21c007,
+	0x0b406247, 0x0b406247, 0x00000000, 0x024091c9, 0x0c7fff40,
+	0x04080208, 0x0c7f1880, 0x058011c7, 0x0b403247, 0x00000000,
+	0x04080208, 0x07c01008, 0x090071c8, 0x090e7208, 0x09545207,
+	0x060e0708, 0x07800047, 0x0b624087, 0x0aa180a0, 0x0aa08020,
+	0x0aa10007, 0x040011c7, 0x0c780100, 0x07c00047, 0x0c784dc0,
+	0x00000000, 0x0fc011c0, 0x0fc011c0, 0x0a620007, 0x078013c8,
+	0x0aa0c088, 0x07800fc8, 0x04001208, 0x07c00fc8, 0x0c784b40,
+	0x00000000, 0x07c013e0, 0x0aa0c0e0, 0x0a60c060, 0x06800007,
+	0x0fc011c0, 0x07c01b07, 0x0fc031c0, 0x07c000c7, 0x07801c07,
+	0x0aa20007, 0x00000000, 0x0fc011c0, 0x07c01c47, 0x0fc011c0,
+	0x07c01c87, 0x054021c7, 0x060c0307, 0x0a6740e0, 0x07801e47,
+	0x0aa6c007, 0x09066207, 0x0aa08088, 0x0c7fae00, 0x0c00a940,
+	0x06801ec8, 0x07901ee3, 0x06801409, 0x09510263, 0x060c2109,
+	0x0c00a7c0, 0x06801f08, 0x07901f08, 0x06801809, 0x09510248,
+	0x060c2109, 0x096108c8, 0x0c00a600, 0x06801f48, 0x0c00a580,
+	0x06801f88, 0x05401923, 0x09c24424, 0x0942f923, 0x0a20c047,
+	0x0c7fa880, 0x00000000, 0x0fc051c0, 0x0c0070c0, 0x07c00107,
+	0x0c006e00, 0x00000000, 0x0a6180a0, 0x078003c7, 0x0a6fc007,
+	0x06800107, 0x07c003c7, 0x08030580, 0x0aa28020, 0x06800048,
+	0x0a6100a0, 0x0fc03200, 0x0fc03240, 0x07c01b89, 0x07c01b48,
+	0x09503248, 0x09809149, 0x060c2109, 0x060c0e08, 0x06800025,
+	0x06490908, 0x0ae10225, 0x00000000, 0x0bef4048, 0x0c780080,
+	0x0c7efe40, 0x0683ffc7, 0x0649bb08, 0x0900c208, 0x0aa10008,
+	0x0aa0c007, 0x0c7fff00, 0x044011c7, 0x06490b07, 0x09807007,
+	0x06090b07, 0x06090b07, 0x09c07007, 0x06090b07, 0x0649c909,
+	0x0aa10009, 0x06800087, 0x0c7ef400, 0x07c01507, 0x07800047,
+	0x0ae0c047, 0x078001c7, 0x0aa20047, 0x07801487, 0x0a608007,
+	0x0c780bc0, 0x044011c7, 0x0aa0c087, 0x07801549, 0x078015c9,
+	0x0b20c1c9, 0x00000000, 0x0c780a00, 0x07800fc8, 0x0609ca08,
 	0x07c00fdf, 0x0680420a, 0x02007289, 0x070001c7, 0x054101c7,
 	0x0680400a, 0x02008289, 0x07000208, 0x094101c8, 0x0609cc07,
 	0x0680444a, 0x02007289, 0x070001c7, 0x0609cb07, 0x06804a4a,
 	0x02008289, 0x07000208, 0x09464248, 0x07801c08, 0x094e1248,
 	0x09809209, 0x0609c909, 0x08007401, 0x06800009, 0x07c01489,
-	0x078001c9, 0x0aa20009, 0x0ae00049, 0x06800089, 0x07c001c9,
-	0x0649c909, 0x0a6fc009, 0x0c7ff780, 0x07801589, 0x06800009,
-	0x07c01509, 0x078014c7, 0x02c07247, 0x0780464a, 0x07804688,
-	0x09610288, 0x0be0c047, 0x0c780a80, 0x06800008, 0x078046ca,
-	0x07804708, 0x09610288, 0x0be0c087, 0x0c780900, 0x06800048,
-	0x0780474a, 0x07804788, 0x09610288, 0x0a27c107, 0x06800088,
-	0x078047ca, 0x07804808, 0x09610288, 0x0a268207, 0x068000c8,
-	0x0780484a, 0x07804888, 0x09610288, 0x0a254407, 0x06800108,
-	0x078048ca, 0x07804908, 0x09610288, 0x0a240807, 0x06800148,
-	0x0780494a, 0x07804988, 0x09610288, 0x0a22d007, 0x06800188,
-	0x078049ca, 0x07804a08, 0x09610288, 0x0a21a007, 0x068001c8,
-	0x0809cd11, 0x06800047, 0x0c7edc40, 0x07c01507, 0x0809cd00,
-	0x07801607, 0x090041c7, 0x0a8051c8, 0x0a6200a0, 0x07801607,
-	0x090841c7, 0x0a4051c8, 0x06800047, 0x03407207, 0x0c7ff180,
-	0x02c091c9, 0x07800b47, 0x0680400f, 0x020093c8, 0x07400247,
-	0x07800b87, 0x04008249, 0x07400247, 0x0680444f, 0x020073c8,
-	0x07801ac9, 0x074001c9, 0x07801c47, 0x054031c7, 0x02c07807,
-	0x06804a4f, 0x020093c8, 0x07400247, 0x06800047, 0x03407207,
-	0x078014c9, 0x02c091c9, 0x07c014c9, 0x0609b20a, 0x04001260,
-	0x07c01489, 0x0a6080a0, 0x0c780340, 0x07801587, 0x07c015c7,
-	0x07c01588, 0x06499109, 0x06099009, 0x07801609, 0x05404249,
-	0x09404248, 0x07c01609, 0x0609910a, 0x0c7800c0, 0x00000000,
-	0x07c01548, 0x08098002, 0x07801c07, 0x0aa64047, 0x00000000,
-	0x07801d07, 0x0aa58047, 0x00000000, 0x06499008, 0x05410208,
-	0x058103c8, 0x02c083c8, 0x06098108, 0x06499108, 0x05410208,
-	0x058103c8, 0x02c083c8, 0x06098208, 0x080980f0, 0x07801c07,
-	0x0aa6c007, 0x00000000, 0x07801d07, 0x0aa60007, 0x00000000,
-	0x080980f4, 0x0c780540, 0x00000000, 0x06499008, 0x05410208,
-	0x0649b10f, 0x054103cf, 0x07801c47, 0x0a614047, 0x00000000,
-	0x05810208, 0x0c7800c0, 0x00000000, 0x058103cf, 0x02c083c8,
+	0x078001c9, 0x0aa2c009, 0x07800047, 0x0ae08047, 0x0c7fff80,
+	0x0aef4049, 0x06800089, 0x07c001c9, 0x0649c909, 0x0a6fc009,
+	0x0c7ff6c0, 0x07801589, 0x06800009, 0x07c01509, 0x078014c7,
+	0x02c07247, 0x0780464a, 0x07804688, 0x09610288, 0x0be0c047,
+	0x0c780a80, 0x06800008, 0x078046ca, 0x07804708, 0x09610288,
+	0x0be0c087, 0x0c780900, 0x06800048, 0x0780474a, 0x07804788,
+	0x09610288, 0x0a27c107, 0x06800088, 0x078047ca, 0x07804808,
+	0x09610288, 0x0a268207, 0x068000c8, 0x0780484a, 0x07804888,
+	0x09610288, 0x0a254407, 0x06800108, 0x078048ca, 0x07804908,
+	0x09610288, 0x0a240807, 0x06800148, 0x0780494a, 0x07804988,
+	0x09610288, 0x0a22d007, 0x06800188, 0x078049ca, 0x07804a08,
+	0x09610288, 0x0a21a007, 0x068001c8, 0x0809cd11, 0x06800047,
+	0x0c7eda40, 0x07c01507, 0x0809cd00, 0x07801607, 0x090041c7,
+	0x0a8051c8, 0x0a6200a0, 0x07801607, 0x090841c7, 0x0a4051c8,
+	0x06800047, 0x03407207, 0x0c7ff180, 0x02c091c9, 0x07800b47,
+	0x0680400f, 0x020093c8, 0x07400247, 0x07800b87, 0x04008249,
+	0x07400247, 0x0680444f, 0x020073c8, 0x07801ac9, 0x074001c9,
+	0x07801c47, 0x054031c7, 0x02c07807, 0x06804a4f, 0x020093c8,
+	0x07400247, 0x06800047, 0x03407207, 0x078014c9, 0x02c091c9,
+	0x07c014c9, 0x0609b20a, 0x04001260, 0x07c01489, 0x0a6080a0,
+	0x0c780340, 0x07801587, 0x07c015c7, 0x07c01588, 0x06499109,
+	0x06099009, 0x07801609, 0x05404249, 0x09404248, 0x07c01609,
+	0x0609910a, 0x0c7800c0, 0x00000000, 0x07c01548, 0x08098002,
+	0x07801c07, 0x0aa64047, 0x00000000, 0x07801d07, 0x0aa58047,
+	0x00000000, 0x06499008, 0x05410208, 0x058103c8, 0x02c083c8,
 	0x06098108, 0x06499108, 0x05410208, 0x058103c8, 0x02c083c8,
-	0x06098208, 0x080980f4, 0x07801b07, 0x06800048, 0x09421207,
-	0x0c7ed640, 0x06090708, 0x06800025, 0x0ae20225, 0x064c0007,
-	0x0a2f8047, 0x00000000, 0x064c3a07, 0x090061c7, 0x0aae8647,
-	0x0c7800c0, 0x0c7ec5c0, 0x00000000, 0x080c2800, 0x080c0002,
-	0x0c7ebec0, 0x00000000, 0x0649c007, 0x07c04647, 0x058101c7,
-	0x07c04687, 0x0649c107, 0x07c046c7, 0x058101c7, 0x07c04707,
-	0x0649c207, 0x07c04747, 0x058101c7, 0x07c04787, 0x0649c307,
-	0x07c047c7, 0x058101c7, 0x07c04807, 0x0649d007, 0x07c04847,
-	0x058101c7, 0x07c04887, 0x0649d107, 0x07c048c7, 0x058101c7,
-	0x07c04907, 0x0649d207, 0x07c04947, 0x058101c7, 0x07c04987,
-	0x0649d307, 0x07c049c7, 0x058101c7, 0x07c04a07, 0x0c004280,
-	0x06800025, 0x08002501, 0x08002605, 0x08002708, 0x08002815,
-	0x08002c14, 0x08002a09, 0x08002b17, 0x06830002, 0x06032602,
-	0x08032261, 0x08032101, 0x0cc00000, 0x00000000, 0x080c2804,
-	0x064c2807, 0x0a2fc047, 0x05801207, 0x080c2800, 0x0aa14008,
-	0x0b21004a, 0x044011ca, 0x0f8001c7, 0x094e9207, 0x0cc00000,
-	0x07400248, 0x080c2804, 0x064c2807, 0x0a2fc047, 0x05801207,
-	0x0cc00000, 0x07400248, 0x0fc011c0, 0x0a608007, 0x0c780ec0,
-	0x06800247, 0x07c00147, 0x07800488, 0x095011c8, 0x060c2107,
-	0x080e1401, 0x080c2440, 0x064e1507, 0x078004c8, 0x0aa400c8,
-	0x0aa54088, 0x060c2207, 0x07800487, 0x0aa28007, 0x07801107,
-	0x064e1508, 0x060c2208, 0x07801c48, 0x094411c8, 0x068010c8,
-	0x09503207, 0x0c780440, 0x060c2108, 0x0c7803c0, 0x080c2141,
-	0x080c2200, 0x080c2200, 0x080c2200, 0x080c2200, 0x0c780240,
-	0x080c2141, 0x064e1507, 0x060c2207, 0x064e1507, 0x060c2207,
-	0x064e1507, 0x060c2207, 0x080c2147, 0x064c2407, 0x0befc3c7,
-	0x078004c7, 0x07c00387, 0x07800487, 0x07c00247, 0x07801107,
-	0x07c01787, 0x06800107, 0x07c003c7, 0x0c007900, 0x00000000,
-	0x08030580, 0x07800007, 0x040011c7, 0x07c00007, 0x06431e07,
-	0x0befc047, 0x0c7ea900, 0x00000000, 0x0fc01200, 0x0fc011c0,
-	0x0aa28047, 0x06800147, 0x0fc011c0, 0x0aa1c047, 0x06800187,
-	0x0fc011c0, 0x0aa10047, 0x068001c7, 0x0fc011c0, 0x06800207,
-	0x07c00147, 0x0a60c008, 0x06800007, 0x0fc061c0, 0x07c01387,
-	0x07800147, 0x0aa4c147, 0x07801387, 0x0aa44007, 0x00000000,
-	0x0fc011c0, 0x0aa38007, 0x07800108, 0x0fc011c0, 0x0aa14007,
-	0x0b21c748, 0x04002208, 0x0c780140, 0x068007c8, 0x0b60c0c8,
-	0x04402208, 0x06800048, 0x07c00108, 0x0c0005c0, 0x040001c8,
-	0x0c7eed00, 0x00000000, 0x06a00007, 0x06e00007, 0x080c24a0,
-	0x060c2207, 0x060c2207, 0x060c2207, 0x060c2207, 0x060c2207,
-	0x0cc00000, 0x060c2207, 0x07801988, 0x094c11c8, 0x0c07fd00,
-	0x060e0407, 0x06800007, 0x07c01cc7, 0x07c00907, 0x0cc00000,
-	0x07c00947, 0x060c0a07, 0x078000c8, 0x0aa24008, 0x06800009,
-	0x0aa1c1c8, 0x06800049, 0x05401247, 0x0400b249, 0x0b403247,
-	0x06800049, 0x06800009, 0x07c00bc9, 0x0b218107, 0x0ae08207,
-	0x0c780380, 0x0b214607, 0x0c780180, 0x00000000, 0x0c780480,
-	0x06820207, 0x0c780240, 0x00000000, 0x05401207, 0x04410208,
-	0x044061c7, 0x054081c7, 0x0c780280, 0x094081c8, 0x0c7800c0,
-	0x0c7800c0, 0x04008207, 0x05401207, 0x0400d1c7, 0x054071c7,
-	0x0c780080, 0x094081c8, 0x07c002c7, 0x06b00008, 0x064c2d09,
-	0x09610248, 0x060c2d09, 0x09610208, 0x060c2f08, 0x07801988,
-	0x094c11c8, 0x0cc00000, 0x060e0407, 0x0680000e, 0x0aa4c00f,
-	0x0ae1400f, 0x0400038f, 0x06bfffce, 0x0300e38f, 0x0400138e,
-	0x0900434e, 0x0b21408d, 0x06800007, 0x0b20c34d, 0x06800047,
-	0x06800087, 0x05c0438e, 0x0540138e, 0x0200e1ce, 0x0ae1000f,
-	0x06bfffcd, 0x0300e34e, 0x0400138e, 0x0cc00000, 0x040003ce,
-	0x07800007, 0x0ae10007, 0x07800109, 0x07800988, 0x02007207,
-	0x044011c7, 0x06808048, 0x02007207, 0x074001c9, 0x0cc00000,
-	0x07c08009, 0x0681f409, 0x04401249, 0x0aefc009, 0x00000000,
-	0x083f0040, 0x083f0000, 0x08090b65, 0x00000000, 0x08090b60,
-	0x06498e07, 0x09807007, 0x068007c9, 0x097051c9, 0x06098e07,
-	0x0681f409, 0x04601249, 0x0c4fffc0, 0x00000000, 0x06800009,
-	0x097051c9, 0x09c07007, 0x06098e07, 0x064c0007, 0x09c07187,
-	0x09807207, 0x060c0007, 0x064c0807, 0x09807347, 0x060c0807,
-	0x083f0040, 0x083f0000, 0x08090b65, 0x0cc00000, 0x08090b60,
-	0x0680001f, 0x07c0149f, 0x07c014df, 0x07c0151f, 0x064c091f,
-	0x07c0175f, 0x07c0005f, 0x06800020, 0x06803fc2, 0x07c01542,
-	0x07c01582, 0x07c015c2, 0x07c01602, 0x060c091f, 0x080c0101,
-	0x080c2901, 0x06840442, 0x060c2e02, 0x064c4027, 0x064c4226,
-	0x024269e6, 0x040089a6, 0x07c006e6, 0x058109a6, 0x07c00726,
-	0x0649cf31, 0x0809c500, 0x0649c707, 0x0aa6c007, 0x09010207,
-	0x092101c7, 0x0401f287, 0x0580528a, 0x0403e247, 0x05806249,
-	0x09610289, 0x0649c709, 0x09610247, 0x0609c709, 0x0400f1c7,
-	0x058041c7, 0x060c0907, 0x07c00987, 0x04401247, 0x07c00609,
-	0x05404287, 0x0649c707, 0x094101c8, 0x0609c707, 0x0400f208,
-	0x05804208, 0x07c009c8, 0x05404208, 0x0961020a, 0x06090808,
-	0x0809c300, 0x0809cb00, 0x0cc00000, 0x00000000, 0x0649c803,
-	0x0aa14003, 0x078014c2, 0x028020c2, 0x07c014c2, 0x0809c800,
-	0x07801502, 0x0aa0c002, 0x06800102, 0x06030502, 0x064c0002,
-	0x0be14042, 0x0ba1d025, 0x06800102, 0x07c01502, 0x08030504,
-	0x06800025, 0x0cc00000, 0x00000000, 0x078001c2, 0x0aa1c002,
-	0x078016c2, 0x078009c3, 0x0a4040c2, 0x00000000, 0x06800102,
-	0x06030502, 0x0cc00000, 0x00000000, 0x0fc02240, 0x0aa4c009,
-	0x0680000a, 0x0b6180c9, 0x0680010a, 0x0fc01280, 0x09422289,
-	0x0c780140, 0x0440128a, 0x0fc01240, 0x0a6fc009, 0x0400128a,
-	0x06800049, 0x03409289, 0x05801249, 0x0f80028a, 0x0b40424a,
-	0x05401249, 0x04401249, 0x0240a24a, 0x0740020a, 0x0cc00000,
-	0x0fc01240, 0x064c441a, 0x0912169a, 0x0aaf801a, 0x0c7e56c0,
-	0x00000000, 0x06490628, 0x0aefcc28, 0x00000000, 0x07800028,
-	0x078016e9, 0x09508a68, 0x068000a8, 0x06c00028, 0x06090628,
-	0x06090629, 0x06881068, 0x06090628, 0x0cc00000, 0x00000000,
-	0x06490628, 0x0aefcc28, 0x06c00028, 0x069001a8, 0x069fffea,
-	0x06090628, 0x06090629, 0x05401a23, 0x06090628, 0x09210a23,
-	0x05401a28, 0x02828aa8, 0x06090628, 0x06985168, 0x0c782700,
-	0x06090628, 0x078003e8, 0x0a6fc028, 0x07800028, 0x078016e9,
-	0x06800030, 0x09508a68, 0x0780016b, 0x07801d2a, 0x04601aaa,
-	0x0c500ec0, 0x0aa4802b, 0x0690002a, 0x0aa4006b, 0x0aa8c36b,
-	0x0aa883eb, 0x0aa3422b, 0x00000000, 0x06a0002a, 0x0aa281eb,
-	0x06c0002a, 0x06b0002a, 0x0aa1c1ab, 0x06c0002a, 0x04602aeb,
-	0x0c500980, 0x0690002a, 0x0c7e4f00, 0x00000000, 0x06490628,
-	0x0aefcc28, 0x068000a8, 0x02c28aa8, 0x09441a30, 0x06090628,
-	0x06090629, 0x069fffeb, 0x06900028, 0x0a00ca2a, 0x080c2400,
-	0x080e1424, 0x064c2228, 0x060e1528, 0x060e1528, 0x060e1528,
-	0x060e1528, 0x09210a68, 0x06090628, 0x02828ae9, 0x06090628,
-	0x06a00028, 0x0a007a2a, 0x080c2440, 0x064c2228, 0x09210a68,
-	0x06090628, 0x02828ae9, 0x06090628, 0x0688d068, 0x02c28aa8,
-	0x09441a30, 0x0c781780, 0x06090628, 0x09441ab0, 0x06031f2a,
-	0x0680016b, 0x09510ae9, 0x0c781600, 0x06031e2b, 0x0aa241eb,
-	0x06a0002a, 0x0aa1c1ab, 0x06b0002a, 0x0aa1416b, 0x0aa1026b,
-	0x06800070, 0x0690002a, 0x06800030, 0x06490628, 0x0aefcc28,
-	0x06c0002a, 0x068408a8, 0x02c28aa8, 0x09441a30, 0x06090628,
-	0x06090629, 0x069fffec, 0x06900028, 0x0a00ba2a, 0x080c2400,
-	0x064c222e, 0x0609062e, 0x09210a2e, 0x09c28068, 0x02828b28,
-	0x09828428, 0x07801d6d, 0x095e1a2d, 0x06090628, 0x06a00028,
-	0x0a00ba2a, 0x080c2440, 0x064c2228, 0x06090628, 0x09210a28,
-	0x09c28068, 0x02828b28, 0x09828428, 0x07801ded, 0x095e1a2d,
-	0x06090628, 0x068c5828, 0x02c28aa8, 0x09441a30, 0x06090628,
-	0x06860828, 0x02c28aa8, 0x09441a30, 0x06090628, 0x06900028,
-	0x0a00ba2a, 0x080c2410, 0x064c222f, 0x0609062f, 0x09210a2f,
-	0x09c28068, 0x02828b28, 0x09828428, 0x07801dad, 0x095e1a2d,
-	0x06090628, 0x06a00028, 0x0a00ba2a, 0x080c2450, 0x064c2228,
-	0x06090628, 0x09210a28, 0x09c28068, 0x02828b28, 0x09828428,
-	0x07801e2d, 0x095e1a2d, 0x06090628, 0x068ed868, 0x02c28aa8,
-	0x09441a30, 0x06090628, 0x080c24a0, 0x080e1424, 0x064c2228,
-	0x060e152e, 0x060e152f, 0x060e1528, 0x0c780080, 0x060e1528,
-	0x0cc00000, 0x00000000, 0x07800028, 0x078016e9, 0x06800030,
-	0x09508a68, 0x0780016b, 0x0780026a, 0x04601aaa, 0x0c500c00,
-	0x0aa1416b, 0x00000000, 0x06800070, 0x0a61826b, 0x00000000,
-	0x078003a8, 0x04602a28, 0x0c500840, 0x0c7800c0, 0x0c780000,
-	0x00000000, 0x06490628, 0x0aefcc28, 0x06b000a8, 0x09441a30,
-	0x06090628, 0x06090629, 0x069fffeb, 0x06900028, 0x080c2400,
-	0x080e1424, 0x064c2228, 0x060e1528, 0x060e1528, 0x060e1528,
-	0x060e1528, 0x09210a68, 0x06090628, 0x02828ae9, 0x06090628,
-	0x080c2440, 0x064c2228, 0x09210a68, 0x06090628, 0x02828ae9,
-	0x06090628, 0x06b8d068, 0x09441a30, 0x0c781340, 0x06090628,
-	0x06b0002a, 0x09441ab0, 0x06031f2a, 0x0680016b, 0x09510ae9,
-	0x0c781180, 0x06031e2b, 0x0aa1416b, 0x0aa1026b, 0x06800070,
-	0x0c7ff5c0, 0x00000000, 0x06490628, 0x0aefcc28, 0x06b408a8,
-	0x09441a30, 0x06090628, 0x06090629, 0x069fffec, 0x06900028,
-	0x080c2400, 0x064c222e, 0x0609062e, 0x09210a2e, 0x09c28068,
-	0x02828b28, 0x09828428, 0x078017ad, 0x095e1a2d, 0x06090628,
-	0x080c2440, 0x064c2228, 0x06090628, 0x09210a28, 0x09c28068,
-	0x02828b28, 0x09828428, 0x06090628, 0x06bc5828, 0x09441a30,
-	0x06090628, 0x06b60828, 0x09441a30, 0x06090628, 0x06900028,
-	0x080c2410, 0x064c222f, 0x0609062f, 0x09210a2f, 0x09c28068,
-	0x02828b28, 0x09828428, 0x078017ad, 0x05801b6d, 0x095e1a2d,
-	0x06090628, 0x080c2450, 0x064c2228, 0x06090628, 0x09210a28,
-	0x09c28068, 0x02828b28, 0x09828428, 0x098283e8, 0x06090628,
-	0x06bed868, 0x09441a30, 0x06090628, 0x080c24a0, 0x080e1424,
-	0x064c2228, 0x060e152e, 0x060e152f, 0x060e1528, 0x060e1528,
-	0x0cc00000, 0x00000000, 0x064e1215, 0x091e1555, 0x0a208055,
-	0x0c782300, 0x0649d915, 0x0900c555, 0x0a6f8015, 0x00000000,
-	0x078003d5, 0x0aa08055, 0x0c780940, 0x07800596, 0x0aa1c016,
-	0x04401596, 0x07c00596, 0x078005d6, 0x04401596, 0x0c7814c0,
-	0x07c005d6, 0x07800916, 0x07800295, 0x05408555, 0x02015595,
-	0x04003596, 0x07c00916, 0x05404595, 0x02016c56, 0x060e1316,
-	0x07800517, 0x0aa0c017, 0x06a16016, 0x06a16196, 0x07c00416,
-	0x069fffd7, 0x044015d7, 0x0aa1c017, 0x00000000, 0x064e1615,
-	0x09010555, 0x0aaec015, 0x04401555, 0x060e1615, 0x06c00016,
-	0x060e1216, 0x06800095, 0x0c781880, 0x07c003d5, 0x0a660095,
-	0x078005d6, 0x0aa18016, 0x04401596, 0x0b210056, 0x07c005d6,
-	0x0c780bc0, 0x00000000, 0x07800956, 0x07800295, 0x05408555,
-	0x02015595, 0x04003596, 0x07c00956, 0x05404595, 0x02016c56,
-	0x060e1316, 0x07800415, 0x09c151d5, 0x06c00015, 0x060e1215,
-	0x068000d5, 0x0c781280, 0x07c003d5, 0x0aa080d5, 0x0c780700,
-	0x07800516, 0x0aa0c016, 0x06800017, 0x06800317, 0x060e1417,
-	0x07800795, 0x07c00755, 0x0683ffd5, 0x064e1516, 0x0900c5d6,
-	0x0a40b5d5, 0x091845d6, 0x07c00797, 0x064e1516, 0x064e1516,
-	0x064e1516, 0x080c24e0, 0x060c2216, 0x064e1516, 0x0c780200,
-	0x060c2216, 0x068000d6, 0x07c00796, 0x06800016, 0x080c24e0,
-	0x060c2216, 0x060c2216, 0x0aa080a0, 0x0c780a00, 0x078003d5,
-	0x0a644115, 0x07800956, 0x068ac015, 0x05408555, 0x02015595,
-	0x04003596, 0x07c00956, 0x05404595, 0x02016c56, 0x060e1316,
-	0x06a16015, 0x09c151d5, 0x06c00015, 0x060e1215, 0x06800195,
-	0x0c780640, 0x07c003d5, 0x0aa0c195, 0x0c780500, 0x00000000,
-	0x06431e18, 0x0befc058, 0x064e1418, 0x080e1400, 0x064e1516,
-	0x0683ffd5, 0x0900c5d6, 0x09203656, 0x0a8045d5, 0x091845d6,
-	0x068000d7, 0x06800019, 0x07c004d7, 0x090015d9, 0x07c00497,
-	0x090225d9, 0x07c01117, 0x060e1418, 0x06800015, 0x07c003d5,
-	0x0cc00000, 0x00400000, 0x06800047, 0x07c003c7, 0x07800507,
-	0x050011c7, 0x07c00507, 0x064e1608, 0x09010208, 0x04001208,
-	0x060e1608, 0x0aa0c007, 0x06800008, 0x06800308, 0x060e1408,
-	0x06b7ffc7, 0x06c00007, 0x060e1507, 0x060e1524, 0x060e1524,
-	0x060e1524, 0x060e1524, 0x0cc00000, 0x08030580, 0x078003c7,
-	0x0a6fc007, 0x07800447, 0x0aa0c0c7, 0x0aa98347, 0x0a638107,
-	0x07800507, 0x050011c7, 0x07c00507, 0x06800047, 0x07c003c7,
-	0x080c24e0, 0x064c2207, 0x064c2208, 0x080c24c0, 0x060c2207,
-	0x060c2208, 0x0cc00000, 0x08030580, 0x06800047, 0x07c003c7,
-	0x07800507, 0x050011c7, 0x07c00507, 0x080e1424, 0x064e1509,
-	0x064e150a, 0x064e150b, 0x064e150c, 0x0aa0c007, 0x06800008,
-	0x06800308, 0x060e1408, 0x0683ffc7, 0x07800448, 0x095841c8,
-	0x07800308, 0x096031c8, 0x060e1507, 0x060e1509, 0x060e150a,
-	0x060e150b, 0x060e150c, 0x0cc00000, 0x08030580, 0x07800987,
-	0x078009c8, 0x06800009, 0x0d000008, 0x020091c9, 0x04401249,
-	0x06800047, 0x0ba10089, 0x05801249, 0x0c7fff80, 0x040011c7,
-	0x0cc00000, 0x07c00687, 0x06800208, 0x064c3b07, 0x091031c7,
-	0x024071c8, 0x0f8001c7, 0x0fc0f1c0, 0x064c0e07, 0x040011c7,
-	0x0f8001c7, 0x07800687, 0x0f8001c7, 0x0fc051c0, 0x0c073d80,
-	0x07c00107, 0x0fc011c0, 0x0aa0c007, 0x0c000640, 0x00000000,
-	0x078002c7, 0x07801988, 0x094c11c8, 0x0c073680, 0x060e0407,
-	0x06800007, 0x07c01cc7, 0x078005c7, 0x0b210087, 0x07800988,
-	0x04002208, 0x024081c8, 0x07800947, 0x04401208, 0x02007207,
-	0x05401208, 0x02007207, 0x07c00947, 0x07800987, 0x040011c7,
-	0x07c005c7, 0x0cc00000, 0x00000000, 0x0fc011c0, 0x0a600007,
-	0x0fc011c0, 0x07801408, 0x0f8001c8, 0x0fc011c0, 0x0fc021c0,
-	0x0fc03200, 0x0aa10007, 0x0aa0c047, 0x0fc03200, 0x0fc03200,
-	0x0cc00000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x06098208, 0x080980f0, 0x07801c07, 0x0aa6c007, 0x00000000,
+	0x07801d07, 0x0aa60007, 0x00000000, 0x080980f4, 0x0c780540,
+	0x00000000, 0x06499008, 0x05410208, 0x0649b10f, 0x054103cf,
+	0x07801c47, 0x0a614047, 0x00000000, 0x05810208, 0x0c7800c0,
+	0x00000000, 0x058103cf, 0x02c083c8, 0x06098108, 0x06499108,
+	0x05410208, 0x058103c8, 0x02c083c8, 0x06098208, 0x080980f4,
+	0x07801b07, 0x06800048, 0x09421207, 0x0c7ed440, 0x06090708,
+	0x06800025, 0x0ae20225, 0x064c0007, 0x0a2f8047, 0x00000000,
+	0x064c3a07, 0x090061c7, 0x0aae8647, 0x0c7800c0, 0x0c7ec3c0,
+	0x00000000, 0x080c2800, 0x080c0002, 0x0c7ebcc0, 0x00000000,
+	0x0649c007, 0x07c04647, 0x058101c7, 0x07c04687, 0x0649c107,
+	0x07c046c7, 0x058101c7, 0x07c04707, 0x0649c207, 0x07c04747,
+	0x058101c7, 0x07c04787, 0x0649c307, 0x07c047c7, 0x058101c7,
+	0x07c04807, 0x0649d007, 0x07c04847, 0x058101c7, 0x07c04887,
+	0x0649d107, 0x07c048c7, 0x058101c7, 0x07c04907, 0x0649d207,
+	0x07c04947, 0x058101c7, 0x07c04987, 0x0649d307, 0x07c049c7,
+	0x058101c7, 0x07c04a07, 0x0c004280, 0x06800025, 0x08002501,
+	0x08002605, 0x08002708, 0x08002815, 0x08002c14, 0x08002a09,
+	0x08002b17, 0x06830002, 0x06032602, 0x08032261, 0x08032101,
+	0x0cc00000, 0x00000000, 0x080c2804, 0x064c2807, 0x0a2fc047,
+	0x05801207, 0x080c2800, 0x0aa14008, 0x0b21004a, 0x044011ca,
+	0x0f8001c7, 0x094e9207, 0x0cc00000, 0x07400248, 0x080c2804,
+	0x064c2807, 0x0a2fc047, 0x05801207, 0x0cc00000, 0x07400248,
+	0x0fc011c0, 0x0a608007, 0x0c780ec0, 0x06800247, 0x07c00147,
+	0x07800488, 0x095011c8, 0x060c2107, 0x080e1401, 0x080c2440,
+	0x064e1507, 0x078004c8, 0x0aa400c8, 0x0aa54088, 0x060c2207,
+	0x07800487, 0x0aa28007, 0x07801107, 0x064e1508, 0x060c2208,
+	0x07801c48, 0x094411c8, 0x068010c8, 0x09503207, 0x0c780440,
+	0x060c2108, 0x0c7803c0, 0x080c2141, 0x080c2200, 0x080c2200,
+	0x080c2200, 0x080c2200, 0x0c780240, 0x080c2141, 0x064e1507,
+	0x060c2207, 0x064e1507, 0x060c2207, 0x064e1507, 0x060c2207,
+	0x080c2147, 0x064c2407, 0x0befc3c7, 0x078004c7, 0x07c00387,
+	0x07800487, 0x07c00247, 0x07801107, 0x07c01787, 0x06800107,
+	0x07c003c7, 0x0c007900, 0x00000000, 0x08030580, 0x07800007,
+	0x040011c7, 0x07c00007, 0x06431e07, 0x0befc047, 0x0c7ea700,
+	0x00000000, 0x0fc01200, 0x0fc011c0, 0x0aa28047, 0x06800147,
+	0x0fc011c0, 0x0aa1c047, 0x06800187, 0x0fc011c0, 0x0aa10047,
+	0x068001c7, 0x0fc011c0, 0x06800207, 0x07c00147, 0x0a60c008,
+	0x06800007, 0x0fc061c0, 0x07c01387, 0x07800147, 0x0aa4c147,
+	0x07801387, 0x0aa44007, 0x00000000, 0x0fc011c0, 0x0aa38007,
+	0x07800108, 0x0fc011c0, 0x0aa14007, 0x0b21c748, 0x04002208,
+	0x0c780140, 0x068007c8, 0x0b60c0c8, 0x04402208, 0x06800048,
+	0x07c00108, 0x0c0005c0, 0x040001c8, 0x0c7eeb40, 0x00000000,
+	0x06a00007, 0x06e00007, 0x080c24a0, 0x060c2207, 0x060c2207,
+	0x060c2207, 0x060c2207, 0x060c2207, 0x0cc00000, 0x060c2207,
+	0x07801988, 0x094c11c8, 0x0c07fd00, 0x060e0407, 0x06800007,
+	0x07c01cc7, 0x07c00907, 0x0cc00000, 0x07c00947, 0x060c0a07,
+	0x078000c8, 0x0aa24008, 0x06800009, 0x0aa1c1c8, 0x06800049,
+	0x05401247, 0x0400b249, 0x0b403247, 0x06800049, 0x06800009,
+	0x07c00bc9, 0x0b218107, 0x0ae08207, 0x0c780380, 0x0b214607,
+	0x0c780180, 0x00000000, 0x0c780480, 0x06820207, 0x0c780240,
+	0x00000000, 0x05401207, 0x04410208, 0x044061c7, 0x054081c7,
+	0x0c780280, 0x094081c8, 0x0c7800c0, 0x0c7800c0, 0x04008207,
+	0x05401207, 0x0400d1c7, 0x054071c7, 0x0c780080, 0x094081c8,
+	0x07c002c7, 0x06b00008, 0x064c2d09, 0x09610248, 0x060c2d09,
+	0x09610208, 0x060c2f08, 0x07801988, 0x094c11c8, 0x0cc00000,
+	0x060e0407, 0x0680000e, 0x0aa4c00f, 0x0ae1400f, 0x0400038f,
+	0x06bfffce, 0x0300e38f, 0x0400138e, 0x0900434e, 0x0b21408d,
+	0x06800007, 0x0b20c34d, 0x06800047, 0x06800087, 0x05c0438e,
+	0x0540138e, 0x0200e1ce, 0x0ae1000f, 0x06bfffcd, 0x0300e34e,
+	0x0400138e, 0x0cc00000, 0x040003ce, 0x07800007, 0x0ae10007,
+	0x07800109, 0x07800988, 0x02007207, 0x044011c7, 0x06808048,
+	0x02007207, 0x074001c9, 0x0cc00000, 0x07c08009, 0x0681f409,
+	0x04401249, 0x0aefc009, 0x00000000, 0x083f0040, 0x083f0000,
+	0x08090b65, 0x00000000, 0x08090b60, 0x06498e07, 0x09807007,
+	0x068007c9, 0x097051c9, 0x06098e07, 0x0681f409, 0x04601249,
+	0x0c4fffc0, 0x00000000, 0x06800009, 0x097051c9, 0x09c07007,
+	0x06098e07, 0x064c0007, 0x09c07187, 0x09807207, 0x060c0007,
+	0x064c0807, 0x09807347, 0x060c0807, 0x083f0040, 0x083f0000,
+	0x08090b65, 0x0cc00000, 0x08090b60, 0x0680001f, 0x07c0149f,
+	0x07c014df, 0x07c0151f, 0x064c091f, 0x07c0175f, 0x07c0005f,
+	0x06800020, 0x06803fc2, 0x07c01542, 0x07c01582, 0x07c015c2,
+	0x07c01602, 0x060c091f, 0x080c0101, 0x080c2901, 0x06840442,
+	0x060c2e02, 0x064c4027, 0x064c4226, 0x024269e6, 0x040089a6,
+	0x07c006e6, 0x058109a6, 0x07c00726, 0x0649cf31, 0x0809c500,
+	0x0649c707, 0x0aa6c007, 0x09010207, 0x092101c7, 0x0401f287,
+	0x0580528a, 0x0403e247, 0x05806249, 0x09610289, 0x0649c709,
+	0x09610247, 0x0609c709, 0x0400f1c7, 0x058041c7, 0x060c0907,
+	0x07c00987, 0x04401247, 0x07c00609, 0x05404287, 0x0649c707,
+	0x094101c8, 0x0609c707, 0x0400f208, 0x05804208, 0x07c009c8,
+	0x05404208, 0x0961020a, 0x06090808, 0x0809c300, 0x0809cb00,
+	0x0cc00000, 0x00000000, 0x0649c803, 0x0aa14003, 0x078014c2,
+	0x028020c2, 0x07c014c2, 0x0809c800, 0x07801502, 0x0aa0c002,
+	0x06800102, 0x06030502, 0x064c0002, 0x0be14042, 0x0ba1d025,
+	0x06800102, 0x07c01502, 0x08030504, 0x06800025, 0x0cc00000,
+	0x00000000, 0x078001c2, 0x0aa1c002, 0x078016c2, 0x078009c3,
+	0x0a4040c2, 0x00000000, 0x06800102, 0x06030502, 0x0cc00000,
+	0x00000000, 0x0fc02240, 0x0aa4c009, 0x0680000a, 0x0b6180c9,
+	0x0680010a, 0x0fc01280, 0x09422289, 0x0c780140, 0x0440128a,
+	0x0fc01240, 0x0a6fc009, 0x0400128a, 0x06800049, 0x03409289,
+	0x05801249, 0x0f80028a, 0x0b40424a, 0x05401249, 0x04401249,
+	0x0240a24a, 0x0740020a, 0x0cc00000, 0x0fc01240, 0x064c441a,
+	0x0912169a, 0x0aaf801a, 0x0c7e54c0, 0x00000000, 0x06490628,
+	0x0aefcc28, 0x00000000, 0x07800028, 0x078016e9, 0x09508a68,
+	0x068000a8, 0x06c00028, 0x06090628, 0x06090629, 0x06881068,
+	0x06090628, 0x0cc00000, 0x00000000, 0x06490628, 0x0aefcc28,
+	0x06c00028, 0x069001a8, 0x069fffea, 0x06090628, 0x06090629,
+	0x05401a23, 0x06090628, 0x09210a23, 0x05401a28, 0x02828aa8,
+	0x06090628, 0x06985168, 0x0c782700, 0x06090628, 0x078003e8,
+	0x0a6fc028, 0x07800028, 0x078016e9, 0x06800030, 0x09508a68,
+	0x0780016b, 0x07801d2a, 0x04601aaa, 0x0c500ec0, 0x0aa4802b,
+	0x0690002a, 0x0aa4006b, 0x0aa8c36b, 0x0aa883eb, 0x0aa3422b,
+	0x00000000, 0x06a0002a, 0x0aa281eb, 0x06c0002a, 0x06b0002a,
+	0x0aa1c1ab, 0x06c0002a, 0x04602aeb, 0x0c500980, 0x0690002a,
+	0x0c7e4d00, 0x00000000, 0x06490628, 0x0aefcc28, 0x068000a8,
+	0x02c28aa8, 0x09441a30, 0x06090628, 0x06090629, 0x069fffeb,
+	0x06900028, 0x0a00ca2a, 0x080c2400, 0x080e1424, 0x064c2228,
+	0x060e1528, 0x060e1528, 0x060e1528, 0x060e1528, 0x09210a68,
+	0x06090628, 0x02828ae9, 0x06090628, 0x06a00028, 0x0a007a2a,
+	0x080c2440, 0x064c2228, 0x09210a68, 0x06090628, 0x02828ae9,
+	0x06090628, 0x0688d068, 0x02c28aa8, 0x09441a30, 0x0c781780,
+	0x06090628, 0x09441ab0, 0x06031f2a, 0x0680016b, 0x09510ae9,
+	0x0c781600, 0x06031e2b, 0x0aa241eb, 0x06a0002a, 0x0aa1c1ab,
+	0x06b0002a, 0x0aa1416b, 0x0aa1026b, 0x06800070, 0x0690002a,
+	0x06800030, 0x06490628, 0x0aefcc28, 0x06c0002a, 0x068408a8,
+	0x02c28aa8, 0x09441a30, 0x06090628, 0x06090629, 0x069fffec,
+	0x06900028, 0x0a00ba2a, 0x080c2400, 0x064c222e, 0x0609062e,
+	0x09210a2e, 0x09c28068, 0x02828b28, 0x09828428, 0x07801d6d,
+	0x095e1a2d, 0x06090628, 0x06a00028, 0x0a00ba2a, 0x080c2440,
+	0x064c2228, 0x06090628, 0x09210a28, 0x09c28068, 0x02828b28,
+	0x09828428, 0x07801ded, 0x095e1a2d, 0x06090628, 0x068c5828,
+	0x02c28aa8, 0x09441a30, 0x06090628, 0x06860828, 0x02c28aa8,
+	0x09441a30, 0x06090628, 0x06900028, 0x0a00ba2a, 0x080c2410,
+	0x064c222f, 0x0609062f, 0x09210a2f, 0x09c28068, 0x02828b28,
+	0x09828428, 0x07801dad, 0x095e1a2d, 0x06090628, 0x06a00028,
+	0x0a00ba2a, 0x080c2450, 0x064c2228, 0x06090628, 0x09210a28,
+	0x09c28068, 0x02828b28, 0x09828428, 0x07801e2d, 0x095e1a2d,
+	0x06090628, 0x068ed868, 0x02c28aa8, 0x09441a30, 0x06090628,
+	0x080c24a0, 0x080e1424, 0x064c2228, 0x060e152e, 0x060e152f,
+	0x060e1528, 0x0c780080, 0x060e1528, 0x0cc00000, 0x00000000,
+	0x07800028, 0x078016e9, 0x06800030, 0x09508a68, 0x0780016b,
+	0x0780026a, 0x04601aaa, 0x0c500c00, 0x0aa1416b, 0x00000000,
+	0x06800070, 0x0a61826b, 0x00000000, 0x078003a8, 0x04602a28,
+	0x0c500840, 0x0c7800c0, 0x0c780000, 0x00000000, 0x06490628,
+	0x0aefcc28, 0x06b000a8, 0x09441a30, 0x06090628, 0x06090629,
+	0x069fffeb, 0x06900028, 0x080c2400, 0x080e1424, 0x064c2228,
+	0x060e1528, 0x060e1528, 0x060e1528, 0x060e1528, 0x09210a68,
+	0x06090628, 0x02828ae9, 0x06090628, 0x080c2440, 0x064c2228,
+	0x09210a68, 0x06090628, 0x02828ae9, 0x06090628, 0x06b8d068,
+	0x09441a30, 0x0c781340, 0x06090628, 0x06b0002a, 0x09441ab0,
+	0x06031f2a, 0x0680016b, 0x09510ae9, 0x0c781180, 0x06031e2b,
+	0x0aa1416b, 0x0aa1026b, 0x06800070, 0x0c7ff5c0, 0x00000000,
+	0x06490628, 0x0aefcc28, 0x06b408a8, 0x09441a30, 0x06090628,
+	0x06090629, 0x069fffec, 0x06900028, 0x080c2400, 0x064c222e,
+	0x0609062e, 0x09210a2e, 0x09c28068, 0x02828b28, 0x09828428,
+	0x078017ad, 0x095e1a2d, 0x06090628, 0x080c2440, 0x064c2228,
+	0x06090628, 0x09210a28, 0x09c28068, 0x02828b28, 0x09828428,
+	0x06090628, 0x06bc5828, 0x09441a30, 0x06090628, 0x06b60828,
+	0x09441a30, 0x06090628, 0x06900028, 0x080c2410, 0x064c222f,
+	0x0609062f, 0x09210a2f, 0x09c28068, 0x02828b28, 0x09828428,
+	0x078017ad, 0x05801b6d, 0x095e1a2d, 0x06090628, 0x080c2450,
+	0x064c2228, 0x06090628, 0x09210a28, 0x09c28068, 0x02828b28,
+	0x09828428, 0x098283e8, 0x06090628, 0x06bed868, 0x09441a30,
+	0x06090628, 0x080c24a0, 0x080e1424, 0x064c2228, 0x060e152e,
+	0x060e152f, 0x060e1528, 0x060e1528, 0x0cc00000, 0x00000000,
+	0x064e1215, 0x091e1555, 0x0a208055, 0x0c782300, 0x0649d915,
+	0x0900c555, 0x0a6f8015, 0x00000000, 0x078003d5, 0x0aa08055,
+	0x0c780940, 0x07800596, 0x0aa1c016, 0x04401596, 0x07c00596,
+	0x078005d6, 0x04401596, 0x0c7814c0, 0x07c005d6, 0x07800916,
+	0x07800295, 0x05408555, 0x02015595, 0x04003596, 0x07c00916,
+	0x05404595, 0x02016c56, 0x060e1316, 0x07800517, 0x0aa0c017,
+	0x06a16016, 0x06a16196, 0x07c00416, 0x069fffd7, 0x044015d7,
+	0x0aa1c017, 0x00000000, 0x064e1615, 0x09010555, 0x0aaec015,
+	0x04401555, 0x060e1615, 0x06c00016, 0x060e1216, 0x06800095,
+	0x0c781880, 0x07c003d5, 0x0a660095, 0x078005d6, 0x0aa18016,
+	0x04401596, 0x0b210056, 0x07c005d6, 0x0c780bc0, 0x00000000,
+	0x07800956, 0x07800295, 0x05408555, 0x02015595, 0x04003596,
+	0x07c00956, 0x05404595, 0x02016c56, 0x060e1316, 0x07800415,
+	0x09c151d5, 0x06c00015, 0x060e1215, 0x068000d5, 0x0c781280,
+	0x07c003d5, 0x0aa080d5, 0x0c780700, 0x07800516, 0x0aa0c016,
+	0x06800017, 0x06800317, 0x060e1417, 0x07800795, 0x07c00755,
+	0x0683ffd5, 0x064e1516, 0x0900c5d6, 0x0a40b5d5, 0x091845d6,
+	0x07c00797, 0x064e1516, 0x064e1516, 0x064e1516, 0x080c24e0,
+	0x060c2216, 0x064e1516, 0x0c780200, 0x060c2216, 0x068000d6,
+	0x07c00796, 0x06800016, 0x080c24e0, 0x060c2216, 0x060c2216,
+	0x0aa080a0, 0x0c780a00, 0x078003d5, 0x0a644115, 0x07800956,
+	0x068ac015, 0x05408555, 0x02015595, 0x04003596, 0x07c00956,
+	0x05404595, 0x02016c56, 0x060e1316, 0x06a16015, 0x09c151d5,
+	0x06c00015, 0x060e1215, 0x06800195, 0x0c780640, 0x07c003d5,
+	0x0aa0c195, 0x0c780500, 0x00000000, 0x06431e18, 0x0befc058,
+	0x064e1418, 0x080e1400, 0x064e1516, 0x0683ffd5, 0x0900c5d6,
+	0x09203656, 0x0a8045d5, 0x091845d6, 0x068000d7, 0x06800019,
+	0x07c004d7, 0x090015d9, 0x07c00497, 0x090225d9, 0x07c01117,
+	0x060e1418, 0x06800015, 0x07c003d5, 0x0cc00000, 0x00400000,
+	0x06800047, 0x07c003c7, 0x07800507, 0x050011c7, 0x07c00507,
+	0x064e1608, 0x09010208, 0x04001208, 0x060e1608, 0x0aa0c007,
+	0x06800008, 0x06800308, 0x060e1408, 0x06b7ffc7, 0x06c00007,
+	0x060e1507, 0x060e1524, 0x060e1524, 0x060e1524, 0x060e1524,
+	0x0cc00000, 0x08030580, 0x078003c7, 0x0a6fc007, 0x07800447,
+	0x0aa0c0c7, 0x0aa98347, 0x0a638107, 0x07800507, 0x050011c7,
+	0x07c00507, 0x06800047, 0x07c003c7, 0x080c24e0, 0x064c2207,
+	0x064c2208, 0x080c24c0, 0x060c2207, 0x060c2208, 0x0cc00000,
+	0x08030580, 0x06800047, 0x07c003c7, 0x07800507, 0x050011c7,
+	0x07c00507, 0x080e1424, 0x064e1509, 0x064e150a, 0x064e150b,
+	0x064e150c, 0x0aa0c007, 0x06800008, 0x06800308, 0x060e1408,
+	0x0683ffc7, 0x07800448, 0x095841c8, 0x07800308, 0x096031c8,
+	0x060e1507, 0x060e1509, 0x060e150a, 0x060e150b, 0x060e150c,
+	0x0cc00000, 0x08030580, 0x07800987, 0x078009c8, 0x06800009,
+	0x0d000008, 0x020091c9, 0x04401249, 0x06800047, 0x0ba10089,
+	0x05801249, 0x0c7fff80, 0x040011c7, 0x0cc00000, 0x07c00687,
+	0x06800208, 0x064c3b07, 0x091031c7, 0x024071c8, 0x0f8001c7,
+	0x0fc0f1c0, 0x064c0e07, 0x040011c7, 0x0f8001c7, 0x07800687,
+	0x0f8001c7, 0x0fc051c0, 0x0c073d80, 0x07c00107, 0x0fc011c0,
+	0x0aa0c007, 0x0c000640, 0x00000000, 0x078002c7, 0x07801988,
+	0x094c11c8, 0x0c073680, 0x060e0407, 0x06800007, 0x07c01cc7,
+	0x078005c7, 0x0b210087, 0x07800988, 0x04002208, 0x024081c8,
+	0x07800947, 0x04401208, 0x02007207, 0x05401208, 0x02007207,
+	0x07c00947, 0x07800987, 0x040011c7, 0x07c005c7, 0x0cc00000,
+	0x00000000, 0x0fc011c0, 0x0a600007, 0x0fc011c0, 0x07801408,
+	0x0f8001c8, 0x0fc011c0, 0x0fc021c0, 0x0fc03200, 0x0aa10007,
+	0x0aa0c047, 0x0fc03200, 0x0fc03200, 0x0cc00000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -1671,31 +1671,31 @@ const u32 __initconst vmpeg4_mc_311[] = {
 };
 
 const u32 __initconst h263_mc[] = {
-	0x0680c001, 0x06800000, 0x0d000001, 0x07400040, 0x0c014a80,
+	0x0680c001, 0x06800000, 0x0d000001, 0x07400040, 0x0c014bc0,
 	0x00000000, 0x00000000, 0x00000000, 0x080c0002, 0x00000000,
-	0x06bfde80, 0x07c017c0, 0x06030400, 0x00400000, 0x0c01a180,
+	0x06bfde80, 0x07c017c0, 0x06030400, 0x00400000, 0x0c01a2c0,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x0c7ffe80, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x0c780400, 0x04001965, 0x0cc00000,
-	0x00400000, 0x0c780540, 0x064c0007, 0x0c79a880, 0x06800025,
+	0x00400000, 0x0c780540, 0x064c0007, 0x0c79a9c0, 0x06800025,
 	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
-	0x00400000, 0x0c7a0080, 0x06800025, 0x0cc00000, 0x00400000,
+	0x00400000, 0x0c7a01c0, 0x06800025, 0x0cc00000, 0x00400000,
 	0x06800025, 0x00800000, 0x078017c9, 0x0c7ffec0, 0x06030409,
-	0x0c781240, 0x00000000, 0x078001c9, 0x0aa0c009, 0x0c7905c0,
+	0x0c781240, 0x00000000, 0x078001c9, 0x0aa0c009, 0x0c790600,
 	0x00000000, 0x06bfdd89, 0x06030409, 0x00400000, 0x07801509,
 	0x0aa30109, 0x07c0151f, 0x0a2bc047, 0x06800025, 0x0aac80c9,
-	0x0aa14009, 0x0a608049, 0x0c791000, 0x0a608089, 0x0c790200,
-	0x0a240807, 0x0c78bb40, 0x00000000, 0x0683ffc8, 0x0ba20048,
+	0x0aa14009, 0x0a608049, 0x0c791140, 0x0a608089, 0x0c790240,
+	0x0a240807, 0x0c78bb80, 0x00000000, 0x0683ffc8, 0x0ba20048,
 	0x064c0007, 0x0a2f8047, 0x04401208, 0x064c3a07, 0x090061c7,
-	0x0aae8647, 0x00000000, 0x06800007, 0x0c017800, 0x07c003c7,
-	0x0c793140, 0x0bec9007, 0x078003c7, 0x0a6fc007, 0x07800007,
+	0x0aae8647, 0x00000000, 0x06800007, 0x0c017940, 0x07c003c7,
+	0x0c793280, 0x0bec9007, 0x078003c7, 0x0a6fc007, 0x07800007,
 	0x07800988, 0x0b81c207, 0x06800007, 0x07c00007, 0x0a61c060,
 	0x06a00008, 0x06e00008, 0x080c24a0, 0x060c2208, 0x0c780240,
 	0x060c2208, 0x0a61c0a0, 0x00000000, 0x080c24c0, 0x080c2200,
 	0x080c2200, 0x080c2200, 0x080c2200, 0x078016c8, 0x04001208,
-	0x078009c9, 0x0b808248, 0x07c016c8, 0x0c0217c0, 0x00000000,
-	0x078003c7, 0x0a6fc007, 0x0c792940, 0x00000000, 0x07800992,
+	0x078009c9, 0x0b808248, 0x07c016c8, 0x0c021900, 0x00000000,
+	0x078003c7, 0x0a6fc007, 0x0c792a80, 0x00000000, 0x07800992,
 	0x078009d3, 0x0680000f, 0x06800010, 0x06800007, 0x07c01507,
 	0x064c4707, 0x06810008, 0x0ac04207, 0x068000c7, 0x0c7feb00,
 	0x07c01507, 0x06490607, 0x0aefcc07, 0x00000000, 0x0540838f,
@@ -1729,171 +1729,172 @@ const u32 __initconst h263_mc[] = {
 	0x0c7ff700, 0x00000000, 0x040013cf, 0x0a80348f, 0x0c7fda40,
 	0x00000000, 0x04001410, 0x0a8054d0, 0x00000000, 0x0680000f,
 	0x0c7fd8c0, 0x00000000, 0x06490907, 0x0befc047, 0x00000000,
-	0x0c78ff40, 0x00000000, 0x07800347, 0x0aa0c007, 0x0c780880,
-	0x00000000, 0x064c1d07, 0x09227207, 0x0a678008, 0x064c2a08,
-	0x064c3607, 0x091081c7, 0x095101c8, 0x064c3b08, 0x09103248,
-	0x04001209, 0x03807207, 0x0900f207, 0x0a650008, 0x0580f1c7,
-	0x06800048, 0x05407208, 0x03808248, 0x04401208, 0x0a40e207,
-	0x064c1d07, 0x0a60c009, 0x00000000, 0x054081c7, 0x06800009,
-	0x09201207, 0x0a610008, 0x054011c7, 0x0c7fff40, 0x04001249,
-	0x060c0e09, 0x0c01f240, 0x00000000, 0x0aa080a0, 0x0c780f40,
-	0x078003c7, 0x0a6fc007, 0x07801bc8, 0x0a63c008, 0x078004c8,
-	0x0a634348, 0x06800107, 0x07c003c7, 0x08030580, 0x068003c9,
-	0x07c00149, 0x06800007, 0x0c016540, 0x07c01d07, 0x07800007,
-	0x040011c7, 0x0c7fc080, 0x07c00007, 0x0c7905c0, 0x078003c7,
-	0x0a6fc007, 0x078005c7, 0x0ba0c087, 0x06800007, 0x06800047,
-	0x07c01fc7, 0x07800787, 0x0aa180c7, 0x06810007, 0x060e0907,
-	0x060e0a07, 0x0c780440, 0x060e0b07, 0x07800507, 0x0aa0c007,
-	0x068000c8, 0x068003c8, 0x060e1408, 0x064e1507, 0x060e0907,
-	0x04003208, 0x060e1408, 0x064e1507, 0x060e0a07, 0x04003208,
-	0x060e1408, 0x064e1507, 0x060e0b07, 0x0683ffc7, 0x080e1418,
-	0x060e1507, 0x080e141b, 0x060e1507, 0x080e141e, 0x060e1507,
-	0x080e1421, 0x0c01d4c0, 0x060e1507, 0x0c785500, 0x00000000,
-	0x0aa60020, 0x00000000, 0x0fc011c0, 0x0aa58007, 0x080c2803,
-	0x06800347, 0x07c00147, 0x080c24a0, 0x060c2224, 0x060c2224,
-	0x06800007, 0x07c01d07, 0x06800025, 0x064c3c07, 0x091011c7,
-	0x0ae1c225, 0x0aaf8007, 0x064c3c07, 0x091011c7, 0x0aae8007,
-	0x0c7ff0c0, 0x080c2800, 0x0c7fac40, 0x00000000, 0x080c2801,
-	0x064c2807, 0x0a2fc047, 0x064c0008, 0x0a209008, 0x0c7faa80,
-	0x058011c7, 0x09004207, 0x07c00148, 0x090821c7, 0x07c00187,
-	0x0aa140c8, 0x080c2800, 0x0aa0c108, 0x0c781940, 0x00000000,
-	0x0fc011c0, 0x0540e1c7, 0x060c2d07, 0x080c2802, 0x064c2807,
-	0x0a2fc047, 0x058011c7, 0x07800188, 0x09444207, 0x07c01388,
-	0x07800148, 0x0a644108, 0x080c2800, 0x0fc021c0, 0x0b61c087,
-	0x07800109, 0x024091c9, 0x0b620089, 0x04401249, 0x0c780180,
-	0x06800049, 0x020091c9, 0x0b20c809, 0x04401249, 0x068007c9,
-	0x07c00109, 0x0c010800, 0x040001c9, 0x07801fcb, 0x0aa1400b,
-	0x078005c9, 0x0b60c089, 0x0c0048c0, 0x00000000, 0x068fdfca,
+	0x0c790080, 0x00000000, 0x0a64c0a0, 0x078003c7, 0x0a6fc007,
+	0x07801bc8, 0x0a63c008, 0x078004c8, 0x0a634348, 0x06800107,
+	0x07c003c7, 0x08030580, 0x068003c9, 0x07c00149, 0x06800007,
+	0x0c016fc0, 0x07c01d07, 0x07800007, 0x040011c7, 0x0c7fc9c0,
+	0x07c00007, 0x07800347, 0x0aa0c007, 0x0c780880, 0x00000000,
+	0x064c1d07, 0x09227207, 0x0a678008, 0x064c2a08, 0x064c3607,
+	0x091081c7, 0x095101c8, 0x064c3b08, 0x09103248, 0x04001209,
+	0x03807207, 0x0900f207, 0x0a650008, 0x0580f1c7, 0x06800048,
+	0x05407208, 0x03808248, 0x04401208, 0x0a40e207, 0x064c1d07,
+	0x0a60c009, 0x00000000, 0x054081c7, 0x06800009, 0x09201207,
+	0x0a610008, 0x054011c7, 0x0c7fff40, 0x04001249, 0x060c0e09,
+	0x0c01eec0, 0x00000000, 0x0aa080a0, 0x0c780ac0, 0x0c7906c0,
+	0x078003c7, 0x0a6fc007, 0x078005c7, 0x0ba0c087, 0x06800007,
+	0x06800047, 0x07c01fc7, 0x07800787, 0x0aa180c7, 0x06810007,
+	0x060e0907, 0x060e0a07, 0x0c780440, 0x060e0b07, 0x07800507,
+	0x0aa0c007, 0x068000c8, 0x068003c8, 0x060e1408, 0x064e1507,
+	0x060e0907, 0x04003208, 0x060e1408, 0x064e1507, 0x060e0a07,
+	0x04003208, 0x060e1408, 0x064e1507, 0x060e0b07, 0x0683ffc7,
+	0x080e1418, 0x060e1507, 0x080e141b, 0x060e1507, 0x080e141e,
+	0x060e1507, 0x080e1421, 0x0c01d5c0, 0x060e1507, 0x0c785500,
+	0x00000000, 0x0aa60020, 0x00000000, 0x0fc011c0, 0x0aa58007,
+	0x080c2803, 0x06800347, 0x07c00147, 0x080c24a0, 0x060c2224,
+	0x060c2224, 0x06800007, 0x07c01d07, 0x06800025, 0x064c3c07,
+	0x091011c7, 0x0ae1c225, 0x0aaf8007, 0x064c3c07, 0x091011c7,
+	0x0aae8007, 0x0c7ff0c0, 0x080c2800, 0x0c7fac00, 0x00000000,
+	0x080c2801, 0x064c2807, 0x0a2fc047, 0x064c0008, 0x0a209008,
+	0x0c7faa40, 0x058011c7, 0x09004207, 0x07c00148, 0x090821c7,
+	0x07c00187, 0x0aa140c8, 0x080c2800, 0x0aa0c108, 0x0c781940,
+	0x00000000, 0x0fc011c0, 0x0540e1c7, 0x060c2d07, 0x080c2802,
+	0x064c2807, 0x0a2fc047, 0x058011c7, 0x07800188, 0x09444207,
+	0x07c01388, 0x07800148, 0x0a644108, 0x080c2800, 0x0fc021c0,
+	0x0b61c087, 0x07800109, 0x024091c9, 0x0b620089, 0x04401249,
+	0x0c780180, 0x06800049, 0x020091c9, 0x0b20c809, 0x04401249,
+	0x068007c9, 0x07c00109, 0x0c010900, 0x040001c9, 0x07801fcb,
+	0x0aa1400b, 0x078005c9, 0x0b60c089, 0x0c0048c0, 0x00000000,
+	0x068fdfca, 0x06feffca, 0x064e0408, 0x02808288, 0x078005ca,
+	0x0ba0c08a, 0x064c0909, 0x098083c8, 0x0ac0424a, 0x0780000a,
+	0x0a60c00a, 0x0400128a, 0x09808388, 0x0b80324a, 0x00000000,
+	0x098081c8, 0x07808007, 0x09605207, 0x07800007, 0x06808049,
+	0x02007247, 0x070001c7, 0x096a5207, 0x060e0408, 0x091e1248,
+	0x07c01fc9, 0x07801388, 0x060c2b08, 0x06880008, 0x098083c8,
+	0x07800507, 0x07801989, 0x0a610049, 0x09581207, 0x09808408,
+	0x098083c8, 0x060e0508, 0x06800009, 0x07800bc8, 0x09541248,
+	0x060c2a09, 0x07801c07, 0x0aa1c007, 0x080c2c03, 0x0fc011c0,
+	0x07c01cc7, 0x068000c9, 0x094a1247, 0x060c2c09, 0x0c01b600,
+	0x00000000, 0x080c0080, 0x0c013340, 0x00000000, 0x080c24a0,
+	0x080c2200, 0x080c2200, 0x07800007, 0x040011c7, 0x07c00007,
+	0x07800147, 0x0c010900, 0x07c00447, 0x0c7f8880, 0x00000000,
+	0x0a60c0e0, 0x06800007, 0x0fc011c0, 0x07c01707, 0x080c2802,
+	0x064c2807, 0x0a2fc047, 0x058011c7, 0x068003c8, 0x024071c8,
+	0x07800188, 0x09444207, 0x07c01388, 0x07800148, 0x0a644048,
+	0x080c2800, 0x0fc021c0, 0x0b61c087, 0x07800109, 0x024091c9,
+	0x0b620089, 0x04401249, 0x0c780180, 0x06800049, 0x020091c9,
+	0x0b20c809, 0x04401249, 0x068007c9, 0x07c00109, 0x0c00ef80,
+	0x040001c9, 0x07801388, 0x060c2b08, 0x07801c07, 0x0a60c007,
+	0x0c7806c0, 0x06800009, 0x0aa10008, 0x080c2800, 0x0fc011c0,
+	0x07c01cc7, 0x07800148, 0x0aa14088, 0x06800009, 0x0aa0c148,
+	0x07800489, 0x0fc01240, 0x07c01d09, 0x0aa38009, 0x0aa34148,
+	0x0aa201c8, 0x00000000, 0x0fc011c0, 0x07c01d47, 0x0fc011c0,
+	0x07c01d87, 0x0a618188, 0x00000000, 0x0fc011c0, 0x07c01dc7,
+	0x0fc011c0, 0x07c01e07, 0x07800148, 0x09501209, 0x07801709,
+	0x09521209, 0x060c2108, 0x07801cc8, 0x05405208, 0x060c2c08,
+	0x06880008, 0x07801989, 0x0aa0c049, 0x07800507, 0x098083c8,
+	0x09581207, 0x060e0508, 0x06800009, 0x07800bc8, 0x09541248,
+	0x060c2a09, 0x064c2408, 0x0befc3c8, 0x078003c8, 0x0a6fc008,
+	0x00000000, 0x080c0080, 0x0aa080a0, 0x0c7812c0, 0x080c2110,
+	0x07800147, 0x0aa38147, 0x078004c7, 0x07c00387, 0x07800487,
+	0x07c00247, 0x07801107, 0x07c01787, 0x06800107, 0x07c003c7,
+	0x08030580, 0x064c2407, 0x0befc3c7, 0x0c780b80, 0x080c2130,
+	0x064c2407, 0x0befc3c7, 0x078004c8, 0x080e1401, 0x080c2440,
+	0x064e1507, 0x0aa400c8, 0x0aa54088, 0x060c2207, 0x07800487,
+	0x0aa28007, 0x07801107, 0x064e1508, 0x060c2208, 0x07801c48,
+	0x094411c8, 0x068010c8, 0x09503207, 0x0c780440, 0x060c2108,
+	0x0c7803c0, 0x080c2141, 0x080c2200, 0x080c2200, 0x080c2200,
+	0x080c2200, 0x0c780240, 0x080c2141, 0x064e1507, 0x060c2207,
+	0x064e1507, 0x060c2207, 0x064e1507, 0x060c2207, 0x080c2147,
+	0x078004c7, 0x07c00387, 0x07800487, 0x07c00247, 0x07801107,
+	0x07c01787, 0x06800107, 0x07c003c7, 0x08030580, 0x064c2407,
+	0x0befc3c7, 0x00000000, 0x07800147, 0x0aa10147, 0x0c011100,
+	0x00000000, 0x0c7800c0, 0x0c0142c0, 0x00000000, 0x07800007,
+	0x040011c7, 0x0c7f5fc0, 0x07c00007, 0x07801fcb, 0x0aa1400b,
+	0x078005c9, 0x0b60c089, 0x0c000e40, 0x00000000, 0x068fdfca,
 	0x06feffca, 0x064e0408, 0x02808288, 0x078005ca, 0x0ba0c08a,
 	0x064c0909, 0x098083c8, 0x0ac0424a, 0x0780000a, 0x0a60c00a,
 	0x0400128a, 0x09808388, 0x0b80324a, 0x00000000, 0x098081c8,
-	0x07808007, 0x09605207, 0x07800007, 0x06808049, 0x02007247,
-	0x070001c7, 0x096a5207, 0x060e0408, 0x091e1248, 0x07c01fc9,
-	0x07801388, 0x060c2b08, 0x06880008, 0x098083c8, 0x07800507,
-	0x07801989, 0x0a610049, 0x09581207, 0x09808408, 0x098083c8,
-	0x060e0508, 0x06800009, 0x07800bc8, 0x09541248, 0x060c2a09,
-	0x07801c07, 0x0aa1c007, 0x080c2c03, 0x0fc011c0, 0x07c01cc7,
-	0x068000c9, 0x094a1247, 0x060c2c09, 0x0c01b500, 0x00000000,
-	0x080c0080, 0x0c013240, 0x00000000, 0x080c24a0, 0x080c2200,
-	0x080c2200, 0x07800007, 0x040011c7, 0x07c00007, 0x07800147,
-	0x0c010800, 0x07c00447, 0x0c7f88c0, 0x00000000, 0x0a60c0e0,
-	0x06800007, 0x0fc011c0, 0x07c01707, 0x080c2802, 0x064c2807,
-	0x0a2fc047, 0x058011c7, 0x068003c8, 0x024071c8, 0x07800188,
-	0x09444207, 0x07c01388, 0x07800148, 0x0a644048, 0x080c2800,
-	0x0fc021c0, 0x0b61c087, 0x07800109, 0x024091c9, 0x0b620089,
-	0x04401249, 0x0c780180, 0x06800049, 0x020091c9, 0x0b20c809,
-	0x04401249, 0x068007c9, 0x07c00109, 0x0c00ee80, 0x040001c9,
-	0x07801388, 0x060c2b08, 0x07801c07, 0x0a60c007, 0x0c7806c0,
-	0x06800009, 0x0aa10008, 0x080c2800, 0x0fc011c0, 0x07c01cc7,
-	0x07800148, 0x0aa14088, 0x06800009, 0x0aa0c148, 0x07800489,
-	0x0fc01240, 0x07c01d09, 0x0aa38009, 0x0aa34148, 0x0aa201c8,
-	0x00000000, 0x0fc011c0, 0x07c01d47, 0x0fc011c0, 0x07c01d87,
-	0x0a618188, 0x00000000, 0x0fc011c0, 0x07c01dc7, 0x0fc011c0,
-	0x07c01e07, 0x07800148, 0x09501209, 0x07801709, 0x09521209,
-	0x060c2108, 0x07801cc8, 0x05405208, 0x060c2c08, 0x06880008,
-	0x07801989, 0x0aa0c049, 0x07800507, 0x098083c8, 0x09581207,
-	0x060e0508, 0x06800009, 0x07800bc8, 0x09541248, 0x060c2a09,
-	0x064c2408, 0x0befc3c8, 0x078003c8, 0x0a6fc008, 0x00000000,
-	0x080c0080, 0x0aa080a0, 0x0c7812c0, 0x080c2110, 0x07800147,
-	0x0aa38147, 0x078004c7, 0x07c00387, 0x07800487, 0x07c00247,
-	0x07801107, 0x07c01787, 0x06800107, 0x07c003c7, 0x08030580,
-	0x064c2407, 0x0befc3c7, 0x0c780b80, 0x080c2130, 0x064c2407,
-	0x0befc3c7, 0x078004c8, 0x080e1401, 0x080c2440, 0x064e1507,
-	0x0aa400c8, 0x0aa54088, 0x060c2207, 0x07800487, 0x0aa28007,
-	0x07801107, 0x064e1508, 0x060c2208, 0x07801c48, 0x094411c8,
-	0x068010c8, 0x09503207, 0x0c780440, 0x060c2108, 0x0c7803c0,
-	0x080c2141, 0x080c2200, 0x080c2200, 0x080c2200, 0x080c2200,
-	0x0c780240, 0x080c2141, 0x064e1507, 0x060c2207, 0x064e1507,
-	0x060c2207, 0x064e1507, 0x060c2207, 0x080c2147, 0x078004c7,
-	0x07c00387, 0x07800487, 0x07c00247, 0x07801107, 0x07c01787,
-	0x06800107, 0x07c003c7, 0x08030580, 0x064c2407, 0x0befc3c7,
-	0x00000000, 0x07800147, 0x0aa10147, 0x0c011000, 0x00000000,
-	0x0c7800c0, 0x0c0141c0, 0x00000000, 0x07800007, 0x040011c7,
-	0x0c7f6000, 0x07c00007, 0x07801fcb, 0x0aa1400b, 0x078005c9,
-	0x0b60c089, 0x0c000e40, 0x00000000, 0x068fdfca, 0x06feffca,
-	0x064e0408, 0x02808288, 0x078005ca, 0x0ba0c08a, 0x064c0909,
-	0x098083c8, 0x0ac0424a, 0x0780000a, 0x0a60c00a, 0x0400128a,
-	0x09808388, 0x0b80324a, 0x00000000, 0x098081c8, 0x060e0408,
-	0x091e1248, 0x07c01fc9, 0x0c018200, 0x00000000, 0x064c2407,
-	0x0befc3c7, 0x078003c7, 0x0a6fc007, 0x00000000, 0x080c2130,
-	0x080c2800, 0x064c2408, 0x0befc3c8, 0x0c0104c0, 0x00000000,
-	0x07800007, 0x040011c7, 0x07c00007, 0x07801d08, 0x07801d47,
-	0x09421207, 0x07801d87, 0x09441207, 0x07c00308, 0x07800148,
-	0x0aa0c348, 0x07c00448, 0x0c7f5300, 0x078003c7, 0x0a6fc007,
-	0x00000000, 0x080c24e0, 0x064c2207, 0x064c2208, 0x080c24c0,
-	0x060c2207, 0x0c7f5b40, 0x060c2208, 0x0780044b, 0x0aa3834b,
-	0x00000000, 0x069fffc9, 0x04401249, 0x0aa1c009, 0x00000000,
-	0x064e160b, 0x090102cb, 0x0aaec00b, 0x0c780140, 0x00000000,
-	0x0809d501, 0x0c7fffc0, 0x00000000, 0x0681000b, 0x060e090b,
-	0x060e0a0b, 0x0cc00000, 0x060e0b0b, 0x064e0009, 0x064e0e0b,
-	0x064e0c0c, 0x083f0040, 0x083f0000, 0x0680020d, 0x0d00000d,
-	0x00000000, 0x060e0009, 0x060e0e0b, 0x0cc00000, 0x060e0c0c,
-	0x0683ffc9, 0x0aa18009, 0x0649470a, 0x0910828a, 0x07800008,
-	0x0a4fc20a, 0x04401249, 0x0cc00000, 0x00000000, 0x0c07fac0,
-	0x00000000, 0x06490b09, 0x09809009, 0x09809089, 0x06090b09,
-	0x09c09009, 0x09c09089, 0x06090b09, 0x08095007, 0x08095000,
-	0x0683ffc9, 0x06498f0a, 0x0aa0c009, 0x0a6f800a, 0x04401249,
-	0x06498e0a, 0x0980a00a, 0x068007c9, 0x09705289, 0x06098e0a,
-	0x06800009, 0x09705289, 0x09c0a00a, 0x06098e0a, 0x0681f409,
-	0x04601249, 0x0c4fffc0, 0x00000000, 0x0cc00000, 0x00000000,
-	0x0a241007, 0x0c07f5c0, 0x00000000, 0x064c000a, 0x09c0a18a,
-	0x0980a20a, 0x0980a00a, 0x060c000a, 0x064c080a, 0x0980a34a,
-	0x060c080a, 0x0c07f580, 0x00000000, 0x080e1600, 0x0680000a,
-	0x07c003ca, 0x0fc081c0, 0x0a60ad87, 0x0c783180, 0x0a60ec47,
-	0x06800047, 0x07c001c7, 0x0c787400, 0x0c7873c0, 0x0c787380,
-	0x00000000, 0x00000000, 0x0fc0a1c0, 0x06800048, 0x0a210047,
-	0x06800047, 0x0fc041c0, 0x0fc03200, 0x07c01807, 0x07c01848,
-	0x0fc041c0, 0x0609c507, 0x0a6103c7, 0x07c01887, 0x0fc101c0,
-	0x0609c507, 0x0fc011c0, 0x0aa30007, 0x00000000, 0x0fc021c0,
-	0x07c018c7, 0x0fc021c0, 0x0a21c047, 0x00000000, 0x0fc101c0,
-	0x0fc101c0, 0x0fc101c0, 0x0fc0f1c0, 0x0fc101c0, 0x0fc021c0,
-	0x0aa0c007, 0x0c7f3740, 0x00000000, 0x0fc011c0, 0x0fc101c0,
-	0x07c01907, 0x0649c308, 0x09410207, 0x0609c308, 0x0b220087,
-	0x06800048, 0x06800008, 0x06800049, 0x0b004247, 0x05401249,
-	0x0c7fff80, 0x04001208, 0x07c01408, 0x0fc021c0, 0x0a21c047,
-	0x07801407, 0x0f8001c7, 0x07c01447, 0x0649c309, 0x09610247,
-	0x0609c309, 0x0fc011c0, 0x0fc0d1c0, 0x0fc01240, 0x0fc0d200,
-	0x0fc01240, 0x0401f287, 0x0580528a, 0x0403e247, 0x05806249,
-	0x09610289, 0x0649c709, 0x09610247, 0x0609c709, 0x0400f1c7,
-	0x058041c7, 0x060c0907, 0x07c00987, 0x04401247, 0x07c00609,
-	0x05404287, 0x0649c707, 0x094101c8, 0x0609c707, 0x0400f208,
-	0x05804208, 0x07c009c8, 0x05404208, 0x0961020a, 0x06090808,
-	0x0fc011c0, 0x07c01c07, 0x06800007, 0x07c01d07, 0x060c0307,
-	0x0fc011c0, 0x0aa14007, 0x07801807, 0x0a610047, 0x0c780100,
-	0x0fc011c0, 0x0c7fefc0, 0x0fc021c0, 0x07c01947, 0x0aa10007,
-	0x0a6f0087, 0x00000000, 0x0fc091c0, 0x07c01e47, 0x0fc011c0,
-	0x0a6dc007, 0x0fc011c0, 0x0a608007, 0x0c780c80, 0x07c01987,
-	0x06800008, 0x0fc011c0, 0x0aa58007, 0x00000000, 0x06490907,
-	0x0befc047, 0x06801007, 0x0fc08240, 0x0aa20009, 0x044011c7,
-	0x0fc08280, 0x0aa1c00a, 0x09508289, 0x0d07fe87, 0x060e020a,
-	0x0c780200, 0x0c7800c0, 0x0950828a, 0x09408289, 0x040011c7,
-	0x058011c7, 0x0d000007, 0x060e020a, 0x04c10208, 0x0fc011c0,
-	0x0aa58007, 0x06801007, 0x06490907, 0x0befc047, 0x06801007,
-	0x0fc08240, 0x0aa20009, 0x044011c7, 0x0fc08280, 0x0aa1c00a,
-	0x09508289, 0x0d07fe87, 0x060e030a, 0x0c780200, 0x0c7800c0,
-	0x0950828a, 0x09408289, 0x040011c7, 0x058011c7, 0x0d000007,
-	0x060e030a, 0x04c08208, 0x060e0008, 0x07801807, 0x0aa18047,
-	0x00000000, 0x0fc011c0, 0x0540b1c7, 0x09807007, 0x060c0107,
-	0x0fc011c0, 0x0aa60007, 0x0fc011c0, 0x07c00347, 0x0aa0c047,
-	0x0c014180, 0x00000000, 0x0fc011c0, 0x0a20c047, 0x00000000,
-	0x0fc011c0, 0x07801807, 0x06800008, 0x0aa18047, 0x06800007,
-	0x0fc011c0, 0x0a624007, 0x0fc01200, 0x0a61c008, 0x07c01a07,
-	0x07c01a48, 0x0fc011c0, 0x046011c7, 0x0c57e900, 0x0c784400,
-	0x0c7fd840, 0x064c5126, 0x064c4627, 0x07800708, 0x05410208,
-	0x078006c9, 0x02008248, 0x0580a208, 0x0e000988, 0x00000000,
-	0x00000000, 0x00000000, 0x0f000200, 0x0f010980, 0x09708226,
-	0x0540a208, 0x020089c8, 0x064c4326, 0x02408988, 0x064c4026,
-	0x02408988, 0x07c00b48, 0x05810208, 0x07c00b88, 0x0fc081c0,
-	0x0fc10480, 0x0fc104c0, 0x040001d3, 0x096101d2, 0x06090807,
-	0x0400f492, 0x05804492, 0x060c0912, 0x07c00992, 0x0400f4d3,
-	0x058044d3, 0x07c009d3, 0x06800007, 0x060c0307, 0x0fc08800,
-	0x0fc081c0, 0x07c01b07, 0x06800047, 0x060c0a07, 0x06820207,
-	0x060e0407, 0x06800025, 0x06490908, 0x0ae10225, 0x00000000,
-	0x0bef4048, 0x0c780080, 0x0c7f0240, 0x0683ffc7, 0x0649bb08,
-	0x0900c208, 0x0aa10008, 0x0aa0c007, 0x0c7fff00, 0x044011c7,
-	0x06490b07, 0x09807007, 0x06090b07, 0x06090b07, 0x09c07007,
-	0x06090b07, 0x0649c909, 0x0aa10009, 0x06800087, 0x0c7ef740,
-	0x07c01507, 0x07801487, 0x0a608007, 0x0c780bc0, 0x044011c7,
+	0x060e0408, 0x091e1248, 0x07c01fc9, 0x0c018300, 0x00000000,
+	0x064c2407, 0x0befc3c7, 0x078003c7, 0x0a6fc007, 0x00000000,
+	0x080c2130, 0x080c2800, 0x064c2408, 0x0befc3c8, 0x0c0105c0,
+	0x00000000, 0x07800007, 0x040011c7, 0x07c00007, 0x07801d08,
+	0x07801d47, 0x09421207, 0x07801d87, 0x09441207, 0x07c00308,
+	0x07800148, 0x0aa0c348, 0x07c00448, 0x0c7f52c0, 0x078003c7,
+	0x0a6fc007, 0x00000000, 0x080c24e0, 0x064c2207, 0x064c2208,
+	0x080c24c0, 0x060c2207, 0x0c7f5b00, 0x060c2208, 0x0780044b,
+	0x0aa3834b, 0x00000000, 0x069fffc9, 0x04401249, 0x0aa1c009,
+	0x00000000, 0x064e160b, 0x090102cb, 0x0aaec00b, 0x0c780140,
+	0x00000000, 0x0809d501, 0x0c7fffc0, 0x00000000, 0x0681000b,
+	0x060e090b, 0x060e0a0b, 0x0cc00000, 0x060e0b0b, 0x064e0009,
+	0x064e0e0b, 0x064e0c0c, 0x083f0040, 0x083f0000, 0x0680020d,
+	0x0d00000d, 0x00000000, 0x060e0009, 0x060e0e0b, 0x0cc00000,
+	0x060e0c0c, 0x0683ffc9, 0x0aa18009, 0x0649470a, 0x0910828a,
+	0x07800008, 0x0a4fc20a, 0x04401249, 0x0cc00000, 0x00000000,
+	0x0c07fac0, 0x00000000, 0x06490b09, 0x09809009, 0x09809089,
+	0x06090b09, 0x09c09009, 0x09c09089, 0x06090b09, 0x08095007,
+	0x08095000, 0x0683ffc9, 0x06498f0a, 0x0aa0c009, 0x0a6f800a,
+	0x04401249, 0x06498e0a, 0x0980a00a, 0x068007c9, 0x09705289,
+	0x06098e0a, 0x06800009, 0x09705289, 0x09c0a00a, 0x06098e0a,
+	0x0681f409, 0x04601249, 0x0c4fffc0, 0x00000000, 0x0cc00000,
+	0x00000000, 0x0a241007, 0x0c07f5c0, 0x00000000, 0x064c000a,
+	0x09c0a18a, 0x0980a20a, 0x0980a00a, 0x060c000a, 0x064c080a,
+	0x0980a34a, 0x060c080a, 0x0c07f580, 0x00000000, 0x080e1600,
+	0x0680000a, 0x07c003ca, 0x0fc081c0, 0x0a60ad87, 0x0c783180,
+	0x0a60ec47, 0x06800047, 0x07c001c7, 0x0c787500, 0x0c7874c0,
+	0x0c787480, 0x00000000, 0x00000000, 0x0fc0a1c0, 0x06800048,
+	0x0a210047, 0x06800047, 0x0fc041c0, 0x0fc03200, 0x07c01807,
+	0x07c01848, 0x0fc041c0, 0x0609c507, 0x0a6103c7, 0x07c01887,
+	0x0fc101c0, 0x0609c507, 0x0fc011c0, 0x0aa30007, 0x00000000,
+	0x0fc021c0, 0x07c018c7, 0x0fc021c0, 0x0a21c047, 0x00000000,
+	0x0fc101c0, 0x0fc101c0, 0x0fc101c0, 0x0fc0f1c0, 0x0fc101c0,
+	0x0fc021c0, 0x0aa0c007, 0x0c7f3700, 0x00000000, 0x0fc011c0,
+	0x0fc101c0, 0x07c01907, 0x0649c308, 0x09410207, 0x0609c308,
+	0x0b220087, 0x06800048, 0x06800008, 0x06800049, 0x0b004247,
+	0x05401249, 0x0c7fff80, 0x04001208, 0x07c01408, 0x0fc021c0,
+	0x0a21c047, 0x07801407, 0x0f8001c7, 0x07c01447, 0x0649c309,
+	0x09610247, 0x0609c309, 0x0fc011c0, 0x0fc0d1c0, 0x0fc01240,
+	0x0fc0d200, 0x0fc01240, 0x0401f287, 0x0580528a, 0x0403e247,
+	0x05806249, 0x09610289, 0x0649c709, 0x09610247, 0x0609c709,
+	0x0400f1c7, 0x058041c7, 0x060c0907, 0x07c00987, 0x04401247,
+	0x07c00609, 0x05404287, 0x0649c707, 0x094101c8, 0x0609c707,
+	0x0400f208, 0x05804208, 0x07c009c8, 0x05404208, 0x0961020a,
+	0x06090808, 0x0fc011c0, 0x07c01c07, 0x06800007, 0x07c01d07,
+	0x060c0307, 0x0fc011c0, 0x0aa14007, 0x07801807, 0x0a610047,
+	0x0c780100, 0x0fc011c0, 0x0c7fefc0, 0x0fc021c0, 0x07c01947,
+	0x0aa10007, 0x0a6f0087, 0x00000000, 0x0fc091c0, 0x07c01e47,
+	0x0fc011c0, 0x0a6dc007, 0x0fc011c0, 0x0a608007, 0x0c780c80,
+	0x07c01987, 0x06800008, 0x0fc011c0, 0x0aa58007, 0x00000000,
+	0x06490907, 0x0befc047, 0x06801007, 0x0fc08240, 0x0aa20009,
+	0x044011c7, 0x0fc08280, 0x0aa1c00a, 0x09508289, 0x0d07fe87,
+	0x060e020a, 0x0c780200, 0x0c7800c0, 0x0950828a, 0x09408289,
+	0x040011c7, 0x058011c7, 0x0d000007, 0x060e020a, 0x04c10208,
+	0x0fc011c0, 0x0aa58007, 0x06801007, 0x06490907, 0x0befc047,
+	0x06801007, 0x0fc08240, 0x0aa20009, 0x044011c7, 0x0fc08280,
+	0x0aa1c00a, 0x09508289, 0x0d07fe87, 0x060e030a, 0x0c780200,
+	0x0c7800c0, 0x0950828a, 0x09408289, 0x040011c7, 0x058011c7,
+	0x0d000007, 0x060e030a, 0x04c08208, 0x060e0008, 0x07801807,
+	0x0aa18047, 0x00000000, 0x0fc011c0, 0x0540b1c7, 0x09807007,
+	0x060c0107, 0x0fc011c0, 0x0aa60007, 0x0fc011c0, 0x07c00347,
+	0x0aa0c047, 0x0c014280, 0x00000000, 0x0fc011c0, 0x0a20c047,
+	0x00000000, 0x0fc011c0, 0x07801807, 0x06800008, 0x0aa18047,
+	0x06800007, 0x0fc011c0, 0x0a624007, 0x0fc01200, 0x0a61c008,
+	0x07c01a07, 0x07c01a48, 0x0fc011c0, 0x046011c7, 0x0c57e900,
+	0x0c784500, 0x0c7fd840, 0x064c5126, 0x064c4627, 0x07800708,
+	0x05410208, 0x078006c9, 0x02008248, 0x0580a208, 0x0e000988,
+	0x00000000, 0x00000000, 0x00000000, 0x0f000200, 0x0f010980,
+	0x09708226, 0x0540a208, 0x020089c8, 0x064c4326, 0x02408988,
+	0x064c4026, 0x02408988, 0x07c00b48, 0x05810208, 0x07c00b88,
+	0x0fc081c0, 0x0fc10480, 0x0fc104c0, 0x040001d3, 0x096101d2,
+	0x06090807, 0x0400f492, 0x05804492, 0x060c0912, 0x07c00992,
+	0x0400f4d3, 0x058044d3, 0x07c009d3, 0x06800007, 0x060c0307,
+	0x0fc08800, 0x0fc081c0, 0x07c01b07, 0x06800047, 0x060c0a07,
+	0x06820207, 0x060e0407, 0x06800025, 0x06490908, 0x0ae10225,
+	0x00000000, 0x0bef4048, 0x0c780080, 0x0c7f0200, 0x0683ffc7,
+	0x0649bb08, 0x0900c208, 0x0aa10008, 0x0aa0c007, 0x0c7fff00,
+	0x044011c7, 0x06490b07, 0x09807007, 0x06090b07, 0x06090b07,
+	0x09c07007, 0x06090b07, 0x0649c909, 0x0aa10009, 0x06800087,
+	0x0c7ef700, 0x07c01507, 0x07800047, 0x0ae0c047, 0x078001c7,
+	0x0aa1c047, 0x07801487, 0x0a608007, 0x0c780bc0, 0x044011c7,
 	0x040002c7, 0x07801589, 0x0b20c1c9, 0x00000000, 0x0c780a40,
 	0x07800fc8, 0x0609ca08, 0x07c00fdf, 0x0680420a, 0x02007289,
 	0x070001c7, 0x054101c7, 0x0680400a, 0x02008289, 0x07000208,
@@ -1912,7 +1913,7 @@ const u32 __initconst h263_mc[] = {
 	0x06800108, 0x078048ca, 0x07804908, 0x09610288, 0x0a240807,
 	0x06800148, 0x0780494a, 0x07804988, 0x09610288, 0x0a22d007,
 	0x06800188, 0x078049ca, 0x07804a08, 0x09610288, 0x0a21a007,
-	0x068001c8, 0x0809cd11, 0x06800047, 0x0c7ede80, 0x07c01507,
+	0x068001c8, 0x0809cd11, 0x06800047, 0x0c7edd40, 0x07c01507,
 	0x0809cd00, 0x07801607, 0x090041c7, 0x0a8041c8, 0x07801607,
 	0x090841c7, 0x0a4051c8, 0x06800047, 0x03407207, 0x0c7ff1c0,
 	0x02c091c9, 0x07800b47, 0x0680400f, 0x020093c8, 0x07400247,
@@ -1932,10 +1933,10 @@ const u32 __initconst h263_mc[] = {
 	0x054103cf, 0x07801c47, 0x0a614047, 0x00000000, 0x05810208,
 	0x0c7800c0, 0x00000000, 0x058103cf, 0x02c083c8, 0x06098108,
 	0x06499108, 0x05410208, 0x058103c8, 0x02c083c8, 0x06098208,
-	0x080980f4, 0x07801b07, 0x06800048, 0x09421207, 0x0c7ed7c0,
+	0x080980f4, 0x07801b07, 0x06800048, 0x09421207, 0x0c7ed680,
 	0x06090708, 0x06800025, 0x0ae20225, 0x064c0007, 0x0a2f8047,
 	0x00000000, 0x064c3a07, 0x090061c7, 0x0aae8647, 0x0c7800c0,
-	0x0c7ec940, 0x00000000, 0x080c2800, 0x080c0002, 0x0c7ec180,
+	0x0c7ec800, 0x00000000, 0x080c2800, 0x080c0002, 0x0c7ec040,
 	0x00000000, 0x0649c007, 0x07c04647, 0x058101c7, 0x07c04687,
 	0x0649c107, 0x07c046c7, 0x058101c7, 0x07c04707, 0x0649c207,
 	0x07c04747, 0x058101c7, 0x07c04787, 0x0649c307, 0x07c047c7,
@@ -1961,7 +1962,7 @@ const u32 __initconst h263_mc[] = {
 	0x080c2147, 0x064c2407, 0x0befc3c7, 0x078004c7, 0x07c00387,
 	0x07800487, 0x07c00247, 0x07801107, 0x07c01787, 0x06800107,
 	0x07c003c7, 0x0c0083c0, 0x00000000, 0x08030580, 0x07800007,
-	0x040011c7, 0x07c00007, 0x0c7eac00, 0x00000000, 0x0fc01200,
+	0x040011c7, 0x07c00007, 0x0c7eaac0, 0x00000000, 0x0fc01200,
 	0x0fc011c0, 0x0aa28047, 0x06800147, 0x0fc011c0, 0x0aa1c047,
 	0x06800187, 0x0fc011c0, 0x0aa10047, 0x068001c7, 0x0fc011c0,
 	0x06800207, 0x07c00147, 0x0a60c008, 0x06800007, 0x0fc061c0,
@@ -1969,7 +1970,7 @@ const u32 __initconst h263_mc[] = {
 	0x00000000, 0x0fc011c0, 0x0aa38007, 0x07800108, 0x0fc011c0,
 	0x0aa14007, 0x0b21c748, 0x04002208, 0x0c780140, 0x068007c8,
 	0x0b60c0c8, 0x04402208, 0x06800048, 0x07c00108, 0x0c0005c0,
-	0x040001c8, 0x0c7f1740, 0x00000000, 0x06a00007, 0x06e00007,
+	0x040001c8, 0x0c7f1640, 0x00000000, 0x06a00007, 0x06e00007,
 	0x080c24a0, 0x060c2207, 0x060c2207, 0x060c2207, 0x060c2207,
 	0x060c2207, 0x0cc00000, 0x060c2207, 0x07801988, 0x094c11c8,
 	0x0c07fd00, 0x060e0407, 0x06800007, 0x07c01cc7, 0x07c00907,
@@ -2018,7 +2019,7 @@ const u32 __initconst h263_mc[] = {
 	0x0c780140, 0x0440128a, 0x0fc01240, 0x0a6fc009, 0x0400128a,
 	0x06800049, 0x03409289, 0x05801249, 0x0f80028a, 0x0b40424a,
 	0x05401249, 0x04401249, 0x0240a24a, 0x0740020a, 0x0cc00000,
-	0x0fc01240, 0x064c441a, 0x0912169a, 0x0aaf801a, 0x0c7e5940,
+	0x0fc01240, 0x064c441a, 0x0912169a, 0x0aaf801a, 0x0c7e5800,
 	0x00000000, 0x06490628, 0x0aefcc28, 0x00000000, 0x07800028,
 	0x078016e9, 0x09508a68, 0x068000a8, 0x06c00028, 0x06090628,
 	0x06090629, 0x06881068, 0x06090628, 0x0cc00000, 0x00000000,
@@ -2030,7 +2031,7 @@ const u32 __initconst h263_mc[] = {
 	0x0c501a40, 0x0aa4802b, 0x0690002a, 0x0aa4006b, 0x0aa8c36b,
 	0x0aa883eb, 0x0aa3422b, 0x00000000, 0x06a0002a, 0x0aa281eb,
 	0x06c0002a, 0x06b0002a, 0x0aa1c1ab, 0x06c0002a, 0x04602aeb,
-	0x0c500980, 0x0690002a, 0x0c7e5240, 0x00000000, 0x06490628,
+	0x0c500980, 0x0690002a, 0x0c7e5100, 0x00000000, 0x06490628,
 	0x0aefcc28, 0x068000a8, 0x02c28aa8, 0x09441a30, 0x06090628,
 	0x06090629, 0x069fffeb, 0x06900028, 0x0a00ca2a, 0x080c2400,
 	0x080e1424, 0x064c2228, 0x060e1528, 0x060e1528, 0x060e1528,
@@ -2148,6 +2149,648 @@ const u32 __initconst h263_mc[] = {
 	0x0fc03200, 0x0fc03200, 0x0cc00000, 0x00000000
 };
 
+const u32 __initconst vmmpeg4_mc_5[] = {
+	0x0c000c80, 0x00000000, 0x0c001500, 0x00000000, 0x0c0144c0,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0c7ffe80,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x0c780400, 0x04001965, 0x0cc00000,
+	0x00400000, 0x0c781880, 0x064c0007, 0x0c799740, 0x06800025,
+	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
+	0x00400000, 0x0c79e980, 0x06800025, 0x0cc00000, 0x00400000,
+	0x0649c800, 0x0be1d000, 0x06807801, 0x06800000, 0x0d000001,
+	0x07400040, 0x0cc00000, 0x00000000, 0x0649cf00, 0x06800001,
+	0x02000040, 0x06035100, 0x06808000, 0x06035200, 0x06b00000,
+	0x06035000, 0x00000000, 0x06435000, 0x0580f000, 0x0bef8040,
+	0x0cc00000, 0x00000000, 0x0649cf00, 0x06800001, 0x02000040,
+	0x06035100, 0x06808000, 0x06035200, 0x06a00000, 0x06035000,
+	0x00000000, 0x06435000, 0x0580f000, 0x0bef8040, 0x0cc00000,
+	0x00000000, 0x0649c800, 0x0be0d000, 0x0cc00000, 0x00000000,
+	0x064e0000, 0x0a20c400, 0x0c0001c0, 0x0680000a, 0x0a20c200,
+	0x0c000100, 0x0680004a, 0x0cc00000, 0x00000000, 0x0649cf0b,
+	0x0682000c, 0x0200b30b, 0x0540628a, 0x0200b28b, 0x0603510b,
+	0x08035210, 0x06b0400b, 0x0603500b, 0x00000000, 0x0643500b,
+	0x0580f2cb, 0x0bef804b, 0x0cc00000, 0x00000000, 0x0649cf07,
+	0x0682000a, 0x02007287, 0x05406249, 0x02007247, 0x06035107,
+	0x08035210, 0x06a04007, 0x06035007, 0x00000000, 0x06435007,
+	0x0580f1c7, 0x0bef8047, 0x0cc00000, 0x00000000, 0x06800025,
+	0x00800000, 0x078017c9, 0x0c7feb00, 0x06030409, 0x06bfdd89,
+	0x06030409, 0x00400000, 0x07801509, 0x0a610049, 0x06800009,
+	0x0c78d080, 0x07c01509, 0x07801509, 0x0aa18109, 0x07c0151f,
+	0x0a2c0047, 0x06800025, 0x0a240807, 0x0c788b80, 0x00000000,
+	0x0683ffc8, 0x0ba20048, 0x064c0007, 0x0a2f8047, 0x04401208,
+	0x064c3a07, 0x090061c7, 0x0aae8647, 0x00000000, 0x06800007,
+	0x0c015d00, 0x07c003c7, 0x0c791980, 0x0bec9007, 0x078003c7,
+	0x0a6fc007, 0x07800007, 0x07800988, 0x0b823207, 0x06800007,
+	0x07c00007, 0x07801149, 0x0a628049, 0x06a00008, 0x06e00008,
+	0x06431e09, 0x0befc049, 0x00000000, 0x080c24a0, 0x060c2208,
+	0x0c780300, 0x060c2208, 0x0a628089, 0x00000000, 0x06431e09,
+	0x0befc049, 0x00000000, 0x080c24c0, 0x080c2200, 0x080c2200,
+	0x080c2200, 0x080c2200, 0x078016c8, 0x04001208, 0x078009c9,
+	0x0b80a248, 0x07c016c8, 0x0c01edc0, 0x00000000, 0x078003c7,
+	0x0a6fc007, 0x0c790fc0, 0x00000000, 0x06431e09, 0x0befc049,
+	0x07800347, 0x0a61c007, 0x00000000, 0x064c2907, 0x091c21c7,
+	0x0a60c0c7, 0x0c01f8c0, 0x00000000, 0x07801147, 0x0aa08087,
+	0x0c780f40, 0x078003c7, 0x0a6fc007, 0x07801bc8, 0x0a63c008,
+	0x078004c8, 0x0a634348, 0x06800107, 0x07c003c7, 0x08030580,
+	0x068003c9, 0x07c00149, 0x06800007, 0x0c0175c0, 0x07c01d07,
+	0x07800007, 0x040011c7, 0x0c7fef00, 0x07c00007, 0x0c791900,
+	0x078003c7, 0x0a6fc007, 0x078005c7, 0x0ba0c087, 0x06800007,
+	0x06800047, 0x07c01fc7, 0x07800787, 0x0aa180c7, 0x06810007,
+	0x060e0907, 0x060e0a07, 0x0c780440, 0x060e0b07, 0x07800507,
+	0x0aa0c007, 0x068000c8, 0x068003c8, 0x060e1408, 0x064e1507,
+	0x060e0907, 0x04003208, 0x060e1408, 0x064e1507, 0x060e0a07,
+	0x04003208, 0x060e1408, 0x064e1507, 0x060e0b07, 0x0683ffc7,
+	0x080e1418, 0x060e1507, 0x080e141b, 0x060e1507, 0x080e141e,
+	0x060e1507, 0x080e1421, 0x0c01db00, 0x060e1507, 0x0c785640,
+	0x00000000, 0x07801147, 0x0aa6c007, 0x00000000, 0x0fc011c0,
+	0x0aa64007, 0x080c2803, 0x06800347, 0x07c00147, 0x06431e07,
+	0x0befc047, 0x00000000, 0x080c24a0, 0x060c2224, 0x060c2224,
+	0x06800007, 0x07c01d07, 0x06800025, 0x064c3c07, 0x091011c7,
+	0x0ae1c225, 0x0aaf8007, 0x064c3c07, 0x091011c7, 0x0aae8007,
+	0x0c7fefc0, 0x080c2800, 0x0c7fd9c0, 0x00000000, 0x080c2801,
+	0x064c2807, 0x0a2fc047, 0x064c0008, 0x0a209008, 0x0c7fd800,
+	0x058011c7, 0x09004207, 0x07c00148, 0x090821c7, 0x07c00187,
+	0x0aa140c8, 0x080c2800, 0x0aa0c108, 0x0c781900, 0x00000000,
+	0x0fc011c0, 0x0540e1c7, 0x060c2d07, 0x080c2802, 0x064c2807,
+	0x0a2fc047, 0x058011c7, 0x07800188, 0x09444207, 0x07c01388,
+	0x07800148, 0x0a644108, 0x080c2800, 0x0fc021c0, 0x0b61c087,
+	0x07800109, 0x024091c9, 0x0b620089, 0x04401249, 0x0c780180,
+	0x06800049, 0x020091c9, 0x0b20c809, 0x04401249, 0x068007c9,
+	0x07c00109, 0x0c011ac0, 0x040001c9, 0x07801fcb, 0x0aa1400b,
+	0x078005c9, 0x0b60c089, 0x0c004900, 0x00000000, 0x068fdfca,
+	0x06feffca, 0x064e0408, 0x02808288, 0x078005ca, 0x0ba0c08a,
+	0x064c0909, 0x098083c8, 0x0ac0424a, 0x0780000a, 0x0a60c00a,
+	0x0400128a, 0x09808388, 0x0b80324a, 0x00000000, 0x098081c8,
+	0x07802007, 0x09605207, 0x07800007, 0x040811c7, 0x070001c7,
+	0x096a5207, 0x060e0408, 0x091e1248, 0x07c01fc9, 0x07801388,
+	0x060c2b08, 0x06880008, 0x098083c8, 0x07800507, 0x07801989,
+	0x0a610049, 0x09581207, 0x09808408, 0x098083c8, 0x060e0508,
+	0x06800009, 0x07800bc8, 0x09541248, 0x060c2a09, 0x07801c07,
+	0x0aa1c007, 0x080c2c03, 0x0fc011c0, 0x07c01cc7, 0x068000c9,
+	0x094a1247, 0x060c2c09, 0x0c01ba80, 0x00000000, 0x080c0080,
+	0x0c014200, 0x00000000, 0x080c24a0, 0x080c2200, 0x080c2200,
+	0x07800007, 0x040011c7, 0x07c00007, 0x07800147, 0x0c011b00,
+	0x07c00447, 0x0c7fb840, 0x00000000, 0x07801147, 0x0a60c0c7,
+	0x06800007, 0x0fc011c0, 0x07c01707, 0x080c2802, 0x064c2807,
+	0x0a2fc047, 0x058011c7, 0x068003c8, 0x024071c8, 0x07800188,
+	0x09444207, 0x07c01388, 0x07800148, 0x0a644048, 0x080c2800,
+	0x0fc021c0, 0x0b61c087, 0x07800109, 0x024091c9, 0x0b620089,
+	0x04401249, 0x0c780180, 0x06800049, 0x020091c9, 0x0b20c809,
+	0x04401249, 0x068007c9, 0x07c00109, 0x0c010140, 0x040001c9,
+	0x07801388, 0x060c2b08, 0x07801c07, 0x0a60c007, 0x0c7806c0,
+	0x06800009, 0x0aa10008, 0x080c2800, 0x0fc011c0, 0x07c01cc7,
+	0x07800148, 0x0aa14088, 0x06800009, 0x0aa0c148, 0x07800489,
+	0x0fc01240, 0x07c01d09, 0x0aa38009, 0x0aa34148, 0x0aa201c8,
+	0x00000000, 0x0fc011c0, 0x07c01d47, 0x0fc011c0, 0x07c01d87,
+	0x0a618188, 0x00000000, 0x0fc011c0, 0x07c01dc7, 0x0fc011c0,
+	0x07c01e07, 0x07800148, 0x09501209, 0x07801709, 0x09521209,
+	0x060c2108, 0x07801cc8, 0x05405208, 0x060c2c08, 0x06880008,
+	0x07801989, 0x0aa0c049, 0x07800507, 0x098083c8, 0x09581207,
+	0x060e0508, 0x06800009, 0x07800bc8, 0x09541248, 0x060c2a09,
+	0x064c2408, 0x0befc3c8, 0x078003c8, 0x0a6fc008, 0x00000000,
+	0x080c0080, 0x07801147, 0x0aa08087, 0x0c7812c0, 0x080c2110,
+	0x07800147, 0x0aa38147, 0x078004c7, 0x07c00387, 0x07800487,
+	0x07c00247, 0x07801107, 0x07c01787, 0x06800107, 0x07c003c7,
+	0x08030580, 0x064c2407, 0x0befc3c7, 0x0c780b80, 0x080c2130,
+	0x064c2407, 0x0befc3c7, 0x078004c8, 0x080e1401, 0x080c2440,
+	0x064e1507, 0x0aa400c8, 0x0aa54088, 0x060c2207, 0x07800487,
+	0x0aa28007, 0x07801107, 0x064e1508, 0x060c2208, 0x07801c48,
+	0x094411c8, 0x068010c8, 0x09503207, 0x0c780440, 0x060c2108,
+	0x0c7803c0, 0x080c2141, 0x080c2200, 0x080c2200, 0x080c2200,
+	0x080c2200, 0x0c780240, 0x080c2141, 0x064e1507, 0x060c2207,
+	0x064e1507, 0x060c2207, 0x064e1507, 0x060c2207, 0x080c2147,
+	0x078004c7, 0x07c00387, 0x07800487, 0x07c00247, 0x07801107,
+	0x07c01787, 0x06800107, 0x07c003c7, 0x08030580, 0x064c2407,
+	0x0befc3c7, 0x00000000, 0x07800147, 0x0aa10147, 0x0c011f40,
+	0x00000000, 0x0c7800c0, 0x0c014580, 0x00000000, 0x07800007,
+	0x040011c7, 0x0c7f8f00, 0x07c00007, 0x07801fcb, 0x0aa1400b,
+	0x078005c9, 0x0b60c089, 0x0c000e40, 0x00000000, 0x068fdfca,
+	0x06feffca, 0x064e0408, 0x02808288, 0x078005ca, 0x0ba0c08a,
+	0x064c0909, 0x098083c8, 0x0ac0424a, 0x0780000a, 0x0a60c00a,
+	0x0400128a, 0x09808388, 0x0b80324a, 0x00000000, 0x098081c8,
+	0x060e0408, 0x091e1248, 0x07c01fc9, 0x0c018700, 0x00000000,
+	0x064c2407, 0x0befc3c7, 0x078003c7, 0x0a6fc007, 0x00000000,
+	0x080c2130, 0x080c2800, 0x064c2408, 0x0befc3c8, 0x0c011400,
+	0x00000000, 0x07800007, 0x040011c7, 0x07c00007, 0x07801d08,
+	0x07801d47, 0x09421207, 0x07801d87, 0x09441207, 0x07c00308,
+	0x07800148, 0x0aa0c348, 0x07c00448, 0x0c7f8200, 0x078003c7,
+	0x0a6fc007, 0x00000000, 0x080c24e0, 0x064c2207, 0x064c2208,
+	0x080c24c0, 0x060c2207, 0x0c7f8880, 0x060c2208, 0x0780044b,
+	0x0aa1034b, 0x064e160b, 0x090102cb, 0x0aaf800b, 0x0681000b,
+	0x060e090b, 0x060e0a0b, 0x0cc00000, 0x060e0b0b, 0x064e0009,
+	0x064e0e0b, 0x064e0c0c, 0x083f0040, 0x083f0000, 0x0680020d,
+	0x0d00000d, 0x00000000, 0x060e0009, 0x060e0e0b, 0x0cc00000,
+	0x060e0c0c, 0x0683ffc9, 0x0aa18009, 0x0649470a, 0x0910828a,
+	0x07800008, 0x0a4fc20a, 0x04401249, 0x0cc00000, 0x00000000,
+	0x0c07fac0, 0x00000000, 0x06490b09, 0x09809009, 0x09809089,
+	0x06090b09, 0x09c09009, 0x09c09089, 0x06090b09, 0x08095007,
+	0x08095000, 0x0683ffc9, 0x06498f0a, 0x0aa0c009, 0x0a6f800a,
+	0x04401249, 0x06498e0a, 0x0980a00a, 0x068007c9, 0x09705289,
+	0x06098e0a, 0x06800009, 0x09705289, 0x09c0a00a, 0x06098e0a,
+	0x0681f409, 0x04601249, 0x0c4fffc0, 0x00000000, 0x0cc00000,
+	0x00000000, 0x0a241007, 0x0c07f5c0, 0x00000000, 0x064c000a,
+	0x09c0a18a, 0x0980a20a, 0x0980a00a, 0x060c000a, 0x064c080a,
+	0x0980a34a, 0x060c080a, 0x0c07f580, 0x00000000, 0x080e1600,
+	0x0680000a, 0x07c003ca, 0x0fc081c0, 0x0b2247c7, 0x0b230bc7,
+	0x0aa22c87, 0x0a60ad87, 0x0c7836c0, 0x0a60ec47, 0x06800047,
+	0x07c001c7, 0x0c788b40, 0x0c788b00, 0x0c788ac0, 0x00000000,
+	0x00000000, 0x0fc0a1c0, 0x06800048, 0x0a210047, 0x06800047,
+	0x0fc041c0, 0x0fc03200, 0x07c01807, 0x07c01848, 0x0fc041c0,
+	0x0609c507, 0x0a6103c7, 0x07c01887, 0x0fc101c0, 0x0609c507,
+	0x0fc011c0, 0x0aa30007, 0x00000000, 0x0fc021c0, 0x07c018c7,
+	0x0fc021c0, 0x0a21c047, 0x00000000, 0x0fc101c0, 0x0fc101c0,
+	0x0fc101c0, 0x0fc0f1c0, 0x0fc101c0, 0x0fc021c0, 0x0aa0c007,
+	0x0c7f6640, 0x00000000, 0x0fc011c0, 0x0fc101c0, 0x07c01907,
+	0x0649c308, 0x09410207, 0x0609c308, 0x0b220087, 0x06800048,
+	0x06800008, 0x06800049, 0x0b004247, 0x05401249, 0x0c7fff80,
+	0x04001208, 0x07c01408, 0x0fc021c0, 0x0a21c047, 0x07801407,
+	0x0f8001c7, 0x07c01447, 0x0649c309, 0x09610247, 0x0609c309,
+	0x0fc011c0, 0x0fc0d1c0, 0x0fc01240, 0x0fc0d200, 0x0fc01240,
+	0x0401f287, 0x0580528a, 0x0403e247, 0x05806249, 0x09610289,
+	0x0649c709, 0x09610247, 0x0609c709, 0x0400f1c7, 0x058041c7,
+	0x060c0907, 0x07c00987, 0x04401247, 0x07c00609, 0x05404287,
+	0x0649c707, 0x094101c8, 0x0609c707, 0x0400f208, 0x05804208,
+	0x07c009c8, 0x05404208, 0x0961020a, 0x06090808, 0x0fc011c0,
+	0x07c01c07, 0x06800007, 0x07c01d07, 0x060c0307, 0x0fc011c0,
+	0x0aa14007, 0x07801807, 0x0a610047, 0x0c780100, 0x0fc011c0,
+	0x0c7fefc0, 0x0fc021c0, 0x07c01947, 0x0aa10007, 0x0a6f0087,
+	0x00000000, 0x0fc091c0, 0x07c01e47, 0x0fc011c0, 0x0a6dc007,
+	0x0fc011c0, 0x0a608007, 0x0c7811c0, 0x07c01987, 0x06800008,
+	0x0fc011c0, 0x0a60c007, 0x0c780800, 0x00000000, 0x06490907,
+	0x0befc047, 0x06801007, 0x06800009, 0x06c00049, 0x060e0209,
+	0x0680400b, 0x0fc08240, 0x0aa28009, 0x044011c7, 0x0fc08280,
+	0x0aa2400a, 0x09508289, 0x074002ca, 0x040012cb, 0x0d07fe07,
+	0x060e020a, 0x0c780280, 0x0c7800c0, 0x0950828a, 0x09408289,
+	0x040011c7, 0x058011c7, 0x074002ca, 0x040012cb, 0x0d07ff87,
+	0x060e020a, 0x04c10208, 0x0c074140, 0x06800009, 0x0fc011c0,
+	0x0aa78007, 0x06801007, 0x06490907, 0x0befc047, 0x06801007,
+	0x06800009, 0x06c00049, 0x060e0209, 0x0680400b, 0x0fc08240,
+	0x0aa28009, 0x044011c7, 0x0fc08280, 0x0aa2400a, 0x09508289,
+	0x074002ca, 0x040012cb, 0x0d07fe07, 0x060e030a, 0x0c780280,
+	0x0c7800c0, 0x0950828a, 0x09408289, 0x040011c7, 0x058011c7,
+	0x074002ca, 0x040012cb, 0x0d07ff87, 0x060e030a, 0x04c08208,
+	0x060e0008, 0x0c0738c0, 0x06800049, 0x07801807, 0x0aa18047,
+	0x00000000, 0x0fc011c0, 0x0540b1c7, 0x09807007, 0x060c0107,
+	0x0fc011c0, 0x0aa60007, 0x0fc011c0, 0x07c00347, 0x0aa0c047,
+	0x0c014300, 0x00000000, 0x0fc011c0, 0x0a20c047, 0x00000000,
+	0x0fc011c0, 0x07801807, 0x06800008, 0x0aa18047, 0x06800007,
+	0x0fc011c0, 0x0a624007, 0x0fc01200, 0x0a61c008, 0x07c01a07,
+	0x07c01a48, 0x0fc011c0, 0x046011c7, 0x0c57e3c0, 0x0c785600,
+	0x0c7fd300, 0x07801488, 0x0a60c008, 0x0c780680, 0x00000000,
+	0x07800fc8, 0x0609ca08, 0x07c00fdf, 0x06800b87, 0x070001c7,
+	0x054101c7, 0x06800b48, 0x07000208, 0x094101c8, 0x0609cc07,
+	0x07801ac7, 0x0609cb07, 0x068000c9, 0x06800a48, 0x07000208,
+	0x09464248, 0x07801c08, 0x094e1248, 0x0c072000, 0x00800000,
+	0x0609c909, 0x08007401, 0x0c780000, 0x00800000, 0x064c5126,
+	0x064c4627, 0x07800708, 0x05410208, 0x078006c9, 0x02008248,
+	0x0580a208, 0x0e000988, 0x00000000, 0x00000000, 0x00000000,
+	0x0f000200, 0x0f010980, 0x09708226, 0x0540a208, 0x020089c8,
+	0x064c4326, 0x02408988, 0x064c4026, 0x02408988, 0x07c00b48,
+	0x05810208, 0x07c00b88, 0x06800007, 0x07c003c7, 0x06800007,
+	0x07c00007, 0x07c01707, 0x07c00507, 0x07c016c7, 0x06800047,
+	0x07c00587, 0x07800607, 0x040021c7, 0x07c005c7, 0x0fc021c0,
+	0x07c01147, 0x06800023, 0x06800024, 0x0aa1c087, 0x06801848,
+	0x06800048, 0x0a60c0c7, 0x06800009, 0x06800049, 0x07c01bc9,
+	0x07c00288, 0x06800008, 0x0fc011c0, 0x0aa0c007, 0x0c7fff80,
+	0x04001208, 0x07c01a88, 0x0fc011c0, 0x07801409, 0x0a670009,
+	0x00000000, 0x064c2a0a, 0x064c360b, 0x0901028a, 0x0540828a,
+	0x058082cb, 0x0940828b, 0x06800009, 0x0ae4c3c9, 0x0540128a,
+	0x0780114b, 0x0aa1804b, 0x04001249, 0x092652ca, 0x0481f2cb,
+	0x0aa1860b, 0x0c7ffe00, 0x092462ca, 0x048372cb, 0x0aa08c0b,
+	0x0c7ffd00, 0x0649ce07, 0x0683e908, 0x0a403207, 0x0bac03c9,
+	0x00000000, 0x07c01409, 0x0f8001c9, 0x07c01ac7, 0x07801148,
+	0x0a624088, 0x07801088, 0x0b814207, 0x02407207, 0x07801908,
+	0x0c780440, 0x02407207, 0x0c7fb480, 0x00000000, 0x07801a88,
+	0x0ae14048, 0x0aa10008, 0x07801088, 0x07801909, 0x02007247,
+	0x02407207, 0x07801ac8, 0x07c01088, 0x06800008, 0x07c01008,
+	0x0c780540, 0x07c010c7, 0x07801008, 0x04001208, 0x0ae44048,
+	0x07c01008, 0x078010c9, 0x02007247, 0x0b21c007, 0x0b406247,
+	0x0b406247, 0x00000000, 0x024091c9, 0x0c7fff40, 0x04080208,
+	0x0c7f13c0, 0x058011c7, 0x0b403247, 0x00000000, 0x04080208,
+	0x07c01008, 0x090071c8, 0x090e7208, 0x09545207, 0x060e0708,
+	0x0fc011c0, 0x0fc011c0, 0x0a620007, 0x078013c8, 0x0aa0c088,
+	0x07800fc8, 0x04001208, 0x07c00fc8, 0x0c782bc0, 0x00000000,
+	0x07801147, 0x07c013c7, 0x0aa0c0c7, 0x0a60c047, 0x06800007,
+	0x0fc011c0, 0x07c01b07, 0x0fc031c0, 0x07c000c7, 0x07801c07,
+	0x0aa20007, 0x00000000, 0x0fc011c0, 0x07c01c47, 0x0fc011c0,
+	0x07c01c87, 0x054021c7, 0x060c0307, 0x07801147, 0x0a6740c7,
+	0x07801e47, 0x0aa6c007, 0x09066207, 0x0aa08088, 0x0c7fa280,
+	0x0c007e00, 0x06801ec8, 0x07901ee3, 0x06801409, 0x09510263,
+	0x060c2109, 0x0c007c80, 0x06801f08, 0x07901f08, 0x06801809,
+	0x09510248, 0x060c2109, 0x096108c8, 0x0c007ac0, 0x06801f48,
+	0x0c007a40, 0x06801f88, 0x05401923, 0x09c24424, 0x0942f923,
+	0x0a20c047, 0x0c7f9d00, 0x00000000, 0x0fc051c0, 0x0c004e40,
+	0x07c00107, 0x0c004b80, 0x00000000, 0x07801147, 0x0a618087,
+	0x078003c7, 0x0a6fc007, 0x06800107, 0x07c003c7, 0x08030580,
+	0x07801149, 0x0aa28009, 0x06800048, 0x0a610089, 0x0fc03200,
+	0x0fc03240, 0x07c01b89, 0x07c01b48, 0x09503248, 0x09809149,
+	0x060c2109, 0x060c0e08, 0x06800025, 0x06490908, 0x0ae10225,
+	0x00000000, 0x0bef4048, 0x0c780080, 0x0c7efb00, 0x0683ffc7,
+	0x0649bb08, 0x0900c208, 0x0aa10008, 0x0aa0c007, 0x0c7fff00,
+	0x044011c7, 0x06490b07, 0x09807007, 0x06090b07, 0x06090b07,
+	0x09c07007, 0x06090b07, 0x06800009, 0x07c01509, 0x07801c47,
+	0x054031c7, 0x07801148, 0x02c07207, 0x06800a49, 0x07400247,
+	0x04001248, 0x07c01489, 0x0a640088, 0x06bfffc7, 0x06c03fc7,
+	0x0649c108, 0x09018208, 0x0a8091c8, 0x0649c208, 0x09018208,
+	0x0a8061c8, 0x0649c107, 0x06099007, 0x0649c207, 0x0c780200,
+	0x06099107, 0x0c780e40, 0x00000000, 0x0649c207, 0x06099007,
+	0x0649b207, 0x06099107, 0x08098002, 0x07801c07, 0x0aa64047,
+	0x00000000, 0x07801d07, 0x0aa58047, 0x00000000, 0x06499008,
+	0x05410208, 0x058103c8, 0x02c083c8, 0x06098108, 0x06499108,
+	0x05410208, 0x058103c8, 0x02c083c8, 0x06098208, 0x080980f0,
+	0x07801c07, 0x0aa6c007, 0x00000000, 0x07801d07, 0x0aa60007,
+	0x00000000, 0x080980f4, 0x0c780540, 0x00000000, 0x06499008,
+	0x05410208, 0x0649b10f, 0x054103cf, 0x07801c47, 0x0a614047,
+	0x00000000, 0x05810208, 0x0c7800c0, 0x00000000, 0x058103cf,
+	0x02c083c8, 0x06098108, 0x06499108, 0x05410208, 0x058103c8,
+	0x02c083c8, 0x06098208, 0x080980f4, 0x07801b07, 0x06800048,
+	0x09421207, 0x0c7ef1c0, 0x06090708, 0x06800025, 0x0ae20225,
+	0x064c0007, 0x0a2f8047, 0x00000000, 0x064c3a07, 0x090061c7,
+	0x0aae8647, 0x0c7800c0, 0x0c7ee100, 0x00000000, 0x080c2800,
+	0x080c0002, 0x0c7edb00, 0x00000000, 0x0c0047c0, 0x06800025,
+	0x08002501, 0x08002605, 0x08002708, 0x08002815, 0x08002c14,
+	0x08002a09, 0x08002b17, 0x06830002, 0x06032602, 0x08032261,
+	0x08032101, 0x06bfdc80, 0x07c017c0, 0x06030400, 0x00400000,
+	0x0649c800, 0x0a22e000, 0x04807000, 0x0aa10000, 0x04401000,
+	0x0c7fff80, 0x0fc08040, 0x06800000, 0x07c01500, 0x080c0002,
+	0x0cc00000, 0x080c2901, 0x0649c800, 0x0be09000, 0x0c7ffe40,
+	0x06800040, 0x07c01500, 0x06800100, 0x0cc00000, 0x06030500,
+	0x080c2804, 0x064c2807, 0x0a2fc047, 0x05801207, 0x080c2800,
+	0x0aa14008, 0x0b21004a, 0x044011ca, 0x0f8001c7, 0x094e9207,
+	0x0cc00000, 0x07400248, 0x080c2804, 0x064c2807, 0x0a2fc047,
+	0x05801207, 0x0cc00000, 0x07400248, 0x0fc011c0, 0x0a608007,
+	0x0c780ec0, 0x06800247, 0x07c00147, 0x07800488, 0x095011c8,
+	0x060c2107, 0x080e1401, 0x080c2440, 0x064e1507, 0x078004c8,
+	0x0aa400c8, 0x0aa54088, 0x060c2207, 0x07800487, 0x0aa28007,
+	0x07801107, 0x064e1508, 0x060c2208, 0x07801c48, 0x094411c8,
+	0x068010c8, 0x09503207, 0x0c780440, 0x060c2108, 0x0c7803c0,
+	0x080c2141, 0x080c2200, 0x080c2200, 0x080c2200, 0x080c2200,
+	0x0c780240, 0x080c2141, 0x064e1507, 0x060c2207, 0x064e1507,
+	0x060c2207, 0x064e1507, 0x060c2207, 0x080c2147, 0x064c2407,
+	0x0befc3c7, 0x078004c7, 0x07c00387, 0x07800487, 0x07c00247,
+	0x07801107, 0x07c01787, 0x06800107, 0x07c003c7, 0x0c007580,
+	0x00000000, 0x08030580, 0x07800007, 0x040011c7, 0x07c00007,
+	0x06431e07, 0x0befc047, 0x0c7ec6c0, 0x00000000, 0x0fc01200,
+	0x0fc011c0, 0x0aa28047, 0x06800147, 0x0fc011c0, 0x0aa1c047,
+	0x06800187, 0x0fc011c0, 0x0aa10047, 0x068001c7, 0x0fc011c0,
+	0x06800207, 0x07c00147, 0x0a60c008, 0x06800007, 0x0fc061c0,
+	0x07c01387, 0x07800147, 0x0aa4c147, 0x07801387, 0x0aa44007,
+	0x00000000, 0x0fc011c0, 0x0aa38007, 0x07800108, 0x0fc011c0,
+	0x0aa14007, 0x0b21c748, 0x04002208, 0x0c780140, 0x068007c8,
+	0x0b60c0c8, 0x04402208, 0x06800048, 0x07c00108, 0x0c0005c0,
+	0x040001c8, 0x0c7f0480, 0x00000000, 0x06a00007, 0x06e00007,
+	0x080c24a0, 0x060c2207, 0x060c2207, 0x060c2207, 0x060c2207,
+	0x060c2207, 0x0cc00000, 0x060c2207, 0x07801988, 0x094c11c8,
+	0x0c07fd00, 0x060e0407, 0x06800007, 0x07c01cc7, 0x07c00907,
+	0x0cc00000, 0x07c00947, 0x060c0a07, 0x078000c8, 0x0aa24008,
+	0x06800009, 0x0aa1c1c8, 0x06800049, 0x05401247, 0x0400b249,
+	0x0b403247, 0x06800049, 0x06800009, 0x07c00bc9, 0x0b218107,
+	0x0ae08207, 0x0c780380, 0x0b214607, 0x0c780180, 0x00000000,
+	0x0c780480, 0x06820207, 0x0c780240, 0x00000000, 0x05401207,
+	0x04410208, 0x044061c7, 0x054081c7, 0x0c780280, 0x094081c8,
+	0x0c7800c0, 0x0c7800c0, 0x04008207, 0x05401207, 0x0400d1c7,
+	0x054071c7, 0x0c780080, 0x094081c8, 0x07c002c7, 0x06b00008,
+	0x064c2d09, 0x09610248, 0x060c2d09, 0x09610208, 0x060c2f08,
+	0x07801988, 0x094c11c8, 0x0cc00000, 0x060e0407, 0x0680000e,
+	0x0aa4c00f, 0x0ae1400f, 0x0400038f, 0x06bfffce, 0x0300e38f,
+	0x0400138e, 0x0900434e, 0x0b21408d, 0x06800007, 0x0b20c34d,
+	0x06800047, 0x06800087, 0x05c0438e, 0x0540138e, 0x0200e1ce,
+	0x0ae1000f, 0x06bfffcd, 0x0300e34e, 0x0400138e, 0x0cc00000,
+	0x040003ce, 0x07800007, 0x0ae10007, 0x07800109, 0x07800988,
+	0x02007207, 0x044011c7, 0x040811c7, 0x074001c9, 0x0cc00000,
+	0x07c02009, 0x0681f409, 0x04401249, 0x0aefc009, 0x00000000,
+	0x083f0040, 0x083f0000, 0x08090b65, 0x00000000, 0x08090b60,
+	0x06498e07, 0x09807007, 0x068007c9, 0x097051c9, 0x06098e07,
+	0x0681f409, 0x04601249, 0x0c4fffc0, 0x00000000, 0x06800009,
+	0x097051c9, 0x09c07007, 0x06098e07, 0x064c0007, 0x09c07187,
+	0x09807207, 0x060c0007, 0x064c0807, 0x09807347, 0x060c0807,
+	0x083f0040, 0x083f0000, 0x08090b65, 0x0cc00000, 0x08090b60,
+	0x0680001f, 0x07c0149f, 0x07c0151f, 0x07800982, 0x060c0902,
+	0x05404082, 0x078009c3, 0x054040c3, 0x096100c2, 0x06090803,
+	0x080c2901, 0x06840442, 0x060c2e02, 0x064c4027, 0x064c4226,
+	0x024269e6, 0x040089a6, 0x07c006e6, 0x058109a6, 0x07c00726,
+	0x0649cf31, 0x0809c500, 0x0649c707, 0x0aa6c007, 0x09010207,
+	0x092101c7, 0x0401f287, 0x0580528a, 0x0403e247, 0x05806249,
+	0x09610289, 0x0649c709, 0x09610247, 0x0609c709, 0x0400f1c7,
+	0x058041c7, 0x060c0907, 0x07c00987, 0x04401247, 0x07c00609,
+	0x05404287, 0x0649c707, 0x094101c8, 0x0609c707, 0x0400f208,
+	0x05804208, 0x07c009c8, 0x05404208, 0x0961020a, 0x06090808,
+	0x0809c300, 0x0809cb00, 0x0cc00000, 0x00000000, 0x0fc02240,
+	0x0aa4c009, 0x0680000a, 0x0b6180c9, 0x0680010a, 0x0fc01280,
+	0x09422289, 0x0c780140, 0x0440128a, 0x0fc01240, 0x0a6fc009,
+	0x0400128a, 0x06800049, 0x03409289, 0x05801249, 0x0f80028a,
+	0x0b40424a, 0x05401249, 0x04401249, 0x0240a24a, 0x0740020a,
+	0x0cc00000, 0x0fc01240, 0x0680001a, 0x064c441b, 0x0a2fc19b,
+	0x058086db, 0x0be1405b, 0x064c471b, 0x058016db, 0x0ba0a01b,
+	0x0c7e6940, 0x078016dc, 0x078009db, 0x0a80d71b, 0x0684001b,
+	0x06c0001b, 0x0a4f369b, 0x0400169a, 0x0649c81a, 0x0a20e01a,
+	0x0c066cc0, 0x00000000, 0x0809c902, 0x08007401, 0x0c780000,
+	0x00800000, 0x0c7f46c0, 0x00000000, 0x06490628, 0x0aefcc28,
+	0x00000000, 0x07800028, 0x078016e9, 0x09508a68, 0x068000a8,
+	0x06c00028, 0x06090628, 0x06090629, 0x06881068, 0x06090628,
+	0x0cc00000, 0x00000000, 0x06490628, 0x0aefcc28, 0x06c00028,
+	0x069001a8, 0x069fffea, 0x06090628, 0x06090629, 0x05401a23,
+	0x06090628, 0x09210a23, 0x05401a28, 0x02828aa8, 0x06090628,
+	0x06985168, 0x0c782700, 0x06090628, 0x078003e8, 0x0a6fc028,
+	0x07800028, 0x078016e9, 0x06800030, 0x09508a68, 0x0780016b,
+	0x07801d2a, 0x04601aaa, 0x0c500ec0, 0x0aa4802b, 0x0690002a,
+	0x0aa4006b, 0x0aa8c36b, 0x0aa883eb, 0x0aa3422b, 0x00000000,
+	0x06a0002a, 0x0aa281eb, 0x06c0002a, 0x06b0002a, 0x0aa1c1ab,
+	0x06c0002a, 0x04602aeb, 0x0c500980, 0x0690002a, 0x0c7e7040,
+	0x00000000, 0x06490628, 0x0aefcc28, 0x068000a8, 0x02c28aa8,
+	0x09441a30, 0x06090628, 0x06090629, 0x069fffeb, 0x06900028,
+	0x0a00ca2a, 0x080c2400, 0x080e1424, 0x064c2228, 0x060e1528,
+	0x060e1528, 0x060e1528, 0x060e1528, 0x09210a68, 0x06090628,
+	0x02828ae9, 0x06090628, 0x06a00028, 0x0a007a2a, 0x080c2440,
+	0x064c2228, 0x09210a68, 0x06090628, 0x02828ae9, 0x06090628,
+	0x0688d068, 0x02c28aa8, 0x09441a30, 0x0c781780, 0x06090628,
+	0x09441ab0, 0x06031f2a, 0x0680016b, 0x09510ae9, 0x0c781600,
+	0x06031e2b, 0x0aa241eb, 0x06a0002a, 0x0aa1c1ab, 0x06b0002a,
+	0x0aa1416b, 0x0aa1026b, 0x06800070, 0x0690002a, 0x06800030,
+	0x06490628, 0x0aefcc28, 0x06c0002a, 0x068408a8, 0x02c28aa8,
+	0x09441a30, 0x06090628, 0x06090629, 0x069fffec, 0x06900028,
+	0x0a00ba2a, 0x080c2400, 0x064c222e, 0x0609062e, 0x09210a2e,
+	0x09c28068, 0x02828b28, 0x09828428, 0x07801d6d, 0x095e1a2d,
+	0x06090628, 0x06a00028, 0x0a00ba2a, 0x080c2440, 0x064c2228,
+	0x06090628, 0x09210a28, 0x09c28068, 0x02828b28, 0x09828428,
+	0x07801ded, 0x095e1a2d, 0x06090628, 0x068c5828, 0x02c28aa8,
+	0x09441a30, 0x06090628, 0x06860828, 0x02c28aa8, 0x09441a30,
+	0x06090628, 0x06900028, 0x0a00ba2a, 0x080c2410, 0x064c222f,
+	0x0609062f, 0x09210a2f, 0x09c28068, 0x02828b28, 0x09828428,
+	0x07801dad, 0x095e1a2d, 0x06090628, 0x06a00028, 0x0a00ba2a,
+	0x080c2450, 0x064c2228, 0x06090628, 0x09210a28, 0x09c28068,
+	0x02828b28, 0x09828428, 0x07801e2d, 0x095e1a2d, 0x06090628,
+	0x068ed868, 0x02c28aa8, 0x09441a30, 0x06090628, 0x080c24a0,
+	0x080e1424, 0x064c2228, 0x060e152e, 0x060e152f, 0x060e1528,
+	0x0c780080, 0x060e1528, 0x0cc00000, 0x00000000, 0x07800028,
+	0x078016e9, 0x06800030, 0x09508a68, 0x0780016b, 0x0780026a,
+	0x04601aaa, 0x0c500c00, 0x0aa1416b, 0x00000000, 0x06800070,
+	0x0a61826b, 0x00000000, 0x078003a8, 0x04602a28, 0x0c500840,
+	0x0c7800c0, 0x0c780000, 0x00000000, 0x06490628, 0x0aefcc28,
+	0x06b000a8, 0x09441a30, 0x06090628, 0x06090629, 0x069fffeb,
+	0x06900028, 0x080c2400, 0x080e1424, 0x064c2228, 0x060e1528,
+	0x060e1528, 0x060e1528, 0x060e1528, 0x09210a68, 0x06090628,
+	0x02828ae9, 0x06090628, 0x080c2440, 0x064c2228, 0x09210a68,
+	0x06090628, 0x02828ae9, 0x06090628, 0x06b8d068, 0x09441a30,
+	0x0c781340, 0x06090628, 0x06b0002a, 0x09441ab0, 0x06031f2a,
+	0x0680016b, 0x09510ae9, 0x0c781180, 0x06031e2b, 0x0aa1416b,
+	0x0aa1026b, 0x06800070, 0x0c7ff5c0, 0x00000000, 0x06490628,
+	0x0aefcc28, 0x06b408a8, 0x09441a30, 0x06090628, 0x06090629,
+	0x069fffec, 0x06900028, 0x080c2400, 0x064c222e, 0x0609062e,
+	0x09210a2e, 0x09c28068, 0x02828b28, 0x09828428, 0x078017ad,
+	0x095e1a2d, 0x06090628, 0x080c2440, 0x064c2228, 0x06090628,
+	0x09210a28, 0x09c28068, 0x02828b28, 0x09828428, 0x06090628,
+	0x06bc5828, 0x09441a30, 0x06090628, 0x06b60828, 0x09441a30,
+	0x06090628, 0x06900028, 0x080c2410, 0x064c222f, 0x0609062f,
+	0x09210a2f, 0x09c28068, 0x02828b28, 0x09828428, 0x078017ad,
+	0x05801b6d, 0x095e1a2d, 0x06090628, 0x080c2450, 0x064c2228,
+	0x06090628, 0x09210a28, 0x09c28068, 0x02828b28, 0x09828428,
+	0x098283e8, 0x06090628, 0x06bed868, 0x09441a30, 0x06090628,
+	0x080c24a0, 0x080e1424, 0x064c2228, 0x060e152e, 0x060e152f,
+	0x060e1528, 0x060e1528, 0x0cc00000, 0x00000000, 0x064e1215,
+	0x091e1555, 0x0a208055, 0x0c782340, 0x0649d915, 0x0900c555,
+	0x0a6f8015, 0x00000000, 0x078003d5, 0x0aa08055, 0x0c780940,
+	0x07800596, 0x0aa1c016, 0x04401596, 0x07c00596, 0x078005d6,
+	0x04401596, 0x0c7814c0, 0x07c005d6, 0x07800916, 0x07800295,
+	0x05408555, 0x02015595, 0x04003596, 0x07c00916, 0x05404595,
+	0x02016c56, 0x060e1316, 0x07800517, 0x0aa0c017, 0x06a16016,
+	0x06a16196, 0x07c00416, 0x069fffd7, 0x044015d7, 0x0aa1c017,
+	0x00000000, 0x064e1615, 0x09010555, 0x0aaec015, 0x04401555,
+	0x060e1615, 0x06c00016, 0x060e1216, 0x06800095, 0x0c7818c0,
+	0x07c003d5, 0x0a660095, 0x078005d6, 0x0aa18016, 0x04401596,
+	0x0b210056, 0x07c005d6, 0x0c780bc0, 0x00000000, 0x07800956,
+	0x07800295, 0x05408555, 0x02015595, 0x04003596, 0x07c00956,
+	0x05404595, 0x02016c56, 0x060e1316, 0x07800415, 0x09c151d5,
+	0x06c00015, 0x060e1215, 0x068000d5, 0x0c7812c0, 0x07c003d5,
+	0x0aa080d5, 0x0c780700, 0x07800516, 0x0aa0c016, 0x06800017,
+	0x06800317, 0x060e1417, 0x07800795, 0x07c00755, 0x0683ffd5,
+	0x064e1516, 0x0900c5d6, 0x0a40b5d5, 0x091845d6, 0x07c00797,
+	0x064e1516, 0x064e1516, 0x064e1516, 0x080c24e0, 0x060c2216,
+	0x064e1516, 0x0c780200, 0x060c2216, 0x068000d6, 0x07c00796,
+	0x06800016, 0x080c24e0, 0x060c2216, 0x060c2216, 0x07801155,
+	0x0aa08095, 0x0c780a00, 0x078003d5, 0x0a644115, 0x07800956,
+	0x06800055, 0x05408555, 0x02015595, 0x04003596, 0x07c00956,
+	0x05404595, 0x02016c56, 0x060e1316, 0x06a16015, 0x09c151d5,
+	0x06c00015, 0x060e1215, 0x06800195, 0x0c780640, 0x07c003d5,
+	0x0aa0c195, 0x0c780500, 0x00000000, 0x06431e18, 0x0befc058,
+	0x064e1418, 0x080e1400, 0x064e1516, 0x0683ffd5, 0x0900c5d6,
+	0x09203656, 0x0a8045d5, 0x091845d6, 0x068000d7, 0x06800019,
+	0x07c004d7, 0x090015d9, 0x07c00497, 0x090225d9, 0x07c01117,
+	0x060e1418, 0x06800015, 0x07c003d5, 0x0cc00000, 0x00400000,
+	0x06800047, 0x07c003c7, 0x07800507, 0x050011c7, 0x07c00507,
+	0x064e1608, 0x09010208, 0x04001208, 0x060e1608, 0x0aa0c007,
+	0x06800008, 0x06800308, 0x060e1408, 0x06b7ffc7, 0x06c00007,
+	0x060e1507, 0x060e1524, 0x060e1524, 0x060e1524, 0x060e1524,
+	0x0cc00000, 0x08030580, 0x078003c7, 0x0a6fc007, 0x07800447,
+	0x0aa0c0c7, 0x0aa98347, 0x0a638107, 0x07800507, 0x050011c7,
+	0x07c00507, 0x06800047, 0x07c003c7, 0x080c24e0, 0x064c2207,
+	0x064c2208, 0x080c24c0, 0x060c2207, 0x060c2208, 0x0cc00000,
+	0x08030580, 0x06800047, 0x07c003c7, 0x07800507, 0x050011c7,
+	0x07c00507, 0x080e1424, 0x064e1509, 0x064e150a, 0x064e150b,
+	0x064e150c, 0x0aa0c007, 0x06800008, 0x06800308, 0x060e1408,
+	0x0683ffc7, 0x07800448, 0x095841c8, 0x07800308, 0x096031c8,
+	0x060e1507, 0x060e1509, 0x060e150a, 0x060e150b, 0x060e150c,
+	0x0cc00000, 0x08030580, 0x07800987, 0x078009c8, 0x06800009,
+	0x0d000008, 0x020091c9, 0x04401249, 0x06800047, 0x0ba10089,
+	0x05801249, 0x0c7fff80, 0x040011c7, 0x0cc00000, 0x07c00687,
+	0x06800208, 0x064c3b07, 0x091031c7, 0x024071c8, 0x0f8001c7,
+	0x0fc0f1c0, 0x064c0e07, 0x040011c7, 0x0f8001c7, 0x07800687,
+	0x0f8001c7, 0x0fc051c0, 0x0c0740c0, 0x07c00107, 0x0fc011c0,
+	0x0aa0c007, 0x0c000640, 0x00000000, 0x078002c7, 0x07801988,
+	0x094c11c8, 0x0c0739c0, 0x060e0407, 0x06800007, 0x07c01cc7,
+	0x078005c7, 0x0b210087, 0x07800988, 0x04002208, 0x024081c8,
+	0x07800947, 0x04401208, 0x02007207, 0x05401208, 0x02007207,
+	0x07c00947, 0x07800987, 0x040011c7, 0x07c005c7, 0x0cc00000,
+	0x00000000, 0x0fc011c0, 0x0a600007, 0x0fc011c0, 0x07801408,
+	0x0f8001c8, 0x0fc011c0, 0x0fc021c0, 0x0fc03200, 0x0aa10007,
+	0x0aa0c047, 0x0fc03200, 0x0fc03200, 0x0cc00000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x06bff7c0, 0x06032400, 0x00400000,
+	0x0c780000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0cc00000,
+	0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000,
+	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0c780200,
+	0x06431e07, 0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000,
+	0x0cc00000, 0x00400000, 0x09027207, 0x0a654048, 0x068fdfca,
+	0x06feffca, 0x064e0408, 0x02808288, 0x09108287, 0x0ba0c08a,
+	0x064c0909, 0x098083c8, 0x0ac0424a, 0x09208287, 0x0a60c00a,
+	0x0400128a, 0x09808388, 0x0b80324a, 0x00000000, 0x098081c8,
+	0x0c780d40, 0x060e0408, 0x0c780cc0, 0x00000000, 0x0a6f8088,
+	0x0680002c, 0x080e1424, 0x09110a47, 0x06431f2a, 0x069fffeb,
+	0x06490628, 0x0aefcc28, 0x05404a2c, 0x060c2428, 0x068010a8,
+	0x02c28aa8, 0x09462a2c, 0x06090628, 0x06090629, 0x064c2228,
+	0x060e1528, 0x09210b68, 0x06090628, 0x02828aed, 0x06090628,
+	0x06a00028, 0x0a009a2a, 0x05404a2c, 0x098281a8, 0x060c2428,
+	0x064c2228, 0x09210b68, 0x06090628, 0x02828aed, 0x06090628,
+	0x0ba9c0ec, 0x04001b2c, 0x06881068, 0x02c28aa8, 0x06090628,
+	0x080c2480, 0x064c2228, 0x09210b68, 0x06090628, 0x02828aed,
+	0x06090628, 0x06a00028, 0x0a006a2a, 0x064c2228, 0x09210b68,
+	0x06090628, 0x02828aed, 0x06090628, 0x08031e00, 0x0cc00000,
+	0x00400000
+};
 
 #define FOR_VFORMAT VFORMAT_MPEG4
 
@@ -2157,6 +2800,7 @@ const u32 __initconst h263_mc[] = {
 		DEF_FIRMWARE_VER(vmpeg4_mc_5, VERSTR);\
 		DEF_FIRMWARE_VER(vmpeg4_mc_311, VERSTR);\
 		DEF_FIRMWARE_VER(h263_mc, VERSTR);\
+		DEF_FIRMWARE_VER(vmmpeg4_mc_5, VERSTR);\
 	} while (0)
 
 INIT_DEF_FIRMWARE();
diff --git a/drivers/amlogic/amports/arch/ucode/vc1/vc1_vc1_linux.h b/drivers/amlogic/amports/arch/ucode/vc1/vc1_vc1_linux.h
index e662a5f..91358b2 100644
--- a/drivers/amlogic/amports/arch/ucode/vc1/vc1_vc1_linux.h
+++ b/drivers/amlogic/amports/arch/ucode/vc1/vc1_vc1_linux.h
@@ -16,42 +16,42 @@
 */
 
 static const u32 MicroCode[] __initconst = {
-	0x06810001, 0x06800000, 0x0d000001, 0x07400040, 0x0c014600,
+	0x06810001, 0x06800000, 0x0d000001, 0x07400040, 0x0c014900,
 	0x06800024, 0x00000000, 0x00000000, 0x080c0002, 0x080c1e01,
-	0x06bfde80, 0x07c017c0, 0x06030400, 0x00400000, 0x0c0154c0,
+	0x06bfde80, 0x07c017c0, 0x06030400, 0x00400000, 0x0c0158c0,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x0c7ffe80, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x0cc00000, 0x00400000, 0x0cc00000,
-	0x00400000, 0x0c780580, 0x064c0007, 0x0c795640, 0x06800024,
+	0x00400000, 0x0c780580, 0x064c0007, 0x0c795a40, 0x06800024,
 	0x0cc00000, 0x00400000, 0x0cc00000, 0x00400000, 0x0cc00000,
-	0x00400000, 0x0c79e380, 0x00000000, 0x0cc00000, 0x00400000,
+	0x00400000, 0x0c79e780, 0x00000000, 0x0cc00000, 0x00400000,
 	0x04001924, 0x0c7fff40, 0x0609c724, 0x06800024, 0x00800000,
 	0x078017c9, 0x0c7ffe00, 0x06030409, 0x06bfdd89, 0x06030409,
 	0x00400000, 0x0a2e0047, 0x07801509, 0x0aa14009, 0x0a608049,
 	0x0c78fb80, 0x0a608089, 0x0c78ecc0, 0x0a220807, 0x0c787d40,
-	0x00000000, 0x06800007, 0x0c0067c0, 0x07c003c7, 0x0c793100,
+	0x00000000, 0x06800007, 0x0c0067c0, 0x07c003c7, 0x0c793400,
 	0x00000000, 0x0bee9007, 0x078003c7, 0x0a6fc007, 0x06800008,
 	0x07800007, 0x0a644007, 0x07c00208, 0x064c2907, 0x091c11c7,
 	0x0a634047, 0x07800347, 0x0a22d007, 0x0aa20020, 0x0aa0c0a0,
 	0x07802987, 0x0a60c0c8, 0x078000c7, 0x0a614007, 0x07800107,
-	0x0a60c007, 0x0c792b80, 0x00000000, 0x0cb8002d, 0x00000000,
+	0x0a60c007, 0x0c792e80, 0x00000000, 0x0cb8002d, 0x00000000,
 	0x07800087, 0x060c2307, 0x06800007, 0x07c00147, 0x04c001c7,
 	0x060c2107, 0x068fdfca, 0x064e0408, 0x02808288, 0x02c08948,
 	0x060e0408, 0x060c0726, 0x06800008, 0x07800507, 0x09582207,
 	0x098083c8, 0x06c00308, 0x060e0508, 0x080c25a0, 0x080c2601,
 	0x078020c8, 0x0a6100c8, 0x080c2602, 0x080c2603, 0x080c2604,
-	0x0c01cd00, 0x080c260e, 0x0c01c440, 0x00000000, 0x0683ffc8,
+	0x0c01d100, 0x080c260e, 0x0c01c840, 0x00000000, 0x0683ffc8,
 	0x064c2307, 0x093041c7, 0x0aa0c007, 0x0b6f4048, 0x04401208,
 	0x07800007, 0x040011c7, 0x07c00007, 0x09c253a5, 0x07800988,
 	0x0b405207, 0x040011c7, 0x0b824207, 0x0c7808c0, 0x098251e5,
 	0x06800007, 0x07c00007, 0x098253a5, 0x09c253e5, 0x09c251e5,
 	0x078016c8, 0x04001208, 0x078009c9, 0x0b410248, 0x07c016c8,
-	0x0be5c7c8, 0x078000c7, 0x0aa0c007, 0x0c020d40, 0x0680000a,
-	0x07800107, 0x0aa0c007, 0x0c020c40, 0x0680004a, 0x07800bc7,
-	0x0aa34007, 0x0c020b40, 0x0680008a, 0x0c780280, 0x078003c7,
+	0x0be5c7c8, 0x078000c7, 0x0aa0c007, 0x0c021140, 0x0680000a,
+	0x07800107, 0x0aa0c007, 0x0c021040, 0x0680004a, 0x07800bc7,
+	0x0aa34007, 0x0c020f40, 0x0680008a, 0x0c780280, 0x078003c7,
 	0x0a6fc007, 0x00000000, 0x06430507, 0x0a2f0107, 0x06a00008,
-	0x060c3d08, 0x0c791780, 0x00000000, 0x07800007, 0x09508987,
+	0x060c3d08, 0x0c791a80, 0x00000000, 0x07800007, 0x09508987,
 	0x078016c9, 0x09408989, 0x0680000b, 0x0481f249, 0x05403249,
 	0x07800007, 0x0480f207, 0x068003ca, 0x0240a20a, 0x058041c7,
 	0x020091c9, 0x06804007, 0x020091c9, 0x078000c7, 0x0a60c007,
@@ -69,8 +69,8 @@ static const u32 MicroCode[] __initconst = {
 	0x0aa20008, 0x00000000, 0x080c2590, 0x080c2607, 0x080c2601,
 	0x080c2604, 0x0c780180, 0x080c2602, 0x080c2500, 0x080c2607,
 	0x080c2604, 0x080c2602, 0x07802c08, 0x04c28208, 0x09808208,
-	0x060c2108, 0x0c01a9c0, 0x080c260e, 0x0c01a100, 0x00000000,
-	0x0c7fdd00, 0x00000000, 0x0c7ffd80, 0x080c2560, 0x0c78ff00,
+	0x060c2108, 0x0c01adc0, 0x080c260e, 0x0c01a500, 0x00000000,
+	0x0c7fdd00, 0x00000000, 0x0c7ffd80, 0x080c2560, 0x0c790200,
 	0x00000000, 0x06800048, 0x07c00148, 0x04c00208, 0x0be68207,
 	0x07800207, 0x0aae4047, 0x060c2108, 0x080c2560, 0x0683ffc9,
 	0x064c2307, 0x09304207, 0x0aa10008, 0x091421c7, 0x0b6f0049,
@@ -98,8 +98,8 @@ static const u32 MicroCode[] __initconst = {
 	0x07c00148, 0x04c00208, 0x0be20207, 0x07800207, 0x0aa4c047,
 	0x060c2108, 0x080c2500, 0x080c2607, 0x0c780140, 0x080c2604,
 	0x060c2108, 0x080c2b00, 0x080c2560, 0x07802c08, 0x04c28208,
-	0x09808208, 0x060c2108, 0x0c018540, 0x080c260e, 0x0c017c80,
-	0x00000000, 0x0c7fb880, 0x00000000, 0x0c78db00, 0x00000000,
+	0x09808208, 0x060c2108, 0x0c018940, 0x080c260e, 0x0c018080,
+	0x00000000, 0x0c7fb880, 0x00000000, 0x0c78de00, 0x00000000,
 	0x07800208, 0x0aaf4048, 0x06800048, 0x07c00148, 0x04c00208,
 	0x0be20207, 0x060c2108, 0x080c2560, 0x080c2609, 0x080c2602,
 	0x080c2601, 0x0c7ffa40, 0x080c2604, 0x080c2b00, 0x0c7ff980,
@@ -109,7 +109,7 @@ static const u32 MicroCode[] __initconst = {
 	0x06c00308, 0x060e0508, 0x080c2540, 0x080c2606, 0x064c2307,
 	0x093041c7, 0x0a6f8007, 0x00000000, 0x064c2307, 0x0a228107,
 	0x091421c7, 0x068000c8, 0x07c00148, 0x04c00208, 0x080c2570,
-	0x0c7fcb00, 0x080c260a, 0x0c78cec0, 0x00000000, 0x07800208,
+	0x0c7fcb00, 0x080c260a, 0x0c78d1c0, 0x00000000, 0x07800208,
 	0x0aaf4048, 0x06800048, 0x07c00148, 0x04c00208, 0x0be20047,
 	0x060c2108, 0x080c2570, 0x080c2607, 0x080c2602, 0x080c2601,
 	0x0c7fee00, 0x080c2604, 0x080c2530, 0x080c2607, 0x080c2602,
@@ -135,14 +135,14 @@ static const u32 MicroCode[] __initconst = {
 	0x0980a34a, 0x060c080a, 0x0c07f580, 0x00000000, 0x080e1600,
 	0x0680000a, 0x07c003ca, 0x07800647, 0x0aa20007, 0x00000000,
 	0x0fc08280, 0x06801007, 0x07c00347, 0x06809409, 0x0c781580,
-	0x060c0809, 0x064c1a07, 0x0b210007, 0x06800008, 0x0c78adc0,
+	0x060c0809, 0x064c1a07, 0x0b210007, 0x06800008, 0x0c78b0c0,
 	0x00000000, 0x0fc08280, 0x0fc081c0, 0x07c00347, 0x020081c8,
 	0x0a20d007, 0x06800409, 0x06809409, 0x060c0809, 0x0fc081c0,
 	0x020081c8, 0x05410247, 0x0fc081c0, 0x0a646207, 0x020081c8,
 	0x0fc081c0, 0x020081c8, 0x09508247, 0x0fc081c0, 0x020081c8,
 	0x09408247, 0x07c02e09, 0x058101c9, 0x07c02f07, 0x04010249,
 	0x05403249, 0x060c1a09, 0x0fc081c0, 0x0aa1a207, 0x020081c8,
-	0x07802007, 0x060c0807, 0x0c78a580, 0x060c1a1f, 0x0fc081c0,
+	0x07802007, 0x060c0807, 0x0c78a880, 0x060c1a1f, 0x0fc081c0,
 	0x020081c8, 0x05408247, 0x0fc081c0, 0x020081c8, 0x09408247,
 	0x07c02049, 0x0fc081c0, 0x0a6d2207, 0x020081c8, 0x0fc081c0,
 	0x020081c8, 0x05408247, 0x0fc081c0, 0x020081c8, 0x09408247,
@@ -153,9 +153,9 @@ static const u32 MicroCode[] __initconst = {
 	0x07c01407, 0x07802507, 0x0aa0c047, 0x06800087, 0x06800047,
 	0x07c024c7, 0x06800047, 0x0c783000, 0x07c004c7, 0x0c782480,
 	0x0aa4c3ca, 0x0aaf838a, 0x0aacc30a, 0x0a61034a, 0x06800007,
-	0x0c782e00, 0x07c004c7, 0x0a6082ca, 0x0c788d00, 0x0a62040a,
+	0x0c782e00, 0x07c004c7, 0x0a6082ca, 0x0c789000, 0x0a62040a,
 	0x00000000, 0x0fc101c0, 0x07c02107, 0x07c02187, 0x0fc101c0,
-	0x0c780100, 0x07c021c7, 0x0c789540, 0x00000000, 0x06800047,
+	0x0c780100, 0x07c021c7, 0x0c789840, 0x00000000, 0x06800047,
 	0x07c00447, 0x06800007, 0x07c00247, 0x0fc02280, 0x07c020ca,
 	0x054011ca, 0x04c011c7, 0x060c1e07, 0x0aa140ca, 0x00000000,
 	0x0fc021c0, 0x0c780100, 0x00000000, 0x0fc031c0, 0x0fc021c0,
@@ -174,13 +174,13 @@ static const u32 MicroCode[] __initconst = {
 	0x0c7801c0, 0x0680080a, 0x0fc081c0, 0x0fc041c0, 0x0aa0c047,
 	0x0680fa0a, 0x0680fa4a, 0x0fc011c0, 0x0aa14007, 0x00000000,
 	0x0fc081c0, 0x0fc081c0, 0x0fc081c0, 0x0fc011c0, 0x0a60c007,
-	0x0c7800c0, 0x06800008, 0x0fc05200, 0x07c02348, 0x0c787d00,
+	0x0c7800c0, 0x06800008, 0x0fc05200, 0x07c02348, 0x0c788000,
 	0x00000000, 0x0fc011c0, 0x07c00047, 0x0fc011c0, 0x0fc011c0,
 	0x07c02d07, 0x0fc011c0, 0x0fc011c0, 0x07c02c47, 0x0fc011c0,
 	0x07c02907, 0x0fc021c0, 0x07c023c7, 0x0fc011c0, 0x07c02b87,
 	0x0fc011c0, 0x0fc011c0, 0x07c02447, 0x0fc011c0, 0x07c02d47,
 	0x0fc011c0, 0x07c02d87, 0x0fc031c0, 0x07c02dc7, 0x0fc021c0,
-	0x07c02407, 0x0fc011c0, 0x07c022c7, 0x0c7875c0, 0x0fc011c0,
+	0x07c02407, 0x0fc011c0, 0x07c022c7, 0x0c7878c0, 0x0fc011c0,
 	0x0fc011c0, 0x0fc011c0, 0x0fc011c0, 0x07c02387, 0x0fc011c0,
 	0x07c00447, 0x0fc011c0, 0x07c00047, 0x0fc011c0, 0x07c02c47,
 	0x0fc011c0, 0x07c02907, 0x0fc021c0, 0x07c023c7, 0x0fc011c0,
@@ -189,490 +189,493 @@ static const u32 MicroCode[] __initconst = {
 	0x04401208, 0x0fc011c0, 0x0aa28007, 0x00000000, 0x0fc0c1c0,
 	0x040011c7, 0x054011c7, 0x07c02187, 0x0fc0c1c0, 0x040011c7,
 	0x054011c7, 0x07c021c7, 0x07802907, 0x0aa0c007, 0x06800007,
-	0x0fc011c0, 0x07c00a07, 0x0c786ac0, 0x00000000, 0x06800048,
+	0x0fc011c0, 0x07c00a07, 0x0c786dc0, 0x00000000, 0x06800048,
 	0x07c01408, 0x064c510a, 0x064c4607, 0x078007c8, 0x05410208,
 	0x07800789, 0x02008248, 0x0580a208, 0x0e000288, 0x00000000,
 	0x00000000, 0x00000000, 0x0f000200, 0x0f010280, 0x0970820a,
 	0x0540a208, 0x020081c8, 0x064c430a, 0x02408288, 0x064c400a,
-	0x02408288, 0x07c00808, 0x05810208, 0x07c00848, 0x07801347,
-	0x040011c7, 0x07c01347, 0x06bff127, 0x06fff127, 0x06800026,
+	0x02408288, 0x07c00808, 0x05810208, 0x07c00848, 0x07801747,
+	0x040011c7, 0x07c01747, 0x06bff127, 0x06fff127, 0x06800026,
 	0x07c00026, 0x07c016e6, 0x098253a6, 0x098253e5, 0x09c251e5,
-	0x07802187, 0x0a608007, 0x0c7860c0, 0x0400f1c7, 0x058041c7,
+	0x07802187, 0x0a608007, 0x0c7863c0, 0x0400f1c7, 0x058041c7,
 	0x05404b87, 0x04401bae, 0x05402bae, 0x060c0907, 0x07c00987,
 	0x04401247, 0x07c00609, 0x09708989, 0x05404287, 0x078021c8,
-	0x0a608008, 0x0c785d40, 0x0400f208, 0x05804208, 0x05404248,
+	0x0a608008, 0x0c786040, 0x0400f208, 0x05804208, 0x05404248,
 	0x04401249, 0x05402249, 0x09610b89, 0x07c009c8, 0x04401248,
 	0x09608989, 0x04000248, 0x09610247, 0x06095209, 0x05404208,
 	0x078020c7, 0x0a6100c7, 0x00000000, 0x0780218a, 0x078021c8,
 	0x0961020a, 0x06090808, 0x06800007, 0x07c00507, 0x06800047,
 	0x07c00587, 0x07800607, 0x040011c7, 0x07c005c7, 0x078020c7,
-	0x0aa080c7, 0x0c784680, 0x078004c7, 0x0a624007, 0x078003a0,
-	0x0c020280, 0x00000000, 0x0c01f580, 0x00000000, 0x0aa14008,
-	0x0c785380, 0x00000000, 0x0c020480, 0x00000000, 0x078024c8,
+	0x0aa080c7, 0x0c784980, 0x078004c7, 0x0a624007, 0x078003a0,
+	0x0c020680, 0x00000000, 0x0c01f980, 0x00000000, 0x0aa14008,
+	0x0c785680, 0x00000000, 0x0c020880, 0x00000000, 0x078024c8,
 	0x05406208, 0x07800247, 0x09482207, 0x09403220, 0x060c0408,
-	0x0687c008, 0x07c00288, 0x0c005840, 0x07c013e0, 0x0c014e00,
+	0x068b8008, 0x07c00288, 0x0c005c40, 0x07c017a0, 0x0c015200,
 	0x06800008, 0x06a00008, 0x07802c87, 0x09610207, 0x060c3d08,
 	0x064c3d08, 0x09161208, 0x0a6f8008, 0x078002c8, 0x0aa14008,
 	0x06bfffc8, 0x060c3908, 0x0c780480, 0x060c3808, 0x06800008,
-	0x06c07e08, 0x078004c9, 0x0aa10009, 0x06a00009, 0x06c00009,
+	0x06c0bc08, 0x078004c9, 0x0aa10009, 0x06800009, 0x06c00049,
 	0x02008248, 0x0aa180a0, 0x020088c8, 0x060c3808, 0x06bfffc8,
 	0x0c780140, 0x060c3908, 0x060c3908, 0x06bfffc8, 0x060c3808,
-	0x0c0065c0, 0x00000000, 0x0c020a40, 0x00000000, 0x080e1600,
-	0x078004c7, 0x0aa0c007, 0x0c782840, 0x00000000, 0x0649c909,
+	0x0c0069c0, 0x00000000, 0x0c020e40, 0x00000000, 0x080e1600,
+	0x078004c7, 0x0aa0c007, 0x0c782b40, 0x00000000, 0x0649c909,
 	0x0aa10009, 0x06800087, 0x0c7f0f00, 0x07c01507, 0x07801487,
 	0x0a608007, 0x0c780c80, 0x044011c7, 0x0aa0c087, 0x07801549,
-	0x078015c9, 0x0b20c0c9, 0x00000000, 0x0c780ac0, 0x0649c808,
+	0x078015c9, 0x0b20c1c9, 0x00000000, 0x0c780ac0, 0x0649c808,
 	0x0aa14008, 0x078014c7, 0x02807207, 0x07c014c7, 0x0809c800,
-	0x040301c9, 0x070001c7, 0x054101c7, 0x04034209, 0x07000208,
-	0x094101c8, 0x0609cb07, 0x040441c9, 0x070001c7, 0x054101c7,
+	0x040301c9, 0x070001c7, 0x054101c7, 0x04038209, 0x07000208,
+	0x094101c8, 0x0609cb07, 0x040481c9, 0x070001c7, 0x054101c7,
 	0x04040209, 0x07000208, 0x094101c8, 0x0609cc07, 0x040621c9,
-	0x070001c7, 0x0609d307, 0x040661c9, 0x070001c7, 0x0609d407,
-	0x040381c9, 0x070001c7, 0x07800fc8, 0x020081c8, 0x0609ca08,
-	0x07c00fdf, 0x04029209, 0x04001249, 0x07000208, 0x09464248,
+	0x070001c7, 0x0609d307, 0x0406a1c9, 0x070001c7, 0x0609d407,
+	0x040c81c9, 0x070001c7, 0x078034c8, 0x020081c8, 0x0609ca08,
+	0x07c034df, 0x040c0209, 0x07000208, 0x09464248, 0x09809209,
 	0x07802248, 0x094e1248, 0x0609c909, 0x08007401, 0x06800009,
 	0x07c01489, 0x06800009, 0x07c01509, 0x078014c7, 0x02c07247,
-	0x04000294, 0x0a238047, 0x06800008, 0x0400029b, 0x0a22c087,
-	0x06800048, 0x0400029c, 0x0a220107, 0x06800088, 0x0400029d,
-	0x0a214207, 0x068000c8, 0x06800047, 0x0c7efd40, 0x07c01507,
-	0x07801607, 0x090041c7, 0x0a8071c8, 0x078002c7, 0x0aa08047,
-	0x0a6200a0, 0x07801607, 0x090841c7, 0x0a4051c8, 0x06800047,
-	0x03407207, 0x0c7ff900, 0x02c091c9, 0x07800807, 0x04040248,
-	0x07400247, 0x07800847, 0x04004249, 0x07400247, 0x07802187,
-	0x04062248, 0x07400247, 0x078021c7, 0x04066248, 0x07400247,
-	0x07801847, 0x054031c7, 0x02c07807, 0x04029248, 0x07400247,
-	0x040301c8, 0x07800f49, 0x074001c9, 0x040341c8, 0x07800f09,
-	0x0a60c060, 0x074001c9, 0x04000848, 0x0a6200a0, 0x040381c8,
-	0x074001df, 0x07000889, 0x0aa1c009, 0x04401249, 0x0c780140,
-	0x07400889, 0x07800f89, 0x074001c9, 0x04000887, 0x07c00f9f,
-	0x06800047, 0x03407207, 0x078014c9, 0x02c091c9, 0x07c014c9,
-	0x06800687, 0x02007207, 0x07802e49, 0x074001c9, 0x0609b20a,
-	0x0609b00a, 0x0609b10a, 0x078002c9, 0x0aa0c049, 0x068000c9,
-	0x04001260, 0x07c01489, 0x078002c9, 0x0aa38049, 0x0a6080a0,
-	0x0c780300, 0x07801587, 0x07c015c7, 0x07c01588, 0x04000aec,
-	0x07801609, 0x05404249, 0x09404248, 0x07c01609, 0x04000b0a,
-	0x0c7800c0, 0x00000000, 0x07c01548, 0x078020c8, 0x0aa1c0c8,
-	0x0aa180a0, 0x0aa10020, 0x06800047, 0x07800307, 0x044011c7,
-	0x07c00307, 0x07800187, 0x0b624087, 0x06800048, 0x0aa240a0,
-	0x0aa08020, 0x0aa1c007, 0x078004c9, 0x0a60c009, 0x040011c7,
-	0x07c00187, 0x0c780180, 0x07c001c8, 0x06800008, 0x07c001c8,
-	0x0c7818c0, 0x00000000, 0x0680192d, 0x0aa34020, 0x0aa180a0,
-	0x07800247, 0x0a628047, 0x0680366d, 0x0c780200, 0x06804eed,
-	0x07800247, 0x0aa14007, 0x06805c6d, 0x0aa0c087, 0x06806d2d,
-	0x06804eed, 0x064c1e07, 0x04c181c7, 0x060c1e07, 0x0c003340,
-	0x00000000, 0x0c01d8c0, 0x00000000, 0x064c1e08, 0x07800247,
-	0x0a618087, 0x09c08408, 0x07800547, 0x0a60c007, 0x00000000,
-	0x09808408, 0x060c1e08, 0x0c01dd40, 0x00000000, 0x0c01f880,
-	0x00000000, 0x0cb8002d, 0x00000000, 0x07800347, 0x0be19007,
-	0x07802e07, 0x07802f08, 0x096101c8, 0x0ae08047, 0x0c780dc0,
-	0x078022c7, 0x0aa0c007, 0x00000000, 0x0fc011c0, 0x0fc021c0,
-	0x07802d87, 0x0aa0c007, 0x06800208, 0x0fc011c0, 0x07c02e47,
-	0x0c7fb6c0, 0x00000000, 0x06800007, 0x07c01407, 0x078001c7,
-	0x0a60c007, 0x0c780980, 0x00000000, 0x0fc091c0, 0x078024c8,
-	0x0a60c088, 0x078009c8, 0x02407207, 0x078016c8, 0x0a802207,
-	0x07c016c7, 0x0fc011c0, 0x0aa50007, 0x0c01b440, 0x00000000,
-	0x078004c7, 0x0aa18007, 0x07802507, 0x0aa0c047, 0x06800087,
-	0x06800047, 0x07c024c7, 0x0c01a580, 0x00000000, 0x078004c7,
-	0x0aa0c007, 0x00000000, 0x078003a0, 0x0aa08008, 0x0c780280,
-	0x0c010040, 0x06800048, 0x098253a5, 0x098253e5, 0x09c251e5,
-	0x0c7fec40, 0x00000000, 0x0c7ece80, 0x00000000, 0x0683ffc9,
-	0x04401249, 0x0aaf0009, 0x064c0007, 0x0a2f4047, 0x00000000,
-	0x064c3a07, 0x090061c7, 0x0aae4647, 0x00000000, 0x080c2800,
-	0x080c0002, 0x0c7ec6c0, 0x00000000, 0x06b21000, 0x07c01440,
-	0x0649c014, 0x0649c11b, 0x0649c21c, 0x0649c31d, 0x0680402b,
-	0x0681412c, 0x0c000440, 0x00000000, 0x08002501, 0x08002605,
-	0x08002708, 0x08002815, 0x08002c14, 0x0cc00000, 0x00000000,
-	0x06800007, 0x07c000c7, 0x07c00107, 0x07c00bc7, 0x07c00207,
-	0x07c00907, 0x0cc00000, 0x07c00947, 0x0649c402, 0x07c00642,
-	0x0649cf23, 0x064c4002, 0x064c4203, 0x02403083, 0x040080c3,
-	0x07c00783, 0x058100c3, 0x07c007c3, 0x064c091f, 0x06bfff82,
-	0x063f0102, 0x06803002, 0x063f0002, 0x06800002, 0x063f0002,
-	0x06bfffc2, 0x063f0102, 0x06800020, 0x07c001a0, 0x07c001e0,
-	0x068000c2, 0x07c024c2, 0x06803fc2, 0x07c01542, 0x07c01582,
-	0x07c015c2, 0x07c01602, 0x060c091f, 0x0680001f, 0x07c0149f,
-	0x07c014df, 0x07c0151f, 0x06800402, 0x07c02002, 0x060c1a1f,
-	0x080c1e01, 0x06800002, 0x060c0c02, 0x06c04042, 0x060c0d02,
-	0x0cc00000, 0x00000000, 0x0649c803, 0x0aa30003, 0x00000000,
-	0x00800000, 0x0649c803, 0x0a60c003, 0x0c7801c0, 0x00400000,
-	0x078014c2, 0x028020c2, 0x07c014c2, 0x0809c800, 0x00400000,
-	0x07801502, 0x0aa0c002, 0x06800102, 0x06030502, 0x0b60c224,
-	0x0cc00000, 0x00000000, 0x00800000, 0x00000000, 0x06800007,
-	0x0c071bc0, 0x07c003c7, 0x080c2800, 0x080c0002, 0x06800024,
-	0x0cc00000, 0x00400000, 0x064c441a, 0x0912169a, 0x0aaf801a,
-	0x0c7eab80, 0x00000000, 0x0683ffe9, 0x04401a69, 0x0aa0c029,
-	0x0649092a, 0x0bef406a, 0x0cc00000, 0x00000000, 0x0c07fe40,
-	0x00000000, 0x06800168, 0x0649072a, 0x09503aa8, 0x07800328,
-	0x09421aa8, 0x07800268, 0x0aa0c0a8, 0x0982a0ea, 0x09c2a0ea,
-	0x078029a8, 0x0a60c028, 0x06d1412a, 0x0982a7ea, 0x0609072a,
-	0x06490b2a, 0x0982a02a, 0x06090b2a, 0x09c2a02a, 0x0982a52a,
-	0x0982a56a, 0x0982a5aa, 0x078020e8, 0x0aa0c0e8, 0x06800029,
-	0x06800069, 0x095c1aa9, 0x07800268, 0x0a63c0a8, 0x068006a8,
-	0x078015e9, 0x06800029, 0x02029a68, 0x07000a68, 0x09541aa8,
-	0x068006a8, 0x078015a9, 0x06800029, 0x02029a68, 0x07000a68,
-	0x09561aa8, 0x0c780340, 0x0982a4ea, 0x068006a8, 0x078015e9,
-	0x02029a68, 0x07000a68, 0x09541aa8, 0x068006a8, 0x078015a9,
-	0x02029a68, 0x07000a68, 0x09561aa8, 0x09c2a4ea, 0x06090b2a,
-	0x07801428, 0x0aa0c068, 0x0c784680, 0x00000000, 0x0680000d,
-	0x078029ce, 0x078002e8, 0x0aa1c068, 0x0a618020, 0x00000000,
-	0x0680000e, 0x07c029ce, 0x0c780440, 0x00000000, 0x0780144a,
-	0x0aa2c060, 0x09082a4a, 0x09102a4a, 0x078004e8, 0x0aa10068,
-	0x00000000, 0x09182a0a, 0x02c29a29, 0x0908134a, 0x090a1a8a,
-	0x02c0da8d, 0x0aa0c029, 0x00000000, 0x0680004e, 0x06490b2a,
-	0x09501a8e, 0x09521a8d, 0x06090b2a, 0x0a61000e, 0x0a60c00d,
-	0x0c783a80, 0x00000000, 0x06800007, 0x06804008, 0x0680c009,
-	0x0680000a, 0x0c003d40, 0x00000000, 0x0780144f, 0x0aa140a0,
-	0x078002c7, 0x0aa0c047, 0x0c781240, 0x00000000, 0x06490b07,
-	0x058081c7, 0x0be0c047, 0x0c780ac0, 0x00000000, 0x0910234f,
-	0x0aa2400d, 0x091421cf, 0x040031c7, 0x054081c7, 0x0540820d,
-	0x06804009, 0x0680004a, 0x0c003800, 0x00000000, 0x078004c7,
-	0x0aa30047, 0x0918220f, 0x0aa28008, 0x091c21cf, 0x02c0d20d,
-	0x040031c7, 0x054081c7, 0x05408208, 0x06804009, 0x0680004a,
-	0x0c0034c0, 0x00000000, 0x0be1404d, 0x00000000, 0x06804007,
-	0x0c005c80, 0x00000000, 0x0be1408d, 0x00000000, 0x06808007,
-	0x0c005b40, 0x00000000, 0x06804007, 0x06800008, 0x0c005580,
-	0x00000000, 0x06808007, 0x06800048, 0x0c005480, 0x00000000,
-	0x06490b07, 0x058091c7, 0x0be0c047, 0x0c782940, 0x00000000,
-	0x0908234f, 0x0aa4400d, 0x090c21cf, 0x040031c7, 0x054081c7,
-	0x0540820d, 0x06804009, 0x0680004a, 0x0c002c80, 0x00000000,
-	0x054081cd, 0x06800088, 0x0c004fc0, 0x00000000, 0x06490b07,
-	0x0902120d, 0x096e11c8, 0x06090b07, 0x0c782440, 0x00000000,
-	0x0908220f, 0x0aa24008, 0x090c21cf, 0x040031c7, 0x054081c7,
-	0x05408208, 0x06804009, 0x0680004a, 0x0c002780, 0x00000000,
-	0x090823cf, 0x0aa0c04f, 0x06808007, 0x06804007, 0x0c004f00,
-	0x00000000, 0x0be100cf, 0x06808007, 0x0c004e00, 0x00000000,
-	0x078029c7, 0x0a608007, 0x0c781340, 0x07802a07, 0x07802a48,
-	0x0680070c, 0x0c0026c0, 0x00000000, 0x07800247, 0x0aa0c087,
-	0x0c780ac0, 0x00000000, 0x06800048, 0x07800b87, 0x0a610087,
-	0x06804010, 0x06808010, 0x06800088, 0x0a80320f, 0x06800051,
-	0x06800011, 0x040001d0, 0x0680c008, 0x04000251, 0x0c003980,
-	0x00000000, 0x040801d0, 0x0680e008, 0x04000251, 0x0c003840,
-	0x00000000, 0x07800b87, 0x0a64c007, 0x07801207, 0x07801248,
-	0x0680070c, 0x0c001f40, 0x00000000, 0x0aa0c08f, 0x06800051,
-	0x06800011, 0x06808007, 0x0680c008, 0x04000251, 0x0c003480,
-	0x00000000, 0x0680a007, 0x0680e008, 0x04000251, 0x0c003340,
-	0x00000000, 0x0c780700, 0x00000000, 0x0aa0c04f, 0x06800051,
-	0x06800011, 0x06804007, 0x0680c008, 0x04000251, 0x0c0030c0,
-	0x00000000, 0x06806007, 0x0680e008, 0x04000251, 0x0c002f80,
-	0x00000000, 0x0aa0c08f, 0x06800051, 0x06800011, 0x06808007,
-	0x0680c008, 0x04000251, 0x0c002d80, 0x00000000, 0x0680a007,
-	0x0680e008, 0x04000251, 0x0c002c40, 0x00000000, 0x06804007,
-	0x06800008, 0x0c003480, 0x00000000, 0x06808007, 0x06800048,
-	0x0c003380, 0x00000000, 0x07800247, 0x0aa20007, 0x0aa1c047,
-	0x078024c7, 0x0aa24047, 0x0680004c, 0x0680008c, 0x0c780180,
-	0x00000000, 0x07802507, 0x0aa0c047, 0x0680004c, 0x0680008c,
-	0x0780144f, 0x094823cc, 0x07c0144f, 0x090c21cf, 0x040031c7,
-	0x054081c7, 0x0540820c, 0x06804009, 0x0680000a, 0x0c000940,
-	0x00000000, 0x090421cf, 0x040031c7, 0x054081c7, 0x068000c8,
-	0x02408308, 0x094023c8, 0x07c0144f, 0x05408208, 0x06804009,
-	0x0680000a, 0x0c000640, 0x00000000, 0x06800007, 0x06804008,
-	0x0680c009, 0x0680004a, 0x0c0004c0, 0x00000000, 0x0aa3c0a0,
-	0x078002c7, 0x0aa34047, 0x07800247, 0x0aa0c087, 0x06800048,
-	0x06800088, 0x07801447, 0x091c2247, 0x054041c7, 0x094421c9,
-	0x04401208, 0x0a6f0008, 0x00000000, 0x07c01447, 0x0cc00000,
-	0x00000000, 0x06035209, 0x06ac0009, 0x06c07e49, 0x020098c9,
-	0x054011c7, 0x02007247, 0x06035107, 0x098083c8, 0x095c120a,
-	0x06035008, 0x06435007, 0x0580f1c7, 0x0bef8047, 0x0cc00000,
-	0x00000000, 0x0906238c, 0x0540838e, 0x0a628007, 0x00000000,
-	0x06bff007, 0x05407248, 0x068ff00a, 0x0240924a, 0x0b2207c8,
-	0x06880008, 0x0c780180, 0x02009209, 0x0b20c7c8, 0x040201c7,
-	0x04440208, 0x05406248, 0x0684c008, 0x090212cc, 0x094e120b,
-	0x06094008, 0x0680000b, 0x06800008, 0x0e000207, 0x00000000,
-	0x00000000, 0x0f000280, 0x0402028a, 0x0200a24a, 0x05c0628a,
-	0x0b213fca, 0x00000000, 0x0c780140, 0x06803fca, 0x0b60c00a,
-	0x00000000, 0x0680000a, 0x054082cb, 0x0200b28b, 0x04001208,
-	0x0be300c8, 0x00000000, 0x0a20c04c, 0x00000000, 0x0609410b,
-	0x0a21c10c, 0x0921034b, 0x0740038d, 0x0400138e, 0x0901034b,
-	0x0740038d, 0x0400138e, 0x0b28ffc8, 0x00000000, 0x0684d008,
-	0x090212cc, 0x094e120b, 0x06094008, 0x0680000b, 0x06800008,
-	0x04480248, 0x0e000247, 0x00000000, 0x00000000, 0x0f000280,
-	0x06880809, 0x0200a24a, 0x05c0628a, 0x0b213fca, 0x00000000,
-	0x0c780140, 0x06803fca, 0x0b60c00a, 0x00000000, 0x0680000a,
-	0x054082cb, 0x0200b28b, 0x04001208, 0x0be300c8, 0x00000000,
-	0x0a20c04c, 0x00000000, 0x0609410b, 0x0a21c10c, 0x0921034b,
-	0x0740038d, 0x0400138e, 0x0901034b, 0x0740038d, 0x0400138e,
-	0x0b28bfc8, 0x00000000, 0x0cc00000, 0x08094000, 0x0680000a,
-	0x0aa0c049, 0x0c780440, 0x00000000, 0x070001c9, 0x091082c9,
-	0x0c000540, 0x00000000, 0x0950824c, 0x090082c9, 0x0c000440,
-	0x00000000, 0x0940824c, 0x074001c9, 0x0400128a, 0x0bad600a,
-	0x040011c7, 0x0c780200, 0x00000000, 0x07000209, 0x074001c9,
-	0x0400128a, 0x040011c7, 0x0baf200a, 0x04001208, 0x0cc00000,
-	0x00000000, 0x0580130b, 0x0200d308, 0x0700034c, 0x040012cb,
-	0x090012cb, 0x054032cb, 0x0380c2cc, 0x048ff30c, 0x0cc00000,
-	0x00000000, 0x0684c00a, 0x0a20c088, 0x06800049, 0x06800089,
-	0x09584289, 0x04801208, 0x094e1288, 0x0609400a, 0x0680000a,
-	0x070001c9, 0x040011c7, 0x070001cb, 0x096102c9, 0x0609410b,
-	0x0400128a, 0x0baea00a, 0x040011c7, 0x0cc00000, 0x08094000,
-	0x0680000a, 0x0487f24a, 0x05401249, 0x04001209, 0x09508209,
-	0x074001c8, 0x0400128a, 0x0b2ebfca, 0x040011c7, 0x0cc00000,
-	0x00000000, 0x0cc00000, 0x00000000, 0x06490628, 0x0aef4c28,
-	0x00000000, 0x064c2328, 0x0a240228, 0x069001a8, 0x069fffea,
-	0x06090628, 0x07800028, 0x078016e9, 0x09508a68, 0x06090629,
-	0x06800028, 0x06090628, 0x05401a28, 0x02828aa8, 0x06090628,
-	0x06985168, 0x0cc00000, 0x06090628, 0x07800028, 0x078016e9,
-	0x09508a68, 0x068000a8, 0x06c00028, 0x06090628, 0x06090629,
-	0x06881068, 0x06090628, 0x0cc00000, 0x00000000, 0x078003c7,
-	0x0a6fc007, 0x07800507, 0x0b20c047, 0x040011c7, 0x06800007,
-	0x07c00507, 0x06800047, 0x07c003c7, 0x0cc00000, 0x08030580,
-	0x064e1215, 0x091e1555, 0x0a208055, 0x0c781280, 0x078003d5,
-	0x0aa08055, 0x0c780b40, 0x07800596, 0x0aa2c016, 0x04401596,
-	0x07c00596, 0x078005d6, 0x04401596, 0x064c2315, 0x0a20c215,
-	0x00000000, 0x080e1601, 0x0c780e80, 0x07c005d6, 0x07800916,
-	0x07800295, 0x05408555, 0x02015595, 0x04004596, 0x07c00916,
-	0x05404595, 0x020168d6, 0x060e1316, 0x07800517, 0x0aa14017,
-	0x06a1a196, 0x0aa0c057, 0x06a1a496, 0x06a1a016, 0x07c00416,
-	0x0683ffd7, 0x044015d7, 0x0b214017, 0x064e1615, 0x09010555,
-	0x0aaf0015, 0x00000000, 0x064c2315, 0x0be0c215, 0x00000000,
-	0x080e1600, 0x06c00016, 0x060e1216, 0x06800095, 0x0c780700,
-	0x07c003d5, 0x0a660095, 0x078005d6, 0x0aa18016, 0x04401596,
-	0x0b210056, 0x07c005d6, 0x0c780480, 0x00000000, 0x07800956,
-	0x07800295, 0x05408555, 0x02015595, 0x04004596, 0x07c00956,
-	0x05404595, 0x020168d6, 0x060e1316, 0x07800415, 0x09c151d5,
-	0x06c00015, 0x060e1215, 0x068000d5, 0x0c780100, 0x07c003d5,
-	0x06800015, 0x07c003d5, 0x0cc00000, 0x00400000, 0x0fc011c0,
-	0x05403207, 0x0fc011c0, 0x0a62c007, 0x0fc011c0, 0x0a634007,
-	0x0fc011c0, 0x0a63c007, 0x06800107, 0x0fc011c0, 0x0a630007,
-	0x06800147, 0x0c780280, 0x06800187, 0x0aa20007, 0x06800007,
-	0x0c780180, 0x06800047, 0x0aa10007, 0x06800087, 0x0c780080,
-	0x068000c7, 0x0a610187, 0x09403207, 0x0cc00000, 0x00000000,
-	0x0c0757c0, 0x00000000, 0x0c00fc40, 0x00000000, 0x0aa08007,
-	0x0a62c107, 0x06800149, 0x07800987, 0x09708247, 0x078009c7,
-	0x09608247, 0x060e1809, 0x064e1807, 0x0befc047, 0x0c781800,
-	0x00000000, 0x0aa0c047, 0x0aa08147, 0x0c781280, 0x0780098b,
-	0x0ba0c0cb, 0x0c7fffc0, 0x044032cb, 0x078009c9, 0x0ba0c0c9,
-	0x0c7fffc0, 0x04403249, 0x0a614009, 0x068001c9, 0x0aa0c00b,
-	0x0c780a80, 0x06800249, 0x07800987, 0x09708247, 0x078009c7,
-	0x09608247, 0x095c224b, 0x09581247, 0x060e1809, 0x064e1809,
-	0x0befc049, 0x0aa4c00b, 0x068000c9, 0x078009c7, 0x09608247,
-	0x06800047, 0x09708247, 0x060e1809, 0x064e1809, 0x0befc049,
-	0x0aa2804b, 0x068000c9, 0x078009c7, 0x09608247, 0x06800047,
-	0x09708247, 0x09809389, 0x060e1809, 0x064e1809, 0x0befc049,
-	0x078009c7, 0x0a228047, 0x06800049, 0x06800047, 0x09608247,
-	0x07800987, 0x09708247, 0x095c224b, 0x060e1809, 0x064e1809,
-	0x0befc049, 0x0c7809c0, 0x078009c7, 0x09608247, 0x07800987,
-	0x09708247, 0x095c1247, 0x060e1809, 0x064e1809, 0x0befc049,
-	0x0be08047, 0x0c780740, 0x068000c9, 0x078009c7, 0x09608247,
-	0x06800047, 0x09708247, 0x060e1809, 0x064e1809, 0x0befc049,
-	0x0c780500, 0x00000000, 0x0a6280c7, 0x068000c9, 0x07800987,
-	0x09708247, 0x078009c7, 0x09608247, 0x060e1809, 0x064e1809,
-	0x0befc049, 0x0c780240, 0x06800049, 0x07800987, 0x09708247,
-	0x078009c7, 0x09608247, 0x060e1809, 0x064e1809, 0x0befc049,
-	0x06800007, 0x06c07e47, 0x0aa2400a, 0x020078c7, 0x06840007,
-	0x06c07e47, 0x0aa1404a, 0x020078c7, 0x06880007, 0x06c07e47,
-	0x020078c7, 0x060e1307, 0x068003c9, 0x07800987, 0x09708247,
+	0x04000294, 0x0a268047, 0x06800008, 0x0400029b, 0x0a25c087,
+	0x06800048, 0x0400029c, 0x0a250107, 0x06800088, 0x0400029d,
+	0x0a244207, 0x068000c8, 0x040002b2, 0x0a238407, 0x06800108,
+	0x040002b3, 0x0a22c807, 0x06800148, 0x040002b4, 0x0a221007,
+	0x06800188, 0x040002b5, 0x0a216007, 0x068001c8, 0x06800047,
+	0x0c7efa40, 0x07c01507, 0x07801607, 0x090041c7, 0x0a8071c8,
+	0x078002c7, 0x0aa08047, 0x0a6200a0, 0x07801607, 0x090841c7,
+	0x0a4051c8, 0x06800047, 0x03407207, 0x0c7ff600, 0x02c091c9,
+	0x07800807, 0x04040248, 0x07400247, 0x07800847, 0x04008249,
+	0x07400247, 0x07802187, 0x04062248, 0x07400247, 0x078021c7,
+	0x0406a248, 0x07400247, 0x07801847, 0x054031c7, 0x02c07807,
+	0x040c0248, 0x07400247, 0x040301c8, 0x07803449, 0x074001c9,
+	0x040381c8, 0x07803409, 0x0a60c060, 0x074001c9, 0x04000848,
+	0x0a6200a0, 0x040c81c8, 0x074001df, 0x07000889, 0x0aa1c009,
+	0x04401249, 0x0c780140, 0x07400889, 0x07803489, 0x074001c9,
+	0x04000887, 0x07c0349f, 0x06800047, 0x03407207, 0x078014c9,
+	0x02c091c9, 0x07c014c9, 0x06803507, 0x02007207, 0x07802e49,
+	0x074001c9, 0x0609b20a, 0x0609b00a, 0x0609b10a, 0x078002c9,
+	0x0aa0c049, 0x068000c9, 0x04001260, 0x07c01489, 0x078002c9,
+	0x0aa38049, 0x0a6080a0, 0x0c780300, 0x07801587, 0x07c015c7,
+	0x07c01588, 0x04000aec, 0x07801609, 0x05404249, 0x09404248,
+	0x07c01609, 0x04000b0a, 0x0c7800c0, 0x00000000, 0x07c01548,
+	0x078020c8, 0x0aa1c0c8, 0x0aa180a0, 0x0aa10020, 0x06800047,
+	0x07800307, 0x044011c7, 0x07c00307, 0x07800187, 0x0b624087,
+	0x06800048, 0x0aa240a0, 0x0aa08020, 0x0aa1c007, 0x078004c9,
+	0x0a60c009, 0x040011c7, 0x07c00187, 0x0c780180, 0x07c001c8,
+	0x06800008, 0x07c001c8, 0x0c7818c0, 0x00000000, 0x0680192d,
+	0x0aa34020, 0x0aa180a0, 0x07800247, 0x0a628047, 0x0680366d,
+	0x0c780200, 0x06804eed, 0x07800247, 0x0aa14007, 0x06805c6d,
+	0x0aa0c087, 0x06806d2d, 0x06804eed, 0x064c1e07, 0x04c181c7,
+	0x060c1e07, 0x0c003440, 0x00000000, 0x0c01d9c0, 0x00000000,
+	0x064c1e08, 0x07800247, 0x0a618087, 0x09c08408, 0x07800547,
+	0x0a60c007, 0x00000000, 0x09808408, 0x060c1e08, 0x0c01de40,
+	0x00000000, 0x0c01f980, 0x00000000, 0x0cb8002d, 0x00000000,
+	0x07800347, 0x0be19007, 0x07802e07, 0x07802f08, 0x096101c8,
+	0x0ae08047, 0x0c780dc0, 0x078022c7, 0x0aa0c007, 0x00000000,
+	0x0fc011c0, 0x0fc021c0, 0x07802d87, 0x0aa0c007, 0x06800208,
+	0x0fc011c0, 0x07c02e47, 0x0c7fb3c0, 0x00000000, 0x06800007,
+	0x07c01407, 0x078001c7, 0x0a60c007, 0x0c780980, 0x00000000,
+	0x0fc091c0, 0x078024c8, 0x0a60c088, 0x078009c8, 0x02407207,
+	0x078016c8, 0x0a802207, 0x07c016c7, 0x0fc011c0, 0x0aa50007,
+	0x0c01b540, 0x00000000, 0x078004c7, 0x0aa18007, 0x07802507,
+	0x0aa0c047, 0x06800087, 0x06800047, 0x07c024c7, 0x0c01a680,
+	0x00000000, 0x078004c7, 0x0aa0c007, 0x00000000, 0x078003a0,
+	0x0aa08008, 0x0c780280, 0x0c010140, 0x06800048, 0x098253a5,
+	0x098253e5, 0x09c251e5, 0x0c7fec40, 0x00000000, 0x0c7ecb80,
+	0x00000000, 0x0683ffc9, 0x04401249, 0x0aaf0009, 0x064c0007,
+	0x0a2f4047, 0x00000000, 0x064c3a07, 0x090061c7, 0x0aae4647,
+	0x00000000, 0x080c2800, 0x080c0002, 0x0c7ec3c0, 0x00000000,
+	0x06b21000, 0x07c01440, 0x0649c014, 0x0649c11b, 0x0649c21c,
+	0x0649c31d, 0x0649d032, 0x0649d133, 0x0649d234, 0x0649d335,
+	0x0680402b, 0x0681412c, 0x0c000440, 0x00000000, 0x08002501,
+	0x08002605, 0x08002708, 0x08002815, 0x08002c14, 0x0cc00000,
+	0x00000000, 0x06800007, 0x07c000c7, 0x07c00107, 0x07c00bc7,
+	0x07c00207, 0x07c00907, 0x0cc00000, 0x07c00947, 0x0649c402,
+	0x07c00642, 0x0649cf23, 0x064c4002, 0x064c4203, 0x02403083,
+	0x040080c3, 0x07c00783, 0x058100c3, 0x07c007c3, 0x064c091f,
+	0x06bfff82, 0x063f0102, 0x06803002, 0x063f0002, 0x06800002,
+	0x063f0002, 0x06bfffc2, 0x063f0102, 0x06800020, 0x07c001a0,
+	0x07c001e0, 0x068000c2, 0x07c024c2, 0x06803fc2, 0x07c01542,
+	0x07c01582, 0x07c015c2, 0x07c01602, 0x060c091f, 0x0680001f,
+	0x07c0149f, 0x07c014df, 0x07c0151f, 0x06800402, 0x07c02002,
+	0x060c1a1f, 0x080c1e01, 0x06800002, 0x060c0c02, 0x06c04042,
+	0x060c0d02, 0x0cc00000, 0x00000000, 0x0649c803, 0x0aa30003,
+	0x00000000, 0x00800000, 0x0649c803, 0x0a60c003, 0x0c7801c0,
+	0x00400000, 0x078014c2, 0x028020c2, 0x07c014c2, 0x0809c800,
+	0x00400000, 0x07801502, 0x0aa0c002, 0x06800102, 0x06030502,
+	0x0b60c224, 0x0cc00000, 0x00000000, 0x00800000, 0x00000000,
+	0x06800007, 0x0c0717c0, 0x07c003c7, 0x080c2800, 0x080c0002,
+	0x06800024, 0x0cc00000, 0x00400000, 0x064c441a, 0x0912169a,
+	0x0aaf801a, 0x0c7ea780, 0x00000000, 0x0683ffe9, 0x04401a69,
+	0x0aa0c029, 0x0649092a, 0x0bef406a, 0x0cc00000, 0x00000000,
+	0x0c07fe40, 0x00000000, 0x06800168, 0x0649072a, 0x09503aa8,
+	0x07800328, 0x09421aa8, 0x07800268, 0x0aa0c0a8, 0x0982a0ea,
+	0x09c2a0ea, 0x078029a8, 0x0a60c028, 0x06d1412a, 0x0982a7ea,
+	0x0609072a, 0x06490b2a, 0x0982a02a, 0x06090b2a, 0x09c2a02a,
+	0x0982a52a, 0x0982a56a, 0x0982a5aa, 0x078020e8, 0x0aa0c0e8,
+	0x06800029, 0x06800069, 0x095c1aa9, 0x07800268, 0x0a63c0a8,
+	0x06803528, 0x078015e9, 0x06800029, 0x02029a68, 0x07000a68,
+	0x09541aa8, 0x06803528, 0x078015a9, 0x06800029, 0x02029a68,
+	0x07000a68, 0x09561aa8, 0x0c780340, 0x0982a4ea, 0x06803528,
+	0x078015e9, 0x02029a68, 0x07000a68, 0x09541aa8, 0x06803528,
+	0x078015a9, 0x02029a68, 0x07000a68, 0x09561aa8, 0x09c2a4ea,
+	0x06090b2a, 0x07801428, 0x0aa0c068, 0x0c784680, 0x00000000,
+	0x0680000d, 0x078029ce, 0x078002e8, 0x0aa1c068, 0x0a618020,
+	0x00000000, 0x0680000e, 0x07c029ce, 0x0c780440, 0x00000000,
+	0x0780144a, 0x0aa2c060, 0x09082a4a, 0x09102a4a, 0x078004e8,
+	0x0aa10068, 0x00000000, 0x09182a0a, 0x02c29a29, 0x0908134a,
+	0x090a1a8a, 0x02c0da8d, 0x0aa0c029, 0x00000000, 0x0680004e,
+	0x06490b2a, 0x09501a8e, 0x09521a8d, 0x06090b2a, 0x0a61000e,
+	0x0a60c00d, 0x0c783a80, 0x00000000, 0x06800007, 0x06804008,
+	0x0680c009, 0x0680000a, 0x0c003d40, 0x00000000, 0x0780144f,
+	0x0aa140a0, 0x078002c7, 0x0aa0c047, 0x0c781240, 0x00000000,
+	0x06490b07, 0x058081c7, 0x0be0c047, 0x0c780ac0, 0x00000000,
+	0x0910234f, 0x0aa2400d, 0x091421cf, 0x040031c7, 0x054081c7,
+	0x0540820d, 0x06804009, 0x0680004a, 0x0c003800, 0x00000000,
+	0x078004c7, 0x0aa30047, 0x0918220f, 0x0aa28008, 0x091c21cf,
+	0x02c0d20d, 0x040031c7, 0x054081c7, 0x05408208, 0x06804009,
+	0x0680004a, 0x0c0034c0, 0x00000000, 0x0be1404d, 0x00000000,
+	0x06804007, 0x0c005c80, 0x00000000, 0x0be1408d, 0x00000000,
+	0x06808007, 0x0c005b40, 0x00000000, 0x06804007, 0x06800008,
+	0x0c005580, 0x00000000, 0x06808007, 0x06800048, 0x0c005480,
+	0x00000000, 0x06490b07, 0x058091c7, 0x0be0c047, 0x0c782940,
+	0x00000000, 0x0908234f, 0x0aa4400d, 0x090c21cf, 0x040031c7,
+	0x054081c7, 0x0540820d, 0x06804009, 0x0680004a, 0x0c002c80,
+	0x00000000, 0x054081cd, 0x06800088, 0x0c004fc0, 0x00000000,
+	0x06490b07, 0x0902120d, 0x096e11c8, 0x06090b07, 0x0c782440,
+	0x00000000, 0x0908220f, 0x0aa24008, 0x090c21cf, 0x040031c7,
+	0x054081c7, 0x05408208, 0x06804009, 0x0680004a, 0x0c002780,
+	0x00000000, 0x090823cf, 0x0aa0c04f, 0x06808007, 0x06804007,
+	0x0c004f00, 0x00000000, 0x0be100cf, 0x06808007, 0x0c004e00,
+	0x00000000, 0x078029c7, 0x0a608007, 0x0c781340, 0x07802a07,
+	0x07802a48, 0x0680070c, 0x0c0026c0, 0x00000000, 0x07800247,
+	0x0aa0c087, 0x0c780ac0, 0x00000000, 0x06800048, 0x07800b87,
+	0x0a610087, 0x06804010, 0x06808010, 0x06800088, 0x0a80320f,
+	0x06800051, 0x06800011, 0x040001d0, 0x0680c008, 0x04000251,
+	0x0c003980, 0x00000000, 0x040801d0, 0x0680e008, 0x04000251,
+	0x0c003840, 0x00000000, 0x07800b87, 0x0a64c007, 0x07800a47,
+	0x07800a88, 0x0680070c, 0x0c001f40, 0x00000000, 0x0aa0c08f,
+	0x06800051, 0x06800011, 0x06808007, 0x0680c008, 0x04000251,
+	0x0c003480, 0x00000000, 0x0680a007, 0x0680e008, 0x04000251,
+	0x0c003340, 0x00000000, 0x0c780700, 0x00000000, 0x0aa0c04f,
+	0x06800051, 0x06800011, 0x06804007, 0x0680c008, 0x04000251,
+	0x0c0030c0, 0x00000000, 0x06806007, 0x0680e008, 0x04000251,
+	0x0c002f80, 0x00000000, 0x0aa0c08f, 0x06800051, 0x06800011,
+	0x06808007, 0x0680c008, 0x04000251, 0x0c002d80, 0x00000000,
+	0x0680a007, 0x0680e008, 0x04000251, 0x0c002c40, 0x00000000,
+	0x06804007, 0x06800008, 0x0c003480, 0x00000000, 0x06808007,
+	0x06800048, 0x0c003380, 0x00000000, 0x07800247, 0x0aa20007,
+	0x0aa1c047, 0x078024c7, 0x0aa24047, 0x0680004c, 0x0680008c,
+	0x0c780180, 0x00000000, 0x07802507, 0x0aa0c047, 0x0680004c,
+	0x0680008c, 0x0780144f, 0x094823cc, 0x07c0144f, 0x090c21cf,
+	0x040031c7, 0x054081c7, 0x0540820c, 0x06804009, 0x0680000a,
+	0x0c000940, 0x00000000, 0x090421cf, 0x040031c7, 0x054081c7,
+	0x068000c8, 0x02408308, 0x094023c8, 0x07c0144f, 0x05408208,
+	0x06804009, 0x0680000a, 0x0c000640, 0x00000000, 0x06800007,
+	0x06804008, 0x0680c009, 0x0680004a, 0x0c0004c0, 0x00000000,
+	0x0aa3c0a0, 0x078002c7, 0x0aa34047, 0x07800247, 0x0aa0c087,
+	0x06800048, 0x06800088, 0x07801447, 0x091c2247, 0x054041c7,
+	0x094421c9, 0x04401208, 0x0a6f0008, 0x00000000, 0x07c01447,
+	0x0cc00000, 0x00000000, 0x06035209, 0x06a00009, 0x06c0bc89,
+	0x020098c9, 0x054011c7, 0x02007247, 0x06035107, 0x098083c8,
+	0x095c120a, 0x06035008, 0x06435007, 0x0580f1c7, 0x0bef8047,
+	0x0cc00000, 0x00000000, 0x0906238c, 0x0540838e, 0x0a628007,
+	0x00000000, 0x06bff007, 0x05407248, 0x068ff00a, 0x0240924a,
+	0x0b2207c8, 0x06880008, 0x0c780180, 0x02009209, 0x0b20c7c8,
+	0x040201c7, 0x04440208, 0x05406248, 0x0684c008, 0x090212cc,
+	0x094e120b, 0x06094008, 0x0680000b, 0x06800008, 0x0e000207,
+	0x00000000, 0x00000000, 0x0f000280, 0x0402028a, 0x0200a24a,
+	0x05c0628a, 0x0b213fca, 0x00000000, 0x0c780140, 0x06803fca,
+	0x0b60c00a, 0x00000000, 0x0680000a, 0x054082cb, 0x0200b28b,
+	0x04001208, 0x0be300c8, 0x00000000, 0x0a20c04c, 0x00000000,
+	0x0609410b, 0x0a21c10c, 0x0921034b, 0x0740038d, 0x0400138e,
+	0x0901034b, 0x0740038d, 0x0400138e, 0x0b28ffc8, 0x00000000,
+	0x0684d008, 0x090212cc, 0x094e120b, 0x06094008, 0x0680000b,
+	0x06800008, 0x04480248, 0x0e000247, 0x00000000, 0x00000000,
+	0x0f000280, 0x06880809, 0x0200a24a, 0x05c0628a, 0x0b213fca,
+	0x00000000, 0x0c780140, 0x06803fca, 0x0b60c00a, 0x00000000,
+	0x0680000a, 0x054082cb, 0x0200b28b, 0x04001208, 0x0be300c8,
+	0x00000000, 0x0a20c04c, 0x00000000, 0x0609410b, 0x0a21c10c,
+	0x0921034b, 0x0740038d, 0x0400138e, 0x0901034b, 0x0740038d,
+	0x0400138e, 0x0b28bfc8, 0x00000000, 0x0cc00000, 0x08094000,
+	0x0680000a, 0x0aa0c049, 0x0c780440, 0x00000000, 0x070001c9,
+	0x091082c9, 0x0c000540, 0x00000000, 0x0950824c, 0x090082c9,
+	0x0c000440, 0x00000000, 0x0940824c, 0x074001c9, 0x0400128a,
+	0x0bad600a, 0x040011c7, 0x0c780200, 0x00000000, 0x07000209,
+	0x074001c9, 0x0400128a, 0x040011c7, 0x0baf200a, 0x04001208,
+	0x0cc00000, 0x00000000, 0x0580130b, 0x0200d308, 0x0700034c,
+	0x040012cb, 0x090012cb, 0x054032cb, 0x0380c2cc, 0x048ff30c,
+	0x0cc00000, 0x00000000, 0x0684c00a, 0x0a20c088, 0x06800049,
+	0x06800089, 0x09584289, 0x04801208, 0x094e1288, 0x0609400a,
+	0x0680000a, 0x070001c9, 0x040011c7, 0x070001cb, 0x096102c9,
+	0x0609410b, 0x0400128a, 0x0baea00a, 0x040011c7, 0x0cc00000,
+	0x08094000, 0x0680000a, 0x0487f24a, 0x05401249, 0x04001209,
+	0x09508209, 0x074001c8, 0x0400128a, 0x0b2ebfca, 0x040011c7,
+	0x0cc00000, 0x00000000, 0x0cc00000, 0x00000000, 0x06490628,
+	0x0aef4c28, 0x00000000, 0x064c2328, 0x0a240228, 0x069001a8,
+	0x069fffea, 0x06090628, 0x07800028, 0x078016e9, 0x09508a68,
+	0x06090629, 0x06800028, 0x06090628, 0x05401a28, 0x02828aa8,
+	0x06090628, 0x06985168, 0x0cc00000, 0x06090628, 0x07800028,
+	0x078016e9, 0x09508a68, 0x068000a8, 0x06c00028, 0x06090628,
+	0x06090629, 0x06881068, 0x06090628, 0x0cc00000, 0x00000000,
+	0x078003c7, 0x0a6fc007, 0x07800507, 0x0b20c047, 0x040011c7,
+	0x06800007, 0x07c00507, 0x06800047, 0x07c003c7, 0x0cc00000,
+	0x08030580, 0x064e1215, 0x091e1555, 0x0a208055, 0x0c781280,
+	0x078003d5, 0x0aa08055, 0x0c780b40, 0x07800596, 0x0aa2c016,
+	0x04401596, 0x07c00596, 0x078005d6, 0x04401596, 0x064c2315,
+	0x0a20c215, 0x00000000, 0x080e1601, 0x0c780e80, 0x07c005d6,
+	0x07800916, 0x07800295, 0x05408555, 0x02015595, 0x04004596,
+	0x07c00916, 0x05404595, 0x020168d6, 0x060e1316, 0x07800517,
+	0x0aa14017, 0x06a1a196, 0x0aa0c057, 0x06a1a496, 0x06a1a016,
+	0x07c00416, 0x0683ffd7, 0x044015d7, 0x0b214017, 0x064e1615,
+	0x09010555, 0x0aaf0015, 0x00000000, 0x064c2315, 0x0be0c215,
+	0x00000000, 0x080e1600, 0x06c00016, 0x060e1216, 0x06800095,
+	0x0c780700, 0x07c003d5, 0x0a660095, 0x078005d6, 0x0aa18016,
+	0x04401596, 0x0b210056, 0x07c005d6, 0x0c780480, 0x00000000,
+	0x07800956, 0x07800295, 0x05408555, 0x02015595, 0x04004596,
+	0x07c00956, 0x05404595, 0x020168d6, 0x060e1316, 0x07800415,
+	0x09c151d5, 0x06c00015, 0x060e1215, 0x068000d5, 0x0c780100,
+	0x07c003d5, 0x06800015, 0x07c003d5, 0x0cc00000, 0x00400000,
+	0x0fc011c0, 0x05403207, 0x0fc011c0, 0x0a62c007, 0x0fc011c0,
+	0x0a634007, 0x0fc011c0, 0x0a63c007, 0x06800107, 0x0fc011c0,
+	0x0a630007, 0x06800147, 0x0c780280, 0x06800187, 0x0aa20007,
+	0x06800007, 0x0c780180, 0x06800047, 0x0aa10007, 0x06800087,
+	0x0c780080, 0x068000c7, 0x0a610187, 0x09403207, 0x0cc00000,
+	0x00000000, 0x0c0757c0, 0x00000000, 0x0c00fc40, 0x00000000,
+	0x0aa08007, 0x0a62c107, 0x06800149, 0x07800987, 0x09708247,
 	0x078009c7, 0x09608247, 0x060e1809, 0x064e1807, 0x0befc047,
-	0x00000000, 0x0649d907, 0x0900c1c7, 0x0a6f8007, 0x06b04009,
-	0x06800007, 0x06c07e47, 0x0aa2c00a, 0x020078c7, 0x06840007,
-	0x06c07e47, 0x020078c7, 0x0aa1804a, 0x06b08009, 0x06880007,
-	0x06c07e47, 0x020078c7, 0x06b0c009, 0x06035107, 0x06804007,
-	0x06035207, 0x06035009, 0x06435007, 0x0580f1c7, 0x0bef8047,
-	0x0900b249, 0x07000247, 0x091e11c7, 0x07800089, 0x0aa1c00a,
-	0x0680004b, 0x0aa2004a, 0x00000000, 0x07c00bcb, 0x0c7801c0,
-	0x095e1247, 0x07c000cb, 0x0c780100, 0x095a1247, 0x07c0010b,
-	0x095c1247, 0x07c00089, 0x0cc00000, 0x00000000, 0x06b04009,
-	0x06800007, 0x06c07e47, 0x0aa3000a, 0x020078c7, 0x06840007,
-	0x06c07e47, 0x020078c7, 0x0aa1c04a, 0x06b08009, 0x06880007,
-	0x06c07e47, 0x020078c7, 0x0aa0804a, 0x06b0c009, 0x05404288,
-	0x02007287, 0x06035107, 0x06804007, 0x06035207, 0x06035009,
-	0x06435007, 0x0580f1c7, 0x0bef8047, 0x0cc00000, 0x00000000,
-	0x07802407, 0x0a628007, 0x078025c7, 0x0b220207, 0x0b21c707,
-	0x044031c7, 0x0b214687, 0x040011c7, 0x0b20c707, 0x040011c7,
-	0x040011c7, 0x07c02647, 0x07802407, 0x0aa28047, 0x0aa20087,
-	0x06800048, 0x0aa180c7, 0x06800008, 0x078025c7, 0x0b20c207,
-	0x06800008, 0x06800048, 0x07c02688, 0x0cc00000, 0x00000000,
-	0x078020c7, 0x0aa080c7, 0x0c780dc0, 0x0a610008, 0x078004c7,
-	0x0aa08007, 0x0c7819c0, 0x07802287, 0x0aa0c007, 0x07802248,
-	0x0fc081c0, 0x0aa28008, 0x07802307, 0x0a620007, 0x07802207,
-	0x0a630007, 0x06800047, 0x07c02507, 0x06800007, 0x0c780500,
-	0x07c02547, 0x07802207, 0x0aa0c007, 0x06800007, 0x0fc021c0,
-	0x0c780380, 0x07c02587, 0x0fc011c0, 0x07c02507, 0x0aa20047,
-	0x07800247, 0x0a618087, 0x06800087, 0x07c024c7, 0x064c0408,
-	0x094c2207, 0x060c0408, 0x0fc011c0, 0x07c02547, 0x07802387,
-	0x0aa18007, 0x00000000, 0x0fc011c0, 0x0aa0c007, 0x0c780000,
-	0x00000000, 0x0fc011c0, 0x07c00307, 0x07802247, 0x0aa0c007,
-	0x078022c7, 0x0fc01200, 0x07800248, 0x0a610008, 0x0aa0c007,
-	0x00000000, 0x0fc011c0, 0x0aa440a0, 0x07800247, 0x0a634087,
-	0x07800447, 0x0aa28007, 0x06800008, 0x0fc02200, 0x0ba1c0c8,
-	0x00000000, 0x0fc011c0, 0x0aa10007, 0x0b60c408, 0x0c7fff40,
-	0x04001208, 0x07c00488, 0x0c780800, 0x00000000, 0x07800247,
-	0x0a60c047, 0x0c780840, 0x00000000, 0x080c2803, 0x064c2807,
-	0x0a2fc047, 0x05801207, 0x07c02c88, 0x080c2800, 0x06800007,
-	0x0960f1c8, 0x060c3d07, 0x078020c7, 0x0aa540c7, 0x091831c8,
-	0x0a638087, 0x091041c8, 0x0a630007, 0x06800048, 0x07c002c8,
-	0x0fc071c0, 0x06800020, 0x078024c8, 0x07800247, 0x09482207,
-	0x05406208, 0x09403220, 0x0c7801c0, 0x060c0408, 0x078020c7,
-	0x0aa100c7, 0x0a60c020, 0x00000000, 0x0fc071c0, 0x0fc051c0,
-	0x07c025c7, 0x0ae0c207, 0x06800007, 0x0fc011c0, 0x07c02607,
-	0x07802407, 0x0a614047, 0x00000000, 0x0fc011c0, 0x040021c7,
-	0x07c02687, 0x0c07db80, 0x00000000, 0x078020c7, 0x0a6080c7,
-	0x0c780840, 0x07802907, 0x0aa28007, 0x06800008, 0x0fc011c0,
-	0x0aa1c007, 0x06800008, 0x0fc011c0, 0x0aa10007, 0x06800048,
-	0x0fc011c0, 0x04002207, 0x07c02948, 0x0aa200a0, 0x06800008,
-	0x078002c7, 0x0aa14047, 0x07802d07, 0x0aa0c007, 0x00000000,
-	0x0fc02200, 0x07c02e88, 0x0aa28060, 0x0aa240a0, 0x06800188,
-	0x07c026c8, 0x07802648, 0x0ba0c248, 0x06800007, 0x07802447,
-	0x0c786200, 0x00000000, 0x0c781080, 0x07802487, 0x0aa0c007,
-	0x00000000, 0x0fc021c0, 0x0a63c0a0, 0x07800247, 0x0a634047,
-	0x00000000, 0x080c2803, 0x064c2807, 0x0a2fc047, 0x05801207,
-	0x07c02c88, 0x080c2800, 0x06800007, 0x0960f1c8, 0x060c3d07,
-	0x0c7803c0, 0x06800007, 0x07800247, 0x0a630087, 0x06800007,
-	0x0aa10060, 0x0a6240a0, 0x0c780200, 0x06800047, 0x0fc011c0,
-	0x0a618007, 0x07c00547, 0x0fc011c0, 0x0c7800c0, 0x07c00887,
-	0x07c00547, 0x0aa0c0a0, 0x0aa08060, 0x0c785280, 0x07802907,
-	0x0aa28007, 0x06800008, 0x0fc011c0, 0x0aa1c007, 0x06800008,
-	0x0fc011c0, 0x0aa10007, 0x06800048, 0x0fc011c0, 0x04002207,
-	0x07c02948, 0x07800247, 0x0aa3c007, 0x06800008, 0x07800a07,
-	0x0aa30007, 0x06800008, 0x0fc011c0, 0x0aa24007, 0x06800008,
-	0x0fc011c0, 0x0aa18007, 0x06800088, 0x0fc011c0, 0x0aa0c007,
-	0x06800048, 0x068000c8, 0x07c00b48, 0x0aa18060, 0x07800247,
-	0x0aa2c047, 0x06800088, 0x0c784240, 0x00000000, 0x07800247,
-	0x0a620047, 0x00000000, 0x0fc011c0, 0x0aa0c007, 0x06800088,
-	0x068000c8, 0x0c780d00, 0x0fc01240, 0x06800009, 0x07802647,
-	0x0ae68307, 0x0fc011c0, 0x0a658007, 0x06800088, 0x0fc011c0,
-	0x0a64c007, 0x068000c8, 0x0fc011c0, 0x0a640007, 0x06800048,
-	0x0fc011c0, 0x0aa34007, 0x06800008, 0x06800049, 0x0fc011c0,
+	0x0c781800, 0x00000000, 0x0aa0c047, 0x0aa08147, 0x0c781280,
+	0x0780098b, 0x0ba0c0cb, 0x0c7fffc0, 0x044032cb, 0x078009c9,
+	0x0ba0c0c9, 0x0c7fffc0, 0x04403249, 0x0a614009, 0x068001c9,
+	0x0aa0c00b, 0x0c780a80, 0x06800249, 0x07800987, 0x09708247,
+	0x078009c7, 0x09608247, 0x095c224b, 0x09581247, 0x060e1809,
+	0x064e1809, 0x0befc049, 0x0aa4c00b, 0x068000c9, 0x078009c7,
+	0x09608247, 0x06800047, 0x09708247, 0x060e1809, 0x064e1809,
+	0x0befc049, 0x0aa2804b, 0x068000c9, 0x078009c7, 0x09608247,
+	0x06800047, 0x09708247, 0x09809389, 0x060e1809, 0x064e1809,
+	0x0befc049, 0x078009c7, 0x0a228047, 0x06800049, 0x06800047,
+	0x09608247, 0x07800987, 0x09708247, 0x095c224b, 0x060e1809,
+	0x064e1809, 0x0befc049, 0x0c7809c0, 0x078009c7, 0x09608247,
+	0x07800987, 0x09708247, 0x095c1247, 0x060e1809, 0x064e1809,
+	0x0befc049, 0x0be08047, 0x0c780740, 0x068000c9, 0x078009c7,
+	0x09608247, 0x06800047, 0x09708247, 0x060e1809, 0x064e1809,
+	0x0befc049, 0x0c780500, 0x00000000, 0x0a6280c7, 0x068000c9,
+	0x07800987, 0x09708247, 0x078009c7, 0x09608247, 0x060e1809,
+	0x064e1809, 0x0befc049, 0x0c780240, 0x06800049, 0x07800987,
+	0x09708247, 0x078009c7, 0x09608247, 0x060e1809, 0x064e1809,
+	0x0befc049, 0x06800007, 0x06c0bc87, 0x0aa2400a, 0x020078c7,
+	0x06840007, 0x06c0bc87, 0x0aa1404a, 0x020078c7, 0x06880007,
+	0x06c0bc87, 0x020078c7, 0x060e1307, 0x068003c9, 0x07800987,
+	0x09708247, 0x078009c7, 0x09608247, 0x060e1809, 0x064e1807,
+	0x0befc047, 0x00000000, 0x0649d907, 0x0900c1c7, 0x0a6f8007,
+	0x06b04009, 0x06800007, 0x06c0bc87, 0x0aa2c00a, 0x020078c7,
+	0x06840007, 0x06c0bc87, 0x020078c7, 0x0aa1804a, 0x06b08009,
+	0x06880007, 0x06c0bc87, 0x020078c7, 0x06b0c009, 0x06035107,
+	0x06804007, 0x06035207, 0x06035009, 0x06435007, 0x0580f1c7,
+	0x0bef8047, 0x0900b249, 0x07000247, 0x091e11c7, 0x07800089,
+	0x0aa1c00a, 0x0680004b, 0x0aa2004a, 0x00000000, 0x07c00bcb,
+	0x0c7801c0, 0x095e1247, 0x07c000cb, 0x0c780100, 0x095a1247,
+	0x07c0010b, 0x095c1247, 0x07c00089, 0x0cc00000, 0x00000000,
+	0x06b04009, 0x06800007, 0x06c0bc87, 0x0aa3000a, 0x020078c7,
+	0x06840007, 0x06c0bc87, 0x020078c7, 0x0aa1c04a, 0x06b08009,
+	0x06880007, 0x06c0bc87, 0x020078c7, 0x0aa0804a, 0x06b0c009,
+	0x05404288, 0x02007287, 0x06035107, 0x06804007, 0x06035207,
+	0x06035009, 0x06435007, 0x0580f1c7, 0x0bef8047, 0x0cc00000,
+	0x00000000, 0x07802407, 0x0a628007, 0x078025c7, 0x0b220207,
+	0x0b21c707, 0x044031c7, 0x0b214687, 0x040011c7, 0x0b20c707,
+	0x040011c7, 0x040011c7, 0x07c02647, 0x07802407, 0x0aa28047,
+	0x0aa20087, 0x06800048, 0x0aa180c7, 0x06800008, 0x078025c7,
+	0x0b20c207, 0x06800008, 0x06800048, 0x07c02688, 0x0cc00000,
+	0x00000000, 0x078020c7, 0x0aa080c7, 0x0c780dc0, 0x0a610008,
+	0x078004c7, 0x0aa08007, 0x0c7819c0, 0x07802287, 0x0aa0c007,
+	0x07802248, 0x0fc081c0, 0x0aa28008, 0x07802307, 0x0a620007,
+	0x07802207, 0x0a630007, 0x06800047, 0x07c02507, 0x06800007,
+	0x0c780500, 0x07c02547, 0x07802207, 0x0aa0c007, 0x06800007,
+	0x0fc021c0, 0x0c780380, 0x07c02587, 0x0fc011c0, 0x07c02507,
+	0x0aa20047, 0x07800247, 0x0a618087, 0x06800087, 0x07c024c7,
+	0x064c0408, 0x094c2207, 0x060c0408, 0x0fc011c0, 0x07c02547,
+	0x07802387, 0x0aa18007, 0x00000000, 0x0fc011c0, 0x0aa0c007,
+	0x0c780000, 0x00000000, 0x0fc011c0, 0x07c00307, 0x07802247,
+	0x0aa0c007, 0x078022c7, 0x0fc01200, 0x07800248, 0x0a610008,
+	0x0aa0c007, 0x00000000, 0x0fc011c0, 0x0aa440a0, 0x07800247,
+	0x0a634087, 0x07800447, 0x0aa28007, 0x06800008, 0x0fc02200,
+	0x0ba1c0c8, 0x00000000, 0x0fc011c0, 0x0aa10007, 0x0b60c408,
+	0x0c7fff40, 0x04001208, 0x07c00488, 0x0c780800, 0x00000000,
+	0x07800247, 0x0a60c047, 0x0c780840, 0x00000000, 0x080c2803,
+	0x064c2807, 0x0a2fc047, 0x05801207, 0x07c02c88, 0x080c2800,
+	0x06800007, 0x0960f1c8, 0x060c3d07, 0x078020c7, 0x0aa540c7,
+	0x091831c8, 0x0a638087, 0x091041c8, 0x0a630007, 0x06800048,
+	0x07c002c8, 0x0fc071c0, 0x06800020, 0x078024c8, 0x07800247,
+	0x09482207, 0x05406208, 0x09403220, 0x0c7801c0, 0x060c0408,
+	0x078020c7, 0x0aa100c7, 0x0a60c020, 0x00000000, 0x0fc071c0,
+	0x0fc051c0, 0x07c025c7, 0x0ae0c207, 0x06800007, 0x0fc011c0,
+	0x07c02607, 0x07802407, 0x0a614047, 0x00000000, 0x0fc011c0,
+	0x040021c7, 0x07c02687, 0x0c07db80, 0x00000000, 0x078020c7,
+	0x0a6080c7, 0x0c780840, 0x07802907, 0x0aa28007, 0x06800008,
+	0x0fc011c0, 0x0aa1c007, 0x06800008, 0x0fc011c0, 0x0aa10007,
+	0x06800048, 0x0fc011c0, 0x04002207, 0x07c02948, 0x0aa200a0,
+	0x06800008, 0x078002c7, 0x0aa14047, 0x07802d07, 0x0aa0c007,
+	0x00000000, 0x0fc02200, 0x07c02e88, 0x0aa28060, 0x0aa240a0,
+	0x06800188, 0x07c026c8, 0x07802648, 0x0ba0c248, 0x06800007,
+	0x07802447, 0x0c786200, 0x00000000, 0x0c781080, 0x07802487,
+	0x0aa0c007, 0x00000000, 0x0fc021c0, 0x0a63c0a0, 0x07800247,
+	0x0a634047, 0x00000000, 0x080c2803, 0x064c2807, 0x0a2fc047,
+	0x05801207, 0x07c02c88, 0x080c2800, 0x06800007, 0x0960f1c8,
+	0x060c3d07, 0x0c7803c0, 0x06800007, 0x07800247, 0x0a630087,
+	0x06800007, 0x0aa10060, 0x0a6240a0, 0x0c780200, 0x06800047,
+	0x0fc011c0, 0x0a618007, 0x07c00547, 0x0fc011c0, 0x0c7800c0,
+	0x07c00887, 0x07c00547, 0x0aa0c0a0, 0x0aa08060, 0x0c785280,
+	0x07802907, 0x0aa28007, 0x06800008, 0x0fc011c0, 0x0aa1c007,
+	0x06800008, 0x0fc011c0, 0x0aa10007, 0x06800048, 0x0fc011c0,
+	0x04002207, 0x07c02948, 0x07800247, 0x0aa3c007, 0x06800008,
+	0x07800a07, 0x0aa30007, 0x06800008, 0x0fc011c0, 0x0aa24007,
+	0x06800008, 0x0fc011c0, 0x0aa18007, 0x06800088, 0x0fc011c0,
+	0x0aa0c007, 0x06800048, 0x068000c8, 0x07c00b48, 0x0aa18060,
+	0x07800247, 0x0aa2c047, 0x06800088, 0x0c784240, 0x00000000,
+	0x07800247, 0x0a620047, 0x00000000, 0x0fc011c0, 0x0aa0c007,
+	0x06800088, 0x068000c8, 0x0c780d00, 0x0fc01240, 0x06800009,
+	0x07802647, 0x0ae68307, 0x0fc011c0, 0x0a658007, 0x06800088,
+	0x0fc011c0, 0x0a64c007, 0x068000c8, 0x0fc011c0, 0x0a640007,
+	0x06800048, 0x0fc011c0, 0x0aa34007, 0x06800008, 0x06800049,
+	0x0fc011c0, 0x0a624007, 0x06800088, 0x0fc011c0, 0x0a618007,
+	0x068000c8, 0x0fc011c0, 0x0aa0c007, 0x06800008, 0x06800048,
+	0x0c780600, 0x00000000, 0x0a658007, 0x06800008, 0x0fc011c0,
+	0x0a64c007, 0x06800088, 0x0fc011c0, 0x0a640007, 0x06800048,
+	0x0fc011c0, 0x0aa34007, 0x068000c8, 0x06800049, 0x0fc011c0,
+	0x0a624007, 0x06800008, 0x0fc011c0, 0x0a618007, 0x06800088,
+	0x0fc011c0, 0x0aa0c007, 0x068000c8, 0x06800048, 0x07c02988,
+	0x07c029c9, 0x0aa68009, 0x00000000, 0x07800247, 0x0a64c087,
+	0x00000000, 0x0fc011c0, 0x0a610007, 0x06800008, 0x0fc011c0,
+	0x04001207, 0x07c00b88, 0x0fc061c0, 0x07c02a07, 0x0fc061c0,
+	0x07c02a47, 0x0a62c008, 0x00000000, 0x0fc061c0, 0x07c00a47,
+	0x0fc061c0, 0x0c780180, 0x07c00a87, 0x0fc061c0, 0x07c02a07,
+	0x0fc061c0, 0x07c02a47, 0x07800247, 0x0aa14007, 0x0a608087,
+	0x0c780bc0, 0x0aa100a0, 0x0c780840, 0x0c781240, 0x00000000,
+	0x0c077040, 0x0680000a, 0x07c02cc8, 0x0c076f80, 0x0680004a,
+	0x07c02ac8, 0x0fc021c0, 0x07c02bc7, 0x0fc021c0, 0x07c02b07,
+	0x0fc031c0, 0x07c02b47, 0x0fc021c0, 0x07c00b07, 0x07802707,
+	0x07800b48, 0x096621c8, 0x07802988, 0x096221c8, 0x07802c48,
+	0x096011c8, 0x07802948, 0x094421c8, 0x07802cc8, 0x095841c8,
+	0x07802ac8, 0x095041c8, 0x04c101c7, 0x0c780a00, 0x060c2107,
+	0x0c0768c0, 0x0680004a, 0x07c02ac8, 0x0fc021c0, 0x07c02bc7,
+	0x0fc021c0, 0x07c02b07, 0x0fc031c0, 0x07c02b47, 0x0fc021c0,
+	0x0c780300, 0x07c00b07, 0x0fc031c0, 0x07c02bc7, 0x07800547,
+	0x0aa0c007, 0x06800087, 0x068000c7, 0x0f8001c7, 0x07c02b07,
+	0x0fc031c0, 0x07c02b47, 0x07802707, 0x07800b48, 0x096621c8,
+	0x07802c48, 0x096011c8, 0x07802948, 0x094421c8, 0x07802ac8,
+	0x095041c8, 0x07802988, 0x096221c8, 0x04c101c7, 0x060c2107,
+	0x0aa0c0c8, 0x0c780800, 0x00000000, 0x0fc021c0, 0x0c780740,
+	0x07c008c7, 0x0a6100c8, 0x068001c8, 0x0c075e00, 0x0680000a,
+	0x07c02a88, 0x0c075d40, 0x0680004a, 0x07c02ac8, 0x07802707,
+	0x07800b48, 0x096621c8, 0x07802988, 0x096221c8, 0x07802c48,
+	0x096011c8, 0x07802948, 0x094421c8, 0x07802a88, 0x095841c8,
+	0x07802ac8, 0x095041c8, 0x04c101c7, 0x060c2107, 0x0fc021c0,
+	0x07c02b07, 0x0fc021c0, 0x07c02b47, 0x0c004d80, 0x00000000,
+	0x07802b87, 0x0aa18007, 0x06800008, 0x0fc011c0, 0x0aa0c007,
+	0x06800108, 0x0fc02200, 0x07c02c08, 0x0fc011c0, 0x0aa10007,
+	0x06800007, 0x0fc011c0, 0x040011c7, 0x07c02787, 0x0fc011c0,
+	0x0c7824c0, 0x07c02807, 0x07802647, 0x0ae34307, 0x0fc011c0,
 	0x0a624007, 0x06800088, 0x0fc011c0, 0x0a618007, 0x068000c8,
-	0x0fc011c0, 0x0aa0c007, 0x06800008, 0x06800048, 0x0c780600,
-	0x00000000, 0x0a658007, 0x06800008, 0x0fc011c0, 0x0a64c007,
-	0x06800088, 0x0fc011c0, 0x0a640007, 0x06800048, 0x0fc011c0,
-	0x0aa34007, 0x068000c8, 0x06800049, 0x0fc011c0, 0x0a624007,
-	0x06800008, 0x0fc011c0, 0x0a618007, 0x06800088, 0x0fc011c0,
-	0x0aa0c007, 0x068000c8, 0x06800048, 0x07c02988, 0x07c029c9,
-	0x0aa68009, 0x00000000, 0x07800247, 0x0a64c087, 0x00000000,
-	0x0fc011c0, 0x0a610007, 0x06800008, 0x0fc011c0, 0x04001207,
-	0x07c00b88, 0x0fc061c0, 0x07c02a07, 0x0fc061c0, 0x07c02a47,
-	0x0a62c008, 0x00000000, 0x0fc061c0, 0x07c01207, 0x0fc061c0,
-	0x0c780180, 0x07c01247, 0x0fc061c0, 0x07c02a07, 0x0fc061c0,
-	0x07c02a47, 0x07800247, 0x0aa14007, 0x0a608087, 0x0c780bc0,
-	0x0aa100a0, 0x0c780840, 0x0c781240, 0x00000000, 0x0c077040,
-	0x0680000a, 0x07c02cc8, 0x0c076f80, 0x0680004a, 0x07c02ac8,
-	0x0fc021c0, 0x07c02bc7, 0x0fc021c0, 0x07c02b07, 0x0fc031c0,
-	0x07c02b47, 0x0fc021c0, 0x07c012c7, 0x07802707, 0x07800b48,
+	0x0fc011c0, 0x0a60c007, 0x06800048, 0x06800008, 0x0c7802c0,
+	0x00000000, 0x0a624007, 0x06800008, 0x0fc011c0, 0x0a618007,
+	0x06800088, 0x0fc011c0, 0x0a60c007, 0x06800048, 0x068000c8,
+	0x07c02988, 0x0c074d00, 0x0680000a, 0x07c02ec8, 0x0fc031c0,
+	0x07c02bc7, 0x07800547, 0x0aa0c007, 0x06800087, 0x068000c7,
+	0x0f8001c7, 0x07c02b07, 0x0fc031c0, 0x07c02b47, 0x07802707,
+	0x07800b48, 0x096621c8, 0x07802c48, 0x096011c8, 0x07802948,
+	0x094421c8, 0x07802ec8, 0x095841c8, 0x07802988, 0x096221c8,
+	0x04c101c7, 0x0c7fe6c0, 0x060c2107, 0x07800247, 0x0aa0c007,
+	0x0c7ff2c0, 0x00000000, 0x0fc011c0, 0x0aa0c007, 0x06800008,
+	0x06800088, 0x07c02988, 0x0c074400, 0x0680000a, 0x07c02cc8,
+	0x0c074340, 0x0680004a, 0x07c02ac8, 0x07802707, 0x07800b48,
 	0x096621c8, 0x07802988, 0x096221c8, 0x07802c48, 0x096011c8,
 	0x07802948, 0x094421c8, 0x07802cc8, 0x095841c8, 0x07802ac8,
-	0x095041c8, 0x04c101c7, 0x0c780a00, 0x060c2107, 0x0c0768c0,
-	0x0680004a, 0x07c02ac8, 0x0fc021c0, 0x07c02bc7, 0x0fc021c0,
-	0x07c02b07, 0x0fc031c0, 0x07c02b47, 0x0fc021c0, 0x0c780300,
-	0x07c012c7, 0x0fc031c0, 0x07c02bc7, 0x07800547, 0x0aa0c007,
-	0x06800087, 0x068000c7, 0x0f8001c7, 0x07c02b07, 0x0fc031c0,
-	0x07c02b47, 0x07802707, 0x07800b48, 0x096621c8, 0x07802c48,
-	0x096011c8, 0x07802948, 0x094421c8, 0x07802ac8, 0x095041c8,
-	0x07802988, 0x096221c8, 0x04c101c7, 0x060c2107, 0x0aa0c0c8,
-	0x0c780800, 0x00000000, 0x0fc021c0, 0x0c780740, 0x07c008c7,
-	0x0a6100c8, 0x068001c8, 0x0c075e00, 0x0680000a, 0x07c02a88,
-	0x0c075d40, 0x0680004a, 0x07c02ac8, 0x07802707, 0x07800b48,
-	0x096621c8, 0x07802988, 0x096221c8, 0x07802c48, 0x096011c8,
-	0x07802948, 0x094421c8, 0x07802a88, 0x095841c8, 0x07802ac8,
-	0x095041c8, 0x04c101c7, 0x060c2107, 0x0fc021c0, 0x07c02b07,
-	0x0fc021c0, 0x07c02b47, 0x0c004d80, 0x00000000, 0x07802b87,
-	0x0aa18007, 0x06800008, 0x0fc011c0, 0x0aa0c007, 0x06800108,
-	0x0fc02200, 0x07c02c08, 0x0fc011c0, 0x0aa10007, 0x06800007,
-	0x0fc011c0, 0x040011c7, 0x07c02787, 0x0fc011c0, 0x0c7824c0,
-	0x07c02807, 0x07802647, 0x0ae34307, 0x0fc011c0, 0x0a624007,
-	0x06800088, 0x0fc011c0, 0x0a618007, 0x068000c8, 0x0fc011c0,
-	0x0a60c007, 0x06800048, 0x06800008, 0x0c7802c0, 0x00000000,
-	0x0a624007, 0x06800008, 0x0fc011c0, 0x0a618007, 0x06800088,
-	0x0fc011c0, 0x0a60c007, 0x06800048, 0x068000c8, 0x07c02988,
-	0x0c074d00, 0x0680000a, 0x07c02ec8, 0x0fc031c0, 0x07c02bc7,
-	0x07800547, 0x0aa0c007, 0x06800087, 0x068000c7, 0x0f8001c7,
-	0x07c02b07, 0x0fc031c0, 0x07c02b47, 0x07802707, 0x07800b48,
-	0x096621c8, 0x07802c48, 0x096011c8, 0x07802948, 0x094421c8,
-	0x07802ec8, 0x095841c8, 0x07802988, 0x096221c8, 0x04c101c7,
-	0x0c7fe6c0, 0x060c2107, 0x07800247, 0x0aa0c007, 0x0c7ff2c0,
-	0x00000000, 0x0fc011c0, 0x0aa0c007, 0x06800008, 0x06800088,
-	0x07c02988, 0x0c074400, 0x0680000a, 0x07c02cc8, 0x0c074340,
-	0x0680004a, 0x07c02ac8, 0x07802707, 0x07800b48, 0x096621c8,
-	0x07802988, 0x096221c8, 0x07802c48, 0x096011c8, 0x07802948,
-	0x094421c8, 0x07802cc8, 0x095841c8, 0x07802ac8, 0x095041c8,
-	0x04c101c7, 0x0c7fe640, 0x060c2107, 0x07800247, 0x0a614047,
-	0x00000000, 0x0c073dc0, 0x0680008a, 0x07c01288, 0x0c073d00,
-	0x0680000a, 0x07c026c8, 0x07802647, 0x0ae38207, 0x07802447,
-	0x0aa30007, 0x06800007, 0x0fc011c0, 0x0aa24007, 0x06800007,
-	0x0fc011c0, 0x0aa18007, 0x06800047, 0x0c073980, 0x0680004a,
-	0x07c02748, 0x06800087, 0x07c02707, 0x07802448, 0x09422207,
-	0x07800049, 0x09461209, 0x060c3108, 0x07801288, 0x097041c8,
-	0x078026c8, 0x095841c8, 0x07802748, 0x095041c8, 0x04c101c7,
-	0x060c2107, 0x0fc011c0, 0x0aa10007, 0x06800007, 0x0fc011c0,
-	0x040011c7, 0x07c02787, 0x0fc011c0, 0x0aa10007, 0x06800007,
-	0x0fc011c0, 0x040011c7, 0x07c027c7, 0x0fc011c0, 0x07c02807,
-	0x078020c7, 0x0aa200c7, 0x0c002c80, 0x06800008, 0x07802647,
-	0x07802608, 0x094c11c8, 0x0c780100, 0x060c0a07, 0x0c002500,
-	0x00000000, 0x064c0907, 0x07802808, 0x095011c8, 0x07802788,
-	0x095221c8, 0x078027c8, 0x095621c8, 0x07802b48, 0x095a31c8,
-	0x07802b08, 0x096031c8, 0x07802bc8, 0x096631c8, 0x078008c8,
-	0x096c21c8, 0x07800548, 0x097011c8, 0x0a6240a0, 0x07800488,
-	0x07802c89, 0x09008249, 0x0e000248, 0x00000000, 0x00000000,
-	0x0f000200, 0x05808208, 0x0b20c0c8, 0x00000000, 0x068000c8,
-	0x097221c8, 0x07800489, 0x02408209, 0x0b20c108, 0x04401208,
-	0x068000c8, 0x097621c8, 0x078004c8, 0x097a11c8, 0x078012c8,
-	0x097c21c8, 0x060c0907, 0x0a624060, 0x0a6200a0, 0x07802448,
-	0x0a618008, 0x078020c8, 0x0aa100c8, 0x0c780000, 0x0c780380,
-	0x00000000, 0x078020c8, 0x0aa200c8, 0x06840007, 0x07802708,
-	0x0a614008, 0x0aa10060, 0x0aa0c0a0, 0x00000000, 0x06850007,
-	0x064e0e08, 0x098081c8, 0x060e0e08, 0x064e0808, 0x09610207,
-	0x060e0808, 0x0cc00000, 0x00000000, 0x06800009, 0x06800008,
-	0x078020c7, 0x0aa400c7, 0x00000000, 0x0fc011c0, 0x0a628007,
-	0x06800060, 0x07802dc7, 0x0aa1c007, 0x06800020, 0x0fc011c0,
-	0x0aa10007, 0x068000a0, 0x0c780080, 0x06800020, 0x07c002c9,
-	0x0cc00000, 0x00000000, 0x07800247, 0x0a638087, 0x00000000,
-	0x0fc031c0, 0x05801287, 0x0aa1c08a, 0x068000a0, 0x0aa1404a,
-	0x06800060, 0x0aa0c00a, 0x06800020, 0x06800049, 0x09401287,
-	0x0c7803c0, 0x07c0038a, 0x0fc011c0, 0x0aa30007, 0x06800060,
-	0x0fc011c0, 0x0aa24007, 0x068000a0, 0x0fc011c0, 0x0aa18007,
-	0x06800020, 0x0fc011c0, 0x0aa0c007, 0x06800049, 0x06800048,
-	0x07c002c9, 0x0cc00000, 0x00000000, 0x07802247, 0x0aa1c007,
-	0x06800008, 0x0fc011c0, 0x0aa10007, 0x06800008, 0x0fc011c0,
-	0x04001207, 0x07c00248, 0x0aa10088, 0x068000c7, 0x0cc00000,
-	0x07c024c7, 0x06800047, 0x07c024c7, 0x07800987, 0x05404287,
-	0x078021c8, 0x05801208, 0x0400f208, 0x05804208, 0x05404248,
-	0x04401249, 0x05402249, 0x09610b89, 0x07c009c8, 0x04401248,
-	0x0cc00000, 0x09608989, 0x078023c7, 0x0aa58007, 0x06800008,
-	0x0aa50087, 0x06800048, 0x0fc011c0, 0x07c028c7, 0x0aa40007,
-	0x06800008, 0x0fc021c0, 0x0aa34007, 0x06800048, 0x0ae1c087,
-	0x0aa0c047, 0x06800088, 0x06800188, 0x0fc021c0, 0x0c780180,
-	0x020081c8, 0x0fc011c0, 0x0aa0c007, 0x068002c8, 0x06800288,
-	0x07c02888, 0x078023c7, 0x0aa34007, 0x06800008, 0x07802887,
-	0x0aa2c007, 0x0aa282c7, 0x00000000, 0x0fc031c0, 0x0aa141c7,
-	0x07802648, 0x020081c8, 0x0c7800c0, 0x04001208, 0x0fc05200,
-	0x07c02848, 0x07802647, 0x07802848, 0x094c51c8, 0x07802688,
-	0x095611c8, 0x07802888, 0x095841c8, 0x07802608, 0x096011c8,
-	0x078025c8, 0x0ae0c208, 0x09807447, 0x09c07447, 0x0cc00000,
-	0x060e1707, 0x0683ffe9, 0x04401a69, 0x0aa1c029, 0x0649bb28,
-	0x0920ca28, 0x0649532a, 0x09001aaa, 0x02028aa8, 0x0a6e4028,
-	0x0cc00000, 0x00000000, 0x0c07fd40, 0x00000000, 0x06495028,
-	0x09828028, 0x09828068, 0x06095028, 0x09c28028, 0x09c28068,
-	0x06095028, 0x068c0028, 0x06c07e68, 0x020288e8, 0x06097d28,
-	0x06980028, 0x06d00028, 0x06097e28, 0x06a20928, 0x06c00228,
-	0x07800269, 0x0a61c069, 0x00000000, 0x09828028, 0x078009a9,
-	0x06498e2a, 0x097c1aa9, 0x06098e2a, 0x06095128, 0x0cc00000,
-	0x00000000, 0x08098002, 0x078024c7, 0x0a6440c7, 0x00000000,
-	0x0541022b, 0x05810248, 0x02c08248, 0x06098108, 0x0541022c,
-	0x05810248, 0x02c08248, 0x06098208, 0x080980f0, 0x078024c7,
-	0x0aa640c7, 0x00000000, 0x080980f4, 0x0c780580, 0x00000000,
-	0x078004c7, 0x0aac0007, 0x00000000, 0x0541022b, 0x0649b109,
-	0x05410249, 0x078024c7, 0x0a614047, 0x00000000, 0x05810208,
-	0x0c7800c0, 0x00000000, 0x05810249, 0x02c08248, 0x06098108,
-	0x0541022c, 0x05810248, 0x02c08248, 0x06098208, 0x080980f4,
-	0x0649b107, 0x06099207, 0x078024c7, 0x0a6100c7, 0x0609902b,
-	0x0c780140, 0x0609912c, 0x0609902b, 0x0c780080, 0x0609912c,
-	0x0aa0c0a0, 0x0aa0c060, 0x0cc00000, 0x0c7809c0, 0x078024c7,
-	0x06985808, 0x0aa300c7, 0x06d81848, 0x07800548, 0x0a664008,
-	0x07800888, 0x0aa24008, 0x06901008, 0x0aa6c087, 0x06d01008,
-	0x06880808, 0x0c780600, 0x06c80808, 0x0c780580, 0x00000000,
-	0x07802508, 0x0aa1c048, 0x06881088, 0x0aa44047, 0x06d08808,
-	0x06885048, 0x0c780380, 0x06c81008, 0x06900888, 0x0aa2c087,
-	0x06c89008, 0x06904848, 0x0c780200, 0x06d00808, 0x06889008,
-	0x0aa14087, 0x06d00888, 0x06889088, 0x0c780080, 0x06c81008,
-	0x0cc00000, 0x060c0f08, 0x078024c7, 0x06985808, 0x0aa400c7,
-	0x06d81848, 0x07802508, 0x0aa1c048, 0x06885048, 0x0aa2c047,
-	0x06c81088, 0x06904848, 0x0c780200, 0x06d00808, 0x06904848,
-	0x0aa14087, 0x06d00888, 0x06885048, 0x0c780080, 0x06c81008,
-	0x0cc00000, 0x060c0f08, 0x0680400a, 0x06c0008a, 0x0681410b,
-	0x06c0018b, 0x0682420c, 0x06c0028c, 0x07800247, 0x0aa0c007,
-	0x06800008, 0x06800048, 0x06499207, 0x0780130d, 0x0a80a287,
-	0x09404348, 0x0780130d, 0x0a8072c7, 0x09484348, 0x0780130d,
-	0x0a804307, 0x09504348, 0x0780130d, 0x09584348, 0x07c0130d,
-	0x05402208, 0x06499007, 0x0a807287, 0x0900438d, 0x0a8052c7,
-	0x0908438d, 0x0a803307, 0x0910438d, 0x0918438d, 0x0940120e,
-	0x06499107, 0x0a807287, 0x0900438d, 0x0a8052c7, 0x0908438d,
-	0x0a803307, 0x0910438d, 0x0918438d, 0x0942120e, 0x064c180e,
-	0x09484388, 0x0cc00000, 0x060c180e
+	0x095041c8, 0x04c101c7, 0x0c7fe640, 0x060c2107, 0x07800247,
+	0x0a614047, 0x00000000, 0x0c073dc0, 0x0680008a, 0x07c00ac8,
+	0x0c073d00, 0x0680000a, 0x07c026c8, 0x07802647, 0x0ae38207,
+	0x07802447, 0x0aa30007, 0x06800007, 0x0fc011c0, 0x0aa24007,
+	0x06800007, 0x0fc011c0, 0x0aa18007, 0x06800047, 0x0c073980,
+	0x0680004a, 0x07c02748, 0x06800087, 0x07c02707, 0x07802448,
+	0x09422207, 0x07800049, 0x09461209, 0x060c3108, 0x07800ac8,
+	0x097041c8, 0x078026c8, 0x095841c8, 0x07802748, 0x095041c8,
+	0x04c101c7, 0x060c2107, 0x0fc011c0, 0x0aa10007, 0x06800007,
+	0x0fc011c0, 0x040011c7, 0x07c02787, 0x0fc011c0, 0x0aa10007,
+	0x06800007, 0x0fc011c0, 0x040011c7, 0x07c027c7, 0x0fc011c0,
+	0x07c02807, 0x078020c7, 0x0aa200c7, 0x0c002c80, 0x06800008,
+	0x07802647, 0x07802608, 0x094c11c8, 0x0c780100, 0x060c0a07,
+	0x0c002500, 0x00000000, 0x064c0907, 0x07802808, 0x095011c8,
+	0x07802788, 0x095221c8, 0x078027c8, 0x095621c8, 0x07802b48,
+	0x095a31c8, 0x07802b08, 0x096031c8, 0x07802bc8, 0x096631c8,
+	0x078008c8, 0x096c21c8, 0x07800548, 0x097011c8, 0x0a6240a0,
+	0x07800488, 0x07802c89, 0x09008249, 0x0e000248, 0x00000000,
+	0x00000000, 0x0f000200, 0x05808208, 0x0b20c0c8, 0x00000000,
+	0x068000c8, 0x097221c8, 0x07800489, 0x02408209, 0x0b20c108,
+	0x04401208, 0x068000c8, 0x097621c8, 0x078004c8, 0x097a11c8,
+	0x07800b08, 0x097c21c8, 0x060c0907, 0x0a624060, 0x0a6200a0,
+	0x07802448, 0x0a618008, 0x078020c8, 0x0aa100c8, 0x0c780000,
+	0x0c780380, 0x00000000, 0x078020c8, 0x0aa200c8, 0x06840007,
+	0x07802708, 0x0a614008, 0x0aa10060, 0x0aa0c0a0, 0x00000000,
+	0x06850007, 0x064e0e08, 0x098081c8, 0x060e0e08, 0x064e0808,
+	0x09610207, 0x060e0808, 0x0cc00000, 0x00000000, 0x06800009,
+	0x06800008, 0x078020c7, 0x0aa400c7, 0x00000000, 0x0fc011c0,
+	0x0a628007, 0x06800060, 0x07802dc7, 0x0aa1c007, 0x06800020,
+	0x0fc011c0, 0x0aa10007, 0x068000a0, 0x0c780080, 0x06800020,
+	0x07c002c9, 0x0cc00000, 0x00000000, 0x07800247, 0x0a638087,
+	0x00000000, 0x0fc031c0, 0x05801287, 0x0aa1c08a, 0x068000a0,
+	0x0aa1404a, 0x06800060, 0x0aa0c00a, 0x06800020, 0x06800049,
+	0x09401287, 0x0c7803c0, 0x07c0038a, 0x0fc011c0, 0x0aa30007,
+	0x06800060, 0x0fc011c0, 0x0aa24007, 0x068000a0, 0x0fc011c0,
+	0x0aa18007, 0x06800020, 0x0fc011c0, 0x0aa0c007, 0x06800049,
+	0x06800048, 0x07c002c9, 0x0cc00000, 0x00000000, 0x07802247,
+	0x0aa1c007, 0x06800008, 0x0fc011c0, 0x0aa10007, 0x06800008,
+	0x0fc011c0, 0x04001207, 0x07c00248, 0x0aa10088, 0x068000c7,
+	0x0cc00000, 0x07c024c7, 0x06800047, 0x07c024c7, 0x07800987,
+	0x05404287, 0x078021c8, 0x05801208, 0x0400f208, 0x05804208,
+	0x05404248, 0x04401249, 0x05402249, 0x09610b89, 0x07c009c8,
+	0x04401248, 0x0cc00000, 0x09608989, 0x078023c7, 0x0aa58007,
+	0x06800008, 0x0aa50087, 0x06800048, 0x0fc011c0, 0x07c028c7,
+	0x0aa40007, 0x06800008, 0x0fc021c0, 0x0aa34007, 0x06800048,
+	0x0ae1c087, 0x0aa0c047, 0x06800088, 0x06800188, 0x0fc021c0,
+	0x0c780180, 0x020081c8, 0x0fc011c0, 0x0aa0c007, 0x068002c8,
+	0x06800288, 0x07c02888, 0x078023c7, 0x0aa34007, 0x06800008,
+	0x07802887, 0x0aa2c007, 0x0aa282c7, 0x00000000, 0x0fc031c0,
+	0x0aa141c7, 0x07802648, 0x020081c8, 0x0c7800c0, 0x04001208,
+	0x0fc05200, 0x07c02848, 0x07802647, 0x07802848, 0x094c51c8,
+	0x07802688, 0x095611c8, 0x07802888, 0x095841c8, 0x07802608,
+	0x096011c8, 0x078025c8, 0x0ae0c208, 0x09807447, 0x09c07447,
+	0x0cc00000, 0x060e1707, 0x0683ffe9, 0x04401a69, 0x0aa1c029,
+	0x0649bb28, 0x0920ca28, 0x0649532a, 0x09001aaa, 0x02028aa8,
+	0x0a6e4028, 0x0cc00000, 0x00000000, 0x0c07fd40, 0x00000000,
+	0x06495028, 0x09828028, 0x09828068, 0x06095028, 0x09c28028,
+	0x09c28068, 0x06095028, 0x068c0028, 0x06c0bca8, 0x020288e8,
+	0x06097d28, 0x06980028, 0x06d00028, 0x06097e28, 0x06a20928,
+	0x06c00228, 0x07800269, 0x0a61c069, 0x00000000, 0x09828028,
+	0x078009a9, 0x06498e2a, 0x097c1aa9, 0x06098e2a, 0x06095128,
+	0x0cc00000, 0x00000000, 0x08098002, 0x078024c7, 0x0a6440c7,
+	0x00000000, 0x0541022b, 0x05810248, 0x02c08248, 0x06098108,
+	0x0541022c, 0x05810248, 0x02c08248, 0x06098208, 0x080980f0,
+	0x078024c7, 0x0aa640c7, 0x00000000, 0x080980f4, 0x0c780580,
+	0x00000000, 0x078004c7, 0x0aac0007, 0x00000000, 0x0541022b,
+	0x0649b109, 0x05410249, 0x078024c7, 0x0a614047, 0x00000000,
+	0x05810208, 0x0c7800c0, 0x00000000, 0x05810249, 0x02c08248,
+	0x06098108, 0x0541022c, 0x05810248, 0x02c08248, 0x06098208,
+	0x080980f4, 0x0649b107, 0x06099207, 0x078024c7, 0x0a6100c7,
+	0x0609902b, 0x0c780140, 0x0609912c, 0x0609902b, 0x0c780080,
+	0x0609912c, 0x0aa0c0a0, 0x0aa0c060, 0x0cc00000, 0x0c7809c0,
+	0x078024c7, 0x06985808, 0x0aa300c7, 0x06d81848, 0x07800548,
+	0x0a664008, 0x07800888, 0x0aa24008, 0x06901008, 0x0aa6c087,
+	0x06d01008, 0x06880808, 0x0c780600, 0x06c80808, 0x0c780580,
+	0x00000000, 0x07802508, 0x0aa1c048, 0x06881088, 0x0aa44047,
+	0x06d08808, 0x06885048, 0x0c780380, 0x06c81008, 0x06900888,
+	0x0aa2c087, 0x06c89008, 0x06904848, 0x0c780200, 0x06d00808,
+	0x06889008, 0x0aa14087, 0x06d00888, 0x06889088, 0x0c780080,
+	0x06c81008, 0x0cc00000, 0x060c0f08, 0x078024c7, 0x06985808,
+	0x0aa400c7, 0x06d81848, 0x07802508, 0x0aa1c048, 0x06885048,
+	0x0aa2c047, 0x06c81088, 0x06904848, 0x0c780200, 0x06d00808,
+	0x06904848, 0x0aa14087, 0x06d00888, 0x06885048, 0x0c780080,
+	0x06c81008, 0x0cc00000, 0x060c0f08, 0x0680400a, 0x06c0008a,
+	0x0681410b, 0x06c0018b, 0x0682420c, 0x06c0028c, 0x07800247,
+	0x0aa0c007, 0x06800008, 0x06800048, 0x06499207, 0x0780170d,
+	0x0a80a287, 0x09404348, 0x0780170d, 0x0a8072c7, 0x09484348,
+	0x0780170d, 0x0a804307, 0x09504348, 0x0780170d, 0x09584348,
+	0x07c0170d, 0x05402208, 0x06499007, 0x0a807287, 0x0900438d,
+	0x0a8052c7, 0x0908438d, 0x0a803307, 0x0910438d, 0x0918438d,
+	0x0940120e, 0x06499107, 0x0a807287, 0x0900438d, 0x0a8052c7,
+	0x0908438d, 0x0a803307, 0x0910438d, 0x0918438d, 0x0942120e,
+	0x064c180e, 0x09484388, 0x0cc00000, 0x060c180e
 };
diff --git a/drivers/amlogic/amports/arch/ucode/vp9/vvp9_mc.c b/drivers/amlogic/amports/arch/ucode/vp9/vvp9_mc.c
index 4f23164..1f10528 100644
--- a/drivers/amlogic/amports/arch/ucode/vp9/vvp9_mc.c
+++ b/drivers/amlogic/amports/arch/ucode/vp9/vvp9_mc.c
@@ -18,307 +18,321 @@
 #include "../firmware_def.h"
 #include "../../../vvp9.h"
 
-/* #def SEND_PARAM_WITH_REG */
+/* commit fe6cf7224765b9ef5251e20d13f16968f0de3d75 */
 #define VERSTR "00000012"
 const u32  vvp9_mc[] __initconst = {
 #ifndef VP9_10B_MMU
+
+
 	0x06814001, 0x06800000, 0x0d000001, 0x07400040, 0x0c0010c0,
 	0x00000000, 0x06bffe40, 0x07c00000, 0x06030400, 0x00400000,
-	0x0800c0ff, 0x0c021900, 0x00000000, 0x00000000, 0x00000000,
+	0x0800c0ff, 0x0c0233c0, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x0c7ffd80, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x0c7969c0, 0x00000000, 0x0c793240,
-	0x06412108, 0x0c7811c0, 0x00000000, 0x0cc00000, 0x00400000,
+	0x00000000, 0x00000000, 0x0c797580, 0x00000000, 0x0c793900,
+	0x06412108, 0x0c7815c0, 0x00000000, 0x0cc00000, 0x00400000,
 	0x06450400, 0x0600d000, 0x0640d000, 0x06035100, 0x0680c000,
 	0x06035200, 0x06a04000, 0x06035000, 0x06435000, 0x0580f000,
 	0x0bef8040, 0x00000000, 0x06435300, 0x0900c000, 0x0a6f8000,
 	0x00000000, 0x0640d000, 0x06818001, 0x02000040, 0x0600d000,
-	0x07803fc0, 0x04001000, 0x07c03fc0, 0x06805581, 0x0b8ea040,
-	0x00000000, 0x06800000, 0x07c03fc0, 0x0600d000, 0x0cc00000,
-	0x00000000, 0x0c07f840, 0x00000000, 0x06800040, 0x09800540,
-	0x09800580, 0x06014000, 0x0800c000, 0x068000c0, 0x07c004c0,
-	0x06800000, 0x07c00480, 0x06860000, 0x06c000c0, 0x06011100,
-	0x08002515, 0x08002608, 0x0640d000, 0x07c013c0, 0x0640d200,
-	0x07c01380, 0x0640c108, 0x06035108, 0x06800408, 0x06035208,
-	0x06a04008, 0x06035008, 0x06435008, 0x0580f208, 0x0bef8048,
-	0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008, 0x00000000,
-	0x0cc00000, 0x00000000, 0x06bfff88, 0x06030408, 0x00400000,
-	0x0640c008, 0x0680042f, 0x0c021380, 0x04000c08, 0x0a6181c8,
-	0x00000000, 0x0c016740, 0x00000000, 0x0c7918c0, 0x0800c0ff,
-	0x0aa0c048, 0x0c7916c0, 0x00000000, 0x06bf0008, 0x06e012c8,
-	0x06014d08, 0x06410c08, 0x08010e84, 0x09382248, 0x0ae18089,
-	0x0aa20009, 0x0aa1c049, 0x06800089, 0x0c780140, 0x06800049,
-	0x09361208, 0x08010e81, 0x02009209, 0x07c00149, 0x07800a48,
-	0x0aa14008, 0x07800a88, 0x0aa0c008, 0x06800048, 0x07c00b48,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x07c02049, 0x0aa2c009,
-	0x06410c08, 0x08010e83, 0x093a3248, 0x07c02089, 0x0c020540,
-	0x00000000, 0x0c020640, 0x00000000, 0x0c790ec0, 0x0800c0ff,
-	0x06410c08, 0x08010e83, 0x093a1248, 0x07c00209, 0x093c1248,
-	0x07c001c9, 0x093e1248, 0x07c00189, 0x06411008, 0x05001249,
-	0x07c00f89, 0x09421209, 0x06011008, 0x06414f08, 0x095e1209,
-	0x09761209, 0x05001289, 0x0968120a, 0x06014f08, 0x0aa0c049,
-	0x0c78ed80, 0x00000000, 0x06800008, 0x0c01e2c0, 0x07c00b48,
-	0x06410c08, 0x08010e88, 0x08010e90, 0x06a0d089, 0x06c01249,
-	0x09118208, 0x0a803248, 0x0c780000, 0x00000000, 0x07800188,
-	0x0aa28008, 0x07800148, 0x0a620008, 0x06800209, 0x07c00249,
-	0x06800049, 0x07c00289, 0x06800049, 0x0c780600, 0x00000000,
-	0x0ba20088, 0x06800209, 0x06410c08, 0x08010e81, 0x093e1208,
-	0x0aa0c008, 0x06800289, 0x06800309, 0x07c00249, 0x06410c08,
-	0x08010e83, 0x093a3248, 0x07c00289, 0x0a60c1c9, 0x0c780000,
-	0x00000000, 0x06410c08, 0x08010e81, 0x07800149, 0x0a20c049,
-	0x0c780000, 0x00000000, 0x07800188, 0x0aa14008, 0x06410c08,
-	0x08010e88, 0x09308248, 0x07c01009, 0x06410c08, 0x08010e90,
-	0x09210248, 0x04001249, 0x07c002c9, 0x06410c08, 0x08010e90,
-	0x09210208, 0x04001208, 0x07c00308, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x0aa24009, 0x00000000, 0x06410c08, 0x08010e90,
-	0x09210248, 0x04001249, 0x08010e90, 0x09010208, 0x04001208,
-	0x07800208, 0x06800009, 0x0a618008, 0x0680004a, 0x06410c08,
-	0x08010e82, 0x093e1248, 0x093c1288, 0x07c00549, 0x07c0058a,
-	0x06410c08, 0x08010e82, 0x093c2248, 0x07c005c9, 0x06410c08,
-	0x08010e8a, 0x09346248, 0x07c00649, 0x092e3248, 0x07c00689,
-	0x092c1248, 0x07c006c9, 0x0aa14009, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x0a608009, 0x0c7810c0, 0x06410c08, 0x08010e81,
+	0x078014c0, 0x04001000, 0x07c014c0, 0x06805581, 0x0b8ea040,
+	0x00000000, 0x06800000, 0x07c014c0, 0x0600d000, 0x0cc00000,
+	0x00000000, 0x0640d72b, 0x0aa2c02b, 0x0640d62b, 0x0aa2402b,
+	0x00000000, 0x0c018540, 0x00000000, 0x06410d2b, 0x09010b2b,
+	0x07c0152c, 0x09210b2b, 0x07c0156c, 0x0640d000, 0x07c013c0,
+	0x0640d200, 0x07c01380, 0x0c07f440, 0x00000000, 0x06800040,
+	0x09800540, 0x09800580, 0x06014000, 0x0800c000, 0x068000c0,
+	0x07c004c0, 0x06800000, 0x07c00480, 0x06860000, 0x06c000c0,
+	0x06011100, 0x08002515, 0x08002608, 0x0800271a, 0x0640c108,
+	0x06035108, 0x06800408, 0x06035208, 0x06a02008, 0x06035008,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06435308,
+	0x0900c208, 0x0a6f8008, 0x00000000, 0x0680006f, 0x0c023100,
+	0x04000c08, 0x0cc00000, 0x00000000, 0x06bfff88, 0x06030408,
+	0x00400000, 0x0640c008, 0x0680042f, 0x0c022ec0, 0x04000c08,
+	0x0a6181c8, 0x00000000, 0x0c017d40, 0x00000000, 0x0c791b80,
+	0x0800c0ff, 0x0aa0c048, 0x0c791980, 0x00000000, 0x06bf0008,
+	0x06e012c8, 0x06014d08, 0x06410c08, 0x08010e84, 0x09382248,
+	0x0ae18089, 0x0aa20009, 0x0aa1c049, 0x06800089, 0x0c780140,
+	0x06800049, 0x09361208, 0x08010e81, 0x02009209, 0x07c00149,
+	0x07800a48, 0x0aa14008, 0x07800a88, 0x0aa0c008, 0x06800048,
+	0x07c00b48, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c02049,
+	0x0aa2c009, 0x06410c08, 0x08010e83, 0x093a3248, 0x07c02089,
+	0x0c022080, 0x00000000, 0x0c022180, 0x00000000, 0x0c791180,
+	0x0800c0ff, 0x06410c08, 0x08010e83, 0x093a1248, 0x07c00209,
+	0x093c1248, 0x07c001c9, 0x093e1248, 0x07c00189, 0x06411008,
+	0x05001249, 0x07c00f89, 0x09421209, 0x06011008, 0x06414f08,
+	0x095e1209, 0x09761209, 0x05001289, 0x0968120a, 0x06014f08,
+	0x0aa0c049, 0x0c78f040, 0x00000000, 0x06800008, 0x0c01f980,
+	0x07c00b48, 0x06410c08, 0x08010e88, 0x08010e90, 0x06a0d089,
+	0x06c01249, 0x09118208, 0x0a803248, 0x0c780000, 0x00000000,
+	0x07800188, 0x0aa28008, 0x07800148, 0x0a620008, 0x06800209,
+	0x07c00249, 0x06800049, 0x07c00289, 0x06800049, 0x0c780600,
+	0x00000000, 0x0ba20088, 0x06800209, 0x06410c08, 0x08010e81,
+	0x093e1208, 0x0aa0c008, 0x06800289, 0x06800309, 0x07c00249,
+	0x06410c08, 0x08010e83, 0x093a3248, 0x07c00289, 0x0a60c1c9,
+	0x0c780000, 0x00000000, 0x06410c08, 0x08010e81, 0x07800149,
+	0x0a20c049, 0x0c780000, 0x00000000, 0x07800188, 0x0aa14008,
+	0x06410c08, 0x08010e88, 0x09308248, 0x07c01009, 0x06410c08,
+	0x08010e90, 0x09210248, 0x04001249, 0x07c002c9, 0x06410c08,
+	0x08010e90, 0x09210208, 0x04001208, 0x07c00308, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0aa24009, 0x00000000, 0x06410c08,
+	0x08010e90, 0x09210248, 0x04001249, 0x08010e90, 0x09010208,
+	0x04001208, 0x07800208, 0x06800009, 0x0a618008, 0x0680004a,
+	0x06410c08, 0x08010e82, 0x093e1248, 0x093c1288, 0x07c00549,
+	0x07c0058a, 0x06410c08, 0x08010e82, 0x093c2248, 0x07c005c9,
+	0x06410c08, 0x08010e8a, 0x068001ef, 0x0c0206c0, 0x04000c08,
+	0x09346248, 0x07c00649, 0x092e3248, 0x07c00689, 0x092c1248,
+	0x07c006c9, 0x0aa14009, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0a608009, 0x0c7810c0, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0aa20009, 0x09301288, 0x08010e87, 0x0aa1000a, 0x09326248,
+	0x0680000a, 0x0240924a, 0x07c00709, 0x06410c08, 0x08010e81,
 	0x093e1248, 0x0aa20009, 0x09301288, 0x08010e87, 0x0aa1000a,
-	0x09326248, 0x0680000a, 0x0240924a, 0x07c00709, 0x06410c08,
+	0x09326248, 0x0680000a, 0x0240924a, 0x07c00749, 0x06410c08,
 	0x08010e81, 0x093e1248, 0x0aa20009, 0x09301288, 0x08010e87,
-	0x0aa1000a, 0x09326248, 0x0680000a, 0x0240924a, 0x07c00749,
+	0x0aa1000a, 0x09326248, 0x0680000a, 0x0240924a, 0x07c00789,
 	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa20009, 0x09301288,
 	0x08010e87, 0x0aa1000a, 0x09326248, 0x0680000a, 0x0240924a,
-	0x07c00789, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa20009,
+	0x07c007c9, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa20009,
 	0x09301288, 0x08010e87, 0x0aa1000a, 0x09326248, 0x0680000a,
-	0x0240924a, 0x07c007c9, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0240924a, 0x07c00809, 0x06410c08, 0x08010e81, 0x093e1248,
 	0x0aa20009, 0x09301288, 0x08010e87, 0x0aa1000a, 0x09326248,
-	0x0680000a, 0x0240924a, 0x07c00809, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x0aa20009, 0x09301288, 0x08010e87, 0x0aa1000a,
-	0x09326248, 0x0680000a, 0x0240924a, 0x07c00849, 0x06410c08,
-	0x08010e88, 0x09308248, 0x07c00889, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x0aa1c009, 0x09341288, 0x08010e85, 0x0aa1000a,
-	0x09364248, 0x0680000a, 0x0240924a, 0x07c00989, 0x07800888,
-	0x02009209, 0x07c008c9, 0x09508248, 0x06c00009, 0x06014609,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa1c009, 0x09341288,
-	0x08010e85, 0x0aa1000a, 0x09364248, 0x0680000a, 0x0240924a,
-	0x07c009c9, 0x07800888, 0x02009209, 0x07c00909, 0x06410c08,
+	0x0680000a, 0x0240924a, 0x07c00849, 0x06410c08, 0x08010e88,
+	0x09308248, 0x07c00889, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0aa1c009, 0x09341288, 0x08010e85, 0x0aa1000a, 0x09364248,
+	0x0680000a, 0x0240924a, 0x07c00989, 0x07800888, 0x02009209,
+	0x07c008c9, 0x09508248, 0x06c00009, 0x06014609, 0x06410c08,
 	0x08010e81, 0x093e1248, 0x0aa1c009, 0x09341288, 0x08010e85,
-	0x0aa1000a, 0x09364248, 0x0680000a, 0x0240924a, 0x07c00a09,
-	0x07800888, 0x02009209, 0x07c00949, 0x07800908, 0x09508209,
-	0x06c00048, 0x06014608, 0x06800089, 0x07800888, 0x0a624008,
-	0x07800988, 0x0a61c008, 0x078009c8, 0x0a614008, 0x07800a08,
-	0x0a60c008, 0x00000000, 0x068000c9, 0x06414f08, 0x096a2209,
-	0x06014f08, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009,
-	0x07c00a49, 0x06800008, 0x0c012100, 0x07c00ac8, 0x06414f08,
-	0x07800a49, 0x096e1209, 0x07800a89, 0x09701209, 0x07800ac9,
-	0x09721209, 0x07800b09, 0x09741209, 0x06014f08, 0x0c01bf40,
-	0x00000000, 0x0c01c040, 0x00000000, 0x0640c008, 0x0a610188,
-	0x00000000, 0x0c78c800, 0x0800c0ff, 0x0c01a780, 0x00000000,
-	0x06800048, 0x07800409, 0x0680100a, 0x0340b20a, 0x0ac0324b,
-	0x0c7fff80, 0x04001208, 0x04401208, 0x07c00048, 0x06800048,
-	0x07800409, 0x0380b209, 0x0ba0c10b, 0x0c7fff80, 0x04001208,
-	0x04401208, 0x07c00088, 0x0780004a, 0x07800089, 0x0b40724a,
-	0x06410c08, 0x08010e81, 0x093e1208, 0x0aa0c008, 0x0c7ffec0,
-	0x0400128a, 0x07c00bca, 0x06800048, 0x03408288, 0x04401208,
-	0x07c00c48, 0x06410c08, 0x08010e81, 0x093e1288, 0x0aa1400a,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0200a24a, 0x07c00c0a,
-	0x06800048, 0x03408288, 0x04401208, 0x07c00c88, 0x06410c08,
-	0x08010e90, 0x09210248, 0x06812008, 0x06010e08, 0x08010e00,
-	0x05403249, 0x098097c9, 0x09809749, 0x06013a09, 0x07800188,
-	0x0aa14008, 0x07800208, 0x0a60c008, 0x07800fc8, 0x0a60c0c8,
-	0x06800008, 0x07c00608, 0x07800fc8, 0x0aa18088, 0x06800009,
-	0x07800609, 0x078005c8, 0x03809209, 0x04801249, 0x0641100a,
-	0x0a610009, 0x0980a3ca, 0x0c7809c0, 0x00000000, 0x0601100a,
-	0x06414d09, 0x093e1249, 0x0a6f8009, 0x00000000, 0x0640c308,
-	0x09108208, 0x0aafbf48, 0x00000000, 0x06410108, 0x09808348,
-	0x06010108, 0x06410108, 0x09021208, 0x0a6f8008, 0x00000000,
-	0x06af0008, 0x06ec09c8, 0x06014d08, 0x0640c908, 0x078005c9,
-	0x0540c249, 0x02008248, 0x06013408, 0x08013501, 0x06413508,
-	0x090e1248, 0x0a6f8009, 0x09308248, 0x0a6f0009, 0x00000000,
-	0x08013500, 0x08014d00, 0x06410108, 0x09c08348, 0x0c780b80,
-	0x06010108, 0x06807fc8, 0x09449288, 0x0601100a, 0x06800049,
-	0x078005c8, 0x03409209, 0x07800608, 0x02c08248, 0x07c00608,
-	0x06411009, 0x0904a249, 0x0a6f8009, 0x00000000, 0x06414d09,
-	0x093e1249, 0x0a6f8009, 0x00000000, 0x06410108, 0x09808348,
-	0x06010108, 0x06410108, 0x09021208, 0x0a6f8008, 0x00000000,
-	0x06af0008, 0x06ec05c8, 0x06014d08, 0x0640c908, 0x078005c9,
-	0x0540c249, 0x02008248, 0x06013408, 0x08013503, 0x06413508,
-	0x090e1248, 0x0a6f8009, 0x09308248, 0x0a6f0009, 0x00000000,
-	0x08013500, 0x08014d00, 0x06410108, 0x09c08348, 0x06010108,
-	0x06411009, 0x091e1249, 0x0a6f8009, 0x00000000, 0x06a00208,
-	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
-	0x0aa08009, 0x0c780000, 0x078008c8, 0x0a624008, 0x07800888,
-	0x0a61c008, 0x07800908, 0x0a614008, 0x07800948, 0x0a60c008,
-	0x0c780400, 0x0680000a, 0x06a00608, 0x06014108, 0x06414108,
-	0x09061248, 0x0a6f8009, 0x09202288, 0x0a6200ca, 0x06a00208,
-	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
-	0x0200a24a, 0x07c00f4a, 0x06414f08, 0x0958320a, 0x06014f08,
-	0x0a62010a, 0x06bf0248, 0x06c002c8, 0x06014108, 0x06414108,
-	0x09061248, 0x0a6f8009, 0x00000000, 0x0680000a, 0x06a00208,
-	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
-	0x0aa24009, 0x06bf0648, 0x06c062c8, 0x097c220a, 0x06014108,
-	0x06414108, 0x09061248, 0x0a6d4009, 0x00000000, 0x07800f48,
-	0x0b40420a, 0x0babc0ca, 0x0400128a, 0x00000000, 0x06bf0a48,
-	0x06c00088, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
-	0x00000000, 0x07800f88, 0x0aa08008, 0x0c781ac0, 0x06bf0e48,
-	0x06c00508, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
-	0x00000000, 0x078010c8, 0x0a620108, 0x06bf1248, 0x06c001c8,
+	0x0aa1000a, 0x09364248, 0x0680000a, 0x0240924a, 0x07c009c9,
+	0x07800888, 0x02009209, 0x07c00909, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa1c009, 0x09341288, 0x08010e85, 0x0aa1000a,
+	0x09364248, 0x0680000a, 0x0240924a, 0x07c00a09, 0x07800888,
+	0x02009209, 0x07c00949, 0x07800908, 0x09508209, 0x06c00048,
+	0x06014608, 0x06800089, 0x07800888, 0x0a624008, 0x07800988,
+	0x0a61c008, 0x078009c8, 0x0a614008, 0x07800a08, 0x0a60c008,
+	0x00000000, 0x068000c9, 0x06414f08, 0x096a2209, 0x06014f08,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009, 0x07c00a49,
+	0x06800008, 0x0c013640, 0x07c00ac8, 0x06414f08, 0x07800a49,
+	0x096e1209, 0x07800a89, 0x09701209, 0x07800ac9, 0x09721209,
+	0x07800b09, 0x09741209, 0x06014f08, 0x0c01d9c0, 0x00000000,
+	0x0c01dac0, 0x00000000, 0x0640c008, 0x0a610188, 0x00000000,
+	0x0c78ca00, 0x0800c0ff, 0x0c01bd80, 0x00000000, 0x06800048,
+	0x07800409, 0x0680100a, 0x0340b20a, 0x0ac0324b, 0x0c7fff80,
+	0x04001208, 0x04401208, 0x07c00048, 0x06800048, 0x07800409,
+	0x0380b209, 0x0ba0c10b, 0x0c7fff80, 0x04001208, 0x04401208,
+	0x07c00088, 0x0780004a, 0x07800089, 0x0b40724a, 0x06410c08,
+	0x08010e81, 0x093e1208, 0x0aa0c008, 0x0c7ffec0, 0x0400128a,
+	0x07c00bca, 0x06800048, 0x03408288, 0x04401208, 0x07c00c48,
+	0x06410c08, 0x08010e81, 0x093e1288, 0x0aa1400a, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0200a24a, 0x07c00c0a, 0x06800048,
+	0x03408288, 0x04401208, 0x07c00c88, 0x06410c08, 0x08010e90,
+	0x09210248, 0x06812008, 0x06010e08, 0x08010e00, 0x05403249,
+	0x098097c9, 0x09809749, 0x06013a09, 0x07800188, 0x0aa14008,
+	0x07800208, 0x0a60c008, 0x07800fc8, 0x0a60c0c8, 0x06800008,
+	0x07c00608, 0x07800fc8, 0x0aa18088, 0x06800009, 0x07800609,
+	0x078005c8, 0x03809209, 0x04801249, 0x0641100a, 0x068014af,
+	0x0c01c900, 0x04000c0a, 0x0a610009, 0x0980a3ca, 0x0c780b40,
+	0x00000000, 0x0601100a, 0x06414d09, 0x068014ef, 0x0c01c6c0,
+	0x04000c09, 0x093e1249, 0x0a6ec009, 0x00000000, 0x0680146f,
+	0x0c01c540, 0x04000c08, 0x0640c308, 0x09108208, 0x0aafbf48,
+	0x00000000, 0x06410108, 0x09808348, 0x06010108, 0x06410108,
+	0x09021208, 0x0a6f8008, 0x00000000, 0x06af0008, 0x06ec09c8,
+	0x06014d08, 0x0640c908, 0x078005c9, 0x0540c249, 0x02008248,
+	0x06013408, 0x08013501, 0x06413508, 0x090e1248, 0x0a6f8009,
+	0x09308248, 0x0a6f0009, 0x00000000, 0x08013500, 0x08014d00,
+	0x06410108, 0x09c08348, 0x0c780b80, 0x06010108, 0x06807fc8,
+	0x09449288, 0x0601100a, 0x06800049, 0x078005c8, 0x03409209,
+	0x07800608, 0x02c08248, 0x07c00608, 0x06411009, 0x0904a249,
+	0x0a6f8009, 0x00000000, 0x06414d09, 0x093e1249, 0x0a6f8009,
+	0x00000000, 0x06410108, 0x09808348, 0x06010108, 0x06410108,
+	0x09021208, 0x0a6f8008, 0x00000000, 0x06af0008, 0x06ec05c8,
+	0x06014d08, 0x0640c908, 0x078005c9, 0x0540c249, 0x02008248,
+	0x06013408, 0x08013503, 0x06413508, 0x090e1248, 0x0a6f8009,
+	0x09308248, 0x0a6f0009, 0x00000000, 0x08013500, 0x08014d00,
+	0x06410108, 0x09c08348, 0x06010108, 0x06411009, 0x091e1249,
+	0x0a6f8009, 0x00000000, 0x06a00208, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x09201248, 0x0aa08009, 0x0c780000,
+	0x078008c8, 0x0a624008, 0x07800888, 0x0a61c008, 0x07800908,
+	0x0a614008, 0x07800948, 0x0a60c008, 0x0c780400, 0x0680000a,
+	0x06a00608, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
+	0x09202288, 0x0a6200ca, 0x06a00208, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x09201248, 0x0200a24a, 0x07c00f4a,
+	0x06414f08, 0x0958320a, 0x06014f08, 0x0a62010a, 0x06bf0248,
+	0x06c002c8, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
+	0x00000000, 0x0680000a, 0x06a00208, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x09201248, 0x0aa24009, 0x06bf0648,
+	0x06c062c8, 0x097c220a, 0x06014108, 0x06414108, 0x09061248,
+	0x0a6d4009, 0x00000000, 0x07800f48, 0x0b40420a, 0x0babc0ca,
+	0x0400128a, 0x00000000, 0x06bf0a48, 0x06c00088, 0x06014108,
+	0x06414108, 0x09061248, 0x0a6f8009, 0x00000000, 0x07800f88,
+	0x0aa08008, 0x0c781ac0, 0x06bf0e48, 0x06c00508, 0x06014108,
+	0x06414108, 0x09061248, 0x0a6f8009, 0x00000000, 0x078010c8,
+	0x0a620108, 0x06bf1248, 0x06c001c8, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x00000000, 0x06bf1648, 0x06c000c8,
 	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
-	0x06bf1648, 0x06c000c8, 0x06014108, 0x06414108, 0x09061248,
-	0x0a6f8009, 0x00000000, 0x06414f0a, 0x07801048, 0x09001248,
-	0x09501289, 0x09081248, 0x094e1289, 0x09101248, 0x094c1289,
-	0x06014f0a, 0x09081288, 0x0a40424a, 0x09001288, 0x0a81324a,
-	0x0680000a, 0x06a00208, 0x06014108, 0x06414108, 0x09061248,
-	0x0a6f8009, 0x09201248, 0x0aa2c009, 0x0680000a, 0x06a00208,
+	0x06414f0a, 0x07801048, 0x09001248, 0x09501289, 0x09081248,
+	0x094e1289, 0x09101248, 0x094c1289, 0x06014f0a, 0x09081288,
+	0x0a40424a, 0x09001288, 0x0a81324a, 0x0680000a, 0x06a00208,
 	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
-	0x0aa0c009, 0x0680004a, 0x0680008a, 0x07c0110a, 0x06414f08,
-	0x0954220a, 0x06014f08, 0x0a62008a, 0x06bf1a48, 0x06c00108,
-	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
-	0x0aa2004a, 0x06bf2248, 0x06c00248, 0x06014108, 0x06414108,
-	0x09061248, 0x0a6f8009, 0x00000000, 0x0aa2000a, 0x06bf1e48,
-	0x06c00108, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
-	0x00000000, 0x06bf2648, 0x06c008c8, 0x06014108, 0x06414108,
-	0x09061248, 0x0a6f8009, 0x00000000, 0x06bf2a48, 0x06c00bc8,
-	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
-	0x06bf2e48, 0x07801089, 0x0a60c009, 0x06c01108, 0x06c01008,
-	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
-	0x06413a08, 0x09013208, 0x0aa0c008, 0x00000000, 0x08010e88,
-	0x06800008, 0x07c00cc8, 0x07c00d08, 0x08013a00, 0x08011c00,
-	0x08011e00, 0x08011d00, 0x08011f00, 0x08014700, 0x08014800,
-	0x08014200, 0x08014300, 0x08014400, 0x08014500, 0x07800cc8,
-	0x07800409, 0x0e000248, 0x068001df, 0x00000000, 0x07800bc9,
-	0x0f000200, 0x03808248, 0x07c00d48, 0x07800cc8, 0x04001208,
-	0x07800409, 0x0e000248, 0x0680000a, 0x07c00b8a, 0x07800bc9,
-	0x0f000200, 0x03808248, 0x07c00dc8, 0x07800d49, 0x02408248,
-	0x07c00e48, 0x07800d08, 0x07800449, 0x0e000248, 0x00000000,
-	0x00000000, 0x07800c09, 0x0f000200, 0x03808248, 0x0aa10008,
-	0x07c00d88, 0x0c00e980, 0x09c1f05f, 0x07800d08, 0x04001208,
+	0x0aa2c009, 0x0680000a, 0x06a00208, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x09201248, 0x0aa0c009, 0x0680004a,
+	0x0680008a, 0x07c0110a, 0x06414f08, 0x0954220a, 0x06014f08,
+	0x0a62008a, 0x06bf1a48, 0x06c00108, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x00000000, 0x0aa2004a, 0x06bf2248,
+	0x06c00248, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
+	0x00000000, 0x0aa2000a, 0x06bf1e48, 0x06c00108, 0x06014108,
+	0x06414108, 0x09061248, 0x0a6f8009, 0x00000000, 0x06bf2648,
+	0x06c008c8, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
+	0x00000000, 0x06bf2a48, 0x06c00bc8, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x00000000, 0x06bf2e48, 0x07801089,
+	0x0a60c009, 0x06c01108, 0x06c01008, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x00000000, 0x06413a08, 0x09013208,
+	0x0aa0c008, 0x00000000, 0x08010e88, 0x06800008, 0x07c00cc8,
+	0x07c00d08, 0x08013a00, 0x08011c00, 0x08011e00, 0x08011d00,
+	0x08011f00, 0x08014700, 0x08014800, 0x08014200, 0x08014300,
+	0x08014400, 0x08014500, 0x07800cc8, 0x07800409, 0x0e000248,
+	0x068001df, 0x00000000, 0x07800bc9, 0x0f000200, 0x03808248,
+	0x07c00d48, 0x07800cc8, 0x04001208, 0x07800409, 0x0e000248,
+	0x0680000a, 0x07c00b8a, 0x07800bc9, 0x0f000200, 0x03808248,
+	0x07c00dc8, 0x07800d49, 0x02408248, 0x07c00e48, 0x07800d08,
 	0x07800449, 0x0e000248, 0x00000000, 0x00000000, 0x07800c09,
-	0x0f000200, 0x03808248, 0x07c00e08, 0x07800d89, 0x02408248,
-	0x07c00e88, 0x07800d48, 0x04001208, 0x07800dc9, 0x0b807248,
-	0x07800d88, 0x04001208, 0x07800e09, 0x0b803248, 0x00000000,
-	0x0981f0df, 0x07800d88, 0x07800409, 0x0e000248, 0x07c00f08,
-	0x07c01348, 0x07800d49, 0x07c00ec9, 0x07c01309, 0x0f000200,
-	0x02008248, 0x07c00508, 0x05404248, 0x05403208, 0x02008248,
-	0x07c01208, 0x07c01248, 0x06800008, 0x07c01288, 0x07c012c8,
-	0x06812008, 0x06010e08, 0x08010e00, 0x07800cc8, 0x0a60c008,
-	0x07800d08, 0x0aa20008, 0x0641390a, 0x0aa1800a, 0x00000000,
-	0x08010e88, 0x00000000, 0x0c7ffec0, 0x00000000, 0x07800cc8,
-	0x07800c49, 0x0b804248, 0x07800d08, 0x07800c89, 0x0b40d248,
-	0x06410c08, 0x08010e90, 0x09210248, 0x06410c08, 0x08010e90,
-	0x09210288, 0x09610289, 0x0601390a, 0x0540324a, 0x098097c9,
-	0x09809789, 0x06013a09, 0x07800e48, 0x0aa0c008, 0x07800e88,
-	0x0a630008, 0x07800cc8, 0x04001208, 0x07800c49, 0x0b082248,
-	0x07c00cc8, 0x06800008, 0x07c00cc8, 0x07800d08, 0x04001208,
-	0x0c7fdf00, 0x07c00d08, 0x07800a48, 0x0aa0c008, 0x0c00db40,
-	0x00000000, 0x06411009, 0x098093c9, 0x06011009, 0x06470109,
-	0x09809209, 0x06070109, 0x06470b08, 0x07800249, 0x04408249,
-	0x09402209, 0x09482209, 0x09502209, 0x06070b08, 0x078002c8,
-	0x07800309, 0x09610209, 0x06020508, 0x07800d48, 0x07800d89,
-	0x09610209, 0x06020708, 0x06060708, 0x07800e48, 0x07800e89,
-	0x09610209, 0x06020808, 0x06060808, 0x07800408, 0x04401208,
-	0x07800449, 0x04401249, 0x09610209, 0x06020608, 0x06420109,
-	0x07800188, 0x0aa0c008, 0x06800388, 0x06800308, 0x09403248,
-	0x078004c8, 0x04003208, 0x09604248, 0x07800488, 0x04003208,
-	0x09684248, 0x06020109, 0x06424c09, 0x09809009, 0x09809049,
-	0x09809089, 0x07801088, 0x05001208, 0x09501248, 0x07801048,
-	0x09001288, 0x095c124a, 0x09081288, 0x095a124a, 0x09101288,
-	0x0958124a, 0x06024c09, 0x06420408, 0x093e1208, 0x0a6f8008,
-	0x00000000, 0x078002c9, 0x0780030a, 0x0960f24a, 0x06040209,
-	0x07800409, 0x0780044a, 0x0960c24a, 0x06040309, 0x08040400,
-	0x07800c48, 0x0a618008, 0x06800049, 0x07800c88, 0x0a60c008,
-	0x06800049, 0x06800009, 0x06040509, 0x07800e48, 0x07800e89,
-	0x09610209, 0x06040308, 0x07800d48, 0x07800d89, 0x09610209,
-	0x06040408, 0x06450d08, 0x09001248, 0x0a6f8009, 0x00000000,
-	0x08040640, 0x06414f0a, 0x07800148, 0x0aa10008, 0x06800009,
-	0x06800289, 0x0980a24a, 0x06040c09, 0x06014f0a, 0x06440009,
-	0x09809009, 0x06040009, 0x09c09009, 0x06040009, 0x06800048,
-	0x09482248, 0x09809049, 0x06040009, 0x07800249, 0x04408249,
-	0x06450108, 0x09602209, 0x09642209, 0x06050108, 0x078002c8,
-	0x07800309, 0x09610209, 0x06050208, 0x07800bc8, 0x06050c08,
-	0x07800d48, 0x07800d89, 0x0960a209, 0x07800cc9, 0x09584209,
-	0x07800d09, 0x09784209, 0x06050608, 0x07800d4a, 0x07800e48,
-	0x02008288, 0x04401208, 0x07800d8a, 0x07800e89, 0x02009289,
-	0x04401249, 0x0960a209, 0x06050708, 0x07800d48, 0x07800d89,
-	0x0960a209, 0x06050808, 0x078002c8, 0x07800309, 0x09610209,
-	0x06060508, 0x07800408, 0x04401208, 0x07800449, 0x04401249,
-	0x09610209, 0x06060608, 0x06460109, 0x09809709, 0x06060109,
-	0x07800ec9, 0x07800f08, 0x0958c248, 0x0978425f, 0x06011609,
-	0x06411009, 0x091e1249, 0x0a6f8009, 0x00000000, 0x06a00208,
-	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
-	0x0aa08009, 0x0c780000, 0x07800508, 0x09808788, 0x098087c8,
-	0x06012408, 0x07800d48, 0x0a610008, 0x07800d88, 0x0a608008,
-	0x00000000, 0x06800048, 0x0541f208, 0x06020408, 0x06060408,
-	0x08040701, 0x06450808, 0x098087c8, 0x06050808, 0x06414008,
-	0x09808048, 0x06014008, 0x06414008, 0x0c783500, 0x00000000,
-	0x078001c8, 0x0a614008, 0x06800009, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x07c00f89, 0x0a60c009, 0x0780020a, 0x0aa0c00a,
-	0x0c00f380, 0x00000000, 0x06414f08, 0x095e1209, 0x05001289,
-	0x0968120a, 0x06014f08, 0x07800208, 0x0a614008, 0x06800009,
-	0x06410c08, 0x08010e82, 0x093c2248, 0x07c00fc9, 0x07800f88,
-	0x0aa08008, 0x0c7f0c80, 0x06410c08, 0x08010e88, 0x09308248,
-	0x07c01009, 0x06410c08, 0x08010e8c, 0x0928c248, 0x07c01049,
-	0x09101209, 0x09081289, 0x0a806288, 0x068009ca, 0x09001289,
-	0x0a803288, 0x06800d8a, 0x06800e8a, 0x06414f09, 0x0940624a,
-	0x06014f09, 0x0680008a, 0x0680000b, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x03408289, 0x02c0b20b, 0x0a63c009, 0x07c023cb,
-	0x0b20c00a, 0x0c7ffe00, 0x0440128a, 0x06410c08, 0x08010e90,
-	0x09210248, 0x04001249, 0x06410c08, 0x08010e90, 0x09210208,
-	0x04001208, 0x07c00308, 0x07c002c9, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x07c021c9, 0x0aa2c009, 0x00000000, 0x06410c08,
-	0x08010e90, 0x09210248, 0x04001249, 0x07c02309, 0x08010e90,
-	0x09010208, 0x04001208, 0x07c02348, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x07c01089, 0x06414f08, 0x09661209, 0x06014f08,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0a61c009, 0x0680010a,
-	0x08010e82, 0x093a2248, 0x0b60c089, 0x04000289, 0x0500128a,
-	0x07c010ca, 0x06414f08, 0x0960320a, 0x06014f08, 0x0c7f0b40,
-	0x00000000, 0x0a60c188, 0x00000000, 0x08010e90, 0x0c780080,
-	0x0800c0ff, 0x00800000, 0x07800008, 0x0c7ed2c0, 0x06030408,
-	0x06806008, 0x06010e08, 0x06410f08, 0x0befc0c8, 0x09118208,
-	0x0cc00000, 0x07400248, 0x0680e008, 0x06010e08, 0x06410f08,
-	0x0befc0c8, 0x09118208, 0x0cc00000, 0x07400248, 0x06410509,
-	0x06bfff89, 0x06030409, 0x00400000, 0x0be0c108, 0x0c7ffa40,
-	0x00000000, 0x08012104, 0x080150c0, 0x06411c26, 0x06411d27,
-	0x06414728, 0x06414229, 0x07800409, 0x0ae1c049, 0x0641432a,
-	0x04000866, 0x040008a7, 0x040008e8, 0x04000929, 0x0400096a,
-	0x06014224, 0x06014325, 0x06011c21, 0x06011d22, 0x0a21c91f,
-	0x06014723, 0x08011e00, 0x08011f00, 0x08014800, 0x08014400,
-	0x08014500, 0x0be0e026, 0x0c7809c0, 0x00000000, 0x07800a48,
-	0x0aa0c008, 0x0c00aac0, 0x00000000, 0x068001df, 0x0978479f,
-	0x06420409, 0x093e1209, 0x0a6f8008, 0x09c09749, 0x06020409,
-	0x07800cc8, 0x04001208, 0x07800c49, 0x0b009248, 0x07c00cc8,
-	0x06800008, 0x07c00cc8, 0x07800d08, 0x04001208, 0x07800c89,
-	0x0ac08248, 0x07c00d08, 0x0c006940, 0x00000000, 0x0c003e40,
-	0x00000000, 0x0c7f7c00, 0x00000000, 0x07800549, 0x0aa0c009,
-	0x0c00ac40, 0x00000000, 0x0c003c40, 0x00000000, 0x0c7fea00,
-	0x0800c0ff, 0x0601161e, 0x07800508, 0x09808788, 0x098087c8,
-	0x06012408, 0x06414009, 0x09809049, 0x06014009, 0x06414009,
-	0x09c1f09f, 0x07800508, 0x04001208, 0x07c00508, 0x07800b88,
-	0x04001208, 0x07c00b88, 0x0a21409f, 0x07800e49, 0x0b803248,
-	0x00000000, 0x09c1f05f, 0x07800ec8, 0x04001208, 0x07800dc9,
-	0x0b811248, 0x07c00ec8, 0x07800d48, 0x07c00ec8, 0x0981f09f,
-	0x07800508, 0x07800409, 0x02008248, 0x07800e49, 0x02408248,
-	0x07c00508, 0x07800f08, 0x04001208, 0x07800e09, 0x0b803248,
-	0x07c00f08, 0x0981f0df, 0x07800f08, 0x04001208, 0x07800e09,
-	0x0b80f248, 0x07800ec8, 0x04001208, 0x07800dc9, 0x0b80b248,
-	0x07800409, 0x0b807248, 0x07800f08, 0x04001208, 0x07800449,
-	0x0b803248, 0x0c7800c0, 0x09c1f11f, 0x0981f11f, 0x0981f0df,
-	0x07800ede, 0x07800f08, 0x0958c788, 0x0978479f, 0x07800b88,
-	0x0ae08048, 0x0c780a00, 0x07800ec9, 0x07800d4a, 0x0400228a,
-	0x0b407289, 0x04402209, 0x0440128a, 0x07800dc8, 0x0b403289,
-	0x04401208, 0x04401208, 0x05403248, 0x02009248, 0x02008248,
-	0x06806009, 0x02009209, 0x07400266, 0x09210226, 0x04001249,
-	0x07400248, 0x04001249, 0x07400269, 0x09210229, 0x04001249,
-	0x07400248, 0x04001249, 0x0740026a, 0x0921022a, 0x04001249,
-	0x07400248, 0x04001249, 0x07400267, 0x09210227, 0x04001249,
-	0x07400248, 0x04001249, 0x07400268, 0x09210228, 0x04001249,
-	0x07400248, 0x0a21c09f, 0x06800024, 0x06800025, 0x06800021,
-	0x06800022, 0x0c780800, 0x06800023, 0x07800ec8, 0x05403248,
-	0x02009248, 0x02008248, 0x06806009, 0x02009209, 0x07000261,
-	0x04001249, 0x07000248, 0x09610848, 0x04001249, 0x07000264,
-	0x04001249, 0x07000248, 0x09610908, 0x04001249, 0x07000265,
-	0x04001249, 0x07000248, 0x09610948, 0x04001249, 0x07000262,
-	0x04001249, 0x07000248, 0x09610888, 0x04001249, 0x07000263,
-	0x04001249, 0x07000248, 0x096108c8, 0x07800a48, 0x0aa0c008,
-	0x0c005cc0, 0x00000000, 0x0c7fc500, 0x00000000, 0x06412106,
-	0x090c1186, 0x0a6f8006, 0x0c7e9700, 0x00000000, 0x06804009,
+	0x0f000200, 0x03808248, 0x0aa10008, 0x07c00d88, 0x0c00fc80,
+	0x09c1f05f, 0x07800d08, 0x04001208, 0x07800449, 0x0e000248,
+	0x00000000, 0x00000000, 0x07800c09, 0x0f000200, 0x03808248,
+	0x07c00e08, 0x07800d89, 0x02408248, 0x07c00e88, 0x07800d48,
+	0x04001208, 0x07800dc9, 0x0b807248, 0x07800d88, 0x04001208,
+	0x07800e09, 0x0b803248, 0x00000000, 0x0981f0df, 0x07800d88,
+	0x07800409, 0x0e000248, 0x07c00f08, 0x07c01348, 0x07800d49,
+	0x07c00ec9, 0x07c01309, 0x0f000200, 0x02008248, 0x07c00508,
+	0x05404248, 0x05403208, 0x02008248, 0x07c01208, 0x07c01248,
+	0x06800008, 0x07c01288, 0x07c012c8, 0x06812008, 0x06010e08,
+	0x08010e00, 0x07800cc8, 0x0a60c008, 0x07800d08, 0x0aa20008,
+	0x0641390a, 0x0aa1800a, 0x00000000, 0x08010e88, 0x00000000,
+	0x0c7ffec0, 0x00000000, 0x07800cc8, 0x07800c49, 0x0b804248,
+	0x07800d08, 0x07800c89, 0x0b40d248, 0x06410c08, 0x08010e90,
+	0x09210248, 0x06410c08, 0x08010e90, 0x09210288, 0x09610289,
+	0x0601390a, 0x0540324a, 0x098097c9, 0x09809789, 0x06013a09,
+	0x07800e48, 0x0aa0c008, 0x07800e88, 0x0a630008, 0x07800cc8,
+	0x04001208, 0x07800c49, 0x0b082248, 0x07c00cc8, 0x06800008,
+	0x07c00cc8, 0x07800d08, 0x04001208, 0x0c7fdf00, 0x07c00d08,
+	0x07800a48, 0x0aa0c008, 0x0c00ee40, 0x00000000, 0x06411009,
+	0x098093c9, 0x06011009, 0x06470109, 0x09809209, 0x06070109,
+	0x06470b08, 0x07800249, 0x04408249, 0x09402209, 0x09482209,
+	0x09502209, 0x06070b08, 0x078002c8, 0x07800309, 0x09610209,
+	0x06020508, 0x07800d48, 0x07800d89, 0x09610209, 0x06020708,
+	0x06060708, 0x07800e48, 0x07800e89, 0x09610209, 0x06020808,
+	0x06060808, 0x07800408, 0x04401208, 0x07800449, 0x04401249,
+	0x09610209, 0x06020608, 0x06420109, 0x07800188, 0x0aa0c008,
+	0x06800388, 0x06800308, 0x09403248, 0x078004c8, 0x04003208,
+	0x09604248, 0x07800488, 0x04003208, 0x09684248, 0x06020109,
+	0x06424c09, 0x09809009, 0x09809049, 0x09809089, 0x07801088,
+	0x05001208, 0x09501248, 0x07801048, 0x09001288, 0x095c124a,
+	0x09081288, 0x095a124a, 0x09101288, 0x0958124a, 0x06024c09,
+	0x06420408, 0x093e1208, 0x0a6f8008, 0x00000000, 0x078002c9,
+	0x0780030a, 0x0960f24a, 0x06040209, 0x07800409, 0x0780044a,
+	0x0960c24a, 0x06040309, 0x08040400, 0x07800c48, 0x0a618008,
+	0x06800049, 0x07800c88, 0x0a60c008, 0x06800049, 0x06800009,
+	0x06040509, 0x07800e48, 0x07800e89, 0x09610209, 0x06040308,
+	0x07800d48, 0x07800d89, 0x09610209, 0x06040408, 0x06450d08,
+	0x09001248, 0x0a6f8009, 0x00000000, 0x08040640, 0x06414f0a,
+	0x07800148, 0x0aa10008, 0x06800009, 0x06800289, 0x0980a24a,
+	0x06040c09, 0x06014f0a, 0x06440009, 0x09809009, 0x06040009,
+	0x09c09009, 0x06040009, 0x06800048, 0x09482248, 0x09809049,
+	0x06040009, 0x07800249, 0x04408249, 0x06450108, 0x09602209,
+	0x09642209, 0x06050108, 0x078002c8, 0x07800309, 0x09610209,
+	0x06050208, 0x07800bc8, 0x06050c08, 0x07800d48, 0x07800d89,
+	0x0960a209, 0x07800cc9, 0x09584209, 0x07800d09, 0x09784209,
+	0x06050608, 0x07800d4a, 0x07800e48, 0x02008288, 0x04401208,
+	0x07800d8a, 0x07800e89, 0x02009289, 0x04401249, 0x0960a209,
+	0x06050708, 0x07800d48, 0x07800d89, 0x0960a209, 0x06050808,
+	0x078002c8, 0x07800309, 0x09610209, 0x06060508, 0x07800408,
+	0x04401208, 0x07800449, 0x04401249, 0x09610209, 0x06060608,
+	0x06460109, 0x09809709, 0x06060109, 0x07800ec9, 0x07800f08,
+	0x0958c248, 0x0978425f, 0x06011609, 0x06411009, 0x091e1249,
+	0x0a6f8009, 0x00000000, 0x06a00208, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x09201248, 0x0aa04009, 0x07800508,
+	0x09808788, 0x098087c8, 0x06012408, 0x07800d48, 0x0a610008,
+	0x07800d88, 0x0a608008, 0x00000000, 0x06800048, 0x0541f208,
+	0x06020408, 0x06060408, 0x08040701, 0x06450808, 0x098087c8,
+	0x06050808, 0x06414008, 0x09808048, 0x06014008, 0x06414008,
+	0x0c783a00, 0x00000000, 0x078001c8, 0x0a614008, 0x06800009,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x07c00f89, 0x0a60c009,
+	0x0780020a, 0x0aa0c00a, 0x0c010780, 0x00000000, 0x06414f08,
+	0x095e1209, 0x05001289, 0x0968120a, 0x06014f08, 0x07800208,
+	0x0a614008, 0x06800009, 0x06410c08, 0x08010e82, 0x093c2248,
+	0x07c00fc9, 0x07800f88, 0x0aa08008, 0x0c7f09c0, 0x06410c08,
+	0x08010e88, 0x09308248, 0x07c01009, 0x06410c08, 0x08010e8c,
+	0x0928c248, 0x07c01049, 0x09101209, 0x09081289, 0x0a806288,
+	0x068009ca, 0x09001289, 0x0a803288, 0x06800d8a, 0x06800e8a,
+	0x06414f09, 0x0940624a, 0x06014f09, 0x0680008a, 0x0680000b,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x03408289, 0x02c0b20b,
+	0x0a63c009, 0x07c023cb, 0x0b20c00a, 0x0c7ffe00, 0x0440128a,
+	0x06410c08, 0x08010e90, 0x09210248, 0x04001249, 0x06410c08,
+	0x08010e90, 0x09210208, 0x04001208, 0x07c00308, 0x07c002c9,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x07c021c9, 0x0aa2c009,
+	0x00000000, 0x06410c08, 0x08010e90, 0x09210248, 0x04001249,
+	0x07c02309, 0x08010e90, 0x09010208, 0x04001208, 0x07c02348,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x07c01089, 0x06414f08,
+	0x09661209, 0x06014f08, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0a61c009, 0x0680010a, 0x08010e82, 0x093a2248, 0x0b60c089,
+	0x04000289, 0x0500128a, 0x07c010ca, 0x06414f08, 0x0960320a,
+	0x06014f08, 0x0c7f0880, 0x00000000, 0x0a60c188, 0x00000000,
+	0x08010e90, 0x0c780080, 0x0800c0ff, 0x00800000, 0x07800008,
+	0x0c7ecc00, 0x06030408, 0x06806008, 0x06010e08, 0x06410f08,
+	0x0befc0c8, 0x09118208, 0x0cc00000, 0x07400248, 0x0680e008,
+	0x06010e08, 0x06410f08, 0x0befc0c8, 0x09118208, 0x0cc00000,
+	0x07400248, 0x06410509, 0x06bfff89, 0x06030409, 0x00400000,
+	0x0be0c108, 0x0c7ffa40, 0x00000000, 0x08012104, 0x080150c0,
+	0x06411c26, 0x06411d27, 0x06414728, 0x06414229, 0x07800409,
+	0x0ae1c049, 0x0641432a, 0x04000866, 0x040008a7, 0x040008e8,
+	0x04000929, 0x0400096a, 0x06014224, 0x06014325, 0x06011c21,
+	0x06011d22, 0x0a21c91f, 0x06014723, 0x08011e00, 0x08011f00,
+	0x08014800, 0x08014400, 0x08014500, 0x0be0e026, 0x0c780ec0,
+	0x00000000, 0x07800a48, 0x0aa0c008, 0x0c00be00, 0x00000000,
+	0x068001df, 0x0978479f, 0x06420409, 0x093e1209, 0x0a6f8008,
+	0x09c09749, 0x06020409, 0x07800cc8, 0x04001208, 0x07800c49,
+	0x0b009248, 0x07c00cc8, 0x06800008, 0x07c00cc8, 0x07800d08,
+	0x04001208, 0x07800c89, 0x0ac08248, 0x07c00d08, 0x0c007c80,
+	0x00000000, 0x0c005180, 0x00000000, 0x0c7f7c40, 0x00000000,
+	0x07800549, 0x0aa0c009, 0x0c00bf80, 0x00000000, 0x0c004f80,
+	0x00000000, 0x0640d708, 0x0aa4c008, 0x00000000, 0x0640d309,
+	0x0aa2c049, 0x07801509, 0x0780154b, 0x0961024b, 0x06410d0b,
+	0x0240b24b, 0x0680802f, 0x0c00f900, 0x04000c0b, 0x0b80720b,
+	0x00000000, 0x0c003d00, 0x00000000, 0x0800c00a, 0x0c7fe580,
+	0x08007401, 0x0c7fe500, 0x0800c0ff, 0x0601161e, 0x07800508,
+	0x09808788, 0x098087c8, 0x06012408, 0x06414009, 0x09809049,
+	0x06014009, 0x06414009, 0x09c1f09f, 0x07800508, 0x04001208,
+	0x07c00508, 0x07800b88, 0x04001208, 0x07c00b88, 0x0a21409f,
+	0x07800e49, 0x0b803248, 0x00000000, 0x09c1f05f, 0x07800ec8,
+	0x04001208, 0x07800dc9, 0x0b811248, 0x07c00ec8, 0x07800d48,
+	0x07c00ec8, 0x0981f09f, 0x07800508, 0x07800409, 0x02008248,
+	0x07800e49, 0x02408248, 0x07c00508, 0x07800f08, 0x04001208,
+	0x07800e09, 0x0b803248, 0x07c00f08, 0x0981f0df, 0x07800f08,
+	0x04001208, 0x07800e09, 0x0b80f248, 0x07800ec8, 0x04001208,
+	0x07800dc9, 0x0b80b248, 0x07800409, 0x0b807248, 0x07800f08,
+	0x04001208, 0x07800449, 0x0b803248, 0x0c7800c0, 0x09c1f11f,
+	0x0981f11f, 0x0981f0df, 0x07800ede, 0x07800f08, 0x0958c788,
+	0x0978479f, 0x07800b88, 0x0ae08048, 0x0c780a00, 0x07800ec9,
+	0x07800d4a, 0x0400228a, 0x0b407289, 0x04402209, 0x0440128a,
+	0x07800dc8, 0x0b403289, 0x04401208, 0x04401208, 0x05403248,
+	0x02009248, 0x02008248, 0x06806009, 0x02009209, 0x07400266,
+	0x09210226, 0x04001249, 0x07400248, 0x04001249, 0x07400269,
+	0x09210229, 0x04001249, 0x07400248, 0x04001249, 0x0740026a,
+	0x0921022a, 0x04001249, 0x07400248, 0x04001249, 0x07400267,
+	0x09210227, 0x04001249, 0x07400248, 0x04001249, 0x07400268,
+	0x09210228, 0x04001249, 0x07400248, 0x0a21c09f, 0x06800024,
+	0x06800025, 0x06800021, 0x06800022, 0x0c780800, 0x06800023,
+	0x07800ec8, 0x05403248, 0x02009248, 0x02008248, 0x06806009,
+	0x02009209, 0x07000261, 0x04001249, 0x07000248, 0x09610848,
+	0x04001249, 0x07000264, 0x04001249, 0x07000248, 0x09610908,
+	0x04001249, 0x07000265, 0x04001249, 0x07000248, 0x09610948,
+	0x04001249, 0x07000262, 0x04001249, 0x07000248, 0x09610888,
+	0x04001249, 0x07000263, 0x04001249, 0x07000248, 0x096108c8,
+	0x07800a48, 0x0aa0c008, 0x0c006b00, 0x00000000, 0x0c7fc000,
+	0x00000000, 0x06808006, 0x0640d707, 0x0aa2c007, 0x06410607,
+	0x0b003187, 0x0c780200, 0x00000000, 0x0681de2f, 0x0c00cf40,
+	0x04000c07, 0x0800c020, 0x08007401, 0x0c780000, 0x06412106,
+	0x090c1186, 0x0a6c4006, 0x0c7e8800, 0x00000000, 0x06804009,
 	0x06012d09, 0x06800f8a, 0x08012e00, 0x00000000, 0x0d07ff8a,
 	0x00000000, 0x0cc00000, 0x00000000, 0x07800148, 0x07c02008,
 	0x07800188, 0x07c020c8, 0x078001c8, 0x07c02108, 0x07800208,
@@ -329,144 +343,157 @@ const u32  vvp9_mc[] __initconst = {
 	0x07c024c8, 0x078007c8, 0x07c02508, 0x07800808, 0x07c02548,
 	0x07800848, 0x07c02588, 0x07800648, 0x07c025c8, 0x07800688,
 	0x07c02608, 0x07800248, 0x07c02648, 0x07800a48, 0x07c02888,
-	0x07800b08, 0x07c028c8, 0x0640c108, 0x06035108, 0x06802008,
-	0x06035208, 0x06a02008, 0x06035008, 0x06435008, 0x0580f208,
+	0x07800b08, 0x07c028c8, 0x07800288, 0x07c02b08, 0x0640c108,
+	0x06035108, 0x06802008, 0x06035208, 0x06a02008, 0x06035008,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06435308,
+	0x0900c208, 0x0a6f8008, 0x00000000, 0x0cc00000, 0x00000000,
+	0x0640c108, 0x06804009, 0x02008248, 0x06035108, 0x06802008,
+	0x06035208, 0x06a00148, 0x06035008, 0x06435008, 0x0580f208,
 	0x0bef8048, 0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008,
-	0x00000000, 0x0cc00000, 0x00000000, 0x0800cf00, 0x0800c0ff,
-	0x06800009, 0x0680ffca, 0x07000248, 0x09808408, 0x0600cf08,
-	0x00000000, 0x0640cf08, 0x0a6fc008, 0x0b403289, 0x0c7ffe40,
-	0x04001249, 0x0cc00000, 0x00000000, 0x069fffca, 0x06440109,
-	0x0a2fc049, 0x0440128a, 0x06460309, 0x093e1289, 0x0a6f800a,
-	0x00000000, 0x0cc00000, 0x00000000, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x0a60c009, 0x07c00a89, 0x0c780b80, 0x06847f4a,
-	0x06012d0a, 0x0680000a, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x0aa14009, 0x06803fc9, 0x06410c08, 0x08010e88, 0x09308248,
-	0x054082cb, 0x094082c9, 0x0bad80ca, 0x0400128a, 0x0a60c10a,
-	0x00000000, 0x06012e0b, 0x0bac41ca, 0x00000000, 0x054082cb,
-	0x06012e0b, 0x06847fca, 0x06012d0a, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x06bfc00b, 0x0aa40009, 0x07c00ac9, 0x0680000a,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009, 0x06803fc9,
-	0x06410c08, 0x08010e88, 0x09308248, 0x054082cb, 0x094082c9,
-	0x0bad808a, 0x0400128a, 0x054082cb, 0x06012e0b, 0x06410c08,
-	0x08010e81, 0x093e1248, 0x0a60c009, 0x0c780d80, 0x00000000,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x07c00b09, 0x0680000c,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009, 0x0680000a,
-	0x06410c08, 0x08010e89, 0x092e9288, 0x0680268b, 0x0200b30b,
-	0x074002ca, 0x0680000b, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x0540f289, 0x0aa28009, 0x095612c9, 0x06410c08, 0x08010e87,
-	0x09346248, 0x09406289, 0x094862c9, 0x09321248, 0x09501289,
-	0x095412c9, 0x040a420c, 0x0740020a, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x0aa18009, 0x094612c9, 0x06410c08, 0x08010e82,
-	0x093c2248, 0x094222c9, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x094012c9, 0x096c32cc, 0x0980b7cb, 0x0b6101cc, 0x0601460b,
-	0x0c7ff4c0, 0x0400130c, 0x0680000c, 0x07800b0a, 0x0aa0c00a,
-	0x0780088b, 0x0680000b, 0x06802688, 0x02008308, 0x07000208,
-	0x09028288, 0x09001248, 0x0aa0c009, 0x0200928b, 0x0240928b,
-	0x0ba14009, 0x0680000a, 0x0ae0ffc9, 0x06803fca, 0x04000289,
-	0x07900988, 0x0200920a, 0x0ba14009, 0x0680000b, 0x0ae0ffc9,
-	0x06803fcb, 0x040002c9, 0x095082ca, 0x096232cc, 0x0601460b,
-	0x07900a08, 0x0200920a, 0x0ba14009, 0x0680000b, 0x0ae0ffc9,
-	0x06803fcb, 0x040002c9, 0x079009c8, 0x0200920a, 0x0ba14009,
-	0x06800008, 0x0ae0ffc9, 0x06803fc8, 0x04000209, 0x0950820b,
-	0x0962320c, 0x09808408, 0x06014608, 0x0b60c1cc, 0x0c7ff480,
-	0x0400130c, 0x0cc00000, 0x00000000, 0x07800dc8, 0x04401208,
+	0x00000000, 0x0cc00000, 0x00000000, 0x0640c100, 0x06035100,
+	0x06802000, 0x06035200, 0x06b02000, 0x06035000, 0x06435000,
+	0x0580f000, 0x0bef8040, 0x00000000, 0x0640c100, 0x06804001,
+	0x02000040, 0x06035100, 0x06802000, 0x06035200, 0x06b00140,
+	0x06035000, 0x06435000, 0x0580f000, 0x0bef8040, 0x00000000,
+	0x0cc00000, 0x00000000, 0x0800cf00, 0x0800c0ff, 0x06800009,
+	0x0680ffca, 0x07000248, 0x09808408, 0x0600cf08, 0x00000000,
+	0x0640cf08, 0x0a6fc008, 0x0b403289, 0x0c7ffe40, 0x04001249,
+	0x0cc00000, 0x00000000, 0x069fffca, 0x06440109, 0x0a2fc049,
+	0x0440128a, 0x06460309, 0x093e1289, 0x0a6f800a, 0x00000000,
+	0x0cc00000, 0x00000000, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0a60c009, 0x07c00a89, 0x0c780b80, 0x06847f4a, 0x06012d0a,
+	0x0680000a, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009,
+	0x06803fc9, 0x06410c08, 0x08010e88, 0x09308248, 0x054082cb,
+	0x094082c9, 0x0bad80ca, 0x0400128a, 0x0a60c10a, 0x00000000,
+	0x06012e0b, 0x0bac41ca, 0x00000000, 0x054082cb, 0x06012e0b,
+	0x06847fca, 0x06012d0a, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x06bfc00b, 0x0aa40009, 0x07c00ac9, 0x0680000a, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0aa14009, 0x06803fc9, 0x06410c08,
+	0x08010e88, 0x09308248, 0x054082cb, 0x094082c9, 0x0bad808a,
+	0x0400128a, 0x054082cb, 0x06012e0b, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0a60c009, 0x0c780d80, 0x00000000, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x07c00b09, 0x0680000c, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0aa14009, 0x0680000a, 0x06410c08,
+	0x08010e89, 0x092e9288, 0x0680268b, 0x0200b30b, 0x074002ca,
+	0x0680000b, 0x06410c08, 0x08010e81, 0x093e1248, 0x0540f289,
+	0x0aa28009, 0x095612c9, 0x06410c08, 0x08010e87, 0x09346248,
+	0x09406289, 0x094862c9, 0x09321248, 0x09501289, 0x095412c9,
+	0x040a420c, 0x0740020a, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0aa18009, 0x094612c9, 0x06410c08, 0x08010e82, 0x093c2248,
+	0x094222c9, 0x06410c08, 0x08010e81, 0x093e1248, 0x094012c9,
+	0x096c32cc, 0x0980b7cb, 0x0b6101cc, 0x0601460b, 0x0c7ff4c0,
+	0x0400130c, 0x0680000c, 0x07800b0a, 0x0aa0c00a, 0x0780088b,
+	0x0680000b, 0x06802688, 0x02008308, 0x07000208, 0x09028288,
+	0x09001248, 0x0aa0c009, 0x0200928b, 0x0240928b, 0x0ba14009,
+	0x0680000a, 0x0ae0ffc9, 0x06803fca, 0x04000289, 0x07900988,
+	0x0200920a, 0x0ba14009, 0x0680000b, 0x0ae0ffc9, 0x06803fcb,
+	0x040002c9, 0x095082ca, 0x096232cc, 0x0601460b, 0x07900a08,
+	0x0200920a, 0x0ba14009, 0x0680000b, 0x0ae0ffc9, 0x06803fcb,
+	0x040002c9, 0x079009c8, 0x0200920a, 0x0ba14009, 0x06800008,
+	0x0ae0ffc9, 0x06803fc8, 0x04000209, 0x0950820b, 0x0962320c,
+	0x09808408, 0x06014608, 0x0b60c1cc, 0x0c7ff480, 0x0400130c,
+	0x0cc00000, 0x00000000, 0x07800dc8, 0x04401208, 0x05403248,
+	0x02009248, 0x02008248, 0x06806009, 0x02009209, 0x07400266,
+	0x09210226, 0x04001249, 0x07400248, 0x04001249, 0x07400269,
+	0x09210229, 0x04001249, 0x07400248, 0x04001249, 0x0740026a,
+	0x0921022a, 0x04001249, 0x07400248, 0x04001249, 0x07400267,
+	0x09210227, 0x04001249, 0x07400248, 0x04001249, 0x07400268,
+	0x09210228, 0x04001249, 0x0cc00000, 0x07400248, 0x07800d48,
 	0x05403248, 0x02009248, 0x02008248, 0x06806009, 0x02009209,
-	0x07400266, 0x09210226, 0x04001249, 0x07400248, 0x04001249,
-	0x07400269, 0x09210229, 0x04001249, 0x07400248, 0x04001249,
-	0x0740026a, 0x0921022a, 0x04001249, 0x07400248, 0x04001249,
-	0x07400267, 0x09210227, 0x04001249, 0x07400248, 0x04001249,
-	0x07400268, 0x09210228, 0x04001249, 0x0cc00000, 0x07400248,
-	0x07800d48, 0x05403248, 0x02009248, 0x02008248, 0x06806009,
-	0x02009209, 0x07000261, 0x04001249, 0x07000248, 0x09610848,
-	0x04001249, 0x07000264, 0x04001249, 0x07000248, 0x09610908,
-	0x04001249, 0x07000265, 0x04001249, 0x07000248, 0x09610948,
-	0x04001249, 0x07000262, 0x04001249, 0x07000248, 0x09610888,
-	0x04001249, 0x07000263, 0x04001249, 0x07000248, 0x096108c8,
-	0x06014224, 0x06014325, 0x06011c21, 0x06011d22, 0x0cc00000,
-	0x06014723, 0x07800a88, 0x0aa14008, 0x07800ac8, 0x0a60c008,
-	0x0cc00000, 0x00000000, 0x07801208, 0x0640cb09, 0x02009248,
-	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06035109,
-	0x06800c08, 0x06035208, 0x06b10008, 0x06035008, 0x08015020,
-	0x06435008, 0x0580f208, 0x0bef8048, 0x06810008, 0x0680018b,
-	0x07800b49, 0x0a618009, 0x06800009, 0x0d00000b, 0x06015109,
-	0x0cc00000, 0x08015080, 0x07000209, 0x04001208, 0x0700020a,
-	0x04001208, 0x0961024a, 0x0d07fecb, 0x06015109, 0x0cc00000,
-	0x08015080, 0x07800b88, 0x0ae08048, 0x0c780900, 0x078012c8,
-	0x05403248, 0x05402208, 0x02008248, 0x06810009, 0x02008248,
-	0x08015020, 0x0643500b, 0x0580f2cb, 0x0bef804b, 0x0680018b,
-	0x06415109, 0x07400209, 0x04001208, 0x09210249, 0x07400209,
-	0x0d07fecb, 0x04001208, 0x07c012c8, 0x07801288, 0x0be3c0c8,
-	0x0be0c108, 0x0681000b, 0x040302cb, 0x07800a88, 0x0aa28008,
-	0x07801248, 0x0640cb09, 0x02009248, 0x06035109, 0x078012c8,
-	0x024082c8, 0x06035208, 0x0980b3cb, 0x0603500b, 0x07801208,
-	0x07c01248, 0x07801288, 0x07c012c8, 0x07800f08, 0x07801349,
-	0x0a408248, 0x07800eca, 0x07801309, 0x04001249, 0x0a40c289,
-	0x07801289, 0x0c780340, 0x04001249, 0x04001249, 0x0a407209,
-	0x07800eca, 0x0a61400a, 0x07801309, 0x04001249, 0x0780040a,
-	0x0a8f6289, 0x07801289, 0x04004249, 0x048fc249, 0x04807249,
-	0x07c01289, 0x0be340c9, 0x07800f08, 0x07800409, 0x0e000248,
-	0x07800ec9, 0x00000000, 0x00000000, 0x0f000200, 0x02008248,
-	0x05404248, 0x05403208, 0x02008248, 0x07c01208, 0x07800ec8,
-	0x07c01308, 0x07800f08, 0x07c01348, 0x07800a88, 0x0aa14008,
-	0x07800ac8, 0x0a60c008, 0x0cc00000, 0x00000000, 0x07801289,
-	0x0be400c9, 0x07801208, 0x0640cb09, 0x02009248, 0x06435008,
+	0x07000261, 0x04001249, 0x07000248, 0x09610848, 0x04001249,
+	0x07000264, 0x04001249, 0x07000248, 0x09610908, 0x04001249,
+	0x07000265, 0x04001249, 0x07000248, 0x09610948, 0x04001249,
+	0x07000262, 0x04001249, 0x07000248, 0x09610888, 0x04001249,
+	0x07000263, 0x04001249, 0x07000248, 0x096108c8, 0x06014224,
+	0x06014325, 0x06011c21, 0x06011d22, 0x0cc00000, 0x06014723,
+	0x07800a88, 0x0aa14008, 0x07800ac8, 0x0a60c008, 0x0cc00000,
+	0x00000000, 0x07801208, 0x0640cb09, 0x02009248, 0x06435008,
 	0x0580f208, 0x0bef8048, 0x00000000, 0x06035109, 0x06800c08,
-	0x06035208, 0x07801289, 0x0be0c109, 0x06b10c08, 0x06b10008,
-	0x06035008, 0x06435008, 0x0580f208, 0x0bef8048, 0x00000000,
-	0x07801288, 0x05403248, 0x05402208, 0x02008248, 0x06810009,
-	0x02008248, 0x08015020, 0x0680018b, 0x07800b49, 0x0a618009,
-	0x06800009, 0x0d00000b, 0x06015109, 0x0cc00000, 0x00000000,
-	0x07000209, 0x04001208, 0x0700020a, 0x04001208, 0x0961024a,
-	0x0d07fecb, 0x06015109, 0x0cc00000, 0x00000000, 0x078012c8,
-	0x0a20c108, 0x0681000a, 0x06810c0a, 0x05403248, 0x05402208,
-	0x02008248, 0x06810009, 0x02008248, 0x08015020, 0x0643500b,
-	0x0580f2cb, 0x0bef804b, 0x0680018b, 0x06415109, 0x07400209,
-	0x04001208, 0x09210249, 0x07400209, 0x0d07fecb, 0x04001208,
-	0x07c012c8, 0x07800a88, 0x0a608008, 0x0cc00000, 0x07801248,
-	0x0640cb09, 0x02009248, 0x06035109, 0x078012c8, 0x02408288,
-	0x06035208, 0x0980a3ca, 0x0cc00000, 0x0603500a, 0x06410108,
-	0x09808348, 0x06010108, 0x06410108, 0x09021208, 0x0a6f8008,
-	0x07800588, 0x0aa34048, 0x06bf0008, 0x06e016c8, 0x06014d08,
-	0x0640ca08, 0x06013408, 0x08013503, 0x06413508, 0x090e1248,
-	0x0a6f8009, 0x09308248, 0x0a6f0009, 0x00000000, 0x08014d00,
-	0x06af0008, 0x06ec05c8, 0x06014d08, 0x0640c908, 0x07800589,
-	0x0aa10009, 0x06900009, 0x078005c9, 0x0540c249, 0x02008248,
-	0x06013408, 0x08013503, 0x06413508, 0x090e1248, 0x0a6f8009,
-	0x09308248, 0x0a6f0009, 0x00000000, 0x08013500, 0x08014d00,
-	0x07800588, 0x0aa14048, 0x06803f48, 0x078005c9, 0x09502209,
-	0x0600c308, 0x06410108, 0x09c08348, 0x0cc00000, 0x06010108,
-	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x0640c408,
-	0x07801189, 0x05408249, 0x02008248, 0x06035108, 0x08035280,
-	0x06bd4008, 0x06035008, 0x07801189, 0x04001249, 0x07c01189,
-	0x06814009, 0x07c01149, 0x06462308, 0x09808288, 0x06062308,
-	0x06462d08, 0x09808048, 0x06062d08, 0x06435008, 0x0580f208,
-	0x0bef8048, 0x00000000, 0x0cc00000, 0x00000000, 0x06463908,
-	0x09105248, 0x0aa40009, 0x0780114a, 0x07000288, 0x0400128a,
-	0x0700028b, 0x0961020b, 0x06063808, 0x0400128a, 0x07c0114a,
-	0x06816008, 0x0b8f620a, 0x04401249, 0x0c07f540, 0x00000000,
-	0x0c7ffc00, 0x00000000, 0x0cc00000, 0x00000000, 0x0680000c,
-	0x06800008, 0x07c00b48, 0x0409a2cc, 0x074002c8, 0x040a42cc,
-	0x074002c8, 0x054162cc, 0x0980b7cb, 0x0b6101cc, 0x0601460b,
-	0x0c7ffe00, 0x0400130c, 0x06800048, 0x07c00708, 0x06800008,
-	0x07c00748, 0x07c00808, 0x07c00848, 0x04401208, 0x07c00788,
-	0x0cc00000, 0x07c007c8, 0x07800349, 0x07800388, 0x09610248,
-	0x06412308, 0x0a804248, 0x06800009, 0x07c00b49, 0x06800049,
-	0x07c003c9, 0x09010248, 0x07c002c9, 0x07c00349, 0x09210208,
-	0x07c00308, 0x07c00388, 0x0403f289, 0x0580628a, 0x07c0040a,
-	0x0403f288, 0x0580628a, 0x0cc00000, 0x07c0044a, 0x067f2f2b,
-	0x0a2fc12b, 0x0640c02b, 0x0a6f7feb, 0x00000000, 0x0641392b,
-	0x0680006f, 0x0c001200, 0x06800030, 0x0c001d00, 0x069fffb1,
+	0x06035208, 0x06b10008, 0x06035008, 0x08015020, 0x06435008,
+	0x0580f208, 0x0bef8048, 0x06810008, 0x0680018b, 0x07800b49,
+	0x0a618009, 0x06800009, 0x0d00000b, 0x06015109, 0x0cc00000,
+	0x08015080, 0x07000209, 0x04001208, 0x0700020a, 0x04001208,
+	0x0961024a, 0x0d07fecb, 0x06015109, 0x0cc00000, 0x08015080,
+	0x07800b88, 0x0ae08048, 0x0c780900, 0x078012c8, 0x05403248,
+	0x05402208, 0x02008248, 0x06810009, 0x02008248, 0x08015020,
+	0x0643500b, 0x0580f2cb, 0x0bef804b, 0x0680018b, 0x06415109,
+	0x07400209, 0x04001208, 0x09210249, 0x07400209, 0x0d07fecb,
+	0x04001208, 0x07c012c8, 0x07801288, 0x0be3c0c8, 0x0be0c108,
+	0x0681000b, 0x040302cb, 0x07800a88, 0x0aa28008, 0x07801248,
+	0x0640cb09, 0x02009248, 0x06035109, 0x078012c8, 0x024082c8,
+	0x06035208, 0x0980b3cb, 0x0603500b, 0x07801208, 0x07c01248,
+	0x07801288, 0x07c012c8, 0x07800f08, 0x07801349, 0x0a408248,
+	0x07800eca, 0x07801309, 0x04001249, 0x0a40c289, 0x07801289,
+	0x0c780340, 0x04001249, 0x04001249, 0x0a407209, 0x07800eca,
+	0x0a61400a, 0x07801309, 0x04001249, 0x0780040a, 0x0a8f6289,
+	0x07801289, 0x04004249, 0x048fc249, 0x04807249, 0x07c01289,
+	0x0be340c9, 0x07800f08, 0x07800409, 0x0e000248, 0x07800ec9,
+	0x00000000, 0x00000000, 0x0f000200, 0x02008248, 0x05404248,
+	0x05403208, 0x02008248, 0x07c01208, 0x07800ec8, 0x07c01308,
+	0x07800f08, 0x07c01348, 0x07800a88, 0x0aa14008, 0x07800ac8,
+	0x0a60c008, 0x0cc00000, 0x00000000, 0x07801289, 0x0be400c9,
+	0x07801208, 0x0640cb09, 0x02009248, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x06035109, 0x06800c08, 0x06035208,
+	0x07801289, 0x0be0c109, 0x06b10c08, 0x06b10008, 0x06035008,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x07801288,
+	0x05403248, 0x05402208, 0x02008248, 0x06810009, 0x02008248,
+	0x08015020, 0x0680018b, 0x07800b49, 0x0a618009, 0x06800009,
+	0x0d00000b, 0x06015109, 0x0cc00000, 0x00000000, 0x07000209,
+	0x04001208, 0x0700020a, 0x04001208, 0x0961024a, 0x0d07fecb,
+	0x06015109, 0x0cc00000, 0x00000000, 0x078012c8, 0x0a20c108,
+	0x0681000a, 0x06810c0a, 0x05403248, 0x05402208, 0x02008248,
+	0x06810009, 0x02008248, 0x08015020, 0x0643500b, 0x0580f2cb,
+	0x0bef804b, 0x0680018b, 0x06415109, 0x07400209, 0x04001208,
+	0x09210249, 0x07400209, 0x0d07fecb, 0x04001208, 0x07c012c8,
+	0x07800a88, 0x0a608008, 0x0cc00000, 0x07801248, 0x0640cb09,
+	0x02009248, 0x06035109, 0x078012c8, 0x02408288, 0x06035208,
+	0x0980a3ca, 0x0cc00000, 0x0603500a, 0x0680142f, 0x0c003d00,
+	0x04000c08, 0x06410108, 0x09808348, 0x06010108, 0x06410108,
+	0x09021208, 0x0a6f8008, 0x07800588, 0x0aa34048, 0x06bf0008,
+	0x06e016c8, 0x06014d08, 0x0640ca08, 0x06013408, 0x08013503,
+	0x06413508, 0x090e1248, 0x0a6f8009, 0x09308248, 0x0a6f0009,
+	0x00000000, 0x08014d00, 0x06af0008, 0x06ec05c8, 0x06014d08,
+	0x0640c908, 0x07800589, 0x0aa10009, 0x06900009, 0x078005c9,
+	0x0540c249, 0x02008248, 0x06013408, 0x08013503, 0x06413508,
+	0x090e1248, 0x0a6f8009, 0x09308248, 0x0a6f0009, 0x00000000,
+	0x08013500, 0x08014d00, 0x07800588, 0x0aa14048, 0x06803f48,
+	0x078005c9, 0x09502209, 0x0600c308, 0x06410108, 0x09c08348,
+	0x0cc00000, 0x06010108, 0x06435008, 0x0580f208, 0x0bef8048,
+	0x00000000, 0x0640c408, 0x07801189, 0x05408249, 0x02008248,
+	0x06035108, 0x08035280, 0x06bd4008, 0x06035008, 0x07801189,
+	0x04001249, 0x07c01189, 0x06814009, 0x07c01149, 0x06462308,
+	0x09808288, 0x06062308, 0x06462d08, 0x09808048, 0x06062d08,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x0cc00000,
+	0x00000000, 0x06463908, 0x09105248, 0x0aa40009, 0x0780114a,
+	0x07000288, 0x0400128a, 0x0700028b, 0x0961020b, 0x06063808,
+	0x0400128a, 0x07c0114a, 0x06816008, 0x0b8f620a, 0x04401249,
+	0x0c07f540, 0x00000000, 0x0c7ffc00, 0x00000000, 0x0cc00000,
+	0x00000000, 0x0680000c, 0x06800008, 0x07c00b48, 0x0409a2cc,
+	0x074002c8, 0x040a42cc, 0x074002c8, 0x054162cc, 0x0980b7cb,
+	0x0b6101cc, 0x0601460b, 0x0c7ffe00, 0x0400130c, 0x06800048,
+	0x07c00708, 0x06800008, 0x07c00748, 0x07c00808, 0x07c00848,
+	0x04401208, 0x07c00788, 0x0cc00000, 0x07c007c8, 0x07800349,
+	0x07800388, 0x09610248, 0x06412308, 0x0a804248, 0x06800009,
+	0x07c00b49, 0x06800049, 0x07c003c9, 0x09010248, 0x07c002c9,
+	0x07c00349, 0x09210208, 0x07c00308, 0x07c00388, 0x0403f289,
+	0x0580628a, 0x07c0040a, 0x0403f288, 0x0580628a, 0x0cc00000,
+	0x07c0044a, 0x067f2f2b, 0x0a2fc12b, 0x0640c02b, 0x0a6f7feb,
+	0x00000000, 0x0780152b, 0x0780156e, 0x09610aee, 0x06410d2e,
+	0x0242eaee, 0x0640d72b, 0x0aa3002b, 0x00000000, 0x068000ef,
+	0x04000c2e, 0x0c001480, 0x09610c2b, 0x04401aeb, 0x0b805aee,
+	0x00000000, 0x0800c00e, 0x0c7ffac0, 0x08007401, 0x0641392b,
+	0x068000af, 0x0c001200, 0x06800030, 0x0c001d00, 0x069fffb1,
 	0x08013900, 0x06410b2b, 0x0982b0ab, 0x06010b2b, 0x0641212b,
 	0x0a2fc06b, 0x00000000, 0x069315ae, 0x06d0536e, 0x06410c2b,
-	0x068000af, 0x0c000e40, 0x04000c2b, 0x0a4edbab, 0x08012101,
-	0x08010e90, 0x08010e90, 0x06410c2b, 0x068000ef, 0x0c000c40,
+	0x068000ef, 0x0c000e40, 0x04000c2b, 0x0a4edbab, 0x08012101,
+	0x08010e90, 0x08010e90, 0x06410c2b, 0x0680012f, 0x0c000c40,
 	0x04000c2b, 0x0695556e, 0x06d5556e, 0x0a409bab, 0x00000000,
 	0x08012101, 0x0800c0f2, 0x08007401, 0x0640c02e, 0x0aaffcae,
 	0x0c7ff700, 0x00000000, 0x093c2aeb, 0x0aa0c0ab, 0x0c7ff600,
 	0x00000000, 0x0641162c, 0x093e1b2c, 0x0aa0402c, 0x0640d22c,
-	0x0a21406c, 0x00000000, 0x0800c0f1, 0x0c7ff280, 0x08007401,
-	0x0680006d, 0x0680012f, 0x0c000540, 0x04000c2d, 0x0600c02d,
-	0x08030504, 0x0c7ff080, 0x00000000, 0x0c074980, 0x00000000,
+	0x0a21406c, 0x00000000, 0x0800c0f1, 0x0c7fee00, 0x08007401,
+	0x0680006d, 0x0680016f, 0x0c000540, 0x04000c2d, 0x0600c02d,
+	0x08030504, 0x0c7fec00, 0x00000000, 0x0c073940, 0x00000000,
 	0x0800c0f0, 0x08007401, 0x0cc00000, 0x00000000, 0x0640c009,
 	0x0aa0c149, 0x0a6f8189, 0x00000000, 0x068004af, 0x0c000100,
 	0x06800030, 0x0cc00000, 0x00000000, 0x0600d130, 0x078013f0,
@@ -494,309 +521,328 @@ const u32  vvp9_mc[] __initconst = {
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 
 #else
+
+
 	0x06814001, 0x06800000, 0x0d000001, 0x07400040, 0x0c0010c0,
 	0x00000000, 0x06bffe40, 0x07c00000, 0x06030400, 0x00400000,
-	0x0800c0ff, 0x0c021cc0, 0x00000000, 0x00000000, 0x00000000,
+	0x0800c0ff, 0x0c023780, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x0c7ffd80, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x0c796d80, 0x00000000, 0x0c793600,
-	0x06412108, 0x0c7811c0, 0x00000000, 0x0cc00000, 0x00400000,
+	0x00000000, 0x00000000, 0x0c797940, 0x00000000, 0x0c793cc0,
+	0x06412108, 0x0c7815c0, 0x00000000, 0x0cc00000, 0x00400000,
 	0x06450400, 0x0600d000, 0x0640d000, 0x06035100, 0x0680c000,
 	0x06035200, 0x06a04000, 0x06035000, 0x06435000, 0x0580f000,
 	0x0bef8040, 0x00000000, 0x06435300, 0x0900c000, 0x0a6f8000,
 	0x00000000, 0x0640d000, 0x06818001, 0x02000040, 0x0600d000,
-	0x07803fc0, 0x04001000, 0x07c03fc0, 0x06805581, 0x0b8ea040,
-	0x00000000, 0x06800000, 0x07c03fc0, 0x0600d000, 0x0cc00000,
-	0x00000000, 0x0c07f840, 0x00000000, 0x06800040, 0x09800540,
-	0x09800580, 0x06014000, 0x0800c000, 0x068000c0, 0x07c004c0,
-	0x06800000, 0x07c00480, 0x06860000, 0x06c000c0, 0x06011100,
-	0x08002515, 0x08002608, 0x0640d000, 0x07c013c0, 0x0640d200,
-	0x07c01380, 0x0640c108, 0x06035108, 0x06800408, 0x06035208,
-	0x06a04008, 0x06035008, 0x06435008, 0x0580f208, 0x0bef8048,
-	0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008, 0x00000000,
-	0x0cc00000, 0x00000000, 0x06bfff88, 0x06030408, 0x00400000,
-	0x0640c008, 0x0680042f, 0x0c021740, 0x04000c08, 0x0a6181c8,
-	0x00000000, 0x0c016b00, 0x00000000, 0x0c791c00, 0x0800c0ff,
-	0x0aa0c048, 0x0c791a00, 0x00000000, 0x06bf0008, 0x06e012c8,
-	0x06014d08, 0x06410c08, 0x08010e84, 0x09382248, 0x0ae18089,
-	0x0aa20009, 0x0aa1c049, 0x06800089, 0x0c780140, 0x06800049,
-	0x09361208, 0x08010e81, 0x02009209, 0x07c00149, 0x07800a48,
-	0x0aa14008, 0x07800a88, 0x0aa0c008, 0x06800048, 0x07c00b48,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x07c02049, 0x0aa2c009,
-	0x06410c08, 0x08010e83, 0x093a3248, 0x07c02089, 0x0c020900,
-	0x00000000, 0x0c020a00, 0x00000000, 0x0c791200, 0x0800c0ff,
-	0x06410c08, 0x08010e83, 0x093a1248, 0x07c00209, 0x093c1248,
-	0x07c001c9, 0x093e1248, 0x07c00189, 0x06411008, 0x05001249,
-	0x07c00f89, 0x09421209, 0x06011008, 0x06414f08, 0x095e1209,
-	0x09761209, 0x05001289, 0x0968120a, 0x06014f08, 0x0aa0c049,
-	0x0c78f0c0, 0x00000000, 0x06800008, 0x0c01e680, 0x07c00b48,
-	0x06410c08, 0x08010e88, 0x08010e90, 0x06a0d089, 0x06c01249,
-	0x09118208, 0x0a803248, 0x0c780000, 0x00000000, 0x07800188,
-	0x0aa28008, 0x07800148, 0x0a620008, 0x06800209, 0x07c00249,
-	0x06800049, 0x07c00289, 0x06800049, 0x0c780600, 0x00000000,
-	0x0ba20088, 0x06800209, 0x06410c08, 0x08010e81, 0x093e1208,
-	0x0aa0c008, 0x06800289, 0x06800309, 0x07c00249, 0x06410c08,
-	0x08010e83, 0x093a3248, 0x07c00289, 0x0a60c1c9, 0x0c780000,
-	0x00000000, 0x06410c08, 0x08010e81, 0x07800149, 0x0a20c049,
-	0x0c780000, 0x00000000, 0x07800188, 0x0aa14008, 0x06410c08,
-	0x08010e88, 0x09308248, 0x07c01009, 0x06410c08, 0x08010e90,
-	0x09210248, 0x04001249, 0x07c002c9, 0x06410c08, 0x08010e90,
-	0x09210208, 0x04001208, 0x07c00308, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x0aa24009, 0x00000000, 0x06410c08, 0x08010e90,
-	0x09210248, 0x04001249, 0x08010e90, 0x09010208, 0x04001208,
-	0x07800208, 0x06800009, 0x0a618008, 0x0680004a, 0x06410c08,
-	0x08010e82, 0x093e1248, 0x093c1288, 0x07c00549, 0x07c0058a,
-	0x06410c08, 0x08010e82, 0x093c2248, 0x07c005c9, 0x06410c08,
-	0x08010e8a, 0x09346248, 0x07c00649, 0x092e3248, 0x07c00689,
-	0x092c1248, 0x07c006c9, 0x0aa14009, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x0a608009, 0x0c7810c0, 0x06410c08, 0x08010e81,
+	0x078014c0, 0x04001000, 0x07c014c0, 0x06805581, 0x0b8ea040,
+	0x00000000, 0x06800000, 0x07c014c0, 0x0600d000, 0x0cc00000,
+	0x00000000, 0x0640d72b, 0x0aa2c02b, 0x0640d62b, 0x0aa2402b,
+	0x00000000, 0x0c018900, 0x00000000, 0x06410d2b, 0x09010b2b,
+	0x07c0152c, 0x09210b2b, 0x07c0156c, 0x0640d000, 0x07c013c0,
+	0x0640d200, 0x07c01380, 0x0c07f440, 0x00000000, 0x06800040,
+	0x09800540, 0x09800580, 0x06014000, 0x0800c000, 0x068000c0,
+	0x07c004c0, 0x06800000, 0x07c00480, 0x06860000, 0x06c000c0,
+	0x06011100, 0x08002515, 0x08002608, 0x0800271a, 0x0640c108,
+	0x06035108, 0x06800408, 0x06035208, 0x06a02008, 0x06035008,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06435308,
+	0x0900c208, 0x0a6f8008, 0x00000000, 0x0680006f, 0x0c0234c0,
+	0x04000c08, 0x0cc00000, 0x00000000, 0x06bfff88, 0x06030408,
+	0x00400000, 0x0640c008, 0x0680042f, 0x0c023280, 0x04000c08,
+	0x0a6181c8, 0x00000000, 0x0c018100, 0x00000000, 0x0c791ec0,
+	0x0800c0ff, 0x0aa0c048, 0x0c791cc0, 0x00000000, 0x06bf0008,
+	0x06e012c8, 0x06014d08, 0x06410c08, 0x08010e84, 0x09382248,
+	0x0ae18089, 0x0aa20009, 0x0aa1c049, 0x06800089, 0x0c780140,
+	0x06800049, 0x09361208, 0x08010e81, 0x02009209, 0x07c00149,
+	0x07800a48, 0x0aa14008, 0x07800a88, 0x0aa0c008, 0x06800048,
+	0x07c00b48, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c02049,
+	0x0aa2c009, 0x06410c08, 0x08010e83, 0x093a3248, 0x07c02089,
+	0x0c022440, 0x00000000, 0x0c022540, 0x00000000, 0x0c7914c0,
+	0x0800c0ff, 0x06410c08, 0x08010e83, 0x093a1248, 0x07c00209,
+	0x093c1248, 0x07c001c9, 0x093e1248, 0x07c00189, 0x06411008,
+	0x05001249, 0x07c00f89, 0x09421209, 0x06011008, 0x06414f08,
+	0x095e1209, 0x09761209, 0x05001289, 0x0968120a, 0x06014f08,
+	0x0aa0c049, 0x0c78f380, 0x00000000, 0x06800008, 0x0c01fd40,
+	0x07c00b48, 0x06410c08, 0x08010e88, 0x08010e90, 0x06a0d089,
+	0x06c01249, 0x09118208, 0x0a803248, 0x0c780000, 0x00000000,
+	0x07800188, 0x0aa28008, 0x07800148, 0x0a620008, 0x06800209,
+	0x07c00249, 0x06800049, 0x07c00289, 0x06800049, 0x0c780600,
+	0x00000000, 0x0ba20088, 0x06800209, 0x06410c08, 0x08010e81,
+	0x093e1208, 0x0aa0c008, 0x06800289, 0x06800309, 0x07c00249,
+	0x06410c08, 0x08010e83, 0x093a3248, 0x07c00289, 0x0a60c1c9,
+	0x0c780000, 0x00000000, 0x06410c08, 0x08010e81, 0x07800149,
+	0x0a20c049, 0x0c780000, 0x00000000, 0x07800188, 0x0aa14008,
+	0x06410c08, 0x08010e88, 0x09308248, 0x07c01009, 0x06410c08,
+	0x08010e90, 0x09210248, 0x04001249, 0x07c002c9, 0x06410c08,
+	0x08010e90, 0x09210208, 0x04001208, 0x07c00308, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0aa24009, 0x00000000, 0x06410c08,
+	0x08010e90, 0x09210248, 0x04001249, 0x08010e90, 0x09010208,
+	0x04001208, 0x07800208, 0x06800009, 0x0a618008, 0x0680004a,
+	0x06410c08, 0x08010e82, 0x093e1248, 0x093c1288, 0x07c00549,
+	0x07c0058a, 0x06410c08, 0x08010e82, 0x093c2248, 0x07c005c9,
+	0x06410c08, 0x08010e8a, 0x068001ef, 0x0c020a80, 0x04000c08,
+	0x09346248, 0x07c00649, 0x092e3248, 0x07c00689, 0x092c1248,
+	0x07c006c9, 0x0aa14009, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0a608009, 0x0c7810c0, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0aa20009, 0x09301288, 0x08010e87, 0x0aa1000a, 0x09326248,
+	0x0680000a, 0x0240924a, 0x07c00709, 0x06410c08, 0x08010e81,
 	0x093e1248, 0x0aa20009, 0x09301288, 0x08010e87, 0x0aa1000a,
-	0x09326248, 0x0680000a, 0x0240924a, 0x07c00709, 0x06410c08,
+	0x09326248, 0x0680000a, 0x0240924a, 0x07c00749, 0x06410c08,
 	0x08010e81, 0x093e1248, 0x0aa20009, 0x09301288, 0x08010e87,
-	0x0aa1000a, 0x09326248, 0x0680000a, 0x0240924a, 0x07c00749,
+	0x0aa1000a, 0x09326248, 0x0680000a, 0x0240924a, 0x07c00789,
 	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa20009, 0x09301288,
 	0x08010e87, 0x0aa1000a, 0x09326248, 0x0680000a, 0x0240924a,
-	0x07c00789, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa20009,
+	0x07c007c9, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa20009,
 	0x09301288, 0x08010e87, 0x0aa1000a, 0x09326248, 0x0680000a,
-	0x0240924a, 0x07c007c9, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0240924a, 0x07c00809, 0x06410c08, 0x08010e81, 0x093e1248,
 	0x0aa20009, 0x09301288, 0x08010e87, 0x0aa1000a, 0x09326248,
-	0x0680000a, 0x0240924a, 0x07c00809, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x0aa20009, 0x09301288, 0x08010e87, 0x0aa1000a,
-	0x09326248, 0x0680000a, 0x0240924a, 0x07c00849, 0x06410c08,
-	0x08010e88, 0x09308248, 0x07c00889, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x0aa1c009, 0x09341288, 0x08010e85, 0x0aa1000a,
-	0x09364248, 0x0680000a, 0x0240924a, 0x07c00989, 0x07800888,
-	0x02009209, 0x07c008c9, 0x09508248, 0x06c00009, 0x06014609,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa1c009, 0x09341288,
-	0x08010e85, 0x0aa1000a, 0x09364248, 0x0680000a, 0x0240924a,
-	0x07c009c9, 0x07800888, 0x02009209, 0x07c00909, 0x06410c08,
+	0x0680000a, 0x0240924a, 0x07c00849, 0x06410c08, 0x08010e88,
+	0x09308248, 0x07c00889, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0aa1c009, 0x09341288, 0x08010e85, 0x0aa1000a, 0x09364248,
+	0x0680000a, 0x0240924a, 0x07c00989, 0x07800888, 0x02009209,
+	0x07c008c9, 0x09508248, 0x06c00009, 0x06014609, 0x06410c08,
 	0x08010e81, 0x093e1248, 0x0aa1c009, 0x09341288, 0x08010e85,
-	0x0aa1000a, 0x09364248, 0x0680000a, 0x0240924a, 0x07c00a09,
-	0x07800888, 0x02009209, 0x07c00949, 0x07800908, 0x09508209,
-	0x06c00048, 0x06014608, 0x06800089, 0x07800888, 0x0a624008,
-	0x07800988, 0x0a61c008, 0x078009c8, 0x0a614008, 0x07800a08,
-	0x0a60c008, 0x00000000, 0x068000c9, 0x06414f08, 0x096a2209,
-	0x06014f08, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009,
-	0x07c00a49, 0x06800008, 0x0c0124c0, 0x07c00ac8, 0x06414f08,
-	0x07800a49, 0x096e1209, 0x07800a89, 0x09701209, 0x07800ac9,
-	0x09721209, 0x07800b09, 0x09741209, 0x06014f08, 0x0c01c300,
-	0x00000000, 0x0c01c400, 0x00000000, 0x0640c008, 0x0a610188,
-	0x00000000, 0x0c78cb40, 0x0800c0ff, 0x0c01ab40, 0x00000000,
-	0x06800048, 0x07800409, 0x0680100a, 0x0340b20a, 0x0ac0324b,
-	0x0c7fff80, 0x04001208, 0x04401208, 0x07c00048, 0x06800048,
-	0x07800409, 0x0380b209, 0x0ba0c10b, 0x0c7fff80, 0x04001208,
-	0x04401208, 0x07c00088, 0x0780004a, 0x07800089, 0x0b40724a,
-	0x06410c08, 0x08010e81, 0x093e1208, 0x0aa0c008, 0x0c7ffec0,
-	0x0400128a, 0x07c00bca, 0x06800048, 0x03408288, 0x04401208,
-	0x07c00c48, 0x06410c08, 0x08010e81, 0x093e1288, 0x0aa1400a,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0200a24a, 0x07c00c0a,
-	0x06800048, 0x03408288, 0x04401208, 0x07c00c88, 0x06410c08,
-	0x08010e90, 0x09210248, 0x06812008, 0x06010e08, 0x08010e00,
-	0x05403249, 0x098097c9, 0x09809749, 0x06013a09, 0x07800188,
-	0x0aa14008, 0x07800208, 0x0a60c008, 0x07800fc8, 0x0a60c0c8,
-	0x06800008, 0x07c00608, 0x07800fc8, 0x0aa18088, 0x06800009,
-	0x07800609, 0x078005c8, 0x03809209, 0x04801249, 0x0641100a,
-	0x0a610009, 0x0980a3ca, 0x0c7809c0, 0x00000000, 0x0601100a,
-	0x06414d09, 0x093e1249, 0x0a6f8009, 0x00000000, 0x0640c308,
-	0x09108208, 0x0aafbf48, 0x00000000, 0x06410108, 0x09808348,
-	0x06010108, 0x06410108, 0x09021208, 0x0a6f8008, 0x00000000,
-	0x06af0008, 0x06ec09c8, 0x06014d08, 0x0640c908, 0x078005c9,
-	0x0540c249, 0x02008248, 0x06013408, 0x08013501, 0x06413508,
-	0x090e1248, 0x0a6f8009, 0x09308248, 0x0a6f0009, 0x00000000,
-	0x08013500, 0x08014d00, 0x06410108, 0x09c08348, 0x0c780b80,
-	0x06010108, 0x06807fc8, 0x09449288, 0x0601100a, 0x06800049,
-	0x078005c8, 0x03409209, 0x07800608, 0x02c08248, 0x07c00608,
-	0x06411009, 0x0904a249, 0x0a6f8009, 0x00000000, 0x06414d09,
-	0x093e1249, 0x0a6f8009, 0x00000000, 0x06410108, 0x09808348,
-	0x06010108, 0x06410108, 0x09021208, 0x0a6f8008, 0x00000000,
-	0x06af0008, 0x06ec05c8, 0x06014d08, 0x0640c908, 0x078005c9,
-	0x0540c249, 0x02008248, 0x06013408, 0x08013503, 0x06413508,
-	0x090e1248, 0x0a6f8009, 0x09308248, 0x0a6f0009, 0x00000000,
-	0x08013500, 0x08014d00, 0x06410108, 0x09c08348, 0x06010108,
-	0x06411009, 0x091e1249, 0x0a6f8009, 0x00000000, 0x06a00208,
-	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
-	0x0aa08009, 0x0c780000, 0x078008c8, 0x0a624008, 0x07800888,
-	0x0a61c008, 0x07800908, 0x0a614008, 0x07800948, 0x0a60c008,
-	0x0c780400, 0x0680000a, 0x06a00608, 0x06014108, 0x06414108,
-	0x09061248, 0x0a6f8009, 0x09202288, 0x0a6200ca, 0x06a00208,
-	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
-	0x0200a24a, 0x07c00f4a, 0x06414f08, 0x0958320a, 0x06014f08,
-	0x0a62010a, 0x06bf0248, 0x06c002c8, 0x06014108, 0x06414108,
-	0x09061248, 0x0a6f8009, 0x00000000, 0x0680000a, 0x06a00208,
-	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
-	0x0aa24009, 0x06bf0648, 0x06c062c8, 0x097c220a, 0x06014108,
-	0x06414108, 0x09061248, 0x0a6d4009, 0x00000000, 0x07800f48,
-	0x0b40420a, 0x0babc0ca, 0x0400128a, 0x00000000, 0x06bf0a48,
-	0x06c00088, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
-	0x00000000, 0x07800f88, 0x0aa08008, 0x0c781ac0, 0x06bf0e48,
-	0x06c00508, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
-	0x00000000, 0x078010c8, 0x0a620108, 0x06bf1248, 0x06c001c8,
+	0x0aa1000a, 0x09364248, 0x0680000a, 0x0240924a, 0x07c009c9,
+	0x07800888, 0x02009209, 0x07c00909, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0aa1c009, 0x09341288, 0x08010e85, 0x0aa1000a,
+	0x09364248, 0x0680000a, 0x0240924a, 0x07c00a09, 0x07800888,
+	0x02009209, 0x07c00949, 0x07800908, 0x09508209, 0x06c00048,
+	0x06014608, 0x06800089, 0x07800888, 0x0a624008, 0x07800988,
+	0x0a61c008, 0x078009c8, 0x0a614008, 0x07800a08, 0x0a60c008,
+	0x00000000, 0x068000c9, 0x06414f08, 0x096a2209, 0x06014f08,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009, 0x07c00a49,
+	0x06800008, 0x0c013a00, 0x07c00ac8, 0x06414f08, 0x07800a49,
+	0x096e1209, 0x07800a89, 0x09701209, 0x07800ac9, 0x09721209,
+	0x07800b09, 0x09741209, 0x06014f08, 0x0c01dd80, 0x00000000,
+	0x0c01de80, 0x00000000, 0x0640c008, 0x0a610188, 0x00000000,
+	0x0c78cd40, 0x0800c0ff, 0x0c01c140, 0x00000000, 0x06800048,
+	0x07800409, 0x0680100a, 0x0340b20a, 0x0ac0324b, 0x0c7fff80,
+	0x04001208, 0x04401208, 0x07c00048, 0x06800048, 0x07800409,
+	0x0380b209, 0x0ba0c10b, 0x0c7fff80, 0x04001208, 0x04401208,
+	0x07c00088, 0x0780004a, 0x07800089, 0x0b40724a, 0x06410c08,
+	0x08010e81, 0x093e1208, 0x0aa0c008, 0x0c7ffec0, 0x0400128a,
+	0x07c00bca, 0x06800048, 0x03408288, 0x04401208, 0x07c00c48,
+	0x06410c08, 0x08010e81, 0x093e1288, 0x0aa1400a, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0200a24a, 0x07c00c0a, 0x06800048,
+	0x03408288, 0x04401208, 0x07c00c88, 0x06410c08, 0x08010e90,
+	0x09210248, 0x06812008, 0x06010e08, 0x08010e00, 0x05403249,
+	0x098097c9, 0x09809749, 0x06013a09, 0x07800188, 0x0aa14008,
+	0x07800208, 0x0a60c008, 0x07800fc8, 0x0a60c0c8, 0x06800008,
+	0x07c00608, 0x07800fc8, 0x0aa18088, 0x06800009, 0x07800609,
+	0x078005c8, 0x03809209, 0x04801249, 0x0641100a, 0x068014af,
+	0x0c01ccc0, 0x04000c0a, 0x0a610009, 0x0980a3ca, 0x0c780b40,
+	0x00000000, 0x0601100a, 0x06414d09, 0x068014ef, 0x0c01ca80,
+	0x04000c09, 0x093e1249, 0x0a6ec009, 0x00000000, 0x0680146f,
+	0x0c01c900, 0x04000c08, 0x0640c308, 0x09108208, 0x0aafbf48,
+	0x00000000, 0x06410108, 0x09808348, 0x06010108, 0x06410108,
+	0x09021208, 0x0a6f8008, 0x00000000, 0x06af0008, 0x06ec09c8,
+	0x06014d08, 0x0640c908, 0x078005c9, 0x0540c249, 0x02008248,
+	0x06013408, 0x08013501, 0x06413508, 0x090e1248, 0x0a6f8009,
+	0x09308248, 0x0a6f0009, 0x00000000, 0x08013500, 0x08014d00,
+	0x06410108, 0x09c08348, 0x0c780b80, 0x06010108, 0x06807fc8,
+	0x09449288, 0x0601100a, 0x06800049, 0x078005c8, 0x03409209,
+	0x07800608, 0x02c08248, 0x07c00608, 0x06411009, 0x0904a249,
+	0x0a6f8009, 0x00000000, 0x06414d09, 0x093e1249, 0x0a6f8009,
+	0x00000000, 0x06410108, 0x09808348, 0x06010108, 0x06410108,
+	0x09021208, 0x0a6f8008, 0x00000000, 0x06af0008, 0x06ec05c8,
+	0x06014d08, 0x0640c908, 0x078005c9, 0x0540c249, 0x02008248,
+	0x06013408, 0x08013503, 0x06413508, 0x090e1248, 0x0a6f8009,
+	0x09308248, 0x0a6f0009, 0x00000000, 0x08013500, 0x08014d00,
+	0x06410108, 0x09c08348, 0x06010108, 0x06411009, 0x091e1249,
+	0x0a6f8009, 0x00000000, 0x06a00208, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x09201248, 0x0aa08009, 0x0c780000,
+	0x078008c8, 0x0a624008, 0x07800888, 0x0a61c008, 0x07800908,
+	0x0a614008, 0x07800948, 0x0a60c008, 0x0c780400, 0x0680000a,
+	0x06a00608, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
+	0x09202288, 0x0a6200ca, 0x06a00208, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x09201248, 0x0200a24a, 0x07c00f4a,
+	0x06414f08, 0x0958320a, 0x06014f08, 0x0a62010a, 0x06bf0248,
+	0x06c002c8, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
+	0x00000000, 0x0680000a, 0x06a00208, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x09201248, 0x0aa24009, 0x06bf0648,
+	0x06c062c8, 0x097c220a, 0x06014108, 0x06414108, 0x09061248,
+	0x0a6d4009, 0x00000000, 0x07800f48, 0x0b40420a, 0x0babc0ca,
+	0x0400128a, 0x00000000, 0x06bf0a48, 0x06c00088, 0x06014108,
+	0x06414108, 0x09061248, 0x0a6f8009, 0x00000000, 0x07800f88,
+	0x0aa08008, 0x0c781ac0, 0x06bf0e48, 0x06c00508, 0x06014108,
+	0x06414108, 0x09061248, 0x0a6f8009, 0x00000000, 0x078010c8,
+	0x0a620108, 0x06bf1248, 0x06c001c8, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x00000000, 0x06bf1648, 0x06c000c8,
 	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
-	0x06bf1648, 0x06c000c8, 0x06014108, 0x06414108, 0x09061248,
-	0x0a6f8009, 0x00000000, 0x06414f0a, 0x07801048, 0x09001248,
-	0x09501289, 0x09081248, 0x094e1289, 0x09101248, 0x094c1289,
-	0x06014f0a, 0x09081288, 0x0a40424a, 0x09001288, 0x0a81324a,
-	0x0680000a, 0x06a00208, 0x06014108, 0x06414108, 0x09061248,
-	0x0a6f8009, 0x09201248, 0x0aa2c009, 0x0680000a, 0x06a00208,
+	0x06414f0a, 0x07801048, 0x09001248, 0x09501289, 0x09081248,
+	0x094e1289, 0x09101248, 0x094c1289, 0x06014f0a, 0x09081288,
+	0x0a40424a, 0x09001288, 0x0a81324a, 0x0680000a, 0x06a00208,
 	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
-	0x0aa0c009, 0x0680004a, 0x0680008a, 0x07c0110a, 0x06414f08,
-	0x0954220a, 0x06014f08, 0x0a62008a, 0x06bf1a48, 0x06c00108,
-	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
-	0x0aa2004a, 0x06bf2248, 0x06c00248, 0x06014108, 0x06414108,
-	0x09061248, 0x0a6f8009, 0x00000000, 0x0aa2000a, 0x06bf1e48,
-	0x06c00108, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
-	0x00000000, 0x06bf2648, 0x06c008c8, 0x06014108, 0x06414108,
-	0x09061248, 0x0a6f8009, 0x00000000, 0x06bf2a48, 0x06c00bc8,
-	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
-	0x06bf2e48, 0x07801089, 0x0a60c009, 0x06c01108, 0x06c01008,
-	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x00000000,
-	0x06413a08, 0x09013208, 0x0aa0c008, 0x00000000, 0x08010e88,
-	0x06800008, 0x07c00cc8, 0x07c00d08, 0x08013a00, 0x08011c00,
-	0x08011e00, 0x08011d00, 0x08011f00, 0x08014700, 0x08014800,
-	0x08014200, 0x08014300, 0x08014400, 0x08014500, 0x07800cc8,
-	0x07800409, 0x0e000248, 0x068001df, 0x00000000, 0x07800bc9,
-	0x0f000200, 0x03808248, 0x07c00d48, 0x07800cc8, 0x04001208,
-	0x07800409, 0x0e000248, 0x0680000a, 0x07c00b8a, 0x07800bc9,
-	0x0f000200, 0x03808248, 0x07c00dc8, 0x07800d49, 0x02408248,
-	0x07c00e48, 0x07800d08, 0x07800449, 0x0e000248, 0x00000000,
-	0x00000000, 0x07800c09, 0x0f000200, 0x03808248, 0x0aa10008,
-	0x07c00d88, 0x0c00ed40, 0x09c1f05f, 0x07800d08, 0x04001208,
+	0x0aa2c009, 0x0680000a, 0x06a00208, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x09201248, 0x0aa0c009, 0x0680004a,
+	0x0680008a, 0x07c0110a, 0x06414f08, 0x0954220a, 0x06014f08,
+	0x0a62008a, 0x06bf1a48, 0x06c00108, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x00000000, 0x0aa2004a, 0x06bf2248,
+	0x06c00248, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
+	0x00000000, 0x0aa2000a, 0x06bf1e48, 0x06c00108, 0x06014108,
+	0x06414108, 0x09061248, 0x0a6f8009, 0x00000000, 0x06bf2648,
+	0x06c008c8, 0x06014108, 0x06414108, 0x09061248, 0x0a6f8009,
+	0x00000000, 0x06bf2a48, 0x06c00bc8, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x00000000, 0x06bf2e48, 0x07801089,
+	0x0a60c009, 0x06c01108, 0x06c01008, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x00000000, 0x06413a08, 0x09013208,
+	0x0aa0c008, 0x00000000, 0x08010e88, 0x06800008, 0x07c00cc8,
+	0x07c00d08, 0x08013a00, 0x08011c00, 0x08011e00, 0x08011d00,
+	0x08011f00, 0x08014700, 0x08014800, 0x08014200, 0x08014300,
+	0x08014400, 0x08014500, 0x07800cc8, 0x07800409, 0x0e000248,
+	0x068001df, 0x00000000, 0x07800bc9, 0x0f000200, 0x03808248,
+	0x07c00d48, 0x07800cc8, 0x04001208, 0x07800409, 0x0e000248,
+	0x0680000a, 0x07c00b8a, 0x07800bc9, 0x0f000200, 0x03808248,
+	0x07c00dc8, 0x07800d49, 0x02408248, 0x07c00e48, 0x07800d08,
 	0x07800449, 0x0e000248, 0x00000000, 0x00000000, 0x07800c09,
-	0x0f000200, 0x03808248, 0x07c00e08, 0x07800d89, 0x02408248,
-	0x07c00e88, 0x07800d48, 0x04001208, 0x07800dc9, 0x0b807248,
-	0x07800d88, 0x04001208, 0x07800e09, 0x0b803248, 0x00000000,
-	0x0981f0df, 0x07800d88, 0x07800409, 0x0e000248, 0x07c00f08,
-	0x07c01348, 0x07800d49, 0x07c00ec9, 0x07c01309, 0x0f000200,
-	0x02008248, 0x07c00508, 0x05404248, 0x05403208, 0x02008248,
-	0x07c01208, 0x07c01248, 0x06800008, 0x07c01288, 0x07c012c8,
-	0x06812008, 0x06010e08, 0x08010e00, 0x07800cc8, 0x0a60c008,
-	0x07800d08, 0x0aa20008, 0x0641390a, 0x0aa1800a, 0x00000000,
-	0x08010e88, 0x00000000, 0x0c7ffec0, 0x00000000, 0x07800cc8,
-	0x07800c49, 0x0b804248, 0x07800d08, 0x07800c89, 0x0b40d248,
-	0x06410c08, 0x08010e90, 0x09210248, 0x06410c08, 0x08010e90,
-	0x09210288, 0x09610289, 0x0601390a, 0x0540324a, 0x098097c9,
-	0x09809789, 0x06013a09, 0x07800e48, 0x0aa0c008, 0x07800e88,
-	0x0a630008, 0x07800cc8, 0x04001208, 0x07800c49, 0x0b082248,
-	0x07c00cc8, 0x06800008, 0x07c00cc8, 0x07800d08, 0x04001208,
-	0x0c7fdf00, 0x07c00d08, 0x07800a48, 0x0aa0c008, 0x0c00df00,
-	0x00000000, 0x06411009, 0x098093c9, 0x06011009, 0x06470109,
-	0x09809209, 0x06070109, 0x06470b08, 0x07800249, 0x04408249,
-	0x09402209, 0x09482209, 0x09502209, 0x06070b08, 0x078002c8,
-	0x07800309, 0x09610209, 0x06020508, 0x07800d48, 0x07800d89,
-	0x09610209, 0x06020708, 0x06060708, 0x07800e48, 0x07800e89,
-	0x09610209, 0x06020808, 0x06060808, 0x07800408, 0x04401208,
-	0x07800449, 0x04401249, 0x09610209, 0x06020608, 0x06420109,
-	0x07800188, 0x0aa0c008, 0x06800388, 0x06800308, 0x09403248,
-	0x078004c8, 0x04003208, 0x09604248, 0x07800488, 0x04003208,
-	0x09684248, 0x06020109, 0x06424c09, 0x09809009, 0x09809049,
-	0x09809089, 0x07801088, 0x05001208, 0x09501248, 0x07801048,
-	0x09001288, 0x095c124a, 0x09081288, 0x095a124a, 0x09101288,
-	0x0958124a, 0x06024c09, 0x06420408, 0x093e1208, 0x0a6f8008,
-	0x00000000, 0x078002c9, 0x0780030a, 0x0960f24a, 0x06040209,
-	0x07800409, 0x0780044a, 0x0960c24a, 0x06040309, 0x08040400,
-	0x07800c48, 0x0a618008, 0x06800049, 0x07800c88, 0x0a60c008,
-	0x06800049, 0x06800009, 0x06040509, 0x07800e48, 0x07800e89,
-	0x09610209, 0x06040308, 0x07800d48, 0x07800d89, 0x09610209,
-	0x06040408, 0x06450d08, 0x09001248, 0x0a6f8009, 0x00000000,
-	0x08040640, 0x06414f0a, 0x07800148, 0x0aa10008, 0x06800009,
-	0x06800289, 0x0980a24a, 0x06040c09, 0x06014f0a, 0x06440009,
-	0x09809009, 0x06040009, 0x09c09009, 0x06040009, 0x06800048,
-	0x09482248, 0x09809049, 0x06040009, 0x07800249, 0x04408249,
-	0x06450108, 0x09602209, 0x09642209, 0x06050108, 0x078002c8,
-	0x07800309, 0x09610209, 0x06050208, 0x07800bc8, 0x06050c08,
-	0x07800d48, 0x07800d89, 0x0960a209, 0x07800cc9, 0x09584209,
-	0x07800d09, 0x09784209, 0x06050608, 0x07800d4a, 0x07800e48,
-	0x02008288, 0x04401208, 0x07800d8a, 0x07800e89, 0x02009289,
-	0x04401249, 0x0960a209, 0x06050708, 0x07800d48, 0x07800d89,
-	0x0960a209, 0x06050808, 0x078002c8, 0x07800309, 0x09610209,
-	0x06060508, 0x07800408, 0x04401208, 0x07800449, 0x04401249,
-	0x09610209, 0x06060608, 0x06460109, 0x09809709, 0x06060109,
-	0x07800ec9, 0x07800f08, 0x0958c248, 0x0978425f, 0x06011609,
-	0x06411009, 0x091e1249, 0x0a6f8009, 0x00000000, 0x06a00208,
-	0x06014108, 0x06414108, 0x09061248, 0x0a6f8009, 0x09201248,
-	0x0aa08009, 0x0c780000, 0x07800508, 0x09808788, 0x098087c8,
-	0x06012408, 0x07800d48, 0x0a644008, 0x07800d88, 0x0a63c008,
-	0x00000000, 0x06400408, 0x09808688, 0x06000408, 0x09c08688,
-	0x06000408, 0x06814008, 0x07c01148, 0x06800008, 0x07c01188,
-	0x0c00eec0, 0x00000000, 0x0c00f580, 0x00000000, 0x06800048,
-	0x0541f208, 0x06020408, 0x06060408, 0x08040701, 0x06450808,
-	0x098087c8, 0x06050808, 0x06414008, 0x09808048, 0x06014008,
-	0x06414008, 0x0c783580, 0x00000000, 0x078001c8, 0x0a614008,
-	0x06800009, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c00f89,
-	0x0a60c009, 0x0780020a, 0x0aa0c00a, 0x0c00f400, 0x00000000,
-	0x06414f08, 0x095e1209, 0x05001289, 0x0968120a, 0x06014f08,
-	0x07800208, 0x0a614008, 0x06800009, 0x06410c08, 0x08010e82,
-	0x093c2248, 0x07c00fc9, 0x07800f88, 0x0aa08008, 0x0c7f0940,
-	0x06410c08, 0x08010e88, 0x09308248, 0x07c01009, 0x06410c08,
-	0x08010e8c, 0x0928c248, 0x07c01049, 0x09101209, 0x09081289,
-	0x0a806288, 0x068009ca, 0x09001289, 0x0a803288, 0x06800d8a,
-	0x06800e8a, 0x06414f09, 0x0940624a, 0x06014f09, 0x0680008a,
-	0x0680000b, 0x06410c08, 0x08010e81, 0x093e1248, 0x03408289,
-	0x02c0b20b, 0x0a63c009, 0x07c023cb, 0x0b20c00a, 0x0c7ffe00,
-	0x0440128a, 0x06410c08, 0x08010e90, 0x09210248, 0x04001249,
-	0x06410c08, 0x08010e90, 0x09210208, 0x04001208, 0x07c00308,
-	0x07c002c9, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c021c9,
-	0x0aa2c009, 0x00000000, 0x06410c08, 0x08010e90, 0x09210248,
-	0x04001249, 0x07c02309, 0x08010e90, 0x09010208, 0x04001208,
-	0x07c02348, 0x06410c08, 0x08010e81, 0x093e1248, 0x07c01089,
-	0x06414f08, 0x09661209, 0x06014f08, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x0a61c009, 0x0680010a, 0x08010e82, 0x093a2248,
-	0x0b60c089, 0x04000289, 0x0500128a, 0x07c010ca, 0x06414f08,
-	0x0960320a, 0x06014f08, 0x0c7f0800, 0x00000000, 0x0a60c188,
-	0x00000000, 0x08010e90, 0x0c780080, 0x0800c0ff, 0x00800000,
-	0x0c00d580, 0x00000000, 0x07800008, 0x0c7ecf00, 0x06030408,
-	0x06806008, 0x06010e08, 0x06410f08, 0x0befc0c8, 0x09118208,
-	0x0cc00000, 0x07400248, 0x0680e008, 0x06010e08, 0x06410f08,
-	0x0befc0c8, 0x09118208, 0x0cc00000, 0x07400248, 0x06410509,
-	0x06bfff89, 0x06030409, 0x00400000, 0x0be0c108, 0x0c7ff9c0,
-	0x00000000, 0x08012104, 0x080150c0, 0x06411c26, 0x06411d27,
-	0x06414728, 0x06414229, 0x07800409, 0x0ae1c049, 0x0641432a,
-	0x04000866, 0x040008a7, 0x040008e8, 0x04000929, 0x0400096a,
-	0x06014224, 0x06014325, 0x06011c21, 0x06011d22, 0x0a21c91f,
-	0x06014723, 0x08011e00, 0x08011f00, 0x08014800, 0x08014400,
-	0x08014500, 0x0be0e026, 0x0c7809c0, 0x00000000, 0x07800a48,
-	0x0aa0c008, 0x0c00aac0, 0x00000000, 0x068001df, 0x0978479f,
-	0x06420409, 0x093e1209, 0x0a6f8008, 0x09c09749, 0x06020409,
-	0x07800cc8, 0x04001208, 0x07800c49, 0x0b009248, 0x07c00cc8,
-	0x06800008, 0x07c00cc8, 0x07800d08, 0x04001208, 0x07800c89,
-	0x0ac08248, 0x07c00d08, 0x0c006940, 0x00000000, 0x0c003e40,
-	0x00000000, 0x0c7f7840, 0x00000000, 0x07800549, 0x0aa0c009,
-	0x0c00ac40, 0x00000000, 0x0c003c40, 0x00000000, 0x0c7fe980,
-	0x0800c0ff, 0x0601161e, 0x07800508, 0x09808788, 0x098087c8,
-	0x06012408, 0x06414009, 0x09809049, 0x06014009, 0x06414009,
-	0x09c1f09f, 0x07800508, 0x04001208, 0x07c00508, 0x07800b88,
-	0x04001208, 0x07c00b88, 0x0a21409f, 0x07800e49, 0x0b803248,
-	0x00000000, 0x09c1f05f, 0x07800ec8, 0x04001208, 0x07800dc9,
-	0x0b811248, 0x07c00ec8, 0x07800d48, 0x07c00ec8, 0x0981f09f,
-	0x07800508, 0x07800409, 0x02008248, 0x07800e49, 0x02408248,
-	0x07c00508, 0x07800f08, 0x04001208, 0x07800e09, 0x0b803248,
-	0x07c00f08, 0x0981f0df, 0x07800f08, 0x04001208, 0x07800e09,
-	0x0b80f248, 0x07800ec8, 0x04001208, 0x07800dc9, 0x0b80b248,
-	0x07800409, 0x0b807248, 0x07800f08, 0x04001208, 0x07800449,
-	0x0b803248, 0x0c7800c0, 0x09c1f11f, 0x0981f11f, 0x0981f0df,
-	0x07800ede, 0x07800f08, 0x0958c788, 0x0978479f, 0x07800b88,
-	0x0ae08048, 0x0c780a00, 0x07800ec9, 0x07800d4a, 0x0400228a,
-	0x0b407289, 0x04402209, 0x0440128a, 0x07800dc8, 0x0b403289,
-	0x04401208, 0x04401208, 0x05403248, 0x02009248, 0x02008248,
-	0x06806009, 0x02009209, 0x07400266, 0x09210226, 0x04001249,
-	0x07400248, 0x04001249, 0x07400269, 0x09210229, 0x04001249,
-	0x07400248, 0x04001249, 0x0740026a, 0x0921022a, 0x04001249,
-	0x07400248, 0x04001249, 0x07400267, 0x09210227, 0x04001249,
-	0x07400248, 0x04001249, 0x07400268, 0x09210228, 0x04001249,
-	0x07400248, 0x0a21c09f, 0x06800024, 0x06800025, 0x06800021,
-	0x06800022, 0x0c780800, 0x06800023, 0x07800ec8, 0x05403248,
-	0x02009248, 0x02008248, 0x06806009, 0x02009209, 0x07000261,
-	0x04001249, 0x07000248, 0x09610848, 0x04001249, 0x07000264,
-	0x04001249, 0x07000248, 0x09610908, 0x04001249, 0x07000265,
-	0x04001249, 0x07000248, 0x09610948, 0x04001249, 0x07000262,
-	0x04001249, 0x07000248, 0x09610888, 0x04001249, 0x07000263,
-	0x04001249, 0x07000248, 0x096108c8, 0x07800a48, 0x0aa0c008,
-	0x0c005cc0, 0x00000000, 0x0c7fc480, 0x00000000, 0x06412106,
-	0x090c1186, 0x0a6f8006, 0x0c7e9340, 0x00000000, 0x06804009,
+	0x0f000200, 0x03808248, 0x0aa10008, 0x07c00d88, 0x0c010040,
+	0x09c1f05f, 0x07800d08, 0x04001208, 0x07800449, 0x0e000248,
+	0x00000000, 0x00000000, 0x07800c09, 0x0f000200, 0x03808248,
+	0x07c00e08, 0x07800d89, 0x02408248, 0x07c00e88, 0x07800d48,
+	0x04001208, 0x07800dc9, 0x0b807248, 0x07800d88, 0x04001208,
+	0x07800e09, 0x0b803248, 0x00000000, 0x0981f0df, 0x07800d88,
+	0x07800409, 0x0e000248, 0x07c00f08, 0x07c01348, 0x07800d49,
+	0x07c00ec9, 0x07c01309, 0x0f000200, 0x02008248, 0x07c00508,
+	0x05404248, 0x05403208, 0x02008248, 0x07c01208, 0x07c01248,
+	0x06800008, 0x07c01288, 0x07c012c8, 0x06812008, 0x06010e08,
+	0x08010e00, 0x07800cc8, 0x0a60c008, 0x07800d08, 0x0aa20008,
+	0x0641390a, 0x0aa1800a, 0x00000000, 0x08010e88, 0x00000000,
+	0x0c7ffec0, 0x00000000, 0x07800cc8, 0x07800c49, 0x0b804248,
+	0x07800d08, 0x07800c89, 0x0b40d248, 0x06410c08, 0x08010e90,
+	0x09210248, 0x06410c08, 0x08010e90, 0x09210288, 0x09610289,
+	0x0601390a, 0x0540324a, 0x098097c9, 0x09809789, 0x06013a09,
+	0x07800e48, 0x0aa0c008, 0x07800e88, 0x0a630008, 0x07800cc8,
+	0x04001208, 0x07800c49, 0x0b082248, 0x07c00cc8, 0x06800008,
+	0x07c00cc8, 0x07800d08, 0x04001208, 0x0c7fdf00, 0x07c00d08,
+	0x07800a48, 0x0aa0c008, 0x0c00f200, 0x00000000, 0x06411009,
+	0x098093c9, 0x06011009, 0x06470109, 0x09809209, 0x06070109,
+	0x06470b08, 0x07800249, 0x04408249, 0x09402209, 0x09482209,
+	0x09502209, 0x06070b08, 0x078002c8, 0x07800309, 0x09610209,
+	0x06020508, 0x07800d48, 0x07800d89, 0x09610209, 0x06020708,
+	0x06060708, 0x07800e48, 0x07800e89, 0x09610209, 0x06020808,
+	0x06060808, 0x07800408, 0x04401208, 0x07800449, 0x04401249,
+	0x09610209, 0x06020608, 0x06420109, 0x07800188, 0x0aa0c008,
+	0x06800388, 0x06800308, 0x09403248, 0x078004c8, 0x04003208,
+	0x09604248, 0x07800488, 0x04003208, 0x09684248, 0x06020109,
+	0x06424c09, 0x09809009, 0x09809049, 0x09809089, 0x07801088,
+	0x05001208, 0x09501248, 0x07801048, 0x09001288, 0x095c124a,
+	0x09081288, 0x095a124a, 0x09101288, 0x0958124a, 0x06024c09,
+	0x06420408, 0x093e1208, 0x0a6f8008, 0x00000000, 0x078002c9,
+	0x0780030a, 0x0960f24a, 0x06040209, 0x07800409, 0x0780044a,
+	0x0960c24a, 0x06040309, 0x08040400, 0x07800c48, 0x0a618008,
+	0x06800049, 0x07800c88, 0x0a60c008, 0x06800049, 0x06800009,
+	0x06040509, 0x07800e48, 0x07800e89, 0x09610209, 0x06040308,
+	0x07800d48, 0x07800d89, 0x09610209, 0x06040408, 0x06450d08,
+	0x09001248, 0x0a6f8009, 0x00000000, 0x08040640, 0x06414f0a,
+	0x07800148, 0x0aa10008, 0x06800009, 0x06800289, 0x0980a24a,
+	0x06040c09, 0x06014f0a, 0x06440009, 0x09809009, 0x06040009,
+	0x09c09009, 0x06040009, 0x06800048, 0x09482248, 0x09809049,
+	0x06040009, 0x07800249, 0x04408249, 0x06450108, 0x09602209,
+	0x09642209, 0x06050108, 0x078002c8, 0x07800309, 0x09610209,
+	0x06050208, 0x07800bc8, 0x06050c08, 0x07800d48, 0x07800d89,
+	0x0960a209, 0x07800cc9, 0x09584209, 0x07800d09, 0x09784209,
+	0x06050608, 0x07800d4a, 0x07800e48, 0x02008288, 0x04401208,
+	0x07800d8a, 0x07800e89, 0x02009289, 0x04401249, 0x0960a209,
+	0x06050708, 0x07800d48, 0x07800d89, 0x0960a209, 0x06050808,
+	0x078002c8, 0x07800309, 0x09610209, 0x06060508, 0x07800408,
+	0x04401208, 0x07800449, 0x04401249, 0x09610209, 0x06060608,
+	0x06460109, 0x09809709, 0x06060109, 0x07800ec9, 0x07800f08,
+	0x0958c248, 0x0978425f, 0x06011609, 0x06411009, 0x091e1249,
+	0x0a6f8009, 0x00000000, 0x06a00208, 0x06014108, 0x06414108,
+	0x09061248, 0x0a6f8009, 0x09201248, 0x0aa04009, 0x07800508,
+	0x09808788, 0x098087c8, 0x06012408, 0x07800d48, 0x0a644008,
+	0x07800d88, 0x0a63c008, 0x00000000, 0x06400408, 0x09808688,
+	0x06000408, 0x09c08688, 0x06000408, 0x06814008, 0x07c01148,
+	0x06800008, 0x07c01188, 0x0c0102c0, 0x00000000, 0x0c010980,
+	0x00000000, 0x06800048, 0x0541f208, 0x06020408, 0x06060408,
+	0x08040701, 0x06450808, 0x098087c8, 0x06050808, 0x06414008,
+	0x09808048, 0x06014008, 0x06414008, 0x0c783a80, 0x00000000,
+	0x078001c8, 0x0a614008, 0x06800009, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x07c00f89, 0x0a60c009, 0x0780020a, 0x0aa0c00a,
+	0x0c010800, 0x00000000, 0x06414f08, 0x095e1209, 0x05001289,
+	0x0968120a, 0x06014f08, 0x07800208, 0x0a614008, 0x06800009,
+	0x06410c08, 0x08010e82, 0x093c2248, 0x07c00fc9, 0x07800f88,
+	0x0aa08008, 0x0c7f0680, 0x06410c08, 0x08010e88, 0x09308248,
+	0x07c01009, 0x06410c08, 0x08010e8c, 0x0928c248, 0x07c01049,
+	0x09101209, 0x09081289, 0x0a806288, 0x068009ca, 0x09001289,
+	0x0a803288, 0x06800d8a, 0x06800e8a, 0x06414f09, 0x0940624a,
+	0x06014f09, 0x0680008a, 0x0680000b, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x03408289, 0x02c0b20b, 0x0a63c009, 0x07c023cb,
+	0x0b20c00a, 0x0c7ffe00, 0x0440128a, 0x06410c08, 0x08010e90,
+	0x09210248, 0x04001249, 0x06410c08, 0x08010e90, 0x09210208,
+	0x04001208, 0x07c00308, 0x07c002c9, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x07c021c9, 0x0aa2c009, 0x00000000, 0x06410c08,
+	0x08010e90, 0x09210248, 0x04001249, 0x07c02309, 0x08010e90,
+	0x09010208, 0x04001208, 0x07c02348, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x07c01089, 0x06414f08, 0x09661209, 0x06014f08,
+	0x06410c08, 0x08010e81, 0x093e1248, 0x0a61c009, 0x0680010a,
+	0x08010e82, 0x093a2248, 0x0b60c089, 0x04000289, 0x0500128a,
+	0x07c010ca, 0x06414f08, 0x0960320a, 0x06014f08, 0x0c7f0540,
+	0x00000000, 0x0a60c188, 0x00000000, 0x08010e90, 0x0c780080,
+	0x0800c0ff, 0x00800000, 0x0c00e980, 0x00000000, 0x07800008,
+	0x0c7ec840, 0x06030408, 0x06806008, 0x06010e08, 0x06410f08,
+	0x0befc0c8, 0x09118208, 0x0cc00000, 0x07400248, 0x0680e008,
+	0x06010e08, 0x06410f08, 0x0befc0c8, 0x09118208, 0x0cc00000,
+	0x07400248, 0x06410509, 0x06bfff89, 0x06030409, 0x00400000,
+	0x0be0c108, 0x0c7ff9c0, 0x00000000, 0x08012104, 0x080150c0,
+	0x06411c26, 0x06411d27, 0x06414728, 0x06414229, 0x07800409,
+	0x0ae1c049, 0x0641432a, 0x04000866, 0x040008a7, 0x040008e8,
+	0x04000929, 0x0400096a, 0x06014224, 0x06014325, 0x06011c21,
+	0x06011d22, 0x0a21c91f, 0x06014723, 0x08011e00, 0x08011f00,
+	0x08014800, 0x08014400, 0x08014500, 0x0be0e026, 0x0c780ec0,
+	0x00000000, 0x07800a48, 0x0aa0c008, 0x0c00be00, 0x00000000,
+	0x068001df, 0x0978479f, 0x06420409, 0x093e1209, 0x0a6f8008,
+	0x09c09749, 0x06020409, 0x07800cc8, 0x04001208, 0x07800c49,
+	0x0b009248, 0x07c00cc8, 0x06800008, 0x07c00cc8, 0x07800d08,
+	0x04001208, 0x07800c89, 0x0ac08248, 0x07c00d08, 0x0c007c80,
+	0x00000000, 0x0c005180, 0x00000000, 0x0c7f7880, 0x00000000,
+	0x07800549, 0x0aa0c009, 0x0c00bf80, 0x00000000, 0x0c004f80,
+	0x00000000, 0x0640d708, 0x0aa4c008, 0x00000000, 0x0640d309,
+	0x0aa2c049, 0x07801509, 0x0780154b, 0x0961024b, 0x06410d0b,
+	0x0240b24b, 0x0680802f, 0x0c00f900, 0x04000c0b, 0x0b80720b,
+	0x00000000, 0x0c003d00, 0x00000000, 0x0800c00a, 0x0c7fe500,
+	0x08007401, 0x0c7fe480, 0x0800c0ff, 0x0601161e, 0x07800508,
+	0x09808788, 0x098087c8, 0x06012408, 0x06414009, 0x09809049,
+	0x06014009, 0x06414009, 0x09c1f09f, 0x07800508, 0x04001208,
+	0x07c00508, 0x07800b88, 0x04001208, 0x07c00b88, 0x0a21409f,
+	0x07800e49, 0x0b803248, 0x00000000, 0x09c1f05f, 0x07800ec8,
+	0x04001208, 0x07800dc9, 0x0b811248, 0x07c00ec8, 0x07800d48,
+	0x07c00ec8, 0x0981f09f, 0x07800508, 0x07800409, 0x02008248,
+	0x07800e49, 0x02408248, 0x07c00508, 0x07800f08, 0x04001208,
+	0x07800e09, 0x0b803248, 0x07c00f08, 0x0981f0df, 0x07800f08,
+	0x04001208, 0x07800e09, 0x0b80f248, 0x07800ec8, 0x04001208,
+	0x07800dc9, 0x0b80b248, 0x07800409, 0x0b807248, 0x07800f08,
+	0x04001208, 0x07800449, 0x0b803248, 0x0c7800c0, 0x09c1f11f,
+	0x0981f11f, 0x0981f0df, 0x07800ede, 0x07800f08, 0x0958c788,
+	0x0978479f, 0x07800b88, 0x0ae08048, 0x0c780a00, 0x07800ec9,
+	0x07800d4a, 0x0400228a, 0x0b407289, 0x04402209, 0x0440128a,
+	0x07800dc8, 0x0b403289, 0x04401208, 0x04401208, 0x05403248,
+	0x02009248, 0x02008248, 0x06806009, 0x02009209, 0x07400266,
+	0x09210226, 0x04001249, 0x07400248, 0x04001249, 0x07400269,
+	0x09210229, 0x04001249, 0x07400248, 0x04001249, 0x0740026a,
+	0x0921022a, 0x04001249, 0x07400248, 0x04001249, 0x07400267,
+	0x09210227, 0x04001249, 0x07400248, 0x04001249, 0x07400268,
+	0x09210228, 0x04001249, 0x07400248, 0x0a21c09f, 0x06800024,
+	0x06800025, 0x06800021, 0x06800022, 0x0c780800, 0x06800023,
+	0x07800ec8, 0x05403248, 0x02009248, 0x02008248, 0x06806009,
+	0x02009209, 0x07000261, 0x04001249, 0x07000248, 0x09610848,
+	0x04001249, 0x07000264, 0x04001249, 0x07000248, 0x09610908,
+	0x04001249, 0x07000265, 0x04001249, 0x07000248, 0x09610948,
+	0x04001249, 0x07000262, 0x04001249, 0x07000248, 0x09610888,
+	0x04001249, 0x07000263, 0x04001249, 0x07000248, 0x096108c8,
+	0x07800a48, 0x0aa0c008, 0x0c006b00, 0x00000000, 0x0c7fbf80,
+	0x00000000, 0x06808006, 0x0640d707, 0x0aa2c007, 0x06410607,
+	0x0b003187, 0x0c780200, 0x00000000, 0x0681de2f, 0x0c00cf40,
+	0x04000c07, 0x0800c020, 0x08007401, 0x0c780000, 0x06412106,
+	0x090c1186, 0x0a6c4006, 0x0c7e8440, 0x00000000, 0x06804009,
 	0x06012d09, 0x06800f8a, 0x08012e00, 0x00000000, 0x0d07ff8a,
 	0x00000000, 0x0cc00000, 0x00000000, 0x07800148, 0x07c02008,
 	0x07800188, 0x07c020c8, 0x078001c8, 0x07c02108, 0x07800208,
@@ -807,144 +853,157 @@ const u32  vvp9_mc[] __initconst = {
 	0x07c024c8, 0x078007c8, 0x07c02508, 0x07800808, 0x07c02548,
 	0x07800848, 0x07c02588, 0x07800648, 0x07c025c8, 0x07800688,
 	0x07c02608, 0x07800248, 0x07c02648, 0x07800a48, 0x07c02888,
-	0x07800b08, 0x07c028c8, 0x0640c108, 0x06035108, 0x06802008,
-	0x06035208, 0x06a02008, 0x06035008, 0x06435008, 0x0580f208,
+	0x07800b08, 0x07c028c8, 0x07800288, 0x07c02b08, 0x0640c108,
+	0x06035108, 0x06802008, 0x06035208, 0x06a02008, 0x06035008,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06435308,
+	0x0900c208, 0x0a6f8008, 0x00000000, 0x0cc00000, 0x00000000,
+	0x0640c108, 0x06804009, 0x02008248, 0x06035108, 0x06802008,
+	0x06035208, 0x06a00148, 0x06035008, 0x06435008, 0x0580f208,
 	0x0bef8048, 0x00000000, 0x06435308, 0x0900c208, 0x0a6f8008,
-	0x00000000, 0x0cc00000, 0x00000000, 0x0800cf00, 0x0800c0ff,
-	0x06800009, 0x0680ffca, 0x07000248, 0x09808408, 0x0600cf08,
-	0x00000000, 0x0640cf08, 0x0a6fc008, 0x0b403289, 0x0c7ffe40,
-	0x04001249, 0x0cc00000, 0x00000000, 0x069fffca, 0x06440109,
-	0x0a2fc049, 0x0440128a, 0x06460309, 0x093e1289, 0x0a6f800a,
-	0x00000000, 0x0cc00000, 0x00000000, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x0a60c009, 0x07c00a89, 0x0c780b80, 0x06847f4a,
-	0x06012d0a, 0x0680000a, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x0aa14009, 0x06803fc9, 0x06410c08, 0x08010e88, 0x09308248,
-	0x054082cb, 0x094082c9, 0x0bad80ca, 0x0400128a, 0x0a60c10a,
-	0x00000000, 0x06012e0b, 0x0bac41ca, 0x00000000, 0x054082cb,
-	0x06012e0b, 0x06847fca, 0x06012d0a, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x06bfc00b, 0x0aa40009, 0x07c00ac9, 0x0680000a,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009, 0x06803fc9,
-	0x06410c08, 0x08010e88, 0x09308248, 0x054082cb, 0x094082c9,
-	0x0bad808a, 0x0400128a, 0x054082cb, 0x06012e0b, 0x06410c08,
-	0x08010e81, 0x093e1248, 0x0a60c009, 0x0c780d80, 0x00000000,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x07c00b09, 0x0680000c,
-	0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009, 0x0680000a,
-	0x06410c08, 0x08010e89, 0x092e9288, 0x0680268b, 0x0200b30b,
-	0x074002ca, 0x0680000b, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x0540f289, 0x0aa28009, 0x095612c9, 0x06410c08, 0x08010e87,
-	0x09346248, 0x09406289, 0x094862c9, 0x09321248, 0x09501289,
-	0x095412c9, 0x040a420c, 0x0740020a, 0x06410c08, 0x08010e81,
-	0x093e1248, 0x0aa18009, 0x094612c9, 0x06410c08, 0x08010e82,
-	0x093c2248, 0x094222c9, 0x06410c08, 0x08010e81, 0x093e1248,
-	0x094012c9, 0x096c32cc, 0x0980b7cb, 0x0b6101cc, 0x0601460b,
-	0x0c7ff4c0, 0x0400130c, 0x0680000c, 0x07800b0a, 0x0aa0c00a,
-	0x0780088b, 0x0680000b, 0x06802688, 0x02008308, 0x07000208,
-	0x09028288, 0x09001248, 0x0aa0c009, 0x0200928b, 0x0240928b,
-	0x0ba14009, 0x0680000a, 0x0ae0ffc9, 0x06803fca, 0x04000289,
-	0x07900988, 0x0200920a, 0x0ba14009, 0x0680000b, 0x0ae0ffc9,
-	0x06803fcb, 0x040002c9, 0x095082ca, 0x096232cc, 0x0601460b,
-	0x07900a08, 0x0200920a, 0x0ba14009, 0x0680000b, 0x0ae0ffc9,
-	0x06803fcb, 0x040002c9, 0x079009c8, 0x0200920a, 0x0ba14009,
-	0x06800008, 0x0ae0ffc9, 0x06803fc8, 0x04000209, 0x0950820b,
-	0x0962320c, 0x09808408, 0x06014608, 0x0b60c1cc, 0x0c7ff480,
-	0x0400130c, 0x0cc00000, 0x00000000, 0x07800dc8, 0x04401208,
+	0x00000000, 0x0cc00000, 0x00000000, 0x0640c100, 0x06035100,
+	0x06802000, 0x06035200, 0x06b02000, 0x06035000, 0x06435000,
+	0x0580f000, 0x0bef8040, 0x00000000, 0x0640c100, 0x06804001,
+	0x02000040, 0x06035100, 0x06802000, 0x06035200, 0x06b00140,
+	0x06035000, 0x06435000, 0x0580f000, 0x0bef8040, 0x00000000,
+	0x0cc00000, 0x00000000, 0x0800cf00, 0x0800c0ff, 0x06800009,
+	0x0680ffca, 0x07000248, 0x09808408, 0x0600cf08, 0x00000000,
+	0x0640cf08, 0x0a6fc008, 0x0b403289, 0x0c7ffe40, 0x04001249,
+	0x0cc00000, 0x00000000, 0x069fffca, 0x06440109, 0x0a2fc049,
+	0x0440128a, 0x06460309, 0x093e1289, 0x0a6f800a, 0x00000000,
+	0x0cc00000, 0x00000000, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0a60c009, 0x07c00a89, 0x0c780b80, 0x06847f4a, 0x06012d0a,
+	0x0680000a, 0x06410c08, 0x08010e81, 0x093e1248, 0x0aa14009,
+	0x06803fc9, 0x06410c08, 0x08010e88, 0x09308248, 0x054082cb,
+	0x094082c9, 0x0bad80ca, 0x0400128a, 0x0a60c10a, 0x00000000,
+	0x06012e0b, 0x0bac41ca, 0x00000000, 0x054082cb, 0x06012e0b,
+	0x06847fca, 0x06012d0a, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x06bfc00b, 0x0aa40009, 0x07c00ac9, 0x0680000a, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0aa14009, 0x06803fc9, 0x06410c08,
+	0x08010e88, 0x09308248, 0x054082cb, 0x094082c9, 0x0bad808a,
+	0x0400128a, 0x054082cb, 0x06012e0b, 0x06410c08, 0x08010e81,
+	0x093e1248, 0x0a60c009, 0x0c780d80, 0x00000000, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x07c00b09, 0x0680000c, 0x06410c08,
+	0x08010e81, 0x093e1248, 0x0aa14009, 0x0680000a, 0x06410c08,
+	0x08010e89, 0x092e9288, 0x0680268b, 0x0200b30b, 0x074002ca,
+	0x0680000b, 0x06410c08, 0x08010e81, 0x093e1248, 0x0540f289,
+	0x0aa28009, 0x095612c9, 0x06410c08, 0x08010e87, 0x09346248,
+	0x09406289, 0x094862c9, 0x09321248, 0x09501289, 0x095412c9,
+	0x040a420c, 0x0740020a, 0x06410c08, 0x08010e81, 0x093e1248,
+	0x0aa18009, 0x094612c9, 0x06410c08, 0x08010e82, 0x093c2248,
+	0x094222c9, 0x06410c08, 0x08010e81, 0x093e1248, 0x094012c9,
+	0x096c32cc, 0x0980b7cb, 0x0b6101cc, 0x0601460b, 0x0c7ff4c0,
+	0x0400130c, 0x0680000c, 0x07800b0a, 0x0aa0c00a, 0x0780088b,
+	0x0680000b, 0x06802688, 0x02008308, 0x07000208, 0x09028288,
+	0x09001248, 0x0aa0c009, 0x0200928b, 0x0240928b, 0x0ba14009,
+	0x0680000a, 0x0ae0ffc9, 0x06803fca, 0x04000289, 0x07900988,
+	0x0200920a, 0x0ba14009, 0x0680000b, 0x0ae0ffc9, 0x06803fcb,
+	0x040002c9, 0x095082ca, 0x096232cc, 0x0601460b, 0x07900a08,
+	0x0200920a, 0x0ba14009, 0x0680000b, 0x0ae0ffc9, 0x06803fcb,
+	0x040002c9, 0x079009c8, 0x0200920a, 0x0ba14009, 0x06800008,
+	0x0ae0ffc9, 0x06803fc8, 0x04000209, 0x0950820b, 0x0962320c,
+	0x09808408, 0x06014608, 0x0b60c1cc, 0x0c7ff480, 0x0400130c,
+	0x0cc00000, 0x00000000, 0x07800dc8, 0x04401208, 0x05403248,
+	0x02009248, 0x02008248, 0x06806009, 0x02009209, 0x07400266,
+	0x09210226, 0x04001249, 0x07400248, 0x04001249, 0x07400269,
+	0x09210229, 0x04001249, 0x07400248, 0x04001249, 0x0740026a,
+	0x0921022a, 0x04001249, 0x07400248, 0x04001249, 0x07400267,
+	0x09210227, 0x04001249, 0x07400248, 0x04001249, 0x07400268,
+	0x09210228, 0x04001249, 0x0cc00000, 0x07400248, 0x07800d48,
 	0x05403248, 0x02009248, 0x02008248, 0x06806009, 0x02009209,
-	0x07400266, 0x09210226, 0x04001249, 0x07400248, 0x04001249,
-	0x07400269, 0x09210229, 0x04001249, 0x07400248, 0x04001249,
-	0x0740026a, 0x0921022a, 0x04001249, 0x07400248, 0x04001249,
-	0x07400267, 0x09210227, 0x04001249, 0x07400248, 0x04001249,
-	0x07400268, 0x09210228, 0x04001249, 0x0cc00000, 0x07400248,
-	0x07800d48, 0x05403248, 0x02009248, 0x02008248, 0x06806009,
-	0x02009209, 0x07000261, 0x04001249, 0x07000248, 0x09610848,
-	0x04001249, 0x07000264, 0x04001249, 0x07000248, 0x09610908,
-	0x04001249, 0x07000265, 0x04001249, 0x07000248, 0x09610948,
-	0x04001249, 0x07000262, 0x04001249, 0x07000248, 0x09610888,
-	0x04001249, 0x07000263, 0x04001249, 0x07000248, 0x096108c8,
-	0x06014224, 0x06014325, 0x06011c21, 0x06011d22, 0x0cc00000,
-	0x06014723, 0x07800a88, 0x0aa14008, 0x07800ac8, 0x0a60c008,
-	0x0cc00000, 0x00000000, 0x07801208, 0x0640cb09, 0x02009248,
-	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x06035109,
-	0x06800c08, 0x06035208, 0x06b10008, 0x06035008, 0x08015020,
-	0x06435008, 0x0580f208, 0x0bef8048, 0x06810008, 0x0680018b,
-	0x07800b49, 0x0a618009, 0x06800009, 0x0d00000b, 0x06015109,
-	0x0cc00000, 0x08015080, 0x07000209, 0x04001208, 0x0700020a,
-	0x04001208, 0x0961024a, 0x0d07fecb, 0x06015109, 0x0cc00000,
-	0x08015080, 0x07800b88, 0x0ae08048, 0x0c780900, 0x078012c8,
-	0x05403248, 0x05402208, 0x02008248, 0x06810009, 0x02008248,
-	0x08015020, 0x0643500b, 0x0580f2cb, 0x0bef804b, 0x0680018b,
-	0x06415109, 0x07400209, 0x04001208, 0x09210249, 0x07400209,
-	0x0d07fecb, 0x04001208, 0x07c012c8, 0x07801288, 0x0be3c0c8,
-	0x0be0c108, 0x0681000b, 0x040302cb, 0x07800a88, 0x0aa28008,
-	0x07801248, 0x0640cb09, 0x02009248, 0x06035109, 0x078012c8,
-	0x024082c8, 0x06035208, 0x0980b3cb, 0x0603500b, 0x07801208,
-	0x07c01248, 0x07801288, 0x07c012c8, 0x07800f08, 0x07801349,
-	0x0a408248, 0x07800eca, 0x07801309, 0x04001249, 0x0a40c289,
-	0x07801289, 0x0c780340, 0x04001249, 0x04001249, 0x0a407209,
-	0x07800eca, 0x0a61400a, 0x07801309, 0x04001249, 0x0780040a,
-	0x0a8f6289, 0x07801289, 0x04004249, 0x048fc249, 0x04807249,
-	0x07c01289, 0x0be340c9, 0x07800f08, 0x07800409, 0x0e000248,
-	0x07800ec9, 0x00000000, 0x00000000, 0x0f000200, 0x02008248,
-	0x05404248, 0x05403208, 0x02008248, 0x07c01208, 0x07800ec8,
-	0x07c01308, 0x07800f08, 0x07c01348, 0x07800a88, 0x0aa14008,
-	0x07800ac8, 0x0a60c008, 0x0cc00000, 0x00000000, 0x07801289,
-	0x0be400c9, 0x07801208, 0x0640cb09, 0x02009248, 0x06435008,
+	0x07000261, 0x04001249, 0x07000248, 0x09610848, 0x04001249,
+	0x07000264, 0x04001249, 0x07000248, 0x09610908, 0x04001249,
+	0x07000265, 0x04001249, 0x07000248, 0x09610948, 0x04001249,
+	0x07000262, 0x04001249, 0x07000248, 0x09610888, 0x04001249,
+	0x07000263, 0x04001249, 0x07000248, 0x096108c8, 0x06014224,
+	0x06014325, 0x06011c21, 0x06011d22, 0x0cc00000, 0x06014723,
+	0x07800a88, 0x0aa14008, 0x07800ac8, 0x0a60c008, 0x0cc00000,
+	0x00000000, 0x07801208, 0x0640cb09, 0x02009248, 0x06435008,
 	0x0580f208, 0x0bef8048, 0x00000000, 0x06035109, 0x06800c08,
-	0x06035208, 0x07801289, 0x0be0c109, 0x06b10c08, 0x06b10008,
-	0x06035008, 0x06435008, 0x0580f208, 0x0bef8048, 0x00000000,
-	0x07801288, 0x05403248, 0x05402208, 0x02008248, 0x06810009,
-	0x02008248, 0x08015020, 0x0680018b, 0x07800b49, 0x0a618009,
-	0x06800009, 0x0d00000b, 0x06015109, 0x0cc00000, 0x00000000,
-	0x07000209, 0x04001208, 0x0700020a, 0x04001208, 0x0961024a,
-	0x0d07fecb, 0x06015109, 0x0cc00000, 0x00000000, 0x078012c8,
-	0x0a20c108, 0x0681000a, 0x06810c0a, 0x05403248, 0x05402208,
-	0x02008248, 0x06810009, 0x02008248, 0x08015020, 0x0643500b,
-	0x0580f2cb, 0x0bef804b, 0x0680018b, 0x06415109, 0x07400209,
-	0x04001208, 0x09210249, 0x07400209, 0x0d07fecb, 0x04001208,
-	0x07c012c8, 0x07800a88, 0x0a608008, 0x0cc00000, 0x07801248,
-	0x0640cb09, 0x02009248, 0x06035109, 0x078012c8, 0x02408288,
-	0x06035208, 0x0980a3ca, 0x0cc00000, 0x0603500a, 0x06410108,
-	0x09808348, 0x06010108, 0x06410108, 0x09021208, 0x0a6f8008,
-	0x07800588, 0x0aa34048, 0x06bf0008, 0x06e016c8, 0x06014d08,
-	0x0640ca08, 0x06013408, 0x08013503, 0x06413508, 0x090e1248,
-	0x0a6f8009, 0x09308248, 0x0a6f0009, 0x00000000, 0x08014d00,
-	0x06af0008, 0x06ec05c8, 0x06014d08, 0x0640c908, 0x07800589,
-	0x0aa10009, 0x06900009, 0x078005c9, 0x0540c249, 0x02008248,
-	0x06013408, 0x08013503, 0x06413508, 0x090e1248, 0x0a6f8009,
-	0x09308248, 0x0a6f0009, 0x00000000, 0x08013500, 0x08014d00,
-	0x07800588, 0x0aa14048, 0x06803f48, 0x078005c9, 0x09502209,
-	0x0600c308, 0x06410108, 0x09c08348, 0x0cc00000, 0x06010108,
-	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x0640c408,
-	0x07801189, 0x05408249, 0x02008248, 0x06035108, 0x08035280,
-	0x06bd4008, 0x06035008, 0x07801189, 0x04001249, 0x07c01189,
-	0x06814009, 0x07c01149, 0x06462308, 0x09808288, 0x06062308,
-	0x06462d08, 0x09808048, 0x06062d08, 0x06435008, 0x0580f208,
-	0x0bef8048, 0x00000000, 0x0cc00000, 0x00000000, 0x06463908,
-	0x09105248, 0x0aa40009, 0x0780114a, 0x07000288, 0x0400128a,
-	0x0700028b, 0x0961020b, 0x06063808, 0x0400128a, 0x07c0114a,
-	0x06816008, 0x0b8f620a, 0x04401249, 0x0c07f540, 0x00000000,
-	0x0c7ffc00, 0x00000000, 0x0cc00000, 0x00000000, 0x0680000c,
-	0x06800008, 0x07c00b48, 0x0409a2cc, 0x074002c8, 0x040a42cc,
-	0x074002c8, 0x054162cc, 0x0980b7cb, 0x0b6101cc, 0x0601460b,
-	0x0c7ffe00, 0x0400130c, 0x06800048, 0x07c00708, 0x06800008,
-	0x07c00748, 0x07c00808, 0x07c00848, 0x04401208, 0x07c00788,
-	0x0cc00000, 0x07c007c8, 0x07800349, 0x07800388, 0x09610248,
-	0x06412308, 0x0a804248, 0x06800009, 0x07c00b49, 0x06800049,
-	0x07c003c9, 0x09010248, 0x07c002c9, 0x07c00349, 0x09210208,
-	0x07c00308, 0x07c00388, 0x0403f289, 0x0580628a, 0x07c0040a,
-	0x0403f288, 0x0580628a, 0x0cc00000, 0x07c0044a, 0x067f2f2b,
-	0x0a2fc12b, 0x0640c02b, 0x0a6f7feb, 0x00000000, 0x0641392b,
-	0x0680006f, 0x0c001200, 0x06800030, 0x0c001d00, 0x069fffb1,
+	0x06035208, 0x06b10008, 0x06035008, 0x08015020, 0x06435008,
+	0x0580f208, 0x0bef8048, 0x06810008, 0x0680018b, 0x07800b49,
+	0x0a618009, 0x06800009, 0x0d00000b, 0x06015109, 0x0cc00000,
+	0x08015080, 0x07000209, 0x04001208, 0x0700020a, 0x04001208,
+	0x0961024a, 0x0d07fecb, 0x06015109, 0x0cc00000, 0x08015080,
+	0x07800b88, 0x0ae08048, 0x0c780900, 0x078012c8, 0x05403248,
+	0x05402208, 0x02008248, 0x06810009, 0x02008248, 0x08015020,
+	0x0643500b, 0x0580f2cb, 0x0bef804b, 0x0680018b, 0x06415109,
+	0x07400209, 0x04001208, 0x09210249, 0x07400209, 0x0d07fecb,
+	0x04001208, 0x07c012c8, 0x07801288, 0x0be3c0c8, 0x0be0c108,
+	0x0681000b, 0x040302cb, 0x07800a88, 0x0aa28008, 0x07801248,
+	0x0640cb09, 0x02009248, 0x06035109, 0x078012c8, 0x024082c8,
+	0x06035208, 0x0980b3cb, 0x0603500b, 0x07801208, 0x07c01248,
+	0x07801288, 0x07c012c8, 0x07800f08, 0x07801349, 0x0a408248,
+	0x07800eca, 0x07801309, 0x04001249, 0x0a40c289, 0x07801289,
+	0x0c780340, 0x04001249, 0x04001249, 0x0a407209, 0x07800eca,
+	0x0a61400a, 0x07801309, 0x04001249, 0x0780040a, 0x0a8f6289,
+	0x07801289, 0x04004249, 0x048fc249, 0x04807249, 0x07c01289,
+	0x0be340c9, 0x07800f08, 0x07800409, 0x0e000248, 0x07800ec9,
+	0x00000000, 0x00000000, 0x0f000200, 0x02008248, 0x05404248,
+	0x05403208, 0x02008248, 0x07c01208, 0x07800ec8, 0x07c01308,
+	0x07800f08, 0x07c01348, 0x07800a88, 0x0aa14008, 0x07800ac8,
+	0x0a60c008, 0x0cc00000, 0x00000000, 0x07801289, 0x0be400c9,
+	0x07801208, 0x0640cb09, 0x02009248, 0x06435008, 0x0580f208,
+	0x0bef8048, 0x00000000, 0x06035109, 0x06800c08, 0x06035208,
+	0x07801289, 0x0be0c109, 0x06b10c08, 0x06b10008, 0x06035008,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x07801288,
+	0x05403248, 0x05402208, 0x02008248, 0x06810009, 0x02008248,
+	0x08015020, 0x0680018b, 0x07800b49, 0x0a618009, 0x06800009,
+	0x0d00000b, 0x06015109, 0x0cc00000, 0x00000000, 0x07000209,
+	0x04001208, 0x0700020a, 0x04001208, 0x0961024a, 0x0d07fecb,
+	0x06015109, 0x0cc00000, 0x00000000, 0x078012c8, 0x0a20c108,
+	0x0681000a, 0x06810c0a, 0x05403248, 0x05402208, 0x02008248,
+	0x06810009, 0x02008248, 0x08015020, 0x0643500b, 0x0580f2cb,
+	0x0bef804b, 0x0680018b, 0x06415109, 0x07400209, 0x04001208,
+	0x09210249, 0x07400209, 0x0d07fecb, 0x04001208, 0x07c012c8,
+	0x07800a88, 0x0a608008, 0x0cc00000, 0x07801248, 0x0640cb09,
+	0x02009248, 0x06035109, 0x078012c8, 0x02408288, 0x06035208,
+	0x0980a3ca, 0x0cc00000, 0x0603500a, 0x0680142f, 0x0c003d00,
+	0x04000c08, 0x06410108, 0x09808348, 0x06010108, 0x06410108,
+	0x09021208, 0x0a6f8008, 0x07800588, 0x0aa34048, 0x06bf0008,
+	0x06e016c8, 0x06014d08, 0x0640ca08, 0x06013408, 0x08013503,
+	0x06413508, 0x090e1248, 0x0a6f8009, 0x09308248, 0x0a6f0009,
+	0x00000000, 0x08014d00, 0x06af0008, 0x06ec05c8, 0x06014d08,
+	0x0640c908, 0x07800589, 0x0aa10009, 0x06900009, 0x078005c9,
+	0x0540c249, 0x02008248, 0x06013408, 0x08013503, 0x06413508,
+	0x090e1248, 0x0a6f8009, 0x09308248, 0x0a6f0009, 0x00000000,
+	0x08013500, 0x08014d00, 0x07800588, 0x0aa14048, 0x06803f48,
+	0x078005c9, 0x09502209, 0x0600c308, 0x06410108, 0x09c08348,
+	0x0cc00000, 0x06010108, 0x06435008, 0x0580f208, 0x0bef8048,
+	0x00000000, 0x0640c408, 0x07801189, 0x05408249, 0x02008248,
+	0x06035108, 0x08035280, 0x06bd4008, 0x06035008, 0x07801189,
+	0x04001249, 0x07c01189, 0x06814009, 0x07c01149, 0x06462308,
+	0x09808288, 0x06062308, 0x06462d08, 0x09808048, 0x06062d08,
+	0x06435008, 0x0580f208, 0x0bef8048, 0x00000000, 0x0cc00000,
+	0x00000000, 0x06463908, 0x09105248, 0x0aa40009, 0x0780114a,
+	0x07000288, 0x0400128a, 0x0700028b, 0x0961020b, 0x06063808,
+	0x0400128a, 0x07c0114a, 0x06816008, 0x0b8f620a, 0x04401249,
+	0x0c07f540, 0x00000000, 0x0c7ffc00, 0x00000000, 0x0cc00000,
+	0x00000000, 0x0680000c, 0x06800008, 0x07c00b48, 0x0409a2cc,
+	0x074002c8, 0x040a42cc, 0x074002c8, 0x054162cc, 0x0980b7cb,
+	0x0b6101cc, 0x0601460b, 0x0c7ffe00, 0x0400130c, 0x06800048,
+	0x07c00708, 0x06800008, 0x07c00748, 0x07c00808, 0x07c00848,
+	0x04401208, 0x07c00788, 0x0cc00000, 0x07c007c8, 0x07800349,
+	0x07800388, 0x09610248, 0x06412308, 0x0a804248, 0x06800009,
+	0x07c00b49, 0x06800049, 0x07c003c9, 0x09010248, 0x07c002c9,
+	0x07c00349, 0x09210208, 0x07c00308, 0x07c00388, 0x0403f289,
+	0x0580628a, 0x07c0040a, 0x0403f288, 0x0580628a, 0x0cc00000,
+	0x07c0044a, 0x067f2f2b, 0x0a2fc12b, 0x0640c02b, 0x0a6f7feb,
+	0x00000000, 0x0780152b, 0x0780156e, 0x09610aee, 0x06410d2e,
+	0x0242eaee, 0x0640d72b, 0x0aa3002b, 0x00000000, 0x068000ef,
+	0x04000c2e, 0x0c001480, 0x09610c2b, 0x04401aeb, 0x0b805aee,
+	0x00000000, 0x0800c00e, 0x0c7ffac0, 0x08007401, 0x0641392b,
+	0x068000af, 0x0c001200, 0x06800030, 0x0c001d00, 0x069fffb1,
 	0x08013900, 0x06410b2b, 0x0982b0ab, 0x06010b2b, 0x0641212b,
 	0x0a2fc06b, 0x00000000, 0x069315ae, 0x06d0536e, 0x06410c2b,
-	0x068000af, 0x0c000e40, 0x04000c2b, 0x0a4edbab, 0x08012101,
-	0x08010e90, 0x08010e90, 0x06410c2b, 0x068000ef, 0x0c000c40,
+	0x068000ef, 0x0c000e40, 0x04000c2b, 0x0a4edbab, 0x08012101,
+	0x08010e90, 0x08010e90, 0x06410c2b, 0x0680012f, 0x0c000c40,
 	0x04000c2b, 0x0695556e, 0x06d5556e, 0x0a409bab, 0x00000000,
 	0x08012101, 0x0800c0f2, 0x08007401, 0x0640c02e, 0x0aaffcae,
 	0x0c7ff700, 0x00000000, 0x093c2aeb, 0x0aa0c0ab, 0x0c7ff600,
 	0x00000000, 0x0641162c, 0x093e1b2c, 0x0aa0402c, 0x0640d22c,
-	0x0a21406c, 0x00000000, 0x0800c0f1, 0x0c7ff280, 0x08007401,
-	0x0680006d, 0x0680012f, 0x0c000540, 0x04000c2d, 0x0600c02d,
-	0x08030504, 0x0c7ff080, 0x00000000, 0x0c074980, 0x00000000,
+	0x0a21406c, 0x00000000, 0x0800c0f1, 0x0c7fee00, 0x08007401,
+	0x0680006d, 0x0680016f, 0x0c000540, 0x04000c2d, 0x0600c02d,
+	0x08030504, 0x0c7fec00, 0x00000000, 0x0c073940, 0x00000000,
 	0x0800c0f0, 0x08007401, 0x0cc00000, 0x00000000, 0x0640c009,
 	0x0aa0c149, 0x0a6f8189, 0x00000000, 0x068004af, 0x0c000100,
 	0x06800030, 0x0cc00000, 0x00000000, 0x0600d130, 0x078013f0,
@@ -969,7 +1028,10 @@ const u32  vvp9_mc[] __initconst = {
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
 
 #endif
 };
diff --git a/drivers/amlogic/amports/cnm/vpu.c b/drivers/amlogic/amports/cnm/vpu.c
index 6658ece..38fadf8 100644
--- a/drivers/amlogic/amports/cnm/vpu.c
+++ b/drivers/amlogic/amports/cnm/vpu.c
@@ -74,6 +74,7 @@
 	} while (0)
 
 static s32 print_level = LOG_DEBUG;
+static s32 clock_level = 4;
 
 static struct video_mm_t s_vmem;
 static struct vpudrv_buffer_t s_video_memory = {0};
@@ -130,7 +131,7 @@ s32 vpu_hw_reset(void)
 s32 vpu_clk_config(u32 enable)
 {
 	if (enable)
-		HevcEnc_clock_enable(4);
+		HevcEnc_clock_enable(clock_level);
 	else
 		HevcEnc_clock_disable();
 	return 0;
@@ -1426,12 +1427,16 @@ static s32 vpu_map_to_instance_pool_memory(
  */
 static s32 vpu_mmap(struct file *fp, struct vm_area_struct *vm)
 {
+	/* if (vm->vm_pgoff == (s_vpu_register.phys_addr >> PAGE_SHIFT)) */
+	if ((vm->vm_end - vm->vm_start == s_vpu_register.size + 1) &&
+						(vm->vm_pgoff == 0)) {
+		vm->vm_pgoff = (s_vpu_register.phys_addr >> PAGE_SHIFT);
+		return vpu_map_to_register(fp, vm);
+	}
+
 	if (vm->vm_pgoff == 0)
 		return vpu_map_to_instance_pool_memory(fp, vm);
 
-	if (vm->vm_pgoff == (s_vpu_register.phys_addr >> PAGE_SHIFT))
-		return vpu_map_to_register(fp, vm);
-
 	return vpu_map_to_physical_memory(fp, vm);
 }
 
@@ -1980,6 +1985,9 @@ static s32 __init hevc_mem_setup(struct reserved_mem *rmem)
 module_param(print_level, uint, 0664);
 MODULE_PARM_DESC(print_level, "\n print_level\n");
 
+module_param(clock_level, uint, 0664);
+MODULE_PARM_DESC(clock_level, "\n clock_level\n");
+
 MODULE_AUTHOR("Amlogic using C&M VPU, Inc.");
 MODULE_DESCRIPTION("VPU linux driver");
 MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/amports/config_parser.c b/drivers/amlogic/amports/config_parser.c
new file mode 100644
index 0000000..b9c64f7
--- /dev/null
+++ b/drivers/amlogic/amports/config_parser.c
@@ -0,0 +1,62 @@
+/*
+ * drivers/amlogic/amports/config_parser.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+
+#include "config_parser.h"
+/*
+sample config:
+configs: width:1920;height:1080;
+need:width
+ok: return 0;
+*val = value;
+*/
+int get_config_int(const char *configs, const char *need, int *val)
+{
+	const char *str;
+	int ret;
+	int lval = 0;
+	*val = 0;
+
+	if (!configs || !need)
+		return -1;
+	str = strstr(configs, need);
+	if (str != NULL) {
+		if (str > configs && str[-1] != ';') {
+			/*
+			   if not the first config val.
+			   make sure before is ';'
+			   to recognize:
+			   ;crop_width:100
+			   ;width:100
+			 */
+			return -2;
+		}
+		str += strlen(need);
+		if (str[0] != ':' || str[1] == '\0')
+			return -3;
+		ret = sscanf(str, ":%d", &lval);
+		if (ret == 1) {
+			*val = lval;
+			return 0;
+		}
+	}
+
+	return -4;
+}
diff --git a/drivers/amlogic/amports/config_parser.h b/drivers/amlogic/amports/config_parser.h
new file mode 100644
index 0000000..e10210a
--- /dev/null
+++ b/drivers/amlogic/amports/config_parser.h
@@ -0,0 +1,21 @@
+/*
+ * drivers/amlogic/amports/config_parser.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+#ifndef CONFIG_PARSER_HHH_
+#define CONFIG_PARSER_HHH_
+int get_config_int(const char *configs, const char *need, int *val);
+
+#endif/*CONFIG_PARSER_HHH_*/
diff --git a/drivers/amlogic/amports/decoder/Makefile b/drivers/amlogic/amports/decoder/Makefile
new file mode 100644
index 0000000..cf48c39
--- /dev/null
+++ b/drivers/amlogic/amports/decoder/Makefile
@@ -0,0 +1,3 @@
+
+obj-y += decoder_mmu_box.o decoder_bmmu_box.o
+
diff --git a/drivers/amlogic/amports/decoder/decoder_bmmu_box.c b/drivers/amlogic/amports/decoder/decoder_bmmu_box.c
new file mode 100644
index 0000000..3395246
--- /dev/null
+++ b/drivers/amlogic/amports/decoder/decoder_bmmu_box.c
@@ -0,0 +1,399 @@
+/*
+ * drivers/amlogic/amports/decoder/decoder_bmmu_box.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/semaphore.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/kfifo.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+#include <linux/amlogic/codec_mm/codec_mm.h>
+#include <linux/platform_device.h>
+
+#include "../video_keeper.h"
+#include "decoder_bmmu_box.h"
+
+struct decoder_bmmu_box {
+	int max_mm_num;
+	const char *name;
+	int channel_id;
+	struct mutex mutex;
+	struct list_head list;
+	int total_size;
+	int change_size_on_need_smaller;
+	int align2n;		/*can overwite on idx alloc */
+	int mem_flags;		/*can overwite on idx alloc */
+	struct codec_mm_s *mm_list[1];
+};
+
+struct decoder_bmmu_box_mgr {
+	int num;
+	struct mutex mutex;
+	struct list_head box_list;
+};
+static struct decoder_bmmu_box_mgr global_blk_mgr;
+static struct decoder_bmmu_box_mgr *get_decoder_bmmu_box_mgr(void)
+{
+	return &global_blk_mgr;
+}
+
+static int decoder_bmmu_box_mgr_add_box(struct decoder_bmmu_box *box)
+{
+	struct decoder_bmmu_box_mgr *mgr = get_decoder_bmmu_box_mgr();
+	mutex_lock(&mgr->mutex);
+	list_add_tail(&box->list, &mgr->box_list);
+	mutex_unlock(&mgr->mutex);
+	return 0;
+}
+
+static int decoder_bmmu_box_mgr_del_box(struct decoder_bmmu_box *box)
+{
+	struct decoder_bmmu_box_mgr *mgr = get_decoder_bmmu_box_mgr();
+	mutex_lock(&mgr->mutex);
+	list_del(&box->list);
+	mutex_unlock(&mgr->mutex);
+	return 0;
+}
+
+void *decoder_bmmu_box_alloc_box(const char *name,
+		int channel_id, int max_num,
+		int aligned, int mem_flags)
+/*min_size_M:wait alloc this size*/
+{
+	struct decoder_bmmu_box *box;
+	int size;
+	size = sizeof(struct decoder_bmmu_box) + sizeof(struct codec_mm_s *) *
+		   max_num;
+	box = kmalloc(size, GFP_KERNEL);
+	if (!box) {
+		pr_err("can't alloc decoder buffers box!!!\n");
+		return NULL;
+	}
+	memset(box, 0, size);
+	box->max_mm_num = max_num;
+	box->name = name;
+	box->channel_id = channel_id;
+	box->align2n = aligned;
+	box->mem_flags = mem_flags;
+	mutex_init(&box->mutex);
+	INIT_LIST_HEAD(&box->list);
+	decoder_bmmu_box_mgr_add_box(box);
+	return (void *)box;
+}
+
+int decoder_bmmu_box_alloc_idx(void *handle, int idx, int size, int aligned_2n,
+							   int mem_flags)
+/*align& flags if -1 user box default.*/
+{
+	struct decoder_bmmu_box *box = handle;
+	struct codec_mm_s *mm;
+	int align = aligned_2n;
+	int memflags = mem_flags;
+
+	if (!box || idx < 0 || idx >= box->max_mm_num) {
+		pr_err("can't alloc mmu box(%p),idx:%d\n",
+				box, idx);
+		return -1;
+	}
+	if (align == -1)
+		align = box->align2n;
+	if (memflags == -1)
+		memflags = box->mem_flags;
+
+	mutex_lock(&box->mutex);
+	mm = box->mm_list[idx];
+	if (mm) {
+		int invalid = 0;
+		if (mm->page_count * PAGE_SIZE < size) {
+			/*size is small. */
+			invalid = 1;
+		} else if (box->change_size_on_need_smaller &&
+				   (mm->buffer_size > (size << 1))) {
+			/*size is too large. */
+			invalid = 2;
+		} else if (mm->phy_addr & ((1 << align) - 1)) {
+			/*addr is not align */
+			invalid = 4;
+		}
+		if (invalid) {
+			box->total_size -= mm->buffer_size;
+			codec_mm_release(mm, box->name);
+			box->mm_list[idx] = NULL;
+			mm = NULL;
+		}
+	}
+	if (!mm) {
+		mm = codec_mm_alloc(box->name, size, align, memflags);
+		if (mm) {
+			box->mm_list[idx] = mm;
+			box->total_size += mm->buffer_size;
+		}
+	}
+	mutex_unlock(&box->mutex);
+	return mm ? 0 : -ENOMEM;
+}
+
+int decoder_bmmu_box_free_idx(void *handle, int idx)
+{
+	struct decoder_bmmu_box *box = handle;
+	struct codec_mm_s *mm;
+	if (!box || idx < 0 || idx >= box->max_mm_num) {
+		pr_err("can't free idx of box(%p),idx:%d  in (%d-%d)\n",
+				box, idx, 0,
+			   box->max_mm_num - 1);
+		return -1;
+	}
+	mutex_lock(&box->mutex);
+	mm = box->mm_list[idx];
+	if (mm) {
+		box->total_size -= mm->buffer_size;
+		codec_mm_release(mm, box->name);
+		box->mm_list[idx] = NULL;
+		mm = NULL;
+	}
+	mutex_unlock(&box->mutex);
+	return 0;
+}
+
+int decoder_bmmu_box_free(void *handle)
+{
+	struct decoder_bmmu_box *box = handle;
+	struct codec_mm_s *mm;
+	int i;
+	if (!box) {
+		pr_err("can't free box of NULL box!\n");
+		return -1;
+	}
+	mutex_lock(&box->mutex);
+	for (i = 0; i < box->max_mm_num; i++) {
+		mm = box->mm_list[i];
+		if (mm) {
+			codec_mm_release(mm, box->name);
+			box->mm_list[i] = NULL;
+		}
+	}
+	mutex_unlock(&box->mutex);
+	decoder_bmmu_box_mgr_del_box(box);
+	kfree(box);
+	return 0;
+}
+
+void *decoder_bmmu_box_get_mem_handle(void *box_handle, int idx)
+{
+	struct decoder_bmmu_box *box = box_handle;
+	if (!box || idx < 0 || idx >= box->max_mm_num)
+		return NULL;
+	return box->mm_list[idx];
+}
+
+int decoder_bmmu_box_get_mem_size(void *box_handle, int idx)
+{
+	struct decoder_bmmu_box *box = box_handle;
+	int size = 0;
+	if (!box || idx < 0 || idx >= box->max_mm_num)
+		return 0;
+	mutex_lock(&box->mutex);
+	if (box->mm_list[idx] != NULL)
+		size = box->mm_list[idx]->buffer_size;
+	mutex_unlock(&box->mutex);
+	return size;
+}
+
+
+unsigned long decoder_bmmu_box_get_phy_addr(void *box_handle, int idx)
+{
+	struct decoder_bmmu_box *box = box_handle;
+	struct codec_mm_s *mm;
+	if (!box || idx < 0 || idx >= box->max_mm_num)
+		return 0;
+	mm = box->mm_list[idx];
+	if (!mm)
+		return 0;
+	return mm->phy_addr;
+}
+
+void *decoder_bmmu_box_get_virt_addr(void *box_handle, int idx)
+{
+	struct decoder_bmmu_box *box = box_handle;
+	struct codec_mm_s *mm;
+	if (!box || idx < 0 || idx >= box->max_mm_num)
+		return NULL;
+	mm = box->mm_list[idx];
+	if (!mm)
+		return 0;
+	return codec_mm_phys_to_virt(mm->phy_addr);
+}
+
+/*flags: &0x1 for wait,*/
+int decoder_bmmu_box_check_and_wait_size(int size, int flags)
+{
+	if ((flags & BMMU_ALLOC_FLAGS_CAN_CLEAR_KEEPER) &&
+		codec_mm_get_free_size() < size) {
+		pr_err("CMA force free keep,for size = %d\n", size);
+		/*need free others?
+		*/
+		try_free_keep_video(1);
+	}
+
+	return codec_mm_enough_for_size(size,
+			flags & BMMU_ALLOC_FLAGS_WAIT);
+}
+
+int decoder_bmmu_box_alloc_idx_wait(
+	void *handle, int idx,
+	int size, int aligned_2n,
+	int mem_flags,
+	int wait_flags)
+{
+	int have_space;
+	int ret = -1;
+	if (decoder_bmmu_box_get_mem_size(handle, idx) >= size)
+		return 0;/*have alloced memery before.*/
+	have_space = decoder_bmmu_box_check_and_wait_size(
+					size,
+					wait_flags);
+	if (have_space) {
+		ret = decoder_bmmu_box_alloc_idx(handle,
+				idx, size, aligned_2n, mem_flags);
+	} else {
+		ret = -ENOMEM;
+	}
+	return ret;
+}
+
+static int decoder_bmmu_box_dump(struct decoder_bmmu_box *box, void *buf,
+								 int size)
+{
+	char *pbuf = buf;
+	char sbuf[512];
+	int tsize = 0;
+	int s;
+	int i;
+	if (!pbuf)
+		pbuf = sbuf;
+
+#define BUFPRINT(args...) \
+	do {\
+		s = sprintf(pbuf, args);\
+		tsize += s;\
+		pbuf += s; \
+	} while (0)
+
+	for (i = 0; i < box->max_mm_num; i++) {
+		struct codec_mm_s *mm = box->mm_list[i];
+		if (buf && (size - tsize) < 128)
+			break;
+		if (mm) {
+			BUFPRINT("code mem[%d]:%p, addr=%p, size=%d,from=%d\n",
+					 i,
+					 (void *)mm,
+					 (void *)mm->phy_addr,
+					 mm->buffer_size,
+					 mm->from_flags);
+		}
+	}
+#undef BUFPRINT
+	if (!buf)
+		pr_info("%s", sbuf);
+
+	return tsize;
+}
+
+static int decoder_bmmu_box_dump_all(void *buf, int size)
+{
+	struct decoder_bmmu_box_mgr *mgr = get_decoder_bmmu_box_mgr();
+	char *pbuf = buf;
+	char sbuf[512];
+	int tsize = 0;
+	int s;
+	int i;
+	struct list_head *head, *list;
+	if (!pbuf)
+		pbuf = sbuf;
+
+#define BUFPRINT(args...) \
+	do {\
+		s = sprintf(pbuf, args);\
+		tsize += s;\
+		pbuf += s; \
+	} while (0)
+
+	mutex_lock(&mgr->mutex);
+	head = &mgr->box_list;
+	list = head->next;
+	i = 0;
+	while (list != head) {
+		struct decoder_bmmu_box *box;
+		box = list_entry(list, struct decoder_bmmu_box, list);
+		BUFPRINT("box[%d]: %s, player_id:%d, max_num:%d, size:%d\n",
+				 i, box->name,
+				 box->channel_id,
+				 box->max_mm_num,
+				 box->total_size);
+		if (buf) {
+			tsize += decoder_bmmu_box_dump(box, pbuf, size - tsize);
+			if (tsize > 0)
+				pbuf += tsize;
+		} else {
+			pr_info("%s", sbuf);
+			pbuf = sbuf;
+			tsize += decoder_bmmu_box_dump(box, NULL, 0);
+		}
+		list = list->next;
+		i++;
+	}
+	mutex_unlock(&mgr->mutex);
+
+#undef BUFPRINT
+	if (!buf)
+		pr_info("%s", sbuf);
+	return tsize;
+}
+
+static ssize_t box_dump_show(struct class *class, struct class_attribute *attr,
+							 char *buf)
+{
+	ssize_t ret = 0;
+	ret = decoder_bmmu_box_dump_all(buf, PAGE_SIZE);
+	return ret;
+}
+
+static struct class_attribute decoder_bmmu_box_class_attrs[] = {
+	__ATTR_RO(box_dump),
+	__ATTR_NULL
+};
+
+static struct class decoder_bmmu_box_class = {
+		.name = "decoder_bmmu_box",
+		.class_attrs = decoder_bmmu_box_class_attrs,
+	};
+
+static int __init decoder_bmmu_box_init(void)
+{
+	int r;
+	memset(&global_blk_mgr, 0, sizeof(global_blk_mgr));
+	INIT_LIST_HEAD(&global_blk_mgr.box_list);
+	mutex_init(&global_blk_mgr.mutex);
+	r = class_register(&decoder_bmmu_box_class);
+	return r;
+}
+
+module_init(decoder_bmmu_box_init);
diff --git a/drivers/amlogic/amports/decoder/decoder_bmmu_box.h b/drivers/amlogic/amports/decoder/decoder_bmmu_box.h
new file mode 100644
index 0000000..4d0769e
--- /dev/null
+++ b/drivers/amlogic/amports/decoder/decoder_bmmu_box.h
@@ -0,0 +1,60 @@
+/*
+ * drivers/amlogic/amports/decoder/decoder_bmmu_box.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef DECODER_BLOCK_BUFFER_BOX
+#define DECODER_BLOCK_BUFFER_BOX
+
+void *decoder_bmmu_box_alloc_box(const char *name,
+								 int channel_id,
+								 int max_num,
+								 int aligned,
+								 int mem_flags);
+
+int decoder_bmmu_box_alloc_idx(
+	void *handle, int idx, int size,
+	int aligned_2n, int mem_flags);
+
+int decoder_bmmu_box_free_idx(void *handle, int idx);
+int decoder_bmmu_box_free(void *handle);
+void *decoder_bmmu_box_get_mem_handle(
+	void *box_handle, int idx);
+
+unsigned long decoder_bmmu_box_get_phy_addr(
+	void *box_handle, int idx);
+
+void *decoder_bmmu_box_get_virt_addr(
+	void *box_handle, int idx);
+
+/*flags: &0x1 for wait,*/
+int decoder_bmmu_box_check_and_wait_size(
+	int size, int flags);
+
+#define BMMU_ALLOC_FLAGS_WAIT (1 << 0)
+#define BMMU_ALLOC_FLAGS_CAN_CLEAR_KEEPER (1 << 1)
+#define BMMU_ALLOC_FLAGS_WAITCLEAR \
+		(BMMU_ALLOC_FLAGS_WAIT |\
+		BMMU_ALLOC_FLAGS_CAN_CLEAR_KEEPER)
+
+int decoder_bmmu_box_alloc_idx_wait(
+	void *handle, int idx,
+	int size, int aligned_2n,
+	int mem_flags,
+	int wait_flags);
+
+#endif	/*
+ */
+
diff --git a/drivers/amlogic/amports/decoder/decoder_mmu_box.c b/drivers/amlogic/amports/decoder/decoder_mmu_box.c
new file mode 100644
index 0000000..7fa3bef
--- /dev/null
+++ b/drivers/amlogic/amports/decoder/decoder_mmu_box.c
@@ -0,0 +1,346 @@
+/*
+ * drivers/amlogic/amports/decoder/decoder_mmu_box.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/semaphore.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/kfifo.h>
+#include <linux/kthread.h>
+#include <linux/slab.h>
+#include <linux/amlogic/codec_mm/codec_mm_scatter.h>
+#include <linux/platform_device.h>
+struct decoder_mmu_box {
+	int max_sc_num;
+	const char *name;
+	int channel_id;
+	struct mutex mutex;
+	struct list_head list;
+	struct codec_mm_scatter *sc_list[1];
+};
+#define MAX_KEEP_FRAME 4
+#define START_KEEP_ID 0x9
+#define MAX_KEEP_ID    (INT_MAX - 1)
+struct decoder_mmu_box_mgr {
+	int num;
+	struct mutex mutex;
+	struct codec_mm_scatter *keep_sc[MAX_KEEP_FRAME];
+	int	keep_id[MAX_KEEP_FRAME];
+	int next_id;/*id for keep & free.*/
+	struct list_head box_list;
+};
+static struct decoder_mmu_box_mgr global_mgr;
+static struct decoder_mmu_box_mgr *get_decoder_mmu_box_mgr(void)
+{
+	return &global_mgr;
+}
+
+static int decoder_mmu_box_mgr_add_box(struct decoder_mmu_box *box)
+{
+	struct decoder_mmu_box_mgr *mgr = get_decoder_mmu_box_mgr();
+	mutex_lock(&mgr->mutex);
+	list_add_tail(&box->list, &mgr->box_list);
+	mutex_unlock(&mgr->mutex);
+	return 0;
+}
+
+static int decoder_mmu_box_mgr_del_box(struct decoder_mmu_box *box)
+{
+	struct decoder_mmu_box_mgr *mgr = get_decoder_mmu_box_mgr();
+	mutex_lock(&mgr->mutex);
+	list_del(&box->list);
+	mutex_unlock(&mgr->mutex);
+	return 0;
+}
+
+
+
+void *decoder_mmu_box_alloc_box(const char *name,
+	int channel_id,
+	int max_num,
+	int min_size_M)
+/*min_size_M:wait alloc this size*/
+{
+	struct decoder_mmu_box *box;
+	int size;
+	size = sizeof(struct decoder_mmu_box) +
+			sizeof(struct codec_mm_scatter *) *
+			max_num;
+	box = kmalloc(size, GFP_KERNEL);
+	if (!box) {
+		pr_err("can't alloc decoder buffers box!!!\n");
+		return NULL;
+	}
+	memset(box, 0, size);
+	box->max_sc_num = max_num;
+	box->name = name;
+	box->channel_id = channel_id;
+	mutex_init(&box->mutex);
+	INIT_LIST_HEAD(&box->list);
+	decoder_mmu_box_mgr_add_box(box);
+	codec_mm_scatter_mgt_delay_free_swith(1, 2000,
+		min_size_M);
+	return (void *)box;
+}
+
+int decoder_mmu_box_alloc_idx(
+	void *handle, int idx, int num_pages,
+	unsigned int *mmu_index_adr)
+{
+	struct decoder_mmu_box *box = handle;
+	struct codec_mm_scatter *sc;
+	int ret;
+	int i;
+
+	if (!box || idx < 0 || idx >= box->max_sc_num) {
+		pr_err("can't alloc mmu box(%p),idx:%d\n",
+			box, idx);
+		return -1;
+	}
+	mutex_lock(&box->mutex);
+	sc = box->sc_list[idx];
+	if (sc) {
+		if (sc->page_max_cnt >= num_pages)
+			ret = codec_mm_scatter_alloc_want_pages(sc,
+				num_pages);
+		else {
+			codec_mm_scatter_dec_owner_user(sc, 0);
+			box->sc_list[idx] = NULL;
+			sc = NULL;
+		}
+
+	}
+	if (!sc) {
+		sc = codec_mm_scatter_alloc(num_pages + 64, num_pages);
+		if (!sc) {
+			mutex_unlock(&box->mutex);
+			pr_err("alloc mmu failed, need pages=%d\n",
+				num_pages);
+			return -1;
+		}
+		box->sc_list[idx] = sc;
+	}
+
+	for (i = 0; i < num_pages; i++)
+		mmu_index_adr[i] = PAGE_INDEX(sc->pages_list[i]);
+	mmu_index_adr[num_pages] = 0;
+
+	mutex_unlock(&box->mutex);
+
+	return 0;
+}
+
+int decoder_mmu_box_free_idx_tail(
+		void *handle, int idx,
+		int start_release_index)
+{
+	struct decoder_mmu_box *box = handle;
+	struct codec_mm_scatter *sc;
+	if (!box || idx < 0 || idx >= box->max_sc_num) {
+		pr_err("can't free tail mmu box(%p),idx:%d in (%d-%d)\n",
+			box, idx, 0,
+			box->max_sc_num - 1);
+		return -1;
+	}
+	mutex_lock(&box->mutex);
+	sc = box->sc_list[idx];
+	if (sc && start_release_index < sc->page_cnt)
+		codec_mm_scatter_free_tail_pages_fast(sc,
+				start_release_index);
+	mutex_unlock(&box->mutex);
+	return 0;
+}
+
+int decoder_mmu_box_free_idx(void *handle, int idx)
+{
+	struct decoder_mmu_box *box = handle;
+	struct codec_mm_scatter *sc;
+	if (!box || idx < 0 || idx >= box->max_sc_num) {
+		pr_err("can't free idx of box(%p),idx:%d  in (%d-%d)\n",
+			box, idx, 0,
+			box->max_sc_num - 1);
+		return -1;
+	}
+	mutex_lock(&box->mutex);
+	sc = box->sc_list[idx];
+	if (sc && sc->page_cnt > 0) {
+		codec_mm_scatter_dec_owner_user(sc, 0);
+		box->sc_list[idx] = NULL;
+	} mutex_unlock(&box->mutex);
+	return 0;
+}
+
+
+int decoder_mmu_box_free(void *handle)
+{
+	struct decoder_mmu_box *box = handle;
+	struct codec_mm_scatter *sc;
+	int i;
+	if (!box) {
+		pr_err("can't free box of NULL box!\n");
+		return -1;
+	}
+	mutex_lock(&box->mutex);
+	for (i = 0; i < box->max_sc_num; i++) {
+		sc = box->sc_list[i];
+		if (sc) {
+			codec_mm_scatter_dec_owner_user(sc, 200);
+			box->sc_list[i] = NULL;
+		}
+	}
+	mutex_unlock(&box->mutex);
+	decoder_mmu_box_mgr_del_box(box);
+	kfree(box);
+	codec_mm_scatter_mgt_delay_free_swith(0, 2000, 0);
+	return 0;
+}
+
+void *decoder_mmu_box_get_mem_handle(void *box_handle, int idx)
+{
+	struct decoder_mmu_box *box = box_handle;
+	if (!box || idx < 0 || idx >= box->max_sc_num)
+		return NULL;
+	return  box->sc_list[idx];
+}
+
+
+static int decoder_mmu_box_dump(struct decoder_mmu_box *box,
+				void *buf, int size)
+{
+	char *pbuf = buf;
+	char sbuf[512];
+	int tsize = 0;
+	int s;
+	int i;
+	if (!pbuf)
+		pbuf = sbuf;
+
+	#define BUFPRINT(args...) \
+	do {\
+		s = sprintf(pbuf, args);\
+		tsize += s;\
+		pbuf += s; \
+	} while (0)
+
+	for (i = 0; i < box->max_sc_num; i++) {
+		struct codec_mm_scatter *sc = box->sc_list[i];
+		if (sc) {
+			BUFPRINT("sc mem[%d]:%p, size=%d\n",
+				i, sc,
+				sc->page_cnt << PAGE_SHIFT);
+		}
+	}
+#undef BUFPRINT
+	if (!buf)
+		pr_info("%s", sbuf);
+
+	return tsize;
+}
+
+static int decoder_mmu_box_dump_all(void *buf, int size)
+{
+	struct decoder_mmu_box_mgr *mgr = get_decoder_mmu_box_mgr();
+	char *pbuf = buf;
+	char sbuf[512];
+	int tsize = 0;
+	int s;
+	int i;
+	struct list_head *head, *list;
+	if (!pbuf)
+		pbuf = sbuf;
+
+	#define BUFPRINT(args...) \
+	do {\
+		s = sprintf(pbuf, args);\
+		tsize += s;\
+		pbuf += s; \
+	} while (0)
+
+	mutex_lock(&mgr->mutex);
+	head = &mgr->box_list;
+	list = head->next;
+	i = 0;
+	while (list != head) {
+		struct decoder_mmu_box *box;
+		box = list_entry(list, struct decoder_mmu_box,
+							list);
+		BUFPRINT("box[%d]: %s, player_id:%d, max_num:%d\n",
+			i,
+			box->name,
+			box->channel_id,
+			box->max_sc_num);
+		if (buf) {
+			tsize += decoder_mmu_box_dump(box, pbuf, size - tsize);
+			if (tsize > 0)
+				pbuf += tsize;
+		} else {
+			pr_info("%s", sbuf);
+			pbuf = sbuf;
+			tsize += decoder_mmu_box_dump(box, NULL, 0);
+		}
+		list = list->next;
+		i++;
+	}
+	mutex_unlock(&mgr->mutex);
+
+
+#undef BUFPRINT
+	if (!buf)
+		pr_info("%s", sbuf);
+	return tsize;
+}
+
+
+
+static ssize_t
+box_dump_show(struct class *class,
+		       struct class_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	ret = decoder_mmu_box_dump_all(buf, PAGE_SIZE);
+	return ret;
+}
+
+
+
+static struct class_attribute decoder_mmu_box_class_attrs[] = {
+	__ATTR_RO(box_dump),
+	__ATTR_NULL
+};
+
+static struct class decoder_mmu_box_class = {
+	.name = "decoder_mmu_box",
+	.class_attrs = decoder_mmu_box_class_attrs,
+};
+
+
+static int __init decoder_mmu_box_init(void)
+{
+	int r;
+	memset(&global_mgr, 0, sizeof(global_mgr));
+	INIT_LIST_HEAD(&global_mgr.box_list);
+	mutex_init(&global_mgr.mutex);
+	global_mgr.next_id = START_KEEP_ID;
+	r = class_register(&decoder_mmu_box_class);
+	return r;
+}
+
+module_init(decoder_mmu_box_init);
+
diff --git a/drivers/amlogic/amports/decoder/decoder_mmu_box.h b/drivers/amlogic/amports/decoder/decoder_mmu_box.h
new file mode 100644
index 0000000..9fa73d9
--- /dev/null
+++ b/drivers/amlogic/amports/decoder/decoder_mmu_box.h
@@ -0,0 +1,44 @@
+/*
+ * drivers/amlogic/amports/decoder/decoder_mmu_box.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef DECODER_BUFFER_BOX
+#define DECODER_BUFFER_BOX
+
+void *decoder_mmu_box_alloc_box(const char *name,
+	int channel_id,
+	int max_num,
+	int min_size_M);
+
+int decoder_mmu_box_alloc_idx(
+	void *handle, int idx, int num_pages,
+	unsigned int *mmu_index_adr);
+
+int decoder_mmu_box_free_idx_tail(void *handle, int idx,
+		int start_release_index);
+
+int decoder_mmu_box_free_idx(void *handle, int idx);
+
+int decoder_mmu_box_free(void *handle);
+
+int decoder_mmu_box_move_keep_idx(void *box_handle,
+	int keep_idx);
+int decoder_mmu_box_free_keep(int keep_id);
+int decoder_mmu_box_free_all_keep(void);
+void *decoder_mmu_box_get_mem_handle(void *box_handle, int idx);
+
+#endif
+
diff --git a/drivers/amlogic/amports/esparser.c b/drivers/amlogic/amports/esparser.c
index aab12b1..2afe373 100644
--- a/drivers/amlogic/amports/esparser.c
+++ b/drivers/amlogic/amports/esparser.c
@@ -33,6 +33,7 @@
 /* #include <mach/am_regs.h> */
 #include <linux/delay.h>
 
+#include "vdec.h"
 #include "vdec_reg.h"
 #include "streambuf_reg.h"
 #include "streambuf.h"
@@ -124,7 +125,10 @@ static irqreturn_t esparser_isr(int irq, void *dev_id)
 
 static inline u32 buf_wp(u32 type)
 {
-	u32 wp =
+	u32 wp;
+
+	if ((READ_MPEG_REG(PARSER_ES_CONTROL) & ES_VID_MAN_RD_PTR) == 0) {
+		wp =
 #if 1/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
 		(type == BUF_TYPE_HEVC) ? READ_VREG(HEVC_STREAM_WR_PTR) :
 #endif
@@ -132,6 +136,16 @@ static inline u32 buf_wp(u32 type)
 		(type == BUF_TYPE_AUDIO) ?
 		READ_MPEG_REG(AIU_MEM_AIFIFO_MAN_WP) :
 		READ_MPEG_REG(PARSER_SUB_START_PTR);
+	} else {
+		wp =
+#if 1/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
+		(type == BUF_TYPE_HEVC) ? READ_MPEG_REG(PARSER_VIDEO_WP) :
+#endif
+		(type == BUF_TYPE_VIDEO) ? READ_MPEG_REG(PARSER_VIDEO_WP) :
+		(type == BUF_TYPE_AUDIO) ?
+			READ_MPEG_REG(AIU_MEM_AIFIFO_MAN_WP) :
+			READ_MPEG_REG(PARSER_SUB_START_PTR);
+	}
 
 	return wp;
 }
@@ -196,15 +210,18 @@ static ssize_t _esparser_write(const char __user *buf,
 			dma_unmap_single(amports_get_dma_device(), dma_addr,
 					FETCHBUF_SIZE, DMA_TO_DEVICE);
 		}
-		WRITE_MPEG_REG(PARSER_FETCH_CMD, (7 << FETCH_ENDIAN) | len);
 
 		search_done = 0;
-
-		WRITE_MPEG_REG(PARSER_FETCH_ADDR, search_pattern_map);
-
-		WRITE_MPEG_REG(PARSER_FETCH_CMD,
-			(7 << FETCH_ENDIAN) | SEARCH_PATTERN_LEN);
-
+		if (!(isphybuf & TYPE_PATTERN)) {
+			WRITE_MPEG_REG(PARSER_FETCH_CMD,
+				(7 << FETCH_ENDIAN) | len);
+			WRITE_MPEG_REG(PARSER_FETCH_ADDR, search_pattern_map);
+			WRITE_MPEG_REG(PARSER_FETCH_CMD,
+				(7 << FETCH_ENDIAN) | SEARCH_PATTERN_LEN);
+		} else {
+			WRITE_MPEG_REG(PARSER_FETCH_CMD,
+				(7 << FETCH_ENDIAN) | (len + 512));
+		}
 		ret = wait_event_interruptible_timeout(wq, search_done != 0,
 			HZ / 5);
 		if (ret == 0) {
@@ -347,7 +364,7 @@ s32 es_apts_checkin(struct stream_buf_s *buf, u32 pts)
 	return pts_checkin_offset(PTS_TYPE_AUDIO, passed, pts);
 }
 
-s32 esparser_init(struct stream_buf_s *buf)
+s32 esparser_init(struct stream_buf_s *buf, struct vdec_s *vdec)
 {
 	s32 r = 0;
 	u32 pts_type;
@@ -445,79 +462,89 @@ s32 esparser_init(struct stream_buf_s *buf)
 		WRITE_MPEG_REG(PARSER_CONTROL, PARSER_AUTOSEARCH);
 
 	}
-	/* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
+
 	/* hook stream buffer with PARSER */
 	if (has_hevc_vdec() && (pts_type == PTS_TYPE_HEVC)) {
-		CLEAR_VREG_MASK(HEVC_STREAM_CONTROL, 1);
-
-		WRITE_MPEG_REG(PARSER_VIDEO_START_PTR,
-				READ_VREG(HEVC_STREAM_START_ADDR));
-		WRITE_MPEG_REG(PARSER_VIDEO_END_PTR,
-				READ_VREG(HEVC_STREAM_END_ADDR) - 8);
-
-		CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
+		WRITE_MPEG_REG(PARSER_VIDEO_START_PTR, vdec->input.start);
+		WRITE_MPEG_REG(PARSER_VIDEO_END_PTR, vdec->input.start
+			+ vdec->input.size - 8);
 
-		/* set vififo_vbuf_rp_sel=>hevc */
-		WRITE_VREG(DOS_GEN_CTRL0, 3 << 1);
+		if (vdec_single(vdec)) {
+			CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL,
+				ES_VID_MAN_RD_PTR);
 
-		SET_VREG_MASK(HEVC_STREAM_CONTROL,
-			(1 << 3) | (0 << 4));	/* set use_parser_vbuf_wp */
-		/* set stream_fetch_enable */
-		SET_VREG_MASK(HEVC_STREAM_CONTROL, 1);
+			/* set vififo_vbuf_rp_sel=>hevc */
+			WRITE_VREG(DOS_GEN_CTRL0, 3 << 1);
 
-		SET_VREG_MASK(HEVC_STREAM_FIFO_CTL,
-			(1 << 29));/* set stream_buffer_hole with 256 bytes */
+			/* set use_parser_vbuf_wp */
+			SET_VREG_MASK(HEVC_STREAM_CONTROL,
+				(1 << 3) | (0 << 4));
+			/* set stream_fetch_enable */
+			SET_VREG_MASK(HEVC_STREAM_CONTROL, 1);
 
+			/* set stream_buffer_hole with 256 bytes */
+			SET_VREG_MASK(HEVC_STREAM_FIFO_CTL, (1 << 29));
+		} else {
+			SET_MPEG_REG_MASK(PARSER_ES_CONTROL,
+					ES_VID_MAN_RD_PTR);
+			WRITE_MPEG_REG(PARSER_VIDEO_WP, vdec->input.start);
+			WRITE_MPEG_REG(PARSER_VIDEO_RP, vdec->input.start);
+		}
 		video_data_parsed = 0;
-	} else
-		/* #endif */
-		if (pts_type == PTS_TYPE_VIDEO) {
-			WRITE_MPEG_REG(PARSER_VIDEO_START_PTR,
-				READ_VREG(VLD_MEM_VIFIFO_START_PTR));
-			WRITE_MPEG_REG(PARSER_VIDEO_END_PTR,
-				READ_VREG(VLD_MEM_VIFIFO_END_PTR));
+	} else if (pts_type == PTS_TYPE_VIDEO) {
+		WRITE_MPEG_REG(PARSER_VIDEO_START_PTR,
+			vdec->input.start);
+		WRITE_MPEG_REG(PARSER_VIDEO_END_PTR,
+			vdec->input.start + vdec->input.size - 8);
+		if (vdec_single(vdec)) {
 			CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL,
 				ES_VID_MAN_RD_PTR);
-			WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL,
-				MEM_BUFCTRL_INIT);
+
+			WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
 			CLEAR_VREG_MASK(VLD_MEM_VIFIFO_BUF_CNTL,
 				MEM_BUFCTRL_INIT);
 
 			if (has_hevc_vdec()) {
 				/* set vififo_vbuf_rp_sel=>vdec */
 				WRITE_VREG(DOS_GEN_CTRL0, 0);
-
 			}
-
-			video_data_parsed = 0;
-		} else if (pts_type == PTS_TYPE_AUDIO) {
-			/* set wp as buffer start */
-			SET_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL,
-				MEM_BUFCTRL_MANUAL);
-			WRITE_MPEG_REG(AIU_MEM_AIFIFO_MAN_RP,
-				READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-			WRITE_MPEG_REG_BITS(AIU_MEM_AIFIFO_CONTROL, 7, 3, 3);
-			SET_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL,
-				MEM_BUFCTRL_INIT);
-			CLEAR_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL,
-				MEM_BUFCTRL_INIT);
-			WRITE_MPEG_REG(AIU_MEM_AIFIFO_MAN_WP,
-				READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
-			audio_data_parsed = 0;
-			audio_buf_start =
-				READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR);
-			audio_real_wp = audio_buf_start;
-			audio_buf_end = READ_MPEG_REG(AIU_MEM_AIFIFO_END_PTR);
-		} else if (buf->type == BUF_TYPE_SUBTITLE) {
-			WRITE_MPEG_REG(PARSER_SUB_START_PTR,
-				parser_sub_start_ptr);
-			WRITE_MPEG_REG(PARSER_SUB_END_PTR,
-				parser_sub_end_ptr);
-			WRITE_MPEG_REG(PARSER_SUB_RP, parser_sub_rp);
+		} else {
 			SET_MPEG_REG_MASK(PARSER_ES_CONTROL,
-				(7 << ES_SUB_WR_ENDIAN_BIT) |
-				ES_SUB_MAN_RD_PTR);
+					ES_VID_MAN_RD_PTR);
+			WRITE_MPEG_REG(PARSER_VIDEO_WP,
+					vdec->input.start);
+			WRITE_MPEG_REG(PARSER_VIDEO_RP,
+					vdec->input.start);
 		}
+		video_data_parsed = 0;
+	} else if (pts_type == PTS_TYPE_AUDIO) {
+		/* set wp as buffer start */
+		SET_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL,
+			MEM_BUFCTRL_MANUAL);
+		WRITE_MPEG_REG(AIU_MEM_AIFIFO_MAN_RP,
+			READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
+		WRITE_MPEG_REG_BITS(AIU_MEM_AIFIFO_CONTROL, 7, 3, 3);
+		SET_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL,
+			MEM_BUFCTRL_INIT);
+		CLEAR_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL,
+			MEM_BUFCTRL_INIT);
+		WRITE_MPEG_REG(AIU_MEM_AIFIFO_MAN_WP,
+			READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
+		audio_data_parsed = 0;
+		audio_buf_start =
+			READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR);
+		audio_real_wp = audio_buf_start;
+		audio_buf_end = READ_MPEG_REG(AIU_MEM_AIFIFO_END_PTR);
+	} else if (buf->type == BUF_TYPE_SUBTITLE) {
+		WRITE_MPEG_REG(PARSER_SUB_START_PTR,
+			parser_sub_start_ptr);
+		WRITE_MPEG_REG(PARSER_SUB_END_PTR,
+			parser_sub_end_ptr);
+		WRITE_MPEG_REG(PARSER_SUB_RP, parser_sub_rp);
+		SET_MPEG_REG_MASK(PARSER_ES_CONTROL,
+			(7 << ES_SUB_WR_ENDIAN_BIT) |
+			ES_SUB_MAN_RD_PTR);
+	}
 
 	if (pts_type < PTS_TYPE_MAX) {
 		r = pts_start(pts_type);
@@ -557,9 +584,9 @@ s32 esparser_init(struct stream_buf_s *buf)
 	if (!(amports_get_debug_flags() & 1) &&
 		!codec_mm_video_tvp_enabled()) {
 		int block_size = (buf->type == BUF_TYPE_AUDIO) ?
-			PAGE_SIZE << 2 : PAGE_SIZE << 4;
+			PAGE_SIZE : PAGE_SIZE << 4;
 		int buf_num = (buf->type == BUF_TYPE_AUDIO) ?
-			5 : 10;
+			20 : (2 * SZ_1M)/(PAGE_SIZE << 4);
 		if (!(buf->type == BUF_TYPE_SUBTITLE))
 			buf->write_thread = threadrw_alloc(buf_num,
 				block_size,
@@ -712,11 +739,11 @@ ssize_t drm_write(struct file *file, struct stream_buf_s *stbuf,
 		return -EFAULT;
 	}
 
-	if (drm->drm_flag == TYPE_DRMINFO && (drm->drm_hasesdata == 0)) {
+	if ((drm->drm_flag & TYPE_DRMINFO) && (drm->drm_hasesdata == 0)) {
 		/* buf only has drminfo not have esdata; */
 		realbuf = drm->drm_phy;
 		realcount = drm->drm_pktsize;
-		isphybuf = 1;
+		isphybuf = drm->drm_flag;
 		/* DRM_PRNT("drm_get_rawdata
 		 *onlydrminfo drm->drm_hasesdata[0x%x]
 		 stbuf->type %d buf[0x%x]\n",
@@ -846,8 +873,39 @@ ssize_t esparser_write(struct file *file,
 			struct stream_buf_s *stbuf,
 			const char __user *buf, size_t count)
 {
-	if (stbuf->write_thread)
-		return threadrw_write(file, stbuf, buf, count);
+	if (stbuf->write_thread) {
+		ssize_t ret;
+		ret = threadrw_write(file, stbuf, buf, count);
+		if (ret == -EAGAIN) {
+			u32 a, b;
+			int vdelay, adelay;
+			if ((stbuf->type != BUF_TYPE_VIDEO) &&
+				(stbuf->type != BUF_TYPE_HEVC))
+				return ret;
+			if (stbuf->buf_size > (SZ_1M * 30) ||
+				(threadrw_buffer_size(stbuf) > SZ_1M * 10) ||
+				!threadrw_support_more_buffers(stbuf))
+				return ret;
+			/*only chang buffer for video.*/
+			vdelay = calculation_stream_delayed_ms(
+					PTS_TYPE_VIDEO, &a, &b);
+			adelay = calculation_stream_delayed_ms(
+					PTS_TYPE_AUDIO, &a, &b);
+			if ((vdelay > 100 && vdelay < 2000) && /*vdelay valid.*/
+				((vdelay < 500) ||/*video delay is short!*/
+				(adelay > 0 && adelay < 1000))/*audio is low.*/
+				) {
+				/*on buffer fulled.
+				if delay is less than 100ms we think errors,
+				And we add more buffer on delay < 2s.
+				*/
+				int new_size = 2 * 1024 * 1024;
+				threadrw_alloc_more_buffer_size(
+						stbuf, new_size);
+			}
+		}
+		return ret;
+	}
 	return esparser_write_ex(file, stbuf, buf, count, 0);
 }
 
diff --git a/drivers/amlogic/amports/esparser.h b/drivers/amlogic/amports/esparser.h
index 2d41cda..25527bf 100644
--- a/drivers/amlogic/amports/esparser.h
+++ b/drivers/amlogic/amports/esparser.h
@@ -18,15 +18,13 @@
 #ifndef ESPARSER_H
 #define ESPARSER_H
 
-extern s32 esparser_init(struct stream_buf_s *buf);
-
-extern void esparser_release(struct stream_buf_s *buf);
+#include "vdec.h"
 
 extern ssize_t drm_write(struct file *file,
 		struct stream_buf_s *stbuf,
 		const char __user *buf, size_t count);
 
-extern s32 esparser_init(struct stream_buf_s *buf);
+extern s32 esparser_init(struct stream_buf_s *buf, struct vdec_s *vdec);
 extern s32 esparser_init_s(struct stream_buf_s *buf);
 extern void esparser_release(struct stream_buf_s *buf);
 extern ssize_t esparser_write(struct file *file,
diff --git a/drivers/amlogic/amports/h264_dpb.c b/drivers/amlogic/amports/h264_dpb.c
new file mode 100644
index 0000000..5505677
--- /dev/null
+++ b/drivers/amlogic/amports/h264_dpb.c
@@ -0,0 +1,5238 @@
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+
+#include "vdec.h"
+#include "vdec_reg.h"
+#include "amvdec.h"
+
+#include "h264_dpb.h"
+
+/* #define OLD_OUTPUT_CODE */
+#undef pr_info
+#define pr_info printk
+int dpb_print(int index, int debug_flag, const char *fmt, ...)
+{
+	if (((h264_debug_flag & debug_flag) &&
+		((1 << index) & h264_debug_mask))
+		|| (debug_flag == PRINT_FLAG_ERROR)) {
+		unsigned char buf[512];
+		int len = 0;
+		va_list args;
+		va_start(args, fmt);
+		if ((index & 0x100) == 0)
+			len = sprintf(buf, "%d: ", index);
+		vsnprintf(buf + len, 512-len, fmt, args);
+		pr_info("%s", buf);
+		va_end(args);
+	}
+	return 0;
+}
+
+unsigned char dpb_is_debug(int index, int debug_flag)
+{
+	if (((h264_debug_flag & debug_flag) &&
+		((1 << index) & h264_debug_mask))
+		|| (debug_flag == PRINT_FLAG_ERROR))
+		return 1;
+	return 0;
+}
+
+#define CHECK_VALID(list_size, mark) {\
+	if (list_size > MAX_LIST_SIZE || list_size < 0) { \
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_ERROR, \
+		"%s(%d): listXsize[%d] %d is larger than max size\r\n",\
+		__func__, __LINE__, mark, list_size);\
+		list_size = 0; \
+	} \
+	}
+
+static struct DecRefPicMarking_s
+	dummy_dec_ref_pic_marking_buffer
+	[DEC_REF_PIC_MARKING_BUFFER_NUM_MAX];
+static struct StorablePicture dummy_pic;
+static struct FrameStore dummy_fs;
+static struct StorablePicture *get_new_pic(
+	struct h264_dpb_stru *p_H264_Dpb,
+	enum PictureStructure structure, unsigned char is_output);
+static void dump_dpb(struct DecodedPictureBuffer *p_Dpb);
+
+static void init_dummy_fs(void)
+{
+	dummy_fs.frame = &dummy_pic;
+	dummy_fs.top_field = &dummy_pic;
+	dummy_fs.bottom_field = &dummy_pic;
+
+	dummy_pic.top_field = &dummy_pic;
+	dummy_pic.bottom_field = &dummy_pic;
+	dummy_pic.frame = &dummy_pic;
+
+	dummy_pic.dec_ref_pic_marking_buffer =
+		&dummy_dec_ref_pic_marking_buffer[0];
+}
+
+enum {
+	LIST_0 = 0,
+	LIST_1 = 1,
+	BI_PRED = 2,
+	BI_PRED_L0 = 3,
+	BI_PRED_L1 = 4
+};
+
+void ref_pic_list_reordering(struct h264_dpb_stru *p_H264_Dpb,
+				struct Slice *currSlice)
+{
+	/* struct VideoParameters *p_Vid = currSlice->p_Vid;
+	   byte dP_nr = assignSE2partition[currSlice->dp_mode][SE_HEADER];
+	   DataPartition *partition = &(currSlice->partArr[dP_nr]);
+	   Bitstream *currStream = partition->bitstream;
+	 */
+	int i, j, val;
+	unsigned short *reorder_cmd =
+		&p_H264_Dpb->dpb_param.mmco.l0_reorder_cmd[0];
+	/* alloc_ref_pic_list_reordering_buffer(currSlice); */
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s\n", __func__);
+	if (currSlice->slice_type != I_SLICE &&
+		currSlice->slice_type != SI_SLICE) {
+		/* val = currSlice->ref_pic_list_reordering_flag[LIST_0] =
+			read_u_1 ("SH: ref_pic_list_reordering_flag_l0",
+				currStream, &p_Dec->UsedBits); */
+		if (reorder_cmd[0] != 3) {
+			val = currSlice->
+				ref_pic_list_reordering_flag[LIST_0] = 1;
+		} else {
+			val = currSlice->
+				ref_pic_list_reordering_flag[LIST_0] = 0;
+		}
+		if (val) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"%s, ref_pic_list_reordering_flag[LIST_0] is 1\n",
+				__func__);
+
+			j = 0;
+			i = 0;
+			do {
+				val = currSlice->
+				modification_of_pic_nums_idc[LIST_0][i] =
+					      reorder_cmd[j++];
+				/* read_ue_v(
+					"SH: modification_of_pic_nums_idc_l0",
+					currStream, &p_Dec->UsedBits); */
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL,
+					"%d(%d):val %x\n", i, j, val);
+				if (j >= 66) {
+					currSlice->
+					ref_pic_list_reordering_flag[LIST_0] =
+					0; /* by rain */
+					dpb_print(p_H264_Dpb->decoder_index,
+						PRINT_FLAG_ERROR,
+						"%s error\n", __func__);
+					break;
+				}
+				if (val == 0 || val == 1) {
+					currSlice->
+					abs_diff_pic_num_minus1[LIST_0][i] =
+					reorder_cmd[j++];
+					/* read_ue_v("SH: "
+					"abs_diff_pic_num_minus1_l0",
+					currStream, &p_Dec->UsedBits); */
+				} else {
+					if (val == 2) {
+						currSlice->
+						long_term_pic_idx[LIST_0][i] =
+						reorder_cmd[j++];
+						/* read_ue_v(
+						"SH: long_term_pic_idx_l0",
+						currStream,
+						&p_Dec->UsedBits); */
+					}
+				}
+				i++;
+				/* assert (i>currSlice->
+					num_ref_idx_active[LIST_0]); */
+				if (/*
+				     i>currSlice->num_ref_idx_active[LIST_0] ||
+				     */
+					i >= REORDERING_COMMAND_MAX_SIZE) {
+					dpb_print(p_H264_Dpb->decoder_index,
+						PRINT_FLAG_ERROR,
+						"%s error %d %d\n",
+						__func__, i,
+						currSlice->
+						num_ref_idx_active[LIST_0]);
+					currSlice->
+					ref_pic_list_reordering_flag[LIST_0] =
+					0; /* by rain */
+					break;
+				}
+				if (j >= 66) {
+					dpb_print(p_H264_Dpb->decoder_index,
+						PRINT_FLAG_ERROR, "%s error\n",
+						__func__);
+					currSlice->
+					ref_pic_list_reordering_flag[LIST_0] =
+					0; /* by rain */
+					break;
+				}
+
+			} while (val != 3);
+		}
+	}
+
+	if (currSlice->slice_type == B_SLICE) {
+		reorder_cmd = &p_H264_Dpb->dpb_param.mmco.l1_reorder_cmd[0];
+		/* val = currSlice->ref_pic_list_reordering_flag[LIST_1]
+		= read_u_1 ("SH: ref_pic_list_reordering_flag_l1",
+		currStream,
+		&p_Dec->UsedBits); */
+
+		if (reorder_cmd[0] != 3) {
+			val =
+			currSlice->ref_pic_list_reordering_flag[LIST_1] = 1;
+		} else {
+			val =
+			currSlice->ref_pic_list_reordering_flag[LIST_1] = 0;
+		}
+
+		if (val) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"%s, ref_pic_list_reordering_flag[LIST_1] is 1\n",
+				__func__);
+
+			j = 0;
+			i = 0;
+			do {
+				val = currSlice->
+				modification_of_pic_nums_idc[LIST_1][i] =
+				reorder_cmd[j++];
+				/* read_ue_v(
+				"SH: modification_of_pic_nums_idc_l1",
+				currStream,
+				&p_Dec->UsedBits); */
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL,
+					"%d(%d):val %x\n",
+					i, j, val);
+				if (j >= 66) {
+					dpb_print(p_H264_Dpb->decoder_index,
+						PRINT_FLAG_ERROR, "%s error\n",
+						__func__);
+					currSlice->
+					ref_pic_list_reordering_flag[LIST_1] =
+					0;  /* by rain */
+					break;
+				}
+				if (val == 0 || val == 1) {
+					currSlice->
+					abs_diff_pic_num_minus1[LIST_1][i] =
+						reorder_cmd[j++];
+					/* read_ue_v(
+					"SH: abs_diff_pic_num_minus1_l1",
+					currStream, &p_Dec->UsedBits); */
+				} else {
+					if (val == 2) {
+						currSlice->
+						long_term_pic_idx[LIST_1][i] =
+						reorder_cmd[j++];
+						/* read_ue_v(
+						"SH: long_term_pic_idx_l1",
+						currStream,
+						&p_Dec->UsedBits); */
+					}
+				}
+				i++;
+				/* assert(i>currSlice->
+					num_ref_idx_active[LIST_1]); */
+				if (
+				/*i>currSlice->num_ref_idx_active[LIST_1] || */
+					i >= REORDERING_COMMAND_MAX_SIZE) {
+					dpb_print(p_H264_Dpb->decoder_index,
+						PRINT_FLAG_ERROR,
+						"%s error %d %d\n",
+						__func__, i,
+						currSlice->
+						num_ref_idx_active[LIST_0]);
+					currSlice->
+					ref_pic_list_reordering_flag[LIST_1] =
+					0;  /* by rain */
+					break;
+				}
+				if (j >= 66) {
+					dpb_print(p_H264_Dpb->decoder_index,
+						PRINT_FLAG_ERROR,
+						"%s error\n", __func__);
+					break;
+				}
+			} while (val != 3);
+		}
+	}
+
+	/* set reference index of redundant slices. */
+	/*
+	if(currSlice->redundant_pic_cnt && (currSlice->slice_type != I_SLICE))
+	{
+	  currSlice->redundant_slice_ref_idx =
+		currSlice->abs_diff_pic_num_minus1[LIST_0][0] + 1;
+	}*/
+}
+
+void slice_prepare(struct h264_dpb_stru *p_H264_Dpb,
+		struct DecodedPictureBuffer *p_Dpb,
+		struct VideoParameters *p_Vid,
+		struct SPSParameters *sps, struct Slice *pSlice)
+{
+	int i, j;
+	/* p_Vid->active_sps = sps; */
+	unsigned short *mmco_cmd = &p_H264_Dpb->dpb_param.mmco.mmco_cmd[0];
+	/* for decode_poc */
+	sps->pic_order_cnt_type =
+		p_H264_Dpb->dpb_param.l.data[PIC_ORDER_CNT_TYPE];
+	sps->log2_max_pic_order_cnt_lsb_minus4 =
+		p_H264_Dpb->dpb_param.l.data[LOG2_MAX_PIC_ORDER_CNT_LSB] - 4;
+	sps->num_ref_frames_in_pic_order_cnt_cycle =
+		p_H264_Dpb->
+		dpb_param.l.data[NUM_REF_FRAMES_IN_PIC_ORDER_CNT_CYCLE];
+	for (i = 0; i < 128; i++)
+		sps->offset_for_ref_frame[i] =
+			(short) p_H264_Dpb->
+			dpb_param.mmco.offset_for_ref_frame_base[i];
+	sps->offset_for_non_ref_pic =
+		(short) p_H264_Dpb->dpb_param.l.data[OFFSET_FOR_NON_REF_PIC];
+	sps->offset_for_top_to_bottom_field =
+		(short) p_H264_Dpb->dpb_param.l.data
+		[OFFSET_FOR_TOP_TO_BOTTOM_FIELD];
+
+	pSlice->frame_num = p_H264_Dpb->dpb_param.dpb.frame_num;
+	pSlice->idr_flag =
+		(p_H264_Dpb->dpb_param.dpb.NAL_info_mmco & 0x1f)
+		== 5 ? 1 : 0;
+	pSlice->nal_reference_idc =
+		(p_H264_Dpb->dpb_param.dpb.NAL_info_mmco >> 5)
+		& 0x3;
+	pSlice->pic_order_cnt_lsb =
+		p_H264_Dpb->dpb_param.dpb.pic_order_cnt_lsb;
+	pSlice->field_pic_flag = 0;
+	pSlice->bottom_field_flag = 0;
+	pSlice->delta_pic_order_cnt_bottom = val(
+		p_H264_Dpb->dpb_param.dpb.delta_pic_order_cnt_bottom);
+	pSlice->delta_pic_order_cnt[0] = val(
+		p_H264_Dpb->dpb_param.dpb.delta_pic_order_cnt_0);
+	pSlice->delta_pic_order_cnt[1] = val(
+		p_H264_Dpb->dpb_param.dpb.delta_pic_order_cnt_1);
+
+	p_Vid->last_has_mmco_5 = 0;
+	/* last memory_management_control_operation is 5 */
+	p_Vid->last_pic_bottom_field = 0;
+	p_Vid->max_frame_num = 1 <<
+	(p_H264_Dpb->dpb_param.l.data[LOG2_MAX_FRAME_NUM]);
+
+	/**/
+	pSlice->structure = (p_H264_Dpb->
+		dpb_param.l.data[NEW_PICTURE_STRUCTURE] == 3) ?
+		FRAME : p_H264_Dpb->dpb_param.l.data[NEW_PICTURE_STRUCTURE];
+	sps->num_ref_frames = p_H264_Dpb->
+		dpb_param.l.data[MAX_REFERENCE_FRAME_NUM];
+	sps->max_dpb_size = p_H264_Dpb->dpb_param.l.data[MAX_DPB_SIZE];
+	if (pSlice->idr_flag) {
+		pSlice->long_term_reference_flag = mmco_cmd[0] & 1;
+		pSlice->no_output_of_prior_pics_flag = (mmco_cmd[0] >> 1) & 1;
+		dpb_print(p_H264_Dpb->decoder_index,
+		PRINT_FLAG_DPB_DETAIL,
+		"IDR: long_term_reference_flag %d no_output_of_prior_pics_flag %d\r\n",
+		pSlice->long_term_reference_flag,
+		pSlice->no_output_of_prior_pics_flag);
+
+		dpb_print(p_H264_Dpb->decoder_index,
+		PRINT_FLAG_DPB_DETAIL,
+		"idr set pre_frame_num(%d) to frame_num (%d)\n",
+		p_Vid->pre_frame_num, pSlice->frame_num);
+
+		p_Vid->pre_frame_num = pSlice->frame_num;
+	}
+	/* pSlice->adaptive_ref_pic_buffering_flag; */
+	sps->log2_max_frame_num_minus4 =
+		p_H264_Dpb->dpb_param.l.data[LOG2_MAX_FRAME_NUM] - 4;
+
+	p_Vid->non_conforming_stream =
+		p_H264_Dpb->dpb_param.l.data[NON_CONFORMING_STREAM];
+	p_Vid->recovery_point =
+		p_H264_Dpb->dpb_param.l.data[RECOVERY_POINT];
+	switch (p_H264_Dpb->dpb_param.l.data[SLICE_TYPE]) {
+	case I_Slice:
+		pSlice->slice_type = I_SLICE;
+		break;
+	case P_Slice:
+		pSlice->slice_type = P_SLICE;
+		break;
+	case B_Slice:
+		pSlice->slice_type = B_SLICE;
+		break;
+	default:
+		pSlice->slice_type = NUM_SLICE_TYPES;
+		break;
+	}
+
+	pSlice->num_ref_idx_active[LIST_0] =
+		p_H264_Dpb->dpb_param.dpb.num_ref_idx_l0_active_minus1 +
+		1;
+	/* p_H264_Dpb->dpb_param.l.data[PPS_NUM_REF_IDX_L0_ACTIVE_MINUS1]; */
+	pSlice->num_ref_idx_active[LIST_1] =
+		p_H264_Dpb->dpb_param.dpb.num_ref_idx_l1_active_minus1 +
+		1;
+	/* p_H264_Dpb->dpb_param.l.data[PPS_NUM_REF_IDX_L1_ACTIVE_MINUS1]; */
+
+	pSlice->p_Vid = p_Vid;
+	pSlice->p_Dpb = p_Dpb;
+
+	p_H264_Dpb->colocated_buf_size =
+		p_H264_Dpb->dpb_param.l.data[FRAME_SIZE_IN_MB] * 96;
+	pSlice->first_mb_in_slice =
+		p_H264_Dpb->dpb_param.l.data[FIRST_MB_IN_SLICE];
+	pSlice->mode_8x8_flags = p_H264_Dpb->dpb_param.l.data[MODE_8X8_FLAGS];
+	pSlice->picture_structure_mmco =
+		p_H264_Dpb->dpb_param.dpb.picture_structure_mmco;
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		  "%s slice_type is %d, num_ref_idx_active[0]=%d, num_ref_idx_active[1]=%d nal_reference_idc %d\n",
+		  __func__, pSlice->slice_type,
+		  pSlice->num_ref_idx_active[LIST_0],
+		  pSlice->num_ref_idx_active[LIST_1],
+		  pSlice->nal_reference_idc);
+#ifdef ERROR_CHECK
+	if (pSlice->num_ref_idx_active[LIST_0] >= MAX_LIST_SIZE)
+		pSlice->num_ref_idx_active[LIST_0] = MAX_LIST_SIZE - 1;
+	if (pSlice->num_ref_idx_active[LIST_1] >= MAX_LIST_SIZE)
+		pSlice->num_ref_idx_active[LIST_1] = MAX_LIST_SIZE - 1;
+#endif
+
+#if 1
+	/* dec_ref_pic_marking_buffer */
+	pSlice->adaptive_ref_pic_buffering_flag = 0;
+	if (pSlice->nal_reference_idc) {
+		for (i = 0, j = 0; i < 44; j++) {
+			unsigned short val;
+			struct DecRefPicMarking_s *tmp_drpm =
+				&pSlice->dec_ref_pic_marking_buffer[j];
+			memset(tmp_drpm, 0, sizeof(struct DecRefPicMarking_s));
+			val = tmp_drpm->
+				memory_management_control_operation =
+					mmco_cmd[i++];
+			tmp_drpm->Next = NULL;
+			if (j > 0) {
+				pSlice->
+				dec_ref_pic_marking_buffer[j - 1].Next =
+					tmp_drpm;
+			}
+			if (val == 0 || i >= 44)
+				break;
+			pSlice->adaptive_ref_pic_buffering_flag = 1;
+			if ((val == 1) || (val == 3)) {
+				tmp_drpm->difference_of_pic_nums_minus1 =
+					mmco_cmd[i++];
+			}
+			if (val == 2)
+				tmp_drpm->long_term_pic_num = mmco_cmd[i++];
+			if (i >= 44)
+				break;
+			if ((val == 3) || (val == 6))
+				tmp_drpm->long_term_frame_idx = mmco_cmd[i++];
+			if (val == 4) {
+				tmp_drpm->max_long_term_frame_idx_plus1 =
+					mmco_cmd[i++];
+			}
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"dec_ref_pic_marking_buffer[%d]:operation %x diff_pic_minus1 %x long_pic_num %x long_frame_idx %x max_long_frame_idx_plus1 %x\n",
+				j,
+				tmp_drpm->memory_management_control_operation,
+				tmp_drpm->difference_of_pic_nums_minus1,
+				tmp_drpm->long_term_pic_num,
+				tmp_drpm->long_term_frame_idx,
+				tmp_drpm->max_long_term_frame_idx_plus1);
+		}
+	}
+
+	ref_pic_list_reordering(p_H264_Dpb, pSlice);
+#endif
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s return\n", __func__);
+}
+
+static void decode_poc(struct VideoParameters *p_Vid, struct Slice *pSlice)
+{
+	struct h264_dpb_stru *p_H264_Dpb = container_of(p_Vid,
+					struct h264_dpb_stru, mVideo);
+	struct SPSParameters *active_sps = p_Vid->active_sps;
+	int i;
+	/* for POC mode 0: */
+	unsigned int MaxPicOrderCntLsb = (1 <<
+		(active_sps->log2_max_pic_order_cnt_lsb_minus4 + 4));
+
+	dpb_print(p_H264_Dpb->decoder_index,
+		PRINT_FLAG_DEBUG_POC,
+		"%s:pic_order_cnt_type %d, idr_flag %d last_has_mmco_5 %d last_pic_bottom_field %d pic_order_cnt_lsb %d PrevPicOrderCntLsb %d\r\n",
+		__func__,
+		active_sps->pic_order_cnt_type,
+		pSlice->idr_flag,
+		p_Vid->last_has_mmco_5,
+		p_Vid->last_pic_bottom_field,
+		pSlice->pic_order_cnt_lsb,
+		p_Vid->PrevPicOrderCntLsb
+	);
+
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DEBUG_POC,
+	"%s:field_pic_flag %d, bottom_field_flag %d frame_num %d PreviousFrameNum %d PreviousFrameNumOffset %d ax_frame_num %d num_ref_frames_in_pic_order_cnt_cycle %d offset_for_non_ref_pic %d\r\n",
+		__func__,
+		pSlice->field_pic_flag,
+		pSlice->bottom_field_flag,
+		pSlice->frame_num,
+		p_Vid->PreviousFrameNum,
+		p_Vid->PreviousFrameNumOffset,
+		p_Vid->max_frame_num,
+		active_sps->num_ref_frames_in_pic_order_cnt_cycle,
+		active_sps->offset_for_non_ref_pic
+	);
+
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DEBUG_POC,
+	"%s: delta_pic_order_cnt %d %d nal_reference_idc %d\r\n",
+	__func__,
+	pSlice->delta_pic_order_cnt[0], pSlice->delta_pic_order_cnt[1],
+	pSlice->nal_reference_idc
+	);
+
+
+	switch (active_sps->pic_order_cnt_type) {
+	case 0: /* POC MODE 0 */
+		/* 1st */
+		if (pSlice->idr_flag) {
+			p_Vid->PrevPicOrderCntMsb = 0;
+			p_Vid->PrevPicOrderCntLsb = 0;
+		} else {
+			if (p_Vid->last_has_mmco_5) {
+				if (p_Vid->last_pic_bottom_field) {
+					p_Vid->PrevPicOrderCntMsb = 0;
+					p_Vid->PrevPicOrderCntLsb = 0;
+				} else {
+					p_Vid->PrevPicOrderCntMsb = 0;
+					p_Vid->PrevPicOrderCntLsb =
+						pSlice->toppoc;
+				}
+			}
+		}
+		/* Calculate the MSBs of current picture */
+		if (pSlice->pic_order_cnt_lsb < p_Vid->PrevPicOrderCntLsb &&
+		    (p_Vid->PrevPicOrderCntLsb - pSlice->pic_order_cnt_lsb) >=
+		    (MaxPicOrderCntLsb / 2))
+			pSlice->PicOrderCntMsb = p_Vid->PrevPicOrderCntMsb +
+					MaxPicOrderCntLsb;
+		else if (pSlice->pic_order_cnt_lsb >
+				p_Vid->PrevPicOrderCntLsb &&
+			 (pSlice->pic_order_cnt_lsb -
+				p_Vid->PrevPicOrderCntLsb)  >
+				 (MaxPicOrderCntLsb / 2))
+			pSlice->PicOrderCntMsb = p_Vid->PrevPicOrderCntMsb -
+					MaxPicOrderCntLsb;
+		else
+			pSlice->PicOrderCntMsb = p_Vid->PrevPicOrderCntMsb;
+
+		/* 2nd */
+		if (pSlice->field_pic_flag == 0) {
+			/* frame pix */
+			pSlice->toppoc = pSlice->PicOrderCntMsb +
+					pSlice->pic_order_cnt_lsb;
+			pSlice->bottompoc = pSlice->toppoc +
+					pSlice->delta_pic_order_cnt_bottom;
+			pSlice->ThisPOC = pSlice->framepoc =
+				(pSlice->toppoc < pSlice->bottompoc) ?
+				 pSlice->toppoc : pSlice->bottompoc;
+					/* POC200301 */
+		} else if (pSlice->bottom_field_flag == FALSE) {
+			/* top field */
+			pSlice->ThisPOC = pSlice->toppoc =
+				pSlice->PicOrderCntMsb +
+				pSlice->pic_order_cnt_lsb;
+		} else {
+			/* bottom field */
+			pSlice->ThisPOC = pSlice->bottompoc =
+				pSlice->PicOrderCntMsb +
+				pSlice->pic_order_cnt_lsb;
+		}
+		pSlice->framepoc = pSlice->ThisPOC;
+
+		p_Vid->ThisPOC = pSlice->ThisPOC;
+
+		/* if ( pSlice->frame_num != p_Vid->PreviousFrameNum)
+			Seems redundant */
+		p_Vid->PreviousFrameNum = pSlice->frame_num;
+
+		if (pSlice->nal_reference_idc) {
+			p_Vid->PrevPicOrderCntLsb = pSlice->pic_order_cnt_lsb;
+			p_Vid->PrevPicOrderCntMsb = pSlice->PicOrderCntMsb;
+		}
+
+		break;
+
+	case 1: /* POC MODE 1 */
+		/* 1st */
+		if (pSlice->idr_flag) {
+			p_Vid->FrameNumOffset = 0;   /* first pix of IDRGOP */
+			if (pSlice->frame_num)
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL,
+					"frame_num not equal to zero in IDR picture %d",
+					-1020);
+		} else {
+			if (p_Vid->last_has_mmco_5) {
+				p_Vid->PreviousFrameNumOffset = 0;
+				p_Vid->PreviousFrameNum = 0;
+			}
+			if (pSlice->frame_num < p_Vid->PreviousFrameNum) {
+				/* not first pix of IDRGOP */
+				p_Vid->FrameNumOffset =
+					p_Vid->PreviousFrameNumOffset +
+						p_Vid->max_frame_num;
+			} else {
+				p_Vid->FrameNumOffset =
+					p_Vid->PreviousFrameNumOffset;
+			}
+		}
+
+		/* 2nd */
+		if (active_sps->num_ref_frames_in_pic_order_cnt_cycle)
+			pSlice->AbsFrameNum =
+				p_Vid->FrameNumOffset + pSlice->frame_num;
+		else
+			pSlice->AbsFrameNum = 0;
+		if ((!pSlice->nal_reference_idc) && pSlice->AbsFrameNum > 0)
+			pSlice->AbsFrameNum--;
+
+		/* 3rd */
+		p_Vid->ExpectedDeltaPerPicOrderCntCycle = 0;
+
+		if (active_sps->num_ref_frames_in_pic_order_cnt_cycle)
+			for (i = 0; i < (int) active_sps->
+				num_ref_frames_in_pic_order_cnt_cycle; i++) {
+				p_Vid->ExpectedDeltaPerPicOrderCntCycle +=
+					active_sps->offset_for_ref_frame[i];
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DEBUG_POC,
+					"%s: offset_for_ref_frame %d\r\n",
+					__func__,
+					active_sps->
+					offset_for_ref_frame[i]);
+			}
+
+		if (pSlice->AbsFrameNum) {
+			p_Vid->PicOrderCntCycleCnt =
+				(pSlice->AbsFrameNum - 1) /
+				active_sps->
+				num_ref_frames_in_pic_order_cnt_cycle;
+			p_Vid->FrameNumInPicOrderCntCycle =
+				(pSlice->AbsFrameNum - 1) %
+				active_sps->
+				num_ref_frames_in_pic_order_cnt_cycle;
+			p_Vid->ExpectedPicOrderCnt =
+				p_Vid->PicOrderCntCycleCnt *
+				p_Vid->ExpectedDeltaPerPicOrderCntCycle;
+			for (i = 0; i <= (int)p_Vid->
+				FrameNumInPicOrderCntCycle; i++) {
+				p_Vid->ExpectedPicOrderCnt +=
+					active_sps->offset_for_ref_frame[i];
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DEBUG_POC,
+					"%s: offset_for_ref_frame %d\r\n",
+					__func__,
+					active_sps->
+					offset_for_ref_frame[i]);
+			}
+		} else
+			p_Vid->ExpectedPicOrderCnt = 0;
+
+		if (!pSlice->nal_reference_idc)
+			p_Vid->ExpectedPicOrderCnt +=
+				active_sps->offset_for_non_ref_pic;
+
+		if (pSlice->field_pic_flag == 0) {
+			/* frame pix */
+			pSlice->toppoc = p_Vid->ExpectedPicOrderCnt +
+				pSlice->delta_pic_order_cnt[0];
+			pSlice->bottompoc = pSlice->toppoc +
+				active_sps->offset_for_top_to_bottom_field +
+				pSlice->delta_pic_order_cnt[1];
+			pSlice->ThisPOC = pSlice->framepoc =
+				(pSlice->toppoc < pSlice->bottompoc) ?
+				pSlice->toppoc : pSlice->bottompoc;
+				/* POC200301 */
+		} else if (pSlice->bottom_field_flag == FALSE) {
+			/* top field */
+			pSlice->ThisPOC = pSlice->toppoc =
+				p_Vid->ExpectedPicOrderCnt +
+				pSlice->delta_pic_order_cnt[0];
+		} else {
+			/* bottom field */
+			pSlice->ThisPOC = pSlice->bottompoc =
+				p_Vid->ExpectedPicOrderCnt +
+				active_sps->offset_for_top_to_bottom_field +
+				pSlice->delta_pic_order_cnt[0];
+		}
+		pSlice->framepoc = pSlice->ThisPOC;
+
+		p_Vid->PreviousFrameNum = pSlice->frame_num;
+		p_Vid->PreviousFrameNumOffset = p_Vid->FrameNumOffset;
+
+		break;
+
+
+	case 2: /* POC MODE 2 */
+		if (pSlice->idr_flag) { /* IDR picture */
+			p_Vid->FrameNumOffset = 0;   /* first pix of IDRGOP */
+			pSlice->ThisPOC = pSlice->framepoc = pSlice->toppoc =
+				pSlice->bottompoc = 0;
+			if (pSlice->frame_num)
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL,
+					"frame_num not equal to zero in IDR picture %d",
+					-1020);
+		} else {
+			if (p_Vid->last_has_mmco_5) {
+				p_Vid->PreviousFrameNum = 0;
+				p_Vid->PreviousFrameNumOffset = 0;
+			}
+			if (pSlice->frame_num < p_Vid->PreviousFrameNum)
+				p_Vid->FrameNumOffset =
+					p_Vid->PreviousFrameNumOffset +
+					p_Vid->max_frame_num;
+			else
+				p_Vid->FrameNumOffset =
+					p_Vid->PreviousFrameNumOffset;
+
+			pSlice->AbsFrameNum = p_Vid->FrameNumOffset +
+				pSlice->frame_num;
+			if (!pSlice->nal_reference_idc)
+				pSlice->ThisPOC =
+					(2 * pSlice->AbsFrameNum - 1);
+			else
+				pSlice->ThisPOC = (2 * pSlice->AbsFrameNum);
+
+			if (pSlice->field_pic_flag == 0)
+				pSlice->toppoc = pSlice->bottompoc =
+					pSlice->framepoc = pSlice->ThisPOC;
+			else if (pSlice->bottom_field_flag == FALSE)
+				pSlice->toppoc = pSlice->framepoc =
+				pSlice->ThisPOC;
+			else
+				pSlice->bottompoc = pSlice->framepoc =
+				pSlice->ThisPOC;
+		}
+
+		p_Vid->PreviousFrameNum = pSlice->frame_num;
+		p_Vid->PreviousFrameNumOffset = p_Vid->FrameNumOffset;
+		break;
+
+
+	default:
+		/* error must occurs */
+		/* assert( 1==0 ); */
+		break;
+	}
+}
+
+void fill_frame_num_gap(struct VideoParameters *p_Vid, struct Slice *currSlice)
+{
+	struct h264_dpb_stru *p_H264_Dpb =
+		container_of(p_Vid, struct h264_dpb_stru, mVideo);
+	struct SPSParameters *active_sps = p_Vid->active_sps;
+	int CurrFrameNum;
+	int UnusedShortTermFrameNum;
+	struct StorablePicture *picture = NULL;
+	int tmp1 = currSlice->delta_pic_order_cnt[0];
+	int tmp2 = currSlice->delta_pic_order_cnt[1];
+	currSlice->delta_pic_order_cnt[0] =
+		currSlice->delta_pic_order_cnt[1] = 0;
+
+	dpb_print(p_H264_Dpb->decoder_index,
+		PRINT_FLAG_DPB_DETAIL,
+		"A gap in frame number is found, try to fill it.(pre_frame_num %d, max_frame_num %d\n",
+		p_Vid->pre_frame_num, p_Vid->max_frame_num
+	);
+
+	UnusedShortTermFrameNum = (p_Vid->pre_frame_num + 1)
+		% p_Vid->max_frame_num;
+	CurrFrameNum = currSlice->frame_num; /*p_Vid->frame_num;*/
+
+	while (CurrFrameNum != UnusedShortTermFrameNum) {
+		/*picture = alloc_storable_picture
+		(p_Vid, FRAME, p_Vid->width,
+		p_Vid->height,
+		p_Vid->width_cr,
+		p_Vid->height_cr, 1);*/
+		picture = get_new_pic(p_H264_Dpb,
+			p_H264_Dpb->mSlice.structure,
+		/*p_Vid->width, p_Vid->height,
+		p_Vid->width_cr,
+		p_Vid->height_cr,*/ 1);
+
+		if (picture == NULL) {
+			struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_ERROR,
+				"%s Error: get_new_pic return NULL\r\n",
+				__func__);
+			h264_debug_flag |= PRINT_FLAG_DUMP_DPB;
+			dump_dpb(p_Dpb);
+			return;
+		}
+
+		picture->colocated_buf_index = -1;
+		picture->buf_spec_num = -1;
+
+		picture->coded_frame = 1;
+		picture->pic_num = UnusedShortTermFrameNum;
+		picture->frame_num = UnusedShortTermFrameNum;
+		picture->non_existing = 1;
+		picture->is_output = 1;
+		picture->used_for_reference = 1;
+		picture->adaptive_ref_pic_buffering_flag = 0;
+		#if (MVC_EXTENSION_ENABLE)
+		picture->view_id = currSlice->view_id;
+		#endif
+
+		currSlice->frame_num = UnusedShortTermFrameNum;
+		if (active_sps->pic_order_cnt_type != 0) {
+			/*decode_poc(p_Vid, p_Vid->ppSliceList[0]);*/
+			decode_poc(&p_H264_Dpb->mVideo, &p_H264_Dpb->mSlice);
+		}
+		picture->top_poc    = currSlice->toppoc;
+		picture->bottom_poc = currSlice->bottompoc;
+		picture->frame_poc  = currSlice->framepoc;
+		picture->poc        = currSlice->framepoc;
+
+		store_picture_in_dpb(p_H264_Dpb, picture);
+
+		picture = NULL;
+		p_Vid->pre_frame_num = UnusedShortTermFrameNum;
+		UnusedShortTermFrameNum =
+			(UnusedShortTermFrameNum + 1) %
+			p_Vid->max_frame_num;
+	}
+	currSlice->delta_pic_order_cnt[0] = tmp1;
+	currSlice->delta_pic_order_cnt[1] = tmp2;
+	currSlice->frame_num = CurrFrameNum;
+}
+
+void dpb_init_global(struct h264_dpb_stru *p_H264_Dpb,
+	int id, int actual_dpb_size, int max_reference_size)
+{
+	int i;
+	init_dummy_fs();
+
+	memset(&p_H264_Dpb->mDPB, 0, sizeof(struct DecodedPictureBuffer));
+
+	memset(&p_H264_Dpb->mSlice, 0, sizeof(struct Slice));
+	memset(&p_H264_Dpb->mVideo, 0, sizeof(struct VideoParameters));
+	memset(&p_H264_Dpb->mSPS, 0, sizeof(struct SPSParameters));
+
+	for (i = 0; i < DPB_SIZE_MAX; i++) {
+		memset(&(p_H264_Dpb->mFrameStore[i]), 0,
+			sizeof(struct FrameStore));
+	}
+
+	for (i = 0; i < MAX_PIC_BUF_NUM; i++) {
+		memset(&(p_H264_Dpb->m_PIC[i]), 0,
+			sizeof(struct StorablePicture));
+		p_H264_Dpb->m_PIC[i].index = i;
+	}
+	p_H264_Dpb->decoder_index = id;
+
+    /* make sure dpb_init_global
+    can be called during decoding
+    (in DECODE_STATE_IDLE or DECODE_STATE_READY state) */
+	p_H264_Dpb->mDPB.size = actual_dpb_size;
+	p_H264_Dpb->max_reference_size = max_reference_size;
+}
+
+static void init_picture(struct h264_dpb_stru *p_H264_Dpb,
+			 struct Slice *currSlice,
+			 struct StorablePicture *dec_picture)
+{
+	/* struct VideoParameters *p_Vid = &(p_H264_Dpb->mVideo); */
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		  "%s dec_picture %p\n", __func__, dec_picture);
+	dec_picture->top_poc = currSlice->toppoc;
+	dec_picture->bottom_poc = currSlice->bottompoc;
+	dec_picture->frame_poc = currSlice->framepoc;
+	switch (currSlice->structure) {
+	case TOP_FIELD: {
+		dec_picture->poc = currSlice->toppoc;
+		/* p_Vid->number *= 2; */
+		break;
+	}
+	case BOTTOM_FIELD: {
+		dec_picture->poc = currSlice->bottompoc;
+		/* p_Vid->number = p_Vid->number * 2 + 1; */
+		break;
+	}
+	case FRAME: {
+		dec_picture->poc = currSlice->framepoc;
+		break;
+	}
+	default:
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			  "p_Vid->structure not initialized %d\n", 235);
+	}
+
+	/* dec_picture->slice_type = p_Vid->type; */
+	dec_picture->used_for_reference = (currSlice->nal_reference_idc != 0);
+	dec_picture->idr_flag = currSlice->idr_flag;
+	dec_picture->no_output_of_prior_pics_flag =
+		currSlice->no_output_of_prior_pics_flag;
+	dec_picture->long_term_reference_flag =
+		currSlice->long_term_reference_flag;
+#if 1
+	dec_picture->adaptive_ref_pic_buffering_flag =
+		currSlice->adaptive_ref_pic_buffering_flag;
+	dec_picture->dec_ref_pic_marking_buffer =
+		&currSlice->dec_ref_pic_marking_buffer[0];
+#endif
+	/* currSlice->dec_ref_pic_marking_buffer   = NULL; */
+
+	/* dec_picture->mb_aff_frame_flag = currSlice->mb_aff_frame_flag; */
+	/* dec_picture->PicWidthInMbs     = p_Vid->PicWidthInMbs; */
+
+	/* p_Vid->get_mb_block_pos =
+		dec_picture->mb_aff_frame_flag ? get_mb_block_pos_mbaff :
+		get_mb_block_pos_normal; */
+	/* p_Vid->getNeighbour     =
+		dec_picture->mb_aff_frame_flag ? getAffNeighbour :
+		getNonAffNeighbour; */
+
+	dec_picture->pic_num   = currSlice->frame_num;
+	dec_picture->frame_num = currSlice->frame_num;
+
+	/* dec_picture->recovery_frame =
+		(unsigned int) ((int) currSlice->frame_num ==
+		p_Vid->recovery_frame_num); */
+
+	dec_picture->coded_frame = (currSlice->structure == FRAME);
+
+	/* dec_picture->chroma_format_idc = active_sps->chroma_format_idc; */
+
+	/* dec_picture->frame_mbs_only_flag =
+		active_sps->frame_mbs_only_flag; */
+	/* dec_picture->frame_cropping_flag =
+		active_sps->frame_cropping_flag; */
+
+	if ((currSlice->picture_structure_mmco & 0x3) == 3) {
+		dec_picture->mb_aff_frame_flag = 1;
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			"%s, picture_structure_mmco is %x, set mb_aff_frame_flag to 1\n",
+			__func__,
+			currSlice->picture_structure_mmco);
+	}
+
+}
+
+static struct StorablePicture *get_new_pic(struct h264_dpb_stru *p_H264_Dpb,
+		enum PictureStructure structure, unsigned char is_output)
+{
+	struct StorablePicture *s = NULL;
+	struct StorablePicture *pic;
+	struct VideoParameters *p_Vid = &(p_H264_Dpb->mVideo);
+	/* recycle un-used pic */
+	int ii = 0;
+
+	for (ii = 0; ii < MAX_PIC_BUF_NUM; ii++) {
+		pic = &(p_H264_Dpb->m_PIC[ii]);
+		if (pic->is_used == 0) {
+			pic->is_used = 1;
+			s = pic;
+			break;
+		}
+	}
+
+	if (s) {
+		s->pic_num   = 0;
+		s->frame_num = 0;
+		s->long_term_frame_idx = 0;
+		s->long_term_pic_num   = 0;
+		s->used_for_reference  = 0;
+		s->is_long_term        = 0;
+		s->non_existing        = 0;
+		s->is_output           = 0;
+		s->pre_output          = 0;
+		s->max_slice_id        = 0;
+#if (MVC_EXTENSION_ENABLE)
+		s->view_id = -1;
+#endif
+
+		s->structure = structure;
+
+#if 0
+		s->size_x = size_x;
+		s->size_y = size_y;
+		s->size_x_cr = size_x_cr;
+		s->size_y_cr = size_y_cr;
+		s->size_x_m1 = size_x - 1;
+		s->size_y_m1 = size_y - 1;
+		s->size_x_cr_m1 = size_x_cr - 1;
+		s->size_y_cr_m1 = size_y_cr - 1;
+
+		s->top_field    = p_Vid->no_reference_picture;
+		s->bottom_field = p_Vid->no_reference_picture;
+		s->frame        = p_Vid->no_reference_picture;
+#endif
+		/* s->dec_ref_pic_marking_buffer = NULL; */
+
+		s->coded_frame  = 0;
+		s->mb_aff_frame_flag  = 0;
+
+		s->top_poc = s->bottom_poc = s->poc = 0;
+		s->seiHasTone_mapping = 0;
+
+		if (!p_Vid->active_sps->frame_mbs_only_flag &&
+			structure != FRAME) {
+			int i, j;
+			for (j = 0; j < MAX_NUM_SLICES; j++) {
+				for (i = 0; i < 2; i++) {
+					/* s->listX[j][i] =
+					calloc(MAX_LIST_SIZE,
+					sizeof (struct StorablePicture *));
+					+1 for reordering   ???
+
+					if (NULL==s->listX[j][i])
+					    no_mem_exit("alloc_storable_picture:
+						s->listX[i]"); */
+				}
+			}
+		}
+	}
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			"%s %p\n", __func__, s);
+	return s;
+}
+
+static void free_picture(struct h264_dpb_stru *p_H264_Dpb,
+			 struct StorablePicture *pic)
+{
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			"%s %p %d\n", __func__, pic, pic->index);
+	/* assert(pic->index<MAX_PIC_BUF_NUM); */
+	p_H264_Dpb->m_PIC[pic->index].is_used = 0;
+}
+
+static void gen_field_ref_ids(struct VideoParameters *p_Vid,
+			      struct StorablePicture *p)
+{
+	int i, j;
+	struct h264_dpb_stru *p_H264_Dpb = container_of(p_Vid,
+					struct h264_dpb_stru, mVideo);
+	/* ! Generate Frame parameters from field information. */
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+					"%s\n", __func__);
+
+	/* copy the list; */
+	for (j = 0; j < p_Vid->iSliceNumOfCurrPic; j++) {
+		if (p->listX[j][LIST_0]) {
+			p->listXsize[j][LIST_0] =
+				p_Vid->ppSliceList[j]->listXsize[LIST_0];
+			for (i = 0; i < p->listXsize[j][LIST_0]; i++)
+				p->listX[j][LIST_0][i] =
+				p_Vid->ppSliceList[j]->listX[LIST_0][i];
+		}
+		if (p->listX[j][LIST_1]) {
+			p->listXsize[j][LIST_1] =
+				p_Vid->ppSliceList[j]->listXsize[LIST_1];
+			for (i = 0; i < p->listXsize[j][LIST_1]; i++)
+				p->listX[j][LIST_1][i] =
+				p_Vid->ppSliceList[j]->listX[LIST_1][i];
+		}
+	}
+}
+
+static void init_dpb(struct h264_dpb_stru *p_H264_Dpb, int type)
+{
+	unsigned i;
+	struct VideoParameters *p_Vid  = &p_H264_Dpb->mVideo;
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+	struct SPSParameters *active_sps = &p_H264_Dpb->mSPS;
+
+	p_Vid->active_sps = active_sps;
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s\n", __func__);
+
+	p_Dpb->p_Vid = p_Vid;
+	if (p_Dpb->init_done) {
+		/* free_dpb(p_Dpb); */
+		if (p_Vid->no_reference_picture) {
+			free_picture(p_H264_Dpb, p_Vid->no_reference_picture);
+			p_Vid->no_reference_picture = NULL;
+		}
+		p_Dpb->init_done = 0;
+	}
+
+	/* p_Dpb->size = 10; //active_sps->max_dpb_size; //16;
+	   getDpbSize(p_Vid, active_sps) +
+		p_Vid->p_Inp->dpb_plus[type==2? 1: 0];
+	   p_Dpb->size = active_sps->max_dpb_size; //16;
+	   getDpbSize(p_Vid, active_sps) +
+		p_Vid->p_Inp->dpb_plus[type==2? 1: 0];
+	   p_Dpb->size initialzie in vh264.c */
+	p_Dpb->num_ref_frames = active_sps->num_ref_frames;
+	/* p_Dpb->num_ref_frames initialzie in vh264.c */
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		  "%s dpb_size is %d (%d) num_ref_frames = %d (%d)\n",
+		  __func__, p_Dpb->size, active_sps->max_dpb_size,
+		  p_Dpb->num_ref_frames,
+		  active_sps->num_ref_frames);
+
+#if 0
+	/* ??? */
+#if (MVC_EXTENSION_ENABLE)
+	if ((unsigned int)active_sps->max_dec_frame_buffering <
+	    active_sps->num_ref_frames) {
+#else
+	if (p_Dpb->size < active_sps->num_ref_frames) {
+#endif
+		error(
+		"DPB size at specified level is smaller than the specified number of reference frames. This is not allowed.\n",
+		1000);
+	}
+#endif
+
+	p_Dpb->used_size = 0;
+	p_Dpb->last_picture = NULL;
+
+	p_Dpb->ref_frames_in_buffer = 0;
+	p_Dpb->ltref_frames_in_buffer = 0;
+
+#if 0
+	p_Dpb->fs = calloc(p_Dpb->size, sizeof(struct FrameStore *));
+	if (NULL == p_Dpb->fs)
+		no_mem_exit("init_dpb: p_Dpb->fs");
+
+	p_Dpb->fs_ref = calloc(p_Dpb->size, sizeof(struct FrameStore *));
+	if (NULL == p_Dpb->fs_ref)
+		no_mem_exit("init_dpb: p_Dpb->fs_ref");
+
+	p_Dpb->fs_ltref = calloc(p_Dpb->size, sizeof(struct FrameStore *));
+	if (NULL == p_Dpb->fs_ltref)
+		no_mem_exit("init_dpb: p_Dpb->fs_ltref");
+#endif
+
+#if (MVC_EXTENSION_ENABLE)
+	p_Dpb->fs_ilref = calloc(1, sizeof(struct FrameStore *));
+	if (NULL == p_Dpb->fs_ilref)
+		no_mem_exit("init_dpb: p_Dpb->fs_ilref");
+#endif
+
+	for (i = 0; i < p_Dpb->size; i++) {
+		p_Dpb->fs[i] = &(p_H264_Dpb->mFrameStore[i]);
+		/* alloc_frame_store(); */
+		p_Dpb->fs[i]->index       = i;
+		p_Dpb->fs_ref[i]   = NULL;
+		p_Dpb->fs_ltref[i] = NULL;
+		p_Dpb->fs[i]->layer_id = 0; /* MVC_INIT_VIEW_ID; */
+#if (MVC_EXTENSION_ENABLE)
+		p_Dpb->fs[i]->view_id = MVC_INIT_VIEW_ID;
+		p_Dpb->fs[i]->inter_view_flag[0] =
+			p_Dpb->fs[i]->inter_view_flag[1] = 0;
+		p_Dpb->fs[i]->anchor_pic_flag[0] =
+			p_Dpb->fs[i]->anchor_pic_flag[1] = 0;
+#endif
+	}
+#if (MVC_EXTENSION_ENABLE)
+	if (type == 2) {
+		p_Dpb->fs_ilref[0] = alloc_frame_store();
+		/* These may need some cleanups */
+		p_Dpb->fs_ilref[0]->view_id = MVC_INIT_VIEW_ID;
+		p_Dpb->fs_ilref[0]->inter_view_flag[0] =
+			p_Dpb->fs_ilref[0]->inter_view_flag[1] = 0;
+		p_Dpb->fs_ilref[0]->anchor_pic_flag[0] =
+			p_Dpb->fs_ilref[0]->anchor_pic_flag[1] = 0;
+		/* given that this is in a different buffer,
+			do we even need proc_flag anymore? */
+	} else
+		p_Dpb->fs_ilref[0] = NULL;
+#endif
+
+	/*
+	for (i = 0; i < 6; i++)
+	{
+	currSlice->listX[i] =
+		calloc(MAX_LIST_SIZE, sizeof (struct StorablePicture *));
+		+1 for reordering
+	if (NULL==currSlice->listX[i])
+	no_mem_exit("init_dpb: currSlice->listX[i]");
+	}
+	*/
+	/* allocate a dummy storable picture */
+	if (!p_Vid->no_reference_picture) {
+		p_Vid->no_reference_picture = get_new_pic(p_H264_Dpb,
+					      FRAME,
+		/*p_Vid->width, p_Vid->height,
+		p_Vid->width_cr, p_Vid->height_cr,*/ 1);
+		p_Vid->no_reference_picture->top_field =
+			p_Vid->no_reference_picture;
+		p_Vid->no_reference_picture->bottom_field =
+			p_Vid->no_reference_picture;
+		p_Vid->no_reference_picture->frame =
+			p_Vid->no_reference_picture;
+	}
+	p_Dpb->last_output_poc = INT_MIN;
+
+#if (MVC_EXTENSION_ENABLE)
+	p_Dpb->last_output_view_id = -1;
+#endif
+
+	p_Vid->last_has_mmco_5 = 0;
+
+	init_colocate_buf(p_H264_Dpb, p_H264_Dpb->max_reference_size);
+
+	p_Dpb->init_done = 1;
+
+#if 0
+/* ??? */
+	/* picture error concealment */
+	if (p_Vid->conceal_mode != 0 && !p_Vid->last_out_fs)
+		p_Vid->last_out_fs = alloc_frame_store();
+#endif
+}
+
+static void dpb_split_field(struct h264_dpb_stru *p_H264_Dpb,
+			    struct FrameStore *fs)
+{
+	struct StorablePicture *fs_top = NULL, *fs_btm = NULL;
+	struct StorablePicture *frame = fs->frame;
+
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s %p %p\n", __func__, fs, frame);
+
+	fs->poc = frame->poc;
+
+	if (!frame->frame_mbs_only_flag) {
+		fs_top = fs->top_field = get_new_pic(p_H264_Dpb,
+			TOP_FIELD,
+			/* frame->size_x, frame->size_y,
+			frame->size_x_cr, frame->size_y_cr,*/ 1);
+		fs_btm = fs->bottom_field = get_new_pic(p_H264_Dpb,
+			BOTTOM_FIELD,
+			/*frame->size_x, frame->size_y,
+			frame->size_x_cr, frame->size_y_cr,*/ 1);
+		if (fs_top == NULL || fs_btm == NULL)
+			return;
+#if 1
+/* rain */
+		fs_top->buf_spec_num = frame->buf_spec_num;
+		fs_btm->buf_spec_num = frame->buf_spec_num;
+
+		fs_top->colocated_buf_index = frame->colocated_buf_index;
+		fs_btm->colocated_buf_index = frame->colocated_buf_index;
+#endif
+		fs_top->poc = frame->top_poc;
+		fs_btm->poc = frame->bottom_poc;
+
+#if (MVC_EXTENSION_ENABLE)
+		fs_top->view_id = frame->view_id;
+		fs_btm->view_id = frame->view_id;
+#endif
+
+		fs_top->frame_poc =  frame->frame_poc;
+
+		fs_top->bottom_poc = fs_btm->bottom_poc =  frame->bottom_poc;
+		fs_top->top_poc    = fs_btm->top_poc    =  frame->top_poc;
+		fs_btm->frame_poc  = frame->frame_poc;
+
+		fs_top->used_for_reference = fs_btm->used_for_reference
+					     = frame->used_for_reference;
+		fs_top->is_long_term = fs_btm->is_long_term
+				       = frame->is_long_term;
+		fs->long_term_frame_idx = fs_top->long_term_frame_idx
+					  = fs_btm->long_term_frame_idx
+					    = frame->long_term_frame_idx;
+
+		fs_top->coded_frame = fs_btm->coded_frame = 1;
+		fs_top->mb_aff_frame_flag = fs_btm->mb_aff_frame_flag
+					    = frame->mb_aff_frame_flag;
+
+		frame->top_field    = fs_top;
+		frame->bottom_field = fs_btm;
+		frame->frame         = frame;
+		fs_top->bottom_field = fs_btm;
+		fs_top->frame        = frame;
+		fs_top->top_field = fs_top;
+		fs_btm->top_field = fs_top;
+		fs_btm->frame     = frame;
+		fs_btm->bottom_field = fs_btm;
+
+#if (MVC_EXTENSION_ENABLE)
+		fs_top->view_id = fs_btm->view_id = fs->view_id;
+		fs_top->inter_view_flag = fs->inter_view_flag[0];
+		fs_btm->inter_view_flag = fs->inter_view_flag[1];
+#endif
+
+		fs_top->chroma_format_idc = fs_btm->chroma_format_idc =
+						    frame->chroma_format_idc;
+		fs_top->iCodingType = fs_btm->iCodingType = frame->iCodingType;
+	} else {
+		fs->top_field       = NULL;
+		fs->bottom_field    = NULL;
+		frame->top_field    = NULL;
+		frame->bottom_field = NULL;
+		frame->frame = frame;
+	}
+
+}
+
+
+static void dpb_combine_field(struct h264_dpb_stru *p_H264_Dpb,
+			      struct FrameStore *fs)
+{
+
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			"%s\n", __func__);
+
+	if (!fs->frame) {
+		fs->frame = get_new_pic(p_H264_Dpb,
+			FRAME,
+			/* fs->top_field->size_x, fs->top_field->size_y*2,
+			fs->top_field->size_x_cr, fs->top_field->size_y_cr*2,
+			*/ 1);
+	}
+	if (!fs->frame)
+		return;
+#if 1
+/* rain */
+	fs->frame->buf_spec_num = fs->top_field->buf_spec_num;
+	fs->frame->colocated_buf_index = fs->top_field->colocated_buf_index;
+#endif
+
+
+	fs->poc = fs->frame->poc = fs->frame->frame_poc = imin(
+			fs->top_field->poc, fs->bottom_field->poc);
+
+	fs->bottom_field->frame_poc = fs->top_field->frame_poc = fs->frame->poc;
+
+	fs->bottom_field->top_poc = fs->frame->top_poc = fs->top_field->poc;
+	fs->top_field->bottom_poc = fs->frame->bottom_poc =
+			fs->bottom_field->poc;
+
+	fs->frame->used_for_reference = (fs->top_field->used_for_reference &&
+					 fs->bottom_field->used_for_reference);
+	fs->frame->is_long_term = (fs->top_field->is_long_term &&
+				   fs->bottom_field->is_long_term);
+
+	if (fs->frame->is_long_term)
+		fs->frame->long_term_frame_idx = fs->long_term_frame_idx;
+
+	fs->frame->top_field    = fs->top_field;
+	fs->frame->bottom_field = fs->bottom_field;
+	fs->frame->frame = fs->frame;
+
+	fs->frame->coded_frame = 0;
+
+	fs->frame->chroma_format_idc = fs->top_field->chroma_format_idc;
+	fs->frame->frame_cropping_flag = fs->top_field->frame_cropping_flag;
+	if (fs->frame->frame_cropping_flag) {
+		fs->frame->frame_crop_top_offset =
+			fs->top_field->frame_crop_top_offset;
+		fs->frame->frame_crop_bottom_offset =
+			fs->top_field->frame_crop_bottom_offset;
+		fs->frame->frame_crop_left_offset =
+			fs->top_field->frame_crop_left_offset;
+		fs->frame->frame_crop_right_offset =
+			fs->top_field->frame_crop_right_offset;
+	}
+
+	fs->top_field->frame = fs->bottom_field->frame = fs->frame;
+	fs->top_field->top_field = fs->top_field;
+	fs->top_field->bottom_field = fs->bottom_field;
+	fs->bottom_field->top_field = fs->top_field;
+	fs->bottom_field->bottom_field = fs->bottom_field;
+
+	/**/
+#if (MVC_EXTENSION_ENABLE)
+	fs->frame->view_id = fs->view_id;
+#endif
+	fs->frame->iCodingType = fs->top_field->iCodingType;
+	/* FIELD_CODING ;*/
+}
+
+static void calculate_frame_no(struct VideoParameters *p_Vid,
+			       struct StorablePicture *p)
+{
+#if 0
+/* ??? */
+	InputParameters *p_Inp = p_Vid->p_Inp;
+	/* calculate frame number */
+	int psnrPOC = p_Vid->active_sps->mb_adaptive_frame_field_flag ?
+		p->poc / (p_Inp->poc_scale) : p->poc / (p_Inp->poc_scale);
+
+	if (psnrPOC == 0) { /* && p_Vid->psnr_number) */
+		p_Vid->idr_psnr_number =
+		p_Vid->g_nFrame * p_Vid->ref_poc_gap / (p_Inp->poc_scale);
+	}
+	p_Vid->psnr_number = imax(p_Vid->psnr_number,
+		p_Vid->idr_psnr_number + psnrPOC);
+
+	p_Vid->frame_no = p_Vid->idr_psnr_number + psnrPOC;
+#endif
+}
+
+static void insert_picture_in_dpb(struct h264_dpb_stru *p_H264_Dpb,
+				  struct FrameStore *fs,
+				  struct StorablePicture *p)
+{
+	struct VideoParameters *p_Vid = &p_H264_Dpb->mVideo;
+	/* InputParameters *p_Inp = p_Vid->p_Inp;
+	   dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"insert (%s) pic with frame_num #%d, poc %d\n",
+		(p->structure == FRAME)?"FRAME":
+		(p->structure == TOP_FIELD)?"TOP_FIELD":
+		"BOTTOM_FIELD", p->pic_num, p->poc);
+	   assert (p!=NULL);
+	   assert (fs!=NULL);*/
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s %p %p\n", __func__, fs, p);
+#if 1
+/* rain */
+/* p->buf_spec_num = fs->index; */
+	fs->buf_spec_num = p->buf_spec_num;
+	fs->colocated_buf_index = p->colocated_buf_index;
+#endif
+	switch (p->structure) {
+	case FRAME:
+		fs->frame = p;
+		fs->is_used = 3;
+		if (p->used_for_reference) {
+			fs->is_reference = 3;
+			fs->is_orig_reference = 3;
+			if (p->is_long_term) {
+				fs->is_long_term = 3;
+				fs->long_term_frame_idx =
+					p->long_term_frame_idx;
+			}
+		}
+		fs->layer_id = p->layer_id;
+#if (MVC_EXTENSION_ENABLE)
+		fs->view_id = p->view_id;
+		fs->inter_view_flag[0] = fs->inter_view_flag[1] =
+			p->inter_view_flag;
+		fs->anchor_pic_flag[0] = fs->anchor_pic_flag[1] =
+			p->anchor_pic_flag;
+#endif
+		/* generate field views */
+		/* return; */
+		dpb_split_field(p_H264_Dpb, fs);
+		/* return; */
+		break;
+	case TOP_FIELD:
+		fs->top_field = p;
+		fs->is_used |= 1;
+		fs->layer_id = p->layer_id;
+#if (MVC_EXTENSION_ENABLE)
+		fs->view_id = p->view_id;
+		fs->inter_view_flag[0] = p->inter_view_flag;
+		fs->anchor_pic_flag[0] = p->anchor_pic_flag;
+#endif
+		if (p->used_for_reference) {
+			fs->is_reference |= 1;
+			fs->is_orig_reference |= 1;
+			if (p->is_long_term) {
+				fs->is_long_term |= 1;
+				fs->long_term_frame_idx =
+					p->long_term_frame_idx;
+			}
+		}
+		if (fs->is_used == 3) {
+			/* generate frame view */
+			dpb_combine_field(p_H264_Dpb, fs);
+		} else {
+			fs->poc = p->poc;
+		}
+		gen_field_ref_ids(p_Vid, p);
+		break;
+	case BOTTOM_FIELD:
+		fs->bottom_field = p;
+		fs->is_used |= 2;
+		fs->layer_id = p->layer_id;
+#if (MVC_EXTENSION_ENABLE)
+		fs->view_id = p->view_id;
+		fs->inter_view_flag[1] = p->inter_view_flag;
+		fs->anchor_pic_flag[1] = p->anchor_pic_flag;
+#endif
+		if (p->used_for_reference) {
+			fs->is_reference |= 2;
+			fs->is_orig_reference |= 2;
+			if (p->is_long_term) {
+				fs->is_long_term |= 2;
+				fs->long_term_frame_idx =
+					p->long_term_frame_idx;
+			}
+		}
+		if (fs->is_used == 3) {
+			/* generate frame view */
+			dpb_combine_field(p_H264_Dpb, fs);
+		} else {
+			fs->poc = p->poc;
+		}
+		gen_field_ref_ids(p_Vid, p);
+		break;
+	}
+	fs->frame_num = p->pic_num;
+	fs->recovery_frame = p->recovery_frame;
+
+	fs->is_output = p->is_output;
+	fs->pre_output = p->pre_output;
+
+	if (fs->is_used == 3) {
+		calculate_frame_no(p_Vid, p);
+#if 0
+/* ??? */
+	if (-1 != p_Vid->p_ref && !p_Inp->silent)
+		find_snr(p_Vid, fs->frame, &p_Vid->p_ref);
+#endif
+	}
+
+	fs->pts = p->pts;
+	fs->pts64 = p->pts64;
+}
+
+void reset_frame_store(struct h264_dpb_stru *p_H264_Dpb,
+			      struct FrameStore *f)
+{
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s\n", __func__);
+
+	if (f) {
+		if (f->frame) {
+			free_picture(p_H264_Dpb, f->frame);
+			f->frame = NULL;
+		}
+		if (f->top_field) {
+			free_picture(p_H264_Dpb, f->top_field);
+			f->top_field = NULL;
+		}
+		if (f->bottom_field) {
+			free_picture(p_H264_Dpb, f->bottom_field);
+			f->bottom_field = NULL;
+		}
+
+		/**/
+		f->is_used      = 0;
+		f->is_reference = 0;
+		f->is_long_term = 0;
+		f->is_orig_reference = 0;
+
+		f->is_output = 0;
+		f->pre_output = 0;
+
+		f->frame        = NULL;
+		f->top_field    = NULL;
+		f->bottom_field = NULL;
+
+		/* free(f); */
+	}
+}
+
+static void unmark_for_reference(struct DecodedPictureBuffer *p_Dpb,
+				 struct FrameStore *fs)
+{
+	struct h264_dpb_stru *p_H264_Dpb = container_of(p_Dpb,
+				struct h264_dpb_stru, mDPB);
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s %p %p %p %p\n", __func__,
+		fs, fs->frame, fs->top_field, fs->bottom_field);
+	/* return; */
+	if (fs->is_used & 1) {
+		if (fs->top_field)
+			fs->top_field->used_for_reference = 0;
+	}
+	if (fs->is_used & 2) {
+		if (fs->bottom_field)
+			fs->bottom_field->used_for_reference = 0;
+	}
+	if (fs->is_used == 3) {
+		if (fs->top_field && fs->bottom_field) {
+			fs->top_field->used_for_reference = 0;
+			fs->bottom_field->used_for_reference = 0;
+		}
+		fs->frame->used_for_reference = 0;
+	}
+
+	fs->is_reference = 0;
+
+}
+
+int get_long_term_flag_by_buf_spec_num(struct h264_dpb_stru *p_H264_Dpb,
+	int buf_spec_num)
+{
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+	unsigned i;
+	for (i = 0; i < p_Dpb->used_size; i++) {
+		if (p_Dpb->fs[i]->buf_spec_num == buf_spec_num)
+			return p_Dpb->fs[i]->is_long_term;
+	}
+	return -1;
+}
+
+static void update_pic_num(struct Slice *currSlice)
+{
+	unsigned int i;
+	struct VideoParameters *p_Vid = currSlice->p_Vid;
+	struct DecodedPictureBuffer *p_Dpb = currSlice->p_Dpb;
+	struct SPSParameters *active_sps = p_Vid->active_sps;
+
+	int add_top = 0, add_bottom = 0;
+	int max_frame_num = 1 << (active_sps->log2_max_frame_num_minus4 + 4);
+
+	if (currSlice->structure == FRAME) {
+		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+			if (p_Dpb->fs_ref[i]->is_used == 3) {
+				if ((p_Dpb->fs_ref[i]->frame->
+					used_for_reference) &&
+				    (!p_Dpb->fs_ref[i]->frame->
+					is_long_term)) {
+					if (p_Dpb->fs_ref[i]->frame_num >
+						currSlice->frame_num) {
+						p_Dpb->fs_ref[i]->
+						frame_num_wrap =
+						p_Dpb->fs_ref[i]->frame_num
+							- max_frame_num;
+					} else {
+						p_Dpb->fs_ref[i]->
+						frame_num_wrap =
+						p_Dpb->fs_ref[i]->frame_num;
+					}
+					p_Dpb->fs_ref[i]->frame->pic_num =
+					p_Dpb->fs_ref[i]->frame_num_wrap;
+				}
+			}
+		}
+		/* update long_term_pic_num */
+		for (i = 0; i < p_Dpb->ltref_frames_in_buffer; i++) {
+			if (p_Dpb->fs_ltref[i]->is_used == 3) {
+				if (p_Dpb->fs_ltref[i]->frame->is_long_term) {
+					p_Dpb->fs_ltref[i]->frame->
+						long_term_pic_num =
+						p_Dpb->fs_ltref[i]->frame->
+							long_term_frame_idx;
+				}
+			}
+		}
+	} else {
+		if (currSlice->structure == TOP_FIELD) {
+			add_top    = 1;
+			add_bottom = 0;
+		} else {
+			add_top    = 0;
+			add_bottom = 1;
+		}
+
+		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+			if (p_Dpb->fs_ref[i]->is_reference) {
+				if (p_Dpb->fs_ref[i]->frame_num > currSlice->
+					frame_num) {
+					p_Dpb->fs_ref[i]->frame_num_wrap =
+					p_Dpb->fs_ref[i]->frame_num -
+					max_frame_num;
+				} else {
+					p_Dpb->fs_ref[i]->frame_num_wrap =
+					p_Dpb->fs_ref[i]->frame_num;
+				}
+				if (p_Dpb->fs_ref[i]->is_reference & 1) {
+					p_Dpb->fs_ref[i]->top_field->
+					pic_num = (2 * p_Dpb->fs_ref[i]->
+						frame_num_wrap) + add_top;
+				}
+				if (p_Dpb->fs_ref[i]->is_reference & 2) {
+					p_Dpb->fs_ref[i]->bottom_field->
+					pic_num = (2 * p_Dpb->fs_ref[i]->
+						frame_num_wrap) + add_bottom;
+				}
+			}
+		}
+		/* update long_term_pic_num */
+		for (i = 0; i < p_Dpb->ltref_frames_in_buffer; i++) {
+			if (p_Dpb->fs_ltref[i]->is_long_term & 1) {
+				p_Dpb->fs_ltref[i]->top_field->
+					long_term_pic_num = 2 *
+					p_Dpb->fs_ltref[i]->top_field->
+					long_term_frame_idx + add_top;
+			}
+			if (p_Dpb->fs_ltref[i]->is_long_term & 2) {
+				p_Dpb->fs_ltref[i]->bottom_field->
+					long_term_pic_num = 2 *
+					p_Dpb->fs_ltref[i]->bottom_field->
+					long_term_frame_idx + add_bottom;
+			}
+		}
+	}
+}
+
+static void remove_frame_from_dpb(struct h264_dpb_stru *p_H264_Dpb, int pos)
+{
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+	struct FrameStore *fs = p_Dpb->fs[pos];
+	struct FrameStore *tmp;
+	unsigned i;
+
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s pos %d %p\n", __func__, pos, fs);
+
+	/* dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"remove frame with frame_num #%d\n", fs->frame_num); */
+	switch (fs->is_used) {
+	case 3:
+		free_picture(p_H264_Dpb, fs->frame);
+		free_picture(p_H264_Dpb, fs->top_field);
+		free_picture(p_H264_Dpb, fs->bottom_field);
+		fs->frame = NULL;
+		fs->top_field = NULL;
+		fs->bottom_field = NULL;
+		break;
+	case 2:
+		free_picture(p_H264_Dpb, fs->bottom_field);
+		fs->bottom_field = NULL;
+		break;
+	case 1:
+		free_picture(p_H264_Dpb, fs->top_field);
+		fs->top_field = NULL;
+		break;
+	case 0:
+		break;
+	default:
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			  "invalid frame store type %x", 500);
+	}
+	fs->is_used = 0;
+	fs->is_long_term = 0;
+	fs->is_reference = 0;
+	fs->is_orig_reference = 0;
+
+	/* move empty framestore to end of buffer */
+	tmp = p_Dpb->fs[pos];
+
+	for (i = pos; i < p_Dpb->used_size - 1; i++)
+		p_Dpb->fs[i] = p_Dpb->fs[i + 1];
+	p_Dpb->fs[p_Dpb->used_size - 1] = tmp;
+	p_Dpb->used_size--;
+}
+
+static int is_used_for_reference(struct FrameStore *fs)
+{
+	if (fs->is_reference)
+		return 1;
+
+	if (fs->is_used == 3) { /* frame */
+		if (fs->frame->used_for_reference)
+			return 1;
+	}
+
+	if (fs->is_used & 1) { /* top field */
+		if (fs->top_field) {
+			if (fs->top_field->used_for_reference)
+				return 1;
+		}
+	}
+
+	if (fs->is_used & 2) { /* bottom field */
+		if (fs->bottom_field) {
+			if (fs->bottom_field->used_for_reference)
+				return 1;
+		}
+	}
+	return 0;
+}
+
+static int remove_unused_frame_from_dpb(struct h264_dpb_stru *p_H264_Dpb)
+{
+	unsigned i;
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+	/* check for frames that were already output and no longer
+		used for reference */
+	for (i = 0; i < p_Dpb->used_size; i++) {
+		if ((!is_used_for_reference(p_Dpb->fs[i])) &&
+		    (p_Dpb->fs[i]->colocated_buf_index >= 0)) {
+			dpb_print(p_H264_Dpb->decoder_index,
+			PRINT_FLAG_DPB_DETAIL,
+			"release_colocate_buf[%d] for fs[%d]\n",
+			p_Dpb->fs[i]->colocated_buf_index, i);
+
+			release_colocate_buf(p_H264_Dpb,
+				p_Dpb->fs[i]->colocated_buf_index); /* rain */
+			p_Dpb->fs[i]->colocated_buf_index = -1;
+		}
+	}
+
+	for (i = 0; i < p_Dpb->used_size; i++) {
+		if (p_Dpb->fs[i]->is_output &&
+			(!is_used_for_reference(p_Dpb->fs[i]))) {
+			release_buf_spec_num(p_H264_Dpb->vdec,
+				p_Dpb->fs[i]->buf_spec_num);
+			p_Dpb->fs[i]->buf_spec_num = -1;
+			remove_frame_from_dpb(p_H264_Dpb, i);
+
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "%s[%d]\n",
+				__func__, i);
+
+			return 1;
+		}
+	}
+	return 0;
+}
+
+void bufmgr_h264_remove_unused_frame(struct h264_dpb_stru *p_H264_Dpb)
+{
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+	int ret = 0;
+	unsigned char print_flag = 0;
+	do {
+		ret = remove_unused_frame_from_dpb(p_H264_Dpb);
+		if (ret != 0)
+			print_flag = 1;
+	} while (ret != 0);
+	if (print_flag) {
+		dpb_print(p_H264_Dpb->decoder_index,
+			PRINT_FLAG_DPB_DETAIL, "%s\r\n", __func__);
+		dump_dpb(p_Dpb);
+	}
+}
+
+#ifdef OUTPUT_BUFFER_IN_C
+int is_there_unused_frame_from_dpb(struct DecodedPictureBuffer *p_Dpb)
+{
+	unsigned i;
+
+	/* check for frames that were already output and no longer
+	 * used for reference */
+	for (i = 0; i < p_Dpb->used_size; i++) {
+		if (p_Dpb->fs[i]->is_output &&
+			(!is_used_for_reference(p_Dpb->fs[i]))) {
+			return 1;
+		}
+	}
+	return 0;
+}
+#endif
+
+static void get_smallest_poc(struct DecodedPictureBuffer *p_Dpb, int *poc,
+			     int *pos)
+{
+	unsigned  i;
+	struct h264_dpb_stru *p_H264_Dpb = container_of(p_Dpb,
+				struct h264_dpb_stru, mDPB);
+	dpb_print(p_H264_Dpb->decoder_index,
+		PRINT_FLAG_DPB_DETAIL, "%s\n", __func__);
+	if (p_Dpb->used_size < 1) {
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			  "Cannot determine smallest POC, DPB empty. %d\n",
+			 150);
+	}
+
+	*pos = -1;
+	*poc = INT_MAX;
+	for (i = 0; i < p_Dpb->used_size; i++) {
+#ifdef OUTPUT_BUFFER_IN_C
+		/* rain */
+		if ((*poc > p_Dpb->fs[i]->poc) &&
+			(!p_Dpb->fs[i]->is_output) &&
+			(!p_Dpb->fs[i]->pre_output)) {
+#else
+		if ((*poc > p_Dpb->fs[i]->poc) && (!p_Dpb->fs[i]->is_output)) {
+#endif
+			*poc = p_Dpb->fs[i]->poc;
+			*pos = i;
+		}
+	}
+}
+
+#ifdef OLD_OUTPUT_CODE
+static int output_one_frame_from_dpb(struct h264_dpb_stru *p_H264_Dpb)
+{
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+	struct VideoParameters *p_Vid = &p_H264_Dpb->mVideo;
+	int poc, pos;
+	/* diagnostics */
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s\n", __func__);
+
+	if (p_Dpb->used_size < 1) {
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			  "Cannot output frame, DPB empty. %d\n", 150);
+	}
+
+	/* find smallest POC */
+	get_smallest_poc(p_Dpb, &poc, &pos);
+
+	if (pos == -1)
+		return 0;
+
+	/* call the output function */
+	/*  dpb_print(p_H264_Dpb->decoder_index,
+	PRINT_FLAG_DPB_DETAIL,
+	"output frame with frame_num #%d, poc %d"
+	"(dpb. p_Dpb->size = %d, p_Dpb->used_size = %d)\n",
+	p_Dpb->fs[pos]->frame_num, p_Dpb->fs[pos]->frame->poc,
+	p_Dpb->size, p_Dpb->used_size);
+	*/
+
+#if 0
+	/* ??? */
+	/* picture error concealment */
+	if (p_Vid->conceal_mode != 0) {
+		if (p_Dpb->last_output_poc == 0)
+			write_lost_ref_after_idr(p_Dpb, pos);
+#if (MVC_EXTENSION_ENABLE)
+		write_lost_non_ref_pic(p_Dpb, poc,
+			p_Vid->p_out_mvc[p_Dpb->layer_id]);
+#else
+		write_lost_non_ref_pic(p_Dpb, poc, p_Vid->p_out);
+#endif
+	}
+#endif
+/* JVT-P072 ends */
+
+#if 0
+/* ??? */
+#if (MVC_EXTENSION_ENABLE)
+	write_stored_frame(p_Vid, p_Dpb->fs[pos],
+		p_Vid->p_out_mvc[p_Dpb->layer_id]);
+#else
+	write_stored_frame(p_Vid, p_Dpb->fs[pos], p_Vid->p_out);
+#endif
+#endif
+	/* picture error concealment */
+	if (p_Vid->conceal_mode == 0) {
+		if (p_Dpb->last_output_poc >= poc) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"output POC must be in ascending order %d\n",
+				150);
+		}
+	}
+
+	p_Dpb->last_output_poc = poc;
+
+	/* free frame store and move empty store to end of buffer */
+/* #ifdef OUTPUT_BUFFER_IN_C */
+	if ((h264_debug_flag & OUTPUT_CURRENT_BUF) == 0) {
+		if (prepare_display_buf(p_H264_Dpb->vdec,
+			p_Dpb->fs[pos]) >= 0) {
+			p_Dpb->fs[pos]->pre_output = 1;
+		}
+	}
+/* #else */
+	else {
+		if (!is_used_for_reference(p_Dpb->fs[pos])) {
+			release_colocate_buf(p_H264_Dpb,
+				p_Dpb->fs[pos]->colocated_buf_index); /*rain*/
+				p_Dpb->fs[pos]->colocated_buf_index = -1;
+
+			release_buf_spec_num(p_H264_Dpb->vdec,
+				p_Dpb->fs[pos]->buf_spec_num);
+			p_Dpb->fs[pos]->buf_spec_num = -1;
+
+			remove_frame_from_dpb(p_H264_Dpb, pos);
+		}
+/* #endif */
+	}
+	return 1;
+}
+
+#else
+/* none OLD_OUTPUT_CODE */
+
+int output_frames(struct h264_dpb_stru *p_H264_Dpb, unsigned char flush_flag)
+{
+	int poc, pos;
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+	int i;
+	int none_displayed_num = 0;
+	if (!flush_flag) {
+		for (i = 0; i < p_Dpb->used_size; i++) {
+			if ((!p_Dpb->fs[i]->is_output) &&
+				(!p_Dpb->fs[i]->pre_output))
+				none_displayed_num++;
+		}
+		if (none_displayed_num < p_H264_Dpb->reorder_pic_num)
+			return 0;
+	}
+
+	get_smallest_poc(p_Dpb, &poc, &pos);
+
+	if (pos == -1)
+		return 0;
+#if 0
+	if (is_used_for_reference(p_Dpb->fs[pos]))
+		return 0;
+#endif
+	p_Dpb->last_output_poc = poc;
+
+	if (prepare_display_buf(p_H264_Dpb->vdec, p_Dpb->fs[pos]) >= 0)
+		p_Dpb->fs[pos]->pre_output = 1;
+
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s[%d] poc %d\n", __func__, pos, poc);
+
+	return 1;
+
+}
+#endif
+
+
+static void flush_dpb(struct h264_dpb_stru *p_H264_Dpb)
+{
+	/* struct VideoParameters *p_Vid = p_Dpb->p_Vid; */
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+	unsigned  i;
+
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s\n", __func__);
+
+	/* diagnostics */
+	/* dpb_print(p_H264_Dpb->decoder_index,
+	PRINT_FLAG_DPB_DETAIL,
+	"Flush remaining frames from the dpb."
+	"p_Dpb->size = %d, p_Dpb->used_size = %d\n",
+	p_Dpb->size, p_Dpb->used_size);
+	*/
+
+	if (!p_Dpb->init_done)
+		return;
+/*  if(p_Vid->conceal_mode == 0) */
+#if 0
+/* ??? */
+	if (p_Vid->conceal_mode != 0)
+		conceal_non_ref_pics(p_Dpb, 0);
+#endif
+	/* mark all frames unused */
+	for (i = 0; i < p_Dpb->used_size; i++) {
+#if MVC_EXTENSION_ENABLE
+		assert(p_Dpb->fs[i]->view_id == p_Dpb->layer_id);
+#endif
+		unmark_for_reference(p_Dpb, p_Dpb->fs[i]);
+
+		if (h264_debug_flag & OUTPUT_CURRENT_BUF)
+			set_frame_output_flag(p_H264_Dpb, i);
+
+	}
+
+	while (remove_unused_frame_from_dpb(p_H264_Dpb))
+		;
+
+	/* output frames in POC order */
+#ifndef OLD_OUTPUT_CODE
+	if ((h264_debug_flag & OUTPUT_CURRENT_BUF) == 0) {
+		while (output_frames(p_H264_Dpb, 1))
+			;
+	}
+#else
+	while (p_Dpb->used_size && output_one_frame_from_dpb(p_H264_Dpb))
+		;
+#endif
+
+	p_Dpb->last_output_poc = INT_MIN;
+}
+
+static int is_short_term_reference(struct DecodedPictureBuffer *p_Dpb,
+				   struct FrameStore *fs)
+{
+	struct h264_dpb_stru *p_H264_Dpb = container_of(p_Dpb,
+			struct h264_dpb_stru, mDPB);
+	if (fs->is_used == 3) { /* frame */
+		if ((fs->frame->used_for_reference) &&
+			(!fs->frame->is_long_term)) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "[[%s 1]]",
+				__func__);
+			return 1;
+		}
+	}
+
+	if (fs->is_used & 1) { /* top field */
+		if (fs->top_field) {
+			if ((fs->top_field->used_for_reference) &&
+				(!fs->top_field->is_long_term)) {
+				dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "[[%s 2]]",
+				__func__);
+				return 1;
+			}
+		}
+	}
+
+	if (fs->is_used & 2) { /* bottom field */
+		if (fs->bottom_field) {
+			if ((fs->bottom_field->used_for_reference) &&
+			    (!fs->bottom_field->is_long_term)) {
+				dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "[[%s 3]]",
+				__func__);
+				return 1;
+			}
+		}
+	}
+	return 0;
+}
+
+static int is_long_term_reference(struct FrameStore *fs)
+{
+
+	if (fs->is_used == 3) { /* frame */
+		if ((fs->frame->used_for_reference) &&
+			(fs->frame->is_long_term)) {
+			return 1;
+		}
+	}
+
+	if (fs->is_used & 1) { /* top field */
+		if (fs->top_field) {
+			if ((fs->top_field->used_for_reference) &&
+				(fs->top_field->is_long_term)) {
+				return 1;
+			}
+		}
+	}
+
+	if (fs->is_used & 2) { /* bottom field */
+		if (fs->bottom_field) {
+			if ((fs->bottom_field->used_for_reference) &&
+			    (fs->bottom_field->is_long_term)) {
+				return 1;
+			}
+		}
+	}
+	return 0;
+}
+
+static void update_ref_list(struct DecodedPictureBuffer *p_Dpb)
+{
+	unsigned i, j;
+
+	struct h264_dpb_stru *p_H264_Dpb = container_of(p_Dpb,
+		struct h264_dpb_stru, mDPB);
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s (%d, %d)\n", __func__, p_Dpb->size, p_Dpb->used_size);
+	for (i = 0, j = 0; i < p_Dpb->used_size; i++) {
+#if 1
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			  "fs[%d]: fs %p frame %p is_reference %d %d %d\n",
+			  i, p_Dpb->fs[i], p_Dpb->fs[i]->frame,
+			  p_Dpb->fs[i]->frame != NULL ?
+			  p_Dpb->fs[i]->frame->used_for_reference : 0,
+			  p_Dpb->fs[i]->top_field != NULL ?
+			  p_Dpb->fs[i]->top_field->used_for_reference :
+			  0,
+			  p_Dpb->fs[i]->bottom_field != NULL ?
+			  p_Dpb->fs[i]->bottom_field->used_for_reference : 0);
+#endif
+		if (is_short_term_reference(p_Dpb, p_Dpb->fs[i])) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+			"fs_ref[%d]=fs[%d]: fs %p\n", j, i, p_Dpb->fs[i]);
+			p_Dpb->fs_ref[j++] = p_Dpb->fs[i];
+		}
+	}
+
+	p_Dpb->ref_frames_in_buffer = j;
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s dpb size is %d, %d\n", __func__, p_Dpb->size, j);
+	while (j < p_Dpb->size) {
+		/* dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"fs_ref[%d]=null\n", j); */
+		p_Dpb->fs_ref[j++] = NULL;
+	}
+#ifdef ERROR_CHECK
+	for (i = 0; i < DPB_SIZE_MAX; i++) {
+		if (p_Dpb->fs_ref[i] == NULL)
+			p_Dpb->fs_ref[i] = &dummy_fs;
+	}
+#endif
+}
+
+static void update_ltref_list(struct DecodedPictureBuffer *p_Dpb)
+{
+	unsigned i, j;
+	struct h264_dpb_stru *p_H264_Dpb = container_of(p_Dpb,
+		struct h264_dpb_stru, mDPB);
+
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s\n", __func__);
+	for (i = 0, j = 0; i < p_Dpb->used_size; i++) {
+		if (is_long_term_reference(p_Dpb->fs[i]))
+			p_Dpb->fs_ltref[j++] = p_Dpb->fs[i];
+	}
+
+	p_Dpb->ltref_frames_in_buffer = j;
+
+	while (j < p_Dpb->size)
+		p_Dpb->fs_ltref[j++] = NULL;
+#ifdef ERROR_CHECK
+	for (i = 0; i < DPB_SIZE_MAX; i++) {
+		if (p_Dpb->fs_ltref[i] == NULL)
+			p_Dpb->fs_ltref[i] = &dummy_fs;
+	}
+#endif
+}
+
+static void idr_memory_management(struct h264_dpb_stru *p_H264_Dpb,
+				  struct StorablePicture *p)
+{
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+	"%s %d %d\n", __func__, p_Dpb->ref_frames_in_buffer,
+	p_Dpb->ltref_frames_in_buffer);
+
+	if (p->no_output_of_prior_pics_flag) {
+#if 0
+		/*???*/
+		/* free all stored pictures */
+		int i;
+		for (i = 0; i < p_Dpb->used_size; i++) {
+			/* reset all reference settings
+			 * free_frame_store(p_Dpb->fs[i]);
+			 * p_Dpb->fs[i] = alloc_frame_store();
+			 */
+			reset_frame_store(p_H264_Dpb, p_Dpb->fs[i]); /* ??? */
+		}
+		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++)
+			p_Dpb->fs_ref[i] = NULL;
+		for (i = 0; i < p_Dpb->ltref_frames_in_buffer; i++)
+			p_Dpb->fs_ltref[i] = NULL;
+		p_Dpb->used_size = 0;
+#endif
+	} else {
+		flush_dpb(p_H264_Dpb);
+	}
+	p_Dpb->last_picture = NULL;
+
+	update_ref_list(p_Dpb);
+	update_ltref_list(p_Dpb);
+	p_Dpb->last_output_poc = INT_MIN;
+
+	if (p->long_term_reference_flag) {
+		p_Dpb->max_long_term_pic_idx = 0;
+		p->is_long_term           = 1;
+		p->long_term_frame_idx    = 0;
+	} else {
+		p_Dpb->max_long_term_pic_idx = -1;
+		p->is_long_term           = 0;
+	}
+
+#if (MVC_EXTENSION_ENABLE)
+	p_Dpb->last_output_view_id = -1;
+#endif
+
+}
+
+static void sliding_window_memory_management(
+		struct DecodedPictureBuffer *p_Dpb,
+		struct StorablePicture *p)
+{
+	unsigned  i;
+	struct h264_dpb_stru *p_H264_Dpb = container_of(p_Dpb,
+		struct h264_dpb_stru, mDPB);
+
+	/* assert (!p->idr_flag); */
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s\n", __func__);
+
+	/* if this is a reference pic with sliding window,
+	   unmark first ref frame */
+	if (p_Dpb->ref_frames_in_buffer == imax(
+		1, p_Dpb->num_ref_frames) - p_Dpb->ltref_frames_in_buffer) {
+		for (i = 0; i < p_Dpb->used_size; i++) {
+			if (p_Dpb->fs[i]->is_reference &&
+				(!(p_Dpb->fs[i]->is_long_term))) {
+				dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "unmark %d\n", i);
+				unmark_for_reference(p_Dpb, p_Dpb->fs[i]);
+				update_ref_list(p_Dpb);
+				break;
+			}
+		}
+	}
+
+	p->is_long_term = 0;
+}
+
+static void check_num_ref(struct DecodedPictureBuffer *p_Dpb)
+{
+	if ((int)(p_Dpb->ltref_frames_in_buffer +
+			p_Dpb->ref_frames_in_buffer) >
+			imax(1, p_Dpb->num_ref_frames)) {
+		struct h264_dpb_stru *p_H264_Dpb = container_of(p_Dpb,
+					 struct h264_dpb_stru, mDPB);
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			  "Max. number of reference frames exceeded. Invalid stream. lt %d ref %d mum_ref %d\n",
+			  p_Dpb->ltref_frames_in_buffer,
+			  p_Dpb->ref_frames_in_buffer,
+			  p_Dpb->num_ref_frames);
+	}
+}
+
+static void dump_dpb(struct DecodedPictureBuffer *p_Dpb)
+{
+	unsigned i;
+	struct h264_dpb_stru *p_H264_Dpb =
+		container_of(p_Dpb, struct h264_dpb_stru, mDPB);
+	if ((h264_debug_flag & PRINT_FLAG_DUMP_DPB) == 0)
+		return;
+	for (i = 0; i < p_Dpb->used_size; i++) {
+		dpb_print(p_H264_Dpb->decoder_index,
+			PRINT_FLAG_DUMP_DPB,
+			"(");
+		dpb_print(p_H264_Dpb->decoder_index,
+			PRINT_FLAG_DUMP_DPB | 0x100,
+			"fn=%d  ", p_Dpb->fs[i]->frame_num);
+		if (p_Dpb->fs[i]->is_used & 1) {
+			if (p_Dpb->fs[i]->top_field)
+				dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DUMP_DPB | 0x100,
+				"T: poc=%d  ",
+				p_Dpb->fs[i]->top_field->poc);
+			else
+				dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DUMP_DPB | 0x100,
+				"T: poc=%d  ",
+				p_Dpb->fs[i]->frame->top_poc);
+		}
+		if (p_Dpb->fs[i]->is_used & 2) {
+			if (p_Dpb->fs[i]->bottom_field)
+				dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DUMP_DPB | 0x100,
+				"B: poc=%d  ",
+				p_Dpb->fs[i]->bottom_field->poc);
+			else
+				dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DUMP_DPB | 0x100,
+				"B: poc=%d  ",
+				p_Dpb->fs[i]->frame->bottom_poc);
+		}
+		if (p_Dpb->fs[i]->is_used == 3)
+			dpb_print(p_H264_Dpb->decoder_index,
+			PRINT_FLAG_DUMP_DPB | 0x100,
+			"F: poc=%d  ",
+			p_Dpb->fs[i]->frame->poc);
+		dpb_print(p_H264_Dpb->decoder_index,
+			PRINT_FLAG_DUMP_DPB | 0x100,
+			"G: poc=%d)  ", p_Dpb->fs[i]->poc);
+		if (p_Dpb->fs[i]->is_reference)
+			dpb_print(p_H264_Dpb->decoder_index,
+			PRINT_FLAG_DUMP_DPB | 0x100,
+			"ref (%d) ", p_Dpb->fs[i]->is_reference);
+		if (p_Dpb->fs[i]->is_long_term)
+			dpb_print(p_H264_Dpb->decoder_index,
+			PRINT_FLAG_DUMP_DPB | 0x100,
+			"lt_ref (%d) ", p_Dpb->fs[i]->is_reference);
+		if (p_Dpb->fs[i]->is_output)
+			dpb_print(p_H264_Dpb->decoder_index,
+			PRINT_FLAG_DUMP_DPB | 0x100,
+			"out  ");
+		if (p_Dpb->fs[i]->pre_output)
+			dpb_print(p_H264_Dpb->decoder_index,
+			PRINT_FLAG_DUMP_DPB | 0x100,
+			"for_out  ");
+		if (p_Dpb->fs[i]->is_used == 3) {
+			if (p_Dpb->fs[i]->frame->non_existing)
+				dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DUMP_DPB | 0x100,
+				"ne  ");
+		}
+#if (MVC_EXTENSION_ENABLE)
+		if (p_Dpb->fs[i]->is_reference)
+			dpb_print(p_H264_Dpb->decoder_index,
+			PRINT_FLAG_DUMP_DPB | 0x100,
+			"view_id (%d) ", p_Dpb->fs[i]->view_id);
+#endif
+		dpb_print(p_H264_Dpb->decoder_index,
+			PRINT_FLAG_DUMP_DPB | 0x100,
+			"\n");
+	}
+}
+
+
+/*!
+ ************************************************************************
+ * \brief
+ *    adaptive memory management
+ *
+ ************************************************************************
+ */
+
+static int get_pic_num_x(struct StorablePicture *p,
+			 int difference_of_pic_nums_minus1)
+{
+	int currPicNum;
+
+	if (p->structure == FRAME)
+		currPicNum = p->frame_num;
+	else
+		currPicNum = 2 * p->frame_num + 1;
+
+	return currPicNum - (difference_of_pic_nums_minus1 + 1);
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    Adaptive Memory Management: Mark short term picture unused
+ ************************************************************************
+ */
+static void mm_unmark_short_term_for_reference(struct DecodedPictureBuffer
+		*p_Dpb, struct StorablePicture *p,
+		int difference_of_pic_nums_minus1)
+{
+	int picNumX;
+
+	unsigned int i;
+
+	picNumX = get_pic_num_x(p, difference_of_pic_nums_minus1);
+
+	for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+		if (p->structure == FRAME) {
+			if ((p_Dpb->fs_ref[i]->is_reference == 3) &&
+			    (p_Dpb->fs_ref[i]->is_long_term == 0)) {
+				if (p_Dpb->fs_ref[i]->frame->pic_num ==
+					picNumX) {
+					unmark_for_reference(p_Dpb,
+						p_Dpb->fs_ref[i]);
+					return;
+				}
+			}
+		} else {
+			if ((p_Dpb->fs_ref[i]->is_reference & 1) &&
+			    (!(p_Dpb->fs_ref[i]->is_long_term & 1))) {
+				if (p_Dpb->fs_ref[i]->top_field->pic_num ==
+					picNumX) {
+					p_Dpb->fs_ref[i]->
+					top_field->used_for_reference = 0;
+					p_Dpb->fs_ref[i]->is_reference &= 2;
+					if (p_Dpb->fs_ref[i]->is_used == 3) {
+						p_Dpb->fs_ref[i]->frame->
+							used_for_reference = 0;
+					}
+					return;
+				}
+			}
+			if ((p_Dpb->fs_ref[i]->is_reference & 2) &&
+			    (!(p_Dpb->fs_ref[i]->is_long_term & 2))) {
+				if (p_Dpb->fs_ref[i]->bottom_field->pic_num ==
+					picNumX) {
+					p_Dpb->fs_ref[i]->bottom_field->
+					used_for_reference = 0;
+					p_Dpb->fs_ref[i]->is_reference &= 1;
+					if (p_Dpb->fs_ref[i]->is_used == 3) {
+						p_Dpb->fs_ref[i]->frame->
+						used_for_reference = 0;
+					}
+					return;
+				}
+			}
+		}
+	}
+}
+
+static void unmark_for_long_term_reference(struct FrameStore *fs)
+{
+	if (fs->is_used & 1) {
+		if (fs->top_field) {
+			fs->top_field->used_for_reference = 0;
+			fs->top_field->is_long_term = 0;
+		}
+	}
+	if (fs->is_used & 2) {
+		if (fs->bottom_field) {
+			fs->bottom_field->used_for_reference = 0;
+			fs->bottom_field->is_long_term = 0;
+		}
+	}
+	if (fs->is_used == 3) {
+		if (fs->top_field && fs->bottom_field) {
+			fs->top_field->used_for_reference = 0;
+			fs->top_field->is_long_term = 0;
+			fs->bottom_field->used_for_reference = 0;
+			fs->bottom_field->is_long_term = 0;
+		}
+		fs->frame->used_for_reference = 0;
+		fs->frame->is_long_term = 0;
+	}
+
+	fs->is_reference = 0;
+	fs->is_long_term = 0;
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    Adaptive Memory Management: Mark long term picture unused
+ ************************************************************************
+ */
+static void mm_unmark_long_term_for_reference(struct DecodedPictureBuffer
+		*p_Dpb, struct StorablePicture *p, int long_term_pic_num)
+{
+	unsigned int i;
+	for (i = 0; i < p_Dpb->ltref_frames_in_buffer; i++) {
+		if (p->structure == FRAME) {
+			if ((p_Dpb->fs_ltref[i]->is_reference == 3) &&
+			    (p_Dpb->fs_ltref[i]->is_long_term == 3)) {
+				if (p_Dpb->fs_ltref[i]->frame->
+					long_term_pic_num ==
+					long_term_pic_num) {
+					unmark_for_long_term_reference(
+						p_Dpb->fs_ltref[i]);
+				}
+			}
+		} else {
+			if ((p_Dpb->fs_ltref[i]->is_reference & 1) &&
+			    ((p_Dpb->fs_ltref[i]->is_long_term & 1))) {
+				if (p_Dpb->fs_ltref[i]->top_field->
+					long_term_pic_num ==
+					long_term_pic_num) {
+					p_Dpb->fs_ltref[i]->top_field->
+						used_for_reference = 0;
+					p_Dpb->fs_ltref[i]->top_field->
+						is_long_term = 0;
+					p_Dpb->fs_ltref[i]->is_reference &= 2;
+					p_Dpb->fs_ltref[i]->is_long_term &= 2;
+					if (p_Dpb->fs_ltref[i]->is_used == 3) {
+						p_Dpb->fs_ltref[i]->frame->
+							used_for_reference = 0;
+						p_Dpb->fs_ltref[i]->frame->
+							is_long_term = 0;
+					}
+					return;
+				}
+			}
+			if ((p_Dpb->fs_ltref[i]->is_reference & 2) &&
+			    ((p_Dpb->fs_ltref[i]->is_long_term & 2))) {
+				if (p_Dpb->fs_ltref[i]->bottom_field->
+					long_term_pic_num ==
+					long_term_pic_num) {
+					p_Dpb->fs_ltref[i]->bottom_field->
+						used_for_reference = 0;
+					p_Dpb->fs_ltref[i]->bottom_field->
+						is_long_term = 0;
+					p_Dpb->fs_ltref[i]->is_reference &= 1;
+					p_Dpb->fs_ltref[i]->is_long_term &= 1;
+					if (p_Dpb->fs_ltref[i]->is_used == 3) {
+						p_Dpb->fs_ltref[i]->frame->
+							used_for_reference = 0;
+						p_Dpb->fs_ltref[i]->frame->
+							is_long_term = 0;
+					}
+					return;
+				}
+			}
+		}
+	}
+}
+
+
+/*!
+ ************************************************************************
+ * \brief
+ *    Mark a long-term reference frame or complementary
+ *    field pair unused for referemce
+ ************************************************************************
+ */
+static void unmark_long_term_frame_for_reference_by_frame_idx(
+	struct DecodedPictureBuffer *p_Dpb, int long_term_frame_idx)
+{
+	unsigned int i;
+	for (i = 0; i < p_Dpb->ltref_frames_in_buffer; i++) {
+		if (p_Dpb->fs_ltref[i]->long_term_frame_idx ==
+			long_term_frame_idx)
+			unmark_for_long_term_reference(p_Dpb->fs_ltref[i]);
+	}
+}
+
+
+static void unmark1(struct DecodedPictureBuffer *p_Dpb,
+	unsigned curr_frame_num, int i)
+{
+	if (p_Dpb->last_picture) {
+		if ((p_Dpb->last_picture != p_Dpb->fs_ltref[i]) ||
+			p_Dpb->last_picture->frame_num != curr_frame_num) {
+			unmark_for_long_term_reference(p_Dpb->fs_ltref[i]);
+		} else {
+			unmark_for_long_term_reference(p_Dpb->fs_ltref[i]);
+		}
+	}
+}
+
+static void unmark2(struct DecodedPictureBuffer *p_Dpb,
+	int curr_pic_num, int i)
+{
+	if ((p_Dpb->fs_ltref[i]->frame_num) != (unsigned)(curr_pic_num >> 1))
+		unmark_for_long_term_reference(p_Dpb->fs_ltref[i]);
+}
+
+static void unmark3_top(struct DecodedPictureBuffer *p_Dpb,
+	unsigned curr_frame_num, int curr_pic_num, int mark_current, int i)
+{
+	if (p_Dpb->fs_ltref[i]->is_long_term == 3) {
+		unmark_for_long_term_reference(p_Dpb->fs_ltref[i]);
+	} else {
+		if (p_Dpb->fs_ltref[i]->is_long_term == 1) {
+			unmark_for_long_term_reference(p_Dpb->fs_ltref[i]);
+		} else {
+			if (mark_current)
+				unmark1(p_Dpb, curr_frame_num, i);
+			else
+				unmark2(p_Dpb, curr_pic_num, i);
+		}
+	}
+}
+
+static void unmark3_bottom(struct DecodedPictureBuffer *p_Dpb,
+	unsigned curr_frame_num, int curr_pic_num, int mark_current, int i)
+{
+	if (p_Dpb->fs_ltref[i]->is_long_term == 2) {
+		unmark_for_long_term_reference(p_Dpb->fs_ltref[i]);
+	} else {
+		if (mark_current)
+			unmark1(p_Dpb, curr_frame_num, i);
+		else
+			unmark2(p_Dpb, curr_pic_num, i);
+	}
+}
+
+static void unmark_long_term_field_for_reference_by_frame_idx(
+	struct DecodedPictureBuffer *p_Dpb, enum PictureStructure structure,
+	int long_term_frame_idx, int mark_current, unsigned curr_frame_num,
+	int curr_pic_num)
+{
+	struct VideoParameters *p_Vid = p_Dpb->p_Vid;
+	unsigned i;
+
+	/* assert(structure!=FRAME); */
+	if (curr_pic_num < 0)
+		curr_pic_num += (2 * p_Vid->max_frame_num);
+
+	for (i = 0; i < p_Dpb->ltref_frames_in_buffer; i++) {
+		if (p_Dpb->fs_ltref[i]->long_term_frame_idx ==
+			long_term_frame_idx) {
+			if (structure == TOP_FIELD)
+				unmark3_top(p_Dpb, curr_frame_num,
+					curr_pic_num, mark_current, i);
+
+			if (structure == BOTTOM_FIELD)
+				unmark3_bottom(p_Dpb, curr_frame_num,
+					curr_pic_num, mark_current, i);
+		}
+	}
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    mark a picture as long-term reference
+ ************************************************************************
+ */
+static void mark_pic_long_term(struct DecodedPictureBuffer *p_Dpb,
+			       struct StorablePicture *p,
+			       int long_term_frame_idx, int picNumX)
+{
+	struct h264_dpb_stru *p_H264_Dpb = container_of(p_Dpb,
+				struct h264_dpb_stru, mDPB);
+	unsigned int i;
+	int add_top, add_bottom;
+
+	if (p->structure == FRAME) {
+		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+			if (p_Dpb->fs_ref[i]->is_reference == 3) {
+				if ((!p_Dpb->fs_ref[i]->frame->
+					is_long_term) &&
+				    (p_Dpb->fs_ref[i]->frame->pic_num ==
+					picNumX)) {
+					p_Dpb->fs_ref[i]->
+						long_term_frame_idx =
+					p_Dpb->fs_ref[i]->frame->
+						long_term_frame_idx =
+						long_term_frame_idx;
+					p_Dpb->fs_ref[i]->frame->
+						long_term_pic_num =
+						long_term_frame_idx;
+					p_Dpb->fs_ref[i]->frame->
+						is_long_term = 1;
+
+					if (p_Dpb->fs_ref[i]->top_field &&
+					    p_Dpb->fs_ref[i]->bottom_field) {
+						p_Dpb->fs_ref[i]->top_field->
+						long_term_frame_idx =
+							p_Dpb->fs_ref[i]->
+							bottom_field->
+							long_term_frame_idx =
+							long_term_frame_idx;
+						p_Dpb->fs_ref[i]->top_field->
+							long_term_pic_num =
+							long_term_frame_idx;
+						p_Dpb->fs_ref[i]->
+							bottom_field->
+							long_term_pic_num =
+							long_term_frame_idx;
+
+						p_Dpb->fs_ref[i]->top_field->
+							is_long_term =
+							p_Dpb->fs_ref[i]->
+							bottom_field->
+							is_long_term
+							= 1;
+
+					}
+					p_Dpb->fs_ref[i]->is_long_term = 3;
+					return;
+				}
+			}
+		}
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			  "Warning: reference frame for long term marking not found\n");
+	} else {
+		if (p->structure == TOP_FIELD) {
+			add_top    = 1;
+			add_bottom = 0;
+		} else {
+			add_top    = 0;
+			add_bottom = 1;
+		}
+		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+			if (p_Dpb->fs_ref[i]->is_reference & 1) {
+				if ((!p_Dpb->fs_ref[i]->top_field->
+					is_long_term) &&
+				    (p_Dpb->fs_ref[i]->top_field->pic_num ==
+					picNumX)) {
+					if ((p_Dpb->fs_ref[i]->
+						is_long_term) &&
+					    (p_Dpb->fs_ref[i]->
+						long_term_frame_idx !=
+						long_term_frame_idx)) {
+						dpb_print(p_H264_Dpb->
+						decoder_index,
+						PRINT_FLAG_DPB_DETAIL,
+						"Warning: assigning long_term_frame_idx different from other field\n");
+					}
+
+					p_Dpb->fs_ref[i]->
+						long_term_frame_idx =
+						p_Dpb->fs_ref[i]->top_field->
+						long_term_frame_idx
+						= long_term_frame_idx;
+					p_Dpb->fs_ref[i]->top_field->
+						long_term_pic_num =
+						2 * long_term_frame_idx +
+						add_top;
+					p_Dpb->fs_ref[i]->top_field->
+						is_long_term = 1;
+					p_Dpb->fs_ref[i]->is_long_term |= 1;
+					if (p_Dpb->fs_ref[i]->is_long_term ==
+						3) {
+						p_Dpb->fs_ref[i]->frame->
+							is_long_term = 1;
+						p_Dpb->fs_ref[i]->frame->
+							long_term_frame_idx =
+							p_Dpb->fs_ref[i]->
+							frame->
+							long_term_pic_num =
+							long_term_frame_idx;
+					}
+					return;
+				}
+			}
+			if (p_Dpb->fs_ref[i]->is_reference & 2) {
+				if ((!p_Dpb->fs_ref[i]->bottom_field->
+					is_long_term) &&
+				    (p_Dpb->fs_ref[i]->bottom_field->pic_num
+					== picNumX)) {
+					if ((p_Dpb->fs_ref[i]->
+						is_long_term) &&
+					    (p_Dpb->fs_ref[i]->
+						long_term_frame_idx !=
+						long_term_frame_idx)) {
+						dpb_print(p_H264_Dpb->
+						decoder_index,
+						PRINT_FLAG_DPB_DETAIL,
+						"Warning: assigning long_term_frame_idx different from other field\n");
+					}
+
+					p_Dpb->fs_ref[i]->
+						long_term_frame_idx =
+						p_Dpb->fs_ref[i]->bottom_field
+						->long_term_frame_idx
+						= long_term_frame_idx;
+					p_Dpb->fs_ref[i]->bottom_field->
+						long_term_pic_num = 2 *
+						long_term_frame_idx +
+						add_bottom;
+					p_Dpb->fs_ref[i]->bottom_field->
+						is_long_term = 1;
+					p_Dpb->fs_ref[i]->is_long_term |= 2;
+					if (p_Dpb->fs_ref[i]->
+						is_long_term == 3) {
+						p_Dpb->fs_ref[i]->frame->
+							is_long_term = 1;
+						p_Dpb->fs_ref[i]->frame->
+							long_term_frame_idx =
+							p_Dpb->fs_ref[i]->
+							frame->
+							long_term_pic_num =
+							long_term_frame_idx;
+					}
+					return;
+				}
+			}
+		}
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			  "Warning: reference field for long term marking not found\n");
+	}
+}
+
+
+/*!
+ ************************************************************************
+ * \brief
+ *    Assign a long term frame index to a short term picture
+ ************************************************************************
+ */
+static void mm_assign_long_term_frame_idx(struct DecodedPictureBuffer *p_Dpb,
+		struct StorablePicture *p, int difference_of_pic_nums_minus1,
+		int long_term_frame_idx)
+{
+	struct h264_dpb_stru *p_H264_Dpb = container_of(p_Dpb,
+			struct h264_dpb_stru, mDPB);
+	int picNumX = get_pic_num_x(p, difference_of_pic_nums_minus1);
+
+	/* remove frames/fields with same long_term_frame_idx */
+	if (p->structure == FRAME) {
+		unmark_long_term_frame_for_reference_by_frame_idx(p_Dpb,
+				long_term_frame_idx);
+	} else {
+		unsigned i;
+		enum PictureStructure structure = FRAME;
+
+		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+			if (p_Dpb->fs_ref[i]->is_reference & 1) {
+				if (p_Dpb->fs_ref[i]->top_field->
+					pic_num == picNumX) {
+					structure = TOP_FIELD;
+					break;
+				}
+			}
+			if (p_Dpb->fs_ref[i]->is_reference & 2) {
+				if (p_Dpb->fs_ref[i]->bottom_field->
+					pic_num == picNumX) {
+					structure = BOTTOM_FIELD;
+					break;
+				}
+			}
+		}
+		if (structure == FRAME) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				  PRINT_FLAG_DPB_DETAIL,
+				  "field for long term marking not found %d",
+				  200);
+		}
+
+		unmark_long_term_field_for_reference_by_frame_idx(p_Dpb,
+				structure,
+				long_term_frame_idx, 0, 0, picNumX);
+	}
+
+	mark_pic_long_term(p_Dpb, p, long_term_frame_idx, picNumX);
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    Set new max long_term_frame_idx
+ ************************************************************************
+ */
+static void mm_update_max_long_term_frame_idx(struct DecodedPictureBuffer
+		*p_Dpb, int max_long_term_frame_idx_plus1)
+{
+	unsigned int i;
+
+	p_Dpb->max_long_term_pic_idx = max_long_term_frame_idx_plus1 - 1;
+
+	/* check for invalid frames */
+	for (i = 0; i < p_Dpb->ltref_frames_in_buffer; i++) {
+		if (p_Dpb->fs_ltref[i]->long_term_frame_idx >
+			p_Dpb->max_long_term_pic_idx) {
+			unmark_for_long_term_reference(p_Dpb->fs_ltref[i]);
+		}
+	}
+}
+
+
+/*!
+ ************************************************************************
+ * \brief
+ *    Mark all long term reference pictures unused for reference
+ ************************************************************************
+ */
+static void mm_unmark_all_long_term_for_reference(struct DecodedPictureBuffer
+		*p_Dpb)
+{
+	mm_update_max_long_term_frame_idx(p_Dpb, 0);
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    Mark all short term reference pictures unused for reference
+ ************************************************************************
+ */
+static void mm_unmark_all_short_term_for_reference(struct DecodedPictureBuffer
+		*p_Dpb)
+{
+	unsigned int i;
+	for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++)
+		unmark_for_reference(p_Dpb, p_Dpb->fs_ref[i]);
+	update_ref_list(p_Dpb);
+}
+
+
+/*!
+ ************************************************************************
+ * \brief
+ *    Mark the current picture used for long term reference
+ ************************************************************************
+ */
+static void mm_mark_current_picture_long_term(struct DecodedPictureBuffer
+		*p_Dpb, struct StorablePicture *p, int long_term_frame_idx)
+{
+	/* remove long term pictures with same long_term_frame_idx */
+	if (p->structure == FRAME) {
+		unmark_long_term_frame_for_reference_by_frame_idx(p_Dpb,
+				long_term_frame_idx);
+	} else {
+		unmark_long_term_field_for_reference_by_frame_idx(p_Dpb,
+				p->structure, long_term_frame_idx,
+				1, p->pic_num, 0);
+	}
+
+	p->is_long_term = 1;
+	p->long_term_frame_idx = long_term_frame_idx;
+}
+
+static void adaptive_memory_management(struct h264_dpb_stru *p_H264_Dpb,
+				       struct StorablePicture *p)
+{
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+	struct DecRefPicMarking_s *tmp_drpm;
+	struct VideoParameters *p_Vid = p_Dpb->p_Vid;
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+				"%s\n", __func__);
+	p_Vid->last_has_mmco_5 = 0;
+
+	/* assert (!p->idr_flag); */
+	/* assert (p->adaptive_ref_pic_buffering_flag); */
+
+	while (p->dec_ref_pic_marking_buffer) {
+		tmp_drpm = p->dec_ref_pic_marking_buffer;
+		switch (tmp_drpm->memory_management_control_operation) {
+		case 0:
+			if (tmp_drpm->Next != NULL)
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_ERROR,
+					"error, memory_management_control_operation = 0 not last operation in buffer\n");
+			break;
+		case 1:
+			mm_unmark_short_term_for_reference(p_Dpb, p,
+				tmp_drpm->difference_of_pic_nums_minus1);
+			update_ref_list(p_Dpb);
+			break;
+		case 2:
+			mm_unmark_long_term_for_reference(p_Dpb, p,
+				tmp_drpm->long_term_pic_num);
+			update_ltref_list(p_Dpb);
+			break;
+		case 3:
+			mm_assign_long_term_frame_idx(p_Dpb, p,
+				tmp_drpm->difference_of_pic_nums_minus1,
+				tmp_drpm->long_term_frame_idx);
+			update_ref_list(p_Dpb);
+			update_ltref_list(p_Dpb);
+			break;
+		case 4:
+			mm_update_max_long_term_frame_idx(p_Dpb,
+				tmp_drpm->max_long_term_frame_idx_plus1);
+			update_ltref_list(p_Dpb);
+			break;
+		case 5:
+			mm_unmark_all_short_term_for_reference(p_Dpb);
+			mm_unmark_all_long_term_for_reference(p_Dpb);
+			p_Vid->last_has_mmco_5 = 1;
+			break;
+		case 6:
+			mm_mark_current_picture_long_term(p_Dpb, p,
+				tmp_drpm->long_term_frame_idx);
+			check_num_ref(p_Dpb);
+			break;
+		default:
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_ERROR,
+				"error, invalid memory_management_control_operation in buffer\n");
+		}
+		p->dec_ref_pic_marking_buffer = tmp_drpm->Next;
+		/* free (tmp_drpm); */
+	}
+	if (p_Vid->last_has_mmco_5) {
+		p->pic_num = p->frame_num = 0;
+
+		switch (p->structure) {
+		case TOP_FIELD: {
+			/* p->poc = p->top_poc = p_Vid->toppoc =0; */
+			p->poc = p->top_poc = 0;
+			break;
+		}
+		case BOTTOM_FIELD: {
+			/* p->poc = p->bottom_poc = p_Vid->bottompoc = 0; */
+			p->poc = p->bottom_poc = 0;
+			break;
+		}
+		case FRAME: {
+			p->top_poc    -= p->poc;
+			p->bottom_poc -= p->poc;
+
+			/* p_Vid->toppoc = p->top_poc; */
+			/* p_Vid->bottompoc = p->bottom_poc; */
+
+			p->poc = imin(p->top_poc, p->bottom_poc);
+			/* p_Vid->framepoc = p->poc; */
+			break;
+		}
+		}
+		/* currSlice->ThisPOC = p->poc; */
+#if (MVC_EXTENSION_ENABLE)
+		if (p->view_id == 0) {
+			flush_dpb(p_Vid->p_Dpb_layer[0]);
+			flush_dpb(p_Vid->p_Dpb_layer[1]);
+		} else {
+			flush_dpb(p_Dpb);
+		}
+#else
+		flush_dpb(p_H264_Dpb);
+#endif
+	}
+}
+
+
+void store_picture_in_dpb(struct h264_dpb_stru *p_H264_Dpb,
+			  struct StorablePicture *p)
+{
+	/* struct VideoParameters *p_Vid = p_Dpb->p_Vid; */
+	struct VideoParameters *p_Vid = &p_H264_Dpb->mVideo;
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+	unsigned i;
+#if 0
+	int poc, pos;
+#endif
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s p_Vid %p\n", __func__, p_Vid);
+
+	/* picture error concealment */
+
+	/* diagnostics */
+	/* dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"Storing (%s) non-ref pic with frame_num #%d\n",
+		(p->type == FRAME)?"FRAME":(p->type == TOP_FIELD)?
+		"TOP_FIELD":"BOTTOM_FIELD", p->pic_num); */
+	/* if frame, check for new store, */
+	/* assert (p!=NULL); */
+
+	p_Vid->last_has_mmco_5 = 0;
+	p_Vid->last_pic_bottom_field = (p->structure == BOTTOM_FIELD);
+
+	if (p->idr_flag) {
+		idr_memory_management(p_H264_Dpb, p);
+#if 0
+/* ??? */
+		/* picture error concealment */
+		memset(p_Vid->pocs_in_dpb, 0, sizeof(int) * 100);
+#endif
+	} else {
+#if 1
+/* ??? */
+		/* adaptive memory management */
+		if (p->used_for_reference &&
+			(p->adaptive_ref_pic_buffering_flag))
+			adaptive_memory_management(p_H264_Dpb, p);
+#endif
+	}
+
+	if ((p->structure == TOP_FIELD) || (p->structure == BOTTOM_FIELD)) {
+		/* check for frame store with same pic_number */
+		if (p_Dpb->last_picture) {
+			if ((int)p_Dpb->last_picture->frame_num ==
+				p->pic_num) {
+				if (((p->structure == TOP_FIELD) &&
+				    (p_Dpb->last_picture->is_used == 2)) ||
+				    ((p->structure == BOTTOM_FIELD) &&
+				    (p_Dpb->last_picture->is_used == 1))) {
+					if ((p->used_for_reference &&
+					    (p_Dpb->last_picture->
+						is_orig_reference != 0)) ||
+					    (!p->used_for_reference &&
+						(p_Dpb->last_picture->
+						is_orig_reference == 0))) {
+						insert_picture_in_dpb(
+							p_H264_Dpb,
+							p_Dpb->last_picture,
+							p);
+						update_ref_list(p_Dpb);
+						update_ltref_list(p_Dpb);
+						dump_dpb(p_Dpb);
+						p_Dpb->last_picture = NULL;
+						return;
+					}
+				}
+			}
+		}
+	}
+	/* this is a frame or a field which has no stored
+	 * complementary field */
+
+	/* sliding window, if necessary */
+	if ((!p->idr_flag) && (p->used_for_reference &&
+			       (!p->adaptive_ref_pic_buffering_flag))) {
+		sliding_window_memory_management(p_Dpb, p);
+	}
+
+	/* picture error concealment */
+	if (p_Vid->conceal_mode != 0) {
+		for (i = 0; i < p_Dpb->size; i++)
+			if (p_Dpb->fs[i]->is_reference)
+				p_Dpb->fs[i]->concealment_reference = 1;
+	}
+
+#ifndef OLD_OUTPUT_CODE
+	while (remove_unused_frame_from_dpb(p_H264_Dpb))
+		;
+
+	if ((h264_debug_flag & OUTPUT_CURRENT_BUF) == 0) {
+		while (output_frames(p_H264_Dpb, 0))
+			;
+	}
+#else
+	/* OLD_OUTPUT_CODE */
+
+	/* first try to remove unused frames */
+	if (p_Dpb->used_size == p_Dpb->size) {
+#if 0
+		/* ??? */
+		/* picture error concealment */
+		if (p_Vid->conceal_mode != 0)
+			conceal_non_ref_pics(p_Dpb, 2);
+#endif
+		remove_unused_frame_from_dpb(p_H264_Dpb);
+
+#if 0
+		/* ??? */
+		if (p_Vid->conceal_mode != 0)
+			sliding_window_poc_management(p_Dpb, p);
+#endif
+	}
+
+	/* then output frames until one can be removed */
+/* #ifdef OUTPUT_BUFFER_IN_C */
+	if ((h264_debug_flag & OUTPUT_CURRENT_BUF) == 0) {
+		if (p_Dpb->used_size > (p_Dpb->size - 5))
+			output_one_frame_from_dpb(p_H264_Dpb);
+	} else {
+/* #else */
+		while (p_Dpb->used_size == p_Dpb->size) {
+#if 0
+			/* non-reference frames may be output directly */
+			if (!p->used_for_reference) {
+				get_smallest_poc(p_Dpb, &poc, &pos);
+				if ((-1 == pos) || (p->poc < poc)) {
+#if (MVC_EXTENSION_ENABLE)
+					if (p_Vid->profile_idc >= MVC_HIGH)
+						dpb_print(
+						p_H264_Dpb->decoder_index,
+						PRINT_FLAG_DPB_DETAIL,
+						"Display order might not be correct, %d, %d\n",
+						p->view_id, p->poc);
+#endif
+#if 0
+/* ??? */
+#if (MVC_EXTENSION_ENABLE)
+					direct_output(p_Vid, p, p_Vid->
+						p_out_mvc[p_Dpb->layer_id]);
+#else
+					direct_output(p_Vid, p, p_Vid->p_out);
+#endif
+#endif
+					return;
+				}
+			}
+#endif
+			/* flush a frame */
+			output_one_frame_from_dpb(p_H264_Dpb);
+		}
+
+	}
+/* #endif */
+	/* OLD_OUTPUT_CODE */
+#endif
+
+	/* check for duplicate frame number in short term reference buffer */
+	if ((p->used_for_reference) && (!p->is_long_term)) {
+		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+			if (p_Dpb->fs_ref[i]->frame_num == p->frame_num) {
+				dpb_print(p_H264_Dpb->decoder_index,
+					  PRINT_FLAG_DPB_DETAIL,
+					  "duplicate frame_num in short-term reference picture buffer %d\n",
+					   500);
+			}
+		}
+	}
+	/* store at end of buffer */
+
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		  "%s p_Dpb->used_size %d\n", __func__, p_Dpb->used_size);
+	if (p_Dpb->used_size >= p_Dpb->size) {
+		dpb_print(p_H264_Dpb->decoder_index,
+			PRINT_FLAG_ERROR,
+			"%s Error: used_sizd %d is large than dpb size\r\n",
+			__func__, p_Dpb->used_size);
+		h264_debug_flag |= PRINT_FLAG_DUMP_DPB;
+		dump_dpb(p_Dpb);
+		return;
+	}
+
+	insert_picture_in_dpb(p_H264_Dpb, p_Dpb->fs[p_Dpb->used_size], p);
+	if (h264_debug_flag & OUTPUT_CURRENT_BUF) {
+		prepare_display_buf(p_H264_Dpb->vdec,
+			p_Dpb->fs[p_Dpb->used_size]);
+		set_frame_output_flag(p_H264_Dpb, p_Dpb->used_size);
+
+	}
+
+	/* picture error concealment */
+	if (p->idr_flag)
+		p_Vid->earlier_missing_poc = 0;
+
+	if (p->structure != FRAME)
+		p_Dpb->last_picture = p_Dpb->fs[p_Dpb->used_size];
+	else
+		p_Dpb->last_picture = NULL;
+
+	p_Dpb->used_size++;
+#if 0
+/* ??? */
+	if (p_Vid->conceal_mode != 0)
+		p_Vid->pocs_in_dpb[p_Dpb->used_size - 1] = p->poc;
+#endif
+	update_ref_list(p_Dpb);
+	update_ltref_list(p_Dpb);
+
+	check_num_ref(p_Dpb);
+
+	dump_dpb(p_Dpb);
+}
+
+void bufmgr_post(struct h264_dpb_stru *p_H264_Dpb)
+{
+	/*VideoParameters *p_Vid = p_Dpb->p_Vid;*/
+	struct VideoParameters *p_Vid = &p_H264_Dpb->mVideo;
+	if (p_Vid->last_has_mmco_5)
+		p_Vid->pre_frame_num = 0;
+}
+/**********************************
+*
+*   Initialize reference lists
+***********************************/
+#define __COMPARE(context, p1, p2) comp(p1, p2)
+#define __SHORTSORT(lo, hi, width, comp, context) \
+	shortsort(lo, hi, width, comp)
+#define CUTOFF 8            /* testing shows that this is good value */
+#define STKSIZ (8*sizeof(void *) - 2)
+
+#undef swap
+static void swap(
+	char *a,
+	char *b,
+	size_t width
+)
+{
+	char tmp;
+
+	if (a != b)
+		/* Do the swap one character at a time to avoid potential
+		   alignment problems. */
+		while (width--) {
+			tmp = *a;
+			*a++ = *b;
+			*b++ = tmp;
+		}
+}
+
+static void shortsort(
+	char *lo,
+	char *hi,
+	size_t width,
+	int (*comp)(const void *, const void *)
+)
+{
+	char *p, *max;
+
+	/* Note: in assertions below, i and j are alway inside original
+	   bound of array to sort. */
+
+	while (hi > lo) {
+		/* A[i] <= A[j] for i <= j, j > hi */
+		max = lo;
+		for (p = lo + width; p <= hi; p += width) {
+			/* A[i] <= A[max] for lo <= i < p */
+			if (__COMPARE(context, p, max) > 0)
+				max = p;
+			/* A[i] <= A[max] for lo <= i <= p */
+		}
+
+		/* A[i] <= A[max] for lo <= i <= hi */
+
+		swap(max, hi, width);
+
+		/* A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j,
+		   j >= hi */
+
+		hi -= width;
+
+		/* A[i] <= A[j] for i <= j, j > hi, loop top condition
+		   established */
+	}
+	/* A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j]
+	   for i < j, so array is sorted */
+}
+
+static void qsort(
+	void *base,
+	size_t num,
+	size_t width,
+	int (*comp)(const void *, const void *)
+)
+{
+	char *lo, *hi;              /* ends of sub-array currently sorting */
+	char *mid;                  /* points to middle of subarray */
+	char *loguy, *higuy;        /* traveling pointers for partition step */
+	size_t size;                /* size of the sub-array */
+	char *lostk[STKSIZ], *histk[STKSIZ];
+	int stkptr;                 /* stack for saving sub-array to be
+					processed */
+#if 0
+	/* validation section */
+	_VALIDATE_RETURN_VOID(base != NULL || num == 0, EINVAL);
+	_VALIDATE_RETURN_VOID(width > 0, EINVAL);
+	_VALIDATE_RETURN_VOID(comp != NULL, EINVAL);
+#endif
+	if (num < 2)
+		return;                 /* nothing to do */
+
+	stkptr = 0;                 /* initialize stack */
+
+	lo = (char *)base;
+	hi = (char *)base + width * (num - 1);      /* initialize limits */
+
+	/* this entry point is for pseudo-recursion calling: setting
+	   lo and hi and jumping to here is like recursion, but stkptr is
+	   preserved, locals aren't, so we preserve stuff on the stack */
+recurse:
+
+	size = (hi - lo) / width + 1;        /* number of el's to sort */
+
+	/* below a certain size, it is faster to use a O(n^2) sorting method */
+	if (size <= CUTOFF) {
+		__SHORTSORT(lo, hi, width, comp, context);
+	} else {
+		/* First we pick a partitioning element.  The efficiency of
+		   the algorithm demands that we find one that is approximately
+		   the median of the values, but also that we select one fast.
+		   We choose the median of the first, middle, and last
+		   elements, to avoid bad performance in the face of already
+		   sorted data, or data that is made up of multiple sorted
+		   runs appended together.  Testing shows that a
+		   median-of-three algorithm provides better performance than
+		   simply picking the middle element for the latter case. */
+
+		mid = lo + (size / 2) * width;      /* find middle element */
+
+		/* Sort the first, middle, last elements into order */
+		if (__COMPARE(context, lo, mid) > 0)
+			swap(lo, mid, width);
+		if (__COMPARE(context, lo, hi) > 0)
+			swap(lo, hi, width);
+		if (__COMPARE(context, mid, hi) > 0)
+			swap(mid, hi, width);
+
+		/* We now wish to partition the array into three pieces, one
+		   consisting of elements <= partition element, one of elements
+		   equal to the partition element, and one of elements > than
+		   it. This is done below; comments indicate conditions
+		   established at every step. */
+
+		loguy = lo;
+		higuy = hi;
+
+		/* Note that higuy decreases and loguy increases on every
+		   iteration, so loop must terminate. */
+		for (;;) {
+			/* lo <= loguy < hi, lo < higuy <= hi,
+			   A[i] <= A[mid] for lo <= i <= loguy,
+			   A[i] > A[mid] for higuy <= i < hi,
+			   A[hi] >= A[mid] */
+
+			/* The doubled loop is to avoid calling comp(mid,mid),
+			   since some existing comparison funcs don't work
+			   when passed the same value for both pointers. */
+
+			if (mid > loguy) {
+				do  {
+					loguy += width;
+				} while (loguy < mid &&
+					__COMPARE(context, loguy, mid) <= 0);
+			}
+			if (mid <= loguy) {
+				do  {
+					loguy += width;
+				} while (loguy <= hi &&
+					__COMPARE(context, loguy, mid) <= 0);
+			}
+
+			/* lo < loguy <= hi+1, A[i] <= A[mid] for
+			   lo <= i < loguy,
+			   either loguy > hi or A[loguy] > A[mid] */
+
+			do  {
+				higuy -= width;
+			} while (higuy > mid &&
+					__COMPARE(context, higuy, mid) > 0);
+
+			/* lo <= higuy < hi, A[i] > A[mid] for higuy < i < hi,
+			   either higuy == lo or A[higuy] <= A[mid] */
+
+			if (higuy < loguy)
+				break;
+
+			/* if loguy > hi or higuy == lo, then we would have
+			   exited, so A[loguy] > A[mid], A[higuy] <= A[mid],
+			   loguy <= hi, higuy > lo */
+
+			swap(loguy, higuy, width);
+
+			/* If the partition element was moved, follow it.
+			   Only need to check for mid == higuy, since before
+			   the swap, A[loguy] > A[mid] implies loguy != mid. */
+
+			if (mid == higuy)
+				mid = loguy;
+
+			/* A[loguy] <= A[mid], A[higuy] > A[mid]; so condition
+			   at top of loop is re-established */
+		}
+
+		/*     A[i] <= A[mid] for lo <= i < loguy,
+		       A[i] > A[mid] for higuy < i < hi,
+		       A[hi] >= A[mid]
+		       higuy < loguy
+		   implying:
+		       higuy == loguy-1
+		       or higuy == hi - 1, loguy == hi + 1, A[hi] == A[mid] */
+
+		/* Find adjacent elements equal to the partition element.  The
+		   doubled loop is to avoid calling comp(mid,mid), since some
+		   existing comparison funcs don't work when passed the same
+		   value for both pointers. */
+
+		higuy += width;
+		if (mid < higuy) {
+			do  {
+				higuy -= width;
+			} while (higuy > mid &&
+				__COMPARE(context, higuy, mid) == 0);
+		}
+		if (mid >= higuy) {
+			do  {
+				higuy -= width;
+			} while (higuy > lo &&
+				__COMPARE(context, higuy, mid) == 0);
+		}
+
+		/* OK, now we have the following:
+		      higuy < loguy
+		      lo <= higuy <= hi
+		      A[i]  <= A[mid] for lo <= i <= higuy
+		      A[i]  == A[mid] for higuy < i < loguy
+		      A[i]  >  A[mid] for loguy <= i < hi
+		      A[hi] >= A[mid] */
+
+		/* We've finished the partition, now we want to sort the
+		   subarrays [lo, higuy] and [loguy, hi].
+		   We do the smaller one first to minimize stack usage.
+		   We only sort arrays of length 2 or more.*/
+
+		if (higuy - lo >= hi - loguy) {
+			if (lo < higuy) {
+				lostk[stkptr] = lo;
+				histk[stkptr] = higuy;
+				++stkptr;
+			}                    /* save big recursion for later */
+
+			if (loguy < hi) {
+				lo = loguy;
+				goto recurse;          /* do small recursion */
+			}
+		} else {
+			if (loguy < hi) {
+				lostk[stkptr] = loguy;
+				histk[stkptr] = hi;
+				++stkptr;    /* save big recursion for later */
+			}
+
+			if (lo < higuy) {
+				hi = higuy;
+				goto recurse;          /* do small recursion */
+			}
+		}
+	}
+
+	/* We have sorted the array, except for any pending sorts on the stack.
+	   Check if there are any, and do them. */
+
+	--stkptr;
+	if (stkptr >= 0) {
+		lo = lostk[stkptr];
+		hi = histk[stkptr];
+		goto recurse;           /* pop subarray from stack */
+	} else
+		return;                 /* all subarrays done */
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    compares two stored pictures by picture number for qsort in
+ *    descending order
+ *
+ ************************************************************************
+ */
+static inline int compare_pic_by_pic_num_desc(const void *arg1,
+		const void *arg2)
+{
+	int pic_num1 = (*(struct StorablePicture **)arg1)->pic_num;
+	int pic_num2 = (*(struct StorablePicture **)arg2)->pic_num;
+
+	if (pic_num1 < pic_num2)
+		return 1;
+	if (pic_num1 > pic_num2)
+		return -1;
+	else
+		return 0;
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    compares two stored pictures by picture number for qsort in
+ *    descending order
+ *
+ ************************************************************************
+ */
+static inline int compare_pic_by_lt_pic_num_asc(const void *arg1,
+		const void *arg2)
+{
+	int long_term_pic_num1 =
+		(*(struct StorablePicture **)arg1)->long_term_pic_num;
+	int long_term_pic_num2 =
+		(*(struct StorablePicture **)arg2)->long_term_pic_num;
+
+	if (long_term_pic_num1 < long_term_pic_num2)
+		return -1;
+	if (long_term_pic_num1 > long_term_pic_num2)
+		return 1;
+	else
+		return 0;
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    compares two frame stores by pic_num for qsort in descending order
+ *
+ ************************************************************************
+ */
+static inline int compare_fs_by_frame_num_desc(const void *arg1,
+		const void *arg2)
+{
+	int frame_num_wrap1 = (*(struct FrameStore **)arg1)->frame_num_wrap;
+	int frame_num_wrap2 = (*(struct FrameStore **)arg2)->frame_num_wrap;
+	if (frame_num_wrap1 < frame_num_wrap2)
+		return 1;
+	if (frame_num_wrap1 > frame_num_wrap2)
+		return -1;
+	else
+		return 0;
+}
+
+
+/*!
+ ************************************************************************
+ * \brief
+ *    compares two frame stores by lt_pic_num for qsort in descending order
+ *
+ ************************************************************************
+ */
+static inline int compare_fs_by_lt_pic_idx_asc(const void *arg1,
+		const void *arg2)
+{
+	int long_term_frame_idx1 =
+		(*(struct FrameStore **)arg1)->long_term_frame_idx;
+	int long_term_frame_idx2 =
+		(*(struct FrameStore **)arg2)->long_term_frame_idx;
+
+	if (long_term_frame_idx1 < long_term_frame_idx2)
+		return -1;
+	else if (long_term_frame_idx1 > long_term_frame_idx2)
+		return 1;
+	else
+		return 0;
+}
+
+
+/*!
+ ************************************************************************
+ * \brief
+ *    compares two stored pictures by poc for qsort in ascending order
+ *
+ ************************************************************************
+ */
+static inline int compare_pic_by_poc_asc(const void *arg1, const void *arg2)
+{
+	int poc1 = (*(struct StorablePicture **)arg1)->poc;
+	int poc2 = (*(struct StorablePicture **)arg2)->poc;
+
+	if (poc1 < poc2)
+		return -1;
+	else if (poc1 > poc2)
+		return 1;
+	else
+		return 0;
+}
+
+
+/*!
+ ************************************************************************
+ * \brief
+ *    compares two stored pictures by poc for qsort in descending order
+ *
+ ************************************************************************
+ */
+static inline int compare_pic_by_poc_desc(const void *arg1, const void *arg2)
+{
+	int poc1 = (*(struct StorablePicture **)arg1)->poc;
+	int poc2 = (*(struct StorablePicture **)arg2)->poc;
+
+	if (poc1 < poc2)
+		return 1;
+	else if (poc1 > poc2)
+		return -1;
+	else
+		return 0;
+}
+
+
+/*!
+ ************************************************************************
+ * \brief
+ *    compares two frame stores by poc for qsort in ascending order
+ *
+ ************************************************************************
+ */
+static inline int compare_fs_by_poc_asc(const void *arg1, const void *arg2)
+{
+	int poc1 = (*(struct FrameStore **)arg1)->poc;
+	int poc2 = (*(struct FrameStore **)arg2)->poc;
+
+	if (poc1 < poc2)
+		return -1;
+	else if (poc1 > poc2)
+		return 1;
+	else
+		return 0;
+}
+
+
+/*!
+ ************************************************************************
+ * \brief
+ *    compares two frame stores by poc for qsort in descending order
+ *
+ ************************************************************************
+ */
+static inline int compare_fs_by_poc_desc(const void *arg1, const void *arg2)
+{
+	int poc1 = (*(struct FrameStore **)arg1)->poc;
+	int poc2 = (*(struct FrameStore **)arg2)->poc;
+
+	if (poc1 < poc2)
+		return 1;
+	else if (poc1 > poc2)
+		return -1;
+	else
+		return 0;
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    returns true, if picture is short term reference picture
+ *
+ ************************************************************************
+ */
+static inline int is_short_ref(struct StorablePicture *s)
+{
+#ifdef ERROR_CHECK
+	return (s &&
+		(s->used_for_reference) && (!(s->is_long_term)));
+#else
+	return (s->used_for_reference) && (!(s->is_long_term));
+#endif
+}
+
+
+/*!
+ ************************************************************************
+ * \brief
+ *    returns true, if picture is long term reference picture
+ *
+ ************************************************************************
+ */
+static inline int is_long_ref(struct StorablePicture *s)
+{
+#ifdef ERROR_CHECK
+	return (s &&
+		s->used_for_reference) && (s->is_long_term);
+#else
+	return (s->used_for_reference) && (s->is_long_term);
+#endif
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    Initialize reference lists for a P Slice
+ *
+ ************************************************************************
+ */
+/*!
+ ************************************************************************
+ * \brief
+ *    Generates a alternating field list from a given FrameStore list
+ *
+ ************************************************************************
+ */
+static void gen_pic_list_from_frame_list(enum PictureStructure currStructure,
+		struct FrameStore **fs_list, int list_idx,
+		struct StorablePicture **list,
+		char *list_size, int long_term)
+{
+	int top_idx = 0;
+	int bot_idx = 0;
+
+	int (*is_ref)(struct StorablePicture *s) = (long_term) ? is_long_ref :
+			is_short_ref;
+
+
+	if (currStructure == TOP_FIELD) {
+		while ((top_idx < list_idx) || (bot_idx < list_idx)) {
+			for (; top_idx < list_idx; top_idx++) {
+				if (fs_list[top_idx]->is_used & 1) {
+					if (is_ref(fs_list[top_idx]->
+						top_field)) {
+						/* short term ref pic */
+						list[(short) *list_size] =
+						fs_list[top_idx]->top_field;
+						(*list_size)++;
+						top_idx++;
+						break;
+					}
+				}
+			}
+			for (; bot_idx < list_idx; bot_idx++) {
+				if (fs_list[bot_idx]->is_used & 2) {
+					if (is_ref(fs_list[bot_idx]->
+						bottom_field)) {
+						/* short term ref pic */
+						list[(short) *list_size] =
+						fs_list[bot_idx]->bottom_field;
+						(*list_size)++;
+						bot_idx++;
+						break;
+					}
+				}
+			}
+		}
+	}
+	if (currStructure == BOTTOM_FIELD) {
+		while ((top_idx < list_idx) || (bot_idx < list_idx)) {
+			for (; bot_idx < list_idx; bot_idx++) {
+				if (fs_list[bot_idx]->is_used & 2) {
+					if (is_ref(fs_list[bot_idx]->
+						bottom_field)) {
+						/* short term ref pic */
+						list[(short) *list_size] =
+						fs_list[bot_idx]->bottom_field;
+						(*list_size)++;
+						bot_idx++;
+						break;
+					}
+				}
+			}
+			for (; top_idx < list_idx; top_idx++) {
+				if (fs_list[top_idx]->is_used & 1) {
+					if (is_ref(fs_list[top_idx]->
+						top_field)) {
+						/* short term ref pic */
+						list[(short) *list_size] =
+						fs_list[top_idx]->top_field;
+						(*list_size)++;
+						top_idx++;
+						break;
+					}
+				}
+			}
+		}
+	}
+}
+
+static void init_lists_p_slice(struct Slice *currSlice)
+{
+	struct VideoParameters *p_Vid = currSlice->p_Vid;
+	struct DecodedPictureBuffer *p_Dpb = currSlice->p_Dpb;
+	struct h264_dpb_stru *p_H264_Dpb = container_of(p_Dpb,
+				struct h264_dpb_stru, mDPB);
+
+	unsigned int i;
+
+	int list0idx = 0;
+	int listltidx = 0;
+
+	struct FrameStore **fs_list0;
+	struct FrameStore **fs_listlt;
+
+#if (MVC_EXTENSION_ENABLE)
+	currSlice->listinterviewidx0 = 0;
+	currSlice->listinterviewidx1 = 0;
+#endif
+
+	if (currSlice->structure == FRAME) {
+		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+			if (p_Dpb->fs_ref[i]->is_used == 3) {
+				if ((p_Dpb->fs_ref[i]->frame->
+					used_for_reference) &&
+				    (!p_Dpb->fs_ref[i]->frame->
+					is_long_term)) {
+					currSlice->listX[0][list0idx++] =
+					p_Dpb->fs_ref[i]->frame;
+				}
+			}
+		}
+		/* order list 0 by PicNum */
+		qsort((void *)currSlice->listX[0], list0idx,
+			sizeof(struct StorablePicture *),
+			compare_pic_by_pic_num_desc);
+		currSlice->listXsize[0] = (char) list0idx;
+		CHECK_VALID(currSlice->listXsize[0], 0);
+		if (h264_debug_flag & PRINT_FLAG_DPB_DETAIL) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				  "listX[0] (PicNum): ");
+			for (i = 0; i < list0idx; i++) {
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL, "%d  ",
+					currSlice->listX[0][i]->pic_num);
+			}
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "\n");
+		}
+		/* long term handling */
+		for (i = 0; i < p_Dpb->ltref_frames_in_buffer; i++) {
+			if (p_Dpb->fs_ltref[i]->is_used == 3) {
+				if (p_Dpb->fs_ltref[i]->frame->is_long_term) {
+					currSlice->listX[0][list0idx++] =
+						p_Dpb->fs_ltref[i]->frame;
+				}
+			}
+		}
+		qsort((void *)&currSlice->listX[0][
+			(short) currSlice->listXsize[0]],
+			list0idx - currSlice->listXsize[0],
+			sizeof(struct StorablePicture *),
+			compare_pic_by_lt_pic_num_asc);
+		currSlice->listXsize[0] = (char) list0idx;
+		CHECK_VALID(currSlice->listXsize[0], 0);
+	} else {
+#if 0
+		fs_list0 = calloc(p_Dpb->size, sizeof(struct FrameStore *));
+		if (NULL == fs_list0)
+			no_mem_exit("init_lists: fs_list0");
+		fs_listlt = calloc(p_Dpb->size, sizeof(struct FrameStore *));
+		if (NULL == fs_listlt)
+			no_mem_exit("init_lists: fs_listlt");
+#else
+		fs_list0 = &(p_Dpb->fs_list0[0]);
+		fs_listlt = &(p_Dpb->fs_listlt[0]);
+#endif
+		for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+			if (p_Dpb->fs_ref[i]->is_reference)
+				fs_list0[list0idx++] = p_Dpb->fs_ref[i];
+		}
+
+		qsort((void *)fs_list0, list0idx, sizeof(struct FrameStore *),
+		      compare_fs_by_frame_num_desc);
+
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			  "fs_list0 (FrameNum): ");
+		for (i = 0; i < list0idx; i++) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				  PRINT_FLAG_DPB_DETAIL, "%d  ",
+				  fs_list0[i]->frame_num_wrap);
+		}
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			  "\n");
+
+		currSlice->listXsize[0] = 0;
+		gen_pic_list_from_frame_list(currSlice->structure, fs_list0,
+						list0idx, currSlice->listX[0],
+						&currSlice->listXsize[0], 0);
+
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			  "listX[0] (PicNum): ");
+		for (i = 0; i < currSlice->listXsize[0]; i++) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "%d  ",
+				currSlice->listX[0][i]->pic_num);
+		}
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			  "\n");
+
+		/* long term handling */
+		for (i = 0; i < p_Dpb->ltref_frames_in_buffer; i++)
+			fs_listlt[listltidx++] = p_Dpb->fs_ltref[i];
+
+		qsort((void *)fs_listlt, listltidx, sizeof(struct FrameStore *),
+		      compare_fs_by_lt_pic_idx_asc);
+
+		gen_pic_list_from_frame_list(currSlice->structure, fs_listlt,
+					listltidx, currSlice->listX[0],
+					&currSlice->listXsize[0], 1);
+
+		/* free(fs_list0); */
+		/* free(fs_listlt); */
+	}
+	currSlice->listXsize[1] = 0;
+
+
+	/* set max size */
+	currSlice->listXsize[0] = (char) imin(currSlice->listXsize[0],
+			currSlice->num_ref_idx_active[LIST_0]);
+	currSlice->listXsize[1] = (char) imin(currSlice->listXsize[1],
+			currSlice->num_ref_idx_active[LIST_1]);
+	CHECK_VALID(currSlice->listXsize[0], 0);
+	CHECK_VALID(currSlice->listXsize[1], 1);
+
+	/* set the unused list entries to NULL */
+	for (i = currSlice->listXsize[0]; i < (MAX_LIST_SIZE); i++)
+		currSlice->listX[0][i] = p_Vid->no_reference_picture;
+	for (i = currSlice->listXsize[1]; i < (MAX_LIST_SIZE); i++)
+		currSlice->listX[1][i] = p_Vid->no_reference_picture;
+
+#if PRINTREFLIST
+#if (MVC_EXTENSION_ENABLE)
+	/* print out for h264_debug_flag purpose */
+	if ((p_Vid->profile_idc == MVC_HIGH ||
+		p_Vid->profile_idc == STEREO_HIGH) &&
+	    currSlice->current_slice_nr == 0) {
+		if (currSlice->listXsize[0] > 0) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "\n");
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				  " ** (CurViewID:%d %d) %s Ref Pic List 0 ****\n",
+				currSlice->view_id,
+				currSlice->ThisPOC,
+				currSlice->structure == FRAME ? "FRM" :
+				  (currSlice->structure == TOP_FIELD ?
+					"TOP" : "BOT"));
+			for (i = 0; i < (unsigned int)(currSlice->
+				listXsize[0]); i++) { /* ref list 0 */
+				dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"   %2d -> POC: %4d PicNum: %4d ViewID: %d\n",
+				i,
+				currSlice->listX[0][i]->poc,
+				currSlice->listX[0][i]->pic_num,
+				currSlice->listX[0][i]->view_id);
+			}
+		}
+	}
+#endif
+#endif
+}
+
+
+/*!
+ ************************************************************************
+ * \brief
+ *    Initialize reference lists
+ *
+ ************************************************************************
+ */
+static void init_mbaff_lists(struct VideoParameters *p_Vid,
+			     struct Slice *currSlice)
+{
+	unsigned j;
+	int i;
+
+	for (i = 2; i < 6; i++) {
+		for (j = 0; j < MAX_LIST_SIZE; j++)
+			currSlice->listX[i][j] = p_Vid->no_reference_picture;
+		currSlice->listXsize[i] = 0;
+	}
+
+	for (i = 0; i < currSlice->listXsize[0]; i++) {
+#ifdef ERROR_CHECK
+		if (currSlice->listX[0][i] == NULL) {
+			pr_info(
+			"error currSlice->listX[0][%d] is NULL\r\n", i);
+			break;
+		}
+#endif
+		currSlice->listX[2][2 * i] =
+			currSlice->listX[0][i]->top_field;
+		currSlice->listX[2][2 * i + 1] =
+			currSlice->listX[0][i]->bottom_field;
+		currSlice->listX[4][2 * i] =
+			currSlice->listX[0][i]->bottom_field;
+		currSlice->listX[4][2 * i + 1] =
+			currSlice->listX[0][i]->top_field;
+	}
+	currSlice->listXsize[2] = currSlice->listXsize[4] =
+		currSlice->listXsize[0] * 2;
+
+	for (i = 0; i < currSlice->listXsize[1]; i++) {
+#ifdef ERROR_CHECK
+		if (currSlice->listX[1][i] == NULL) {
+			pr_info(
+			"error currSlice->listX[1][%d] is NULL\r\n", i);
+			break;
+		}
+#endif
+		currSlice->listX[3][2 * i] =
+			currSlice->listX[1][i]->top_field;
+		currSlice->listX[3][2 * i + 1] =
+			currSlice->listX[1][i]->bottom_field;
+		currSlice->listX[5][2 * i] =
+			currSlice->listX[1][i]->bottom_field;
+		currSlice->listX[5][2 * i + 1] =
+			currSlice->listX[1][i]->top_field;
+	}
+	currSlice->listXsize[3] = currSlice->listXsize[5] =
+		currSlice->listXsize[1] * 2;
+}
+
+
+
+static void init_lists_i_slice(struct Slice *currSlice)
+{
+
+#if (MVC_EXTENSION_ENABLE)
+	currSlice->listinterviewidx0 = 0;
+	currSlice->listinterviewidx1 = 0;
+#endif
+
+	currSlice->listXsize[0] = 0;
+	currSlice->listXsize[1] = 0;
+}
+
+static void init_lists_b_slice(struct Slice *currSlice)
+{
+	struct VideoParameters *p_Vid = currSlice->p_Vid;
+	struct DecodedPictureBuffer *p_Dpb = currSlice->p_Dpb;
+	struct h264_dpb_stru *p_H264_Dpb = container_of(p_Dpb,
+		struct h264_dpb_stru, mDPB);
+
+	unsigned int i;
+	int j;
+
+	int list0idx = 0;
+	int list0idx_1 = 0;
+	int listltidx = 0;
+
+	struct FrameStore **fs_list0;
+	struct FrameStore **fs_list1;
+	struct FrameStore **fs_listlt;
+
+#if (MVC_EXTENSION_ENABLE)
+	currSlice->listinterviewidx0 = 0;
+	currSlice->listinterviewidx1 = 0;
+#endif
+
+	{
+		/* B-Slice */
+		if (currSlice->structure == FRAME) {
+			for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+				if ((p_Dpb->fs_ref[i]->is_used == 3) &&
+					((p_Dpb->fs_ref[i]->frame->
+					used_for_reference) &&
+					(!p_Dpb->fs_ref[i]->frame->
+					is_long_term)) &&
+					(currSlice->framepoc >=
+					p_Dpb->fs_ref[i]->frame->poc)) {
+					/* !KS use >= for error
+						concealment */
+					currSlice->listX[0][list0idx++] =
+						p_Dpb->fs_ref[i]->frame;
+				}
+			}
+			qsort((void *)currSlice->listX[0], list0idx,
+				sizeof(struct StorablePicture *),
+				compare_pic_by_poc_desc);
+
+			/* get the backward reference picture
+			   (POC>current POC) in list0; */
+			list0idx_1 = list0idx;
+			for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+				if ((p_Dpb->fs_ref[i]->is_used == 3) &&
+					((p_Dpb->fs_ref[i]->frame->
+					used_for_reference) &&
+					(!p_Dpb->fs_ref[i]->frame->
+					is_long_term)) &&
+					(currSlice->framepoc <
+					p_Dpb->fs_ref[i]->frame->poc)) {
+					currSlice->
+					listX[0][list0idx++] =
+						p_Dpb->fs_ref[i]->frame;
+				}
+			}
+			qsort((void *)&currSlice->listX[0][list0idx_1],
+				list0idx - list0idx_1,
+				sizeof(struct StorablePicture *),
+				compare_pic_by_poc_asc);
+
+			for (j = 0; j < list0idx_1; j++) {
+				currSlice->
+				listX[1][list0idx - list0idx_1 + j] =
+					currSlice->listX[0][j];
+			}
+			for (j = list0idx_1; j < list0idx; j++) {
+				currSlice->listX[1][j - list0idx_1] =
+					currSlice->listX[0][j];
+			}
+
+			currSlice->listXsize[0] = currSlice->listXsize[1] =
+				(char) list0idx;
+			CHECK_VALID(currSlice->listXsize[0], 0);
+			CHECK_VALID(currSlice->listXsize[1], 1);
+
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"listX[0] (PicNum): ");
+			for (i = 0; i < currSlice->listXsize[0]; i++) {
+				dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "%d  ",
+				currSlice->listX[0][i]->pic_num);
+			}
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "\n");
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"listX[1] (PicNum): ");
+			for (i = 0; i < currSlice->listXsize[1]; i++) {
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL, "%d  ",
+					currSlice->listX[1][i]->pic_num);
+			}
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "\n");
+			/* dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"currSlice->listX[0] currPoc=%d (Poc): ",
+				p_Vid->framepoc);
+			   for (i=0; i<currSlice->listXsize[0]; i++) {
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL,
+					"%d  ", currSlice->listX[0][i]->poc);
+			   }
+			   dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "\n");
+			   dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"currSlice->listX[1] currPoc=%d (Poc): ",
+				p_Vid->framepoc);
+			   for (i=0; i<currSlice->listXsize[1]; i++) {
+				dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"%d  ",
+				currSlice->listX[1][i]->poc);
+			   }
+			   dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "\n"); */
+
+			/* long term handling */
+			for (i = 0; i < p_Dpb->ltref_frames_in_buffer; i++) {
+				if (p_Dpb->fs_ltref[i]->is_used == 3) {
+					if (p_Dpb->fs_ltref[i]->frame->
+						is_long_term) {
+						currSlice->
+						listX[0][list0idx] =
+						p_Dpb->fs_ltref[i]->frame;
+						currSlice->
+						listX[1][list0idx++] =
+						p_Dpb->fs_ltref[i]->frame;
+					}
+				}
+			}
+			qsort((void *)&currSlice->
+				listX[0][(short) currSlice->listXsize[0]],
+				list0idx - currSlice->listXsize[0],
+				sizeof(struct StorablePicture *),
+				compare_pic_by_lt_pic_num_asc);
+			qsort((void *)&currSlice->
+				listX[1][(short) currSlice->listXsize[0]],
+				list0idx - currSlice->listXsize[0],
+				sizeof(struct StorablePicture *),
+				compare_pic_by_lt_pic_num_asc);
+			currSlice->listXsize[0] = currSlice->listXsize[1] =
+				(char) list0idx;
+			CHECK_VALID(currSlice->listXsize[0], 0);
+			CHECK_VALID(currSlice->listXsize[1], 1);
+		} else {
+#if 0
+			fs_list0 = calloc(p_Dpb->size,
+				sizeof(struct FrameStore *));
+			if (NULL == fs_list0)
+				no_mem_exit("init_lists: fs_list0");
+			fs_list1 = calloc(p_Dpb->size,
+				sizeof(struct FrameStore *));
+			if (NULL == fs_list1)
+				no_mem_exit("init_lists: fs_list1");
+			fs_listlt = calloc(p_Dpb->size,
+				sizeof(struct FrameStore *));
+			if (NULL == fs_listlt)
+				no_mem_exit("init_lists: fs_listlt");
+#else
+			fs_list0 = &(p_Dpb->fs_list0[0]);
+			fs_list1 = &(p_Dpb->fs_list1[0]);
+			fs_listlt = &(p_Dpb->fs_listlt[0]);
+
+#endif
+			currSlice->listXsize[0] = 0;
+			currSlice->listXsize[1] = 1;
+
+			for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+				if (p_Dpb->fs_ref[i]->is_used) {
+					if (currSlice->ThisPOC >=
+						p_Dpb->fs_ref[i]->poc) {
+						fs_list0[list0idx++] =
+							p_Dpb->fs_ref[i];
+					}
+				}
+			}
+			qsort((void *)fs_list0, list0idx,
+				sizeof(struct FrameStore *),
+				compare_fs_by_poc_desc);
+			list0idx_1 = list0idx;
+			for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+				if (p_Dpb->fs_ref[i]->is_used) {
+					if (currSlice->ThisPOC <
+						p_Dpb->fs_ref[i]->poc) {
+						fs_list0[list0idx++] =
+							p_Dpb->fs_ref[i];
+					}
+				}
+			}
+			qsort((void *)&fs_list0[list0idx_1],
+				list0idx - list0idx_1,
+				sizeof(struct FrameStore *),
+				compare_fs_by_poc_asc);
+
+			for (j = 0; j < list0idx_1; j++) {
+				fs_list1[list0idx - list0idx_1 + j] =
+				fs_list0[j];
+			}
+			for (j = list0idx_1; j < list0idx; j++)
+				fs_list1[j - list0idx_1] = fs_list0[j];
+
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"fs_list0 currPoc=%d (Poc): ",
+				currSlice->ThisPOC);
+			for (i = 0; i < list0idx; i++) {
+				dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "%d  ",
+				fs_list0[i]->poc);
+			}
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "\n");
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"fs_list1 currPoc=%d (Poc): ",
+				currSlice->ThisPOC);
+			for (i = 0; i < list0idx; i++) {
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL, "%d  ",
+					fs_list1[i]->poc);
+			}
+			dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL, "\n");
+
+			currSlice->listXsize[0] = 0;
+			currSlice->listXsize[1] = 0;
+			gen_pic_list_from_frame_list(currSlice->structure,
+						fs_list0, list0idx,
+						currSlice->listX[0],
+						&currSlice->listXsize[0], 0);
+			gen_pic_list_from_frame_list(currSlice->structure,
+						fs_list1, list0idx,
+						currSlice->listX[1],
+						&currSlice->listXsize[1], 0);
+
+			/* dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"currSlice->listX[0] currPoc=%d (Poc): ",
+				p_Vid->framepoc);
+			  for (i=0; i<currSlice->listXsize[0]; i++) {
+				dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "%d  ",
+				currSlice->listX[0][i]->poc);
+			  }
+			  dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "\n"); */
+			/* dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"currSlice->listX[1] currPoc=%d (Poc): ",
+				p_Vid->framepoc);
+			  for (i=0; i<currSlice->listXsize[1]; i++) {
+				dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "%d  ",
+				currSlice->listX[1][i]->poc);
+			  }
+			  dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"\n"); */
+
+			/* long term handling */
+			for (i = 0; i < p_Dpb->ltref_frames_in_buffer; i++)
+				fs_listlt[listltidx++] = p_Dpb->fs_ltref[i];
+
+			qsort((void *)fs_listlt, listltidx,
+				sizeof(struct FrameStore *),
+				compare_fs_by_lt_pic_idx_asc);
+
+			gen_pic_list_from_frame_list(currSlice->structure,
+				fs_listlt, listltidx,
+				currSlice->listX[0],
+				&currSlice->listXsize[0], 1);
+			gen_pic_list_from_frame_list(currSlice->structure,
+				fs_listlt, listltidx,
+				currSlice->listX[1],
+				&currSlice->listXsize[1], 1);
+
+			/* free(fs_list0); */
+			/* free(fs_list1); */
+			/* free(fs_listlt); */
+		}
+	}
+
+	if ((currSlice->listXsize[0] == currSlice->listXsize[1]) &&
+	    (currSlice->listXsize[0] > 1)) {
+		/* check if lists are identical,
+		if yes swap first two elements of currSlice->listX[1] */
+		int diff = 0;
+		for (j = 0; j < currSlice->listXsize[0]; j++) {
+			if (currSlice->listX[0][j] !=
+				currSlice->listX[1][j]) {
+				diff = 1;
+				break;
+			}
+		}
+		if (!diff) {
+			struct StorablePicture *tmp_s =
+				currSlice->listX[1][0];
+			currSlice->listX[1][0] = currSlice->listX[1][1];
+			currSlice->listX[1][1] = tmp_s;
+		}
+	}
+
+	/* set max size */
+	currSlice->listXsize[0] = (char) imin(currSlice->listXsize[0],
+		currSlice->num_ref_idx_active[LIST_0]);
+	currSlice->listXsize[1] = (char) imin(currSlice->listXsize[1],
+		currSlice->num_ref_idx_active[LIST_1]);
+	CHECK_VALID(currSlice->listXsize[0], 0);
+	CHECK_VALID(currSlice->listXsize[1], 1);
+
+	/* set the unused list entries to NULL */
+	for (i = currSlice->listXsize[0]; i < (MAX_LIST_SIZE); i++)
+		currSlice->listX[0][i] = p_Vid->no_reference_picture;
+	for (i = currSlice->listXsize[1]; i < (MAX_LIST_SIZE); i++)
+		currSlice->listX[1][i] = p_Vid->no_reference_picture;
+
+#if PRINTREFLIST
+#if (MVC_EXTENSION_ENABLE)
+	/* print out for h264_debug_flag purpose */
+	if ((p_Vid->profile_idc == MVC_HIGH ||
+	    p_Vid->profile_idc == STEREO_HIGH) &&
+	    currSlice->current_slice_nr == 0) {
+		if ((currSlice->listXsize[0] > 0) ||
+		    (currSlice->listXsize[1] > 0))
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "\n");
+		if (currSlice->listXsize[0] > 0) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				" ** (CurViewID:%d %d) %s Ref Pic List 0 ****\n",
+				currSlice->view_id,
+				currSlice->ThisPOC,
+				currSlice->structure == FRAME ? "FRM" :
+				(currSlice->structure == TOP_FIELD ?
+				"TOP" : "BOT"));
+			for (i = 0; i < (unsigned int)(currSlice->
+				listXsize[0]); i++) { /* ref list 0 */
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL,
+					"   %2d -> POC: %4d PicNum: %4d ViewID: %d\n",
+					i,
+					currSlice->listX[0][i]->poc,
+					currSlice->listX[0][i]->pic_num,
+					currSlice->listX[0][i]->view_id);
+			}
+		}
+		if (currSlice->listXsize[1] > 0) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				" ** (CurViewID:%d %d) %s Ref Pic List 1 ****\n",
+				currSlice->view_id,
+				currSlice->ThisPOC,
+				currSlice->structure == FRAME ? "FRM" :
+				(currSlice->structure == TOP_FIELD ? "TOP" :
+				"BOT"));
+			for (i = 0; i < (unsigned int)(currSlice->
+				listXsize[1]); i++) { /* ref list 1 */
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL,
+					"   %2d -> POC: %4d PicNum: %4d	ViewID: %d\n",
+					i,
+					currSlice->listX[1][i]->poc,
+					currSlice->listX[1][i]->pic_num,
+					currSlice->listX[1][i]->view_id);
+			}
+		}
+	}
+#endif
+#endif
+}
+
+static struct StorablePicture *get_short_term_pic(struct Slice *currSlice,
+		struct DecodedPictureBuffer *p_Dpb, int picNum)
+{
+	unsigned i;
+
+	for (i = 0; i < p_Dpb->ref_frames_in_buffer; i++) {
+		if (currSlice->structure == FRAME) {
+			if (p_Dpb->fs_ref[i]->is_reference == 3)
+				if ((!p_Dpb->fs_ref[i]->frame->
+					is_long_term) &&
+				    (p_Dpb->fs_ref[i]->frame->
+					pic_num == picNum))
+					return p_Dpb->fs_ref[i]->frame;
+		} else {
+			if (p_Dpb->fs_ref[i]->is_reference & 1)
+				if ((!p_Dpb->fs_ref[i]->top_field->
+					is_long_term) &&
+				    (p_Dpb->fs_ref[i]->top_field->
+					pic_num == picNum))
+					return p_Dpb->fs_ref[i]->top_field;
+			if (p_Dpb->fs_ref[i]->is_reference & 2)
+				if ((!p_Dpb->fs_ref[i]->bottom_field->
+					is_long_term) &&
+				    (p_Dpb->fs_ref[i]->bottom_field->
+					pic_num == picNum))
+					return p_Dpb->fs_ref[i]->bottom_field;
+		}
+	}
+
+	return currSlice->p_Vid->no_reference_picture;
+}
+
+
+static void reorder_short_term(struct Slice *currSlice, int cur_list,
+				int num_ref_idx_lX_active_minus1,
+				int picNumLX, int *refIdxLX)
+{
+	struct h264_dpb_stru *p_H264_Dpb = container_of(currSlice->p_Vid,
+					struct h264_dpb_stru, mVideo);
+
+	struct StorablePicture **RefPicListX = currSlice->listX[cur_list];
+	int cIdx, nIdx;
+
+	struct StorablePicture *picLX;
+
+	picLX = get_short_term_pic(currSlice, currSlice->p_Dpb, picNumLX);
+
+	for (cIdx = num_ref_idx_lX_active_minus1 + 1; cIdx > *refIdxLX;
+		cIdx--) {
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+			"%s: RefPicListX[ %d ] = RefPicListX[ %d ]\n",
+			__func__, cIdx, cIdx - 1);
+		RefPicListX[cIdx] = RefPicListX[cIdx - 1];
+	}
+
+	dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s: RefPicListX[ %d ] = pic %x (%d)\n", __func__,
+		*refIdxLX, picLX, picNumLX);
+
+	RefPicListX[(*refIdxLX)++] = picLX;
+
+	nIdx = *refIdxLX;
+
+	for (cIdx = *refIdxLX; cIdx <= num_ref_idx_lX_active_minus1 + 1;
+		cIdx++) {
+		if (RefPicListX[cIdx])
+			if ((RefPicListX[cIdx]->is_long_term) ||
+			    (RefPicListX[cIdx]->pic_num != picNumLX)) {
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL,
+					"%s: RefPicListX[ %d ] = RefPicListX[ %d ]\n",
+					__func__, nIdx, cIdx);
+				RefPicListX[nIdx++] = RefPicListX[cIdx];
+			}
+	}
+}
+
+
+static struct StorablePicture *get_long_term_pic(struct Slice *currSlice,
+		struct DecodedPictureBuffer *p_Dpb, int LongtermPicNum)
+{
+	unsigned int i;
+
+	for (i = 0; i < p_Dpb->ltref_frames_in_buffer; i++) {
+		if (currSlice->structure == FRAME) {
+			if (p_Dpb->fs_ltref[i]->is_reference == 3)
+				if ((p_Dpb->fs_ltref[i]->frame->
+					is_long_term) &&
+				    (p_Dpb->fs_ltref[i]->frame->
+					long_term_pic_num ==
+					LongtermPicNum))
+					return p_Dpb->fs_ltref[i]->frame;
+		} else {
+			if (p_Dpb->fs_ltref[i]->is_reference & 1)
+				if ((p_Dpb->fs_ltref[i]->top_field->
+					is_long_term) &&
+				    (p_Dpb->fs_ltref[i]->top_field->
+					long_term_pic_num == LongtermPicNum))
+					return p_Dpb->fs_ltref[i]->top_field;
+			if (p_Dpb->fs_ltref[i]->is_reference & 2)
+				if ((p_Dpb->fs_ltref[i]->bottom_field->
+					is_long_term) &&
+				    (p_Dpb->fs_ltref[i]->bottom_field->
+					long_term_pic_num ==
+					LongtermPicNum))
+					return p_Dpb->fs_ltref[i]->
+						bottom_field;
+		}
+	}
+	return NULL;
+}
+
+/*!
+ ************************************************************************
+ * \brief
+ *    Reordering process for long-term reference pictures
+ *
+ ************************************************************************
+ */
+static void reorder_long_term(struct Slice *currSlice,
+				struct StorablePicture **RefPicListX,
+				int num_ref_idx_lX_active_minus1,
+			      int LongTermPicNum, int *refIdxLX)
+{
+	int cIdx, nIdx;
+
+	struct StorablePicture *picLX;
+
+	picLX = get_long_term_pic(currSlice, currSlice->p_Dpb, LongTermPicNum);
+
+	for (cIdx = num_ref_idx_lX_active_minus1 + 1; cIdx > *refIdxLX; cIdx--)
+		RefPicListX[cIdx] = RefPicListX[cIdx - 1];
+
+	RefPicListX[(*refIdxLX)++] = picLX;
+
+	nIdx = *refIdxLX;
+
+	for (cIdx = *refIdxLX; cIdx <= num_ref_idx_lX_active_minus1 + 1;
+		cIdx++) {
+		if (RefPicListX[cIdx]) {
+			if ((!RefPicListX[cIdx]->is_long_term) ||
+			    (RefPicListX[cIdx]->long_term_pic_num !=
+				LongTermPicNum))
+				RefPicListX[nIdx++] = RefPicListX[cIdx];
+		}
+	}
+}
+
+static void reorder_ref_pic_list(struct Slice *currSlice, int cur_list)
+{
+	int *modification_of_pic_nums_idc =
+		currSlice->modification_of_pic_nums_idc[cur_list];
+	int *abs_diff_pic_num_minus1 =
+		currSlice->abs_diff_pic_num_minus1[cur_list];
+	int *long_term_pic_idx = currSlice->long_term_pic_idx[cur_list];
+	int num_ref_idx_lX_active_minus1 =
+		currSlice->num_ref_idx_active[cur_list] - 1;
+
+	struct VideoParameters *p_Vid = currSlice->p_Vid;
+	int i;
+
+	int maxPicNum, currPicNum, picNumLXNoWrap, picNumLXPred, picNumLX;
+	int refIdxLX = 0;
+
+	if (currSlice->structure == FRAME) {
+		maxPicNum  = p_Vid->max_frame_num;
+		currPicNum = currSlice->frame_num;
+	} else {
+		maxPicNum  = 2 * p_Vid->max_frame_num;
+		currPicNum = 2 * currSlice->frame_num + 1;
+	}
+
+	picNumLXPred = currPicNum;
+
+	for (i = 0;  i < REORDERING_COMMAND_MAX_SIZE &&
+		modification_of_pic_nums_idc[i] != 3; i++) {
+		if (modification_of_pic_nums_idc[i] > 3) {
+			struct h264_dpb_stru *p_H264_Dpb =
+			container_of(p_Vid, struct h264_dpb_stru, mVideo);
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_ERROR,
+				"error, Invalid modification_of_pic_nums_idc command\n");
+			/*h264_debug_flag = 0x1f;*/
+			break;
+		}
+		if (modification_of_pic_nums_idc[i] < 2) {
+			if (modification_of_pic_nums_idc[i] == 0) {
+				if (picNumLXPred - (abs_diff_pic_num_minus1[i]
+					+ 1) < 0)
+					picNumLXNoWrap = picNumLXPred -
+					(abs_diff_pic_num_minus1[i] + 1) +
+					maxPicNum;
+				else
+					picNumLXNoWrap = picNumLXPred -
+					(abs_diff_pic_num_minus1[i] + 1);
+			} else { /* (modification_of_pic_nums_idc[i] == 1) */
+				if (picNumLXPred + (abs_diff_pic_num_minus1[i]
+					+ 1)  >=  maxPicNum)
+					picNumLXNoWrap = picNumLXPred +
+					(abs_diff_pic_num_minus1[i] + 1) -
+					maxPicNum;
+				else
+					picNumLXNoWrap = picNumLXPred +
+					(abs_diff_pic_num_minus1[i] + 1);
+			}
+			picNumLXPred = picNumLXNoWrap;
+
+			if (picNumLXNoWrap > currPicNum)
+				picNumLX = picNumLXNoWrap - maxPicNum;
+			else
+				picNumLX = picNumLXNoWrap;
+
+#if (MVC_EXTENSION_ENABLE)
+			reorder_short_term(currSlice, cur_list,
+					num_ref_idx_lX_active_minus1, picNumLX,
+					&refIdxLX, -1);
+#else
+			reorder_short_term(currSlice, cur_list,
+					num_ref_idx_lX_active_minus1, picNumLX,
+					&refIdxLX);
+#endif
+		} else { /* (modification_of_pic_nums_idc[i] == 2) */
+#if (MVC_EXTENSION_ENABLE)
+			reorder_long_term(currSlice, currSlice->listX[cur_list],
+					num_ref_idx_lX_active_minus1,
+					long_term_pic_idx[i], &refIdxLX, -1);
+#else
+			reorder_long_term(currSlice, currSlice->listX[cur_list],
+					num_ref_idx_lX_active_minus1,
+					long_term_pic_idx[i], &refIdxLX);
+#endif
+		}
+
+	}
+	/* that's a definition */
+	currSlice->listXsize[cur_list] =
+		(char)(num_ref_idx_lX_active_minus1 + 1);
+}
+
+
+static void reorder_lists(struct Slice *currSlice)
+{
+	struct VideoParameters *p_Vid = currSlice->p_Vid;
+	struct h264_dpb_stru *p_H264_Dpb = container_of(p_Vid,
+		struct h264_dpb_stru, mVideo);
+	int i;
+	if ((currSlice->slice_type != I_SLICE) &&
+		(currSlice->slice_type != SI_SLICE)) {
+		if (currSlice->ref_pic_list_reordering_flag[LIST_0])
+			reorder_ref_pic_list(currSlice, LIST_0);
+		if (p_Vid->no_reference_picture ==
+		    currSlice->
+			listX[0][currSlice->num_ref_idx_active[LIST_0] - 1]) {
+			if (p_Vid->non_conforming_stream)
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL,
+					"RefPicList0[ %d ] is equal to 'no reference picture'\n",
+					currSlice->
+					num_ref_idx_active[LIST_0] - 1);
+			else
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL,
+					"RefPicList0 [ num_ref_idx_l0_active_minus1 ] is equal to 'no reference picture', invalid bitstream %d\n",
+					500);
+		}
+		/* that's a definition */
+		currSlice->listXsize[0] =
+			(char)currSlice->num_ref_idx_active[LIST_0];
+		CHECK_VALID(currSlice->listXsize[0], 0);
+		if (h264_debug_flag & PRINT_FLAG_DPB_DETAIL) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+				"listX[0] reorder (PicNum): ");
+			for (i = 0; i < currSlice->listXsize[0]; i++) {
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL, "%d  ",
+					currSlice->listX[0][i]->pic_num);
+			}
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "\n");
+		}
+	}
+
+	if (currSlice->slice_type == B_SLICE) {
+		if (currSlice->ref_pic_list_reordering_flag[LIST_1])
+			reorder_ref_pic_list(currSlice, LIST_1);
+		if (p_Vid->no_reference_picture ==
+		    currSlice->listX[1][currSlice->
+			num_ref_idx_active[LIST_1] - 1]) {
+			if (p_Vid->non_conforming_stream)
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL,
+					"RefPicList1[ %d ] is equal to 'no reference picture'\n",
+					currSlice->
+					num_ref_idx_active[LIST_1] - 1);
+			else
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL,
+					"RefPicList1 [ num_ref_idx_l1_active_minus1 ] is equal to 'no reference picture', invalid bitstream %d\n",
+					500);
+		}
+		/* that's a definition */
+		currSlice->listXsize[1] =
+			(char)currSlice->num_ref_idx_active[LIST_1];
+		if (h264_debug_flag & PRINT_FLAG_DPB_DETAIL) {
+			dpb_print(p_H264_Dpb->decoder_index,
+			PRINT_FLAG_DPB_DETAIL,
+				  "listX[1] reorder (PicNum): ");
+			for (i = 0; i < currSlice->listXsize[1]; i++) {
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL, "%d  ",
+					currSlice->listX[1][i]->pic_num);
+			}
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL, "\n");
+		}
+	}
+
+	/* free_ref_pic_list_reordering_buffer(currSlice); */
+
+	if (currSlice->slice_type == P_SLICE) {
+#if PRINTREFLIST
+		unsigned int i;
+#if (MVC_EXTENSION_ENABLE)
+		/* print out for h264_debug_flag purpose */
+		if ((p_Vid->profile_idc == MVC_HIGH ||
+			p_Vid->profile_idc == STEREO_HIGH) &&
+			currSlice->current_slice_nr == 0) {
+			if (currSlice->listXsize[0] > 0
+				&& (h264_debug_flag & PRINT_FLAG_DPB_DETAIL)) {
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL, "\n");
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL,
+					  " ** (FinalViewID:%d) %s Ref Pic List 0 ****\n",
+					currSlice->view_id,
+					currSlice->structure == FRAME ?
+					"FRM" :
+					(currSlice->structure == TOP_FIELD ?
+					"TOP" : "BOT"));
+				for (i = 0; i < (unsigned int)(currSlice->
+					listXsize[0]); i++) { /* ref list 0 */
+					dpb_print(p_H264_Dpb->decoder_index,
+						PRINT_FLAG_DPB_DETAIL,
+						"   %2d -> POC: %4d PicNum: %4d ViewID: %d\n",
+						i,
+						currSlice->listX[0][i]->poc,
+						currSlice->listX[0][i]->
+							pic_num,
+						currSlice->listX[0][i]->
+							view_id);
+				}
+			}
+		}
+#endif
+#endif
+	} else if (currSlice->slice_type == B_SLICE) {
+#if PRINTREFLIST
+		unsigned int i;
+#if (MVC_EXTENSION_ENABLE)
+		/* print out for h264_debug_flag purpose */
+		if ((p_Vid->profile_idc == MVC_HIGH ||
+			p_Vid->profile_idc == STEREO_HIGH) &&
+		    currSlice->current_slice_nr == 0) {
+			if ((currSlice->listXsize[0] > 0) ||
+				(currSlice->listXsize[1] > 0))
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL, "\n");
+			if (currSlice->listXsize[0] > 0
+				&& (h264_debug_flag & PRINT_FLAG_DPB_DETAIL)) {
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL,
+					" ** (FinalViewID:%d) %s Ref Pic List 0 ****\n",
+					currSlice->view_id,
+					currSlice->structure == FRAME ?
+					"FRM" :
+					(currSlice->structure == TOP_FIELD ?
+					"TOP" : "BOT"));
+				for (i = 0; i < (unsigned int)(currSlice->
+					listXsize[0]); i++) { /* ref list 0 */
+					dpb_print(p_H264_Dpb->decoder_index,
+						PRINT_FLAG_DPB_DETAIL,
+						"   %2d -> POC: %4d PicNum: %4d ViewID: %d\n",
+						i,
+						currSlice->listX[0][i]->poc,
+						currSlice->listX[0][i]->
+							pic_num,
+						currSlice->listX[0][i]->
+							view_id);
+				}
+			}
+			if (currSlice->listXsize[1] > 0
+				 && (h264_debug_flag & PRINT_FLAG_DPB_DETAIL)) {
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_DPB_DETAIL,
+					" ** (FinalViewID:%d) %s Ref Pic List 1 ****\n",
+					currSlice->view_id,
+					currSlice->structure == FRAME ?
+					"FRM" :
+					(currSlice->structure == TOP_FIELD ?
+					"TOP" : "BOT"));
+				for (i = 0; i < (unsigned int)(currSlice->
+					listXsize[1]); i++) { /* ref list 1 */
+					dpb_print(p_H264_Dpb->decoder_index,
+						PRINT_FLAG_DPB_DETAIL,
+						"   %2d -> POC: %4d PicNum: %4d ViewID: %d\n",
+						i,
+						currSlice->listX[1][i]->poc,
+						currSlice->listX[1][i]->
+							pic_num,
+						currSlice->listX[1][i]->
+							view_id);
+				}
+			}
+		}
+#endif
+
+#endif
+	}
+}
+
+void init_colocate_buf(struct h264_dpb_stru *p_H264_Dpb, int count)
+{
+	p_H264_Dpb->colocated_buf_map = 0;
+	p_H264_Dpb->colocated_buf_count = count;
+}
+
+int allocate_colocate_buf(struct h264_dpb_stru *p_H264_Dpb)
+{
+	int i;
+	for (i = 0; i < p_H264_Dpb->colocated_buf_count; i++) {
+		if (((p_H264_Dpb->colocated_buf_map >> i) & 0x1) == 0) {
+			p_H264_Dpb->colocated_buf_map |= (1 << i);
+			break;
+		}
+	}
+	if (i == p_H264_Dpb->colocated_buf_count)
+		i = -1;
+	return i;
+}
+
+int release_colocate_buf(struct h264_dpb_stru *p_H264_Dpb, int index)
+{
+	if (index >= 0) {
+		if (index >= p_H264_Dpb->colocated_buf_count) {
+			dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_ERROR,
+				"%s error, index %d is bigger than buf count %d\n",
+				__func__, index,
+				p_H264_Dpb->colocated_buf_count);
+		} else {
+			if (((p_H264_Dpb->colocated_buf_map >>
+				index) & 0x1) == 0x1) {
+				p_H264_Dpb->colocated_buf_map &=
+					(~(1 << index));
+			} else {
+				dpb_print(p_H264_Dpb->decoder_index,
+					PRINT_FLAG_ERROR,
+					"%s error, index %d is not allocated\n",
+					__func__, index);
+			}
+		}
+	}
+	return 0;
+}
+
+void set_frame_output_flag(struct h264_dpb_stru *p_H264_Dpb, int index)
+{
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+	p_H264_Dpb->mFrameStore[index].is_output = 1;
+	p_H264_Dpb->mFrameStore[index].pre_output = 0;
+	dump_dpb(p_Dpb);
+}
+
+#if 0
+void init_old_slice(OldSliceParams *p_old_slice)
+{
+	p_old_slice->field_pic_flag = 0;
+	p_old_slice->pps_id         = INT_MAX;
+	p_old_slice->frame_num      = INT_MAX;
+	p_old_slice->nal_ref_idc    = INT_MAX;
+	p_old_slice->idr_flag       = FALSE;
+
+	p_old_slice->pic_oder_cnt_lsb          = UINT_MAX;
+	p_old_slice->delta_pic_oder_cnt_bottom = INT_MAX;
+
+	p_old_slice->delta_pic_order_cnt[0] = INT_MAX;
+	p_old_slice->delta_pic_order_cnt[1] = INT_MAX;
+}
+
+
+void copy_slice_info(struct Slice *currSlice, OldSliceParams *p_old_slice)
+{
+	struct VideoParameters *p_Vid = currSlice->p_Vid;
+
+	p_old_slice->pps_id         = currSlice->pic_parameter_set_id;
+	p_old_slice->frame_num      = currSlice->frame_num;
+	/* p_Vid->frame_num; */
+	p_old_slice->field_pic_flag =
+		currSlice->field_pic_flag;
+	/* p_Vid->field_pic_flag; */
+
+	if (currSlice->field_pic_flag)
+		p_old_slice->bottom_field_flag = currSlice->bottom_field_flag;
+
+	p_old_slice->nal_ref_idc = currSlice->nal_reference_idc;
+	p_old_slice->idr_flag    = (byte) currSlice->idr_flag;
+
+	if (currSlice->idr_flag)
+		p_old_slice->idr_pic_id = currSlice->idr_pic_id;
+
+	if (p_Vid->active_sps->pic_order_cnt_type == 0) {
+		p_old_slice->pic_oder_cnt_lsb =
+			currSlice->pic_order_cnt_lsb;
+		p_old_slice->delta_pic_oder_cnt_bottom =
+			currSlice->delta_pic_order_cnt_bottom;
+	}
+
+	if (p_Vid->active_sps->pic_order_cnt_type == 1) {
+		p_old_slice->delta_pic_order_cnt[0] =
+			currSlice->delta_pic_order_cnt[0];
+		p_old_slice->delta_pic_order_cnt[1] =
+			currSlice->delta_pic_order_cnt[1];
+	}
+#if (MVC_EXTENSION_ENABLE)
+	p_old_slice->view_id = currSlice->view_id;
+	p_old_slice->inter_view_flag = currSlice->inter_view_flag;
+	p_old_slice->anchor_pic_flag = currSlice->anchor_pic_flag;
+#endif
+	p_old_slice->layer_id = currSlice->layer_id;
+}
+
+int is_new_picture(StorablePicture *dec_picture, struct Slice *currSlice,
+		   OldSliceParams *p_old_slice)
+{
+	struct VideoParameters *p_Vid = currSlice->p_Vid;
+
+	int result = 0;
+
+	result |= (NULL == dec_picture);
+
+	result |= (p_old_slice->pps_id != currSlice->pic_parameter_set_id);
+
+	result |= (p_old_slice->frame_num != currSlice->frame_num);
+
+	result |= (p_old_slice->field_pic_flag != currSlice->field_pic_flag);
+
+	if (currSlice->field_pic_flag && p_old_slice->field_pic_flag) {
+		result |= (p_old_slice->bottom_field_flag !=
+				currSlice->bottom_field_flag);
+	}
+
+	result |= (p_old_slice->nal_ref_idc !=
+			currSlice->nal_reference_idc) &&
+		  ((p_old_slice->nal_ref_idc == 0) ||
+			(currSlice->nal_reference_idc == 0));
+	result |= (p_old_slice->idr_flag    != currSlice->idr_flag);
+
+	if (currSlice->idr_flag && p_old_slice->idr_flag)
+		result |= (p_old_slice->idr_pic_id != currSlice->idr_pic_id);
+
+	if (p_Vid->active_sps->pic_order_cnt_type == 0) {
+		result |= (p_old_slice->pic_oder_cnt_lsb !=
+			   currSlice->pic_order_cnt_lsb);
+		if (p_Vid->active_pps->
+			bottom_field_pic_order_in_frame_present_flag  ==  1 &&
+		    !currSlice->field_pic_flag) {
+			result |= (p_old_slice->delta_pic_oder_cnt_bottom !=
+				   currSlice->delta_pic_order_cnt_bottom);
+		}
+	}
+
+	if (p_Vid->active_sps->pic_order_cnt_type == 1) {
+		if (!p_Vid->active_sps->delta_pic_order_always_zero_flag) {
+			result |= (p_old_slice->delta_pic_order_cnt[0] !=
+				   currSlice->delta_pic_order_cnt[0]);
+			if (p_Vid->active_pps->
+			bottom_field_pic_order_in_frame_present_flag  ==  1 &&
+			    !currSlice->field_pic_flag) {
+				result |= (p_old_slice->
+					delta_pic_order_cnt[1] !=
+					currSlice->delta_pic_order_cnt[1]);
+			}
+		}
+	}
+
+#if (MVC_EXTENSION_ENABLE)
+	result |= (currSlice->view_id != p_old_slice->view_id);
+	result |= (currSlice->inter_view_flag != p_old_slice->inter_view_flag);
+	result |= (currSlice->anchor_pic_flag != p_old_slice->anchor_pic_flag);
+#endif
+	result |= (currSlice->layer_id != p_old_slice->layer_id);
+	return result;
+}
+#else
+int is_new_picture(struct StorablePicture *dec_picture,
+		   struct h264_dpb_stru *p_H264_Dpb,
+		   struct OldSliceParams *p_old_slice)
+{
+	int ret = 0;
+	if (p_H264_Dpb->dpb_param.l.data[FIRST_MB_IN_SLICE] == 0)
+		ret = 1;
+	return ret;
+}
+
+#endif
+
+int remove_picture(struct h264_dpb_stru *p_H264_Dpb,
+		   struct StorablePicture *pic)
+{
+	struct DecodedPictureBuffer *p_Dpb = &p_H264_Dpb->mDPB;
+	if (p_Dpb->last_picture == NULL) {
+		if (pic->colocated_buf_index >= 0) {
+			release_colocate_buf(p_H264_Dpb,
+			pic->colocated_buf_index);
+			pic->colocated_buf_index = -1;
+		}
+		release_buf_spec_num(p_H264_Dpb->vdec, pic->buf_spec_num);
+	}
+	free_picture(p_H264_Dpb, pic);
+	return 0;
+}
+
+static void check_frame_store_same_pic_num(struct DecodedPictureBuffer *p_Dpb,
+	struct StorablePicture *p, struct Slice *currSlice)
+{
+	if (p_Dpb->last_picture) {
+		if ((int)p_Dpb->last_picture->frame_num == p->pic_num) {
+			if (((p->structure == TOP_FIELD) &&
+				(p_Dpb->last_picture->is_used == 2)) ||
+			    ((p->structure == BOTTOM_FIELD) &&
+				(p_Dpb->last_picture->is_used == 1))) {
+				if ((p->used_for_reference &&
+					(p_Dpb->last_picture->
+					is_orig_reference != 0)) ||
+				    (!p->used_for_reference &&
+					(p_Dpb->last_picture->
+					is_orig_reference == 0))) {
+					p->buf_spec_num =
+						p_Dpb->last_picture->
+						buf_spec_num;
+					p->colocated_buf_index = p_Dpb->
+						last_picture->
+						colocated_buf_index;
+					if (currSlice->structure ==
+						TOP_FIELD) {
+						p->bottom_poc =
+							p_Dpb->last_picture->
+							bottom_field->poc;
+					} else {
+						p->top_poc =
+							p_Dpb->last_picture->
+							top_field->poc;
+					}
+					p->frame_poc = imin(p->bottom_poc,
+						p->top_poc);
+				}
+			}
+		}
+	}
+}
+
+int h264_slice_header_process(struct h264_dpb_stru *p_H264_Dpb)
+{
+
+	int new_pic_flag = 0;
+	struct Slice *currSlice = &p_H264_Dpb->mSlice;
+	struct VideoParameters *p_Vid = &p_H264_Dpb->mVideo;
+#if 0
+	new_pic_flag = is_new_picture(p_H264_Dpb->mVideo.dec_picture,
+				      p_H264_Dpb,
+				      &p_H264_Dpb->mVideo.old_slice);
+
+	if (new_pic_flag) { /* new picture */
+		if (p_H264_Dpb->mVideo.dec_picture) {
+			store_picture_in_dpb(p_H264_Dpb,
+				p_H264_Dpb->mVideo.dec_picture);
+			/* dump_dpb(&p_H264_Dpb->mDPB); */
+		}
+	}
+#else
+	new_pic_flag = (p_H264_Dpb->mVideo.dec_picture == NULL);
+#endif
+
+	slice_prepare(p_H264_Dpb, &p_H264_Dpb->mDPB, &p_H264_Dpb->mVideo,
+		      &p_H264_Dpb->mSPS, &p_H264_Dpb->mSlice);
+
+	/* if (p_Vid->active_sps != sps) { */
+	if (p_H264_Dpb->mDPB.init_done == 0) {
+		/*init_global_buffers(p_Vid, 0);
+
+		if (!p_Vid->no_output_of_prior_pics_flag)
+		{
+		    flush_dpb(p_Vid->p_Dpb_layer[0]);
+		}
+		init_dpb(p_Vid, p_Vid->p_Dpb_layer[0], 0);
+		*/
+		init_dpb(p_H264_Dpb, 0);
+	}
+
+
+	if (new_pic_flag) { /* new picture */
+		dpb_print(p_H264_Dpb->decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"check frame_num gap: cur frame_num %d pre_frame_num %d max_frmae_num %d\r\n",
+		currSlice->frame_num,
+		p_Vid->pre_frame_num,
+		p_Vid->max_frame_num);
+		if (p_Vid->recovery_point == 0 &&
+			currSlice->frame_num != p_Vid->pre_frame_num &&
+			currSlice->frame_num !=
+			(p_Vid->pre_frame_num + 1) % p_Vid->max_frame_num) {
+			/*if (active_sps->
+			gaps_in_frame_num_value_allowed_flag
+			== 0) {
+			  error("An unintentional
+			  loss of pictures occurs! Exit\n",
+			  100);
+			}
+			if (p_Vid->conceal_mode == 0)*/
+			fill_frame_num_gap(p_Vid, currSlice);
+		}
+
+		if (currSlice->nal_reference_idc) {
+			dpb_print(p_H264_Dpb->decoder_index,
+				PRINT_FLAG_DPB_DETAIL,
+			"nal_reference_idc not 0, set pre_frame_num(%d) to frame_num (%d)\n",
+			p_Vid->pre_frame_num, currSlice->frame_num);
+			p_Vid->pre_frame_num = currSlice->frame_num;
+		}
+
+		decode_poc(&p_H264_Dpb->mVideo, &p_H264_Dpb->mSlice);
+		p_H264_Dpb->mVideo.dec_picture = get_new_pic(p_H264_Dpb,
+						 p_H264_Dpb->mSlice.structure,
+						/*p_Vid->width, p_Vid->height,
+						  p_Vid->width_cr,
+						  p_Vid->height_cr,*/
+						 1);
+		if (p_H264_Dpb->mVideo.dec_picture) {
+			struct DecodedPictureBuffer *p_Dpb =
+				&p_H264_Dpb->mDPB;
+			struct StorablePicture *p =
+				p_H264_Dpb->mVideo.dec_picture;
+			init_picture(p_H264_Dpb, &p_H264_Dpb->mSlice,
+				p_H264_Dpb->mVideo.dec_picture);
+#if 1
+			/* rain */
+			p_H264_Dpb->mVideo.dec_picture->offset_delimiter_lo  =
+			p_H264_Dpb->dpb_param.l.data[OFFSET_DELIMITER_LO];
+			p_H264_Dpb->mVideo.dec_picture->offset_delimiter_hi  =
+			p_H264_Dpb->dpb_param.l.data[OFFSET_DELIMITER_HI];
+
+			p_H264_Dpb->mVideo.dec_picture->buf_spec_num  = -1;
+			p_H264_Dpb->mVideo.dec_picture->
+				colocated_buf_index = -1;
+			update_pic_num(&p_H264_Dpb->mSlice);
+
+			if ((currSlice->structure == TOP_FIELD) ||
+			    (currSlice->structure == BOTTOM_FIELD)) {
+				/* check for frame store with same
+				   pic_number */
+				check_frame_store_same_pic_num(p_Dpb, p,
+					currSlice);
+			}
+
+			if (p_H264_Dpb->mVideo.dec_picture->buf_spec_num ==
+				-1) {
+				p_H264_Dpb->mVideo.dec_picture->buf_spec_num =
+					get_free_buf_idx(p_H264_Dpb->vdec);
+				if (p_H264_Dpb->mVideo.dec_picture->
+					used_for_reference) {
+					p_H264_Dpb->mVideo.dec_picture->
+						colocated_buf_index =
+						allocate_colocate_buf(
+							p_H264_Dpb);
+				}
+			}
+#endif
+		}
+	}
+
+	if (p_H264_Dpb->mSlice.slice_type == P_SLICE)
+		init_lists_p_slice(&p_H264_Dpb->mSlice);
+	else if (p_H264_Dpb->mSlice.slice_type == B_SLICE)
+		init_lists_b_slice(&p_H264_Dpb->mSlice);
+	else
+		init_lists_i_slice(&p_H264_Dpb->mSlice);
+
+	reorder_lists(&p_H264_Dpb->mSlice);
+
+	if (p_H264_Dpb->mSlice.structure == FRAME)
+		init_mbaff_lists(&p_H264_Dpb->mVideo, &p_H264_Dpb->mSlice);
+
+	if (new_pic_flag)
+		return 1;
+
+	return 0;
+}
diff --git a/drivers/amlogic/amports/h264_dpb.h b/drivers/amlogic/amports/h264_dpb.h
new file mode 100644
index 0000000..e58f084
--- /dev/null
+++ b/drivers/amlogic/amports/h264_dpb.h
@@ -0,0 +1,788 @@
+#ifndef H264_DPB_H_
+#define H264_DPB_H_
+
+#define ERROR_CHECK
+
+#define OUTPUT_BUFFER_IN_C
+
+#define PRINT_FLAG_ERROR              0x0
+#define PRINT_FLAG_DPB                0X0001
+#define PRINT_FLAG_DPB_DETAIL         0x0002
+#define PRINT_FLAG_DUMP_DPB           0x0004
+#define PRINT_FLAG_UCODE_EVT          0x0008
+#define PRINT_FLAG_VDEC_STATUS        0x0010
+#define PRINT_FLAG_VDEC_DETAIL        0x0020
+#define PRINT_FLAG_UCODE_DBG          0x0040
+#define PRINT_FLAG_TIME_STAMP         0x0080
+#define PRINT_FLAG_RUN_SCHEDULE       0x0100
+#define PRINT_FLAG_DEBUG_POC          0x0200
+#define PRINT_FLAG_VDEC_DATA          0x0400
+#define DISABLE_ERROR_HANDLE          0x10000
+#define OUTPUT_CURRENT_BUF            0x20000
+#define ONLY_RESET_AT_START           0x40000
+#define LOAD_UCODE_ALWAYS             0x80000
+#define FORCE_NO_SLICE                0x100000
+#define REINIT_DPB_TEST               0x200000
+
+
+#define MVC_EXTENSION_ENABLE 0
+#define PRINTREFLIST  0
+
+#define MAX_LIST_SIZE 33
+
+#define FALSE 0
+
+#define H264_SLICE_HEAD_DONE         0x01
+#define H264_PIC_DATA_DONE          0x02
+/*#define H264_SPS_DONE               0x03*/
+/*#define H264_PPS_DONE               0x04*/
+/*#define H264_SLICE_DATA_DONE        0x05*/
+/*#define H264_DATA_END               0x06*/
+
+#define H264_CONFIG_REQUEST         0x11
+#define H264_DATA_REQUEST           0x12
+
+#define H264_DECODE_BUFEMPTY        0x20
+#define H264_DECODE_TIMEOUT         0x21
+#define H264_SEARCH_BUFEMPTY        0x22
+    /* 0x8x, search state*/
+#define H264_STATE_SEARCH_AFTER_SPS  0x80
+#define H264_STATE_SEARCH_AFTER_PPS  0x81
+#define H264_STATE_PARSE_SLICE_HEAD  0x82
+#define H264_STATE_SEARCH_HEAD       0x83
+  /**/
+#define H264_ACTION_SEARCH_HEAD     0xf0
+#define H264_ACTION_DECODE_SLICE    0xf1
+#define H264_ACTION_CONFIG_DONE     0xf2
+#define H264_ACTION_DECODE_NEWPIC   0xf3
+#define H264_ACTION_DECODE_START    0xff
+
+#define RPM_BEGIN			0x0
+#define RPM_END				0x400
+
+#define val(s) (s[0]|(s[1]<<16))
+
+#define FRAME_IN_DPB	24
+#define DPB_OFFSET		0x100
+#define MMCO_OFFSET		0x200
+union param {
+#define H_TIME_STAMP_START	0X00
+#define H_TIME_STAMP_END	0X17
+#define PTS_ZERO_0		0X18
+#define PTS_ZERO_1		0X19
+#define FIXED_FRAME_RATE_FLAG                   0X1A
+
+#define OFFSET_DELIMITER_LO                     0x2f
+#define OFFSET_DELIMITER_HI                     0x30
+
+
+#define SLICE_IPONLY_BREAK						0X5C
+#define PREV_MAX_REFERENCE_FRAME_NUM					0X5D
+#define EOS								0X5E
+#define FRAME_PACKING_TYPE						0X5F
+#define OLD_POC_PAR_1							0X60
+#define OLD_POC_PAR_2							0X61
+#define PREV_MBX							0X62
+#define PREV_MBY							0X63
+#define ERROR_SKIP_MB_NUM						0X64
+#define ERROR_MB_STATUS							0X65
+#define L0_PIC0_STATUS							0X66
+#define TIMEOUT_COUNTER							0X67
+#define BUFFER_SIZE							0X68
+#define BUFFER_SIZE_HI							0X69
+#define CROPPING_LEFT_RIGHT						0X6A
+#define CROPPING_TOP_BOTTOM						0X6B
+#define POC_SELECT_NEED_SWAP						0X6C
+#define POC_SELECT_SWAP							0X6D
+#define MAX_BUFFER_FRAME						0X6E
+
+#define NON_CONFORMING_STREAM						0X70
+#define RECOVERY_POINT							0X71
+#define POST_CANVAS							0X72
+#define POST_CANVAS_H							0X73
+#define SKIP_PIC_COUNT							0X74
+#define TARGET_NUM_SCALING_LIST						0X75
+#define FF_POST_ONE_FRAME						0X76
+#define PREVIOUS_BIT_CNT						0X77
+#define MB_NOT_SHIFT_COUNT						0X78
+#define PIC_STATUS							0X79
+#define FRAME_COUNTER							0X7A
+#define NEW_SLICE_TYPE							0X7B
+#define NEW_PICTURE_STRUCTURE						0X7C
+#define NEW_FRAME_NUM							0X7D
+#define NEW_IDR_PIC_ID							0X7E
+#define IDR_PIC_ID							0X7F
+
+/* h264 LOCAL */
+#define NAL_UNIT_TYPE							0X80
+#define NAL_REF_IDC							0X81
+#define SLICE_TYPE							0X82
+#define LOG2_MAX_FRAME_NUM						0X83
+#define FRAME_MBS_ONLY_FLAG						0X84
+#define PIC_ORDER_CNT_TYPE						0X85
+#define LOG2_MAX_PIC_ORDER_CNT_LSB					0X86
+#define PIC_ORDER_PRESENT_FLAG						0X87
+#define REDUNDANT_PIC_CNT_PRESENT_FLAG					0X88
+#define PIC_INIT_QP_MINUS26						0X89
+#define DEBLOCKING_FILTER_CONTROL_PRESENT_FLAG				0X8A
+#define NUM_SLICE_GROUPS_MINUS1						0X8B
+#define MODE_8X8_FLAGS							0X8C
+#define ENTROPY_CODING_MODE_FLAG					0X8D
+#define SLICE_QUANT							0X8E
+#define TOTAL_MB_HEIGHT							0X8F
+#define PICTURE_STRUCTURE						0X90
+#define TOP_INTRA_TYPE							0X91
+#define RV_AI_STATUS							0X92
+#define AI_READ_START							0X93
+#define AI_WRITE_START							0X94
+#define AI_CUR_BUFFER							0X95
+#define AI_DMA_BUFFER							0X96
+#define AI_READ_OFFSET							0X97
+#define AI_WRITE_OFFSET							0X98
+#define AI_WRITE_OFFSET_SAVE						0X99
+#define RV_AI_BUFF_START						0X9A
+#define I_PIC_MB_COUNT							0X9B
+#define AI_WR_DCAC_DMA_CTRL						0X9C
+#define SLICE_MB_COUNT							0X9D
+#define PICTYPE								0X9E
+#define SLICE_GROUP_MAP_TYPE						0X9F
+#define MB_TYPE								0XA0
+#define MB_AFF_ADDED_DMA						0XA1
+#define PREVIOUS_MB_TYPE						0XA2
+#define WEIGHTED_PRED_FLAG						0XA3
+#define WEIGHTED_BIPRED_IDC						0XA4
+/* bit 3:2 - PICTURE_STRUCTURE
+ * bit 1 - MB_ADAPTIVE_FRAME_FIELD_FLAG
+ * bit 0 - FRAME_MBS_ONLY_FLAG
+ */
+#define MBFF_INFO							0XA5
+#define TOP_INTRA_TYPE_TOP						0XA6
+
+#define RV_AI_BUFF_INC							0xa7
+
+#define DEFAULT_MB_INFO_LO						0xa8
+
+/* 0 -- no need to read
+ * 1 -- need to wait Left
+ * 2 -- need to read Intra
+ * 3 -- need to read back MV
+ */
+#define NEED_READ_TOP_INFO						0xa9
+/* 0 -- idle
+ * 1 -- wait Left
+ * 2 -- reading top Intra
+ * 3 -- reading back MV
+ */
+#define READ_TOP_INFO_STATE						0xaa
+#define DCAC_MBX							0xab
+#define TOP_MB_INFO_OFFSET						0xac
+#define TOP_MB_INFO_RD_IDX						0xad
+#define TOP_MB_INFO_WR_IDX						0xae
+
+#define VLD_NO_WAIT     0
+#define VLD_WAIT_BUFFER 1
+#define VLD_WAIT_HOST   2
+#define VLD_WAIT_GAP	3
+
+#define VLD_WAITING							0xaf
+
+#define MB_X_NUM							0xb0
+/* #define MB_WIDTH							0xb1 */
+#define MB_HEIGHT							0xb2
+#define MBX								0xb3
+#define TOTAL_MBY							0xb4
+#define INTR_MSK_SAVE							0xb5
+
+/* #define has_time_stamp						0xb6 */
+#define NEED_DISABLE_PPE						0xb6
+#define IS_NEW_PICTURE							0XB7
+#define PREV_NAL_REF_IDC						0XB8
+#define PREV_NAL_UNIT_TYPE						0XB9
+#define FRAME_MB_COUNT							0XBA
+#define SLICE_GROUP_UCODE						0XBB
+#define SLICE_GROUP_CHANGE_RATE						0XBC
+#define SLICE_GROUP_CHANGE_CYCLE_LEN					0XBD
+#define DELAY_LENGTH							0XBE
+#define PICTURE_STRUCT							0XBF
+/* #define pre_picture_struct						0xc0 */
+#define DCAC_PREVIOUS_MB_TYPE						0xc1
+
+#define TIME_STAMP							0XC2
+#define H_TIME_STAMP							0XC3
+#define VPTS_MAP_ADDR							0XC4
+#define H_VPTS_MAP_ADDR							0XC5
+
+#define MAX_DPB_SIZE							0XC6
+#define PIC_INSERT_FLAG							0XC7
+
+#define TIME_STAMP_START						0XC8
+#define TIME_STAMP_END							0XDF
+
+#define OFFSET_FOR_NON_REF_PIC						0XE0
+#define OFFSET_FOR_TOP_TO_BOTTOM_FIELD					0XE2
+#define MAX_REFERENCE_FRAME_NUM						0XE4
+#define FRAME_NUM_GAP_ALLOWED						0XE5
+#define NUM_REF_FRAMES_IN_PIC_ORDER_CNT_CYCLE				0XE6
+#define PROFILE_IDC_MMCO						0XE7
+#define LEVEL_IDC_MMCO							0XE8
+#define FRAME_SIZE_IN_MB						0XE9
+#define DELTA_PIC_ORDER_ALWAYS_ZERO_FLAG				0XEA
+#define PPS_NUM_REF_IDX_L0_ACTIVE_MINUS1				0XEB
+#define PPS_NUM_REF_IDX_L1_ACTIVE_MINUS1				0XEC
+#define CURRENT_SPS_ID							0XED
+#define CURRENT_PPS_ID							0XEE
+/* bit 0 - sequence parameter set may change
+ * bit 1 - picture parameter set may change
+ * bit 2 - new dpb just inited
+ * bit 3 - IDR picture not decoded yet
+ * bit 5:4 - 0: mb level code loaded 1: picture
+ * level code loaded 2: slice level code loaded
+ */
+#define DECODE_STATUS							0XEF
+#define FIRST_MB_IN_SLICE						0XF0
+#define PREV_MB_WIDTH							0XF1
+#define PREV_FRAME_SIZE_IN_MB						0XF2
+#define MAX_REFERENCE_FRAME_NUM_IN_MEM					0XF3
+/* bit 0 - aspect_ratio_info_present_flag
+ * bit 1 - timing_info_present_flag
+ * bit 2 - nal_hrd_parameters_present_flag
+ * bit 3 - vcl_hrd_parameters_present_flag
+ * bit 4 - pic_struct_present_flag
+ * bit 5 - bitstream_restriction_flag
+ */
+#define VUI_STATUS							0XF4
+#define ASPECT_RATIO_IDC						0XF5
+#define ASPECT_RATIO_SAR_WIDTH						0XF6
+#define ASPECT_RATIO_SAR_HEIGHT						0XF7
+#define NUM_UNITS_IN_TICK						0XF8
+#define TIME_SCALE							0XFA
+#define CURRENT_PIC_INFO						0XFC
+#define DPB_BUFFER_INFO							0XFD
+#define	REFERENCE_POOL_INFO						0XFE
+#define REFERENCE_LIST_INFO						0XFF
+	struct{
+		unsigned short data[RPM_END-RPM_BEGIN];
+	} l;
+	struct{
+		unsigned short dump[DPB_OFFSET];
+		unsigned short dpb_base[FRAME_IN_DPB<<3];
+
+		unsigned short dpb_max_buffer_frame;
+		unsigned short actual_dpb_size;
+
+		unsigned short colocated_buf_status;
+
+		unsigned short num_forward_short_term_reference_pic;
+		unsigned short num_short_term_reference_pic;
+		unsigned short num_reference_pic;
+
+		unsigned short current_dpb_index;
+		unsigned short current_decoded_frame_num;
+		unsigned short current_reference_frame_num;
+
+		unsigned short l0_size;
+		unsigned short l1_size;
+
+		/* [6:5] : nal_ref_idc */
+		/* [4:0] : nal_unit_type */
+		unsigned short NAL_info_mmco;
+
+		/* [1:0] : 00 - top field, 01 - bottom field,
+		   10 - frame, 11 - mbaff frame */
+		unsigned short picture_structure_mmco;
+
+		unsigned short frame_num;
+		unsigned short pic_order_cnt_lsb;
+
+		unsigned short num_ref_idx_l0_active_minus1;
+		unsigned short num_ref_idx_l1_active_minus1;
+
+		unsigned short PrevPicOrderCntLsb;
+		unsigned short PreviousFrameNum;
+
+		/* 32 bits variables */
+		unsigned short delta_pic_order_cnt_bottom[2];
+		unsigned short	delta_pic_order_cnt_0[2];
+		unsigned short delta_pic_order_cnt_1[2];
+
+		unsigned short PrevPicOrderCntMsb[2];
+		unsigned short PrevFrameNumOffset[2];
+
+		unsigned short frame_pic_order_cnt[2];
+		unsigned short top_field_pic_order_cnt[2];
+		unsigned short bottom_field_pic_order_cnt[2];
+
+		unsigned short colocated_mv_addr_start[2];
+		unsigned short colocated_mv_addr_end[2];
+		unsigned short colocated_mv_wr_addr[2];
+	} dpb;
+	struct {
+		unsigned short dump[MMCO_OFFSET];
+
+		/* array base address for offset_for_ref_frame */
+		unsigned short offset_for_ref_frame_base[128];
+
+		/* 0 - Index in DPB
+		 * 1 - Picture Flag
+		 *  [    2] : 0 - short term reference,
+		 *            1 - long term reference
+		 *  [    1] : bottom field
+		 *  [    0] : top field
+		 * 2 - Picture Number (short term or long term) low 16 bits
+		 * 3 - Picture Number (short term or long term) high 16 bits
+		 */
+		unsigned short	reference_base[128];
+
+		/* command and parameter, until command is 3 */
+		unsigned short l0_reorder_cmd[66];
+		unsigned short l1_reorder_cmd[66];
+
+		/* command and parameter, until command is 0 */
+		unsigned short mmco_cmd[44];
+
+		unsigned short l0_base[40];
+		unsigned short l1_base[40];
+	} mmco;
+	struct {
+		/* from ucode lmem, do not change this struct */
+	} p;
+};
+
+
+struct StorablePicture;
+struct VideoParameters;
+struct DecodedPictureBuffer;
+
+/* New enum for field processing */
+enum PictureStructure {
+	FRAME,
+	TOP_FIELD,
+	BOTTOM_FIELD
+};
+
+#define I_Slice                               2
+#define P_Slice                               5
+#define B_Slice                               6
+#define P_Slice_0                             0
+#define B_Slice_1                             1
+#define I_Slice_7                             7
+
+enum SliceType {
+	P_SLICE = 0,
+	B_SLICE = 1,
+	I_SLICE = 2,
+	SP_SLICE = 3,
+	SI_SLICE = 4,
+	NUM_SLICE_TYPES = 5
+};
+
+struct SPSParameters {
+	int pic_order_cnt_type;
+	int log2_max_pic_order_cnt_lsb_minus4;
+	int num_ref_frames_in_pic_order_cnt_cycle;
+	short offset_for_ref_frame[128];
+	short offset_for_non_ref_pic;
+	short offset_for_top_to_bottom_field;
+
+	/**/
+	int frame_mbs_only_flag;
+	int num_ref_frames;
+	int max_dpb_size;
+
+	int log2_max_frame_num_minus4;
+};
+
+#define DEC_REF_PIC_MARKING_BUFFER_NUM_MAX   45
+struct DecRefPicMarking_s {
+	int memory_management_control_operation;
+	int difference_of_pic_nums_minus1;
+	int long_term_pic_num;
+	int long_term_frame_idx;
+	int max_long_term_frame_idx_plus1;
+	struct DecRefPicMarking_s *Next;
+};
+
+#define REORDERING_COMMAND_MAX_SIZE    33
+struct Slice {
+	int first_mb_in_slice;
+	int mode_8x8_flags;
+	int picture_structure_mmco;
+
+	int frame_num;
+	int idr_flag;
+	int toppoc;
+	int bottompoc;
+	int framepoc;
+	int pic_order_cnt_lsb;
+	int PicOrderCntMsb;
+	unsigned char field_pic_flag;
+	unsigned char bottom_field_flag;
+	int ThisPOC;
+	int nal_reference_idc;
+	int AbsFrameNum;
+	int delta_pic_order_cnt_bottom;
+	int delta_pic_order_cnt[2];
+
+	/**/
+	char listXsize[6];
+	struct StorablePicture *listX[6][MAX_LIST_SIZE * 2];
+
+	/**/
+	enum PictureStructure structure;
+	int long_term_reference_flag;
+	int no_output_of_prior_pics_flag;
+	int adaptive_ref_pic_buffering_flag;
+
+	struct VideoParameters *p_Vid;
+	struct DecodedPictureBuffer *p_Dpb;
+	int num_ref_idx_active[2];    /* number of available list references */
+
+	/*modification*/
+	int slice_type;    /* slice type */
+	int ref_pic_list_reordering_flag[2];
+	int modification_of_pic_nums_idc[2][REORDERING_COMMAND_MAX_SIZE];
+	int abs_diff_pic_num_minus1[2][REORDERING_COMMAND_MAX_SIZE];
+	int long_term_pic_idx[2][REORDERING_COMMAND_MAX_SIZE];
+	/**/
+	unsigned char dec_ref_pic_marking_buffer_valid;
+	struct DecRefPicMarking_s
+		dec_ref_pic_marking_buffer[DEC_REF_PIC_MARKING_BUFFER_NUM_MAX];
+};
+
+struct OldSliceParams {
+	unsigned field_pic_flag;
+	unsigned frame_num;
+	int      nal_ref_idc;
+	unsigned pic_oder_cnt_lsb;
+	int      delta_pic_oder_cnt_bottom;
+	int      delta_pic_order_cnt[2];
+	unsigned char     bottom_field_flag;
+	unsigned char     idr_flag;
+	int      idr_pic_id;
+	int      pps_id;
+#if (MVC_EXTENSION_ENABLE)
+	int      view_id;
+	int      inter_view_flag;
+	int      anchor_pic_flag;
+#endif
+	int      layer_id;
+};
+
+struct VideoParameters {
+	int PrevPicOrderCntMsb;
+	int PrevPicOrderCntLsb;
+	unsigned char last_has_mmco_5;
+	unsigned char last_pic_bottom_field;
+	int ThisPOC;
+	int PreviousFrameNum;
+	int FrameNumOffset;
+	int PreviousFrameNumOffset;
+	int max_frame_num;
+	unsigned int pre_frame_num;
+	int ExpectedDeltaPerPicOrderCntCycle;
+	int PicOrderCntCycleCnt;
+	int FrameNumInPicOrderCntCycle;
+	int ExpectedPicOrderCnt;
+
+	/**/
+	struct SPSParameters *active_sps;
+	struct Slice **ppSliceList;
+	int iSliceNumOfCurrPic;
+	int conceal_mode;
+	int earlier_missing_poc;
+	int pocs_in_dpb[100];
+
+	struct OldSliceParams old_slice;
+	/**/
+	struct StorablePicture *dec_picture;
+	struct StorablePicture *no_reference_picture;
+
+	/*modification*/
+	int non_conforming_stream;
+	int recovery_point;
+};
+
+static inline int imin(int a, int b)
+{
+	return ((a) < (b)) ? (a) : (b);
+}
+
+static inline int imax(int a, int b)
+{
+	return ((a) > (b)) ? (a) : (b);
+}
+
+#define MAX_PIC_BUF_NUM 128
+#define MAX_NUM_SLICES 50
+
+struct StorablePicture {
+/**/
+	int width;
+	int height;
+
+	int y_canvas_index;
+	int u_canvas_index;
+	int v_canvas_index;
+/**/
+	int index;
+	unsigned char is_used;
+
+	enum PictureStructure structure;
+
+	int         poc;
+	int         top_poc;
+	int         bottom_poc;
+	int         frame_poc;
+	unsigned int  frame_num;
+	unsigned int  recovery_frame;
+
+	int         pic_num;
+	int         buf_spec_num;
+	int         colocated_buf_index;
+	int         long_term_pic_num;
+	int         long_term_frame_idx;
+
+	unsigned char  is_long_term;
+	int         used_for_reference;
+	int         is_output;
+#if 1
+	/* rain */
+	int         pre_output;
+#endif
+	int         non_existing;
+	int         separate_colour_plane_flag;
+
+	short       max_slice_id;
+
+	int         size_x, size_y, size_x_cr, size_y_cr;
+	int         size_x_m1, size_y_m1, size_x_cr_m1, size_y_cr_m1;
+	int         coded_frame;
+	int         mb_aff_frame_flag;
+	unsigned    PicWidthInMbs;
+	unsigned    PicSizeInMbs;
+	int         iLumaPadY, iLumaPadX;
+	int         iChromaPadY, iChromaPadX;
+
+	/* for mb aff, if frame for referencing the top field */
+	struct StorablePicture *top_field;
+	/* for mb aff, if frame for referencing the bottom field */
+	struct StorablePicture *bottom_field;
+	/* for mb aff, if field for referencing the combined frame */
+	struct StorablePicture *frame;
+
+	int         slice_type;
+	int         idr_flag;
+	int         no_output_of_prior_pics_flag;
+	int         long_term_reference_flag;
+	int         adaptive_ref_pic_buffering_flag;
+
+	int         chroma_format_idc;
+	int         frame_mbs_only_flag;
+	int         frame_cropping_flag;
+	int         frame_crop_left_offset;
+	int         frame_crop_right_offset;
+	int         frame_crop_top_offset;
+	int         frame_crop_bottom_offset;
+	int         qp;
+	int         chroma_qp_offset[2];
+	int         slice_qp_delta;
+	/* stores the memory management control operations */
+	struct DecRefPicMarking_s *dec_ref_pic_marking_buffer;
+
+	/* picture error concealment */
+	/*indicates if this is a concealed picture */
+	int         concealed_pic;
+
+	/* variables for tone mapping */
+	int         seiHasTone_mapping;
+	int         tone_mapping_model_id;
+	int         tonemapped_bit_depth;
+	/* imgpel*     tone_mapping_lut; tone mapping look up table */
+
+	int         proc_flag;
+#if (MVC_EXTENSION_ENABLE)
+	int         view_id;
+	int         inter_view_flag;
+	int         anchor_pic_flag;
+#endif
+	int         iLumaStride;
+	int         iChromaStride;
+	int         iLumaExpandedHeight;
+	int         iChromaExpandedHeight;
+	/* imgpel **cur_imgY; for more efficient get_block_luma */
+	int no_ref;
+	int iCodingType;
+
+	char listXsize[MAX_NUM_SLICES][2];
+	struct StorablePicture **listX[MAX_NUM_SLICES][2];
+	int         layer_id;
+
+	int offset_delimiter_lo;
+	int offset_delimiter_hi;
+
+	u32         pts;
+	u64         pts64;
+};
+
+struct FrameStore {
+	/* rain */
+	int      buf_spec_num;
+	/* rain */
+	int      colocated_buf_index;
+
+	/* 0=empty; 1=top; 2=bottom; 3=both fields (or frame) */
+	int       is_used;
+	/* 0=not used for ref; 1=top used; 2=bottom used;
+	 * 3=both fields (or frame) used */
+	int       is_reference;
+	/* 0=not used for ref; 1=top used; 2=bottom used;
+	 * 3=both fields (or frame) used */
+	int       is_long_term;
+	/* original marking by nal_ref_idc: 0=not used for ref; 1=top used;
+	 * 2=bottom used; 3=both fields (or frame) used */
+	int       is_orig_reference;
+
+	int       is_non_existent;
+
+	unsigned  frame_num;
+	unsigned  recovery_frame;
+
+	int       frame_num_wrap;
+	int       long_term_frame_idx;
+	int       is_output;
+#if 1
+	/* rain */
+	int         pre_output;
+	/* index in gFrameStore */
+	int       index;
+#endif
+	int       poc;
+
+	/* picture error concealment */
+	int concealment_reference;
+
+	struct StorablePicture *frame;
+	struct StorablePicture *top_field;
+	struct StorablePicture *bottom_field;
+
+#if (MVC_EXTENSION_ENABLE)
+	int       view_id;
+	int       inter_view_flag[2];
+	int       anchor_pic_flag[2];
+#endif
+	int       layer_id;
+
+	u32       pts;
+	u64       pts64;
+};
+
+int prepare_display_buf(struct vdec_s *vdec, struct FrameStore *frame);
+
+
+/* #define DPB_SIZE_MAX     16 */
+#define DPB_SIZE_MAX     32
+struct DecodedPictureBuffer {
+	struct VideoParameters *p_Vid;
+	/* InputParameters *p_Inp; ??? */
+	struct FrameStore  *fs[DPB_SIZE_MAX];
+	struct FrameStore  *fs_ref[DPB_SIZE_MAX];
+	struct FrameStore  *fs_ltref[DPB_SIZE_MAX];
+	/* inter-layer reference (for multi-layered codecs) */
+	struct FrameStore  *fs_ilref[DPB_SIZE_MAX];
+	/**/
+	struct FrameStore *fs_list0[DPB_SIZE_MAX];
+	struct FrameStore *fs_list1[DPB_SIZE_MAX];
+	struct FrameStore *fs_listlt[DPB_SIZE_MAX];
+
+	/**/
+	unsigned      size;
+	unsigned      used_size;
+	unsigned      ref_frames_in_buffer;
+	unsigned      ltref_frames_in_buffer;
+	int           last_output_poc;
+#if (MVC_EXTENSION_ENABLE)
+	int           last_output_view_id;
+#endif
+	int           max_long_term_pic_idx;
+
+
+	int           init_done;
+	int           num_ref_frames;
+
+	struct FrameStore   *last_picture;
+	unsigned     used_size_il;
+	int          layer_id;
+
+	/* DPB related function; */
+};
+
+struct h264_dpb_stru {
+	struct vdec_s *vdec;
+	int decoder_index;
+
+	union param dpb_param;
+
+	int decode_idx;
+	int buf_num;
+	int curr_POC;
+	int reorder_pic_num;
+	/**/
+	unsigned int max_reference_size;
+
+	unsigned int colocated_buf_map;
+	unsigned int colocated_buf_count;
+	unsigned int colocated_mv_addr_start;
+	unsigned int colocated_mv_addr_end;
+	unsigned int colocated_buf_size;
+
+	struct DecodedPictureBuffer mDPB;
+	struct Slice mSlice;
+	struct VideoParameters mVideo;
+	struct SPSParameters mSPS;
+
+	struct StorablePicture m_PIC[MAX_PIC_BUF_NUM];
+	struct FrameStore mFrameStore[DPB_SIZE_MAX];
+
+};
+
+
+extern unsigned int h264_debug_flag;
+extern unsigned int h264_debug_mask;
+
+int dpb_print(int indext, int debug_flag, const char *fmt, ...);
+
+unsigned char dpb_is_debug(int index, int debug_flag);
+
+int prepare_display_buf(struct vdec_s *vdec, struct FrameStore *frame);
+
+int release_buf_spec_num(struct vdec_s *vdec, int buf_spec_num);
+
+void set_frame_output_flag(struct h264_dpb_stru *p_H264_Dpb, int index);
+
+int is_there_unused_frame_from_dpb(struct DecodedPictureBuffer *p_Dpb);
+
+int h264_slice_header_process(struct h264_dpb_stru *p_H264_Dpb);
+
+void dpb_init_global(struct h264_dpb_stru *p_H264_Dpb,
+	int id, int actual_dpb_size, int max_reference_size);
+
+void init_colocate_buf(struct h264_dpb_stru *p_H264_Dpb, int count);
+
+int release_colocate_buf(struct h264_dpb_stru *p_H264_Dpb, int index);
+
+int get_free_buf_idx(struct vdec_s *vdec);
+
+void store_picture_in_dpb(struct h264_dpb_stru *p_H264_Dpb,
+			struct StorablePicture *p);
+
+int remove_picture(struct h264_dpb_stru *p_H264_Dpb,
+			struct StorablePicture *pic);
+
+void bufmgr_post(struct h264_dpb_stru *p_H264_Dpb);
+
+int get_long_term_flag_by_buf_spec_num(struct h264_dpb_stru *p_H264_Dpb,
+	int buf_spec_num);
+
+void bufmgr_h264_remove_unused_frame(struct h264_dpb_stru *p_H264_Dpb);
+
+#endif
diff --git a/drivers/amlogic/amports/picdec.c b/drivers/amlogic/amports/picdec.c
index 27dbdb6..1e59605 100644
--- a/drivers/amlogic/amports/picdec.c
+++ b/drivers/amlogic/amports/picdec.c
@@ -641,7 +641,10 @@ static int picdec_start(void)
 
 	unsigned map_start, map_size = 0;
 
-	picdec_buffer_init();
+	if (picdec_buffer_init() < 0) {
+		aml_pr_info(0, "no memory, open fail\n");
+		return -1;
+	}
 
 	get_picdec_buf_info(&buf_start, &buf_size, NULL);
 
@@ -1435,9 +1438,9 @@ int picdec_fill_buffer(struct vframe_s *vf, struct ge2d_context_s *context,
 
 	ge2d_config->src_para.left = 0;
 
-	ge2d_config->src_para.width = frame_width;
+	ge2d_config->src_para.width = picdec_device.origin_width;
 
-	ge2d_config->src_para.height = frame_height;
+	ge2d_config->src_para.height = picdec_device.origin_height;
 
 	/* pr_info("vf_width is %d , vf_height is %d\n",
 	   vf->width ,vf->height); */
@@ -1767,7 +1770,7 @@ int picdec_cma_buf_uninit(void)
 int picdec_buffer_init(void)
 {
 	int i;
-
+	int ret = 0;
 	u32 canvas_width, canvas_height;
 
 	u32 decbuf_size;
@@ -1784,8 +1787,10 @@ int picdec_buffer_init(void)
 
 	sema_init(&pic_vb_done_sema, 1);/*init 1*/
 
-	if (!buf_start || !buf_size)
+	if (!buf_start || !buf_size) {
+		ret = -1;
 		goto exit;
+	}
 
 	picdec_device.vinfo = get_current_vinfo();
 
@@ -1830,7 +1835,7 @@ int picdec_buffer_init(void)
 	picdec_device.assit_buf_start =
 		buf_start + canvas_width * canvas_height * 3;
 exit:
-	return 0;
+	return ret;
 
 }
 
diff --git a/drivers/amlogic/amports/psparser.c b/drivers/amlogic/amports/psparser.c
index a794706..08c39cc 100644
--- a/drivers/amlogic/amports/psparser.c
+++ b/drivers/amlogic/amports/psparser.c
@@ -853,7 +853,7 @@ static ssize_t _psparser_write(const char __user *buf, size_t count)
 	return count - r;
 }
 
-s32 psparser_init(u32 vid, u32 aid, u32 sid)
+s32 psparser_init(u32 vid, u32 aid, u32 sid, struct vdec_s *vdec)
 {
 	s32 r;
 	u32 parser_sub_start_ptr;
@@ -911,10 +911,19 @@ s32 psparser_init(u32 vid, u32 aid, u32 sid)
 	CLEAR_MPEG_REG_MASK(TS_FILE_CONFIG, (1 << TS_HIU_ENABLE));
 
 	/* hook stream buffer with PARSER */
-	WRITE_MPEG_REG(PARSER_VIDEO_START_PTR,
-				   READ_VREG(VLD_MEM_VIFIFO_START_PTR));
-	WRITE_MPEG_REG(PARSER_VIDEO_END_PTR, READ_VREG(VLD_MEM_VIFIFO_END_PTR));
-	CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
+	WRITE_MPEG_REG(PARSER_VIDEO_START_PTR, vdec->input.start);
+	WRITE_MPEG_REG(PARSER_VIDEO_END_PTR,
+		vdec->input.start + vdec->input.size - 8);
+
+	if (vdec_single(vdec)) {
+		CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
+		WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+		CLEAR_VREG_MASK(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	} else {
+		SET_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
+		WRITE_MPEG_REG(PARSER_VIDEO_WP, vdec->input.start);
+		WRITE_MPEG_REG(PARSER_VIDEO_RP, vdec->input.start);
+	}
 
 	WRITE_MPEG_REG(PARSER_AUDIO_START_PTR,
 				   READ_MPEG_REG(AIU_MEM_AIFIFO_START_PTR));
@@ -927,8 +936,10 @@ s32 psparser_init(u32 vid, u32 aid, u32 sid)
 				   (1 << PS_CFG_MAX_ES_WR_CYCLE_BIT) |
 				   (16 << PS_CFG_MAX_FETCH_CYCLE_BIT));
 
-	WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
-	CLEAR_VREG_MASK(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	if (vdec_single(vdec)) {
+		WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+		CLEAR_VREG_MASK(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+	}
 
 	WRITE_MPEG_REG(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
 	CLEAR_MPEG_REG_MASK(AIU_MEM_AIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
@@ -1017,7 +1028,8 @@ ssize_t psparser_write(struct file *file,
 	const char __user *buf, size_t count)
 {
 	s32 r;
-	struct stream_port_s *port = (struct stream_port_s *)file->private_data;
+	struct port_priv_s *priv = (struct port_priv_s *)file->private_data;
+	struct stream_port_s *port = priv->port;
 
 	if ((stbuf_space(vbuf) < count) || (stbuf_space(abuf) < count)) {
 		if (file->f_flags & O_NONBLOCK)
diff --git a/drivers/amlogic/amports/psparser.h b/drivers/amlogic/amports/psparser.h
index 95d112a..ccdce39 100644
--- a/drivers/amlogic/amports/psparser.h
+++ b/drivers/amlogic/amports/psparser.h
@@ -18,7 +18,9 @@
 #ifndef PSPARSER_H
 #define PSPARSER_H
 
-extern s32 psparser_init(u32 vid, u32 aid, u32 sid);
+#include "vdec.h"
+
+extern s32 psparser_init(u32 vid, u32 aid, u32 sid, struct vdec_s *vdec);
 
 extern void psparser_release(void);
 
diff --git a/drivers/amlogic/amports/rdma.c b/drivers/amlogic/amports/rdma.c
index 0f4ba18..053a5a2 100644
--- a/drivers/amlogic/amports/rdma.c
+++ b/drivers/amlogic/amports/rdma.c
@@ -46,30 +46,19 @@
 #define Wr(adr, val) WRITE_VCBUS_REG(adr, val)
 #define Rd(adr)    READ_VCBUS_REG(adr)
 #define Wr_reg_bits(adr, val, start, len) \
-			WRITE_VCBUS_REG_BITS(adr, val, start, len)
-
-
-/*#define CONFIG_RDMA_IN_RDMAIRQ*/
-/*#define CONFIG_RDMA_IN_TASK*/
-
-#define RDMA_TABLE_SIZE                    (2 * (PAGE_SIZE))
+	WRITE_VCBUS_REG_BITS(adr, val, start, len)
 
+#define RDMA_TABLE_SIZE                    (8 * (PAGE_SIZE))
 static int vsync_rdma_handle;
-
 static int irq_count;
-
 static int enable;
-
-static int enable_mask = 0x400ff;
-
+static int cur_enable;
 static int pre_enable_;
-
 static int debug_flag;
-
 static int vsync_cfg_count;
-
-#define RDMA_VSYNC_INPUT_TRIG		0x1
-static bool vsync_rdma_config_delay_flag;
+static u32 force_rdma_config;
+static bool first_config;
+static bool rdma_done;
 
 static void vsync_rdma_irq(void *arg);
 
@@ -78,96 +67,81 @@ struct rdma_op_s vsync_rdma_op = {
 	NULL
 };
 
-static struct semaphore  rdma_sema;
-struct task_struct *rdma_task = NULL;
-static unsigned rdma_config_flag;
-
-static unsigned char rdma_start_flag;
-
-
-static int rdma_task_handle(void *data)
-{
-	int ret = 0;
-	while (1) {
-		ret = down_interruptible(&rdma_sema);
-		if (debug_flag & 2)
-			pr_info("%s: %x\r\n", __func__ , rdma_config_flag);
-		if (rdma_config_flag == 1) {
-			rdma_config_flag = 0;
-			if (rdma_config(vsync_rdma_handle,
-				RDMA_VSYNC_INPUT_TRIG) != 1){
-				rdma_config_flag = 2;
-				/* fail or rdma table empty,
-				there is no rdma irq */
-			}
-		}
-		if (rdma_start_flag) {
-			if (vsync_rdma_handle <= 0)
-				vsync_rdma_handle =
-				rdma_register(&vsync_rdma_op,
-				NULL, RDMA_TABLE_SIZE);
-			rdma_start_flag = 0;
-		}
-	}
-	return 0;
-}
-
-
 void vsync_rdma_config(void)
 {
-	int enable_ = ((enable & enable_mask) | (enable_mask >> 8)) & 0xff;
+	int iret = 0;
+	int enable_ = cur_enable & 0xf;
 
-	if (vsync_rdma_handle == 0)
+	if (vsync_rdma_handle <= 0)
 		return;
 
+	/* first frame not use rdma */
+	if (!first_config) {
+		cur_enable = enable;
+		pre_enable_ = enable_;
+		first_config = true;
+		rdma_done = false;
+		return;
+	}
+
+	/* if rdma mode changed, reset rdma */
 	if (pre_enable_ != enable_) {
-		if (((enable_mask >> 17) & 0x1) == 0)
-			rdma_clear(vsync_rdma_handle);
-		vsync_rdma_config_delay_flag = false;
+		rdma_clear(vsync_rdma_handle);
+		force_rdma_config = 1;
 	}
-	if (enable == 1)
-		rdma_watchdog_setting(1);
-	else
-		rdma_watchdog_setting(0);
-	if (enable_ == 1) {
-#ifdef CONFIG_RDMA_IN_TASK
-		if (debug_flag & 2) {
-			pr_info("%s: %d : %d :\r\n", __func__ ,
-			rdma_config_flag , pre_enable_);
-		}
-		if ((rdma_config_flag == 2) || (pre_enable_ != enable)) {
-			rdma_config_flag = 1;
-			up(&rdma_sema);
-		}
-
-#elif (defined CONFIG_RDMA_IN_RDMAIRQ)
-		if (pre_enable_ != enable_)
-			rdma_config(vsync_rdma_handle, RDMA_VSYNC_INPUT_TRIG);
-#else
-		rdma_config(vsync_rdma_handle, RDMA_VSYNC_INPUT_TRIG);
-		vsync_cfg_count++;
-#endif
-	} else if (enable_ == 2)
-		rdma_config(vsync_rdma_handle,
-			RDMA_TRIGGER_MANUAL); /*manually in cur vsync*/
-	else if (enable_ == 3)
-		;
-	else if (enable_ == 4)
-		rdma_config(vsync_rdma_handle,
-			RDMA_TRIGGER_DEBUG1); /*for debug*/
-	else if (enable_ == 5)
-		rdma_config(vsync_rdma_handle,
-			RDMA_TRIGGER_DEBUG2); /*for debug*/
-	else if (enable_ == 6)
-		;
 
+	if (force_rdma_config)
+		rdma_done = true;
+
+	if (enable_ == 1) {
+		if (rdma_done)
+			iret = rdma_watchdog_setting(0);
+		else
+			iret = rdma_watchdog_setting(1);
+	} else {
+		/* not vsync mode */
+		iret = rdma_watchdog_setting(0);
+		force_rdma_config = 1;
+	}
+	rdma_done = false;
+	if (iret)
+		force_rdma_config = 1;
+
+	iret = 0;
+	if (force_rdma_config) {
+		if (enable_ == 1) {
+			iret = rdma_config(vsync_rdma_handle,
+				RDMA_TRIGGER_VSYNC_INPUT);
+			if (iret)
+				vsync_cfg_count++;
+		} else if (enable_ == 2)
+			/*manually in cur vsync*/
+			rdma_config(vsync_rdma_handle,
+				RDMA_TRIGGER_MANUAL);
+		else if (enable_ == 3)
+			;
+		else if (enable_ == 4)
+			rdma_config(vsync_rdma_handle,
+				RDMA_TRIGGER_DEBUG1); /*for debug*/
+		else if (enable_ == 5)
+			rdma_config(vsync_rdma_handle,
+				RDMA_TRIGGER_DEBUG2); /*for debug*/
+		else if (enable_ == 6)
+			;
+		if (!iret)
+			force_rdma_config = 1;
+		else
+			force_rdma_config = 0;
+	}
 	pre_enable_ = enable_;
+	cur_enable = enable;
 }
 EXPORT_SYMBOL(vsync_rdma_config);
 
 void vsync_rdma_config_pre(void)
 {
-	int enable_ = ((enable&enable_mask)|(enable_mask>>8))&0xff;
+	int enable_ = cur_enable & 0xf;
+
 	if (vsync_rdma_handle == 0)
 		return;
 	if (enable_ == 3)/*manually in next vsync*/
@@ -179,48 +153,32 @@ EXPORT_SYMBOL(vsync_rdma_config_pre);
 
 static void vsync_rdma_irq(void *arg)
 {
-#ifdef CONFIG_RDMA_IN_TASK
-	int enable_ = ((enable&enable_mask) | (enable_mask >> 8)) & 0xff;
+	int iret;
+	int enable_ = cur_enable & 0xf;
 
 	if (enable_ == 1) {
-		rdma_config_flag = 1;
-		up(&rdma_sema);
+		/*triggered by next vsync*/
+		iret = rdma_config(vsync_rdma_handle,
+			RDMA_TRIGGER_VSYNC_INPUT);
+		if (iret)
+			vsync_cfg_count++;
 	} else
-		rdma_config(vsync_rdma_handle, 0);
+		iret = rdma_config(vsync_rdma_handle, 0);
+	pre_enable_ = enable_;
 
-#elif (defined CONFIG_RDMA_IN_RDMAIRQ)
-	int enable_ = ((enable&enable_mask) | (enable_mask >> 8)) & 0xff;
-	if (enable_ == 1)
-		rdma_config(vsync_rdma_handle,
-		RDMA_VSYNC_INPUT_TRIG); /*triggered by next vsync*/
+	if ((!iret) || (enable_ != 1))
+		force_rdma_config = 1;
 	else
-		rdma_config(vsync_rdma_handle, 0);
-#endif
+		force_rdma_config = 0;
+	rdma_done = true;
 	irq_count++;
 	return;
 }
 
-MODULE_PARM_DESC(enable, "\n enable\n");
-module_param(enable, uint, 0664);
-
-MODULE_PARM_DESC(enable_mask, "\n enable_mask\n");
-module_param(enable_mask, uint, 0664);
-
-MODULE_PARM_DESC(irq_count, "\n irq_count\n");
-module_param(irq_count, uint, 0664);
-
-
-
-MODULE_PARM_DESC(debug_flag, "\n debug_flag\n");
-module_param(debug_flag, uint, 0664);
-
-
-MODULE_PARM_DESC(vsync_cfg_count, "\n vsync_cfg_count\n");
-module_param(vsync_cfg_count, uint, 0664);
-
 u32 VSYNC_RD_MPEG_REG(u32 adr)
 {
-	int enable_ = ((enable&enable_mask) | (enable_mask >> 8)) & 0xff;
+	int enable_ = cur_enable & 0xf;
+
 	u32 read_val = Rd(adr);
 	if ((enable_ != 0) && (vsync_rdma_handle > 0))
 		read_val = rdma_read_reg(vsync_rdma_handle, adr);
@@ -231,7 +189,8 @@ EXPORT_SYMBOL(VSYNC_RD_MPEG_REG);
 
 int VSYNC_WR_MPEG_REG(u32 adr, u32 val)
 {
-	int enable_ = ((enable & enable_mask) | (enable_mask >> 8)) & 0xff;
+	int enable_ = cur_enable & 0xf;
+
 	if ((enable_ != 0) && (vsync_rdma_handle > 0)) {
 		rdma_write_reg(vsync_rdma_handle, adr, val);
 	} else {
@@ -245,10 +204,11 @@ EXPORT_SYMBOL(VSYNC_WR_MPEG_REG);
 
 int VSYNC_WR_MPEG_REG_BITS(u32 adr, u32 val, u32 start, u32 len)
 {
-	int enable_ = ((enable & enable_mask) | (enable_mask >> 8)) & 0xff;
+	int enable_ = cur_enable & 0xf;
+
 	if ((enable_ != 0) && (vsync_rdma_handle > 0)) {
 		rdma_write_reg_bits(vsync_rdma_handle, adr, val, start, len);
-	}	else {
+	} else {
 		u32 read_val = Rd(adr);
 		u32 write_val = (read_val & ~(((1L<<(len))-1)<<(start)))
 			|((unsigned int)(val) << (start));
@@ -260,23 +220,15 @@ int VSYNC_WR_MPEG_REG_BITS(u32 adr, u32 val, u32 start, u32 len)
 }
 EXPORT_SYMBOL(VSYNC_WR_MPEG_REG_BITS);
 
-
 bool is_vsync_rdma_enable(void)
 {
-	int enable_ = ((enable & enable_mask) | (enable_mask >> 8)) & 0xff;
-	return (enable_ != 0) && (((enable_mask >> 19) & 0x1) == 0);
+	bool ret;
+	int enable_ = cur_enable & 0xf;
+	ret = (enable_ != 0);
+	return ret;
 }
 EXPORT_SYMBOL(is_vsync_rdma_enable);
 
-void start_rdma(void)
-{
-	if (vsync_rdma_handle <= 0) {
-		rdma_start_flag = 1;
-		up(&rdma_sema);
-	}
-}
-EXPORT_SYMBOL(start_rdma);
-
 void enable_rdma_log(int flag)
 {
 	if (flag)
@@ -297,13 +249,29 @@ static int  __init rdma_init(void)
 	WRITE_VCBUS_REG(VPU_VDISP_ASYNC_HOLD_CTRL, 0x18101810);
 	WRITE_VCBUS_REG(VPU_VPUARB2_ASYNC_HOLD_CTRL, 0x18101810);
 
+	vsync_rdma_handle =
+		rdma_register(&vsync_rdma_op,
+		NULL, RDMA_TABLE_SIZE);
+	pr_info("%s video rdma handle = %d.\n", __func__,
+		vsync_rdma_handle);
+	cur_enable = 0;
 	enable = 1;
-
-	sema_init(&rdma_sema, 1);
-	kthread_run(rdma_task_handle, NULL, "kthread_h265");
+	force_rdma_config = 1;
 	return 0;
 }
+module_init(rdma_init);
+
+MODULE_PARM_DESC(enable, "\n enable\n");
+module_param(enable, uint, 0664);
 
+MODULE_PARM_DESC(irq_count, "\n irq_count\n");
+module_param(irq_count, uint, 0664);
 
+MODULE_PARM_DESC(debug_flag, "\n debug_flag\n");
+module_param(debug_flag, uint, 0664);
 
-module_init(rdma_init);
+MODULE_PARM_DESC(vsync_cfg_count, "\n vsync_cfg_count\n");
+module_param(vsync_cfg_count, uint, 0664);
+
+MODULE_PARM_DESC(force_rdma_config, "\n force_rdma_config\n");
+module_param(force_rdma_config, uint, 0664);
diff --git a/drivers/amlogic/amports/rdma.h b/drivers/amlogic/amports/rdma.h
index fd0f181..2d83099 100644
--- a/drivers/amlogic/amports/rdma.h
+++ b/drivers/amlogic/amports/rdma.h
@@ -3,11 +3,9 @@
 void vsync_rdma_config(void);
 void vsync_rdma_config_pre(void);
 bool is_vsync_rdma_enable(void);
-void start_rdma(void);
 void enable_rdma_log(int flag);
 void enable_rdma(int enable_flag);
 extern int rdma_watchdog_setting(int flag);
-int rdma_init2(void);
 
 #endif
 
diff --git a/drivers/amlogic/amports/rmparser.c b/drivers/amlogic/amports/rmparser.c
index 1ed65e5..5ec29e6 100644
--- a/drivers/amlogic/amports/rmparser.c
+++ b/drivers/amlogic/amports/rmparser.c
@@ -58,7 +58,7 @@ static irqreturn_t rm_parser_isr(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-s32 rmparser_init(void)
+s32 rmparser_init(struct vdec_s *vdec)
 {
 	s32 r;
 	parse_halt = 0;
@@ -82,9 +82,10 @@ s32 rmparser_init(void)
 	CLEAR_MPEG_REG_MASK(TS_FILE_CONFIG, (1 << TS_HIU_ENABLE));
 
 	/* hook stream buffer with PARSER */
-	WRITE_MPEG_REG(PARSER_VIDEO_START_PTR,
-				   READ_VREG(VLD_MEM_VIFIFO_START_PTR));
-	WRITE_MPEG_REG(PARSER_VIDEO_END_PTR, READ_VREG(VLD_MEM_VIFIFO_END_PTR));
+	WRITE_MPEG_REG(PARSER_VIDEO_START_PTR, vdec->input.start);
+	WRITE_MPEG_REG(PARSER_VIDEO_END_PTR,
+		vdec->input.start + vdec->input.size - 8);
+
 	CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
 
 	WRITE_MPEG_REG(PARSER_AUDIO_START_PTR,
@@ -270,7 +271,8 @@ ssize_t rmparser_write(struct file *file,
 					   const char __user *buf, size_t count)
 {
 	s32 r;
-	struct stream_port_s *port = (struct stream_port_s *)file->private_data;
+	struct port_priv_s *priv = (struct port_priv_s *)file->private_data;
+	struct stream_port_s *port = priv->port;
 	size_t towrite = count;
 	if ((stbuf_space(vbuf) < count) || (stbuf_space(abuf) < count)) {
 		if (file->f_flags & O_NONBLOCK) {
diff --git a/drivers/amlogic/amports/rmparser.h b/drivers/amlogic/amports/rmparser.h
index cdb7584..4db6564 100644
--- a/drivers/amlogic/amports/rmparser.h
+++ b/drivers/amlogic/amports/rmparser.h
@@ -18,6 +18,8 @@
 #ifndef RMPARSER_H
 #define RMPARSER_H
 
+#include "vdec.h"
+
 extern void rm_set_vasid(u32 vid, u32 aid);
 
 extern ssize_t rmparser_write(struct file *file,
@@ -25,7 +27,7 @@ extern ssize_t rmparser_write(struct file *file,
 		struct stream_buf_s *abuf,
 		const char __user *buf, size_t count);
 
-s32 rmparser_init(void);
+s32 rmparser_init(struct vdec_s *vdec);
 
 extern void rmparser_release(void);
 
diff --git a/drivers/amlogic/amports/streambuf.c b/drivers/amlogic/amports/streambuf.c
index 2fd8c5a..b78200f 100644
--- a/drivers/amlogic/amports/streambuf.c
+++ b/drivers/amlogic/amports/streambuf.c
@@ -105,7 +105,8 @@ static s32 _stbuf_alloc(struct stream_buf_s *buf)
 				"Subtitle", (void *)buf->buf_start,
 				buf->buf_size);
 	}
-
+	if (buf->buf_size < buf->canusebuf_size)
+		buf->canusebuf_size = buf->buf_size;
 	buf->flag |= BUF_FLAG_ALLOC;
 
 	return 0;
@@ -181,11 +182,6 @@ void stbuf_fetch_release(void)
 	return;
 }
 
-static inline u32 _stbuf_wp(struct stream_buf_s *buf)
-{
-	return _READ_ST_REG(WP);
-}
-
 static void _stbuf_timer_func(unsigned long arg)
 {
 	struct stream_buf_s *p = (struct stream_buf_s *)arg;
@@ -201,16 +197,35 @@ static void _stbuf_timer_func(unsigned long arg)
 
 u32 stbuf_level(struct stream_buf_s *buf)
 {
-	return (buf->type ==
-			BUF_TYPE_HEVC) ? READ_VREG(HEVC_STREAM_LEVEL) :
-		   _READ_ST_REG(LEVEL);
+	if ((buf->type == BUF_TYPE_HEVC) || (buf->type == BUF_TYPE_VIDEO)) {
+		if (READ_MPEG_REG(PARSER_ES_CONTROL) & 1) {
+			int level = READ_MPEG_REG(PARSER_VIDEO_WP) -
+				READ_MPEG_REG(PARSER_VIDEO_RP);
+			if (level < 0)
+				level += READ_MPEG_REG(PARSER_VIDEO_END_PTR) -
+				READ_MPEG_REG(PARSER_VIDEO_START_PTR) + 8;
+			return (u32)level;
+		} else
+			return (buf->type == BUF_TYPE_HEVC) ?
+				READ_VREG(HEVC_STREAM_LEVEL) :
+				_READ_ST_REG(LEVEL);
+	}
+
+	return _READ_ST_REG(LEVEL);
 }
 
 u32 stbuf_rp(struct stream_buf_s *buf)
 {
-	return (buf->type ==
-			BUF_TYPE_HEVC) ? READ_VREG(HEVC_STREAM_RD_PTR) :
-		   _READ_ST_REG(RP);
+	if ((buf->type == BUF_TYPE_HEVC) || (buf->type == BUF_TYPE_VIDEO)) {
+		if (READ_MPEG_REG(PARSER_ES_CONTROL) & 1)
+			return READ_MPEG_REG(PARSER_VIDEO_RP);
+		else
+			return (buf->type == BUF_TYPE_HEVC) ?
+				READ_VREG(HEVC_STREAM_RD_PTR) :
+				_READ_ST_REG(RP);
+	}
+
+	return _READ_ST_REG(RP);
 }
 
 u32 stbuf_space(struct stream_buf_s *buf)
@@ -219,30 +234,7 @@ u32 stbuf_space(struct stream_buf_s *buf)
 	   the parser fifo size is 1024byts, so reserve it */
 	int size;
 
-	if (buf->type == BUF_TYPE_HEVC)
-		size = buf->canusebuf_size - READ_VREG(HEVC_STREAM_LEVEL);
-	else
-		size = (buf->canusebuf_size - _READ_ST_REG(LEVEL));
-
-	/* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TVD */
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8) {
-		if ((buf->type == BUF_TYPE_VIDEO) && (vdec_on(VDEC_2))) {
-			int v2_start = _READ_VDEC2_ST_REG(START_PTR);
-			int v_start = _READ_ST_REG(START_PTR);
-			int v2_end = _READ_VDEC2_ST_REG(END_PTR);
-			int v_end = _READ_ST_REG(END_PTR);
-			int v2_ctl = _READ_VDEC2_ST_REG(CONTROL);
-			if ((v2_start == v_start)
-					&& (v2_end == v_end)
-					&& (v2_ctl & MEM_CTRL_FILL_EN)) {
-				int v2_st_level = _READ_VDEC2_ST_REG(LEVEL);
-				size = min(size,
-						(int)(buf->canusebuf_size -
-							  v2_st_level));
-			}
-		}
-	}
-	/* #endif */
+	size = buf->canusebuf_size - stbuf_level(buf);
 
 	if (buf->canusebuf_size >= buf->buf_size / 2) {
 		/* old reversed value,tobe full, reversed only... */
@@ -266,7 +258,7 @@ u32 stbuf_canusesize(struct stream_buf_s *buf)
 	return buf->canusebuf_size;
 }
 
-s32 stbuf_init(struct stream_buf_s *buf)
+s32 stbuf_init(struct stream_buf_s *buf, struct vdec_s *vdec)
 {
 	s32 r;
 	u32 dummy;
@@ -279,6 +271,18 @@ s32 stbuf_init(struct stream_buf_s *buf)
 	}
 	addr32 = buf->buf_start & 0xffffffff;
 	init_waitqueue_head(&buf->wq);
+
+	if ((buf->type == BUF_TYPE_VIDEO) || (buf->type == BUF_TYPE_HEVC)) {
+		if (vdec) {
+			if (vdec_stream_based(vdec))
+				vdec_input_set_buffer(&vdec->input, addr32,
+						buf->buf_size);
+			else
+				return vdec_input_set_buffer(&vdec->input,
+					addr32,	buf->buf_size);
+		}
+	}
+
 	buf->write_thread = 0;
 	if (has_hevc_vdec() && buf->type == BUF_TYPE_HEVC) {
 		CLEAR_VREG_MASK(HEVC_STREAM_CONTROL, 1);
@@ -384,7 +388,9 @@ s32 stbuf_wait_space(struct stream_buf_s *stream_buf, size_t count)
 void stbuf_release(struct stream_buf_s *buf)
 {
 	buf->first_tstamp = INVALID_PTS;
-	stbuf_init(buf);	/* reinit buffer */
+
+	stbuf_init(buf, NULL);	/* reinit buffer */
+
 	if (buf->flag & BUF_FLAG_ALLOC && buf->buf_start) {
 		codec_mm_free_for_dma(MEM_NAME, buf->buf_start);
 		buf->flag &= ~BUF_FLAG_ALLOC;
diff --git a/drivers/amlogic/amports/streambuf.h b/drivers/amlogic/amports/streambuf.h
index 703ccd5..0c3ba83 100644
--- a/drivers/amlogic/amports/streambuf.h
+++ b/drivers/amlogic/amports/streambuf.h
@@ -37,6 +37,8 @@
 #define FETCHBUF_SIZE   (64*1024)
 #define USER_DATA_SIZE  (8*1024)
 
+struct vdec_s;
+
 struct stream_buf_s {
 	s32 flag;
 	u32 type;
@@ -105,6 +107,9 @@ struct drm_info {
 } /*drminfo_t */;
 
 #define TYPE_DRMINFO   0x80
+#define TYPE_PATTERN   0x40
+
+struct vdec_s;
 
 extern void *fetchbuf;
 
@@ -113,7 +118,7 @@ extern u32 stbuf_rp(struct stream_buf_s *buf);
 extern u32 stbuf_space(struct stream_buf_s *buf);
 extern u32 stbuf_size(struct stream_buf_s *buf);
 extern u32 stbuf_canusesize(struct stream_buf_s *buf);
-extern s32 stbuf_init(struct stream_buf_s *buf);
+extern s32 stbuf_init(struct stream_buf_s *buf, struct vdec_s *vdec);
 extern s32 stbuf_wait_space(struct stream_buf_s *stream_buf, size_t count);
 extern void stbuf_release(struct stream_buf_s *buf);
 extern int stbuf_change_size(struct stream_buf_s *buf, int size);
diff --git a/drivers/amlogic/amports/thread_rw.c b/drivers/amlogic/amports/thread_rw.c
index 7b142f6..c557be7 100644
--- a/drivers/amlogic/amports/thread_rw.c
+++ b/drivers/amlogic/amports/thread_rw.c
@@ -46,24 +46,30 @@ struct threadrw_buf {
 	int write_off;
 	int data_size;
 	int buffer_size;
+	int from_cma;
 };
 
+#define MAX_MM_BUFFER_NUM 16
 struct threadrw_write_task {
 	struct file *file;
 	struct delayed_work write_work;
 	DECLARE_KFIFO_PTR(datafifo, void *);
 	DECLARE_KFIFO_PTR(freefifo, void *);
-	int max_buf;
+	int bufs_num;
+	int max_bufs;
 	int errors;
 	spinlock_t lock;
+	struct mutex mutex;
 	struct stream_buf_s *sbuf;
 	int buffered_data_size;
 	int passed_data_len;
 	int buffer_size;
+	int def_block_size;
 	int data_offset;
 	int writework_on;
-	unsigned long codec_mm_buffer;
+	unsigned long codec_mm_buffer[MAX_MM_BUFFER_NUM];
 	int manual_write;
+	int failed_onmore;
 	wait_queue_head_t wq;
 	ssize_t (*write)(struct file *,
 		struct stream_buf_s *,
@@ -202,10 +208,12 @@ static int do_write_work_in(struct threadrw_write_task *task)
 		return 0;
 	if (!kfifo_peek(&task->datafifo, (void *)&rwbuf))
 		return 0;
-	if (task->codec_mm_buffer && !rwbuf->write_off)
+	if (!task->manual_write &&
+			rwbuf->from_cma &&
+			!rwbuf->write_off)
 		codec_mm_dma_flush(rwbuf->vbuffer,
-				rwbuf->data_size,
-				DMA_TO_DEVICE);
+						rwbuf->buffer_size,
+						DMA_TO_DEVICE);
 	if (task->manual_write) {
 		ret = task->write(task->file, task->sbuf,
 			(const char __user *)rwbuf->vbuffer + rwbuf->write_off,
@@ -255,42 +263,75 @@ static void do_write_work(struct work_struct *work)
 	struct threadrw_write_task *task = container_of(work,
 					struct threadrw_write_task,
 					write_work.work);
+	int need_retry = 1;
 	task->writework_on = 1;
-	while (do_write_work_in(task))
-		;
+	while (need_retry) {
+		mutex_lock(&task->mutex);
+		need_retry = do_write_work_in(task);
+		mutex_unlock(&task->mutex);
+	}
 	threadrw_schedule_delayed_work(task, HZ / 10);
 	task->writework_on = 0;
 	return;
 }
 
-static int init_task_buffers(struct threadrw_write_task *task, int num,
-							 int block_size)
+static int alloc_task_buffers_inlock(struct threadrw_write_task *task,
+		int new_bubffers,
+		int block_size)
 {
 	struct threadrw_buf *rwbuf;
 	int i;
-	int used_codec_mm = 1;
-	int buffers_num = num;
-	if (used_codec_mm && (block_size * buffers_num) >= 128 * 1024) {
-		int total_mm = ALIGN(block_size * buffers_num, (1 << 17));
-		task->codec_mm_buffer = codec_mm_alloc_for_dma(BUF_NAME,
+	int used_codec_mm = task->manual_write ? 0 : 1;
+	int new_num = new_bubffers;
+	int mm_slot = -1;
+	int start_idx = task->bufs_num;
+	int total_mm = 0;
+	unsigned long addr;
+
+	if (codec_mm_get_total_size() < 80 ||
+		codec_mm_get_free_size() < 40)
+		used_codec_mm = 0;
+	if (task->bufs_num + new_num > task->max_bufs)
+		new_num = task->max_bufs - task->bufs_num;
+	for (i = 0; i < MAX_MM_BUFFER_NUM; i++) {
+		if (task->codec_mm_buffer[i] == 0) {
+			mm_slot = i;
+			break;
+		}
+	}
+	if (mm_slot < 0)
+		used_codec_mm = 0;
+	if (block_size <= 0)
+		block_size = DEFAULT_BLOCK_SIZE;
+
+	if (used_codec_mm && (block_size * new_num) >= 128 * 1024) {
+		total_mm = ALIGN(block_size * new_num, (1 << 17));
+		addr =
+				codec_mm_alloc_for_dma(BUF_NAME,
 					total_mm / PAGE_SIZE, 0,
 					CODEC_MM_FLAGS_DMA_CPU);
-		task->buffer_size = total_mm;
-		buffers_num = total_mm / block_size;
+		if (addr != 0) {
+			task->codec_mm_buffer[mm_slot] = addr;
+			task->buffer_size += total_mm;
+		} else {
+			used_codec_mm = 0;
+		}
 	}
-	for (i = 0; i < buffers_num; i++) {
-		rwbuf = &task->buf[i];
-		rwbuf->buffer_size = block_size > 0 ?
-					block_size : DEFAULT_BLOCK_SIZE;
-		if (task->codec_mm_buffer) {
-			rwbuf->buffer_size = block_size;
-			if (i == buffers_num - 1)
-				rwbuf->buffer_size = task->buffer_size -
+	for (i = 0; i < new_num; i++) {
+		int bufidx = start_idx + i;
+		rwbuf = &task->buf[bufidx];
+		rwbuf->buffer_size = block_size;
+		if (used_codec_mm) {
+			unsigned long start_addr =
+					task->codec_mm_buffer[mm_slot];
+			if (i == new_num - 1)
+				rwbuf->buffer_size = total_mm -
 						block_size * i;
-			rwbuf->dma_handle = (dma_addr_t) task->codec_mm_buffer +
+			rwbuf->dma_handle = (dma_addr_t) start_addr +
 						block_size * i;
 			rwbuf->vbuffer = codec_mm_phys_to_virt(
 						rwbuf->dma_handle);
+			rwbuf->from_cma = 1;
 
 		} else {
 			rwbuf->vbuffer = dma_alloc_coherent(
@@ -300,18 +341,24 @@ static int init_task_buffers(struct threadrw_write_task *task, int num,
 			if (!rwbuf->vbuffer) {
 				rwbuf->buffer_size = 0;
 				rwbuf->dma_handle = 0;
-				task->max_buf = i + 1;
+				task->bufs_num = bufidx;
 				break;
 			}
+			rwbuf->from_cma = 0;
 			task->buffer_size += rwbuf->buffer_size;
 		}
 
 		kfifo_put(&task->freefifo, (const void *)rwbuf);
-		task->max_buf = i + 1;
+		task->bufs_num = bufidx + 1;
 	}
-	if (task->max_buf >= 3 || task->max_buf == num)
+	if (start_idx > 0 ||/*have buffers before*/
+		task->bufs_num >= 3 ||
+		task->bufs_num == new_num) {
+		if (!task->def_block_size)
+			task->def_block_size = task->buf[0].buffer_size;
 		return 0;	/*must >=3 for swap buffers. */
-	if (task->max_buf > 0)
+	}
+	if (task->bufs_num > 0)
 		free_task_buffers(task);
 	return -1;
 }
@@ -319,50 +366,61 @@ static int init_task_buffers(struct threadrw_write_task *task, int num,
 static int free_task_buffers(struct threadrw_write_task *task)
 {
 	int i;
-	if (task->codec_mm_buffer)
-		codec_mm_free_for_dma(BUF_NAME, task->codec_mm_buffer);
-	else {
-		for (i = 0; i < task->max_buf; i++) {
-			if (task->buf[i].vbuffer)
-				dma_free_coherent(amports_get_dma_device(),
-					task->buf[i].buffer_size,
-					task->buf[i].vbuffer,
-					task->buf[i].dma_handle);
-		}
+	for (i = 0; i < MAX_MM_BUFFER_NUM; i++) {
+		if (task->codec_mm_buffer[i])
+			codec_mm_free_for_dma(BUF_NAME,
+				task->codec_mm_buffer[i]);
+	}
+	for (i = 0; i < task->bufs_num; i++) {
+		if (task->buf[i].vbuffer && task->buf[i].from_cma == 0)
+			dma_free_coherent(amports_get_dma_device(),
+				task->buf[i].buffer_size,
+				task->buf[i].vbuffer,
+				task->buf[i].dma_handle);
 	}
 	return 0;
 }
 
-static struct threadrw_write_task *threadrw_buf_alloc_in(int num,
+static struct threadrw_write_task *threadrw_alloc_in(int num,
 		int block_size,
 		ssize_t (*write)(struct file *,
 			struct stream_buf_s *,
 			const char __user *, size_t, int),
 			int flags)
 {
-	int task_buffer_size = sizeof(struct threadrw_write_task) +
-				sizeof(struct threadrw_buf) * (num - 1) + 4;
-	struct threadrw_write_task *task = vmalloc(task_buffer_size);
+	int max_bufs = num;
+	int task_buffer_size;
+	struct threadrw_write_task *task;
 	int ret;
 
+	if (!(flags & 1)) /*not audio*/
+		max_bufs = 300; /*can great for video bufs.*/
+	task_buffer_size = sizeof(struct threadrw_write_task) +
+				sizeof(struct threadrw_buf) * max_bufs;
+	task = vmalloc(task_buffer_size);
+
 	if (!task)
 		return NULL;
 	memset(task, 0, task_buffer_size);
 
 	spin_lock_init(&task->lock);
+	mutex_init(&task->mutex);
 	INIT_DELAYED_WORK(&task->write_work, do_write_work);
 	init_waitqueue_head(&task->wq);
-	ret = kfifo_alloc(&task->datafifo, num, GFP_KERNEL);
+	ret = kfifo_alloc(&task->datafifo, max_bufs, GFP_KERNEL);
 	if (ret)
 		goto err1;
-	ret = kfifo_alloc(&task->freefifo, num, GFP_KERNEL);
+	ret = kfifo_alloc(&task->freefifo, max_bufs, GFP_KERNEL);
 	if (ret)
 		goto err2;
 	task->write = write;
 	task->file = NULL;
 	task->buffer_size = 0;
 	task->manual_write = flags & 1;
-	ret = init_task_buffers(task, num, block_size);
+	task->max_bufs = max_bufs;
+	mutex_lock(&task->mutex);
+	ret = alloc_task_buffers_inlock(task, num, block_size);
+	mutex_unlock(&task->mutex);
 	if (ret < 0)
 		goto err3;
 	threadrw_wq_get();	/*start thread. */
@@ -413,6 +471,15 @@ int threadrw_freefifo_len(struct stream_buf_s *stbuf)
 		return kfifo_len(&task->freefifo);
 	return 0;
 }
+int threadrw_support_more_buffers(struct stream_buf_s *stbuf)
+{
+	struct threadrw_write_task *task = stbuf->write_thread;
+	if (!task)
+		return 0;
+	if (task->failed_onmore)
+		return 0;
+	return task->max_bufs - task->bufs_num;
+}
 
 /*
 data len out fifo;
@@ -442,11 +509,15 @@ ssize_t threadrw_write(struct file *file, struct stream_buf_s *stbuf,
 					   const char __user *buf, size_t count)
 {
 	struct threadrw_write_task *task = stbuf->write_thread;
+	ssize_t size;
 	if (!task->file) {
 		task->file = file;
 		task->sbuf = stbuf;
 	}
-	return threadrw_write_in(task, stbuf, buf, count);
+	mutex_lock(&task->mutex);
+	size = threadrw_write_in(task, stbuf, buf, count);
+	mutex_unlock(&task->mutex);
+	return size;
 }
 
 int threadrw_flush_buffers(struct stream_buf_s *stbuf)
@@ -463,6 +534,39 @@ int threadrw_flush_buffers(struct stream_buf_s *stbuf)
 		return -1;/*data not flushed*/
 	return 0;
 }
+int threadrw_alloc_more_buffer_size(
+	struct stream_buf_s *stbuf,
+	int size)
+{
+	struct threadrw_write_task *task = stbuf->write_thread;
+	int block_size;
+	int new_num;
+	int ret = -1;
+	int old_num;
+
+	if (!task)
+		return -1;
+	mutex_lock(&task->mutex);
+	block_size = task->def_block_size;
+	if (block_size == 0)
+		block_size = 32 * 1024;
+	new_num = size / block_size;
+	old_num = task->bufs_num;
+	if (new_num == 0)
+		new_num = 1;
+	else if (new_num > task->max_bufs - task->bufs_num)
+		new_num = task->max_bufs - task->bufs_num;
+	if (new_num != 0)
+		ret = alloc_task_buffers_inlock(task, new_num,
+			block_size);
+	mutex_unlock(&task->mutex);
+	pr_info("threadrw add more buffer from %d -> %d for size %d\n",
+		old_num, task->bufs_num,
+		size);
+	if (ret < 0 || old_num == task->bufs_num)
+		task->failed_onmore = 1;
+	return ret;
+}
 
 void *threadrw_alloc(int num,
 		int block_size,
@@ -472,7 +576,7 @@ void *threadrw_alloc(int num,
 				size_t, int),
 				int flags)
 {
-	return threadrw_buf_alloc_in(num, block_size, write, flags);
+	return threadrw_alloc_in(num, block_size, write, flags);
 }
 
 void threadrw_release(struct stream_buf_s *stbuf)
@@ -481,7 +585,9 @@ void threadrw_release(struct stream_buf_s *stbuf)
 	if (task) {
 		wake_up_interruptible(&task->wq);
 		cancel_delayed_work_sync(&task->write_work);
+		mutex_lock(&task->mutex);
 		free_task_buffers(task);
+		mutex_unlock(&task->mutex);
 		kfifo_free(&task->freefifo);
 		kfifo_free(&task->datafifo);
 		vfree(task);
diff --git a/drivers/amlogic/amports/thread_rw.h b/drivers/amlogic/amports/thread_rw.h
index df7d4f3..04d0ad3 100644
--- a/drivers/amlogic/amports/thread_rw.h
+++ b/drivers/amlogic/amports/thread_rw.h
@@ -27,5 +27,9 @@ int threadrw_freefifo_len(struct stream_buf_s *stbuf);
 int threadrw_passed_len(struct stream_buf_s *stbuf);
 int threadrw_flush_buffers(struct stream_buf_s *stbuf);
 int threadrw_dataoffset(struct stream_buf_s *stbuf);
+int threadrw_alloc_more_buffer_size(
+	struct stream_buf_s *stbuf,
+	int size);
+int threadrw_support_more_buffers(struct stream_buf_s *stbuf);
 
 #endif
diff --git a/drivers/amlogic/amports/tsdemux.c b/drivers/amlogic/amports/tsdemux.c
index f52590b..c88b028 100644
--- a/drivers/amlogic/amports/tsdemux.c
+++ b/drivers/amlogic/amports/tsdemux.c
@@ -36,6 +36,7 @@
 /* #include <mach/mod_gate.h> */
 /* #endif */
 
+#include "vdec.h"
 #include "vdec_reg.h"
 #include "streambuf_reg.h"
 #include "streambuf.h"
@@ -63,12 +64,18 @@ static u8 pcrscr_valid;
 
 static int demux_skipbyte;
 
-#ifdef ENABLE_DEMUX_DRIVER
 static struct tsdemux_ops *demux_ops;
-static irq_handler_t demux_handler;
-static void *demux_data;
 static DEFINE_SPINLOCK(demux_ops_lock);
 
+static int enable_demux_driver(void)
+{
+#ifdef ENABLE_DEMUX_DRIVER
+	return demux_ops ? 1 : 0;
+#else
+	return 0;
+#endif
+}
+
 void tsdemux_set_ops(struct tsdemux_ops *ops)
 {
 	unsigned long flags;
@@ -81,14 +88,10 @@ EXPORT_SYMBOL(tsdemux_set_ops);
 
 int tsdemux_set_reset_flag_ext(void)
 {
-	int r;
+	int r = 0;
 
 	if (demux_ops && demux_ops->set_reset_flag)
 		r = demux_ops->set_reset_flag();
-	else {
-		WRITE_MPEG_REG(FEC_INPUT_CONTROL, 0);
-		r = 0;
-	}
 
 	return r;
 }
@@ -114,28 +117,12 @@ static int tsdemux_reset(void)
 	if (demux_ops && demux_ops->reset) {
 		tsdemux_set_reset_flag_ext();
 		r = demux_ops->reset();
-	} else {
-		WRITE_MPEG_REG(RESET1_REGISTER, RESET_DEMUXSTB);
-		WRITE_MPEG_REG(STB_TOP_CONFIG, 0);
-		WRITE_MPEG_REG(DEMUX_CONTROL, 0);
-		r = 0;
 	}
 	spin_unlock_irqrestore(&demux_ops_lock, flags);
 
 	return r;
 }
 
-static irqreturn_t tsdemux_default_isr_handler(int irq, void *dev_id)
-{
-	u32 int_status = READ_MPEG_REG(STB_INT_STATUS);
-
-	if (demux_handler)
-		demux_handler(irq, (void *)0);
-
-	WRITE_MPEG_REG(STB_INT_STATUS, int_status);
-	return IRQ_HANDLED;
-}
-
 static int tsdemux_request_irq(irq_handler_t handler, void *data)
 {
 	unsigned long flags;
@@ -144,19 +131,6 @@ static int tsdemux_request_irq(irq_handler_t handler, void *data)
 	spin_lock_irqsave(&demux_ops_lock, flags);
 	if (demux_ops && demux_ops->request_irq)
 		r = demux_ops->request_irq(handler, data);
-	else {
-		demux_handler = handler;
-		demux_data = data;
-		/*TODO irq */
-
-		r = vdec_request_irq(DEMUX_IRQ, tsdemux_default_isr_handler,
-						"tsdemux-irq",
-						(void *)tsdemux_irq_id);
-
-		WRITE_MPEG_REG(STB_INT_MASK, (1 << SUB_PES_READY)
-					   | (1 << NEW_PDTS_READY)
-					   | (1 << DIS_CONTINUITY_PACKET));
-	}
 	spin_unlock_irqrestore(&demux_ops_lock, flags);
 
 	return r;
@@ -170,14 +144,6 @@ static int tsdemux_free_irq(void)
 	spin_lock_irqsave(&demux_ops_lock, flags);
 	if (demux_ops && demux_ops->free_irq)
 		r = demux_ops->free_irq();
-	else {
-		WRITE_MPEG_REG(STB_INT_MASK, 0);
-		/*TODO irq */
-
-		vdec_free_irq(DEMUX_IRQ, (void *)tsdemux_irq_id);
-
-		r = 0;
-	}
 	spin_unlock_irqrestore(&demux_ops_lock, flags);
 
 	return r;
@@ -191,17 +157,6 @@ static int tsdemux_set_vid(int vpid)
 	spin_lock_irqsave(&demux_ops_lock, flags);
 	if (demux_ops && demux_ops->set_vid)
 		r = demux_ops->set_vid(vpid);
-	else if ((vpid >= 0) && (vpid < 0x1FFF)) {
-		u32 data = READ_MPEG_REG(FM_WR_DATA);
-		WRITE_MPEG_REG(FM_WR_DATA,
-				(((vpid & 0x1fff) | (VIDEO_PACKET << 13)) << 16)
-				| (data & 0xffff));
-		WRITE_MPEG_REG(FM_WR_ADDR, 0x8000);
-		while (READ_MPEG_REG(FM_WR_ADDR) & 0x8000)
-			;
-		WRITE_MPEG_REG(MAX_FM_COMP_ADDR, 1);
-		r = 0;
-	}
 	spin_unlock_irqrestore(&demux_ops_lock, flags);
 
 	return r;
@@ -215,17 +170,6 @@ static int tsdemux_set_aid(int apid)
 	spin_lock_irqsave(&demux_ops_lock, flags);
 	if (demux_ops && demux_ops->set_aid)
 		r = demux_ops->set_aid(apid);
-	else if ((apid >= 0) && (apid < 0x1FFF)) {
-		u32 data = READ_MPEG_REG(FM_WR_DATA);
-		WRITE_MPEG_REG(FM_WR_DATA,
-				((apid & 0x1fff) | (AUDIO_PACKET << 13)) |
-				(data & 0xffff0000));
-		WRITE_MPEG_REG(FM_WR_ADDR, 0x8000);
-		while (READ_MPEG_REG(FM_WR_ADDR) & 0x8000)
-			;
-		WRITE_MPEG_REG(MAX_FM_COMP_ADDR, 1);
-		r = 0;
-	}
 	spin_unlock_irqrestore(&demux_ops_lock, flags);
 
 	return r;
@@ -239,16 +183,6 @@ static int tsdemux_set_sid(int spid)
 	spin_lock_irqsave(&demux_ops_lock, flags);
 	if (demux_ops && demux_ops->set_sid)
 		r = demux_ops->set_sid(spid);
-	else if ((spid >= 0) && (spid < 0x1FFF)) {
-		WRITE_MPEG_REG(FM_WR_DATA,
-				(((spid & 0x1fff) | (SUB_PACKET << 13)) << 16) |
-				0xffff);
-		WRITE_MPEG_REG(FM_WR_ADDR, 0x8001);
-		while (READ_MPEG_REG(FM_WR_ADDR) & 0x8000)
-			;
-		WRITE_MPEG_REG(MAX_FM_COMP_ADDR, 1);
-		r = 0;
-	}
 	spin_unlock_irqrestore(&demux_ops_lock, flags);
 
 	return r;
@@ -275,8 +209,6 @@ static int tsdemux_set_skip_byte(int skipbyte)
 	spin_lock_irqsave(&demux_ops_lock, flags);
 	if (demux_ops && demux_ops->set_skipbyte)
 		r = demux_ops->set_skipbyte(skipbyte);
-	else
-		demux_skipbyte = skipbyte;
 	spin_unlock_irqrestore(&demux_ops_lock, flags);
 
 	return r;
@@ -284,94 +216,68 @@ static int tsdemux_set_skip_byte(int skipbyte)
 
 static int tsdemux_config(void)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&demux_ops_lock, flags);
-
-	if (!demux_ops) {
-		WRITE_MPEG_REG(STB_INT_MASK, 0);
-		WRITE_MPEG_REG(STB_INT_STATUS, 0xffff);
-
-		/* TS data path */
-		WRITE_MPEG_REG(FEC_INPUT_CONTROL, 0x7000);
-		WRITE_MPEG_REG(DEMUX_MEM_REQ_EN,
-				(1 << VIDEO_PACKET) |
-				(1 << AUDIO_PACKET) | (1 << SUB_PACKET));
-		WRITE_MPEG_REG(DEMUX_ENDIAN,
-				(7 << OTHER_ENDIAN) |
-				(7 << BYPASS_ENDIAN) | (0 << SECTION_ENDIAN));
-		WRITE_MPEG_REG(TS_HIU_CTL, 1 << USE_HI_BSF_INTERFACE);
-		WRITE_MPEG_REG(TS_FILE_CONFIG,
-				(demux_skipbyte << 16) |
-				(6 << DES_OUT_DLY) |
-				(3 << TRANSPORT_SCRAMBLING_CONTROL_ODD) |
-				(1 << TS_HIU_ENABLE) | (4 << FEC_FILE_CLK_DIV));
-
-		/* enable TS demux */
-		WRITE_MPEG_REG(DEMUX_CONTROL, (1 << STB_DEMUX_ENABLE));
-	}
-
-	spin_unlock_irqrestore(&demux_ops_lock, flags);
 	return 0;
 }
-#endif				/*ENABLE_DEMUX_DRIVER */
 
 /*TODO irq*/
 static irqreturn_t tsdemux_isr(int irq, void *dev_id)
 {
-#ifndef ENABLE_DEMUX_DRIVER
-	u32 int_status = READ_MPEG_REG(STB_INT_STATUS);
-#else
 	u32 int_status = 0;
-
 	int id = (long)dev_id;
-	if (id == 0)
+
+	if (!enable_demux_driver()) {
 		int_status = READ_MPEG_REG(STB_INT_STATUS);
-	else if (id == 1)
-		int_status = READ_MPEG_REG(STB_INT_STATUS_2);
-	else if (id == 2)
-		int_status = READ_MPEG_REG(STB_INT_STATUS_3);
-#endif
+	} else {
+		if (id == 0)
+			int_status = READ_MPEG_REG(STB_INT_STATUS);
+		else if (id == 1)
+			int_status = READ_MPEG_REG(STB_INT_STATUS_2);
+		else if (id == 2)
+			int_status = READ_MPEG_REG(STB_INT_STATUS_3);
+	}
 
 	if (int_status & (1 << NEW_PDTS_READY)) {
-#ifndef ENABLE_DEMUX_DRIVER
-		u32 pdts_status = READ_MPEG_REG(STB_PTS_DTS_STATUS);
+		if (!enable_demux_driver()) {
+			u32 pdts_status = READ_MPEG_REG(STB_PTS_DTS_STATUS);
 
-		if (pdts_status & (1 << VIDEO_PTS_READY))
-			pts_checkin_wrptr(PTS_TYPE_VIDEO,
+			if (pdts_status & (1 << VIDEO_PTS_READY))
+				pts_checkin_wrptr(PTS_TYPE_VIDEO,
 					READ_MPEG_REG(VIDEO_PDTS_WR_PTR),
 					READ_MPEG_REG(VIDEO_PTS_DEMUX));
 
-		if (pdts_status & (1 << AUDIO_PTS_READY))
-			pts_checkin_wrptr(PTS_TYPE_AUDIO,
+			if (pdts_status & (1 << AUDIO_PTS_READY))
+				pts_checkin_wrptr(PTS_TYPE_AUDIO,
 					READ_MPEG_REG(AUDIO_PDTS_WR_PTR),
 					READ_MPEG_REG(AUDIO_PTS_DEMUX));
 
-		WRITE_MPEG_REG(STB_PTS_DTS_STATUS, pdts_status);
-#else
+			WRITE_MPEG_REG(STB_PTS_DTS_STATUS, pdts_status);
+		} else {
 #define DMX_READ_REG(i, r)\
 	((i) ? ((i == 1) ? READ_MPEG_REG(r##_2) : \
 		READ_MPEG_REG(r##_3)) : READ_MPEG_REG(r))
 
-		u32 pdts_status = DMX_READ_REG(id, STB_PTS_DTS_STATUS);
+			u32 pdts_status = DMX_READ_REG(id, STB_PTS_DTS_STATUS);
 
-		if (pdts_status & (1 << VIDEO_PTS_READY))
-			pts_checkin_wrptr(PTS_TYPE_VIDEO,
+			if (pdts_status & (1 << VIDEO_PTS_READY))
+				pts_checkin_wrptr(PTS_TYPE_VIDEO,
 					DMX_READ_REG(id, VIDEO_PDTS_WR_PTR),
 					DMX_READ_REG(id, VIDEO_PTS_DEMUX));
 
-		if (pdts_status & (1 << AUDIO_PTS_READY))
-			pts_checkin_wrptr(PTS_TYPE_AUDIO,
+			if (pdts_status & (1 << AUDIO_PTS_READY))
+				pts_checkin_wrptr(PTS_TYPE_AUDIO,
 					DMX_READ_REG(id, AUDIO_PDTS_WR_PTR),
 					DMX_READ_REG(id, AUDIO_PTS_DEMUX));
 
-		if (id == 1)
-			WRITE_MPEG_REG(STB_PTS_DTS_STATUS_2, pdts_status);
-		else if (id == 2)
-			WRITE_MPEG_REG(STB_PTS_DTS_STATUS_3, pdts_status);
-		else
-			WRITE_MPEG_REG(STB_PTS_DTS_STATUS, pdts_status);
-#endif
+			if (id == 1)
+				WRITE_MPEG_REG(STB_PTS_DTS_STATUS_2,
+							pdts_status);
+			else if (id == 2)
+				WRITE_MPEG_REG(STB_PTS_DTS_STATUS_3,
+							pdts_status);
+			else
+				WRITE_MPEG_REG(STB_PTS_DTS_STATUS,
+							pdts_status);
+		}
 	}
 	if (int_status & (1 << DIS_CONTINUITY_PACKET)) {
 		discontinued_counter++;
@@ -382,9 +288,10 @@ static irqreturn_t tsdemux_isr(int irq, void *dev_id)
 		/* pr_info("subtitle pes ready\n"); */
 		wakeup_sub_poll();
 	}
-#ifndef ENABLE_DEMUX_DRIVER
-	WRITE_MPEG_REG(STB_INT_STATUS, int_status);
-#endif
+
+	if (!enable_demux_driver())
+		WRITE_MPEG_REG(STB_INT_STATUS, int_status);
+
 	return IRQ_HANDLED;
 }
 
@@ -522,7 +429,8 @@ static int reset_pcr_regs(void)
 	return 1;
 }
 
-s32 tsdemux_init(u32 vid, u32 aid, u32 sid, u32 pcrid, bool is_hevc)
+s32 tsdemux_init(u32 vid, u32 aid, u32 sid, u32 pcrid, bool is_hevc,
+		struct vdec_s *vdec)
 {
 	s32 r;
 	u32 parser_sub_start_ptr;
@@ -544,14 +452,14 @@ s32 tsdemux_init(u32 vid, u32 aid, u32 sid, u32 pcrid, bool is_hevc)
 
 	WRITE_MPEG_REG(RESET1_REGISTER, RESET_PARSER);
 
-#ifdef ENABLE_DEMUX_DRIVER
-	tsdemux_reset();
-#else
-	WRITE_MPEG_REG(RESET1_REGISTER, RESET_PARSER | RESET_DEMUXSTB);
+	if (enable_demux_driver()) {
+		tsdemux_reset();
+	} else {
+		WRITE_MPEG_REG(RESET1_REGISTER, RESET_PARSER | RESET_DEMUXSTB);
 
-	WRITE_MPEG_REG(STB_TOP_CONFIG, 0);
-	WRITE_MPEG_REG(DEMUX_CONTROL, 0);
-#endif
+		WRITE_MPEG_REG(STB_TOP_CONFIG, 0);
+		WRITE_MPEG_REG(DEMUX_CONTROL, 0);
+	}
 
 	/* set PID filter */
 	pr_info
@@ -561,45 +469,52 @@ s32 tsdemux_init(u32 vid, u32 aid, u32 sid, u32 pcrid, bool is_hevc)
 		("sub_pid = 0x%x, pcrid = 0x%x\n",
 		 sid, pcrid);
 
-#ifndef ENABLE_DEMUX_DRIVER
-	WRITE_MPEG_REG(FM_WR_DATA,
-			(((vid & 0x1fff) | (VIDEO_PACKET << 13)) << 16) |
-			((aid & 0x1fff) | (AUDIO_PACKET << 13)));
-	WRITE_MPEG_REG(FM_WR_ADDR, 0x8000);
-	while (READ_MPEG_REG(FM_WR_ADDR) & 0x8000)
-		;
-
-	WRITE_MPEG_REG(FM_WR_DATA,
-			(((sid & 0x1fff) | (SUB_PACKET << 13)) << 16) | 0xffff);
-	WRITE_MPEG_REG(FM_WR_ADDR, 0x8001);
-	while (READ_MPEG_REG(FM_WR_ADDR) & 0x8000)
-		;
-
-	WRITE_MPEG_REG(MAX_FM_COMP_ADDR, 1);
-
-	WRITE_MPEG_REG(STB_INT_MASK, 0);
-	WRITE_MPEG_REG(STB_INT_STATUS, 0xffff);
-
-	/* TS data path */
-	WRITE_MPEG_REG(FEC_INPUT_CONTROL, 0x7000);
-	WRITE_MPEG_REG(DEMUX_MEM_REQ_EN,
-			(1 << VIDEO_PACKET) |
-			(1 << AUDIO_PACKET) | (1 << SUB_PACKET));
-	WRITE_MPEG_REG(DEMUX_ENDIAN,
-			(7 << OTHER_ENDIAN) |
-			(7 << BYPASS_ENDIAN) | (0 << SECTION_ENDIAN));
-	WRITE_MPEG_REG(TS_HIU_CTL, 1 << USE_HI_BSF_INTERFACE);
-	WRITE_MPEG_REG(TS_FILE_CONFIG,
-			(demux_skipbyte << 16) |
-			(6 << DES_OUT_DLY) |
-			(3 << TRANSPORT_SCRAMBLING_CONTROL_ODD) |
-			(1 << TS_HIU_ENABLE) | (4 << FEC_FILE_CLK_DIV));
-
-	/* enable TS demux */
-	WRITE_MPEG_REG(DEMUX_CONTROL,
-			(1 << STB_DEMUX_ENABLE) |
-			(1 << KEEP_DUPLICATE_PACKAGE));
-#endif
+	if (!enable_demux_driver()) {
+		WRITE_MPEG_REG(FM_WR_DATA,
+				(((vid < 0x1fff)
+					? (vid & 0x1fff) | (VIDEO_PACKET << 13)
+					: 0xffff) << 16)
+				| ((aid < 0x1fff)
+					? (aid & 0x1fff) | (AUDIO_PACKET << 13)
+					: 0xffff));
+		WRITE_MPEG_REG(FM_WR_ADDR, 0x8000);
+		while (READ_MPEG_REG(FM_WR_ADDR) & 0x8000)
+			;
+
+		WRITE_MPEG_REG(FM_WR_DATA,
+				(((sid < 0x1fff)
+					? (sid & 0x1fff) | (SUB_PACKET << 13)
+					: 0xffff) << 16)
+				| 0xffff);
+		WRITE_MPEG_REG(FM_WR_ADDR, 0x8001);
+		while (READ_MPEG_REG(FM_WR_ADDR) & 0x8000)
+			;
+
+		WRITE_MPEG_REG(MAX_FM_COMP_ADDR, 1);
+
+		WRITE_MPEG_REG(STB_INT_MASK, 0);
+		WRITE_MPEG_REG(STB_INT_STATUS, 0xffff);
+
+		/* TS data path */
+		WRITE_MPEG_REG(FEC_INPUT_CONTROL, 0x7000);
+		WRITE_MPEG_REG(DEMUX_MEM_REQ_EN,
+				(1 << VIDEO_PACKET) |
+				(1 << AUDIO_PACKET) | (1 << SUB_PACKET));
+		WRITE_MPEG_REG(DEMUX_ENDIAN,
+				(7 << OTHER_ENDIAN) |
+				(7 << BYPASS_ENDIAN) | (0 << SECTION_ENDIAN));
+		WRITE_MPEG_REG(TS_HIU_CTL, 1 << USE_HI_BSF_INTERFACE);
+		WRITE_MPEG_REG(TS_FILE_CONFIG,
+				(demux_skipbyte << 16) |
+				(6 << DES_OUT_DLY) |
+				(3 << TRANSPORT_SCRAMBLING_CONTROL_ODD) |
+				(1 << TS_HIU_ENABLE) | (4 << FEC_FILE_CLK_DIV));
+
+		/* enable TS demux */
+		WRITE_MPEG_REG(DEMUX_CONTROL,
+				(1 << STB_DEMUX_ENABLE) |
+				(1 << KEEP_DUPLICATE_PACKAGE));
+	}
 
 	if (fetchbuf == 0) {
 		pr_info("%s: no fetchbuf\n", __func__);
@@ -607,38 +522,51 @@ s32 tsdemux_init(u32 vid, u32 aid, u32 sid, u32 pcrid, bool is_hevc)
 	}
 
 	/* hook stream buffer with PARSER */
-	/* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
 	if (has_hevc_vdec() && is_hevc) {
-		WRITE_MPEG_REG(PARSER_VIDEO_START_PTR,
-					   READ_VREG(HEVC_STREAM_START_ADDR));
-		WRITE_MPEG_REG(PARSER_VIDEO_END_PTR,
-					   READ_VREG(HEVC_STREAM_END_ADDR) - 8);
-
-		CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
-		/* set vififo_vbuf_rp_sel=>hevc */
-		WRITE_VREG(DOS_GEN_CTRL0, 3 << 1);
-		/* set use_parser_vbuf_wp */
-		SET_VREG_MASK(HEVC_STREAM_CONTROL,
-					  (1 << 3) | (0 << 4));
-		/* set stream_fetch_enable */
-		SET_VREG_MASK(HEVC_STREAM_CONTROL, 1);
-		/* set stream_buffer_hole with 256 bytes */
-		SET_VREG_MASK(HEVC_STREAM_FIFO_CTL,
-					  (1 << 29));
-	} else
-		/* #endif */
-	{
-		WRITE_MPEG_REG(PARSER_VIDEO_START_PTR,
-					   READ_VREG(VLD_MEM_VIFIFO_START_PTR));
-		WRITE_MPEG_REG(PARSER_VIDEO_END_PTR,
-					   READ_VREG(VLD_MEM_VIFIFO_END_PTR));
-		CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
-
-		WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
-		CLEAR_VREG_MASK(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
-		/* set vififo_vbuf_rp_sel=>vdec */
-		if (has_hevc_vdec())
-			WRITE_VREG(DOS_GEN_CTRL0, 0);
+		WRITE_MPEG_REG(PARSER_VIDEO_START_PTR, vdec->input.start);
+		WRITE_MPEG_REG(PARSER_VIDEO_END_PTR, vdec->input.start +
+			vdec->input.size - 8);
+
+		if (vdec_single(vdec)) {
+			CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL,
+					ES_VID_MAN_RD_PTR);
+			/* set vififo_vbuf_rp_sel=>hevc */
+			WRITE_VREG(DOS_GEN_CTRL0, 3 << 1);
+
+			/* set use_parser_vbuf_wp */
+			SET_VREG_MASK(HEVC_STREAM_CONTROL,
+				  (1 << 3) | (0 << 4));
+			/* set stream_fetch_enable */
+			SET_VREG_MASK(HEVC_STREAM_CONTROL, 1);
+			/* set stream_buffer_hole with 256 bytes */
+			SET_VREG_MASK(HEVC_STREAM_FIFO_CTL,
+				  (1 << 29));
+		} else {
+			SET_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
+			WRITE_MPEG_REG(PARSER_VIDEO_WP, vdec->input.start);
+			WRITE_MPEG_REG(PARSER_VIDEO_RP, vdec->input.start);
+		}
+	} else {
+		WRITE_MPEG_REG(PARSER_VIDEO_START_PTR, vdec->input.start);
+		WRITE_MPEG_REG(PARSER_VIDEO_END_PTR, vdec->input.start +
+			vdec->input.size - 8);
+
+		if (vdec_single(vdec)) {
+			CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL,
+					ES_VID_MAN_RD_PTR);
+
+			WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+			CLEAR_VREG_MASK(VLD_MEM_VIFIFO_BUF_CNTL,
+				MEM_BUFCTRL_INIT);
+
+			/* set vififo_vbuf_rp_sel=>vdec */
+			if (has_hevc_vdec())
+				WRITE_VREG(DOS_GEN_CTRL0, 0);
+		} else {
+			SET_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
+			WRITE_MPEG_REG(PARSER_VIDEO_WP, vdec->input.start);
+			WRITE_MPEG_REG(PARSER_VIDEO_RP, vdec->input.start);
+		}
 	}
 
 	WRITE_MPEG_REG(PARSER_AUDIO_START_PTR,
@@ -693,51 +621,51 @@ s32 tsdemux_init(u32 vid, u32 aid, u32 sid, u32 pcrid, bool is_hevc)
 	WRITE_MPEG_REG(PARSER_AUDIO_HOLE, 0x400);
 
 	discontinued_counter = 0;
-#ifndef ENABLE_DEMUX_DRIVER
-	/*TODO irq */
 
-	r = vdec_request_irq(DEMUX_IRQ, tsdemux_isr,
-			"tsdemux-irq", (void *)tsdemux_irq_id);
+	if (!enable_demux_driver()) {
+		/*TODO irq */
 
-	WRITE_MPEG_REG(STB_INT_MASK, (1 << SUB_PES_READY)
-				   | (1 << NEW_PDTS_READY)
-				   | (1 << DIS_CONTINUITY_PACKET));
-	if (r)
-		goto err4;
-#else
-	tsdemux_config();
-	tsdemux_request_irq(tsdemux_isr, (void *)tsdemux_irq_id);
-	if (vid < 0x1FFF) {
-		curr_vid_id = vid;
-		tsdemux_set_vid(vid);
-	}
-	if (aid < 0x1FFF) {
-		curr_aud_id = aid;
-		tsdemux_set_aid(aid);
-	}
-	if (sid < 0x1FFF) {
-		curr_sub_id = sid;
-		tsdemux_set_sid(sid);
-	}
+		r = vdec_request_irq(DEMUX_IRQ, tsdemux_isr,
+				"tsdemux-irq", (void *)tsdemux_irq_id);
 
-	curr_pcr_id = pcrid;
-	if ((pcrid < 0x1FFF) && (pcrid != vid) && (pcrid != aid)
-		&& (pcrid != sid))
-		tsdemux_set_pcrid(pcrid);
-#endif
+		WRITE_MPEG_REG(STB_INT_MASK, (1 << SUB_PES_READY)
+					   | (1 << NEW_PDTS_READY)
+					   | (1 << DIS_CONTINUITY_PACKET));
+		if (r)
+			goto err4;
+	} else {
+		tsdemux_config();
+		tsdemux_request_irq(tsdemux_isr, (void *)tsdemux_irq_id);
+		if (vid < 0x1FFF) {
+			curr_vid_id = vid;
+			tsdemux_set_vid(vid);
+		}
+		if (aid < 0x1FFF) {
+			curr_aud_id = aid;
+			tsdemux_set_aid(aid);
+		}
+		if (sid < 0x1FFF) {
+			curr_sub_id = sid;
+			tsdemux_set_sid(sid);
+		}
+
+		curr_pcr_id = pcrid;
+		if ((pcrid < 0x1FFF) && (pcrid != vid) && (pcrid != aid)
+			&& (pcrid != sid))
+			tsdemux_set_pcrid(pcrid);
+	}
 
 	pcrscr_valid = reset_pcr_regs();
 	first_pcr = 0;
 
 	return 0;
 
-#ifndef ENABLE_DEMUX_DRIVER
 err4:
 	/*TODO irq */
 
-	vdec_free_irq(PARSER_IRQ, (void *)tsdemux_fetch_id);
+	if (!enable_demux_driver())
+		vdec_free_irq(PARSER_IRQ, (void *)tsdemux_fetch_id);
 
-#endif
 err3:
 	pts_stop(PTS_TYPE_AUDIO);
 err2:
@@ -760,35 +688,42 @@ void tsdemux_release(void)
 	WRITE_MPEG_REG(PARSER_INT_ENABLE, 0);
 	WRITE_MPEG_REG(PARSER_VIDEO_HOLE, 0);
 	WRITE_MPEG_REG(PARSER_AUDIO_HOLE, 0);
-	/*TODO irq */
 
-	vdec_free_irq(PARSER_IRQ, (void *)tsdemux_fetch_id);
+#ifdef CONFIG_MULTI_DEC
+	SET_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
+	WRITE_MPEG_REG(PARSER_VIDEO_WP, 0);
+	WRITE_MPEG_REG(PARSER_VIDEO_RP, 0);
+#endif
 
-#ifndef ENABLE_DEMUX_DRIVER
-	WRITE_MPEG_REG(STB_INT_MASK, 0);
 	/*TODO irq */
 
-	vdec_free_irq(DEMUX_IRQ, (void *)tsdemux_irq_id);
-
-#else
+	vdec_free_irq(PARSER_IRQ, (void *)tsdemux_fetch_id);
 
-	tsdemux_set_aid(0xffff);
-	tsdemux_set_vid(0xffff);
-	tsdemux_set_sid(0xffff);
-	tsdemux_set_pcrid(0xffff);
-	tsdemux_free_irq();
+	if (!enable_demux_driver()) {
+		WRITE_MPEG_REG(STB_INT_MASK, 0);
+		/*TODO irq */
 
-	curr_vid_id = 0xffff;
-	curr_aud_id = 0xffff;
-	curr_sub_id = 0xffff;
-	curr_pcr_id = 0xffff;
-	curr_pcr_num = 0xffff;
+		vdec_free_irq(DEMUX_IRQ, (void *)tsdemux_irq_id);
+	} else {
 
-#endif
+		tsdemux_set_aid(0xffff);
+		tsdemux_set_vid(0xffff);
+		tsdemux_set_sid(0xffff);
+		tsdemux_set_pcrid(0xffff);
+		tsdemux_free_irq();
+
+		curr_vid_id = 0xffff;
+		curr_aud_id = 0xffff;
+		curr_sub_id = 0xffff;
+		curr_pcr_id = 0xffff;
+		curr_pcr_num = 0xffff;
+	}
 
 	pts_stop(PTS_TYPE_VIDEO);
 	pts_stop(PTS_TYPE_AUDIO);
 
+	WRITE_MPEG_REG(RESET1_REGISTER, RESET_PARSER);
+
 	/* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
 	/*TODO clk */
 	/*
@@ -855,7 +790,8 @@ ssize_t drm_tswrite(struct file *file,
 	int isphybuf = 0;
 	unsigned long realbuf;
 
-	struct stream_port_s *port = (struct stream_port_s *)file->private_data;
+	struct port_priv_s *priv = (struct port_priv_s *)file->private_data;
+	struct stream_port_s *port = priv->port;
 	size_t wait_size, write_size;
 
 	if (buf == NULL || count == 0)
@@ -955,7 +891,8 @@ ssize_t tsdemux_write(struct file *file,
 					  const char __user *buf, size_t count)
 {
 	s32 r;
-	struct stream_port_s *port = (struct stream_port_s *)file->private_data;
+	struct port_priv_s *priv = (struct port_priv_s *)file->private_data;
+	struct stream_port_s *port = priv->port;
 	size_t wait_size, write_size;
 
 	if ((stbuf_space(vbuf) < count) || (stbuf_space(abuf) < count)) {
@@ -1035,40 +972,43 @@ void tsdemux_class_unregister(void)
 
 void tsdemux_change_avid(unsigned int vid, unsigned int aid)
 {
-#ifndef ENABLE_DEMUX_DRIVER
-	WRITE_MPEG_REG(FM_WR_DATA,
-			(((vid & 0x1fff) | (VIDEO_PACKET << 13)) << 16) |
-			((aid & 0x1fff) | (AUDIO_PACKET << 13)));
-	WRITE_MPEG_REG(FM_WR_ADDR, 0x8000);
-	while (READ_MPEG_REG(FM_WR_ADDR) & 0x8000)
-		;
-#else
-	curr_vid_id = vid;
-	curr_aud_id = aid;
+	if (!enable_demux_driver()) {
+		WRITE_MPEG_REG(FM_WR_DATA,
+				(((vid & 0x1fff) | (VIDEO_PACKET << 13)) << 16)
+				| ((aid & 0x1fff) | (AUDIO_PACKET << 13)));
+		WRITE_MPEG_REG(FM_WR_ADDR, 0x8000);
+		while (READ_MPEG_REG(FM_WR_ADDR) & 0x8000)
+			;
+	} else {
+		curr_vid_id = vid;
+		curr_aud_id = aid;
+
+		tsdemux_set_vid(vid);
+		tsdemux_set_aid(aid);
 
-	tsdemux_set_vid(vid);
-	tsdemux_set_aid(aid);
+		reset_pcr_regs();
+	}
 
-	reset_pcr_regs();
-#endif
 	return;
 }
 
 void tsdemux_change_sid(unsigned int sid)
 {
-#ifndef ENABLE_DEMUX_DRIVER
-	WRITE_MPEG_REG(FM_WR_DATA,
-			(((sid & 0x1fff) | (SUB_PACKET << 13)) << 16) | 0xffff);
-	WRITE_MPEG_REG(FM_WR_ADDR, 0x8001);
-	while (READ_MPEG_REG(FM_WR_ADDR) & 0x8000)
-		;
-#else
-	curr_sub_id = sid;
+	if (!enable_demux_driver()) {
+		WRITE_MPEG_REG(FM_WR_DATA,
+				(((sid & 0x1fff) | (SUB_PACKET << 13)) << 16)
+				| 0xffff);
+		WRITE_MPEG_REG(FM_WR_ADDR, 0x8001);
+		while (READ_MPEG_REG(FM_WR_ADDR) & 0x8000)
+			;
+	} else {
+		curr_sub_id = sid;
 
-	tsdemux_set_sid(sid);
+		tsdemux_set_sid(sid);
+
+		reset_pcr_regs();
+	}
 
-	reset_pcr_regs();
-#endif
 	return;
 }
 
@@ -1124,25 +1064,25 @@ void tsdemux_sub_reset(void)
 
 void tsdemux_set_skipbyte(int skipbyte)
 {
-#ifndef ENABLE_DEMUX_DRIVER
-	demux_skipbyte = skipbyte;
-#else
-	tsdemux_set_skip_byte(skipbyte);
-#endif
+	if (!enable_demux_driver())
+		demux_skipbyte = skipbyte;
+	else
+		tsdemux_set_skip_byte(skipbyte);
+
 	return;
 }
 
 void tsdemux_set_demux(int dev)
 {
-#ifdef ENABLE_DEMUX_DRIVER
-	unsigned long flags;
-	int r = 0;
-
-	spin_lock_irqsave(&demux_ops_lock, flags);
-	if (demux_ops && demux_ops->set_demux)
-		r = demux_ops->set_demux(dev);
-	spin_unlock_irqrestore(&demux_ops_lock, flags);
-#endif
+	if (enable_demux_driver()) {
+		unsigned long flags;
+		int r = 0;
+
+		spin_lock_irqsave(&demux_ops_lock, flags);
+		if (demux_ops && demux_ops->set_demux)
+			r = demux_ops->set_demux(dev);
+		spin_unlock_irqrestore(&demux_ops_lock, flags);
+	}
 }
 
 u32 tsdemux_pcrscr_get(void)
diff --git a/drivers/amlogic/amports/tsdemux.h b/drivers/amlogic/amports/tsdemux.h
index 636091f..51a9575 100644
--- a/drivers/amlogic/amports/tsdemux.h
+++ b/drivers/amlogic/amports/tsdemux.h
@@ -64,8 +64,10 @@
 #define PARSER_INT_HOST_EN_BIT      8
 
 struct stream_buf_s;
+struct vdec_s;
 
-extern s32 tsdemux_init(u32 vid, u32 aid, u32 sid, u32 pcrid, bool is_hevc);
+extern s32 tsdemux_init(u32 vid, u32 aid, u32 sid, u32 pcrid, bool is_hevc,
+			struct vdec_s *vdec);
 
 extern void tsdemux_release(void);
 extern ssize_t drm_tswrite(struct file *file,
diff --git a/drivers/amlogic/amports/vavs.c b/drivers/amlogic/amports/vavs.c
index 9e7294e..8d7bf6c 100644
--- a/drivers/amlogic/amports/vavs.c
+++ b/drivers/amlogic/amports/vavs.c
@@ -605,7 +605,7 @@ static void vavs_vf_put(struct vframe_s *vf, void *op_arg)
 
 }
 
-int vavs_dec_status(struct vdec_status *vstatus)
+int vavs_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
 {
 	vstatus->width = frame_width;	/* vavs_amstream_dec_info.width; */
 	vstatus->height = frame_height;	/* vavs_amstream_dec_info.height; */
@@ -763,11 +763,14 @@ void vavs_recover(void)
 
 	WRITE_VREG(DOS_SW_RESET0, (1 << 9) | (1 << 8));
 	WRITE_VREG(DOS_SW_RESET0, 0);
-	/*
-	WRITE_VREG(POWER_CTL_VLD, 0x10);
-	WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL, 2, MEM_FIFO_CNT_BIT, 2);
-	WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL, 8, MEM_LEVEL_CNT_BIT, 6);
-	*/
+
+	if (firmware_sel == 1) {
+		WRITE_VREG(POWER_CTL_VLD, 0x10);
+		WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL, 2,
+			MEM_FIFO_CNT_BIT, 2);
+		WRITE_VREG_BITS(VLD_MEM_VIFIFO_CONTROL, 8,
+			MEM_LEVEL_CNT_BIT, 6);
+	}
 	if (firmware_sel == 0)
 		WRITE_VREG(AV_SCRATCH_5, 0);
 
@@ -1234,17 +1237,17 @@ static s32 vavs_init(void)
 
 	vavs_local_init();
 
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXM) {
 		if (debug_flag & 2) {
 			if (amvdec_loadmc_ex(VFORMAT_AVS,
-				"txl_vavs_mc_debug", NULL) < 0) {
+				"gxm_vavs_mc_debug", NULL) < 0) {
 				amvdec_disable();
 				pr_info("failed\n");
 				return -EBUSY;
 			}
 		} else {
 			if (amvdec_loadmc_ex(VFORMAT_AVS,
-				"txl_vavs_mc", NULL) < 0) {
+				"gxm_vavs_mc", NULL) < 0) {
 				amvdec_disable();
 				pr_info("failed\n");
 				return -EBUSY;
@@ -1331,23 +1334,19 @@ static s32 vavs_init(void)
 
 	stat |= STAT_VDEC_RUN;
 
-	set_vdec_func(&vavs_dec_status);
-
 	return 0;
 }
 
 static int amvdec_avs_probe(struct platform_device *pdev)
 {
-	struct vdec_dev_reg_s *pdata =
-		(struct vdec_dev_reg_s *)pdev->dev.platform_data;
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
 
 	if (pdata == NULL) {
 		pr_info("amvdec_avs memory resource undefined.\n");
 		return -EFAULT;
 	}
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL) {
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXM)
 		firmware_sel = 1;
-	}
 
 	if (firmware_sel == 1) {
 		vf_buf_num = 4;
@@ -1383,6 +1382,9 @@ static int amvdec_avs_probe(struct platform_device *pdev)
 
 	pr_info("%s (%d,%d) %d\n", __func__, vavs_amstream_dec_info.width,
 		   vavs_amstream_dec_info.height, vavs_amstream_dec_info.rate);
+
+	pdata->dec_status = vavs_dec_status;
+
 	if (vavs_init() < 0) {
 		pr_info("amvdec_avs init failed.\n");
 
diff --git a/drivers/amlogic/amports/vdec.c b/drivers/amlogic/amports/vdec.c
index 8259da5..d4a47a3 100644
--- a/drivers/amlogic/amports/vdec.c
+++ b/drivers/amlogic/amports/vdec.c
@@ -20,11 +20,26 @@
 #include <linux/types.h>
 #include <linux/errno.h>
 #include <linux/delay.h>
+#include <linux/kthread.h>
 #include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/semaphore.h>
+#include <linux/sched/rt.h>
+#include <linux/interrupt.h>
 #include <linux/amlogic/amports/vformat.h>
 #include <linux/amlogic/iomap.h>
+#include <linux/amlogic/canvas/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/amlogic/amports/ionvideo_ext.h>
+#include <linux/amlogic/amports/vfm_ext.h>
+
 #include "vdec_reg.h"
 #include "vdec.h"
+#ifdef CONFIG_MULTI_DEC
+#include "vdec_profile.h"
+#endif
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 #include <linux/libfdt_env.h>
@@ -39,7 +54,8 @@
 
 #include "amports_config.h"
 #include "amvdec.h"
-
+#include "vvp9.h"
+#include "vdec_input.h"
 
 #include "arch/clk.h"
 #include <linux/reset.h>
@@ -51,16 +67,13 @@ static DEFINE_MUTEX(vdec_mutex);
 #define MC_SIZE (4096 * 4)
 #define CMA_ALLOC_SIZE SZ_64M
 #define MEM_NAME "vdec_prealloc"
-#define SUPPORT_VCODEC_NUM  1
 static int inited_vcodec_num;
 static int poweron_clock_level;
 static int keep_vdec_mem;
 static unsigned int debug_trace_num = 16 * 20;
+static int step_mode;
 static unsigned int clk_config;
 
-static int vdec_irq[VDEC_IRQ_MAX];
-static struct platform_device *vdec_device;
-static struct platform_device *vdec_core_device;
 static struct page *vdec_cma_page;
 int vdec_mem_alloced_from_codec, delay_release;
 static unsigned long reserved_mem_start, reserved_mem_end;
@@ -75,7 +88,106 @@ struct am_reg {
 	int offset;
 };
 
-static struct vdec_dev_reg_s vdec_dev_reg;
+struct vdec_isr_context_s {
+	int index;
+	int irq;
+	irq_handler_t dev_isr;
+	irq_handler_t dev_threaded_isr;
+	void *dev_id;
+};
+
+struct vdec_core_s {
+	struct list_head connected_vdec_list;
+	spinlock_t lock;
+
+	atomic_t vdec_nr;
+	struct vdec_s *vfm_vdec;
+	struct vdec_s *active_vdec;
+	struct platform_device *vdec_core_platform_device;
+	struct device *cma_dev;
+	unsigned long mem_start;
+	unsigned long mem_end;
+
+	struct semaphore sem;
+	struct task_struct *thread;
+
+	struct vdec_isr_context_s isr_context[VDEC_IRQ_MAX];
+	int power_ref_count[VDEC_MAX];
+};
+
+static struct vdec_core_s *vdec_core;
+
+unsigned long vdec_core_lock(struct vdec_core_s *core)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&core->lock, flags);
+
+	return flags;
+}
+
+void vdec_core_unlock(struct vdec_core_s *core, unsigned long flags)
+{
+	spin_unlock_irqrestore(&core->lock, flags);
+}
+
+static int get_canvas(unsigned int index, unsigned int base)
+{
+	int start;
+	int canvas_index = index * base;
+
+	if ((base > 4) || (base == 0))
+		return -1;
+
+	if ((AMVDEC_CANVAS_START_INDEX + canvas_index + base - 1)
+		<= AMVDEC_CANVAS_MAX1) {
+		start = AMVDEC_CANVAS_START_INDEX + base * index;
+	} else {
+		canvas_index -= (AMVDEC_CANVAS_MAX1 -
+			AMVDEC_CANVAS_START_INDEX + 1) / base * base;
+		if (canvas_index <= AMVDEC_CANVAS_MAX2)
+			start = canvas_index / base;
+		else
+			return -1;
+	}
+
+	if (base == 1) {
+		return start;
+	} else if (base == 2) {
+		return ((start + 1) << 16) | ((start + 1) << 8) | start;
+	} else if (base == 3) {
+		return ((start + 2) << 16) | ((start + 1) << 8) | start;
+	} else if (base == 4) {
+		return (((start + 3) << 24) | (start + 2) << 16) |
+			((start + 1) << 8) | start;
+	}
+
+	return -1;
+}
+
+
+int vdec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+{
+	if (vdec->dec_status)
+		return vdec->dec_status(vdec, vstatus);
+
+	return -1;
+}
+
+int vdec_set_trickmode(struct vdec_s *vdec, unsigned long trickmode)
+{
+	int r;
+
+	if (vdec->set_trickmode) {
+		r = vdec->set_trickmode(vdec, trickmode);
+
+		if ((r == 0) && (vdec->slave) && (vdec->slave->set_trickmode))
+			r = vdec->slave->set_trickmode(vdec->slave,
+				trickmode);
+	}
+
+	return -1;
+}
 
 /*
  clk_config:
@@ -103,8 +215,53 @@ static bool hevc_workaround_needed(void)
 
 struct device *get_codec_cma_device(void)
 {
-	return vdec_dev_reg.cma_dev;
+	return vdec_core->cma_dev;
 }
+
+#ifdef CONFIG_MULTI_DEC
+static const char * const vdec_device_name[] = {
+	"amvdec_mpeg12",     "ammvdec_mpeg12",
+	"amvdec_mpeg4",      "ammvdec_mpeg4",
+	"amvdec_h264",       "ammvdec_h264",
+	"amvdec_mjpeg",      "ammvdec_mjpeg",
+	"amvdec_real",       "ammvdec_real",
+	"amjpegdec",         "ammjpegdec",
+	"amvdec_vc1",        "ammvdec_vc1",
+	"amvdec_avs",        "ammvdec_avs",
+	"amvdec_yuv",        "ammvdec_yuv",
+	"amvdec_h264mvc",    "ammvdec_h264mvc",
+	"amvdec_h264_4k2k",  "ammvdec_h264_4k2k",
+	"amvdec_h265",       "ammvdec_h265",
+	"amvenc_avc",        "amvenc_avc",
+	"jpegenc",           "jpegenc",
+	"amvdec_vp9",        "ammvdec_vp9"
+};
+
+static int vdec_default_buf_size[] = {
+	32, 32, /*"amvdec_mpeg12",*/
+	32, 0,  /*"amvdec_mpeg4",*/
+	48, 0,  /*"amvdec_h264",*/
+	32, 32, /*"amvdec_mjpeg",*/
+	32, 32, /*"amvdec_real",*/
+	32, 32, /*"amjpegdec",*/
+	32, 32, /*"amvdec_vc1",*/
+	32, 32, /*"amvdec_avs",*/
+	32, 32, /*"amvdec_yuv",*/
+	64, 64, /*"amvdec_h264mvc",*/
+	64, 64, /*"amvdec_h264_4k2k", else alloc on decoder*/
+	48, 48, /*"amvdec_h265", else alloc on decoder*/
+	0, 0,   /* avs encoder */
+	0, 0,   /* jpg encoder */
+#ifdef VP9_10B_MMU
+	24, 24, /*"amvdec_vp9", else alloc on decoder*/
+#else
+	32, 32,
+#endif
+	0
+};
+
+#else
+
 static const char * const vdec_device_name[] = {
 	"amvdec_mpeg12",
 	"amvdec_mpeg4",
@@ -138,43 +295,643 @@ static int vdec_default_buf_size[] = {
 	48, /*"amvdec_h265", else alloc on decoder*/
 	0,  /* avs encoder */
 	0,  /* jpg encoder */
-	32, /*"amvdec_vp9", else alloc on decoder*/
-	0
+#ifdef VP9_10B_MMU
+	24, /*"amvdec_vp9", else alloc on decoder*/
+#else
+	32,
+#endif
 };
+#endif
 
-void vdec_set_decinfo(struct dec_sysinfo *p)
+int vdec_set_decinfo(struct vdec_s *vdec, struct dec_sysinfo *p)
 {
-	vdec_dev_reg.sys_info = p;
+	if (copy_from_user((void *)&vdec->sys_info_store, (void *)p,
+		sizeof(struct dec_sysinfo)))
+		return -EFAULT;
+
+	return 0;
 }
 
-int vdec_set_resource(unsigned long start, unsigned long end, struct device *p)
+/* construct vdec strcture */
+struct vdec_s *vdec_create(struct stream_port_s *port,
+			struct vdec_s *master)
 {
-	if (inited_vcodec_num != 0) {
-		pr_info
-		("ERROR:We can't support the change resource at running\n");
-		return -1;
+	struct vdec_s *vdec;
+	int type = VDEC_TYPE_SINGLE;
+
+	if (port->type & PORT_TYPE_DECODER_SCHED)
+		type = (port->type & PORT_TYPE_FRAME) ?
+			VDEC_TYPE_FRAME_BLOCK :
+			VDEC_TYPE_STREAM_PARSER;
+
+	vdec = vzalloc(sizeof(struct vdec_s));
+
+	/* TBD */
+	if (vdec) {
+		vdec->magic = 0x43454456;
+		vdec->id = 0;
+		vdec->type = type;
+		vdec->port = port;
+		vdec->sys_info = &vdec->sys_info_store;
+
+		INIT_LIST_HEAD(&vdec->list);
+
+		vdec_input_init(&vdec->input, vdec);
+
+		atomic_inc(&vdec_core->vdec_nr);
+
+		if (master) {
+			vdec->master = master;
+			master->slave = vdec;
+			master->sched = 1;
+		}
 	}
 
-	vdec_dev_reg.mem_start = ALIGN(start, SZ_64K);
-	vdec_dev_reg.mem_end = end;
-	vdec_dev_reg.cma_dev = p;
+	pr_info("vdec_create instance %p, total %d\n", vdec,
+		atomic_read(&vdec_core->vdec_nr));
+
+	return vdec;
+}
+
+int vdec_set_format(struct vdec_s *vdec, int format)
+{
+	vdec->format = format;
+
+	if (vdec->slave)
+		vdec->slave->format = format;
+
+	return 0;
+}
 
-	reserved_mem_start = vdec_dev_reg.mem_start;
-	reserved_mem_end = end;
+int vdec_set_pts(struct vdec_s *vdec, u32 pts)
+{
+	vdec->pts = pts;
+	vdec->pts_valid = true;
+	return 0;
+}
 
+int vdec_set_pts64(struct vdec_s *vdec, u64 pts64)
+{
+	vdec->pts64 = pts64;
+	vdec->pts_valid = true;
 	return 0;
 }
 
-s32 vdec_init(enum vformat_e vf, int is_4k)
+void vdec_set_status(struct vdec_s *vdec, int status)
 {
-	s32 r;
+	vdec->status = status;
+}
+
+void vdec_set_next_status(struct vdec_s *vdec, int status)
+{
+	vdec->next_status = status;
+}
+
+int vdec_set_video_path(struct vdec_s *vdec, int video_path)
+{
+	vdec->frame_base_video_path = video_path;
+	return 0;
+}
+
+/* add frame data to input chain */
+int vdec_write_vframe(struct vdec_s *vdec, const char *buf, size_t count)
+{
+	return vdec_input_add_frame(&vdec->input, buf, count);
+}
+
+/* get next frame from input chain */
+/* THE VLD_FIFO is 512 bytes and Video buffer level
+ * empty interrupt is set to 0x80 bytes threshold
+ */
+#define VLD_PADDING_SIZE 1024
+#define HEVC_PADDING_SIZE (1024*16)
+#define FIFO_ALIGN 8
+int vdec_prepare_input(struct vdec_s *vdec, struct vframe_chunk_s **p)
+{
+	struct vdec_input_s *input = (vdec->master) ?
+		&vdec->master->input : &vdec->input;
+	struct vframe_chunk_s *chunk = NULL;
+	struct vframe_block_list_s *block = NULL;
+	int dummy;
+
+	/* full reset to HW input */
+	if (input->target == VDEC_INPUT_TARGET_VLD) {
+		WRITE_VREG(VLD_MEM_VIFIFO_CONTROL, 0);
+
+		/* reset VLD fifo for all vdec */
+		WRITE_VREG(DOS_SW_RESET0, (1<<5) | (1<<4) | (1<<3));
+		WRITE_VREG(DOS_SW_RESET0, 0);
+
+		dummy = READ_MPEG_REG(RESET0_REGISTER);
+		WRITE_VREG(POWER_CTL_VLD, 1 << 4);
+	} else if (input->target == VDEC_INPUT_TARGET_HEVC) {
+#if 0
+		/*move to driver*/
+		if (input_frame_based(input))
+			WRITE_VREG(HEVC_STREAM_CONTROL, 0);
+
+		/*
+		 * 2: assist
+		 * 3: parser
+		 * 4: parser_state
+		 * 8: dblk
+		 * 11:mcpu
+		 * 12:ccpu
+		 * 13:ddr
+		 * 14:iqit
+		 * 15:ipp
+		 * 17:qdct
+		 * 18:mpred
+		 * 19:sao
+		 * 24:hevc_afifo
+		 */
+		WRITE_VREG(DOS_SW_RESET3,
+			(1<<3)|(1<<4)|(1<<8)|(1<<11)|(1<<12)|(1<<14)|(1<<15)|
+			(1<<17)|(1<<18)|(1<<19));
+		WRITE_VREG(DOS_SW_RESET3, 0);
+#endif
+	}
+
+	/* setup HW decoder input buffer (VLD context)
+	 * based on input->type and input->target
+	 */
+	if (input_frame_based(input)) {
+		chunk = vdec_input_next_chunk(&vdec->input);
+
+		if (chunk == NULL) {
+			*p = NULL;
+			return -1;
+		}
+
+		block = chunk->block;
+
+		if (input->target == VDEC_INPUT_TARGET_VLD) {
+			WRITE_VREG(VLD_MEM_VIFIFO_START_PTR, block->start);
+			WRITE_VREG(VLD_MEM_VIFIFO_END_PTR, block->start +
+					block->size - 8);
+			WRITE_VREG(VLD_MEM_VIFIFO_CURR_PTR,
+					round_down(block->start + chunk->offset,
+						FIFO_ALIGN));
+
+			WRITE_VREG(VLD_MEM_VIFIFO_CONTROL, 1);
+			WRITE_VREG(VLD_MEM_VIFIFO_CONTROL, 0);
+
+			/* set to manual mode */
+			WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, 2);
+			WRITE_VREG(VLD_MEM_VIFIFO_RP,
+					round_down(block->start + chunk->offset,
+						FIFO_ALIGN));
+			dummy = chunk->offset + chunk->size +
+				VLD_PADDING_SIZE;
+			if (dummy >= block->size)
+				dummy -= block->size;
+			WRITE_VREG(VLD_MEM_VIFIFO_WP,
+				round_down(block->start + dummy, FIFO_ALIGN));
+
+			WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, 3);
+			WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, 2);
+
+			WRITE_VREG(VLD_MEM_VIFIFO_CONTROL,
+				(0x11 << 16) | (1<<10) | (7<<3));
+
+		} else if (input->target == VDEC_INPUT_TARGET_HEVC) {
+			WRITE_VREG(HEVC_STREAM_START_ADDR, block->start);
+			WRITE_VREG(HEVC_STREAM_END_ADDR, block->start +
+					block->size);
+			WRITE_VREG(HEVC_STREAM_RD_PTR, block->start +
+					chunk->offset);
+			dummy = chunk->offset + chunk->size +
+					HEVC_PADDING_SIZE;
+			if (dummy >= block->size)
+				dummy -= block->size;
+			WRITE_VREG(HEVC_STREAM_WR_PTR,
+				round_down(block->start + dummy, FIFO_ALIGN));
+
+			/* set endian */
+			SET_VREG_MASK(HEVC_STREAM_CONTROL, 7 << 4);
+		}
+
+		*p = chunk;
+		return chunk->size;
+
+	} else {
+		u32 rp = 0, wp = 0, fifo_len = 0;
+		int size;
+		/* stream based */
+		if (input->swap_valid) {
+			if (input->target == VDEC_INPUT_TARGET_VLD) {
+				WRITE_VREG(VLD_MEM_VIFIFO_CONTROL, 0);
+
+				/* restore read side */
+				WRITE_VREG(VLD_MEM_SWAP_ADDR,
+					page_to_phys(input->swap_page));
+				WRITE_VREG(VLD_MEM_SWAP_CTL, 1);
+
+				while (READ_VREG(VLD_MEM_SWAP_CTL) & (1<<7))
+					;
+				WRITE_VREG(VLD_MEM_SWAP_CTL, 0);
+
+				/* restore wrap count */
+				WRITE_VREG(VLD_MEM_VIFIFO_WRAP_COUNT,
+					input->stream_cookie);
+
+				rp = READ_VREG(VLD_MEM_VIFIFO_RP);
+				fifo_len = READ_VREG(VLD_MEM_VIFIFO_LEVEL);
+
+				/* enable */
+				WRITE_VREG(VLD_MEM_VIFIFO_CONTROL,
+					(0x11 << 16) | (1<<10));
+
+				/* update write side */
+				WRITE_VREG(VLD_MEM_VIFIFO_WP,
+					READ_MPEG_REG(PARSER_VIDEO_WP));
+
+				wp = READ_VREG(VLD_MEM_VIFIFO_WP);
+			} else if (input->target == VDEC_INPUT_TARGET_HEVC) {
+				SET_VREG_MASK(HEVC_STREAM_CONTROL, 1);
+
+				/* restore read side */
+				WRITE_VREG(HEVC_STREAM_SWAP_ADDR,
+					page_to_phys(input->swap_page));
+				WRITE_VREG(HEVC_STREAM_SWAP_CTRL, 1);
+
+				while (READ_VREG(HEVC_STREAM_SWAP_CTRL)
+					& (1<<7))
+					;
+				WRITE_VREG(HEVC_STREAM_SWAP_CTRL, 0);
+
+				/* restore stream offset */
+				WRITE_VREG(HEVC_SHIFT_BYTE_COUNT,
+					input->stream_cookie);
+
+				rp = READ_VREG(HEVC_STREAM_RD_PTR);
+				fifo_len = (READ_VREG(HEVC_STREAM_FIFO_CTL)
+						>> 16) & 0x7f;
+
+
+				/* enable */
+
+				/* update write side */
+				WRITE_VREG(HEVC_STREAM_WR_PTR,
+					READ_MPEG_REG(PARSER_VIDEO_WP));
+
+				wp = READ_VREG(HEVC_STREAM_WR_PTR);
+			}
+
+		} else {
+			if (input->target == VDEC_INPUT_TARGET_VLD) {
+				WRITE_VREG(VLD_MEM_VIFIFO_START_PTR,
+					input->start);
+				WRITE_VREG(VLD_MEM_VIFIFO_END_PTR,
+					input->start + input->size - 8);
+				WRITE_VREG(VLD_MEM_VIFIFO_CURR_PTR,
+					input->start);
+
+				WRITE_VREG(VLD_MEM_VIFIFO_CONTROL, 1);
+				WRITE_VREG(VLD_MEM_VIFIFO_CONTROL, 0);
+
+				/* set to manual mode */
+				WRITE_VREG(VLD_MEM_VIFIFO_BUF_CNTL, 2);
+				WRITE_VREG(VLD_MEM_VIFIFO_RP, input->start);
+				WRITE_VREG(VLD_MEM_VIFIFO_WP,
+					READ_MPEG_REG(PARSER_VIDEO_WP));
+
+				rp = READ_VREG(VLD_MEM_VIFIFO_RP);
+
+				/* enable */
+				WRITE_VREG(VLD_MEM_VIFIFO_CONTROL,
+					(0x11 << 16) | (1<<10));
+
+				wp = READ_VREG(VLD_MEM_VIFIFO_WP);
+
+			} else if (input->target == VDEC_INPUT_TARGET_HEVC) {
+				WRITE_VREG(HEVC_STREAM_START_ADDR,
+					input->start);
+				WRITE_VREG(HEVC_STREAM_END_ADDR,
+					input->start + input->size);
+				WRITE_VREG(HEVC_STREAM_RD_PTR,
+					input->start);
+				WRITE_VREG(HEVC_STREAM_WR_PTR,
+					READ_MPEG_REG(PARSER_VIDEO_WP));
+
+				rp = READ_VREG(HEVC_STREAM_RD_PTR);
+				wp = READ_VREG(HEVC_STREAM_WR_PTR);
+				fifo_len = (READ_VREG(HEVC_STREAM_FIFO_CTL)
+						>> 16) & 0x7f;
+
+				/* enable */
+			}
+		}
+		*p = NULL;
+		if (wp >= rp)
+			size = wp - rp + fifo_len;
+		else
+			size = wp + input->size - rp + fifo_len;
+		if (size < 0) {
+			pr_info("%s error: input->size %x wp %x rp %x fifo_len %x => size %x\r\n",
+				__func__, input->size, wp, rp, fifo_len, size);
+			size = 0;
+		}
+		return size;
+	}
+}
+
+void vdec_enable_input(struct vdec_s *vdec)
+{
+	struct vdec_input_s *input = &vdec->input;
+
+	if (vdec->status != VDEC_STATUS_ACTIVE)
+		return;
+
+	if (input->target == VDEC_INPUT_TARGET_VLD)
+		SET_VREG_MASK(VLD_MEM_VIFIFO_CONTROL, (1<<2) | (1<<1));
+	else if (input->target == VDEC_INPUT_TARGET_HEVC) {
+		SET_VREG_MASK(HEVC_STREAM_CONTROL, 1);
+		if (vdec_stream_based(vdec))
+			CLEAR_VREG_MASK(HEVC_STREAM_CONTROL, 7 << 4);
+		else
+			SET_VREG_MASK(HEVC_STREAM_CONTROL, 7 << 4);
+		SET_VREG_MASK(HEVC_STREAM_FIFO_CTL, (1<<29));
+	}
+}
+
+void vdec_set_flag(struct vdec_s *vdec, u32 flag)
+{
+	vdec->flag = flag;
+}
+
+void vdec_set_next_sched(struct vdec_s *vdec, struct vdec_s *next_vdec)
+{
+	if (vdec && next_vdec) {
+		vdec->sched = 0;
+		next_vdec->sched = 1;
+	}
+}
+
+void vdec_vframe_dirty(struct vdec_s *vdec, struct vframe_chunk_s *chunk)
+{
+	if (chunk)
+		chunk->flag |= VFRAME_CHUNK_FLAG_CONSUMED;
+
+	if (vdec_stream_based(vdec)) {
+		if (vdec->slave &&
+			((vdec->slave->flag &
+			VDEC_FLAG_INPUT_KEEP_CONTEXT) == 0)) {
+			vdec->input.swap_needed = false;
+		} else
+			vdec->input.swap_needed = true;
+
+		if (vdec->input.target == VDEC_INPUT_TARGET_VLD) {
+			WRITE_MPEG_REG(PARSER_VIDEO_RP,
+				READ_VREG(VLD_MEM_VIFIFO_RP));
+			WRITE_VREG(VLD_MEM_VIFIFO_WP,
+				READ_MPEG_REG(PARSER_VIDEO_WP));
+		} else if (vdec->input.target == VDEC_INPUT_TARGET_HEVC) {
+			WRITE_MPEG_REG(PARSER_VIDEO_RP,
+				READ_VREG(HEVC_STREAM_RD_PTR));
+			WRITE_VREG(HEVC_STREAM_WR_PTR,
+				READ_MPEG_REG(PARSER_VIDEO_WP));
+		}
+	}
+}
+
+void vdec_save_input_context(struct vdec_s *vdec)
+{
+	struct vdec_input_s *input = (vdec->master) ?
+		&vdec->master->input : &vdec->input;
+
+#ifdef CONFIG_MULTI_DEC
+	vdec_profile(vdec, VDEC_PROFILE_EVENT_SAVE_INPUT);
+#endif
+
+	if (input->target == VDEC_INPUT_TARGET_VLD)
+		WRITE_VREG(VLD_MEM_VIFIFO_CONTROL, 1<<15);
+
+	if (input_stream_based(input) && (input->swap_needed)) {
+		if (input->target == VDEC_INPUT_TARGET_VLD) {
+			WRITE_VREG(VLD_MEM_SWAP_ADDR,
+				page_to_phys(input->swap_page));
+			WRITE_VREG(VLD_MEM_SWAP_CTL, 3);
+			while (READ_VREG(VLD_MEM_SWAP_CTL) & (1<<7))
+				;
+			WRITE_VREG(VLD_MEM_SWAP_CTL, 0);
+			vdec->input.stream_cookie =
+				READ_VREG(VLD_MEM_VIFIFO_WRAP_COUNT);
+		} else if (input->target == VDEC_INPUT_TARGET_HEVC) {
+			WRITE_VREG(HEVC_STREAM_SWAP_ADDR,
+				page_to_phys(input->swap_page));
+			WRITE_VREG(HEVC_STREAM_SWAP_CTRL, 3);
+
+			while (READ_VREG(HEVC_STREAM_SWAP_CTRL) & (1<<7))
+				;
+			WRITE_VREG(HEVC_STREAM_SWAP_CTRL, 0);
+
+			vdec->input.stream_cookie =
+				READ_VREG(HEVC_SHIFT_BYTE_COUNT);
+		}
+
+		input->swap_valid = true;
+
+		if (input->target == VDEC_INPUT_TARGET_VLD)
+			WRITE_MPEG_REG(PARSER_VIDEO_RP,
+				READ_VREG(VLD_MEM_VIFIFO_RP));
+		else
+			WRITE_MPEG_REG(PARSER_VIDEO_RP,
+				READ_VREG(HEVC_STREAM_RD_PTR));
+	}
+}
+
+void vdec_clean_input(struct vdec_s *vdec)
+{
+	struct vdec_input_s *input = &vdec->input;
+
+	while (!list_empty(&input->vframe_chunk_list)) {
+		struct vframe_chunk_s *chunk =
+			vdec_input_next_chunk(input);
+		if (chunk->flag & VFRAME_CHUNK_FLAG_CONSUMED)
+			vdec_input_release_chunk(input, chunk);
+		else
+			break;
+	}
+	vdec_save_input_context(vdec);
+}
+
+const char *vdec_status_str(struct vdec_s *vdec)
+{
+	switch (vdec->status) {
+	case VDEC_STATUS_UNINITIALIZED:
+		return "VDEC_STATUS_UNINITIALIZED";
+	case VDEC_STATUS_DISCONNECTED:
+		return "VDEC_STATUS_DISCONNECTED";
+	case VDEC_STATUS_CONNECTED:
+		return "VDEC_STATUS_CONNECTED";
+	case VDEC_STATUS_ACTIVE:
+		return "VDEC_STATUS_ACTIVE";
+	default:
+		return "invalid status";
+	}
+}
+
+const char *vdec_type_str(struct vdec_s *vdec)
+{
+	switch (vdec->type) {
+	case VDEC_TYPE_SINGLE:
+		return "VDEC_TYPE_SINGLE";
+	case VDEC_TYPE_STREAM_PARSER:
+		return "VDEC_TYPE_STREAM_PARSER";
+	case VDEC_TYPE_FRAME_BLOCK:
+		return "VDEC_TYPE_FRAME_BLOCK";
+	case VDEC_TYPE_FRAME_CIRCULAR:
+		return "VDEC_TYPE_FRAME_CIRCULAR";
+	default:
+		return "VDEC_TYPE_INVALID";
+	}
+}
+
+const char *vdec_device_name_str(struct vdec_s *vdec)
+{
+	return vdec_device_name[vdec->format * 2 + 1];
+}
+
+void walk_vdec_core_list(char *s)
+{
+	struct vdec_s *vdec;
+	struct vdec_core_s *core = vdec_core;
+	unsigned long flags;
+
+	pr_info("%s --->\n", s);
+
+	flags = vdec_core_lock(vdec_core);
+
+	if (list_empty(&core->connected_vdec_list)) {
+		pr_info("connected vdec list empty\n");
+	} else {
+		list_for_each_entry(vdec, &core->connected_vdec_list, list) {
+			pr_info("\tvdec (%p), status = %s\n", vdec,
+				vdec_status_str(vdec));
+		}
+	}
+
+	vdec_core_unlock(vdec_core, flags);
+}
+
+/* insert vdec to vdec_core for scheduling,
+ * for dual running decoders, connect/disconnect always runs in pairs
+ */
+int vdec_connect(struct vdec_s *vdec)
+{
+	unsigned long flags;
+
+	if (vdec->status != VDEC_STATUS_DISCONNECTED)
+		return 0;
+
+	vdec_set_status(vdec, VDEC_STATUS_CONNECTED);
+	vdec_set_next_status(vdec, VDEC_STATUS_CONNECTED);
+
+	init_completion(&vdec->inactive_done);
+
+	if (vdec->slave) {
+		vdec_set_status(vdec->slave, VDEC_STATUS_CONNECTED);
+		vdec_set_next_status(vdec->slave, VDEC_STATUS_CONNECTED);
+
+		init_completion(&vdec->slave->inactive_done);
+	}
+
+	flags = vdec_core_lock(vdec_core);
+
+	list_add_tail(&vdec->list, &vdec_core->connected_vdec_list);
+
+	if (vdec->slave) {
+		list_add_tail(&vdec->slave->list,
+			&vdec_core->connected_vdec_list);
+	}
+
+	vdec_core_unlock(vdec_core, flags);
+
+	up(&vdec_core->sem);
+
+	return 0;
+}
+
+/* remove vdec from vdec_core scheduling */
+int vdec_disconnect(struct vdec_s *vdec)
+{
+#ifdef CONFIG_MULTI_DEC
+	vdec_profile(vdec, VDEC_PROFILE_EVENT_DISCONNECT);
+#endif
+
+	if ((vdec->status != VDEC_STATUS_CONNECTED) &&
+		(vdec->status != VDEC_STATUS_ACTIVE)) {
+		return 0;
+	}
+
+	/* when a vdec is under the management of scheduler
+	 * the status change will only be from vdec_core_thread
+	 */
+	vdec_set_next_status(vdec, VDEC_STATUS_DISCONNECTED);
+
+	if (vdec->slave)
+		vdec_set_next_status(vdec->slave, VDEC_STATUS_DISCONNECTED);
+	else if (vdec->master)
+		vdec_set_next_status(vdec->master, VDEC_STATUS_DISCONNECTED);
+
+	up(&vdec_core->sem);
+
+	wait_for_completion(&vdec->inactive_done);
+
+	if (vdec->slave)
+		wait_for_completion(&vdec->slave->inactive_done);
+	else if (vdec->master)
+		wait_for_completion(&vdec->master->inactive_done);
+
+	return 0;
+}
+
+/* release vdec structure */
+int vdec_destroy(struct vdec_s *vdec)
+{
+	if (!vdec->master)
+		vdec_input_release(&vdec->input);
+
+#ifdef CONFIG_MULTI_DEC
+	vdec_profile_flush(vdec);
+#endif
+
+	vfree(vdec);
+
+	atomic_dec(&vdec_core->vdec_nr);
+
+	return 0;
+}
+
+/*
+ * Only support time sliced decoding for frame based input,
+ * so legacy decoder can exist with time sliced decoder.
+ */
+static const char *get_dev_name(bool use_legacy_vdec, int format)
+{
+#ifdef CONFIG_MULTI_DEC
+	if (use_legacy_vdec)
+		return vdec_device_name[format * 2];
+	else
+		return vdec_device_name[format * 2 + 1];
+#else
+	return vdec_device_name[format];
+#endif
+}
+
+/* register vdec_device
+ * create output, vfm or create ionvideo output
+ */
+s32 vdec_init(struct vdec_s *vdec, int is_4k)
+{
+	int r = 0;
+	struct vdec_s *p = vdec;
 	int retry_num = 0;
 	int more_buffers = 0;
-	if (inited_vcodec_num >= SUPPORT_VCODEC_NUM) {
-		pr_err("We only support the one video code at each time\n");
-		return -EIO;
-	}
-	if (is_4k && vf < VFORMAT_H264) {
+	const char *dev_name;
+
+	if (is_4k && vdec->format < VFORMAT_H264) {
 		/*old decoder don't support 4k
 			but size is bigger;
 			clear 4k flag, and used more buffers;
@@ -182,105 +939,430 @@ s32 vdec_init(enum vformat_e vf, int is_4k)
 		more_buffers = 1;
 		is_4k = 0;
 	}
-	if (vf == VFORMAT_H264_4K2K ||
-		(vf == VFORMAT_HEVC && is_4k)) {
-		try_free_keep_video();
+
+	dev_name = get_dev_name(vdec_single(vdec), vdec->format);
+
+	if (dev_name == NULL)
+		return -ENODEV;
+
+	pr_info("vdec_init, dev_name:%s, vdec_type=%s\n",
+		dev_name, vdec_type_str(vdec));
+
+	/* todo: VFM patch control should be configurable,
+	 * for now all stream based input uses default VFM path.
+	 */
+	if (vdec_stream_based(vdec) && !vdec_dual(vdec)) {
+		if (vdec_core->vfm_vdec == NULL) {
+			pr_info("vdec_init set vfm decoder %p\n", vdec);
+			vdec_core->vfm_vdec = vdec;
+		} else {
+			pr_info("vdec_init vfm path busy.\n");
+			return -EBUSY;
+		}
+	}
+
+	if (vdec_single(vdec) &&
+		((vdec->format == VFORMAT_H264_4K2K) ||
+		(vdec->format == VFORMAT_HEVC && is_4k))) {
+		try_free_keep_video(0);
+	}
+
+	/*when blackout_policy was set, vdec would not free cma buffer, if
+		current vformat require larger buffer size than current
+		buf size, reallocated it
+	*/
+	if (vdec_single(vdec) &&
+		((vdec_core->mem_start != vdec_core->mem_end &&
+			vdec_core->mem_end - vdec_core->mem_start + 1 <
+			vdec_default_buf_size[vdec->format] * SZ_1M))) {
+#ifdef CONFIG_MULTI_DEC
+		pr_info("current vdec size %ld, vformat %d need size %d\n",
+			vdec_core->mem_end - vdec_core->mem_start,
+			vdec->format,
+			vdec_default_buf_size[vdec->format * 2] * SZ_1M);
+#else
+		pr_info("current vdec size %ld, vformat %d need size %d\n",
+			vdec_core->mem_end - vdec_core->mem_start,
+			vdec->format,
+			vdec_default_buf_size[vdec->format] * SZ_1M);
+#endif
+		try_free_keep_video(0);
+		vdec_free_cmabuf();
 	}
 
 	mutex_lock(&vdec_mutex);
 	inited_vcodec_num++;
 	mutex_unlock(&vdec_mutex);
 
-	pr_debug("vdec_dev_reg.mem[0x%lx -- 0x%lx]\n",
-		vdec_dev_reg.mem_start,
-		vdec_dev_reg.mem_end);
+	vdec_input_set_type(&vdec->input, vdec->type,
+			(vdec->format == VFORMAT_HEVC ||
+			vdec->format == VFORMAT_VP9) ?
+				VDEC_INPUT_TARGET_HEVC :
+				VDEC_INPUT_TARGET_VLD);
+
+	p->cma_dev = vdec_core->cma_dev;
+	p->get_canvas = get_canvas;
+	/* todo */
+	if (!vdec_dual(vdec))
+		p->use_vfm_path = vdec_stream_based(vdec);
+
+	if (vdec_single(vdec)) {
+		pr_info("vdec_dev_reg.mem[0x%lx -- 0x%lx]\n",
+			vdec_core->mem_start,
+			vdec_core->mem_end);
+		p->mem_start = vdec_core->mem_start;
+		p->mem_end = vdec_core->mem_end;
+	}
+
+	/* allocate base memory for decoder instance */
+	while ((p->mem_start == p->mem_end) && (vdec_single(vdec))) {
+		int alloc_size;
 
-/*retry alloc:*/
-	while (vdec_dev_reg.mem_start == vdec_dev_reg.mem_end) {
-		int alloc_size = vdec_default_buf_size[vf] * SZ_1M;
+#ifdef CONFIG_MULTI_DEC
+		alloc_size =
+			vdec_default_buf_size[vdec->format * 2 + 1]
+			* SZ_1M;
+#else
+		alloc_size = vdec_default_buf_size[vdec->format] * SZ_1M;
+#endif
 		if (alloc_size == 0)
 			break;/*alloc end*/
 		if (is_4k) {
 			/*used 264 4k's setting for 265.*/
+#ifdef CONFIG_MULTI_DEC
+			int m4k_size =
+				vdec_default_buf_size[VFORMAT_H264_4K2K * 2] *
+				SZ_1M;
+#else
 			int m4k_size =
 				vdec_default_buf_size[VFORMAT_H264_4K2K] *
 				SZ_1M;
+#endif
 			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB)
 				m4k_size = 32 * SZ_1M;
 			if ((m4k_size > 0) && (m4k_size < 200 * SZ_1M))
 				alloc_size = m4k_size;
+
+#ifdef VP9_10B_MMU
+			if ((vdec->format == VFORMAT_VP9) &&
+				(get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)) {
+#ifdef CONFIG_MULTI_DEC
+				if (p->use_vfm_path)
+					alloc_size =
+					vdec_default_buf_size[VFORMAT_VP9 * 2]
+					* SZ_1M;
+				else
+					alloc_size =
+					vdec_default_buf_size[VFORMAT_VP9
+						* 2 + 1] * SZ_1M;
+
+#else
+				alloc_size =
+				vdec_default_buf_size[VFORMAT_VP9] * SZ_1M;
+#endif
+			}
+#endif
 		} else if (more_buffers) {
 			alloc_size = alloc_size + 16 * SZ_1M;
 		}
-		vdec_dev_reg.mem_start = codec_mm_alloc_for_dma(MEM_NAME,
+
+		if ((vdec->format == VFORMAT_HEVC)
+			&& get_mmu_mode()
+			&& (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)) {
+#ifdef CONFIG_MULTI_DEC
+				if (p->use_vfm_path)
+					alloc_size = 33 * SZ_1M;
+				else
+					alloc_size = 33 * SZ_1M;
+#else
+				alloc_size = 33 * SZ_1M;
+#endif
+		}
+
+		if ((vdec->format == VFORMAT_H264)
+			&& (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)
+			&& codec_mm_get_total_size() <= 80 * SZ_1M) {
+#ifdef CONFIG_MULTI_DEC
+			if (p->use_vfm_path)
+				alloc_size = 32 * SZ_1M;
+			else
+				alloc_size = 32 * SZ_1M;
+#else
+			alloc_size = 32 * SZ_1M;
+#endif
+		}
+
+
+		p->mem_start = codec_mm_alloc_for_dma(MEM_NAME,
 			alloc_size / PAGE_SIZE, 4 + PAGE_SHIFT,
-			CODEC_MM_FLAGS_CMA_CLEAR |
+			CODEC_MM_FLAGS_CMA_CLEAR | CODEC_MM_FLAGS_CPU |
 			CODEC_MM_FLAGS_FOR_VDECODER);
-		if (!vdec_dev_reg.mem_start) {
+		if (!p->mem_start) {
 			if (retry_num < 1) {
 				pr_err("vdec base CMA allocation failed,try again\\n");
 				retry_num++;
-				try_free_keep_video();
+				try_free_keep_video(0);
 				continue;/*retry alloc*/
 			}
 			pr_err("vdec base CMA allocation failed.\n");
+
+			mutex_lock(&vdec_mutex);
 			inited_vcodec_num--;
+			mutex_unlock(&vdec_mutex);
+
 			return -ENOMEM;
 		}
-		pr_debug("vdec base memory alloced %p\n",
-		(void *)vdec_dev_reg.mem_start);
 
-		vdec_dev_reg.mem_end = vdec_dev_reg.mem_start +
-			alloc_size - 1;
-		vdec_mem_alloced_from_codec = 1;
+		p->mem_end = p->mem_start + alloc_size - 1;
+		pr_info("vdec base memory alloced [%p -- %p]\n",
+			(void *)p->mem_start,
+			(void *)p->mem_end);
+
 		break;/*alloc end*/
 	}
+
+	if (vdec_single(vdec)) {
+		vdec_core->mem_start = p->mem_start;
+		vdec_core->mem_end = p->mem_end;
+		vdec_mem_alloced_from_codec = 1;
+	}
+
 /*alloc end:*/
-	vdec_dev_reg.flag = 0;
+	/* vdec_dev_reg.flag = 0; */
 
-	vdec_device =
-		platform_device_register_data(&vdec_core_device->dev,
-				vdec_device_name[vf], -1,
-				&vdec_dev_reg, sizeof(vdec_dev_reg));
+	p->dev =
+		platform_device_register_data(
+				&vdec_core->vdec_core_platform_device->dev,
+				dev_name,
+				PLATFORM_DEVID_AUTO,
+				&p, sizeof(struct vdec_s *));
 
-	if (IS_ERR(vdec_device)) {
-		r = PTR_ERR(vdec_device);
-		pr_err("vdec: Decoder device register failed (%d)\n", r);
+	if (IS_ERR(p->dev)) {
+		r = PTR_ERR(p->dev);
+		pr_err("vdec: Decoder device %s register failed (%d)\n",
+			dev_name, r);
+
+		mutex_lock(&vdec_mutex);
 		inited_vcodec_num--;
+		mutex_unlock(&vdec_mutex);
+
 		goto error;
 	}
 
-	return 0;
+	if ((p->type == VDEC_TYPE_FRAME_BLOCK) && (p->run == NULL)) {
+		r = -ENODEV;
+		pr_err("vdec: Decoder device not handled (%s)\n", dev_name);
 
-error:
-	vdec_device = NULL;
+		mutex_lock(&vdec_mutex);
+		inited_vcodec_num--;
+		mutex_unlock(&vdec_mutex);
 
-	inited_vcodec_num--;
+		goto error;
+	}
+
+	if (p->use_vfm_path) {
+		vdec->vf_receiver_inst = -1;
+	} else if (!vdec_dual(vdec)) {
+		/* create IONVIDEO instance and connect decoder's
+		 * vf_provider interface to it
+		 */
+		if (p->type != VDEC_TYPE_FRAME_BLOCK) {
+			r = -ENODEV;
+			pr_err("vdec: Incorrect decoder type\n");
+
+			mutex_lock(&vdec_mutex);
+			inited_vcodec_num--;
+			mutex_unlock(&vdec_mutex);
+
+			goto error;
+		}
+		if (p->frame_base_video_path == FRAME_BASE_PATH_IONVIDEO) {
+#ifdef CONFIG_AMLOGIC_IONVIDEO
+#if 1
+			r = ionvideo_alloc_map(&vdec->vf_receiver_name,
+					&vdec->vf_receiver_inst);
+#else
+			/*
+			 * temporarily just use decoder instance ID as iondriver
+			 * ID to solve OMX iondriver instance number check time
+			 * sequence only the limitation is we can NOT mix
+			 * different video decoders since same ID will be used
+			 * for differentdecoder formats.
+			 */
+			vdec->vf_receiver_inst = p->dev->id;
+			r = ionvideo_assign_map(&vdec->vf_receiver_name,
+					&vdec->vf_receiver_inst);
+#endif
+			if (r < 0) {
+				pr_err("IonVideo frame receiver allocation failed.\n");
+
+				mutex_lock(&vdec_mutex);
+				inited_vcodec_num--;
+				mutex_unlock(&vdec_mutex);
+
+				goto error;
+			}
+#endif
+
+			snprintf(vdec->vfm_map_chain, VDEC_MAP_NAME_SIZE,
+				"%s %s", vdec->vf_provider_name,
+				vdec->vf_receiver_name);
+			snprintf(vdec->vfm_map_id, VDEC_MAP_NAME_SIZE,
+				"%s-%s", vdec->vf_provider_name,
+				vdec->vf_receiver_name);
+
+		} else if (p->frame_base_video_path ==
+				FRAME_BASE_PATH_AMLVIDEO_AMVIDEO) {
+			snprintf(vdec->vfm_map_chain, VDEC_MAP_NAME_SIZE,
+				"%s %s", vdec->vf_provider_name,
+				"amlvideo.0 amvideo");
+			snprintf(vdec->vfm_map_id, VDEC_MAP_NAME_SIZE,
+				"%s-%s", vdec->vf_provider_name,
+				"amlvideo.0 amvideo");
+		} else if (p->frame_base_video_path ==
+				FRAME_BASE_PATH_AMLVIDEO1_AMVIDEO2) {
+			snprintf(vdec->vfm_map_chain, VDEC_MAP_NAME_SIZE,
+				"%s %s", vdec->vf_provider_name,
+				"ppmgr amlvideo.1 amvide2");
+			snprintf(vdec->vfm_map_id, VDEC_MAP_NAME_SIZE,
+				"%s-%s", vdec->vf_provider_name,
+				"ppmgr amlvideo.1 amvide2");
+		}
+
+		if (vfm_map_add(vdec->vfm_map_id,
+					vdec->vfm_map_chain) < 0) {
+			r = -ENOMEM;
+			pr_err("Decoder pipeline map creation failed %s.\n",
+				vdec->vfm_map_id);
+			vdec->vfm_map_id[0] = 0;
+
+			mutex_lock(&vdec_mutex);
+			inited_vcodec_num--;
+			mutex_unlock(&vdec_mutex);
+
+			goto error;
+		}
+
+		pr_info("vfm map %s created\n", vdec->vfm_map_id);
+
+		/* assume IONVIDEO driver already have a few vframe_receiver
+		 * registered.
+		 * 1. Call iondriver function to allocate a IONVIDEO path and
+		 *    provide receiver's name and receiver op.
+		 * 2. Get decoder driver's provider name from driver instance
+		 * 3. vfm_map_add(name, "<decoder provider name>
+		 *    <iondriver receiver name>"), e.g.
+		 *    vfm_map_add("vdec_ion_map_0", "mpeg4_0 iondriver_1");
+		 * 4. vf_reg_provider and vf_reg_receiver
+		 * Note: the decoder provider's op uses vdec as op_arg
+		 *       the iondriver receiver's op uses iondev device as
+		 *       op_arg
+		 */
+	}
+
+	if (!vdec_single(vdec)) {
+		vf_reg_provider(&p->vframe_provider);
+
+		vf_notify_receiver(p->vf_provider_name,
+			VFRAME_EVENT_PROVIDER_START,
+			vdec);
+	}
+
+	pr_info("vdec_init, vf_provider_name = %s\n", p->vf_provider_name);
 
+	/* vdec is now ready to be active */
+	vdec_set_status(vdec, VDEC_STATUS_DISCONNECTED);
+
+	return 0;
+
+error:
 	return r;
 }
 
-s32 vdec_release(enum vformat_e vf)
+/* vdec_create/init/release/destroy are applied to both dual running decoders
+ */
+void vdec_release(struct vdec_s *vdec)
 {
+	vdec_disconnect(vdec);
+
+	if (vdec->vframe_provider.name)
+		vf_unreg_provider(&vdec->vframe_provider);
+
+	if (vdec_core->vfm_vdec == vdec)
+		vdec_core->vfm_vdec = NULL;
+
+	if (vdec->vf_receiver_inst >= 0) {
+		if (vdec->vfm_map_id[0]) {
+			vfm_map_remove(vdec->vfm_map_id);
+			vdec->vfm_map_id[0] = 0;
+		}
 
-	if (vdec_device)
-		platform_device_unregister(vdec_device);
+		/* vf_receiver_inst should be > 0 since 0 is
+		 * for either un-initialized vdec or a ionvideo
+		 * instance reserved for legacy path.
+		 */
+#ifdef CONFIG_AMLOGIC_IONVIDEO
+		ionvideo_release_map(vdec->vf_receiver_inst);
+#endif
+	}
+
+	platform_device_unregister(vdec->dev);
 
-	if (delay_release-- <= 0 &&
+	if (!vdec->use_vfm_path) {
+		if (vdec->mem_start) {
+			codec_mm_free_for_dma(MEM_NAME, vdec->mem_start);
+			vdec->mem_start = 0;
+			vdec->mem_end = 0;
+		}
+	} else if (delay_release-- <= 0 &&
 			!keep_vdec_mem &&
 			vdec_mem_alloced_from_codec &&
-			vdec_dev_reg.mem_start &&
+			vdec_core->mem_start &&
 			get_blackout_policy()) {
-		codec_mm_free_for_dma(MEM_NAME, vdec_dev_reg.mem_start);
+		codec_mm_free_for_dma(MEM_NAME, vdec_core->mem_start);
 		vdec_cma_page = NULL;
-		vdec_dev_reg.mem_start = reserved_mem_start;
-		vdec_dev_reg.mem_end = reserved_mem_end;
+		vdec_core->mem_start = reserved_mem_start;
+		vdec_core->mem_end = reserved_mem_end;
 	}
 
+	vdec_destroy(vdec);
 
+	mutex_lock(&vdec_mutex);
 	inited_vcodec_num--;
+	mutex_unlock(&vdec_mutex);
+}
 
-	vdec_device = NULL;
+/* For dual running decoders, vdec_reset is only called with master vdec.
+ */
+int vdec_reset(struct vdec_s *vdec)
+{
+	vdec_disconnect(vdec);
+
+	if (vdec->vframe_provider.name)
+		vf_unreg_provider(&vdec->vframe_provider);
+
+	if ((vdec->slave) && (vdec->slave->vframe_provider.name))
+		vf_unreg_provider(&vdec->slave->vframe_provider);
+
+	if (vdec->reset) {
+		vdec->reset(vdec);
+		if (vdec->slave)
+			vdec->slave->reset(vdec->slave);
+	}
+
+	vdec_input_release(&vdec->input);
+
+	vf_reg_provider(&vdec->vframe_provider);
+	vf_notify_receiver(vdec->vf_provider_name,
+			VFRAME_EVENT_PROVIDER_START, vdec);
+
+	if (vdec->slave) {
+		vf_reg_provider(&vdec->slave->vframe_provider);
+		vf_notify_receiver(vdec->slave->vf_provider_name,
+			VFRAME_EVENT_PROVIDER_START, vdec->slave);
+	}
+
+	vdec_connect(vdec);
 
 	return 0;
 }
@@ -289,22 +1371,287 @@ void vdec_free_cmabuf(void)
 {
 	mutex_lock(&vdec_mutex);
 
-	if ((inited_vcodec_num > 0) || (vdec_device)) {
+	if (inited_vcodec_num > 0) {
 		mutex_unlock(&vdec_mutex);
 		return;
 	}
 
-	if (vdec_mem_alloced_from_codec && vdec_dev_reg.mem_start) {
-		codec_mm_free_for_dma(MEM_NAME, vdec_dev_reg.mem_start);
+	if (vdec_mem_alloced_from_codec && vdec_core->mem_start) {
+		codec_mm_free_for_dma(MEM_NAME, vdec_core->mem_start);
 		vdec_cma_page = NULL;
-		vdec_dev_reg.mem_start = reserved_mem_start;
-		vdec_dev_reg.mem_end = reserved_mem_end;
+		vdec_core->mem_start = reserved_mem_start;
+		vdec_core->mem_end = reserved_mem_end;
 		pr_info("force free vdec memory\n");
 	}
 
 	mutex_unlock(&vdec_mutex);
 }
 
+static struct vdec_s *active_vdec(struct vdec_core_s *core)
+{
+	struct vdec_s *vdec;
+	struct list_head *p;
+
+	list_for_each(p, &core->connected_vdec_list) {
+		vdec = list_entry(p, struct vdec_s, list);
+		if (vdec->status == VDEC_STATUS_ACTIVE)
+			return vdec;
+	}
+
+	return NULL;
+}
+
+/* Decoder callback
+ * Each decoder instance uses this callback to notify status change, e.g. when
+ * decoder finished using HW resource.
+ * a sample callback from decoder's driver is following:
+ *
+ *        if (hw->vdec_cb) {
+ *            vdec_set_next_status(vdec, VDEC_STATUS_CONNECTED);
+ *            hw->vdec_cb(vdec, hw->vdec_cb_arg);
+ *        }
+ */
+static void vdec_callback(struct vdec_s *vdec, void *data)
+{
+	struct vdec_core_s *core = (struct vdec_core_s *)data;
+
+#ifdef CONFIG_MULTI_DEC
+	vdec_profile(vdec, VDEC_PROFILE_EVENT_CB);
+#endif
+
+	up(&core->sem);
+}
+
+static irqreturn_t vdec_isr(int irq, void *dev_id)
+{
+	struct vdec_isr_context_s *c =
+		(struct vdec_isr_context_s *)dev_id;
+	struct vdec_s *vdec = vdec_core->active_vdec;
+
+	if (c->dev_isr)
+		return c->dev_isr(irq, c->dev_id);
+
+	if (c != &vdec_core->isr_context[VDEC_IRQ_1]) {
+#if 0
+		pr_warn("vdec interrupt w/o a valid receiver\n");
+#endif
+		return IRQ_HANDLED;
+	}
+
+	if (!vdec) {
+#if 0
+		pr_warn("vdec interrupt w/o an active instance running. core = %p\n",
+			core);
+#endif
+		return IRQ_HANDLED;
+	}
+
+	if (!vdec->irq_handler) {
+#if 0
+		pr_warn("vdec instance has no irq handle.\n");
+#endif
+		return IRQ_HANDLED;
+	}
+
+	return vdec->irq_handler(vdec);
+}
+
+static irqreturn_t vdec_thread_isr(int irq, void *dev_id)
+{
+	struct vdec_isr_context_s *c =
+		(struct vdec_isr_context_s *)dev_id;
+	struct vdec_s *vdec = vdec_core->active_vdec;
+
+	if (c->dev_threaded_isr)
+		return c->dev_threaded_isr(irq, c->dev_id);
+
+	if (!vdec)
+		return IRQ_HANDLED;
+
+	if (!vdec->threaded_irq_handler)
+		return IRQ_HANDLED;
+
+	return vdec->threaded_irq_handler(vdec);
+}
+
+static inline bool vdec_ready_to_run(struct vdec_s *vdec)
+{
+	bool r;
+
+	if (vdec->status != VDEC_STATUS_CONNECTED)
+		return false;
+
+	if (!vdec->run_ready)
+		return false;
+
+	if ((vdec->slave || vdec->master) &&
+		(vdec->sched == 0))
+		return false;
+
+	if (step_mode) {
+		if ((step_mode & 0xff) != vdec->id)
+			return false;
+	}
+
+	step_mode &= ~0xff;
+
+#ifdef CONFIG_MULTI_DEC
+	vdec_profile(vdec, VDEC_PROFILE_EVENT_CHK_RUN_READY);
+#endif
+
+	r = vdec->run_ready(vdec);
+
+#ifdef CONFIG_MULTI_DEC
+	if (r)
+		vdec_profile(vdec, VDEC_PROFILE_EVENT_RUN_READY);
+#endif
+
+	return r;
+}
+
+/* struct vdec_core_shread manages all decoder instance in active list. When
+ * a vdec is added into the active list, it can onlt be in two status:
+ * VDEC_STATUS_CONNECTED(the decoder does not own HW resource and ready to run)
+ * VDEC_STATUS_ACTIVE(the decoder owns HW resources and is running).
+ * Removing a decoder from active list is only performed within core thread.
+ * Adding a decoder into active list is performed from user thread.
+ */
+static int vdec_core_thread(void *data)
+{
+	unsigned long flags;
+	struct vdec_core_s *core = (struct vdec_core_s *)data;
+
+	struct sched_param param = {.sched_priority = MAX_RT_PRIO - 1};
+
+	sched_setscheduler(current, SCHED_FIFO, &param);
+
+	allow_signal(SIGTERM);
+
+	while (down_interruptible(&core->sem) == 0) {
+		struct vdec_s *vdec, *tmp;
+		LIST_HEAD(disconnecting_list);
+
+		if (kthread_should_stop())
+			break;
+
+		/* clean up previous active vdec's input */
+		if ((core->active_vdec) &&
+		    (core->active_vdec->status == VDEC_STATUS_CONNECTED)) {
+			struct vdec_input_s *input = &core->active_vdec->input;
+
+			while (!list_empty(&input->vframe_chunk_list)) {
+				struct vframe_chunk_s *chunk =
+					vdec_input_next_chunk(input);
+				if (chunk->flag & VFRAME_CHUNK_FLAG_CONSUMED)
+					vdec_input_release_chunk(input, chunk);
+				else
+					break;
+			}
+
+			vdec_save_input_context(core->active_vdec);
+		}
+
+		/* todo:
+		 * this is the case when the decoder is in active mode and
+		 * the system side wants to stop it. Currently we rely on
+		 * the decoder instance to go back to VDEC_STATUS_CONNECTED
+		 * from VDEC_STATUS_ACTIVE by its own. However, if for some
+		 * reason the decoder can not exist by itself (dead decoding
+		 * or whatever), then we may have to add another vdec API
+		 * to kill the vdec and release its HW resource and make it
+		 * become inactive again.
+		 * if ((core->active_vdec) &&
+		 * (core->active_vdec->status == VDEC_STATUS_DISCONNECTED)) {
+		 * }
+		 */
+
+		flags = vdec_core_lock(core);
+
+		/* check disconnected decoders */
+		list_for_each_entry_safe(vdec, tmp,
+			&core->connected_vdec_list, list) {
+			if ((vdec->status == VDEC_STATUS_CONNECTED) &&
+			    (vdec->next_status == VDEC_STATUS_DISCONNECTED)) {
+				if (core->active_vdec == vdec)
+					core->active_vdec = NULL;
+				list_move(&vdec->list, &disconnecting_list);
+			}
+		}
+
+		/* activate next decoder instance if there is none */
+		vdec = active_vdec(core);
+
+		if (!vdec) {
+			/* round-robin decoder scheduling
+			 * start from the decoder after previous active
+			 * decoder instance, if not, then start from beginning
+			 */
+			if (core->active_vdec)
+				vdec = list_entry(
+						core->active_vdec->list.next,
+						struct vdec_s, list);
+			else
+				vdec = list_entry(
+						core->connected_vdec_list.next,
+						struct vdec_s, list);
+
+			list_for_each_entry_from(vdec,
+				&core->connected_vdec_list, list) {
+				if (vdec_ready_to_run(vdec))
+					break;
+			}
+
+			if ((&vdec->list == &core->connected_vdec_list) &&
+				(core->active_vdec)) {
+				/* search from beginning */
+				list_for_each_entry(vdec,
+					&core->connected_vdec_list, list) {
+					if (vdec_ready_to_run(vdec))
+						break;
+
+					if (vdec == core->active_vdec) {
+						vdec = NULL;
+						break;
+					}
+				}
+			}
+
+			if (&vdec->list == &core->connected_vdec_list)
+				vdec = NULL;
+
+			core->active_vdec = NULL;
+		}
+
+		vdec_core_unlock(core, flags);
+
+		/* start the vdec instance */
+		if ((vdec) && (vdec->status != VDEC_STATUS_ACTIVE)) {
+			vdec_set_status(vdec, VDEC_STATUS_ACTIVE);
+
+			/* activatate the decoder instance to run */
+			core->active_vdec = vdec;
+#ifdef CONFIG_MULTI_DEC
+			vdec_profile(vdec, VDEC_PROFILE_EVENT_RUN);
+#endif
+			vdec->run(vdec, vdec_callback, core);
+		}
+
+		/* remove disconnected decoder from active list */
+		list_for_each_entry_safe(vdec, tmp, &disconnecting_list, list) {
+			list_del(&vdec->list);
+			vdec_set_status(vdec, VDEC_STATUS_DISCONNECTED);
+			complete(&vdec->inactive_done);
+		}
+
+		if (!core->active_vdec) {
+			msleep(20);
+			up(&core->sem);
+		}
+	}
+
+	return 0;
+}
+
 #if 1				/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
 static bool test_hevc(u32 decomp_addr, u32 us_delay)
 {
@@ -373,8 +1720,22 @@ void vdec_poweron(enum vdec_type_e core)
 	u32 decomp_addr_aligned = 0;
 	int hevc_loop = 0;
 
+	if (core >= VDEC_MAX)
+		return;
+
 	mutex_lock(&vdec_mutex);
 
+	vdec_core->power_ref_count[core]++;
+	if (vdec_core->power_ref_count[core] > 1) {
+		mutex_unlock(&vdec_mutex);
+		return;
+	}
+
+	if (vdec_on(core)) {
+		mutex_unlock(&vdec_mutex);
+		return;
+	}
+
 	if (hevc_workaround_needed() &&
 		(core == VDEC_HEVC)) {
 		decomp_addr = dma_alloc_coherent(amports_get_dma_device(),
@@ -536,7 +1897,17 @@ void vdec_poweron(enum vdec_type_e core)
 
 void vdec_poweroff(enum vdec_type_e core)
 {
+	if (core >= VDEC_MAX)
+		return;
+
 	mutex_lock(&vdec_mutex);
+
+	vdec_core->power_ref_count[core]--;
+	if (vdec_core->power_ref_count[core] > 0) {
+		mutex_unlock(&vdec_mutex);
+		return;
+	}
+
 	if (core == VDEC_1) {
 		if (get_cpu_type() >=
 			MESON_CPU_MAJOR_ID_GXBB) {
@@ -1042,8 +2413,11 @@ static ssize_t show_keep_vdec_mem(struct class *class,
 		"mailbox_1",
 		"mailbox_2";
 */
-s32 vdec_request_irq(enum vdec_irq_num num, irq_handler_t handler,
-				const char *devname, void *dev)
+s32 vdec_request_threaded_irq(enum vdec_irq_num num,
+			irq_handler_t handler,
+			irq_handler_t thread_fn,
+			unsigned long irqflags,
+			const char *devname, void *dev)
 {
 	s32 res_irq;
 	s32 ret = 0;
@@ -1051,25 +2425,75 @@ s32 vdec_request_irq(enum vdec_irq_num num, irq_handler_t handler,
 		pr_err("[%s] request irq error, irq num too big!", __func__);
 		return -EINVAL;
 	}
-	res_irq = platform_get_irq(vdec_core_device, num);
-	if (res_irq < 0) {
-		pr_err("[%s] get irq error!", __func__);
-		return -EINVAL;
+
+	if (vdec_core->isr_context[num].irq < 0) {
+		res_irq = platform_get_irq(
+			vdec_core->vdec_core_platform_device, num);
+		if (res_irq < 0) {
+			pr_err("[%s] get irq error!", __func__);
+			return -EINVAL;
+		}
+
+		vdec_core->isr_context[num].irq = res_irq;
+		vdec_core->isr_context[num].dev_isr = handler;
+		vdec_core->isr_context[num].dev_threaded_isr = thread_fn;
+		vdec_core->isr_context[num].dev_id = dev;
+
+		ret = request_threaded_irq(res_irq,
+			vdec_isr,
+			vdec_thread_isr,
+			(thread_fn) ? IRQF_ONESHOT : irqflags,
+			devname,
+			&vdec_core->isr_context[num]);
+
+		if (ret) {
+			vdec_core->isr_context[num].irq = -1;
+			vdec_core->isr_context[num].dev_isr = NULL;
+			vdec_core->isr_context[num].dev_threaded_isr = NULL;
+			vdec_core->isr_context[num].dev_id = NULL;
+
+			pr_err("vdec irq register error for %s.\n", devname);
+			return -EIO;
+		}
+	} else {
+		vdec_core->isr_context[num].dev_isr = handler;
+		vdec_core->isr_context[num].dev_threaded_isr = thread_fn;
+		vdec_core->isr_context[num].dev_id = dev;
 	}
-	vdec_irq[num] = res_irq;
-	ret = request_irq(vdec_irq[num], handler,
-	IRQF_SHARED, devname, dev);
+
 	return ret;
 }
 
+s32 vdec_request_irq(enum vdec_irq_num num, irq_handler_t handler,
+				const char *devname, void *dev)
+{
+	pr_info("vdec_request_irq %p, %s\n", handler, devname);
+
+	return vdec_request_threaded_irq(num,
+		handler,
+		NULL,/*no thread_fn*/
+		IRQF_SHARED,
+		devname,
+		dev);
+}
+
 void vdec_free_irq(enum vdec_irq_num num, void *dev)
 {
 	if (num >= VDEC_IRQ_MAX) {
 		pr_err("[%s] request irq error, irq num too big!", __func__);
 		return;
 	}
-	free_irq(vdec_irq[num], dev);
+
+	synchronize_irq(vdec_core->isr_context[num].irq);
+
+	/* assume amrisc is stopped already and there is no mailbox interrupt
+	 * when we reset pointers here.
+	 */
+	vdec_core->isr_context[num].dev_isr = NULL;
+	vdec_core->isr_context[num].dev_threaded_isr = NULL;
+	vdec_core->isr_context[num].dev_id = NULL;
 }
+
 static int dump_mode;
 static ssize_t dump_risc_mem_store(struct class *class,
 		struct class_attribute *attr,
@@ -1162,6 +2586,28 @@ static ssize_t dump_risc_mem_show(struct class *class,
 	return sprintf(buf, "done\n");
 }
 
+static ssize_t core_show(struct class *class, struct class_attribute *attr,
+			char *buf)
+{
+	struct vdec_core_s *core = vdec_core;
+	char *pbuf = buf;
+
+	if (list_empty(&core->connected_vdec_list))
+		pbuf += sprintf(pbuf, "connected vdec list empty\n");
+	else {
+		struct vdec_s *vdec;
+		list_for_each_entry(vdec, &core->connected_vdec_list, list) {
+			pbuf += sprintf(pbuf,
+				"\tvdec (%p (%s)), status = %s,\ttype = %s\n",
+				vdec, vdec_device_name[vdec->format * 2],
+				vdec_status_str(vdec),
+				vdec_type_str(vdec));
+		}
+	}
+
+	return pbuf - buf;
+}
+
 static struct class_attribute vdec_class_attrs[] = {
 	__ATTR_RO(amrisc_regs),
 	__ATTR_RO(dump_trace),
@@ -1172,6 +2618,7 @@ static struct class_attribute vdec_class_attrs[] = {
 	dump_risc_mem_show, dump_risc_mem_store),
 	__ATTR(keep_vdec_mem, S_IRUGO | S_IWUSR | S_IWGRP,
 	show_keep_vdec_mem, store_keep_vdec_mem),
+	__ATTR_RO(core),
 	__ATTR_NULL
 };
 
@@ -1187,27 +2634,36 @@ fast start.
 */
 void pre_alloc_vdec_memory(void)
 {
-	if (!keep_vdec_mem || vdec_dev_reg.mem_start)
+	if (!keep_vdec_mem || vdec_core->mem_start)
 		return;
 
-	vdec_dev_reg.mem_start = codec_mm_alloc_for_dma(MEM_NAME,
+	vdec_core->mem_start = codec_mm_alloc_for_dma(MEM_NAME,
 		CMA_ALLOC_SIZE / PAGE_SIZE, 4 + PAGE_SHIFT,
 		CODEC_MM_FLAGS_CMA_CLEAR |
 		CODEC_MM_FLAGS_FOR_VDECODER);
-	if (!vdec_dev_reg.mem_start)
+	if (!vdec_core->mem_start)
 		return;
 	pr_debug("vdec base memory alloced %p\n",
-	(void *)vdec_dev_reg.mem_start);
+	(void *)vdec_core->mem_start);
 
-	vdec_dev_reg.mem_end = vdec_dev_reg.mem_start +
-		CMA_ALLOC_SIZE - 1;
+	vdec_core->mem_end = vdec_core->mem_start + CMA_ALLOC_SIZE - 1;
 	vdec_mem_alloced_from_codec = 1;
 	delay_release = 3;
 }
 
 static int vdec_probe(struct platform_device *pdev)
 {
-	s32 r;
+	s32 i, r;
+
+	vdec_core = (struct vdec_core_s *)devm_kzalloc(&pdev->dev,
+			sizeof(struct vdec_core_s), GFP_KERNEL);
+	if (vdec_core == NULL) {
+		pr_err("vdec core allocation failed.\n");
+		return -ENOMEM;
+	}
+
+	atomic_set(&vdec_core->vdec_nr, 0);
+	sema_init(&vdec_core->sem, 1);
 
 	r = class_register(&vdec_class);
 	if (r) {
@@ -1215,13 +2671,27 @@ static int vdec_probe(struct platform_device *pdev)
 		return r;
 	}
 
-	vdec_core_device = pdev;
+	vdec_core->vdec_core_platform_device = pdev;
+
+	platform_set_drvdata(pdev, vdec_core);
+
+	for (i = 0; i < VDEC_IRQ_MAX; i++) {
+		vdec_core->isr_context[i].index = i;
+		vdec_core->isr_context[i].irq = -1;
+	}
+
+	r = vdec_request_threaded_irq(VDEC_IRQ_1, NULL, NULL,
+		IRQF_ONESHOT, "vdec-1", NULL);
+	if (r < 0) {
+		pr_err("vdec interrupt request failed\n");
+		return r;
+	}
 
 	r = of_reserved_mem_device_init(&pdev->dev);
 	if (r == 0)
 		pr_info("vdec_probe done\n");
 
-	vdec_dev_reg.cma_dev = &pdev->dev;
+	vdec_core->cma_dev = &pdev->dev;
 
 	if (get_cpu_type() < MESON_CPU_MAJOR_ID_M8) {
 		/* default to 250MHz */
@@ -1234,16 +2704,44 @@ static int vdec_probe(struct platform_device *pdev)
 	}
 	if (codec_mm_get_reserved_size() >= 48 * SZ_1M
 		&& codec_mm_get_reserved_size() <=  96 * SZ_1M) {
+#ifdef CONFIG_MULTI_DEC
+		vdec_default_buf_size[VFORMAT_H264_4K2K * 2] =
+			codec_mm_get_reserved_size() / SZ_1M;
+#else
 		vdec_default_buf_size[VFORMAT_H264_4K2K] =
 			codec_mm_get_reserved_size() / SZ_1M;
+#endif
+
 		/*all reserved size for prealloc*/
 	}
 	pre_alloc_vdec_memory();
+
+	INIT_LIST_HEAD(&vdec_core->connected_vdec_list);
+	spin_lock_init(&vdec_core->lock);
+
+	vdec_core->thread = kthread_run(vdec_core_thread, vdec_core,
+					"vdec-core");
+
 	return 0;
 }
 
 static int vdec_remove(struct platform_device *pdev)
 {
+	int i;
+
+	for (i = 0; i < VDEC_IRQ_MAX; i++) {
+		if (vdec_core->isr_context[i].irq >= 0) {
+			free_irq(vdec_core->isr_context[i].irq,
+				&vdec_core->isr_context[i]);
+			vdec_core->isr_context[i].irq = -1;
+			vdec_core->isr_context[i].dev_isr = NULL;
+			vdec_core->isr_context[i].dev_threaded_isr = NULL;
+			vdec_core->isr_context[i].dev_id = NULL;
+		}
+	}
+
+	kthread_stop(vdec_core->thread);
+
 	class_unregister(&vdec_class);
 
 	return 0;
@@ -1288,7 +2786,10 @@ static int vdec_mem_device_init(struct reserved_mem *rmem, struct device *dev)
 	end = rmem->base + rmem->size - 1;
 	pr_info("init vdec memsource %lx->%lx\n", start, end);
 
-	vdec_set_resource(start, end, dev);
+	vdec_core->mem_start = start;
+	vdec_core->mem_end = end;
+	vdec_core->cma_dev = dev;
+
 	return 0;
 }
 
@@ -1309,6 +2810,7 @@ RESERVEDMEM_OF_DECLARE(vdec, "amlogic, vdec-memory", vdec_mem_setup);
 module_param(debug_trace_num, uint, 0664);
 module_param(hevc_max_reset_count, int, 0664);
 module_param(clk_config, uint, 0664);
+module_param(step_mode, int, 0664);
 
 module_init(vdec_module_init);
 module_exit(vdec_module_exit);
diff --git a/drivers/amlogic/amports/vdec.h b/drivers/amlogic/amports/vdec.h
index 56e37fb..06d4291 100644
--- a/drivers/amlogic/amports/vdec.h
+++ b/drivers/amlogic/amports/vdec.h
@@ -20,23 +20,16 @@
 #include "amports_config.h"
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
+#include <linux/list.h>
+#include <linux/completion.h>
+#include <linux/irqreturn.h>
 
-struct vdec_dev_reg_s {
-	unsigned long mem_start;
-	unsigned long mem_end;
-	struct device *cma_dev;
-	struct dec_sysinfo *sys_info;
-	unsigned long flag;
-} /*vdec_dev_reg_t */;
+#include <linux/amlogic/amports/amstream.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
 
-
-
-extern void vdec_set_decinfo(struct dec_sysinfo *p);
-extern int vdec_set_resource(unsigned long start, unsigned long end,
-							 struct device *p);
-
-extern s32 vdec_init(enum vformat_e vf, int is_4k);
-extern s32 vdec_release(enum vformat_e vf);
+#include "vdec_input.h"
 
 s32 vdec_dev_register(void);
 s32 vdec_dev_unregister(void);
@@ -87,6 +80,11 @@ enum vdec_irq_num {
 	VDEC_IRQ_2,
 	VDEC_IRQ_MAX,
 };
+extern s32 vdec_request_threaded_irq(enum vdec_irq_num num,
+			irq_handler_t handler,
+			irq_handler_t thread_fn,
+			unsigned long irqflags,
+			const char *devname, void *dev);
 extern s32 vdec_request_irq(enum vdec_irq_num num, irq_handler_t handler,
 	const char *devname, void *dev);
 extern void vdec_free_irq(enum vdec_irq_num num, void *dev);
@@ -103,6 +101,200 @@ extern enum vdec2_usage_e get_vdec2_usage(void);
 extern void dma_contiguous_early_fixup(phys_addr_t base, unsigned long size);
 unsigned int get_vdec_clk_config_settings(void);
 void update_vdec_clk_config_settings(unsigned int config);
+unsigned int  get_mmu_mode(void);
+
+
+struct vdec_s;
+enum vformat_t;
+
+/* stream based with single instance decoder driver */
+#define VDEC_TYPE_SINGLE           0
+/* stream based with multi-instance decoder with HW resouce sharing */
+#define VDEC_TYPE_STREAM_PARSER    1
+/* frame based with multi-instance decoder, input block list based */
+#define VDEC_TYPE_FRAME_BLOCK      2
+/* frame based with multi-instance decoder, single circular input block */
+#define VDEC_TYPE_FRAME_CIRCULAR   3
+
+/* decoder status: uninitialized */
+#define VDEC_STATUS_UNINITIALIZED  0
+/* decoder status: before the decoder can start consuming data */
+#define VDEC_STATUS_DISCONNECTED   1
+/* decoder status: decoder should become disconnected once it's not active */
+#define VDEC_STATUS_CONNECTED      2
+/* decoder status: decoder owns HW resource and is running */
+#define VDEC_STATUS_ACTIVE         3
+
+#define VDEC_PROVIDER_NAME_SIZE 16
+#define VDEC_RECEIVER_NAME_SIZE 16
+#define VDEC_MAP_NAME_SIZE      40
+
+#define VDEC_FLAG_INPUT_KEEP_CONTEXT 0x01
+
+struct vdec_s {
+	u32 magic;
+	struct list_head list;
+	int id;
+
+	struct vdec_s *master;
+	struct vdec_s *slave;
+	struct stream_port_s *port;
+	int status;
+	int next_status;
+	int type;
+	int port_flag;
+	int format;
+	u32 pts;
+	u64 pts64;
+	bool pts_valid;
+	int flag;
+	int sched;
+
+	struct completion inactive_done;
+
+	/* config (temp) */
+	unsigned long mem_start;
+	unsigned long mem_end;
+
+	struct device *cma_dev;
+	struct platform_device *dev;
+	struct dec_sysinfo sys_info_store;
+	struct dec_sysinfo *sys_info;
+
+	/* input */
+	struct vdec_input_s input;
+
+	/* mc cache */
+	u32 mc[4096 * 4];
+	bool mc_loaded;
+
+	/* frame provider/receiver interface */
+	char vf_provider_name[VDEC_PROVIDER_NAME_SIZE];
+	struct vframe_provider_s vframe_provider;
+	char *vf_receiver_name;
+	char vfm_map_id[VDEC_MAP_NAME_SIZE];
+	char vfm_map_chain[VDEC_MAP_NAME_SIZE];
+	int vf_receiver_inst;
+	enum FRAME_BASE_VIDEO_PATH frame_base_video_path;
+	bool use_vfm_path;
+	char config[PAGE_SIZE];
+	int config_len;
+
+	/* canvas */
+	int (*get_canvas)(unsigned int index, unsigned int base);
+
+	int (*dec_status)(struct vdec_s *vdec, struct vdec_status *vstatus);
+	int (*set_trickmode)(struct vdec_s *vdec, unsigned long trickmode);
+
+	bool (*run_ready)(struct vdec_s *vdec);
+	void (*run)(struct vdec_s *vdec,
+			void (*callback)(struct vdec_s *, void *), void *);
+	void (*reset)(struct vdec_s *vdec);
+	irqreturn_t (*irq_handler)(struct vdec_s *);
+	irqreturn_t (*threaded_irq_handler)(struct vdec_s *);
+
+	/* private */
+	void *private;       /* decoder per instance specific data */
+};
+
+/* common decoder vframe provider name to use default vfm path */
+#define VFM_DEC_PROVIDER_NAME "decoder"
+#define VFM_DEC_DVBL_PROVIDER_NAME "dvbldec"
+#define VFM_DEC_DVEL_PROVIDER_NAME "dveldec"
+
+#define hw_to_vdec(hw) ((struct vdec_s *) \
+	(platform_get_drvdata(hw->platform_dev)))
+
+#define canvas_y(canvas) ((canvas) & 0xff)
+#define canvas_u(canvas) (((canvas) >> 8) & 0xff)
+#define canvas_v(canvas) (((canvas) >> 16) & 0xff)
+#define canvas_y2(canvas) (((canvas) >> 16) & 0xff)
+#define canvas_u2(canvas) (((canvas) >> 24) & 0xff)
+
+#define vdec_frame_based(vdec) \
+	(((vdec)->type == VDEC_TYPE_FRAME_BLOCK) || \
+	 ((vdec)->type == VDEC_TYPE_FRAME_CIRCULAR))
+#define vdec_stream_based(vdec) \
+	(((vdec)->type == VDEC_TYPE_STREAM_PARSER) || \
+	 ((vdec)->type == VDEC_TYPE_SINGLE))
+#define vdec_single(vdec) \
+	((vdec)->type == VDEC_TYPE_SINGLE)
+#define vdec_dual(vdec) \
+	((vdec)->port->type & PORT_TYPE_DUALDEC)
+
+/* construct vdec strcture */
+extern struct vdec_s *vdec_create(struct stream_port_s *port,
+				struct vdec_s *master);
+
+/* set video format */
+extern int vdec_set_format(struct vdec_s *vdec, int format);
+
+/* set PTS */
+extern int vdec_set_pts(struct vdec_s *vdec, u32 pts);
+
+extern int vdec_set_pts64(struct vdec_s *vdec, u64 pts64);
+
+/* set vfm map when use frame base decoder */
+extern int vdec_set_video_path(struct vdec_s *vdec, int video_path);
+
+/* add frame data to input chain */
+extern int vdec_write_vframe(struct vdec_s *vdec, const char *buf,
+				size_t count);
+
+/* mark the vframe_chunk as consumed */
+extern void vdec_vframe_dirty(struct vdec_s *vdec,
+				struct vframe_chunk_s *chunk);
+
+/* prepare decoder input */
+extern int vdec_prepare_input(struct vdec_s *vdec, struct vframe_chunk_s **p);
+
+/* clean decoder input */
+extern void vdec_clean_input(struct vdec_s *vdec);
+
+/* enable decoder input */
+extern void vdec_enable_input(struct vdec_s *vdec);
+
+/* allocate input chain
+ * register vdec_device
+ * create output, vfm or create ionvideo output
+ * insert vdec to vdec_manager for scheduling
+ */
+extern int vdec_connect(struct vdec_s *vdec);
+
+/* remove vdec from vdec_manager scheduling
+ * release input chain
+ * disconnect video output from ionvideo
+ */
+extern int vdec_disconnect(struct vdec_s *vdec);
+
+/* release vdec structure */
+extern int vdec_destroy(struct vdec_s *vdec);
+
+/* reset vdec */
+extern int vdec_reset(struct vdec_s *vdec);
+
+extern void vdec_set_status(struct vdec_s *vdec, int status);
+
+extern void vdec_set_next_status(struct vdec_s *vdec, int status);
+
+extern int vdec_set_decinfo(struct vdec_s *vdec, struct dec_sysinfo *p);
+
+extern int vdec_init(struct vdec_s *vdec, int is_4k);
+
+extern void vdec_release(struct vdec_s *vdec);
+
+extern int vdec_status(struct vdec_s *vdec, struct vdec_status *vstatus);
+
+extern int vdec_set_trickmode(struct vdec_s *vdec, unsigned long trickmode);
+
+extern void vdec_set_flag(struct vdec_s *vdec, u32 flag);
+
+extern void vdec_set_next_sched(struct vdec_s *vdec, struct vdec_s *next_vdec);
+
+extern const char *vdec_status_str(struct vdec_s *vdec);
+
+extern const char *vdec_type_str(struct vdec_s *vdec);
 
+extern const char *vdec_device_name_str(struct vdec_s *vdec);
 
 #endif				/* VDEC_H */
diff --git a/drivers/amlogic/amports/vdec_input.c b/drivers/amlogic/amports/vdec_input.c
new file mode 100644
index 0000000..b656685
--- /dev/null
+++ b/drivers/amlogic/amports/vdec_input.c
@@ -0,0 +1,518 @@
+#include <linux/uaccess.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/amlogic/codec_mm/codec_mm.h>
+
+#include "amports_priv.h"
+#include "vdec.h"
+#include "vdec_input.h"
+
+#define VFRAME_BLOCK_SIZE (4*SZ_1M)
+#define VFRAME_BLOCK_PAGESIZE (PAGE_ALIGN(VFRAME_BLOCK_SIZE)/PAGE_SIZE)
+#define VFRAME_BLOCK_PAGEALIGN 4
+#define VFRAME_BLOCK_MAX_LEVEL (8*SZ_1M)
+#define VFRAME_BLOCK_HOLE (SZ_64K)
+
+#define FRAME_PADDING_SIZE 1024U
+#define MEM_NAME "VFRAME_INPUT"
+
+static int vframe_chunk_fill(struct vdec_input_s *input,
+			struct vframe_chunk_s *chunk, const char *buf,
+			size_t count, struct vframe_block_list_s *block)
+{
+	u8 *p = (u8 *)block->start_virt + block->wp;
+
+	if (block->type == VDEC_TYPE_FRAME_BLOCK) {
+		if (copy_from_user(p, buf, count))
+			return -EFAULT;
+
+		p += count;
+
+		memset(p, 0, FRAME_PADDING_SIZE);
+
+		dma_sync_single_for_device(amports_get_dma_device(),
+			block->start + block->wp,
+			count + FRAME_PADDING_SIZE, DMA_TO_DEVICE);
+
+	} else if (block->type == VDEC_TYPE_FRAME_CIRCULAR) {
+		size_t len = min((size_t)(block->size - block->wp), count);
+		u32 wp;
+
+		if (copy_from_user(p, buf, len))
+			return -EFAULT;
+
+		dma_sync_single_for_device(amports_get_dma_device(),
+			block->start + block->wp,
+			len, DMA_TO_DEVICE);
+
+		p += len;
+
+		if (count > len) {
+			p = (u8 *)block->start_virt;
+			if (copy_from_user(p, buf, count - len))
+				return -EFAULT;
+
+			dma_sync_single_for_device(amports_get_dma_device(),
+				block->start,
+				count-len, DMA_TO_DEVICE);
+
+			p += count - len;
+		}
+
+		wp = block->wp + count;
+		if (wp >= block->size)
+			wp -= block->size;
+
+		len = min(block->size - wp, FRAME_PADDING_SIZE);
+
+		memset(p, 0, len);
+
+		dma_sync_single_for_device(amports_get_dma_device(),
+			block->start + wp,
+			len, DMA_TO_DEVICE);
+
+		if (FRAME_PADDING_SIZE > len) {
+			p = (u8 *)block->start_virt;
+
+			memset(p, 0, count - len);
+
+			dma_sync_single_for_device(amports_get_dma_device(),
+					block->start,
+					count - len, DMA_TO_DEVICE);
+		}
+	}
+
+	return 0;
+}
+
+static inline u32 vframe_block_space(struct vframe_block_list_s *block)
+{
+	if (block->type == VDEC_TYPE_FRAME_BLOCK) {
+		return block->size - block->wp;
+	} else {
+		return (block->rp >= block->wp) ?
+			   (block->rp - block->wp) :
+			   (block->rp - block->wp + block->size);
+	}
+}
+
+static void vframe_block_add_chunk(struct vframe_block_list_s *block,
+				struct vframe_chunk_s *chunk)
+{
+	block->wp += chunk->size + FRAME_PADDING_SIZE;
+	if (block->wp >= block->size)
+		block->wp -= block->size;
+	block->chunk_count++;
+	chunk->block = block;
+	block->input->wr_block = block;
+	chunk->sequence = block->input->sequence;
+	block->input->sequence++;
+}
+
+static void vframe_block_free_storage(struct vframe_block_list_s *block)
+{
+	if (block->addr) {
+		dma_unmap_single(
+			amports_get_dma_device(),
+			block->start,
+			VFRAME_BLOCK_PAGESIZE,
+			DMA_TO_DEVICE);
+
+		codec_mm_free_for_dma(MEM_NAME,	block->addr);
+
+		block->addr = 0;
+		block->start_virt = NULL;
+		block->start = 0;
+	}
+
+	block->size = 0;
+}
+
+static int vframe_block_init_alloc_storage(struct vdec_input_s *input,
+			struct vframe_block_list_s *block)
+{
+	block->magic = 0x4b434c42;
+	block->input = input;
+	block->type = input->type;
+
+	/*
+	 * todo: for different type use different size
+	 */
+	block->addr = codec_mm_alloc_for_dma(
+		MEM_NAME,
+		VFRAME_BLOCK_PAGESIZE,
+		VFRAME_BLOCK_PAGEALIGN,
+		CODEC_MM_FLAGS_DMA_CPU | CODEC_MM_FLAGS_FOR_VDECODER);
+
+	if (!block->addr) {
+		pr_err("Input block allocation failed\n");
+		return -ENOMEM;
+	}
+
+	block->start_virt = (void *)codec_mm_phys_to_virt(block->addr);
+	block->start = dma_map_single(
+		amports_get_dma_device(),
+		block->start_virt,
+		VFRAME_BLOCK_PAGESIZE,
+		DMA_TO_DEVICE);
+	block->size = VFRAME_BLOCK_PAGESIZE * PAGE_SIZE;
+
+	return 0;
+}
+
+void vdec_input_init(struct vdec_input_s *input, struct vdec_s *vdec)
+{
+	INIT_LIST_HEAD(&input->vframe_block_list);
+	INIT_LIST_HEAD(&input->vframe_chunk_list);
+	spin_lock_init(&input->lock);
+
+	input->vdec = vdec;
+}
+
+int vdec_input_set_buffer(struct vdec_input_s *input, u32 start, u32 size)
+{
+	if (input_frame_based(input))
+		return -EINVAL;
+
+	input->start = start;
+	input->size = size;
+	input->swap_page = alloc_page(GFP_KERNEL);
+
+	if (input->swap_page == NULL)
+		return -ENOMEM;
+
+	return 0;
+}
+
+void vdec_input_set_type(struct vdec_input_s *input, int type, int target)
+{
+	input->type = type;
+	input->target = target;
+}
+
+int vdec_input_get_status(struct vdec_input_s *input,
+			struct vdec_input_status_s *status)
+{
+	unsigned long flags;
+
+	if (input->vdec == NULL)
+		return -EINVAL;
+
+	flags = vdec_input_lock(input);
+
+	if (list_empty(&input->vframe_block_list)) {
+		status->size = VFRAME_BLOCK_SIZE;
+		status->data_len = 0;
+		status->free_len = VFRAME_BLOCK_SIZE;
+		status->read_pointer = 0;
+	} else {
+		int r = VFRAME_BLOCK_MAX_LEVEL - vdec_input_level(input)
+			- VFRAME_BLOCK_HOLE;
+		status->size = input->size;
+		status->data_len = vdec_input_level(input);
+		status->free_len = (r > 0) ? r : 0;
+		status->read_pointer = input->total_rd_count;
+	}
+
+	vdec_input_unlock(input, flags);
+
+	return 0;
+}
+
+static void vdec_input_add_block(struct vdec_input_s *input,
+				struct vframe_block_list_s *block)
+{
+	unsigned long flags;
+
+	flags = vdec_input_lock(input);
+
+	list_add_tail(&block->list, &input->vframe_block_list);
+	input->size += block->size;
+
+	vdec_input_unlock(input, flags);
+}
+
+static void vdec_input_remove_block(struct vdec_input_s *input,
+				struct vframe_block_list_s *block)
+{
+	unsigned long flags;
+
+	flags = vdec_input_lock(input);
+
+	list_del(&block->list);
+	input->size -= block->size;
+
+	vdec_input_unlock(input, flags);
+
+	vframe_block_free_storage(block);
+
+	kfree(block);
+
+	pr_info("block %p removed\n", block);
+}
+
+int vdec_input_level(struct vdec_input_s *input)
+{
+	return input->total_wr_count - input->total_rd_count;
+}
+
+int vdec_input_add_frame(struct vdec_input_s *input, const char *buf,
+			size_t count)
+{
+	unsigned long flags;
+	struct vframe_chunk_s *chunk;
+	struct vdec_s *vdec = input->vdec;
+	struct vframe_block_list_s *block = input->wr_block;
+
+#if 0
+	if (add_count == 0) {
+		add_count++;
+		memcpy(sps, buf, 30);
+		return 30;
+	} else if (add_count == 1) {
+		add_count++;
+		memcpy(pps, buf, 8);
+		return 8;
+	}
+	add_count++;
+#endif
+
+#if 0
+	pr_info("vdec_input_add_frame add %p, count=%d\n", buf, (int)count);
+
+	if (count >= 8) {
+		pr_info("%02x %02x %02x %02x %02x %02x %02x %02x\n",
+		buf[0], buf[1], buf[2], buf[3],
+		buf[4], buf[5], buf[6], buf[7]);
+	}
+	if (count >= 16) {
+		pr_info("%02x %02x %02x %02x %02x %02x %02x %02x\n",
+		buf[8], buf[9], buf[10], buf[11],
+		buf[12], buf[13], buf[14], buf[15]);
+	}
+	if (count >= 24) {
+		pr_info("%02x %02x %02x %02x %02x %02x %02x %02x\n",
+		buf[16], buf[17], buf[18], buf[19],
+		buf[20], buf[21], buf[22], buf[23]);
+	}
+	if (count >= 32) {
+		pr_info("%02x %02x %02x %02x %02x %02x %02x %02x\n",
+		buf[24], buf[25], buf[26], buf[27],
+		buf[28], buf[29], buf[30], buf[31]);
+	}
+#endif
+	if (input_stream_based(input))
+		return -EINVAL;
+
+	/* prepare block to write */
+	if ((!block) || (block &&
+		(vframe_block_space(block) < (count + FRAME_PADDING_SIZE)))) {
+		/* switch to another block for the added chunk */
+		struct vframe_block_list_s *new_block;
+
+#if 0
+		pr_info("Adding new block, total level = %d, total_wr_count=%d, total_rd_count=%d\n",
+			vdec_input_level(input),
+			(int)input->total_wr_count,
+			(int)input->total_rd_count);
+#endif
+
+		if ((!list_empty(&input->vframe_block_list)) &&
+			(block->type == VDEC_TYPE_FRAME_CIRCULAR))
+			return -EAGAIN;
+		else {
+			/* todo: add input limit check for
+			 * VDEC_TYPE_FRAME_BLOCK
+			 */
+			if (vdec_input_level(input) >
+				VFRAME_BLOCK_MAX_LEVEL) {
+				pr_info("vdec_input %p reaching max size\n",
+					input);
+				return -EAGAIN;
+			}
+		}
+
+		/* check next block of current wr_block, it should be an empty
+		 * block to use
+		 */
+		if ((block) && (!list_is_last(
+			&block->list, &input->vframe_block_list))) {
+			block = list_next_entry(block, list);
+
+			if (vframe_block_space(block) != VFRAME_BLOCK_SIZE)
+				/* should never happen */
+				pr_err("next writing block not empty.\n");
+		} else {
+			/* add a new block into input list */
+			new_block = kzalloc(sizeof(struct vframe_block_list_s),
+					GFP_KERNEL);
+			if (new_block == NULL) {
+				pr_err("vframe_block structure allocation failed\n");
+				return -EAGAIN;
+			}
+
+			if (vframe_block_init_alloc_storage(input,
+				new_block) != 0) {
+				kfree(new_block);
+				pr_err("vframe_block storage allocation failed\n");
+				return -EAGAIN;
+			}
+
+			INIT_LIST_HEAD(&new_block->list);
+
+			vdec_input_add_block(input, new_block);
+
+			/* pr_info("added new block %p\n", new_block); */
+
+			block = new_block;
+		}
+	}
+
+	chunk = kzalloc(sizeof(struct vframe_chunk_s), GFP_KERNEL);
+
+	if (!chunk) {
+		pr_err("vframe_chunk structure allocation failed\n");
+		return -ENOMEM;
+	}
+
+	chunk->magic = 0x4b554843;
+	if (vdec->pts_valid) {
+		chunk->pts = vdec->pts;
+		chunk->pts64 = vdec->pts64;
+	}
+	chunk->pts_valid = vdec->pts_valid;
+	vdec->pts_valid = false;
+	chunk->offset = block->wp;
+	chunk->size = count;
+
+	INIT_LIST_HEAD(&chunk->list);
+
+	if (vframe_chunk_fill(input, chunk, buf, count, block)) {
+		pr_err("vframe_chunk_fill failed\n");
+		kfree(chunk);
+		return -EFAULT;
+	}
+
+	flags = vdec_input_lock(input);
+
+	vframe_block_add_chunk(block, chunk);
+
+	list_add_tail(&chunk->list, &input->vframe_chunk_list);
+
+	vdec_input_unlock(input, flags);
+
+	input->total_wr_count += count;
+
+#if 0
+	if (add_count == 2)
+		input->total_wr_count += 38;
+#endif
+
+	return count;
+}
+
+struct vframe_chunk_s *vdec_input_next_chunk(struct vdec_input_s *input)
+{
+	if (list_empty(&input->vframe_chunk_list))
+		return NULL;
+
+	return list_first_entry(&input->vframe_chunk_list,
+				struct vframe_chunk_s, list);
+}
+
+struct vframe_chunk_s *vdec_input_next_input_chunk(
+			struct vdec_input_s *input)
+{
+	struct vframe_chunk_s *chunk = NULL;
+	struct list_head *p;
+
+	list_for_each(p, &input->vframe_chunk_list) {
+		struct vframe_chunk_s *c = list_entry(
+			p, struct vframe_chunk_s, list);
+		if ((c->flag & VFRAME_CHUNK_FLAG_CONSUMED) == 0) {
+			chunk = c;
+			break;
+		}
+	}
+
+	return chunk;
+}
+
+void vdec_input_release_chunk(struct vdec_input_s *input,
+			struct vframe_chunk_s *chunk)
+{
+	unsigned long flags;
+	struct vframe_block_list_s *block = chunk->block;
+
+	flags = vdec_input_lock(input);
+
+	list_del(&chunk->list);
+
+	block->rp += chunk->size;
+	if (block->rp >= block->size)
+		block->rp -= block->size;
+	block->chunk_count--;
+	input->total_rd_count += chunk->size;
+
+	if (block->chunk_count == 0) {
+		/* reuse the block */
+		block->wp = 0;
+		block->rp = 0;
+
+		if ((input->wr_block == block) &&
+			(!list_is_last(&block->list,
+				&input->vframe_block_list)))
+			input->wr_block = list_next_entry(block, list);
+
+		list_move_tail(&block->list, &input->vframe_block_list);
+	}
+
+	vdec_input_unlock(input, flags);
+
+	kfree(chunk);
+}
+
+unsigned long vdec_input_lock(struct vdec_input_s *input)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&input->lock, flags);
+
+	return flags;
+}
+
+void vdec_input_unlock(struct vdec_input_s *input, unsigned long flags)
+{
+	spin_unlock_irqrestore(&input->lock, flags);
+}
+
+void vdec_input_release(struct vdec_input_s *input)
+{
+	struct list_head *p, *tmp;
+
+	/* release chunk data */
+	list_for_each_safe(p, tmp, &input->vframe_chunk_list) {
+		struct vframe_chunk_s *chunk = list_entry(
+				p, struct vframe_chunk_s, list);
+		vdec_input_release_chunk(input, chunk);
+	}
+
+	/* release input blocks */
+	list_for_each_safe(p, tmp, &input->vframe_block_list) {
+		struct vframe_block_list_s *block = list_entry(
+			p, struct vframe_block_list_s, list);
+		vdec_input_remove_block(input, block);
+	}
+
+	/* release swap page */
+	if (input->swap_page) {
+		__free_page(input->swap_page);
+		input->swap_page = NULL;
+		input->swap_valid = false;
+	}
+}
+
+
+
+
diff --git a/drivers/amlogic/amports/vdec_input.h b/drivers/amlogic/amports/vdec_input.h
new file mode 100644
index 0000000..8b8d06c
--- /dev/null
+++ b/drivers/amlogic/amports/vdec_input.h
@@ -0,0 +1,115 @@
+#ifndef VDEC_INPUT_H
+#define VDEC_INPUT_H
+
+struct vdec_s;
+struct vdec_input_s;
+
+struct vframe_block_list_s {
+	u32 magic;
+	struct list_head list;
+	ulong start;
+	void *start_virt;
+	ulong addr;
+	int type;
+	u32 size;
+	u32 wp;
+	u32 rp;
+	int chunk_count;
+	struct vdec_input_s *input;
+};
+
+#define VFRAME_CHUNK_FLAG_CONSUMED  0x0001
+
+struct vframe_chunk_s {
+	u32 magic;
+	struct list_head list;
+	int flag;
+	u32 offset;
+	u32 size;
+	u32 pts;
+	u64 pts64;
+	bool pts_valid;
+	u64 sequence;
+	struct vframe_block_list_s *block;
+};
+
+#define VDEC_INPUT_TARGET_VLD           0
+#define VDEC_INPUT_TARGET_HEVC          1
+
+struct vdec_input_s {
+	struct list_head vframe_block_list;
+	struct list_head vframe_chunk_list;
+	struct vframe_block_list_s *wr_block;
+	spinlock_t lock;
+	int type;
+	int target;
+	struct vdec_s *vdec;
+	bool swap_valid;
+	bool swap_needed;
+	struct page *swap_page;
+	int total_wr_count;
+	int total_rd_count;
+	u64 sequence;
+	unsigned start;
+	unsigned size;
+	int stream_cookie; /* wrap count for vld_mem and
+			      HEVC_SHIFT_BYTE_COUNT for hevc */
+};
+
+struct vdec_input_status_s {
+	int size;
+	int data_len;
+	int free_len;
+	int read_pointer;
+};
+
+#define input_frame_based(input) \
+	(((input)->type == VDEC_TYPE_FRAME_BLOCK) || \
+	 ((input)->type == VDEC_TYPE_FRAME_CIRCULAR))
+#define input_stream_based(input) \
+	(((input)->type == VDEC_TYPE_STREAM_PARSER) || \
+	 ((input)->type == VDEC_TYPE_SINGLE))
+
+/* Initialize vdec_input structure */
+extern void vdec_input_init(struct vdec_input_s *input, struct vdec_s *vdec);
+
+/* Get available input data size */
+extern int vdec_input_level(struct vdec_input_s *input);
+
+/* Set input type and target */
+extern void vdec_input_set_type(struct vdec_input_s *input, int type,
+			int target);
+
+/* Set stream buffer information for stream based input */
+extern int vdec_input_set_buffer(struct vdec_input_s *input, u32 start,
+			u32 size);
+
+/* Add enqueue video data into decoder's input */
+extern int vdec_input_add_frame(struct vdec_input_s *input, const char *buf,
+			size_t count);
+
+/* Peek next frame data from decoder's input */
+extern struct vframe_chunk_s *vdec_input_next_chunk(
+			struct vdec_input_s *input);
+
+/* Peek next frame data from decoder's input, not marked as consumed */
+extern struct vframe_chunk_s *vdec_input_next_input_chunk(
+			struct vdec_input_s *input);
+
+/* Consume next frame data from decoder's input */
+extern void vdec_input_release_chunk(struct vdec_input_s *input,
+			struct vframe_chunk_s *chunk);
+
+/* Get decoder input buffer status */
+extern int vdec_input_get_status(struct vdec_input_s *input,
+			struct vdec_input_status_s *status);
+
+extern unsigned long vdec_input_lock(struct vdec_input_s *input);
+
+extern void vdec_input_unlock(struct vdec_input_s *input, unsigned long lock);
+
+/* release all resource for decoder's input */
+extern void vdec_input_release(struct vdec_input_s *input);
+
+#endif /* VDEC_INPUT_H */
+
diff --git a/drivers/amlogic/amports/vdec_profile.c b/drivers/amlogic/amports/vdec_profile.c
new file mode 100644
index 0000000..6c3130d
--- /dev/null
+++ b/drivers/amlogic/amports/vdec_profile.c
@@ -0,0 +1,177 @@
+/*
+ * drivers/amlogic/amports/vdec_profile.c
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/types.h>
+#include <linux/debugfs.h>
+
+#include "vdec_reg.h"
+#include "vdec_profile.h"
+
+#define ISA_TIMERE 0x2662
+#define ISA_TIMERE_HI 0x2663
+
+#define PROFILE_REC_SIZE 40
+
+static DEFINE_MUTEX(vdec_profile_mutex);
+static int rec_wp;
+static bool rec_wrapped;
+
+struct vdec_profile_rec_s {
+	struct vdec_s *vdec;
+	u64 timestamp;
+	int event;
+};
+
+static struct vdec_profile_rec_s recs[PROFILE_REC_SIZE];
+static const char *event_name[VDEC_PROFILE_MAX_EVENT] = {
+	"run",
+	"cb",
+	"save_input",
+	"check run ready",
+	"run ready",
+	"disconnect",
+	"dec_work"
+};
+
+static u64 get_us_time(void)
+{
+	u32 lo, hi1, hi2;
+
+	do {
+		hi1 = READ_MPEG_REG(ISA_TIMERE_HI);
+		lo = READ_MPEG_REG(ISA_TIMERE);
+		hi2 = READ_MPEG_REG(ISA_TIMERE_HI);
+	} while (hi1 != hi2);
+
+	return (((u64)hi1) << 32) | lo;
+}
+
+void vdec_profile(struct vdec_s *vdec, int event)
+{
+	mutex_lock(&vdec_profile_mutex);
+
+	recs[rec_wp].vdec = vdec;
+	recs[rec_wp].timestamp = get_us_time();
+	recs[rec_wp].event = event;
+
+	rec_wp++;
+	if (rec_wp == PROFILE_REC_SIZE) {
+		rec_wrapped = true;
+		rec_wp = 0;
+	}
+
+	mutex_unlock(&vdec_profile_mutex);
+}
+
+void vdec_profile_flush(struct vdec_s *vdec)
+{
+	int i;
+
+	mutex_lock(&vdec_profile_mutex);
+
+	for (i = 0; i < PROFILE_REC_SIZE; i++) {
+		if (recs[i].vdec == vdec)
+			recs[i].vdec = NULL;
+	}
+
+	mutex_unlock(&vdec_profile_mutex);
+}
+
+static const char *event_str(int event)
+{
+	if (event < VDEC_PROFILE_MAX_EVENT)
+		return event_name[event];
+
+	return "INVALID";
+}
+
+static int vdec_profile_dbg_show(struct seq_file *m, void *v)
+{
+	int i, end;
+	u64 base_timestamp;
+
+	mutex_lock(&vdec_profile_mutex);
+
+	if (rec_wrapped) {
+		i = rec_wp;
+		end = rec_wp - 1;
+		if (end < 0)
+			end = PROFILE_REC_SIZE - 1;
+	} else {
+		i = 0;
+		end = rec_wp;
+	}
+
+	base_timestamp = recs[i].timestamp;
+	for (; i != end; ) {
+		if (recs[i].vdec) {
+			seq_printf(m, "[%s:%d] %016llu us : %s\n",
+				vdec_device_name_str(recs[i].vdec),
+				recs[i].vdec->id,
+				recs[i].timestamp - base_timestamp,
+				event_str(recs[i].event));
+		}
+
+		if (++i == PROFILE_REC_SIZE)
+			i = 0;
+	}
+
+	mutex_unlock(&vdec_profile_mutex);
+
+	return 0;
+}
+
+static int vdec_profile_dbg_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, vdec_profile_dbg_show, NULL);
+}
+
+static const struct file_operations event_dbg_fops = {
+	.open    = vdec_profile_dbg_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = single_release,
+};
+
+static int __init vdec_profile_init_debugfs(void)
+{
+	struct dentry *root, *event;
+
+	root = debugfs_create_dir("vdec_profile", NULL);
+	if (IS_ERR(root) || !root)
+		goto err;
+
+	event = debugfs_create_file("event", 0400, root, NULL,
+			&event_dbg_fops);
+	if (!event)
+		goto err_1;
+
+	mutex_init(&vdec_profile_mutex);
+
+	return 0;
+
+err_1:
+	debugfs_remove(root);
+err:
+	pr_err("Can not create debugfs for vdec_profile\n");
+	return 0;
+}
+
+module_init(vdec_profile_init_debugfs);
+
diff --git a/drivers/amlogic/amports/vdec_profile.h b/drivers/amlogic/amports/vdec_profile.h
new file mode 100644
index 0000000..01a89c4
--- /dev/null
+++ b/drivers/amlogic/amports/vdec_profile.h
@@ -0,0 +1,36 @@
+/*
+ * drivers/amlogic/amports/vdec_profile.h
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef VDEC_PROFILE_H
+#define VDEC_PROFILE_H
+
+struct vdec_s;
+
+#define VDEC_PROFILE_EVENT_RUN         0
+#define VDEC_PROFILE_EVENT_CB          1
+#define VDEC_PROFILE_EVENT_SAVE_INPUT  2
+#define VDEC_PROFILE_EVENT_CHK_RUN_READY 3
+#define VDEC_PROFILE_EVENT_RUN_READY   4
+#define VDEC_PROFILE_EVENT_DISCONNECT  5
+#define VDEC_PROFILE_EVENT_DEC_WORK    6
+#define VDEC_PROFILE_MAX_EVENT         7
+
+extern void vdec_profile(struct vdec_s *vdec, int event);
+
+extern void vdec_profile_flush(struct vdec_s *vdec);
+
+#endif /* VDEC_PROFILE_H */
diff --git a/drivers/amlogic/amports/vh264.c b/drivers/amlogic/amports/vh264.c
index e584814..d05bd7c 100644
--- a/drivers/amlogic/amports/vh264.c
+++ b/drivers/amlogic/amports/vh264.c
@@ -44,6 +44,8 @@
 #include "amvdec.h"
 #include "vh264.h"
 #include "streambuf.h"
+#include "decoder/decoder_bmmu_box.h"
+
 #include <linux/delay.h>
 
 #include <linux/amlogic/ge2d/ge2d.h>
@@ -51,13 +53,11 @@
 #define DRIVER_NAME "amvdec_h264"
 #define MODULE_NAME "amvdec_h264"
 #define MEM_NAME "codec_264"
-
 #define HANDLE_H264_IRQ
 /* #define DEBUG_PTS */
 #if 0 /* MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6TV */
 #define DROP_B_FRAME_FOR_1080P_50_60FPS
 #endif
-
 #define RATE_MEASURE_NUM 8
 #define RATE_CORRECTION_THRESHOLD 5
 #define RATE_24_FPS  4004	/* 23.97 */
@@ -187,6 +187,8 @@ static struct vframe_s vfpool[VF_POOL_SIZE];
 static s32 vfbuf_use[VF_BUF_NUM];
 static struct buffer_spec_s buffer_spec[VF_BUF_NUM];
 static struct buffer_spec_s fense_buffer_spec[2];
+#define MAX_BLK_BUFFERS (VF_BUF_NUM + 3)
+#define FENSE_BUFFER_IDX(n) (VF_BUF_NUM + n)
 static struct vframe_s fense_vf[2];
 
 static struct timer_list recycle_timer;
@@ -201,6 +203,7 @@ static u32 dec_control;
 static u32 vh264_ratio;
 static u32 vh264_rotation;
 static u32 use_idr_framerate;
+static u32 high_bandwith;
 
 static u32 seq_info;
 static u32 timing_info_present_flag;
@@ -211,6 +214,8 @@ static u32 num_units_in_tick;
 static u32 time_scale;
 static u32 h264_ar;
 static u32 decoder_debug_flag;
+static u32 dpb_size_adj = 6;
+
 #ifdef DROP_B_FRAME_FOR_1080P_50_60FPS
 static u32 last_interlaced;
 #endif
@@ -225,6 +230,10 @@ static u32 fatal_error_flag;
 static u32 fatal_error_reset;
 static u32 max_refer_buf = 1;
 static u32 decoder_force_reset;
+static unsigned int no_idr_error_count;
+static unsigned int no_idr_error_max = 60;
+static unsigned int enable_switch_fense = 1;
+#define EN_SWITCH_FENCE() (enable_switch_fense && !is_4k)
 #if 0
 static u32 vh264_no_disp_wd_count;
 #endif
@@ -233,6 +242,7 @@ static s32 vh264_stream_switching_state;
 static s32 vh264_eos;
 static struct vframe_s *p_last_vf;
 static s32 iponly_early_mode;
+static void *mm_blk_handle;
 
 /*TODO irq*/
 #if 1
@@ -244,11 +254,12 @@ static bool check_pts_discontinue;
 static u32 wait_buffer_counter;
 static u32 video_signal_from_vui;
 
-static uint error_recovery_mode = 1;
+static uint error_recovery_mode;
 static uint error_recovery_mode_in = 3;
 static uint error_recovery_mode_use = 3;
 
 static uint mb_total = 0, mb_width = 0, mb_height;
+static uint saved_idc_level;
 #define UCODE_IP_ONLY 2
 #define UCODE_IP_ONLY_PARAM 1
 static uint ucode_type;
@@ -423,7 +434,7 @@ static void prepare_display_q(void)
 		kfifo_len(&newframe_q);
 
 	if ((vh264_stream_switching_state != SWITCHING_STATE_OFF)
-		|| is_4k)
+		|| !EN_SWITCH_FENCE())
 		count = 0;
 	else
 		count = (count < 2) ? 0 : 2;
@@ -652,6 +663,10 @@ static void vh264_set_params(struct work_struct *work)
 	num_units_in_tick = READ_VREG(AV_SCRATCH_4);
 	time_scale = READ_VREG(AV_SCRATCH_5);
 	level_idc = READ_VREG(AV_SCRATCH_A);
+	if (level_idc > 0)
+		saved_idc_level = level_idc;
+	else if (saved_idc_level > 0)
+		level_idc = saved_idc_level;
 	video_signal = READ_VREG(AV_SCRATCH_H);
 	video_signal_from_vui =
 				((video_signal & 0xffff) << 8) |
@@ -752,14 +767,21 @@ static void vh264_set_params(struct work_struct *work)
 
 	 /*max_reference_size <= max_dpb_size <= actual_dpb_size*/
 	 is_4k = (mb_total > 8160) ? true:false;
-	if (is_4k) {
+
+	if (is_4k || dpb_size_adj) {
 		/*4k2k*/
 		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
 			max_dpb_size = get_max_dpb_size(
 					level_idc, mb_width, mb_height);
-			actual_dpb_size = max_dpb_size + 4;
-		      if (actual_dpb_size > VF_BUF_NUM)
-			actual_dpb_size = VF_BUF_NUM;
+			actual_dpb_size = max_dpb_size + 5;
+			if (dpb_size_adj)
+				actual_dpb_size
+				= max_reference_size + dpb_size_adj;
+			if (actual_dpb_size > VF_BUF_NUM)
+				actual_dpb_size = VF_BUF_NUM;
+			pr_info
+			("actual_dpb_size %d max_ref_size %d\n",
+			actual_dpb_size, max_reference_size);
 		} else {
 			vh264_running = 0;
 			fatal_error_flag =
@@ -772,7 +794,12 @@ static void vh264_set_params(struct work_struct *work)
 		actual_dpb_size = (frame_buffer_size - mb_total * mb_mv_byte *
 				max_reference_size) / (mb_total * 384);
 		actual_dpb_size = min(actual_dpb_size, VF_BUF_NUM);
+
 		max_dpb_size = get_max_dpb_size(level_idc, mb_width, mb_height);
+		if (max_reference_size > 1)
+			max_dpb_size = max_reference_size - 1;
+		else
+			max_dpb_size = max_reference_size;
 		if (actual_dpb_size < (max_dpb_size + 4)) {
 			actual_dpb_size = max_dpb_size + 4;
 			if (actual_dpb_size > VF_BUF_NUM)
@@ -781,6 +808,7 @@ static void vh264_set_params(struct work_struct *work)
 		 pr_info("actual_dpb_size %d max_dpb_size %d\n",
 				 actual_dpb_size, max_dpb_size);
 	}
+
 	if (max_dpb_size == 0)
 		max_dpb_size = actual_dpb_size;
 	else
@@ -827,53 +855,37 @@ static void vh264_set_params(struct work_struct *work)
 					PAGE_ALIGN((mb_total << 8) +
 						(mb_total << 7)) / PAGE_SIZE;
 #endif
-				if (buffer_spec[i].phy_addr) {
-					if (page_count !=
-						buffer_spec[i].alloc_count) {
-						pr_info("Delay release cma	buf %d\n",
-							i);
-						codec_mm_free_for_dma(MEM_NAME,
-						buffer_spec[i].phy_addr);
-						buffer_spec[i].phy_addr = 0;
-						buffer_spec[i].alloc_count = 0;
-					} else
-					pr_info("Re-use CMA buffer %d\n", i);
-				}
-				if (!buffer_spec[i].phy_addr) {
-					if (!codec_mm_enough_for_size(
-						page_count * PAGE_SIZE)) {
-						buffer_spec[i].alloc_count = 0;
-						fatal_error_flag =
-						DECODER_FATAL_ERROR_NO_MEM;
-						vh264_running = 0;
-						mutex_unlock(&vh264_mutex);
-						pr_err("CMA  not enough mem! %d\n",
-							i);
-						return;
-					}
-					buffer_spec[i].alloc_count = page_count;
+				buffer_spec[i].alloc_count = page_count;
+				if (!decoder_bmmu_box_alloc_idx_wait(
+					mm_blk_handle,
+					i,
+					page_count << PAGE_SHIFT,
+					-1,
+					-1,
+					BMMU_ALLOC_FLAGS_WAITCLEAR
+					)) {
 					buffer_spec[i].phy_addr =
-						codec_mm_alloc_for_dma(MEM_NAME,
-						buffer_spec[i].alloc_count,
-						4 + PAGE_SHIFT,
-						CODEC_MM_FLAGS_CMA_CLEAR |
-						CODEC_MM_FLAGS_FOR_VDECODER);
+						decoder_bmmu_box_get_phy_addr(
+							mm_blk_handle,
+							i);
 					pr_info("CMA malloc ok  %d\n", i);
-				}
-				alloc_count++;
-				if (!buffer_spec[i].phy_addr) {
+					alloc_count++;
+				} else {
 					buffer_spec[i].alloc_count = 0;
-					pr_err("264-4k mem alloc failed %d\n",
-						i);
+					fatal_error_flag =
+					DECODER_FATAL_ERROR_NO_MEM;
 					vh264_running = 0;
 					mutex_unlock(&vh264_mutex);
+					pr_err("CMA  not enough mem! %d\n",
+						i);
 					return;
 				}
 				addr = buffer_spec[i].phy_addr;
 			} else {
 					if (buffer_spec[i].phy_addr) {
-						codec_mm_free_for_dma(MEM_NAME,
-						buffer_spec[i].phy_addr);
+						decoder_bmmu_box_free_idx(
+							mm_blk_handle,
+							i);
 						buffer_spec[i].phy_addr = 0;
 						buffer_spec[i].alloc_count = 0;
 					}
@@ -1124,7 +1136,13 @@ static inline bool vh264_isr_parser(struct vframe_s *vf,
 		h264_pts_count = 0;
 		h264_first_pts_ready = 1;
 	} else {
-
+		if (pts < h264pts1) {
+			if (h264_pts_count > 24) {
+				pr_info("invalid h264pts1, reset\n");
+				h264pts1 = pts;
+				h264_pts_count = 0;
+			}
+		}
 		if (pts_valid && (pts > h264pts1) && (h264_pts_count > 24)
 				&& (duration_from_pts_done == 0)) {
 			unsigned int
@@ -1279,11 +1297,15 @@ static void vh264_isr(void)
 		(frame_height >= 1000) && (last_interlaced == 0))
 		SET_VREG_MASK(AV_SCRATCH_F, 0x8);
 #endif
-	if (decoder_force_reset == 1) {
+	if ((decoder_force_reset == 1)
+			|| ((error_recovery_mode != 1)
+			&& (no_idr_error_count >= no_idr_error_max)
+			&& (ucode_type != UCODE_IP_ONLY_PARAM))) {
 		vh264_running = 0;
-		pr_info("force reset decoder !!!\n");
+		pr_info("force reset decoder  %d!!!\n", no_idr_error_count);
 		schedule_work(&error_wd_work);
 		decoder_force_reset = 0;
+		no_idr_error_count = 0;
 	} else if ((cpu_cmd & 0xff) == 1) {
 		if (unlikely
 			(vh264_running
@@ -1356,9 +1378,18 @@ static void vh264_isr(void)
 				vh264_eos = 1;
 
 			b_offset = (status >> 16) & 0xffff;
+
+			if (error)
+				no_idr_error_count++;
+			if (idr_flag ||
+				(!error && (slice_type != SLICE_TYPE_I)))
+				no_idr_error_count = 0;
+
 			if (decoder_debug_flag) {
-				pr_info("slice_type %x idr %x  error %x",
-						slice_type, idr_flag, error);
+				pr_info
+				("slice_type %x idr %x error %x count %d",
+					slice_type, idr_flag, error,
+					no_idr_error_count);
 				pr_info(" prog %x pic_struct %x offset %x\n",
 				prog_frame, pic_struct,	b_offset);
 			}
@@ -1632,7 +1663,10 @@ static void vh264_isr(void)
 					spec2canvas(&buffer_spec[buffer_index]);
 				vf->type_original = vf->type;
 				vfbuf_use[buffer_index]++;
-
+				vf->mem_handle =
+					decoder_bmmu_box_get_mem_handle(
+						mm_blk_handle,
+						buffer_index);
 				if ((error_recovery_mode_use & 2) && error) {
 					kfifo_put(&recycle_q,
 						(const struct vframe_s *)vf);
@@ -1658,6 +1692,13 @@ static void vh264_isr(void)
 				vf->type |= VIDTYPE_VIU_NV21;
 				vf->type |= VIDTYPE_INTERLACE_FIRST;
 
+				high_bandwith |=
+				((codec_mm_get_total_size() < 80 * SZ_1M)
+				& ((READ_VREG(AV_SCRATCH_N) & 0xf) == 3)
+				& ((frame_width * frame_height) >= 1920*1080));
+				if (high_bandwith)
+					vf->flag |= VFRAME_FLAG_HIGH_BANDWITH;
+
 				vf->duration >>= 1;
 				vf->duration_pulldown = 0;
 				vf->signal_type = video_signal_from_vui;
@@ -1672,7 +1713,10 @@ static void vh264_isr(void)
 				vf->type_original = vf->type;
 				vfbuf_use[buffer_index]++;
 				vf->ready_jiffies64 = jiffies_64;
-
+				vf->mem_handle =
+					decoder_bmmu_box_get_mem_handle(
+						mm_blk_handle,
+						buffer_index);
 				if ((error_recovery_mode_use & 2) && error) {
 					kfifo_put(&recycle_q,
 						(const struct vframe_s *)vf);
@@ -1719,10 +1763,15 @@ static void vh264_isr(void)
 					spec2canvas(&buffer_spec[buffer_index]);
 				vf->type_original = vf->type;
 				vfbuf_use[buffer_index]++;
+				if (high_bandwith)
+					vf->flag |= VFRAME_FLAG_HIGH_BANDWITH;
 
 				p_last_vf = vf;
 				vf->ready_jiffies64 = jiffies_64;
-
+				vf->mem_handle =
+					decoder_bmmu_box_get_mem_handle(
+						mm_blk_handle,
+						buffer_index);
 				kfifo_put(&delay_display_q,
 						(const struct vframe_s *)vf);
 			}
@@ -1800,6 +1849,9 @@ static void vh264_isr(void)
 			vf->canvas0Addr = vf->canvas1Addr =
 					spec2canvas(&buffer_spec[buffer_index]);
 			vf->type_original = vf->type;
+			vf->mem_handle = decoder_bmmu_box_get_mem_handle(
+					mm_blk_handle,
+					buffer_index);
 			vfbuf_use[buffer_index]++;
 			p_last_vf = vf;
 			pts_discontinue = false;
@@ -2013,7 +2065,7 @@ static void vh264_put_timer_func(unsigned long arg)
 	add_timer(timer);
 }
 
-int vh264_dec_status(struct vdec_status *vstatus)
+int vh264_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
 {
 	vstatus->width = frame_width;
 	vstatus->height = frame_height;
@@ -2028,7 +2080,7 @@ int vh264_dec_status(struct vdec_status *vstatus)
 	return 0;
 }
 
-int vh264_set_trickmode(unsigned long trickmode)
+int vh264_set_trickmode(struct vdec_s *vdec, unsigned long trickmode)
 {
 	if (trickmode == TRICKMODE_I) {
 		WRITE_VREG(AV_SCRATCH_F,
@@ -2091,6 +2143,7 @@ static void vh264_prot_init(void)
 	WRITE_VREG(AV_SCRATCH_7, 0);
 	WRITE_VREG(AV_SCRATCH_8, 0);
 	WRITE_VREG(AV_SCRATCH_9, 0);
+	WRITE_VREG(AV_SCRATCH_N, 0);
 
 	error_recovery_mode_use =
 		(error_recovery_mode !=
@@ -2145,6 +2198,14 @@ static void vh264_local_init(void)
 				& 0x04) >> 2;
 	max_refer_buf = !(((unsigned long) vh264_amstream_dec_info.param
 				& 0x10) >> 4);
+	if (!mm_blk_handle)
+		mm_blk_handle = decoder_bmmu_box_alloc_box(
+			DRIVER_NAME,
+			0,
+			MAX_BLK_BUFFERS,
+			4 + PAGE_SHIFT,
+			CODEC_MM_FLAGS_CMA_CLEAR |
+			CODEC_MM_FLAGS_FOR_VDECODER);
 
 	pr_info
 	("H264 sysinfo: %dx%d duration=%d, pts_outside=%d, ",
@@ -2199,12 +2260,14 @@ static void vh264_local_init(void)
 	wait_buffer_counter = 0;
 	vh264_no_disp_count = 0;
 	fatal_error_flag = 0;
+	high_bandwith = 0;
 	vh264_stream_switching_state = SWITCHING_STATE_OFF;
 #ifdef DEBUG_PTS
 	pts_missed = 0;
 	pts_hit = 0;
 #endif
 	pts_discontinue = false;
+	no_idr_error_count = 0;
 	return;
 }
 
@@ -2229,6 +2292,7 @@ static s32 vh264_init(void)
 	fixed_frame_rate_check_count = 0;
 	saved_resolution = 0;
 	iponly_early_mode = 0;
+	saved_idc_level = 0;
 	vh264_local_init();
 
 	query_video_status(0, &trickmode_fffb);
@@ -2400,22 +2464,29 @@ static s32 vh264_init(void)
 	}
 
 	stat |= STAT_MC_LOAD;
-
-	for (i = 0; i < ARRAY_SIZE(fense_buffer_spec); i++) {
-		struct buffer_spec_s *s = &fense_buffer_spec[i];
-		if (!codec_mm_enough_for_size(3 * SZ_1M))
-			return -ENOMEM;
-
-		s->alloc_count = 3 * SZ_1M / PAGE_SIZE;
-		s->phy_addr = codec_mm_alloc_for_dma(MEM_NAME,
-			s->alloc_count,
-			4 + PAGE_SHIFT,
-			CODEC_MM_FLAGS_CMA_CLEAR | CODEC_MM_FLAGS_FOR_VDECODER);
-		s->y_canvas_index = 2 * i;
-		s->u_canvas_index = 2 * i + 1;
-		s->v_canvas_index = 2 * i + 1;
+	if (enable_switch_fense) {
+		for (i = 0; i < ARRAY_SIZE(fense_buffer_spec); i++) {
+			struct buffer_spec_s *s = &fense_buffer_spec[i];
+			s->alloc_count = 3 * SZ_1M / PAGE_SIZE;
+			if (!decoder_bmmu_box_alloc_idx_wait(
+					mm_blk_handle,
+					FENSE_BUFFER_IDX(i),
+					3 * SZ_1M,
+					-1,
+					-1,
+					BMMU_ALLOC_FLAGS_WAITCLEAR
+					)) {
+				s->phy_addr = decoder_bmmu_box_get_phy_addr(
+					mm_blk_handle,
+					FENSE_BUFFER_IDX(i));
+			} else {
+				return -ENOMEM;
+			}
+			s->y_canvas_index = 2 * i;
+			s->u_canvas_index = 2 * i + 1;
+			s->v_canvas_index = 2 * i + 1;
+		}
 	}
-
 	/* enable AMRISC side protocol */
 	vh264_prot_init();
 
@@ -2464,8 +2535,6 @@ static s32 vh264_init(void)
 	/* -- start decoder */
 	amvdec_start();
 
-	set_vdec_func(&vh264_dec_status);
-	set_trickmode_func(&vh264_set_trickmode);
 	init_userdata_fifo();
 
 	return 0;
@@ -2473,7 +2542,7 @@ static s32 vh264_init(void)
 
 static int vh264_stop(int mode)
 {
-	int i;
+
 
 	if (stat & STAT_VDEC_RUN) {
 		amvdec_stop();
@@ -2523,29 +2592,12 @@ static int vh264_stop(int mode)
 		sei_data_buffer_phys = 0;
 	}
 	amvdec_disable();
-
-	for (i = 0; i < ARRAY_SIZE(fense_buffer_spec); i++) {
-		if (fense_buffer_spec[i].phy_addr) {
-			codec_mm_free_for_dma(MEM_NAME,
-				fense_buffer_spec[i].phy_addr);
-			fense_buffer_spec[i].phy_addr = 0;
-			fense_buffer_spec[i].alloc_count = 0;
-		}
+	if (mm_blk_handle) {
+		decoder_bmmu_box_free(mm_blk_handle);
+		mm_blk_handle = NULL;
 	}
-
-	  for (i = 0; i < ARRAY_SIZE(buffer_spec); i++) {
-			if (buffer_spec[i].phy_addr) {
-				if (is_4k && !get_blackout_policy())
-					pr_info("Skip releasing CMA buffer %d\n",
-								i);
-				else {
-					codec_mm_free_for_dma(MEM_NAME,
-					buffer_spec[i].phy_addr);
-					buffer_spec[i].phy_addr = 0;
-					buffer_spec[i].alloc_count = 0;
-				}
-			}
-	  }
+	memset(&fense_buffer_spec, 0, sizeof(fense_buffer_spec));
+	memset(&buffer_spec, 0, sizeof(buffer_spec));
 	return 0;
 }
 
@@ -2670,7 +2722,7 @@ static void stream_switching_do(struct work_struct *work)
 			buffer_spec[buffer_index].u_canvas_width,
 			buffer_spec[buffer_index].u_canvas_height);
 #endif
-		if (!is_4k) {
+		if (EN_SWITCH_FENCE()) {
 			y_index = buffer_spec[buffer_index].y_canvas_index;
 			u_index = buffer_spec[buffer_index].u_canvas_index;
 
@@ -2704,15 +2756,17 @@ static void stream_switching_do(struct work_struct *work)
 				src_index,
 				des_index);
 		}
+		vf->mem_handle = decoder_bmmu_box_get_mem_handle(
+			mm_blk_handle,
+			FENSE_BUFFER_IDX(i));
 		fense_vf[i] = *vf;
 		fense_vf[i].index = -1;
 
-		if (!is_4k)
+		if (EN_SWITCH_FENCE())
 			fense_vf[i].canvas0Addr =
 				spec2canvas(&fense_buffer_spec[i]);
 		else
 			fense_vf[i].flag |= VFRAME_FLAG_SWITCHING_FENSE;
-
 		/* send clone to receiver */
 		kfifo_put(&display_q,
 			(const struct vframe_s *)&fense_vf[i]);
@@ -2737,8 +2791,7 @@ static void stream_switching_do(struct work_struct *work)
 
 static int amvdec_h264_probe(struct platform_device *pdev)
 {
-	struct vdec_dev_reg_s *pdata =
-		(struct vdec_dev_reg_s *)pdev->dev.platform_data;
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
 
 	mutex_lock(&vh264_mutex);
 
@@ -2781,6 +2834,8 @@ static int amvdec_h264_probe(struct platform_device *pdev)
 	}
 	pr_debug("amvdec_h264 mem-addr=%lx,buff_offset=%x,buf_start=%lx buf_size %x\n",
 		   pdata->mem_start, buf_offset, buf_start, buf_size);
+	pdata->dec_status = vh264_dec_status;
+	pdata->set_trickmode = vh264_set_trickmode;
 
 	if (vh264_init() < 0) {
 		pr_info("\namvdec_h264 init failed.\n");
@@ -2849,8 +2904,14 @@ static int __init amvdec_h264_driver_init_module(void)
 		pr_err("failed to register amvdec_h264 driver\n");
 		return -ENODEV;
 	}
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB)
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB
+		&& (codec_mm_get_total_size() > 80 * SZ_1M)) {
 		amvdec_h264_profile.profile = "4k";
+		dpb_size_adj = 0;
+	}
+	if (get_cpu_type() <= MESON_CPU_MAJOR_ID_GXBB)
+		dpb_size_adj = 0;
+
 	vcodec_profile_register(&amvdec_h264_profile);
 	return 0;
 }
@@ -2892,9 +2953,22 @@ module_param(decoder_debug_flag, uint, 0664);
 MODULE_PARM_DESC(decoder_debug_flag,
 				 "\n amvdec_h264 decoder_debug_flag\n");
 
+module_param(dpb_size_adj, uint, 0664);
+MODULE_PARM_DESC(dpb_size_adj,
+				 "\n amvdec_h264 dpb_size_adj\n");
+
+
 module_param(decoder_force_reset, uint, 0664);
 MODULE_PARM_DESC(decoder_force_reset,
 		"\n amvdec_h264 decoder force reset\n");
+module_param(no_idr_error_max, uint, 0664);
+MODULE_PARM_DESC(no_idr_error_max,
+		"\n print no_idr_error_max\n");
+module_param(enable_switch_fense, uint, 0664);
+MODULE_PARM_DESC(enable_switch_fense,
+		"\n enable switch fense\n");
+
+
 module_init(amvdec_h264_driver_init_module);
 module_exit(amvdec_h264_driver_remove_module);
 
diff --git a/drivers/amlogic/amports/vh264_4k2k.c b/drivers/amlogic/amports/vh264_4k2k.c
index 81b771c..48228fb 100644
--- a/drivers/amlogic/amports/vh264_4k2k.c
+++ b/drivers/amlogic/amports/vh264_4k2k.c
@@ -100,7 +100,7 @@ static u32 saved_resolution;
 static struct timer_list recycle_timer;
 static u32 stat;
 static u32 error_watchdog_count;
-static uint error_recovery_mode = 1;
+static uint error_recovery_mode;
 static u32 sync_outside;
 static u32 vh264_4k2k_rotation;
 static u32 first_i_recieved;
@@ -441,8 +441,15 @@ int init_canvas(int start_addr, long dpb_size, int dpb_number, int mb_width,
 			}
 
 			if (!buffer_spec[i].phy_addr) {
+				if (codec_mm_get_free_size()
+					< (page_count * PAGE_SIZE)) {
+					pr_err
+					("CMA not enough free keep buf! %d\n",
+					i);
+					try_free_keep_video(1);
+				}
 				if (!codec_mm_enough_for_size(
-					page_count * PAGE_SIZE)) {
+					page_count * PAGE_SIZE, 1)) {
 					buffer_spec[i].alloc_count = 0;
 					fatal_error =
 						DECODER_FATAL_ERROR_NO_MEM;
@@ -1014,7 +1021,7 @@ static void vh264_4k2k_put_timer_func(unsigned long arg)
 	add_timer(timer);
 }
 
-int vh264_4k2k_dec_status(struct vdec_status *vstatus)
+int vh264_4k2k_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
 {
 	vstatus->width = frame_width;
 	vstatus->height = frame_height;
@@ -1027,7 +1034,7 @@ int vh264_4k2k_dec_status(struct vdec_status *vstatus)
 	return 0;
 }
 
-int vh264_4k2k_set_trickmode(unsigned long trickmode)
+int vh264_4k2k_set_trickmode(struct vdec_s *vdec, unsigned long trickmode)
 {
 	if (trickmode == TRICKMODE_I) {
 		WRITE_VREG(DECODE_MODE, 1);
@@ -1566,11 +1573,6 @@ static s32 vh264_4k2k_init(void)
 
 	stat |= STAT_VDEC_RUN;
 
-	set_vdec_func(&vh264_4k2k_dec_status);
-
-	if (H264_4K2K_SINGLE_CORE)
-		set_trickmode_func(&vh264_4k2k_set_trickmode);
-
 	return 0;
 }
 
@@ -1688,8 +1690,7 @@ void vh264_4k_free_cmabuf(void)
 
 static int amvdec_h264_4k2k_probe(struct platform_device *pdev)
 {
-	struct vdec_dev_reg_s *pdata =
-		(struct vdec_dev_reg_s *)pdev->dev.platform_data;
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
 
 	pr_info("amvdec_h264_4k2k probe start.\n");
 
@@ -1752,6 +1753,10 @@ static int amvdec_h264_4k2k_probe(struct platform_device *pdev)
 	if (!H264_4K2K_SINGLE_CORE)
 		vdec2_power_mode(1);
 
+	pdata->dec_status = vh264_4k2k_dec_status;
+	if (H264_4K2K_SINGLE_CORE)
+		pdata->set_trickmode = vh264_4k2k_set_trickmode;
+
 	if (vh264_4k2k_init() < 0) {
 		pr_info("\namvdec_h264_4k2k init failed.\n");
 #if 1/* (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) && (has_hdec()) */
@@ -1844,8 +1849,8 @@ static int __init amvdec_h264_4k2k_driver_init_module(void)
 		pr_err("failed to register amvdec_h264_4k2k driver\n");
 		return -ENODEV;
 	}
-
-	vcodec_profile_register(&amvdec_h264_4k2k_profile);
+	if (get_cpu_type() < MESON_CPU_MAJOR_ID_GXTVBB)
+		vcodec_profile_register(&amvdec_h264_4k2k_profile);
 
 	return 0;
 }
diff --git a/drivers/amlogic/amports/vh264mvc.c b/drivers/amlogic/amports/vh264mvc.c
index 5ea7750..965c733 100644
--- a/drivers/amlogic/amports/vh264mvc.c
+++ b/drivers/amlogic/amports/vh264mvc.c
@@ -1078,7 +1078,7 @@ static void vh264mvc_put_timer_func(unsigned long arg)
 	add_timer(timer);
 }
 
-int vh264mvc_dec_status(struct vdec_status *vstatus)
+int vh264mvc_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
 {
 	vstatus->width = frame_width;
 	vstatus->height = frame_height;
@@ -1091,7 +1091,7 @@ int vh264mvc_dec_status(struct vdec_status *vstatus)
 	return 0;
 }
 
-int vh264mvc_set_trickmode(unsigned long trickmode)
+int vh264mvc_set_trickmode(struct vdec_s *vdec, unsigned long trickmode)
 {
 	if (trickmode == TRICKMODE_I) {
 		WRITE_VREG(AV_SCRATCH_F,
@@ -1415,9 +1415,6 @@ static s32 vh264mvc_init(void)
 
 	stat |= STAT_VDEC_RUN;
 
-	set_vdec_func(&vh264mvc_dec_status);
-	/* set_trickmode_func(&vh264mvc_set_trickmode); */
-
 	return 0;
 }
 
@@ -1478,8 +1475,8 @@ static int amvdec_h264mvc_probe(struct platform_device *pdev)
 	struct resource mem;
 	int buf_size;
 
-	struct vdec_dev_reg_s *pdata =
-		(struct vdec_dev_reg_s *)pdev->dev.platform_data;
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
+
 	pr_info("amvdec_h264mvc probe start.\n");
 
 #if 0
@@ -1509,6 +1506,9 @@ static int amvdec_h264mvc_probe(struct platform_device *pdev)
 	if (pdata->sys_info)
 		vh264mvc_amstream_dec_info = *pdata->sys_info;
 
+	pdata->dec_status = vh264mvc_dec_status;
+	/* pdata->set_trickmode = vh264mvc_set_trickmode; */
+
 	if (vh264mvc_init() < 0) {
 		pr_info("\namvdec_h264mvc init failed.\n");
 
diff --git a/drivers/amlogic/amports/vh265.c b/drivers/amlogic/amports/vh265.c
index 6ed562b..f7fbd22 100644
--- a/drivers/amlogic/amports/vh265.c
+++ b/drivers/amlogic/amports/vh265.c
@@ -38,8 +38,25 @@
 #include <linux/slab.h>
 #include "amports_priv.h"
 #include <linux/amlogic/codec_mm/codec_mm.h>
+#include "decoder/decoder_mmu_box.h"
+#include "decoder/decoder_bmmu_box.h"
+#include "config_parser.h"
 
 /*#define HEVC_PIC_STRUCT_SUPPORT*/
+#define MULTI_INSTANCE_SUPPORT
+
+
+
+#define MMU_COMPRESS_HEADER_SIZE  0x48000
+#define MAX_FRAME_4K_NUM 0x1200
+#define FRAME_MMU_MAP_SIZE  (MAX_FRAME_4K_NUM * 4)
+#define H265_MMU_MAP_BUFFER       HEVC_ASSIST_SCRATCH_7
+#define HEVC_CM_HEADER_START_ADDR                  0x3628
+#define HEVC_SAO_MMU_VH1_ADDR                      0x363b
+#define HEVC_SAO_MMU_VH0_ADDR                      0x363a
+#define HEVC_SAO_MMU_STATUS                        0x3639
+
+
 
 #define MEM_NAME "codec_265"
 /* #include <mach/am_regs.h> */
@@ -47,6 +64,7 @@
 
 #include "vdec.h"
 #include "amvdec.h"
+#include "video.h"
 
 #define SUPPORT_10BIT
 /* #define ERROR_HANDLE_DEBUG */
@@ -60,6 +78,10 @@
 #define STAT_KTHREAD 0x40
 #endif
 
+#ifdef MULTI_INSTANCE_SUPPORT
+#define MAX_DECODE_INSTANCE_NUM     12
+#define MULTI_DRIVER_NAME "ammvdec_h265"
+#endif
 #define DRIVER_NAME "amvdec_h265"
 #define MODULE_NAME "amvdec_h265"
 
@@ -73,8 +95,13 @@
 #define PTS_MODE_SWITCHING_RECOVERY_THREASHOLD 3
 
 #define DUR2PTS(x) ((x)*90/96)
+#define HEVC_SIZE (4096*2304)
 
 struct hevc_state_s;
+static int hevc_print(struct hevc_state_s *hevc,
+	int debug_flag, const char *fmt, ...);
+static int hevc_print_cont(struct hevc_state_s *hevc,
+	int debug_flag, const char *fmt, ...);
 static int vh265_vf_states(struct vframe_states *states, void *);
 static struct vframe_s *vh265_vf_peek(void *);
 static struct vframe_s *vh265_vf_get(void *);
@@ -82,14 +109,25 @@ static void vh265_vf_put(struct vframe_s *, void *);
 static int vh265_event_cb(int type, void *data, void *private_data);
 
 static int vh265_stop(struct hevc_state_s *hevc);
+#ifdef MULTI_INSTANCE_SUPPORT
+static int vmh265_stop(struct hevc_state_s *hevc);
+static s32 vh265_init(struct vdec_s *vdec);
+static bool run_ready(struct vdec_s *vdec);
+static void reset_process_time(struct hevc_state_s *hevc);
+static void start_process_time(struct hevc_state_s *hevc);
+static void timeout_process(struct hevc_state_s *hevc);
+#else
 static s32 vh265_init(struct hevc_state_s *hevc);
+#endif
 static void vh265_prot_init(struct hevc_state_s *hevc);
 static int vh265_local_init(struct hevc_state_s *hevc);
-static void vh265_put_timer_func(unsigned long arg);
+static void vh265_check_timer_func(unsigned long arg);
+static void config_decode_mode(struct hevc_state_s *hevc);
 
 static const char vh265_dec_id[] = "vh265-dev";
 
 #define PROVIDER_NAME   "decoder.h265"
+#define MULTI_INSTANCE_PROVIDER_NAME    "vdec.h265"
 
 static const struct vframe_operations_s vh265_vf_provider = {
 	.peek = vh265_vf_peek,
@@ -105,6 +143,9 @@ static u32 bit_depth_luma;
 static u32 bit_depth_chroma;
 static u32 video_signal_type;
 
+static unsigned int start_decode_buf_level = 0x8000;
+
+static unsigned int decode_timeout_val;
 #define VIDEO_SIGNAL_TYPE_AVAILABLE_MASK	0x20000000
 
 static const char * const video_format_names[] = {
@@ -137,13 +178,17 @@ static const char * const matrix_coeffs_names[] = {
 #define HEVC_CM_BODY_LENGTH                        0x3627
 #define HEVC_CM_HEADER_LENGTH                      0x3629
 #define HEVC_CM_HEADER_OFFSET                      0x362b
-
+#define HEVC_SAO_CTRL9                             0x362d
 #define LOSLESS_COMPRESS_MODE
 /* DOUBLE_WRITE_MODE is enabled only when NV21 8 bit output is needed */
-/* double_write_mode: 0, no double write; 1, 1:1 ratio; 2, (1/4):(1/4) ratio;
+/* hevc->double_write_mode:
+	0, no double write;
+	1, 1:1 ratio;
+	2, (1/4):(1/4) ratio;
 	3, (1/4):(1/4) ratio, with both compressed frame included
 	0x10, double write only
 */
+
 static u32 double_write_mode;
 
 /*#define DECOMP_HEADR_SURGENT*/
@@ -167,25 +212,33 @@ static u32 pts_unstable;
 #define H265_DEBUG_NO_DISPLAY               0x200
 #define H265_DEBUG_DISCARD_NAL              0x400
 #define H265_DEBUG_OUT_PTS                  0x800
-#define H265_DEBUG_PRINT_DECODE_STATUS      0x1000
 #define H265_DEBUG_PRINT_SEI		      0x2000
+#define H265_DEBUG_PIC_STRUCT				0x4000
 #define H265_DEBUG_DIS_LOC_ERROR_PROC       0x10000
 #define H265_DEBUG_DIS_SYS_ERROR_PROC   0x20000
 #define H265_DEBUG_DUMP_PIC_LIST       0x40000
 #define H265_DEBUG_TRIG_SLICE_SEGMENT_PROC 0x80000
 #define H265_DEBUG_HW_RESET               0x100000
-#define H265_DEBUG_LOAD_UCODE_FROM_FILE   0x200000
 #define H265_DEBUG_ERROR_TRIG             0x400000
 #define H265_DEBUG_NO_EOS_SEARCH_DONE     0x800000
 #define H265_DEBUG_NOT_USE_LAST_DISPBUF   0x1000000
 #define H265_DEBUG_IGNORE_CONFORMANCE_WINDOW	0x2000000
-#define H265_DEBUG_NOWAIT_DECODE_DONE_WHEN_STOP   0x4000000
-
+#define H265_DEBUG_WAIT_DECODE_DONE_WHEN_STOP   0x4000000
+#ifdef MULTI_INSTANCE_SUPPORT
+#define IGNORE_PARAM_FROM_CONFIG		0x08000000
+#define PRINT_FRAMEBASE_DATA            0x10000000
+#define PRINT_FLAG_VDEC_STATUS             0x20000000
+#define PRINT_FLAG_VDEC_DETAIL             0x40000000
+#endif
 #define MAX_BUF_NUM 24
 #define MAX_REF_PIC_NUM 24
 #define MAX_REF_ACTIVE  16
 
+#define BMMU_MAX_BUFFERS (MAX_BUF_NUM + 1)
+#define BMMU_WORKSPACE_ID (MAX_BUF_NUM)
+
 const u32 h265_version = 201602101;
+static u32 debug_mask = 0xffffffff;
 static u32 debug;
 static u32 radr;
 static u32 rval;
@@ -215,8 +268,9 @@ static u32 dynamic_buf_num_margin;
 #else
 static u32 buf_alloc_width;
 static u32 buf_alloc_height;
-static u32 dynamic_buf_num_margin = 7;
+static u32 dynamic_buf_num_margin = 10;
 #endif
+static u32 max_buf_num = 16;
 static u32 buf_alloc_size;
 static u32 re_config_pic_flag;
 /*
@@ -237,6 +291,7 @@ bit[3]: 1, if blackout is not 1, do not release current
 	set to 8 for other case of "keep last frame"
 */
 static u32 buffer_mode = 1;
+
 /* buffer_mode_dbg: debug only*/
 static u32 buffer_mode_dbg = 0xffff0000;
 /**/
@@ -262,6 +317,10 @@ use_cma: 1, use both reserver memory and cma for buffers
 */
 static u32 use_cma = 2;
 
+#define AUX_BUF_ALIGN(adr) ((adr + 0xf) & (~0xf))
+static u32 prefix_aux_buf_size;
+static u32 suffix_aux_buf_size;
+
 static u32 max_decoding_time;
 /*
 error handling
@@ -289,19 +348,65 @@ static u32 error_handle_threshold = 30;
 static u32 error_handle_nal_skip_threshold = 10;
 static u32 error_handle_system_threshold = 30;
 static u32 interlace_enable = 1;
+	/*
+	parser_sei_enable:
+	  bit 0, sei;
+	  bit 1, sei_suffix (fill aux buf)
+	  bit 2, fill sei to aux buf (when bit 0 is 1)
+	  bit 8, debug flag
+	*/
 static u32 parser_sei_enable;
+#ifdef CONFIG_AM_VDEC_DV
+static u32 parser_dolby_vision_enable;
+#endif
+/* this is only for h265 mmu enable */
+
+#ifdef CONFIG_MULTI_DEC
+static u32 mmu_enable;
+#else
+static u32 mmu_enable = 1;
+#endif
+
+#ifdef MULTI_INSTANCE_SUPPORT
+static u32 work_buf_size = 48 * 1024 * 1024;
+static unsigned int max_decode_instance_num
+				= MAX_DECODE_INSTANCE_NUM;
+static unsigned int decode_frame_count[MAX_DECODE_INSTANCE_NUM];
+static unsigned int max_process_time[MAX_DECODE_INSTANCE_NUM];
+static unsigned int max_get_frame_interval[MAX_DECODE_INSTANCE_NUM];
+
+#ifdef CONFIG_MULTI_DEC
+static unsigned char get_idx(struct hevc_state_s *hevc);
+#endif
+
+#ifdef CONFIG_AM_VDEC_DV
+static u32 dv_toggle_prov_name;
+
+static u32 dv_debug;
+#endif
+#endif
+
+
+#ifdef CONFIG_MULTI_DEC
+#define get_dbg_flag(hevc) ((debug_mask & (1 << hevc->index)) ? debug : 0)
+#define get_dbg_flag2(hevc) ((debug_mask & (1 << get_idx(hevc))) ? debug : 0)
+#else
+#define get_dbg_flag(hevc) debug
+#define get_dbg_flag2(hevc) debug
+#define get_double_write_mode(hevc) double_write_mode
+#define get_buf_alloc_width(hevc) buf_alloc_width
+#define get_buf_alloc_height(hevc) buf_alloc_height
+#define get_dynamic_buf_num_margin(hevc) dynamic_buf_num_margin
+#endif
+#define get_buffer_mode(hevc) buffer_mode
 
-static u32 max_buf_num = 16;
 
 DEFINE_SPINLOCK(lock);
 struct task_struct *h265_task = NULL;
-
-#define DEBUG_REG
+#undef DEBUG_REG
 #ifdef DEBUG_REG
 void WRITE_VREG_DBG(unsigned adr, unsigned val)
 {
-	if (debug & H265_DEBUG_REG)
-		pr_info("%s(%x, %x)\n", __func__, adr, val);
 	WRITE_VREG(adr, val);
 }
 
@@ -311,7 +416,6 @@ void WRITE_VREG_DBG(unsigned adr, unsigned val)
 
 static DEFINE_MUTEX(vh265_mutex);
 
-static struct device *cma_dev;
 
 /**************************************************
 
@@ -416,11 +520,26 @@ enum NalUnitType {
 #define HEVC_NAL_UNIT_PPS                    0x3
 #define HEVC_NAL_UNIT_CODED_SLICE_SEGMENT    0x4
 #define HEVC_CODED_SLICE_SEGMENT_DAT         0x5
-#define HEVC_DUMP_LMEM                       0x7
+#define HEVC_SLICE_DECODING                  0x6
+#define HEVC_NAL_UNIT_SEI                    0x7
 #define HEVC_SLICE_SEGMENT_DONE              0x8
 #define HEVC_NAL_SEARCH_DONE                 0x9
+#define HEVC_DECPIC_DATA_DONE                0xa
+#define HEVC_DECPIC_DATA_ERROR               0xb
 #define HEVC_SEI_DAT                         0xc
 #define HEVC_SEI_DAT_DONE                    0xd
+#define HEVC_NAL_DECODE_DONE				0xe
+
+#define HEVC_DATA_REQUEST           0x12
+
+#define HEVC_DECODE_BUFEMPTY        0x20
+#define HEVC_DECODE_TIMEOUT         0x21
+#define HEVC_SEARCH_BUFEMPTY        0x22
+
+#define HEVC_FIND_NEXT_PIC_NAL				0x50
+#define HEVC_FIND_NEXT_DVEL_NAL				0x51
+
+#define HEVC_DUMP_LMEM				0x30
 
 #define HEVC_4k2k_60HZ_NOT_SUPPORT	0x80
 #define HEVC_DISCARD_NAL         0xf0
@@ -506,9 +625,16 @@ h265 buffer management
 #define HEVC_WAIT_FLAG            HEVC_ASSIST_SCRATCH_E
 #define RPM_CMD_REG               HEVC_ASSIST_SCRATCH_F
 #define LMEM_DUMP_ADR                 HEVC_ASSIST_SCRATCH_F
+#ifdef ENABLE_SWAP_TEST
 #define HEVC_STREAM_SWAP_TEST     HEVC_ASSIST_SCRATCH_L
-#define HEVC_DECODE_PIC_BEGIN_REG HEVC_ASSIST_SCRATCH_M
-#define HEVC_DECODE_PIC_NUM_REG   HEVC_ASSIST_SCRATCH_N
+#endif
+
+/*#define HEVC_DECODE_PIC_BEGIN_REG HEVC_ASSIST_SCRATCH_M*/
+/*#define HEVC_DECODE_PIC_NUM_REG   HEVC_ASSIST_SCRATCH_N*/
+#define HEVC_DECODE_SIZE		HEVC_ASSIST_SCRATCH_N
+	/*do not define ENABLE_SWAP_TEST*/
+#define HEVC_AUX_ADR			HEVC_ASSIST_SCRATCH_L
+#define HEVC_AUX_DATA_SIZE		HEVC_ASSIST_SCRATCH_M
 
 #define DEBUG_REG1              HEVC_ASSIST_SCRATCH_G
 #define DEBUG_REG2              HEVC_ASSIST_SCRATCH_H
@@ -527,13 +653,31 @@ bit [15:4] nal skip count (valid when bit0 == 1 (manual mode) )
 bit [16]: for NAL_UNIT_EOS when bit0 is 0:
 	0, send SEARCH_DONE to arm ;  1, do not send SEARCH_DONE to arm
 bit [17]: for NAL_SEI when bit0 is 0:
-	0, do not parse SEI in ucode; 1, parse SEI in ucode
-bit [31:20]: used by ucode for debug purpose
+	0, do not parse/fetch SEI in ucode;
+	1, parse/fetch SEI in ucode
+bit [18]: for NAL_SEI_SUFFIX when bit0 is 0:
+	0, do not fetch NAL_SEI_SUFFIX to aux buf;
+	1, fetch NAL_SEL_SUFFIX data to aux buf
+bit [19]:
+	0, parse NAL_SEI in ucode
+	1, fetch NAL_SEI to aux buf
+bit [20]: for DOLBY_VISION_META
+	0, do not fetch DOLBY_VISION_META to aux buf
+	1, fetch DOLBY_VISION_META to aux buf
 */
 #define NAL_SEARCH_CTL            HEVC_ASSIST_SCRATCH_I
+	/*read only*/
 #define CUR_NAL_UNIT_TYPE       HEVC_ASSIST_SCRATCH_J
+	/*set before start decoder*/
+#define HEVC_DECODE_MODE		HEVC_ASSIST_SCRATCH_J
 #define DECODE_STOP_POS         HEVC_ASSIST_SCRATCH_K
 
+#define DECODE_MODE_SINGLE					0x0
+#define DECODE_MODE_MULTI_FRAMEBASE			0x1
+#define DECODE_MODE_MULTI_STREAMBASE		0x2
+#define DECODE_MODE_MULTI_DVBAL				0x3
+#define DECODE_MODE_MULTI_DVENL				0x4
+
 #define MAX_INT 0x7FFFFFFF
 
 #define RPM_BEGIN                                              0x100
@@ -616,7 +760,8 @@ union param_u {
 };
 
 #define RPM_BUF_SIZE (0x80*2)
-#define LMEM_BUF_SIZE (0x400 * 2)
+/* non mmu mode lmem size : 0x400, mmu mode : 0x500*/
+#define LMEM_BUF_SIZE (0x500 * 2)
 
 struct buff_s {
 	u32 buf_start;
@@ -642,6 +787,8 @@ struct BuffInfo_s {
 	struct buff_s scalelut;
 	struct buff_s dblk_para;
 	struct buff_s dblk_data;
+	struct buff_s mmu_vbh;
+	struct buff_s cm_header;
 	struct buff_s mpred_above;
 	struct buff_s mpred_mv;
 	struct buff_s rpm;
@@ -714,6 +861,12 @@ static struct BuffInfo_s amvh265_workbuff_spec[WORK_BUF_SPEC_NUM] = {
 		.dblk_data = {
 			.buf_size = 0x40000,
 		},
+		.mmu_vbh = {
+			.buf_size = 0x5000, /*2*16*2304/4, 4K*/
+		},
+		.cm_header = {/* 0x44000 = ((1088*2*1024*4)/32/4)*(32/8)*/
+			.buf_size = MMU_COMPRESS_HEADER_SIZE*(16+1),
+		},
 		.mpred_above = {
 			.buf_size = 0x8000,
 		},
@@ -724,7 +877,7 @@ static struct BuffInfo_s amvh265_workbuff_spec[WORK_BUF_SPEC_NUM] = {
 			.buf_size = RPM_BUF_SIZE,
 		},
 		.lmem = {
-			.buf_size = 0x400 * 2,
+			.buf_size = 0x500 * 2,
 		}
 	},
 	{
@@ -788,6 +941,12 @@ static struct BuffInfo_s amvh265_workbuff_spec[WORK_BUF_SPEC_NUM] = {
 		.dblk_data = {
 			.buf_size = 0x40000,
 		},
+		.mmu_vbh = {
+			.buf_size = 0x5000, /*2*16*2304/4, 4K*/
+		},
+		.cm_header = {/*0x44000 = ((1088*2*1024*4)/32/4)*(32/8)*/
+			.buf_size = MMU_COMPRESS_HEADER_SIZE * (16+1),
+		},
 		.mpred_above = {
 			.buf_size = 0x8000,
 		},
@@ -801,11 +960,16 @@ static struct BuffInfo_s amvh265_workbuff_spec[WORK_BUF_SPEC_NUM] = {
 			.buf_size = RPM_BUF_SIZE,
 		},
 		.lmem = {
-			.buf_size = 0x400 * 2,
+			.buf_size = 0x500 * 2,
 		}
 	}
 };
 
+unsigned int get_mmu_mode(void)
+{
+	return mmu_enable;
+}
+
 #ifdef SUPPORT_10BIT
 /* Losless compression body buffer size 4K per 64x32 (jt) */
 static  int  compute_losless_comp_body_size(int width, int height,
@@ -820,8 +984,9 @@ static  int  compute_losless_comp_body_size(int width, int height,
 
 	height_x32 = height + 31;
 	height_x32 >>= 5;
-
-	if (mem_saving_mode == 1)
+	if (mem_saving_mode == 1 && mmu_enable)
+		bsize = 3200 * width_x64 * height_x32;
+	else if (mem_saving_mode == 1)
 		bsize = 3072 * width_x64 * height_x32;
 	else
 		bsize = 4096 * width_x64 * height_x32;
@@ -849,7 +1014,8 @@ static  int  compute_losless_comp_header_size(int width, int height)
 
 #endif
 
-static void init_buff_spec(struct BuffInfo_s *buf_spec)
+static void init_buff_spec(struct hevc_state_s *hevc,
+	struct BuffInfo_s *buf_spec)
 {
 	buf_spec->ipp.buf_start = buf_spec->start_adr;
 	buf_spec->sao_abv.buf_start =
@@ -878,12 +1044,16 @@ static void init_buff_spec(struct BuffInfo_s *buf_spec)
 		buf_spec->scalelut.buf_start + buf_spec->scalelut.buf_size;
 	buf_spec->dblk_data.buf_start =
 		buf_spec->dblk_para.buf_start + buf_spec->dblk_para.buf_size;
-	buf_spec->mpred_above.buf_start =
+	buf_spec->mmu_vbh.buf_start  =
 		buf_spec->dblk_data.buf_start + buf_spec->dblk_data.buf_size;
+	buf_spec->cm_header.buf_start =
+		buf_spec->mmu_vbh.buf_start + buf_spec->mmu_vbh.buf_size;
+	buf_spec->mpred_above.buf_start =
+		buf_spec->cm_header.buf_start + buf_spec->cm_header.buf_size;
 	buf_spec->mpred_mv.buf_start =
 		buf_spec->mpred_above.buf_start +
 		buf_spec->mpred_above.buf_size;
-	if (debug & H265_DEBUG_SEND_PARAM_WITH_REG) {
+	if (get_dbg_flag2(hevc) & H265_DEBUG_SEND_PARAM_WITH_REG) {
 		buf_spec->end_adr =
 			buf_spec->mpred_mv.buf_start +
 			buf_spec->mpred_mv.buf_size;
@@ -891,7 +1061,7 @@ static void init_buff_spec(struct BuffInfo_s *buf_spec)
 		buf_spec->rpm.buf_start =
 			buf_spec->mpred_mv.buf_start +
 			buf_spec->mpred_mv.buf_size;
-		if (debug & H265_DEBUG_UCODE) {
+		if (get_dbg_flag2(hevc) & H265_DEBUG_UCODE) {
 			buf_spec->lmem.buf_start =
 				buf_spec->rpm.buf_start +
 				buf_spec->rpm.buf_size;
@@ -905,44 +1075,64 @@ static void init_buff_spec(struct BuffInfo_s *buf_spec)
 		}
 	}
 
-	if (debug) {
-		pr_info("%s workspace (%x %x) size = %x\n", __func__,
+	if (get_dbg_flag2(hevc)) {
+		hevc_print(hevc, 0,
+				"%s workspace (%x %x) size = %x\n", __func__,
 			   buf_spec->start_adr, buf_spec->end_adr,
 			   buf_spec->end_adr - buf_spec->start_adr);
 	}
-	if (debug) {
-		pr_info("ipp.buf_start             :%x\n",
-			   buf_spec->ipp.buf_start);
-		pr_info("sao_abv.buf_start          :%x\n",
-			   buf_spec->sao_abv.buf_start);
-		pr_info("sao_vb.buf_start          :%x\n",
-			   buf_spec->sao_vb.buf_start);
-		pr_info("short_term_rps.buf_start  :%x\n",
-			   buf_spec->short_term_rps.buf_start);
-		pr_info("vps.buf_start             :%x\n",
-			   buf_spec->vps.buf_start);
-		pr_info("sps.buf_start             :%x\n",
-			   buf_spec->sps.buf_start);
-		pr_info("pps.buf_start             :%x\n",
-			   buf_spec->pps.buf_start);
-		pr_info("sao_up.buf_start          :%x\n",
-			   buf_spec->sao_up.buf_start);
-		pr_info("swap_buf.buf_start        :%x\n",
-			   buf_spec->swap_buf.buf_start);
-		pr_info("swap_buf2.buf_start       :%x\n",
-			   buf_spec->swap_buf2.buf_start);
-		pr_info("scalelut.buf_start        :%x\n",
-			   buf_spec->scalelut.buf_start);
-		pr_info("dblk_para.buf_start       :%x\n",
-			   buf_spec->dblk_para.buf_start);
-		pr_info("dblk_data.buf_start       :%x\n",
-			   buf_spec->dblk_data.buf_start);
-		pr_info("mpred_above.buf_start     :%x\n",
-			   buf_spec->mpred_above.buf_start);
-		pr_info("mpred_mv.buf_start        :%x\n",
-			   buf_spec->mpred_mv.buf_start);
-		if ((debug & H265_DEBUG_SEND_PARAM_WITH_REG) == 0) {
-			pr_info("rpm.buf_start             :%x\n",
+	if (get_dbg_flag2(hevc)) {
+		hevc_print(hevc, 0,
+			"ipp.buf_start             :%x\n",
+			buf_spec->ipp.buf_start);
+		hevc_print(hevc, 0,
+			"sao_abv.buf_start          :%x\n",
+			buf_spec->sao_abv.buf_start);
+		hevc_print(hevc, 0,
+			"sao_vb.buf_start          :%x\n",
+			buf_spec->sao_vb.buf_start);
+		hevc_print(hevc, 0,
+			"short_term_rps.buf_start  :%x\n",
+			buf_spec->short_term_rps.buf_start);
+		hevc_print(hevc, 0,
+			"vps.buf_start             :%x\n",
+			buf_spec->vps.buf_start);
+		hevc_print(hevc, 0,
+			"sps.buf_start             :%x\n",
+			buf_spec->sps.buf_start);
+		hevc_print(hevc, 0,
+			"pps.buf_start             :%x\n",
+			buf_spec->pps.buf_start);
+		hevc_print(hevc, 0,
+			"sao_up.buf_start          :%x\n",
+			buf_spec->sao_up.buf_start);
+		hevc_print(hevc, 0,
+			"swap_buf.buf_start        :%x\n",
+			buf_spec->swap_buf.buf_start);
+		hevc_print(hevc, 0,
+			"swap_buf2.buf_start       :%x\n",
+			buf_spec->swap_buf2.buf_start);
+		hevc_print(hevc, 0,
+			"scalelut.buf_start        :%x\n",
+			buf_spec->scalelut.buf_start);
+		hevc_print(hevc, 0,
+			"dblk_para.buf_start       :%x\n",
+			buf_spec->dblk_para.buf_start);
+		hevc_print(hevc, 0,
+			"dblk_data.buf_start       :%x\n",
+			buf_spec->dblk_data.buf_start);
+		hevc_print(hevc, 0,
+			"mpred_above.buf_start     :%x\n",
+			buf_spec->mpred_above.buf_start);
+		hevc_print(hevc, 0,
+			"mpred_mv.buf_start        :%x\n",
+			  buf_spec->mpred_mv.buf_start);
+		if ((get_dbg_flag2(hevc)
+			&
+			H265_DEBUG_SEND_PARAM_WITH_REG)
+			== 0) {
+			hevc_print(hevc, 0,
+				"rpm.buf_start             :%x\n",
 				   buf_spec->rpm.buf_start);
 		}
 	}
@@ -958,10 +1148,7 @@ enum SliceType {
 /*USE_BUF_BLOCK*/
 struct BUF_s {
 	int index;
-	unsigned int alloc_flag;
 	/*buffer */
-	unsigned int cma_page_count;
-	unsigned long alloc_addr;
 	unsigned long start_adr;
 	unsigned int size;
 
@@ -990,7 +1177,13 @@ struct PIC_s {
 	int m_aiRefPOCList0[MAX_SLICE_NUM][16];
 	int m_aiRefPOCList1[MAX_SLICE_NUM][16];
 	/*buffer */
-	unsigned int cma_page_count;
+	unsigned int header_adr;
+#ifdef CONFIG_AM_VDEC_DV
+	unsigned char dv_enhance_exist;
+#endif
+	char *aux_data_buf;
+	int aux_data_size;
+	unsigned long cma_alloc_addr;
 	struct page *alloc_pages;
 	unsigned int mpred_mv_wr_start_addr;
 	unsigned int mc_y_adr;
@@ -1008,11 +1201,17 @@ struct PIC_s {
 
 	int y_canvas_index;
 	int uv_canvas_index;
+#ifdef MULTI_INSTANCE_SUPPORT
+	struct canvas_config_s canvas_config[2];
+#endif
 #ifdef LOSLESS_COMPRESS_MODE
 	unsigned int losless_comp_body_size;
 #endif
 	unsigned char pic_struct;
 	int vf_ref;
+
+	u32 pts;
+	u64 pts64;
 } /*PIC_t */;
 
 #define MAX_TILE_COL_NUM    5
@@ -1028,14 +1227,59 @@ struct tile_s {
 };
 
 #define SEI_MASTER_DISPLAY_COLOR_MASK 0x00000001
+#define SEI_CONTENT_LIGHT_LEVEL_MASK  0x00000002
 
 #define VF_POOL_SIZE        32
+
+#ifdef MULTI_INSTANCE_SUPPORT
+#define DEC_RESULT_NONE             0
+#define DEC_RESULT_DONE             1
+#define DEC_RESULT_AGAIN            2
+#define DEC_RESULT_CONFIG_PARAM     3
+#define DEC_RESULT_ERROR            4
+#define DEC_INIT_PICLIST			5
+#define DEC_UNINIT_PICLIST			6
+#define DEC_RESULT_GET_DATA         7
+#define DEC_RESULT_GET_DATA_RETRY   8
+
+static void vh265_work(struct work_struct *work);
+#endif
 struct hevc_state_s {
+#ifdef MULTI_INSTANCE_SUPPORT
+	struct platform_device *platform_dev;
+	void (*vdec_cb)(struct vdec_s *, void *);
+	void *vdec_cb_arg;
+	struct vframe_chunk_s *chunk;
+	int dec_result;
+	struct work_struct work;
+	/* timeout handle */
+	unsigned long int start_process_time;
+	unsigned last_lcu_idx;
+	unsigned decode_timeout_count;
+	unsigned timeout_num;
+#ifdef CONFIG_AM_VDEC_DV
+	unsigned char switch_dvlayer_flag;
+#endif
+	unsigned start_parser_type;
+#endif
+	char *provider_name;
+	int index;
+	struct device *cma_dev;
+	unsigned char m_ins_flag;
+	unsigned char dolby_enhance_flag;
+	unsigned long buf_start;
+	u32 buf_size;
+
+	struct BuffInfo_s work_space_buf_store;
 	struct BuffInfo_s *work_space_buf;
 	struct buff_s *mc_buf;
 
+	u32 prefix_aux_size;
+	u32 suffix_aux_size;
+	void *aux_addr;
 	void *rpm_addr;
 	void *lmem_addr;
+	dma_addr_t aux_phy_addr;
 	dma_addr_t rpm_phy_addr;
 	dma_addr_t lmem_phy_addr;
 
@@ -1145,7 +1389,7 @@ struct hevc_state_s {
 	struct timer_list timer;
 	struct BUF_s m_BUF[MAX_BUF_NUM];
 	u32 used_buf_num;
-	struct PIC_s m_PIC[MAX_REF_PIC_NUM];
+	struct PIC_s *m_PIC[MAX_REF_PIC_NUM];
 
 	DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
 	DECLARE_KFIFO(display_q, struct vframe_s *, VF_POOL_SIZE);
@@ -1177,26 +1421,130 @@ struct hevc_state_s {
 
 	int show_frame_num;
 	struct semaphore h265_sema;
+#ifdef USE_UNINIT_SEMA
+	struct semaphore h265_uninit_done_sema;
+#endif
 	int fatal_error;
 
-	unsigned long pre_last_frame_alloc_addr;
-	unsigned long pre_last_frame_alloc_size;
-	u32 predisp_addr;
-	u32 predisp_size;
 
 	u32 sei_present_flag;
+	void *frame_mmu_map_addr;
+	dma_addr_t frame_mmu_map_phy_addr;
+	unsigned int mmu_mc_buf_start;
+	unsigned int mmu_mc_buf_end;
+	unsigned int mmu_mc_start_4k_adr;
+	void *mmu_box;
+	void *bmmu_box;
+
+	unsigned int last_put_idx_a;
+	unsigned int last_put_idx_b;
+
+	unsigned int dec_status;
 
 	/* data for SEI_MASTER_DISPLAY_COLOR */
 	unsigned int primaries[3][2];
 	unsigned int white_point[2];
 	unsigned int luminance[2];
+	/* data for SEI_CONTENT_LIGHT_LEVEL */
+	unsigned int content_light_level[2];
 
 	struct PIC_s *pre_top_pic;
 	struct PIC_s *pre_bot_pic;
 
+#ifdef MULTI_INSTANCE_SUPPORT
+	int double_write_mode;
+	int buf_alloc_width;
+	int buf_alloc_height;
+	int dynamic_buf_num_margin;
+	int start_action;
+#endif
 } /*hevc_stru_t */;
 
-static void set_canvas(struct PIC_s *pic);
+#ifdef CONFIG_MULTI_DEC
+static int get_double_write_mode(struct hevc_state_s *hevc)
+{
+	return hevc->double_write_mode;
+}
+
+static int get_buf_alloc_width(struct hevc_state_s *hevc)
+{
+	return hevc->buf_alloc_width;
+}
+
+static int get_buf_alloc_height(struct hevc_state_s *hevc)
+{
+	return hevc->buf_alloc_height;
+}
+
+static int get_dynamic_buf_num_margin(struct hevc_state_s *hevc)
+{
+	return hevc->dynamic_buf_num_margin;
+}
+#endif
+
+#ifdef CONFIG_MULTI_DEC
+static unsigned char get_idx(struct hevc_state_s *hevc)
+{
+	return hevc->index;
+}
+#endif
+
+#undef pr_info
+#define pr_info printk
+static int hevc_print(struct hevc_state_s *hevc,
+	int flag, const char *fmt, ...)
+{
+#define HEVC_PRINT_BUF		128
+	unsigned char buf[HEVC_PRINT_BUF];
+	int len = 0;
+#ifdef CONFIG_MULTI_DEC
+	if (hevc == NULL ||
+		(flag == 0) ||
+		((debug_mask &
+		(1 << hevc->index))
+		&& (debug & flag))) {
+#endif
+		va_list args;
+		va_start(args, fmt);
+		if (hevc)
+			len = sprintf(buf, "[%d]", hevc->index);
+		vsnprintf(buf + len, HEVC_PRINT_BUF - len, fmt, args);
+		pr_info("%s", buf);
+		va_end(args);
+#ifdef CONFIG_MULTI_DEC
+	}
+#endif
+	return 0;
+}
+
+static int hevc_print_cont(struct hevc_state_s *hevc,
+	int flag, const char *fmt, ...)
+{
+#define HEVC_PRINT_BUF		128
+	unsigned char buf[HEVC_PRINT_BUF];
+	int len = 0;
+#ifdef CONFIG_MULTI_DEC
+	if (hevc == NULL ||
+		(flag == 0) ||
+		((debug_mask &
+		(1 << hevc->index))
+		&& (debug & flag))) {
+#endif
+		va_list args;
+		va_start(args, fmt);
+		vsnprintf(buf + len, HEVC_PRINT_BUF - len, fmt, args);
+		pr_info("%s", buf);
+		va_end(args);
+#ifdef CONFIG_MULTI_DEC
+	}
+#endif
+	return 0;
+}
+
+static void set_canvas(struct hevc_state_s *hevc, struct PIC_s *pic);
+
+static void release_aux_data(struct hevc_state_s *hevc,
+	struct PIC_s *pic);
 
 static void hevc_init_stru(struct hevc_state_s *hevc,
 		struct BuffInfo_s *buf_spec_i,
@@ -1205,6 +1553,9 @@ static void hevc_init_stru(struct hevc_state_s *hevc,
 	int i;
 	hevc->work_space_buf = buf_spec_i;
 	hevc->mc_buf = mc_buf_i;
+	hevc->prefix_aux_size = 0;
+	hevc->suffix_aux_size = 0;
+	hevc->aux_addr = NULL;
 	hevc->rpm_addr = NULL;
 	hevc->lmem_addr = NULL;
 
@@ -1258,7 +1609,7 @@ static void hevc_init_stru(struct hevc_state_s *hevc,
 		hevc->ignore_bufmgr_error = 0x0;
 
 	for (i = 0; i < MAX_REF_PIC_NUM; i++)
-		hevc->m_PIC[i].index = -1;
+		hevc->m_PIC[i] = NULL;
 	hevc->buf_num = 0;
 	hevc->pic_num = 0;
 	hevc->lcu_x_num_pre = 0;
@@ -1269,9 +1620,18 @@ static void hevc_init_stru(struct hevc_state_s *hevc,
 	hevc->pre_bot_pic = NULL;
 
 	hevc->sei_present_flag = 0;
+#ifdef MULTI_INSTANCE_SUPPORT
+	hevc->start_process_time = 0;
+	hevc->last_lcu_idx = 0;
+	hevc->decode_timeout_count = 0;
+	hevc->timeout_num = 0;
+#endif
 }
 
 static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic);
+static int H265_alloc_mmu(struct hevc_state_s *hevc,
+			struct PIC_s *new_pic,	unsigned short bit_depth,
+			unsigned int *mmu_index_adr);
 
 static void get_rpm_param(union param_u *params)
 {
@@ -1280,10 +1640,10 @@ static void get_rpm_param(union param_u *params)
 	for (i = 0; i < 128; i++) {
 		do {
 			data32 = READ_VREG(RPM_CMD_REG);
-			/* pr_info("%x\n", data32); */
+			/* hevc_print(hevc, 0, "%x\n", data32); */
 		} while ((data32 & 0x10000) == 0);
 		params->l.data[i] = data32 & 0xffff;
-		/* pr_info("%x\n", data32); */
+		/* hevc_print(hevc, 0, "%x\n", data32); */
 		WRITE_VREG(RPM_CMD_REG, 0);
 	}
 }
@@ -1294,8 +1654,8 @@ static struct PIC_s *get_pic_by_POC(struct hevc_state_s *hevc, int POC)
 	struct PIC_s *pic;
 	struct PIC_s *ret_pic = NULL;
 	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-		pic = &hevc->m_PIC[i];
-		if (pic->index == -1)
+		pic = hevc->m_PIC[i];
+		if (pic == NULL || pic->index == -1)
 			continue;
 		if (pic->POC == POC) {
 			if (ret_pic == NULL)
@@ -1315,8 +1675,8 @@ static struct PIC_s *get_ref_pic_by_POC(struct hevc_state_s *hevc, int POC)
 	struct PIC_s *pic;
 	struct PIC_s *ret_pic = NULL;
 	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-		pic = &hevc->m_PIC[i];
-		if (pic->index == -1)
+		pic = hevc->m_PIC[i];
+		if (pic == NULL || pic->index == -1)
 			continue;
 		if ((pic->POC == POC) && (pic->referenced)) {
 			if (ret_pic == NULL)
@@ -1329,8 +1689,9 @@ static struct PIC_s *get_ref_pic_by_POC(struct hevc_state_s *hevc, int POC)
 	}
 
 	if (ret_pic == NULL) {
-		if (debug) {
-			pr_info("Wrong, POC of %d is not in referenced list\n",
+		if (get_dbg_flag(hevc)) {
+			hevc_print(hevc, 0,
+				"Wrong, POC of %d is not in referenced list\n",
 				   POC);
 		}
 		ret_pic = get_pic_by_POC(hevc, POC);
@@ -1350,130 +1711,44 @@ static unsigned int log2i(unsigned int val)
 
 static int init_buf_spec(struct hevc_state_s *hevc);
 
-/*USE_BUF_BLOCK*/
-static void uninit_buf_list(struct hevc_state_s *hevc, bool force_free)
+static void uninit_mmu_buffers(struct hevc_state_s *hevc)
 {
-	int i;
-	unsigned char release_cma_flag = 0;
-	unsigned char blackout = get_blackout_policy();
-	u32 buffer_mode_real =
-		(buffer_mode & ((buffer_mode_dbg >> 16) & 0xfff)) |
-		(buffer_mode_dbg & 0xfff);
-	blackout &= ((buffer_mode_dbg >> 28) & 0xf);
-	blackout |=  ((buffer_mode_dbg >> 12) & 0xf);
-
-	hevc->predisp_addr = 0;
-
-	if (force_free) {
-		blackout = 0;
-		buffer_mode_real = 0;
-		pr_info("maybe reuinit buf_list, free cma buffer\n");
-	}
-
-	if (buffer_mode_real & 1) {
-		if (blackout == 1)
-			release_cma_flag = 1;
-	} else {
-		if (buffer_mode_real & 2)
-			;
-		else
-			release_cma_flag = 1;
-	}
-
-	if (blackout != 1) {
-		struct PIC_s *pic;
-		if ((release_cma_flag == 1) &&
-				(buffer_mode_real & 8)) {
-			release_cma_flag = 2;
-		}
 
-		msleep(50); /* ensure RDMA for display is done */
-		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB &&
-			((double_write_mode == 0) ||
-			 (double_write_mode == 3))) {
-			hevc->predisp_addr =
-			READ_VCBUS_REG(AFBC_BODY_BADDR) << 4;
-		} else {
-			struct canvas_s cur_canvas;
-			canvas_read((READ_VCBUS_REG(VD1_IF0_CANVAS0) & 0xff),
-				 &cur_canvas);
-			hevc->predisp_addr = cur_canvas.addr;
-		}
+	if (hevc->mmu_box)
+		decoder_mmu_box_free(hevc->mmu_box);
+	hevc->mmu_box = NULL;
 
-		for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-			pic = &hevc->m_PIC[i];
-			if (pic->index == -1)
-				continue;
-			if (hevc->predisp_addr == pic->mc_y_adr) {
-				hevc->predisp_size = pic->buf_size;
-				pr_info("%s, set  hevc->predisp_size = %d\n",
-					__func__, pic->buf_size);
-				break;
-			}
+	if (hevc->bmmu_box)
+		decoder_bmmu_box_free(hevc->bmmu_box);
+	hevc->bmmu_box = NULL;
+}
+static int init_mmu_buffers(struct hevc_state_s *hevc)
+{
+	if (mmu_enable) {
+		hevc->mmu_box = decoder_mmu_box_alloc_box(DRIVER_NAME,
+			hevc->index,
+			MAX_REF_PIC_NUM,
+			64 * SZ_1M
+			);
+		if (!hevc->mmu_box) {
+			pr_err("h265 alloc mmu box failed!!\n");
+			return -1;
 		}
 	}
-
-	if (hevc->pre_last_frame_alloc_addr) {
-		if (blackout == 1 || hevc->predisp_addr == 0
-			|| hevc->predisp_addr < hevc->pre_last_frame_alloc_addr
-			|| hevc->predisp_addr >=
-			(hevc->pre_last_frame_alloc_addr
-				+ hevc->pre_last_frame_alloc_size)
-			) {
-			codec_mm_free_for_dma(MEM_NAME,
-				hevc->pre_last_frame_alloc_addr);
-			pr_info("release pre_last_frame cma buffer %ld\n",
-				hevc->pre_last_frame_alloc_addr);
-			hevc->pre_last_frame_alloc_addr = 0;
-			hevc->pre_last_frame_alloc_size = 0;
-		}
-	}
-
-	if (release_cma_flag) {
-		pr_info("release cma begin\n");
-		for (i = 0; i < hevc->used_buf_num; i++) {
-			if (hevc->m_BUF[i].alloc_addr != 0
-				&& hevc->m_BUF[i].cma_page_count > 0) {
-				if ((release_cma_flag == 2)
-					&& (hevc->predisp_addr >=
-						hevc->m_BUF[i].start_adr)
-					&& (hevc->predisp_addr <
-					(hevc->m_BUF[i].start_adr +
-						hevc->m_BUF[i].size))) {
-					if (hevc->pre_last_frame_alloc_addr)
-						pr_info("last buf not free\n");
-					else {
-						hevc->pre_last_frame_alloc_addr
-						=
-						hevc->m_BUF[i].alloc_addr;
-						hevc->pre_last_frame_alloc_size
-						= hevc->m_BUF[i].size;
-						hevc->m_BUF[i].alloc_addr = 0;
-						hevc->m_BUF[i].
-						cma_page_count = 0;
-						continue;
-					}
-				}
-
-				pr_debug("release cma buffer[%d] (%d %ld)\n", i,
-					hevc->m_BUF[i].cma_page_count,
-					hevc->m_BUF[i].alloc_addr);
-				codec_mm_free_for_dma(MEM_NAME,
-					hevc->m_BUF[i].alloc_addr);
-				hevc->m_BUF[i].alloc_addr = 0;
-				hevc->m_BUF[i].cma_page_count = 0;
-
-			}
-		}
-		pr_info("release cma end\n");
+	hevc->bmmu_box = decoder_bmmu_box_alloc_box(DRIVER_NAME,
+			hevc->index,
+			BMMU_MAX_BUFFERS,
+			4 + PAGE_SHIFT,
+			CODEC_MM_FLAGS_CMA_CLEAR |
+			CODEC_MM_FLAGS_FOR_VDECODER);
+	if (!hevc->bmmu_box) {
+		if (hevc->mmu_box)
+			decoder_mmu_box_free(hevc->mmu_box);
+		hevc->mmu_box = NULL;
+		pr_err("h265 alloc mmu box failed!!\n");
+		return -1;
 	}
-	pr_info("%s, blackout %x r%x buf_mode %x r%x rel_cma_flag %x hevc->predisp_addr %d pre_alloc_addr(%ld, %ld)\n",
-		__func__, get_blackout_policy(), blackout,
-		buffer_mode, buffer_mode_real, release_cma_flag,
-		hevc->predisp_addr, hevc->pre_last_frame_alloc_addr,
-		hevc->pre_last_frame_alloc_size);
-	hevc->pic_list_init_flag = 0;
-	hevc->buf_num = 0;
+	return 0;
 }
 
 static void init_buf_list(struct hevc_state_s *hevc)
@@ -1482,9 +1757,9 @@ static void init_buf_list(struct hevc_state_s *hevc)
 	int buf_size;
 	int mc_buffer_end = hevc->mc_buf->buf_start + hevc->mc_buf->buf_size;
 
-	if (dynamic_buf_num_margin > 0)
+	if (get_dynamic_buf_num_margin(hevc) > 0)
 		hevc->used_buf_num = hevc->sps_num_reorder_pics_0
-			+ dynamic_buf_num_margin;
+			+ get_dynamic_buf_num_margin(hevc);
 	else
 		hevc->used_buf_num = max_buf_num;
 
@@ -1492,12 +1767,15 @@ static void init_buf_list(struct hevc_state_s *hevc)
 		hevc->used_buf_num = MAX_BUF_NUM;
 	if (buf_alloc_size > 0) {
 		buf_size = buf_alloc_size;
-		if (debug)
-			pr_info("[Buffer Management] init_buf_list:\n");
+		if (get_dbg_flag(hevc))
+			hevc_print(hevc, 0,
+				"[Buffer Management] init_buf_list:\n");
 	} else {
-		int pic_width = buf_alloc_width ? buf_alloc_width : hevc->pic_w;
+		int pic_width = get_buf_alloc_width(hevc)
+		? get_buf_alloc_width(hevc) : hevc->pic_w;
 		int pic_height =
-			buf_alloc_height ? buf_alloc_height : hevc->pic_h;
+			get_buf_alloc_height(hevc)
+			? get_buf_alloc_height(hevc) : hevc->pic_h;
 #ifdef LOSLESS_COMPRESS_MODE
 /*SUPPORT_10BIT*/
 	int losless_comp_header_size = compute_losless_comp_header_size
@@ -1507,13 +1785,13 @@ static void init_buf_list(struct hevc_state_s *hevc)
 	int mc_buffer_size = losless_comp_header_size
 		+ losless_comp_body_size;
 	int mc_buffer_size_h = (mc_buffer_size + 0xffff)>>16;
-	if (double_write_mode) {
-		int pic_width_dw = ((double_write_mode == 2) ||
-			(double_write_mode == 3)) ?
-			pic_width / 2 : pic_width;
-		int pic_height_dw = ((double_write_mode == 2) ||
-			(double_write_mode == 3)) ?
-			pic_height / 2 : pic_height;
+	if (get_double_write_mode(hevc)) {
+		int pic_width_dw = ((get_double_write_mode(hevc) == 2) ||
+			(get_double_write_mode(hevc) == 3)) ?
+			pic_width / 4 : pic_width;
+		int pic_height_dw = ((get_double_write_mode(hevc) == 2) ||
+			(get_double_write_mode(hevc) == 3)) ?
+			pic_height / 4 : pic_height;
 		int lcu_size = hevc->lcu_size;
 		int pic_width_lcu  = (pic_width_dw % lcu_size)
 			? pic_width_dw / lcu_size
@@ -1532,8 +1810,13 @@ static void init_buf_list(struct hevc_state_s *hevc)
 	if (mc_buffer_size & 0xffff) { /*64k alignment*/
 		mc_buffer_size_h += 1;
 	}
-	if ((double_write_mode & 0x10) == 0)
+	if (mmu_enable) {
+		if (get_double_write_mode(hevc) == 1)
+			buf_size += (mc_buffer_size_h << 16);
+	} else {
+	if ((get_double_write_mode(hevc) & 0x10) == 0)
 		buf_size += (mc_buffer_size_h << 16);
+	}
 #else
 		int lcu_size = hevc->lcu_size;
 		int pic_width_lcu =
@@ -1549,63 +1832,51 @@ static void init_buf_list(struct hevc_state_s *hevc)
 					/*64k alignment*/
 		buf_size = (mc_buffer_size_u_v_h << 16) * 3;
 #endif
-		if (debug) {
-			pr_info
-			("init_buf_list num %d (width %d height %d):\n",
+		if (get_dbg_flag(hevc)) {
+			hevc_print(hevc, 0,
+			"init_buf_list num %d (width %d height %d):\n",
 			 hevc->used_buf_num, pic_width, pic_height);
 		}
 	}
 
-	pr_info("allocate begin\n");
+	hevc_print(hevc, 0, "allocate begin\n");
 	get_cma_alloc_ref();
 	for (i = 0; i < hevc->used_buf_num; i++) {
 		if (((i + 1) * buf_size) > hevc->mc_buf->buf_size) {
 			if (use_cma)
 				hevc->use_cma_flag = 1;
 			else {
-				if (debug) {
-					pr_info("%s maximum buf size is used\n",
+				if (get_dbg_flag(hevc)) {
+					hevc_print(hevc, 0,
+						"%s maximum buf size is used\n",
 						   __func__);
 				}
 				break;
 			}
 		}
-		hevc->m_BUF[i].alloc_flag = 0;
-		hevc->m_BUF[i].index = i;
-
-		if (use_cma == 2)
-			hevc->use_cma_flag = 1;
-		if (hevc->use_cma_flag) {
-			if ((hevc->m_BUF[i].cma_page_count != 0)
-				&& (hevc->m_BUF[i].alloc_addr != 0)
-				&& (hevc->m_BUF[i].size != buf_size)) {
-				if ((hevc->predisp_addr >=
-						hevc->m_BUF[i].alloc_addr)
-					&& (hevc->predisp_addr <
-					(hevc->m_BUF[i].alloc_addr +
-						hevc->m_BUF[i].size))) {
-					hevc->pre_last_frame_alloc_addr =
-						hevc->m_BUF[i].alloc_addr;
-					hevc->pre_last_frame_alloc_size =
-						hevc->m_BUF[i].size;
-				} else {
-					codec_mm_free_for_dma(MEM_NAME,
-						hevc->m_BUF[i].alloc_addr);
-					pr_info("release cma buffer[%d] (%d %ld)\n",
-					i, hevc->m_BUF[i].cma_page_count,
-						hevc->m_BUF[i].alloc_addr);
-				}
-				hevc->m_BUF[i].alloc_addr = 0;
-				hevc->m_BUF[i].cma_page_count = 0;
-			}
-			if (hevc->m_BUF[i].alloc_addr == 0) {
-				if (!codec_mm_enough_for_size(buf_size)) {
+
+
+		if (!mmu_enable) {
+			hevc->m_BUF[i].index = i;
+
+			if (use_cma == 2)
+				hevc->use_cma_flag = 1;
+			if (hevc->use_cma_flag) {
+				if (decoder_bmmu_box_alloc_idx_wait(
+				hevc->bmmu_box,
+				i,
+				buf_size,
+				-1,
+				-1,
+				BMMU_ALLOC_FLAGS_WAITCLEAR
+				) < 0) {
 					/*
 					not enough mem for buffer.
 					*/
-					pr_info("not enought buffer for [%d],%d\n",
+					hevc_print(hevc, 0,
+						"not enought buffer for [%d],%d\n",
 						i, buf_size);
-					hevc->m_BUF[i].cma_page_count = 0;
+					hevc->m_BUF[i].start_adr = 0;
 					if (i <= 8) {
 						/*if alloced (i+1)>=9
 						don't send errors.*/
@@ -1614,71 +1885,55 @@ static void init_buf_list(struct hevc_state_s *hevc)
 					}
 					break;
 				}
-				hevc->m_BUF[i].cma_page_count =
-					PAGE_ALIGN(buf_size) / PAGE_SIZE;
-				hevc->m_BUF[i].alloc_addr =
-				    codec_mm_alloc_for_dma(
-					MEM_NAME, hevc->m_BUF[i].cma_page_count,
-					4 + PAGE_SHIFT,
-					CODEC_MM_FLAGS_FOR_VDECODER);
-				if (hevc->m_BUF[i].alloc_addr == 0) {
-					pr_info("alloc cma buffer[%d] fail\n",
-					i);
-					hevc->m_BUF[i].cma_page_count = 0;
+				hevc->m_BUF[i].start_adr =
+					decoder_bmmu_box_get_phy_addr(
+						hevc->bmmu_box,
+						i);
+				pr_debug("allocate cma buffer[%d] %ld\n",
+					i,
+					hevc->m_BUF[i].start_adr);
+			} else {
+				hevc->m_BUF[i].start_adr =
+					hevc->mc_buf->buf_start + i * buf_size;
+				if (((hevc->m_BUF[i].start_adr + buf_size) >
+						mc_buffer_end)) {
+					if (get_dbg_flag(hevc)) {
+						hevc_print(hevc, 0,
+						"Max mc buffer or mpred_mv buffer is used\n");
+					}
 					break;
 				}
-				pr_debug("allocate cma buffer[%d] (%d,%ld,%ld)\n",
-						i,
-						hevc->m_BUF[i].cma_page_count,
-						hevc->m_BUF[i].alloc_addr,
-						hevc->m_BUF[i].start_adr);
-			} else {
-				pr_info("reuse cma buffer[%d] (%d,%ld,%ld)\n",
-						i,
-						hevc->m_BUF[i].cma_page_count,
-						hevc->m_BUF[i].alloc_addr,
-						hevc->m_BUF[i].start_adr);
 			}
-			hevc->m_BUF[i].start_adr =  hevc->m_BUF[i].alloc_addr;
-		} else {
-			hevc->m_BUF[i].cma_page_count = 0;
-			hevc->m_BUF[i].alloc_addr = 0;
-			hevc->m_BUF[i].start_adr =
-				hevc->mc_buf->buf_start + i * buf_size;
-		}
-		hevc->m_BUF[i].size = buf_size;
-		hevc->m_BUF[i].free_start_adr = hevc->m_BUF[i].start_adr;
-
-		if (((hevc->m_BUF[i].start_adr + buf_size) > mc_buffer_end)
-			&& (hevc->m_BUF[i].alloc_addr == 0)) {
-			if (debug) {
-				pr_info
-				("Max mc buffer or mpred_mv buffer is used\n");
+			hevc->m_BUF[i].size = buf_size;
+			hevc->m_BUF[i].free_start_adr =
+					hevc->m_BUF[i].start_adr;
+
+			if (get_dbg_flag(hevc)) {
+				hevc_print(hevc, 0,
+					"Buffer %d: start_adr %p size %x\n", i,
+					   (void *)hevc->m_BUF[i].start_adr,
+					   hevc->m_BUF[i].size);
 			}
-			break;
-		}
-
-		if (debug) {
-			pr_info("Buffer %d: start_adr %p size %x\n", i,
-				   (void *)hevc->m_BUF[i].start_adr,
-				   hevc->m_BUF[i].size);
 		}
 	}
 	put_cma_alloc_ref();
-	pr_info("allocate end\n");
+	hevc_print(hevc, 0, "allocate end\n");
 
 	hevc->buf_num = i;
 
 }
 
-static int config_pic(struct hevc_state_s *hevc, struct PIC_s *pic)
+static int config_pic(struct hevc_state_s *hevc, struct PIC_s *pic,
+						unsigned int last_disp_addr)
 {
 	int ret = -1;
 	int i;
-	int pic_width = ((re_config_pic_flag == 0) && buf_alloc_width) ?
-		buf_alloc_width : hevc->pic_w;
-	int pic_height = ((re_config_pic_flag == 0) && buf_alloc_height) ?
-		buf_alloc_height : hevc->pic_h;
+	int pic_width = ((re_config_pic_flag == 0) &&
+		get_buf_alloc_width(hevc)) ?
+		get_buf_alloc_width(hevc) : hevc->pic_w;
+	int pic_height = ((re_config_pic_flag == 0) &&
+		get_buf_alloc_height(hevc)) ?
+		get_buf_alloc_height(hevc) : hevc->pic_h;
 	int lcu_size = hevc->lcu_size;
 	int pic_width_lcu = (pic_width % lcu_size) ? pic_width / lcu_size +
 				 1 : pic_width / lcu_size;
@@ -1705,13 +1960,13 @@ static int config_pic(struct hevc_state_s *hevc, struct PIC_s *pic)
 	int mc_buffer_size_h = (mc_buffer_size + 0xffff)>>16;
 	int mc_buffer_size_u_v = 0;
 	int mc_buffer_size_u_v_h = 0;
-	if (double_write_mode) {
-		int pic_width_dw = ((double_write_mode == 2) ||
-			(double_write_mode == 3)) ?
-			pic_width / 2 : pic_width;
-		int pic_height_dw = ((double_write_mode == 2) ||
-			(double_write_mode == 3)) ?
-			pic_height / 2 : pic_height;
+	if (get_double_write_mode(hevc)) {
+		int pic_width_dw = ((get_double_write_mode(hevc) == 2) ||
+			(get_double_write_mode(hevc) == 3)) ?
+			pic_width / 4 : pic_width;
+		int pic_height_dw = ((get_double_write_mode(hevc) == 2) ||
+			(get_double_write_mode(hevc) == 3)) ?
+			pic_height / 4 : pic_height;
 		int pic_width_lcu_dw = (pic_width_dw % lcu_size) ?
 			pic_width_dw / lcu_size + 1 :
 			pic_width_dw / lcu_size;
@@ -1728,8 +1983,13 @@ static int config_pic(struct hevc_state_s *hevc, struct PIC_s *pic)
 	if (mc_buffer_size & 0xffff) { /*64k alignment*/
 		mc_buffer_size_h += 1;
 	}
-	if ((double_write_mode & 0x10) == 0)
+	if (mmu_enable) {
+		if (get_double_write_mode(hevc) == 1)
+			buf_size += (mc_buffer_size_h << 16);
+	} else {
+	if ((get_double_write_mode(hevc) & 0x10) == 0)
 		buf_size += (mc_buffer_size_h << 16);
+	}
 #else
 	int mc_buffer_size_u_v = lcu_total * lcu_size * lcu_size / 2;
 	int mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff) >> 16;
@@ -1737,12 +1997,44 @@ static int config_pic(struct hevc_state_s *hevc, struct PIC_s *pic)
 	buf_size = ((mc_buffer_size_u_v_h << 16) * 3);
 #endif
 
+
+		if (mmu_enable) {
+			if ((hevc->work_space_buf->cm_header.buf_start +
+			   ((pic->index + 1)
+			   * MMU_COMPRESS_HEADER_SIZE))
+			   > (hevc->work_space_buf->cm_header.buf_start +
+			   hevc->work_space_buf->cm_header.buf_size)) {
+				hevc_print(hevc, 0,
+					"MMU header_adr allocate fail\n");
+				return -1;
+		}
+
+		pic->header_adr = hevc->work_space_buf->cm_header.buf_start +
+			(pic->index * MMU_COMPRESS_HEADER_SIZE);
+	if (last_disp_addr && pic->header_adr == last_disp_addr) {
+		/*if same as disp add used last one.*/
+		pr_info("same as disp %d: %d\n",
+			pic->index, pic->header_adr);
+		pic->header_adr =
+			hevc->work_space_buf->cm_header.buf_start +
+			(16 * MMU_COMPRESS_HEADER_SIZE);
+	}
+			if (get_dbg_flag(hevc)&H265_DEBUG_BUFMGR) {
+				hevc_print(hevc, 0,
+					"MMU header_adr %d: %x\n",
+					pic->index, pic->header_adr);
+			}
+		}
+
+
 	if ((hevc->work_space_buf->mpred_mv.buf_start + (((pic->index + 1)
 					* lcu_total) * MV_MEM_UNIT))
 						<= mpred_mv_end) {
-		for (i = 0; i < hevc->buf_num; i++) {
-			y_adr = ((hevc->m_BUF[i].free_start_adr
-				+ 0xffff) >> 16) << 16;
+
+		if (!mmu_enable) {
+			for (i = 0; i < hevc->buf_num; i++) {
+				y_adr = ((hevc->m_BUF[i].free_start_adr
+					+ 0xffff) >> 16) << 16;
 					/*64k alignment*/
 				if ((y_adr+buf_size) <=
 						(hevc->m_BUF[i].start_adr+
@@ -1752,6 +2044,8 @@ static int config_pic(struct hevc_state_s *hevc, struct PIC_s *pic)
 					break;
 				}
 		}
+	} else
+		i = pic->index;
 		if (i < hevc->buf_num) {
 			pic->POC = INVALID_POC;
 			/*ensure get_pic_by_POC()
@@ -1761,11 +2055,39 @@ static int config_pic(struct hevc_state_s *hevc, struct PIC_s *pic)
 /*SUPPORT_10BIT*/
 			pic->comp_body_size = losless_comp_body_size;
 			pic->buf_size = buf_size;
-			pic->mc_y_adr = y_adr;
 
+			if (!mmu_enable)
+				pic->mc_y_adr = y_adr;
+			else if (get_double_write_mode(hevc)) {
+				if ((hevc->mc_buf->buf_start
+					+ (i + 1) * buf_size)
+					< hevc->mc_buf->buf_end)
+					y_adr = hevc->mc_buf->buf_start
+							+ i * buf_size;
+				else {
+					if (decoder_bmmu_box_alloc_idx_wait(
+						hevc->bmmu_box,
+						pic->BUF_index,
+						buf_size,
+						-1,
+						-1,
+						BMMU_ALLOC_FLAGS_WAITCLEAR
+						) < 0) {
+						return -1;
+					}
+					pic->cma_alloc_addr =
+						decoder_bmmu_box_get_phy_addr(
+							hevc->bmmu_box,
+							pic->BUF_index);
+					if (pic->cma_alloc_addr)
+						y_adr = pic->cma_alloc_addr;
+					else
+						return -1;
+				}
+			}
 			pic->mc_canvas_y = pic->index;
 			pic->mc_canvas_u_v = pic->index;
-			if (double_write_mode & 0x10) {
+			if (!mmu_enable && get_double_write_mode(hevc) & 0x10) {
 				pic->mc_u_v_adr = y_adr +
 					((mc_buffer_size_u_v_h << 16) << 1);
 
@@ -1774,11 +2096,14 @@ static int config_pic(struct hevc_state_s *hevc, struct PIC_s *pic)
 
 				pic->dw_y_adr = y_adr;
 				pic->dw_u_v_adr = pic->mc_u_v_adr;
-			} else if (double_write_mode) {
-				pic->dw_y_adr = y_adr +
-					(mc_buffer_size_h << 16);
-				pic->dw_u_v_adr = pic->dw_y_adr +
-				((mc_buffer_size_u_v_h << 16) << 1);
+			} else if (get_double_write_mode(hevc)) {
+					if (mmu_enable)
+						pic->dw_y_adr = y_adr;
+					else
+						pic->dw_y_adr = y_adr +
+						(mc_buffer_size_h << 16);
+					pic->dw_u_v_adr = pic->dw_y_adr +
+					((mc_buffer_size_u_v_h << 16) << 1);
 			}
 #else
 			pic->buf_size = (mc_buffer_size_u_v_h << 16) * 3;
@@ -1794,37 +2119,25 @@ static int config_pic(struct hevc_state_s *hevc, struct PIC_s *pic)
 						((pic->index * lcu_total)
 						* MV_MEM_UNIT);
 
-			if ((hevc->predisp_addr != 0) &&
-				(hevc->predisp_size != 0) &&
-					(buffer_mode & 0x4) == 0) {
-				if ((pic->mc_y_adr >=
-						(hevc->predisp_addr +
-						hevc->predisp_size)) ||
-					((pic->mc_y_adr + pic->buf_size) <=
-						hevc->predisp_addr)) {
-						pic->used_by_display = 0;
-				} else {
-					pic->used_by_display = 1;
-					pr_info("%s, pic[%d] is displayed now, do not use it before it is not displayed\n",
-							 __func__, i);
-				}
-			} else
-				pic->used_by_display = 0;
-
-			if (debug) {
-				pr_info
-				("%s index %d BUF_index %d mc_y_adr %x ",
+			if (get_dbg_flag(hevc)) {
+				hevc_print(hevc, 0,
+				"%s index %d BUF_index %d mc_y_adr %x ",
 				 __func__, pic->index,
 				 pic->BUF_index, pic->mc_y_adr);
 #ifdef LOSLESS_COMPRESS_MODE
-				pr_info
-				("comp_body_size %x comp_buf_size %x ",
+				hevc_print_cont(hevc, 0,
+				"comp_body_size %x comp_buf_size %x ",
 				 pic->comp_body_size, pic->buf_size);
-				pr_info
-				("mpred_mv_wr_start_adr %x\n",
+				hevc_print_cont(hevc, 0,
+				"mpred_mv_wr_start_adr %x\n",
 				 pic->mpred_mv_wr_start_addr);
+				if (mmu_enable && get_double_write_mode(hevc))
+					hevc_print(hevc, 0,
+					"mmu double write  adr %ld\n",
+					 pic->cma_alloc_addr);
+
 #else
-				pr_info
+				hevc_print(hevc, 0,
 				("mc_u_v_adr %x mpred_mv_wr_start_adr %x\n",
 				 pic->mc_u_v_adr, pic->mpred_mv_wr_start_addr);
 #endif
@@ -1843,15 +2156,20 @@ static int recycle_buf(struct hevc_state_s *hevc)
 {
 	int i, j;
 	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-		struct PIC_s *pic = &hevc->m_PIC[i];
-		if (pic->index == -1)
+		struct PIC_s *pic = hevc->m_PIC[i];
+		if (pic == NULL || pic->index == -1)
 			continue;
 		if (pic->width != hevc->pic_w || pic->height != hevc->pic_h) {
 			if (pic->output_mark == 0 && pic->referenced == 0
 				&& pic->output_ready == 0) {
+				if (mmu_enable) {
+					decoder_mmu_box_free_idx(hevc->mmu_box,
+						pic->index);
+				}
 				pic->BUF_index = -1;
-				if (debug) {
-					pr_info("%s: %d\n", __func__,
+				if (get_dbg_flag(hevc)) {
+					hevc_print(hevc, 0,
+						"%s: %d\n", __func__,
 						   pic->index);
 				}
 			}
@@ -1859,10 +2177,11 @@ static int recycle_buf(struct hevc_state_s *hevc)
 	}
 
 	for (i = 0; i < hevc->buf_num; i++) {
-		if (hevc->m_BUF[i].free_start_adr != hevc->m_BUF[i].start_adr) {
+		if (hevc->m_BUF[i].free_start_adr !=
+			hevc->m_BUF[i].start_adr) {
 			for (j = 0; j < MAX_REF_PIC_NUM; j++) {
-				struct PIC_s *pic = &hevc->m_PIC[j];
-				if (pic->index == -1)
+				struct PIC_s *pic = hevc->m_PIC[j];
+				if (pic == NULL || pic->index == -1)
 					continue;
 				if (pic->BUF_index == i)
 					break;
@@ -1878,34 +2197,86 @@ static int recycle_buf(struct hevc_state_s *hevc)
 static void init_pic_list(struct hevc_state_s *hevc)
 {
 	int i;
+	struct vframe_s vf;
+	unsigned long flags;
+	unsigned long disp_addr = 0;
+	if (!get_video0_frame_info(&vf)) {
+		spin_lock_irqsave(&lock, flags);
+		if (vf.type & VIDTYPE_SCATTER) {
+			/*sc only used header.*/
+			disp_addr = (VSYNC_RD_MPEG_REG(AFBC_HEAD_BADDR) << 4);
+		} else if (vf.type & VIDTYPE_COMPRESS) {
+			/*sc checked body.*/
+			disp_addr = (VSYNC_RD_MPEG_REG(AFBC_BODY_BADDR) << 4);
+		} else {
+			struct canvas_s cur_canvas;
+			canvas_read(vf.canvas0Addr & 0xff, &cur_canvas);
+			disp_addr = cur_canvas.addr;
+		}
+		spin_unlock_irqrestore(&lock, flags);
+	}
 	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-		struct PIC_s *pic = &hevc->m_PIC[i];
+		struct PIC_s *pic =
+			vmalloc(sizeof(struct PIC_s));
+		if (pic == NULL) {
+			hevc_print(hevc, 0,
+				"alloc pic %d fail\n", i);
+			break;
+		}
 		memset(pic, 0, sizeof(struct PIC_s));
+		hevc->m_PIC[i] = pic;
 		pic->index = i;
 		pic->BUF_index = -1;
-		if (config_pic(hevc, pic) < 0) {
-			if (debug)
-				pr_info("Config_pic %d fail\n", pic->index);
+		if (config_pic(hevc, pic, disp_addr) < 0) {
+			if (get_dbg_flag(hevc))
+				hevc_print(hevc, 0,
+					"Config_pic %d fail\n", pic->index);
 			pic->index = -1;
+			i++;
 			break;
 		}
 		pic->width = hevc->pic_w;
 		pic->height = hevc->pic_h;
-		set_canvas(pic);
+		if (get_double_write_mode(hevc))
+			set_canvas(hevc, pic);
 	}
 
 	for (; i < MAX_REF_PIC_NUM; i++) {
-		struct PIC_s *pic = &hevc->m_PIC[i];
+		struct PIC_s *pic =
+			vmalloc(sizeof(struct PIC_s));
+		if (pic == NULL) {
+			hevc_print(hevc, 0,
+				"alloc pic %d fail\n", i);
+			break;
+		}
 		memset(pic, 0, sizeof(struct PIC_s));
+		hevc->m_PIC[i] = pic;
 		pic->index = -1;
 		pic->BUF_index = -1;
 	}
 
 }
 
+static void uninit_pic_list(struct hevc_state_s *hevc)
+{
+	int i;
+	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+		struct PIC_s *pic = hevc->m_PIC[i];
+		if (pic) {
+			release_aux_data(hevc, pic);
+			vfree(pic);
+			hevc->m_PIC[i] = NULL;
+		}
+	}
+}
+
 #ifdef LOSLESS_COMPRESS_MODE
 static void init_decode_head_hw(struct hevc_state_s *hevc)
 {
+
+	struct BuffInfo_s *buf_spec = hevc->work_space_buf;
+	unsigned int data32;
+
 	int losless_comp_header_size =
 		compute_losless_comp_header_size(hevc->pic_w,
 			 hevc->pic_h);
@@ -1914,6 +2285,11 @@ static void init_decode_head_hw(struct hevc_state_s *hevc)
 
 	hevc->losless_comp_body_size = losless_comp_body_size;
 
+
+	if (mmu_enable) {
+		WRITE_VREG(HEVCD_MPP_DECOMP_CTL1, (0x1 << 4));
+		WRITE_VREG(HEVCD_MPP_DECOMP_CTL2, 0x0);
+	} else {
 	if (hevc->mem_saving_mode == 1)
 		WRITE_VREG(HEVCD_MPP_DECOMP_CTL1,
 			(1 << 3) | ((workaround_enable & 2) ? 1 : 0));
@@ -1923,13 +2299,31 @@ static void init_decode_head_hw(struct hevc_state_s *hevc)
 	WRITE_VREG(HEVCD_MPP_DECOMP_CTL2, (losless_comp_body_size >> 5));
 	/*WRITE_VREG(HEVCD_MPP_DECOMP_CTL3,(0xff<<20) | (0xff<<10) | 0xff);
 		//8-bit mode */
+	}
 	WRITE_VREG(HEVC_CM_BODY_LENGTH, losless_comp_body_size);
 	WRITE_VREG(HEVC_CM_HEADER_OFFSET, losless_comp_body_size);
 	WRITE_VREG(HEVC_CM_HEADER_LENGTH, losless_comp_header_size);
 
-	pr_info("%s: (%d, %d) body_size 0x%x header_size 0x%x\n",
-		__func__, hevc->pic_w, hevc->pic_h,
-		losless_comp_body_size, losless_comp_header_size);
+	if (mmu_enable) {
+		WRITE_VREG(HEVC_SAO_MMU_VH0_ADDR, buf_spec->mmu_vbh.buf_start);
+		WRITE_VREG(HEVC_SAO_MMU_VH1_ADDR,
+			buf_spec->mmu_vbh.buf_start +
+			buf_spec->mmu_vbh.buf_size/2);
+		data32 = READ_VREG(HEVC_SAO_CTRL9);
+		data32 |= 0x1;
+		WRITE_VREG(HEVC_SAO_CTRL9, data32);
+
+		/* use HEVC_CM_HEADER_START_ADDR */
+		data32 = READ_VREG(HEVC_SAO_CTRL5);
+		data32 |= (1<<10);
+		WRITE_VREG(HEVC_SAO_CTRL5, data32);
+	}
+
+	if (!hevc->m_ins_flag)
+		hevc_print(hevc, 0,
+			"%s: (%d, %d) body_size 0x%x header_size 0x%x\n",
+			__func__, hevc->pic_w, hevc->pic_h,
+			losless_comp_body_size, losless_comp_header_size);
 
 }
 #endif
@@ -1946,46 +2340,61 @@ static void init_pic_list_hw(struct hevc_state_s *hevc)
 		WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR, 0x0);
 
 	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-		if (hevc->m_PIC[i].index == -1) {
+		if (hevc->m_PIC[i] == NULL ||
+			hevc->m_PIC[i]->index == -1) {
 			cur_pic_num = i;
 			break;
 		}
-		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)
-			WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA,
-				hevc->m_PIC[i].mc_y_adr >> 5);
-		else
-			WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR,
-				hevc->m_PIC[i].mc_y_adr |
-				(hevc->m_PIC[i].mc_canvas_y << 8) | 0x1);
-		if (double_write_mode & 0x10) {
-			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
+			if (mmu_enable)
 				WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA,
-					hevc->m_PIC[i].mc_u_v_adr >> 5);
+					hevc->m_PIC[i]->header_adr>>5);
+			else
+				WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA,
+					hevc->m_PIC[i]->mc_y_adr >> 5);
+		} else
+			WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR,
+				hevc->m_PIC[i]->mc_y_adr |
+				(hevc->m_PIC[i]->mc_canvas_y << 8) | 0x1);
+		if (get_double_write_mode(hevc) & 0x10) {
+			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
+				if (mmu_enable)
+					WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA,
+						hevc->m_PIC[i]->header_adr>>5);
+				else
+					WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA,
+					hevc->m_PIC[i]->mc_u_v_adr >> 5);
+				}
 			else
 				WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR,
-					hevc->m_PIC[i].mc_u_v_adr |
-					(hevc->m_PIC[i].mc_canvas_u_v << 8)
+					hevc->m_PIC[i]->mc_u_v_adr |
+					(hevc->m_PIC[i]->mc_canvas_u_v << 8)
 					| 0x1);
 		}
 	}
-
+	if (cur_pic_num == 0)
+		return;
 	for (; i < MAX_REF_PIC_NUM; i++) {
 		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
-			WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA,
-				hevc->m_PIC[cur_pic_num-1].mc_y_adr >> 5);
+			if (mmu_enable)
+				WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA,
+				hevc->m_PIC[cur_pic_num-1]->header_adr>>5);
+			else
+				WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA,
+				hevc->m_PIC[cur_pic_num-1]->mc_y_adr >> 5);
 #ifndef LOSLESS_COMPRESS_MODE
 			WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_DATA,
-				hevc->m_PIC[cur_pic_num-1].mc_u_v_adr >> 5);
+				hevc->m_PIC[cur_pic_num-1]->mc_u_v_adr >> 5);
 #endif
 		} else {
 			WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR,
-				hevc->m_PIC[cur_pic_num-1].mc_y_adr|
-				(hevc->m_PIC[cur_pic_num-1].mc_canvas_y<<8)
+				hevc->m_PIC[cur_pic_num-1]->mc_y_adr|
+				(hevc->m_PIC[cur_pic_num-1]->mc_canvas_y<<8)
 				| 0x1);
 #ifndef LOSLESS_COMPRESS_MODE
 			WRITE_VREG(HEVCD_MPP_ANC2AXI_TBL_CMD_ADDR,
-				hevc->m_PIC[cur_pic_num-1].mc_u_v_adr|
-				(hevc->m_PIC[cur_pic_num-1].mc_canvas_u_v<<8)
+				hevc->m_PIC[cur_pic_num-1]->mc_u_v_adr|
+				(hevc->m_PIC[cur_pic_num-1]->mc_canvas_u_v<<8)
 				| 0x1);
 #endif
 		}
@@ -2000,7 +2409,7 @@ static void init_pic_list_hw(struct hevc_state_s *hevc)
 		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_DATA_ADDR, 0);
 
 #ifdef LOSLESS_COMPRESS_MODE
-	if ((double_write_mode & 0x10) == 0)
+	if ((get_double_write_mode(hevc) & 0x10) == 0)
 		init_decode_head_hw(hevc);
 #endif
 
@@ -2011,18 +2420,21 @@ static void dump_pic_list(struct hevc_state_s *hevc)
 {
 	int i;
 	struct PIC_s *pic;
-	pr_info("pic_list_init_flag is %d\r\n", hevc->pic_list_init_flag);
+	hevc_print(hevc, 0,
+		"pic_list_init_flag is %d\r\n", hevc->pic_list_init_flag);
 	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-		pic = &hevc->m_PIC[i];
-		if (pic->index == -1)
+		pic = hevc->m_PIC[i];
+		if (pic == NULL || pic->index == -1)
 			continue;
-		pr_info
-		("index %d decode_idx:%d,	POC:%d,	referenced:%d,	",
+		hevc_print_cont(hevc, 0,
+		"index %d decode_idx:%d,	POC:%d,	referenced:%d,	",
 		 pic->index, pic->decode_idx, pic->POC, pic->referenced);
-		pr_info("num_reorder_pic:%d, output_mark:%d, w/h %d,%d",
+		hevc_print_cont(hevc, 0,
+			"num_reorder_pic:%d, output_mark:%d, w/h %d,%d",
 				pic->num_reorder_pic, pic->output_mark,
 				pic->width, pic->height);
-		pr_info("output_ready:%d, mv_wr_start %x vf_ref %d\n",
+		hevc_print_cont(hevc, 0,
+			"output_ready:%d, mv_wr_start %x vf_ref %d\n",
 				pic->output_ready, pic->mpred_mv_wr_start_addr,
 				pic->vf_ref);
 	}
@@ -2037,8 +2449,9 @@ static struct PIC_s *output_pic(struct hevc_state_s *hevc,
 	struct PIC_s *pic_display = NULL;
 	if (i_only_flag & 0x4) {
 		for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-			pic = &hevc->m_PIC[i];
-			if ((pic->index == -1) || (pic->POC == INVALID_POC))
+			pic = hevc->m_PIC[i];
+			if (pic == NULL ||
+				(pic->index == -1) || (pic->POC == INVALID_POC))
 				continue;
 			if (pic->output_mark) {
 				if (pic_display) {
@@ -2059,16 +2472,18 @@ static struct PIC_s *output_pic(struct hevc_state_s *hevc,
 		}
 	} else {
 		for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-			pic = &hevc->m_PIC[i];
-			if ((pic->index == -1) || (pic->POC == INVALID_POC))
+			pic = hevc->m_PIC[i];
+			if (pic == NULL ||
+				(pic->index == -1) || (pic->POC == INVALID_POC))
 				continue;
 			if (pic->output_mark)
 				num_pic_not_yet_display++;
 		}
 
 		for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-			pic = &hevc->m_PIC[i];
-			if ((pic->index == -1) || (pic->POC == INVALID_POC))
+			pic = hevc->m_PIC[i];
+			if (pic == NULL ||
+				(pic->index == -1) || (pic->POC == INVALID_POC))
 				continue;
 			if (pic->output_mark) {
 				if (pic_display) {
@@ -2096,7 +2511,8 @@ static struct PIC_s *output_pic(struct hevc_state_s *hevc,
 				pic_display->output_mark = 0;
 				pic_display->recon_mark = 0;
 				pic_display->output_ready = 1;
-				pr_info("Warning, num_reorder_pic %d is byeond buf num\n",
+				hevc_print(hevc, 0,
+					"Warning, num_reorder_pic %d is byeond buf num\n",
 					pic_display->num_reorder_pic);
 			} else
 				pic_display = NULL;
@@ -2109,8 +2525,9 @@ static int config_mc_buffer(struct hevc_state_s *hevc, struct PIC_s *cur_pic)
 {
 	int i;
 	struct PIC_s *pic;
-	if (debug & H265_DEBUG_BUFMGR)
-		pr_info("config_mc_buffer entered .....\n");
+	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+		hevc_print(hevc, 0,
+			"config_mc_buffer entered .....\n");
 	if (cur_pic->slice_type != 2) {	/* P and B pic */
 		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
 				   (0 << 8) | (0 << 1) | 1);
@@ -2128,22 +2545,23 @@ static int config_mc_buffer(struct hevc_state_s *hevc, struct PIC_s *cur_pic)
 						| (pic->mc_canvas_u_v
 							<< 8) |
 						   pic->mc_canvas_y);
-				if (debug & H265_DEBUG_BUFMGR) {
-					pr_info
-					("refid %x mc_canvas_u_v %x",
+				if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+					hevc_print_cont(hevc, 0,
+					"refid %x mc_canvas_u_v %x",
 					 i, pic->mc_canvas_u_v);
-					pr_info(" mc_canvas_y %x\n",
+					hevc_print_cont(hevc, 0,
+						" mc_canvas_y %x\n",
 					 pic->mc_canvas_y);
 				}
 			} else {
-				if (debug) {
-					pr_info
-					("Error %s, %dth poc (%d)",
+				if (get_dbg_flag(hevc)) {
+					hevc_print_cont(hevc, 0,
+					"Error %s, %dth poc (%d)",
 					 __func__, i,
 					 cur_pic->m_aiRefPOCList0[cur_pic->
 					 slice_idx][i]);
-					pr_info
-					(" of RPS is not in the pic list0\n");
+					hevc_print_cont(hevc, 0,
+					" of RPS is not in the pic list0\n");
 				}
 				cur_pic->error_mark = 1;
 				/* dump_lmem(); */
@@ -2151,8 +2569,9 @@ static int config_mc_buffer(struct hevc_state_s *hevc, struct PIC_s *cur_pic)
 		}
 	}
 	if (cur_pic->slice_type == 0) {	/* B pic */
-		if (debug & H265_DEBUG_BUFMGR)
-			pr_info("config_mc_buffer RefNum_L1\n");
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+			hevc_print(hevc, 0,
+				"config_mc_buffer RefNum_L1\n");
 		WRITE_VREG(HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
 				   (16 << 8) | (0 << 1) | 1);
 		for (i = 0; i < cur_pic->RefNum_L1; i++) {
@@ -2169,22 +2588,23 @@ static int config_mc_buffer(struct hevc_state_s *hevc, struct PIC_s *cur_pic)
 						   | (pic->mc_canvas_u_v
 								   << 8) |
 						   pic->mc_canvas_y);
-				if (debug & H265_DEBUG_BUFMGR) {
-					pr_info
-					("refid %x mc_canvas_u_v %x",
+				if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+					hevc_print_cont(hevc, 0,
+					"refid %x mc_canvas_u_v %x",
 					 i, pic->mc_canvas_u_v);
-					pr_info(" mc_canvas_y %x\n",
+					hevc_print_cont(hevc, 0,
+						" mc_canvas_y %x\n",
 					 pic->mc_canvas_y);
 				}
 			} else {
-				if (debug) {
-					pr_info
-					("Error %s, %dth poc (%d)",
+				if (get_dbg_flag(hevc)) {
+					hevc_print_cont(hevc, 0,
+					"Error %s, %dth poc (%d)",
 					 __func__, i,
 					 cur_pic->m_aiRefPOCList1[cur_pic->
 					 slice_idx][i]);
-					pr_info
-					(" of RPS is not in the pic list1\n");
+					hevc_print_cont(hevc, 0,
+					" of RPS is not in the pic list1\n");
 				}
 				cur_pic->error_mark = 1;
 				/* dump_lmem(); */
@@ -2201,10 +2621,12 @@ static void apply_ref_pic_set(struct hevc_state_s *hevc, int cur_poc,
 	int poc_tmp;
 	struct PIC_s *pic;
 	unsigned char is_referenced;
-	/* pr_info("%s cur_poc %d\n", __func__, cur_poc); */
+	/* hevc_print(hevc, 0,
+	"%s cur_poc %d\n", __func__, cur_poc); */
 	for (ii = 0; ii < MAX_REF_PIC_NUM; ii++) {
-		pic = &hevc->m_PIC[ii];
-		if (pic->index == -1)
+		pic = hevc->m_PIC[ii];
+		if (pic == NULL ||
+			pic->index == -1)
 			continue;
 
 		if ((pic->referenced == 0 || pic->POC == cur_poc))
@@ -2225,20 +2647,22 @@ static void apply_ref_pic_set(struct hevc_state_s *hevc, int cur_poc,
 				poc_tmp = cur_poc + delt;
 			if (poc_tmp == pic->POC) {
 				is_referenced = 1;
-				/* pr_info("i is %d\n", i); */
+				/* hevc_print(hevc, 0, "i is %d\n", i); */
 				break;
 			}
 		}
 		if (is_referenced == 0) {
 			pic->referenced = 0;
-			/* pr_info("set poc %d reference to 0\n", pic->POC); */
+			/* hevc_print(hevc, 0,
+			"set poc %d reference to 0\n", pic->POC); */
 		}
 	}
 
 }
 
-static void set_ref_pic_list(struct PIC_s *pic, union param_u *params)
+static void set_ref_pic_list(struct hevc_state_s *hevc, union param_u *params)
 {
+	struct PIC_s *pic = hevc->cur_pic;
 	int i, rIdx;
 	int num_neg = 0;
 	int num_pos = 0;
@@ -2271,31 +2695,35 @@ static void set_ref_pic_list(struct PIC_s *pic, union param_u *params)
 				RefPicSetStCurr0[num_neg] =
 					pic->POC - ((1 << (RPS_USED_BIT - 1)) -
 								delt);
-				/* pr_info("RefPicSetStCurr0 %x %x %x\n",
+				/* hevc_print(hevc, 0,
+					"RefPicSetStCurr0 %x %x %x\n",
 				   RefPicSetStCurr0[num_neg], pic->POC,
 				   (0x800-(params[i]&0x7ff))); */
 				num_neg++;
 			} else {
 				RefPicSetStCurr1[num_pos] = pic->POC + delt;
-				/* pr_info("RefPicSetStCurr1 %d\n",
+				/* hevc_print(hevc, 0,
+					"RefPicSetStCurr1 %d\n",
 				   RefPicSetStCurr1[num_pos]); */
 				num_pos++;
 			}
 		}
 	}
 	total_num = num_neg + num_pos;
-	if (debug & H265_DEBUG_BUFMGR) {
-		pr_info
-		("%s: curpoc %d slice_type %d, total %d ",
+	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+		hevc_print(hevc, 0,
+		"%s: curpoc %d slice_type %d, total %d ",
 		 __func__, pic->POC, params->p.slice_type, total_num);
-		pr_info("num_neg %d num_list0 %d num_list1 %d\n",
+		hevc_print_cont(hevc, 0,
+			"num_neg %d num_list0 %d num_list1 %d\n",
 		 num_neg, num_ref_idx_l0_active, num_ref_idx_l1_active);
 	}
 
-	if (debug & H265_DEBUG_BUFMGR) {
-		pr_info
-		("HEVC Stream buf start ");
-		pr_info("%x end %x wr %x rd %x lev %x ctl %x intctl %x\n",
+	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+		hevc_print(hevc, 0,
+		"HEVC Stream buf start ");
+		hevc_print_cont(hevc, 0,
+		"%x end %x wr %x rd %x lev %x ctl %x intctl %x\n",
 		 READ_VREG(HEVC_STREAM_START_ADDR),
 		 READ_VREG(HEVC_STREAM_END_ADDR),
 		 READ_VREG(HEVC_STREAM_WR_PTR),
@@ -2307,8 +2735,8 @@ static void set_ref_pic_list(struct PIC_s *pic, union param_u *params)
 
 	if (total_num > 0) {
 		if (params->p.modification_flag & 0x1) {
-			if (debug & H265_DEBUG_BUFMGR)
-				pr_info("ref0 POC (modification):");
+			if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+				hevc_print(hevc, 0, "ref0 POC (modification):");
 			for (rIdx = 0; rIdx < num_ref_idx_l0_active; rIdx++) {
 				int cIdx = params->p.modification_list[rIdx];
 				pic->m_aiRefPOCList0[pic->slice_idx][rIdx] =
@@ -2316,16 +2744,16 @@ static void set_ref_pic_list(struct PIC_s *pic, union param_u *params)
 					num_neg ? RefPicSetStCurr1[cIdx -
 					num_neg] :
 					RefPicSetStCurr0[cIdx];
-				if (debug & H265_DEBUG_BUFMGR) {
-					pr_info("%d ",
+				if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+					hevc_print_cont(hevc, 0, "%d ",
 						   pic->m_aiRefPOCList0[pic->
 						   slice_idx]
 						   [rIdx]);
 				}
 			}
 		} else {
-			if (debug & H265_DEBUG_BUFMGR)
-				pr_info("ref0 POC:");
+			if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+				hevc_print(hevc, 0, "ref0 POC:");
 			for (rIdx = 0; rIdx < num_ref_idx_l0_active; rIdx++) {
 				int cIdx = rIdx % total_num;
 				pic->m_aiRefPOCList0[pic->slice_idx][rIdx] =
@@ -2333,20 +2761,21 @@ static void set_ref_pic_list(struct PIC_s *pic, union param_u *params)
 					num_neg ? RefPicSetStCurr1[cIdx -
 					num_neg] :
 					RefPicSetStCurr0[cIdx];
-				if (debug & H265_DEBUG_BUFMGR) {
-					pr_info("%d ",
+				if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+					hevc_print_cont(hevc, 0, "%d ",
 						   pic->m_aiRefPOCList0[pic->
 						   slice_idx]
 						   [rIdx]);
 				}
 			}
 		}
-		if (debug & H265_DEBUG_BUFMGR)
-			pr_info("\n");
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+			hevc_print_cont(hevc, 0, "\n");
 		if (params->p.slice_type == B_SLICE) {
 			if (params->p.modification_flag & 0x2) {
-				if (debug & H265_DEBUG_BUFMGR)
-					pr_info("ref1 POC (modification):");
+				if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+					hevc_print(hevc, 0,
+						"ref1 POC (modification):");
 				for (rIdx = 0; rIdx < num_ref_idx_l1_active;
 					 rIdx++) {
 					int cIdx;
@@ -2367,8 +2796,9 @@ static void set_ref_pic_list(struct PIC_s *pic, union param_u *params)
 						num_pos ?
 						RefPicSetStCurr0[cIdx -	num_pos]
 						: RefPicSetStCurr1[cIdx];
-					if (debug & H265_DEBUG_BUFMGR) {
-						pr_info("%d ",
+					if (get_dbg_flag(hevc) &
+						H265_DEBUG_BUFMGR) {
+						hevc_print_cont(hevc, 0, "%d ",
 							   pic->
 							   m_aiRefPOCList1[pic->
 							   slice_idx]
@@ -2376,8 +2806,9 @@ static void set_ref_pic_list(struct PIC_s *pic, union param_u *params)
 					}
 				}
 			} else {
-				if (debug & H265_DEBUG_BUFMGR)
-					pr_info("ref1 POC:");
+				if (get_dbg_flag(hevc) &
+					H265_DEBUG_BUFMGR)
+					hevc_print(hevc, 0, "ref1 POC:");
 				for (rIdx = 0; rIdx < num_ref_idx_l1_active;
 					 rIdx++) {
 					int cIdx = rIdx % total_num;
@@ -2388,8 +2819,9 @@ static void set_ref_pic_list(struct PIC_s *pic, union param_u *params)
 						RefPicSetStCurr0[cIdx -
 						num_pos]
 						: RefPicSetStCurr1[cIdx];
-					if (debug & H265_DEBUG_BUFMGR) {
-						pr_info("%d ",
+					if (get_dbg_flag(hevc) &
+						H265_DEBUG_BUFMGR) {
+						hevc_print_cont(hevc, 0, "%d ",
 							   pic->
 							   m_aiRefPOCList1[pic->
 							   slice_idx]
@@ -2397,8 +2829,8 @@ static void set_ref_pic_list(struct PIC_s *pic, union param_u *params)
 					}
 				}
 			}
-			if (debug & H265_DEBUG_BUFMGR)
-				pr_info("\n");
+			if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+				hevc_print_cont(hevc, 0, "\n");
 		}
 	}
 	/*set m_PIC */
@@ -2426,20 +2858,23 @@ static void update_tile_info(struct hevc_state_s *hevc, int pic_width_cu,
 		if (hevc->num_tile_row > MAX_TILE_ROW_NUM
 			|| hevc->num_tile_row <= 0) {
 			hevc->num_tile_row = 1;
-			pr_info("%s: num_tile_rows_minus1 (%d) error!!\n",
+			hevc_print(hevc, 0,
+				"%s: num_tile_rows_minus1 (%d) error!!\n",
 				   __func__, params->p.num_tile_rows_minus1);
 		}
 		if (hevc->num_tile_col > MAX_TILE_COL_NUM
 			|| hevc->num_tile_col <= 0) {
 			hevc->num_tile_col = 1;
-			pr_info("%s: num_tile_columns_minus1 (%d) error!!\n",
+			hevc_print(hevc, 0,
+				"%s: num_tile_columns_minus1 (%d) error!!\n",
 				   __func__, params->p.num_tile_columns_minus1);
 		}
-		if (debug & H265_DEBUG_BUFMGR) {
-			pr_info
-			("%s pic_w_cu %d pic_h_cu %d tile_enabled ",
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+			hevc_print(hevc, 0,
+			"%s pic_w_cu %d pic_h_cu %d tile_enabled ",
 			 __func__, pic_width_cu, pic_height_cu);
-			pr_info("num_tile_col %d num_tile_row %d:\n",
+			hevc_print_cont(hevc, 0,
+				"num_tile_col %d num_tile_row %d:\n",
 			 hevc->num_tile_col, hevc->num_tile_row);
 		}
 
@@ -2472,21 +2907,22 @@ static void update_tile_info(struct hevc_state_s *hevc, int pic_width_cu,
 					hevc->m_tile[i][j].sao_abv_start_addr =
 						hevc->work_space_buf->sao_abv.
 						buf_start + i * sao_abv_size;
-					if (debug & H265_DEBUG_BUFMGR) {
-						pr_info
-						("{y=%d, x=%d w %d h %d ",
+					if (get_dbg_flag(hevc) &
+						H265_DEBUG_BUFMGR) {
+						hevc_print_cont(hevc, 0,
+						"{y=%d, x=%d w %d h %d ",
 						 i, j, hevc->m_tile[i][j].width,
 						 hevc->m_tile[i][j].height);
-						pr_info
-						("start_x %d start_y %d ",
+						hevc_print_cont(hevc, 0,
+						"start_x %d start_y %d ",
 						 hevc->m_tile[i][j].start_cu_x,
 						 hevc->m_tile[i][j].start_cu_y);
-						pr_info
-						("sao_vb_start 0x%x ",
+						hevc_print_cont(hevc, 0,
+						"sao_vb_start 0x%x ",
 						 hevc->m_tile[i][j].
 						 sao_vb_start_addr);
-						pr_info
-						("sao_abv_start 0x%x}\n",
+						hevc_print_cont(hevc, 0,
+						"sao_abv_start 0x%x}\n",
 						 hevc->m_tile[i][j].
 						 sao_abv_start_addr);
 					}
@@ -2527,21 +2963,22 @@ static void update_tile_info(struct hevc_state_s *hevc, int pic_width_cu,
 					hevc->m_tile[i][j].sao_abv_start_addr =
 						hevc->work_space_buf->sao_abv.
 						buf_start + i * sao_abv_size;
-					if (debug & H265_DEBUG_BUFMGR) {
-						pr_info
-						("{y=%d, x=%d w %d h %d ",
+					if (get_dbg_flag(hevc) &
+						H265_DEBUG_BUFMGR) {
+						hevc_print_cont(hevc, 0,
+						"{y=%d, x=%d w %d h %d ",
 						 i, j, hevc->m_tile[i][j].width,
 						 hevc->m_tile[i][j].height);
-						pr_info
-						("start_x %d start_y %d ",
+						hevc_print_cont(hevc, 0,
+						"start_x %d start_y %d ",
 						 hevc->m_tile[i][j].start_cu_x,
 						 hevc->m_tile[i][j].start_cu_y);
-						pr_info
-						("sao_vb_start 0x%x ",
+						hevc_print_cont(hevc, 0,
+						"sao_vb_start 0x%x ",
 						 hevc->m_tile[i][j].
 						 sao_vb_start_addr);
-						pr_info
-						("sao_abv_start 0x%x}\n",
+						hevc_print_cont(hevc, 0,
+						"sao_abv_start 0x%x}\n",
 						 hevc->m_tile[i][j].
 						 sao_abv_start_addr);
 
@@ -2574,9 +3011,9 @@ static int get_tile_index(struct hevc_state_s *hevc, int cu_adr,
 	int tile_y = 0;
 	int i;
 	if (pic_width_lcu == 0) {
-		if (debug) {
-			pr_info
-			("%s Error, pic_width_lcu is 0, pic_w %d, pic_h %d\n",
+		if (get_dbg_flag(hevc)) {
+			hevc_print(hevc, 0,
+			"%s Error, pic_width_lcu is 0, pic_w %d, pic_h %d\n",
 			 __func__, hevc->pic_w, hevc->pic_h);
 		}
 		return -1;
@@ -2602,18 +3039,22 @@ static int get_tile_index(struct hevc_state_s *hevc, int cu_adr,
 
 static void print_scratch_error(int error_num)
 {
-	if (debug) {
-		pr_info(" ERROR : HEVC_ASSIST_SCRATCH_TEST Error : %d\n",
+#if 0
+	if (get_dbg_flag(hevc)) {
+		hevc_print(hevc, 0,
+		" ERROR : HEVC_ASSIST_SCRATCH_TEST Error : %d\n",
 			   error_num);
 	}
+#endif
 }
 
 static void hevc_config_work_space_hw(struct hevc_state_s *hevc)
 {
 	struct BuffInfo_s *buf_spec = hevc->work_space_buf;
 
-	if (debug)
-		pr_info("%s %x %x %x %x %x %x %x %x %x %x %x %x\n",
+	if (get_dbg_flag(hevc))
+		hevc_print(hevc, 0,
+			"%s %x %x %x %x %x %x %x %x %x %x %x %x\n",
 			__func__,
 			buf_spec->ipp.buf_start,
 			buf_spec->start_adr,
@@ -2628,14 +3069,18 @@ static void hevc_config_work_space_hw(struct hevc_state_s *hevc)
 			buf_spec->dblk_para.buf_start,
 			buf_spec->dblk_data.buf_start);
 	WRITE_VREG(HEVCD_IPP_LINEBUFF_BASE, buf_spec->ipp.buf_start);
-	if ((debug & H265_DEBUG_SEND_PARAM_WITH_REG) == 0)
+	if ((get_dbg_flag(hevc) & H265_DEBUG_SEND_PARAM_WITH_REG) == 0)
 		WRITE_VREG(HEVC_RPM_BUFFER, (u32)hevc->rpm_phy_addr);
 	WRITE_VREG(HEVC_SHORT_TERM_RPS, buf_spec->short_term_rps.buf_start);
 	WRITE_VREG(HEVC_VPS_BUFFER, buf_spec->vps.buf_start);
 	WRITE_VREG(HEVC_SPS_BUFFER, buf_spec->sps.buf_start);
 	WRITE_VREG(HEVC_PPS_BUFFER, buf_spec->pps.buf_start);
 	WRITE_VREG(HEVC_SAO_UP, buf_spec->sao_up.buf_start);
-	WRITE_VREG(HEVC_STREAM_SWAP_BUFFER, buf_spec->swap_buf.buf_start);
+	if (mmu_enable)
+		WRITE_VREG(H265_MMU_MAP_BUFFER, hevc->frame_mmu_map_phy_addr);
+	else
+		WRITE_VREG(HEVC_STREAM_SWAP_BUFFER,
+				buf_spec->swap_buf.buf_start);
 	WRITE_VREG(HEVC_STREAM_SWAP_BUFFER2, buf_spec->swap_buf2.buf_start);
 	WRITE_VREG(HEVC_SCALELUT, buf_spec->scalelut.buf_start);
 	/* cfg_p_addr */
@@ -2643,20 +3088,22 @@ static void hevc_config_work_space_hw(struct hevc_state_s *hevc)
 	/* cfg_d_addr */
 	WRITE_VREG(HEVC_DBLK_CFG5, buf_spec->dblk_data.buf_start);
 
-	if (debug & H265_DEBUG_UCODE)
+	if (get_dbg_flag(hevc) & H265_DEBUG_UCODE)
 		WRITE_VREG(LMEM_DUMP_ADR, (u32)hevc->lmem_phy_addr);
 
 }
 
-static void hevc_init_decoder_hw(int decode_pic_begin, int decode_pic_num)
+static void hevc_init_decoder_hw(struct hevc_state_s *hevc,
+	int decode_pic_begin, int decode_pic_num)
 {
 	unsigned int data32;
 	int i;
 
 #if 1
 	/* m8baby test1902 */
-	if (debug & H265_DEBUG_BUFMGR)
-		pr_info("[test.c] Test Parser Register Read/Write\n");
+	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+		hevc_print(hevc, 0,
+			"[test.c] Test Parser Register Read/Write\n");
 	data32 = READ_VREG(HEVC_PARSER_VERSION);
 	if (data32 != 0x00010001) {
 		print_scratch_error(25);
@@ -2677,7 +3124,8 @@ static void hevc_init_decoder_hw(int decode_pic_begin, int decode_pic_num)
 	WRITE_VREG(DOS_SW_RESET3, 0);	/* clear reset_whole parser */
 	data32 = READ_VREG(HEVC_PARSER_VERSION);
 	if (data32 != 0x00010001)
-		pr_info("Test Parser Fatal Error\n");
+		hevc_print(hevc, 0,
+		"Test Parser Fatal Error\n");
 #endif
 	/* reset iqit to start mem init again */
 	WRITE_VREG(DOS_SW_RESET3, (1 << 14)
@@ -2687,13 +3135,15 @@ static void hevc_init_decoder_hw(int decode_pic_begin, int decode_pic_num)
 
 #endif
 
-	if (debug & H265_DEBUG_BUFMGR)
-		pr_info("[test.c] Enable BitStream Fetch\n");
-	data32 = READ_VREG(HEVC_STREAM_CONTROL);
-	data32 = data32 | (1 << 0)	/* stream_fetch_enable */
+	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+		hevc_print(hevc, 0,
+			"[test.c] Enable BitStream Fetch\n");
 			 ;
-	WRITE_VREG(HEVC_STREAM_CONTROL, data32);
-
+	if (!hevc->m_ins_flag) {
+		data32 = READ_VREG(HEVC_STREAM_CONTROL);
+		data32 = data32 | (1 << 0);      /* stream_fetch_enable */
+		WRITE_VREG(HEVC_STREAM_CONTROL, data32);
+	}
 	data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
 	if (data32 != 0x00000100) {
 		print_scratch_error(29);
@@ -2719,8 +3169,9 @@ static void hevc_init_decoder_hw(int decode_pic_begin, int decode_pic_num)
 	WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x00000100);
 	WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x00000300);
 
-	if (debug & H265_DEBUG_BUFMGR)
-		pr_info("[test.c] Enable HEVC Parser Interrupt\n");
+	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+		hevc_print(hevc, 0,
+			"[test.c] Enable HEVC Parser Interrupt\n");
 	data32 = READ_VREG(HEVC_PARSER_INT_CONTROL);
 	data32 &= 0x03ffffff;
 	data32 = data32 | (3 << 29) | (2 << 26) | (1 << 24)
@@ -2733,8 +3184,9 @@ static void hevc_init_decoder_hw(int decode_pic_begin, int decode_pic_num)
 			 ;
 	WRITE_VREG(HEVC_PARSER_INT_CONTROL, data32);
 
-	if (debug & H265_DEBUG_BUFMGR)
-		pr_info("[test.c] Enable HEVC Parser Shift\n");
+	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+		hevc_print(hevc, 0,
+			"[test.c] Enable HEVC Parser Shift\n");
 
 	data32 = READ_VREG(HEVC_SHIFT_STATUS);
 	data32 = data32 | (1 << 1) |	/* emulation_check_on */
@@ -2757,11 +3209,11 @@ static void hevc_init_decoder_hw(int decode_pic_begin, int decode_pic_num)
 	WRITE_VREG(HEVC_DEC_STATUS_REG, 0);
 
 	/* Initial IQIT_SCALELUT memory -- just to avoid X in simulation */
-	if (debug & H265_DEBUG_BUFMGR) {
-		pr_info
-		("[test.c] Initial IQIT_SCALELUT memory --");
-		pr_info
-		(" just to avoid X in simulation...\n");
+	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+		hevc_print(hevc, 0,
+		"[test.c] Initial IQIT_SCALELUT memory --");
+		hevc_print_cont(hevc, 0,
+		" just to avoid X in simulation...\n");
 	}
 	WRITE_VREG(HEVC_IQIT_SCALELUT_WR_ADDR, 0);	/* cfg_p_addr */
 	for (i = 0; i < 1024; i++)
@@ -2769,16 +3221,16 @@ static void hevc_init_decoder_hw(int decode_pic_begin, int decode_pic_num)
 
 #ifdef ENABLE_SWAP_TEST
 	WRITE_VREG(HEVC_STREAM_SWAP_TEST, 100);
-#else
-	WRITE_VREG(HEVC_STREAM_SWAP_TEST, 0);
 #endif
 
-	WRITE_VREG(HEVC_DECODE_PIC_BEGIN_REG, 0);
-	WRITE_VREG(HEVC_DECODE_PIC_NUM_REG, 0xffffffff);
-
+	/*WRITE_VREG(HEVC_DECODE_PIC_BEGIN_REG, 0);*/
+	/*WRITE_VREG(HEVC_DECODE_PIC_NUM_REG, 0xffffffff);*/
+	WRITE_VREG(HEVC_DECODE_SIZE, 0);
+	/*WRITE_VREG(HEVC_DECODE_COUNT, 0);*/
 	/* Send parser_cmd */
-	if (debug)
-		pr_info("[test.c] SEND Parser Command ...\n");
+	if (get_dbg_flag(hevc))
+		hevc_print(hevc, 0,
+			"[test.c] SEND Parser Command ...\n");
 	WRITE_VREG(HEVC_PARSER_CMD_WRITE, (1 << 16) | (0 << 0));
 	for (i = 0; i < PARSER_CMD_NUMBER; i++)
 		WRITE_VREG(HEVC_PARSER_CMD_WRITE, parser_cmd[i]);
@@ -2796,14 +3248,15 @@ static void hevc_init_decoder_hw(int decode_pic_begin, int decode_pic_num)
 
 	/* Changed to Start MPRED in microcode */
 	/*
-	   pr_info("[test.c] Start MPRED\n");
+	   hevc_print(hevc, 0, "[test.c] Start MPRED\n");
 	   WRITE_VREG(HEVC_MPRED_INT_STATUS,
 	   (1<<31)
 	   );
 	 */
 
-	if (debug)
-		pr_info("[test.c] Reset IPP\n");
+	if (get_dbg_flag(hevc))
+		hevc_print(hevc, 0,
+			"[test.c] Reset IPP\n");
 	WRITE_VREG(HEVCD_IPP_TOP_CNTL, (0 << 1) |	/* enable ipp */
 			   (1 << 0)	/* software reset ipp and mpp */
 			  );
@@ -2811,7 +3264,7 @@ static void hevc_init_decoder_hw(int decode_pic_begin, int decode_pic_num)
 			   (0 << 0)	/* software reset ipp and mpp */
 			  );
 
-	if (double_write_mode & 0x10)
+	if (get_double_write_mode(hevc) & 0x10)
 		WRITE_VREG(HEVCD_MPP_DECOMP_CTL1,
 			0x1 << 31  /*/Enable NV21 reference read mode for MC*/
 			);
@@ -2969,7 +3422,7 @@ static void config_mcrcc_axi_hw(struct hevc_state_s *hevc, int slice_type)
 	unsigned int rdata32_2;
 	int l0_cnt = 0;
 	int l1_cnt = 0x7fff;
-	if (double_write_mode & 0x10) {
+	if (get_double_write_mode(hevc) & 0x10) {
 		l0_cnt = hevc->cur_pic->RefNum_L0;
 		l1_cnt = hevc->cur_pic->RefNum_L1;
 	}
@@ -3036,6 +3489,15 @@ static void config_title_hw(struct hevc_state_s *hevc, int sao_vb_size,
 	WRITE_VREG(HEVC_SAO_VB, hevc->work_space_buf->sao_vb.buf_start);
 }
 
+static void config_aux_buf(struct hevc_state_s *hevc)
+{
+	WRITE_VREG(HEVC_AUX_ADR, hevc->aux_phy_addr);
+	WRITE_VREG(HEVC_AUX_DATA_SIZE,
+		((hevc->prefix_aux_size >> 4) << 16) |
+		(hevc->suffix_aux_size >> 4)
+		);
+}
+
 static void config_mpred_hw(struct hevc_state_s *hevc)
 {
 	int i;
@@ -3099,9 +3561,10 @@ static void config_mpred_hw(struct hevc_state_s *hevc)
 		cur_pic->mpred_mv_wr_start_addr +
 		(hevc->slice_addr * MV_MEM_UNIT);
 
-	if (debug & H265_DEBUG_BUFMGR) {
-		pr_info("cur pic index %d  col pic index %d\n", cur_pic->index,
-			   col_pic->index);
+	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+		hevc_print(hevc, 0,
+			"cur pic index %d  col pic index %d\n", cur_pic->index,
+			col_pic->index);
 	}
 
 	WRITE_VREG(HEVC_MPRED_MV_WR_START_ADDR,
@@ -3271,10 +3734,10 @@ static void config_sao_hw(struct hevc_state_s *hevc, union param_u *params)
 		WRITE_VREG(HEVC_SAO_Y_START_ADDR, 0xffffffff);
 #ifdef LOSLESS_COMPRESS_MODE
 /*SUPPORT_10BIT*/
-	if ((double_write_mode & 0x10) == 0) {
+	if ((get_double_write_mode(hevc) & 0x10) == 0) {
 		data32 = READ_VREG(HEVC_SAO_CTRL5);
 		data32 &= (~(0xff << 16));
-		if (double_write_mode != 1)
+		if (get_double_write_mode(hevc) != 1)
 			data32 |= (0xff<<16);
 		if (hevc->mem_saving_mode == 1)
 			data32 |= (1 << 9);
@@ -3285,11 +3748,14 @@ static void config_sao_hw(struct hevc_state_s *hevc, union param_u *params)
 		WRITE_VREG(HEVC_SAO_CTRL5, data32);
 	}
 	data32 = cur_pic->mc_y_adr;
-	if (double_write_mode)
+	if (get_double_write_mode(hevc))
 		WRITE_VREG(HEVC_SAO_Y_START_ADDR, cur_pic->dw_y_adr);
 
-	if ((double_write_mode & 0x10) == 0)
+	if ((get_double_write_mode(hevc) & 0x10) == 0)
 		WRITE_VREG(HEVC_CM_BODY_START_ADDR, data32);
+
+	if (mmu_enable)
+		WRITE_VREG(HEVC_CM_HEADER_START_ADDR, cur_pic->header_adr);
 #else
 	data32 = cur_pic->mc_y_adr;
 	WRITE_VREG(HEVC_SAO_Y_START_ADDR, data32);
@@ -3299,7 +3765,7 @@ static void config_sao_hw(struct hevc_state_s *hevc, union param_u *params)
 
 #ifdef LOSLESS_COMPRESS_MODE
 /*SUPPORT_10BIT*/
-	if (double_write_mode)
+	if (get_double_write_mode(hevc))
 		WRITE_VREG(HEVC_SAO_C_START_ADDR, cur_pic->dw_u_v_adr);
 #else
 	data32 = cur_pic->mc_u_v_adr;
@@ -3310,7 +3776,7 @@ static void config_sao_hw(struct hevc_state_s *hevc, union param_u *params)
 
 #ifdef LOSLESS_COMPRESS_MODE
 /*SUPPORT_10BIT*/
-	if (double_write_mode) {
+	if (get_double_write_mode(hevc)) {
 		WRITE_VREG(HEVC_SAO_Y_WPTR, cur_pic->dw_y_adr);
 		WRITE_VREG(HEVC_SAO_C_WPTR, cur_pic->dw_u_v_adr);
 	}
@@ -3370,13 +3836,13 @@ static void config_sao_hw(struct hevc_state_s *hevc, union param_u *params)
 	/* data32 |= 0x670;  // Big-Endian per 64-bit */
 	data32 |= endian;	/* Big-Endian per 64-bit */
 	data32 &= (~0x3); /*[1]:dw_disable [0]:cm_disable*/
-	if (double_write_mode == 0)
+	if (get_double_write_mode(hevc) == 0)
 		data32 |= 0x2; /*disable double write*/
-	else if (double_write_mode & 0x10)
+	else if (!mmu_enable && (get_double_write_mode(hevc) & 0x10))
 		data32 |= 0x1; /*disable cm*/
 	WRITE_VREG(HEVC_SAO_CTRL1, data32);
 
-	if (double_write_mode & 0x10) {
+	if (get_double_write_mode(hevc) & 0x10) {
 		/* [23:22] dw_v1_ctrl
 		[21:20] dw_v0_ctrl
 		[19:18] dw_h1_ctrl
@@ -3422,27 +3888,31 @@ static void config_sao_hw(struct hevc_state_s *hevc, union param_u *params)
 		   (misc_flag0>>SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT)&0x1;
 		//ucode has handle it , so read it from ucode directly */
 		data32 |= slice_deblocking_filter_disabled_flag << 2;
-		if (debug & H265_DEBUG_BUFMGR)
-			pr_info("(1,%x)", data32);
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+			hevc_print_cont(hevc, 0,
+			"(1,%x)", data32);
 		if (!slice_deblocking_filter_disabled_flag) {
 			data32 |= (params->p.slice_beta_offset_div2 & 0xf) << 3;
 			data32 |= (params->p.slice_tc_offset_div2 & 0xf) << 7;
-			if (debug & H265_DEBUG_BUFMGR)
-				pr_info("(2,%x)", data32);
+			if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+				hevc_print_cont(hevc, 0,
+				"(2,%x)", data32);
 		}
 	} else {
 		data32 |=
 			((misc_flag0 >>
 			  PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT) &
 			 0x1) << 2;
-		if (debug & H265_DEBUG_BUFMGR)
-			pr_info("(3,%x)", data32);
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+			hevc_print_cont(hevc, 0,
+			"(3,%x)", data32);
 		if (((misc_flag0 >> PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT) &
 			 0x1) == 0) {
 			data32 |= (params->p.pps_beta_offset_div2 & 0xf) << 3;
 			data32 |= (params->p.pps_tc_offset_div2 & 0xf) << 7;
-			if (debug & H265_DEBUG_BUFMGR)
-				pr_info("(4,%x)", data32);
+			if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+				hevc_print_cont(hevc, 0,
+				"(4,%x)", data32);
 		}
 	}
 	if ((misc_flag0 & (1 << PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT))
@@ -3457,8 +3927,9 @@ static void config_sao_hw(struct hevc_state_s *hevc, union param_u *params)
 			((misc_flag0 >>
 			  SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)
 			& 0x1) << 9;
-		if (debug & H265_DEBUG_BUFMGR)
-			pr_info("(5,%x)\n", data32);
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+			hevc_print_cont(hevc, 0,
+			"(5,%x)\n", data32);
 	} else {
 		data32 |=
 			((misc_flag0 >>
@@ -3468,8 +3939,9 @@ static void config_sao_hw(struct hevc_state_s *hevc, union param_u *params)
 			((misc_flag0 >>
 			  PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)
 			 & 0x1) << 9;
-		if (debug & H265_DEBUG_BUFMGR)
-			pr_info("(6,%x)\n", data32);
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+			hevc_print_cont(hevc, 0,
+			"(6,%x)\n", data32);
 	}
 	WRITE_VREG(HEVC_DBLK_CFG9, data32);
 	WRITE_VREG(HEVC_SAO_CTRL0, data32_2);
@@ -3479,12 +3951,13 @@ static void clear_used_by_display_flag(struct hevc_state_s *hevc)
 {
 	struct PIC_s *pic;
 	int i;
-	if (debug & H265_DEBUG_NOT_USE_LAST_DISPBUF)
+	if (get_dbg_flag(hevc) & H265_DEBUG_NOT_USE_LAST_DISPBUF)
 		return;
 
 	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-		pic = &hevc->m_PIC[i];
-		pic->used_by_display = 0;
+		pic = hevc->m_PIC[i];
+		if (pic)
+			pic->used_by_display = 0;
 	}
 }
 
@@ -3495,11 +3968,12 @@ static struct PIC_s *get_new_pic(struct hevc_state_s *hevc,
 	struct PIC_s *pic;
 	/* recycle un-used pic */
 	int i;
+	int ret;
 	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-		pic = &hevc->m_PIC[i];
-		if (pic->index == -1)
+		pic = hevc->m_PIC[i];
+		if (pic == NULL || pic->index == -1)
 			continue;
-		if ((pic->used_by_display)
+		if ((pic->used_by_display) && !mmu_enable
 			&& ((READ_VCBUS_REG(AFBC_BODY_BADDR) << 4) !=
 				pic->mc_y_adr))
 			pic->used_by_display = 0;
@@ -3518,32 +3992,39 @@ static struct PIC_s *get_new_pic(struct hevc_state_s *hevc,
 	if (re_config_pic_flag && new_pic == NULL) {
 		int ii;
 		for (ii = 0; ii < MAX_REF_PIC_NUM; ii++) {
-			if (hevc->m_PIC[ii].index == -1)
+			if (hevc->m_PIC[ii] == NULL ||
+				hevc->m_PIC[ii]->index == -1)
 				break;
 		}
 		if (ii < MAX_REF_PIC_NUM) {
-			new_pic = &hevc->m_PIC[ii];
-			memset(new_pic, 0, sizeof(struct PIC_s));
-			new_pic->index = ii;
-			new_pic->BUF_index = -1;
+			new_pic = hevc->m_PIC[ii];
+			if (new_pic) {
+				memset(new_pic, 0, sizeof(struct PIC_s));
+				new_pic->index = ii;
+				new_pic->BUF_index = -1;
+			}
 		}
 	}
 	/**/
 
 	if (new_pic == NULL) {
-		/* pr_info("Error: Buffer management, no free buffer\n"); */
+		/* hevc_print(hevc, 0,
+		"Error: Buffer management, no free buffer\n"); */
 		return new_pic;
 	}
 
 	new_pic->referenced = 1;
-	if (new_pic->width != hevc->pic_w || new_pic->height != hevc->pic_h) {
+	if (new_pic->width != hevc->pic_w ||
+		new_pic->height != hevc->pic_h) {
 		if (re_config_pic_flag) {
 			/* re config pic for new resolution */
 			recycle_buf(hevc);
 			/* if(new_pic->BUF_index == -1){ */
-			if (config_pic(hevc, new_pic) < 0) {
-				if (debug & H265_DEBUG_BUFMGR_MORE) {
-					pr_info("Config_pic %d fail\n",
+			if (config_pic(hevc, new_pic, 0) < 0) {
+				if (get_dbg_flag(hevc) &
+					H265_DEBUG_BUFMGR_MORE) {
+					hevc_print(hevc, 0,
+					"Config_pic %d fail\n",
 					new_pic->index);
 					dump_pic_list(hevc);
 				}
@@ -3555,7 +4036,7 @@ static struct PIC_s *get_new_pic(struct hevc_state_s *hevc,
 		if (new_pic) {
 			new_pic->width = hevc->pic_w;
 			new_pic->height = hevc->pic_h;
-			set_canvas(new_pic);
+			set_canvas(hevc, new_pic);
 		}
 	}
 	if (new_pic) {
@@ -3570,7 +4051,24 @@ static struct PIC_s *get_new_pic(struct hevc_state_s *hevc,
 		new_pic->losless_comp_body_size = hevc->losless_comp_body_size;
 		new_pic->POC = hevc->curr_POC;
 		new_pic->pic_struct = hevc->curr_pic_struct;
+		if (new_pic->aux_data_buf)
+			release_aux_data(hevc, new_pic);
+	}
+
+	if (mmu_enable) {
+		ret = H265_alloc_mmu(hevc, new_pic, rpm_param->p.bit_depth,
+			hevc->frame_mmu_map_addr);
+			/*hevc_print(hevc, 0,
+			"get pic index %x\n",new_pic->index);*/
+		if (ret != 0) {
+			pr_err("can't alloc need mmu1,idx %d ret =%d\n",
+			new_pic->decode_idx,
+			ret);
+		return NULL;
+		}
+
 	}
+
 	return new_pic;
 }
 
@@ -3580,8 +4078,9 @@ static int get_display_pic_num(struct hevc_state_s *hevc)
 	struct PIC_s *pic;
 	int num = 0;
 	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
-		pic = &hevc->m_PIC[i];
-		if (pic->index == -1)
+		pic = hevc->m_PIC[i];
+		if (pic == NULL ||
+			pic->index == -1)
 			continue;
 
 		if (pic->output_ready == 1)
@@ -3621,18 +4120,20 @@ static void flush_output(struct hevc_state_s *hevc, struct PIC_s *pic)
 			pic_display->referenced = 0;
 			if ((pic_display->error_mark
 				 && ((hevc->ignore_bufmgr_error & 0x2) == 0))
-				|| (debug & H265_DEBUG_DISPLAY_CUR_FRAME)
-				|| (debug & H265_DEBUG_NO_DISPLAY)) {
+				|| (get_dbg_flag(hevc) &
+					H265_DEBUG_DISPLAY_CUR_FRAME)
+				|| (get_dbg_flag(hevc) &
+					H265_DEBUG_NO_DISPLAY)) {
 				pic_display->output_ready = 0;
-				if (debug & H265_DEBUG_BUFMGR) {
-					pr_info
-					("[BM] Display: POC %d, ",
+				if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+					hevc_print(hevc, 0,
+					"[BM] Display: POC %d, ",
 					 pic_display->POC);
-					pr_info
-					("decoding index %d ==> ",
+					hevc_print_cont(hevc, 0,
+					"decoding index %d ==> ",
 					 pic_display->decode_idx);
-					pr_info
-					("Debug mode or error, recycle it\n");
+					hevc_print_cont(hevc, 0,
+					"Debug mode or error, recycle it\n");
 				}
 			} else {
 				if (i_only_flag & 0x1
@@ -3640,12 +4141,13 @@ static void flush_output(struct hevc_state_s *hevc, struct PIC_s *pic)
 					pic_display->output_ready = 0;
 				else {
 					prepare_display_buf(hevc, pic_display);
-					if (debug & H265_DEBUG_BUFMGR) {
-						pr_info
-						("[BM] flush Display: POC %d, ",
+					if (get_dbg_flag(hevc)
+						& H265_DEBUG_BUFMGR) {
+						hevc_print(hevc, 0,
+						"[BM] flush Display: POC %d, ",
 						 pic_display->POC);
-						pr_info
-						("decoding index %d\n",
+						hevc_print_cont(hevc, 0,
+						"decoding index %d\n",
 						 pic_display->decode_idx);
 					}
 				}
@@ -3654,8 +4156,127 @@ static void flush_output(struct hevc_state_s *hevc, struct PIC_s *pic)
 	} while (pic_display);
 }
 
-static inline void hevc_pre_pic(struct hevc_state_s *hevc,
-			struct PIC_s *pic)
+static void set_aux_data(struct hevc_state_s *hevc,
+	struct PIC_s *pic, unsigned char suffix_flag)
+{
+	int i;
+	unsigned short *aux_adr;
+	unsigned size_reg_val =
+		READ_VREG(HEVC_AUX_DATA_SIZE);
+	unsigned aux_count = 0;
+	int aux_size = 0;
+	if (suffix_flag) {
+		aux_adr = (unsigned short *)
+			(hevc->aux_addr +
+			hevc->prefix_aux_size);
+		aux_count =
+		((size_reg_val & 0xffff) << 4)
+			>> 1;
+		aux_size =
+			hevc->suffix_aux_size;
+	} else {
+		aux_adr =
+		(unsigned short *)hevc->aux_addr;
+		aux_count =
+		((size_reg_val >> 16) << 4)
+			>> 1;
+		aux_size =
+			hevc->prefix_aux_size;
+	}
+	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR_MORE) {
+		hevc_print(hevc, 0, "%s:old size %d count %d,suf %d\r\n",
+			__func__, pic->aux_data_size, aux_count, suffix_flag);
+	}
+	if (aux_size > 0 && aux_count > 0) {
+		int heads_size = 0;
+		int new_size;
+		char *new_buf;
+		for (i = 0; i < aux_count; i++) {
+			unsigned char tag = aux_adr[i] >> 8;
+			if (tag != 0 && tag != 0xff)
+				heads_size += 8;
+		}
+		new_size = pic->aux_data_size + aux_count + heads_size;
+		new_buf = krealloc(pic->aux_data_buf,
+			new_size,
+			GFP_KERNEL);
+		if (new_buf) {
+			unsigned char *p =
+				new_buf +
+				pic->aux_data_size;
+			unsigned char *h = p;
+			int h_bytes = 8;
+			int len = 0;
+			int padding_len = 0;
+			pic->aux_data_buf = new_buf;
+			pic->aux_data_size += (aux_count + heads_size);
+			for (i = 0; i < aux_count; i += 4) {
+				int ii;
+				unsigned char tag = aux_adr[i + 3] >> 8;
+				if (tag != 0 && tag != 0xff) {
+					if (i > 0) {
+						h[0] = (len >> 24) & 0xff;
+						h[1] = (len >> 16) & 0xff;
+						h[2] = (len >> 8) & 0xff;
+						h[3] = (len >> 0) & 0xff;
+						h[6] = (padding_len >> 8)
+						& 0xff;
+						h[7] = (padding_len) & 0xff;
+						h += (len + 8);
+						h_bytes += 8;
+						len = 0;
+						padding_len = 0;
+					}
+					h[4] = tag;
+					h[5] = 0;
+					h[6] = 0;
+					h[7] = 0;
+				}
+				for (ii = 0; ii < 4; ii++) {
+					unsigned short aa =
+						aux_adr[i + 3
+						- ii];
+						p[h_bytes + i + ii] =
+							aa & 0xff;
+					len++;
+					if ((aa >> 8) == 0xff)
+						padding_len++;
+				}
+			}
+			h[0] = (len >> 24) & 0xff;
+			h[1] = (len >> 16) & 0xff;
+			h[2] = (len >> 8) & 0xff;
+			h[3] = (len >> 0) & 0xff;
+			h[6] = (padding_len >> 8) & 0xff;
+			h[7] = (padding_len) & 0xff;
+			if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR_MORE) {
+				hevc_print(hevc, 0,
+					"aux: (size %d) suffix_flag %d\n",
+					pic->aux_data_size, suffix_flag);
+				for (i = 0; i < pic->aux_data_size; i++) {
+					hevc_print_cont(hevc, 0,
+						"%02x ", pic->aux_data_buf[i]);
+					if (((i + 1) & 0xf) == 0)
+						hevc_print_cont(hevc, 0, "\n");
+				}
+				hevc_print_cont(hevc, 0, "\n");
+			}
+
+		}
+	}
+
+}
+
+static void release_aux_data(struct hevc_state_s *hevc,
+	struct PIC_s *pic)
+{
+	kfree(pic->aux_data_buf);
+	pic->aux_data_buf = NULL;
+	pic->aux_data_size = 0;
+}
+
+static inline void hevc_pre_pic(struct hevc_state_s *hevc,
+			struct PIC_s *pic)
 {
 
 	/* prev pic */
@@ -3691,21 +4312,22 @@ static inline void hevc_pre_pic(struct hevc_state_s *hevc,
 				if ((pic_display->error_mark &&
 					((hevc->ignore_bufmgr_error &
 							  0x2) == 0))
-					|| (debug &
+					|| (get_dbg_flag(hevc) &
 						H265_DEBUG_DISPLAY_CUR_FRAME)
-					|| (debug &
+					|| (get_dbg_flag(hevc) &
 						H265_DEBUG_NO_DISPLAY)) {
 					pic_display->output_ready = 0;
-					if (debug & H265_DEBUG_BUFMGR) {
-						pr_info
-						("[BM] Display: POC %d, ",
+					if (get_dbg_flag(hevc) &
+						H265_DEBUG_BUFMGR) {
+						hevc_print(hevc, 0,
+						"[BM] Display: POC %d, ",
 							 pic_display->POC);
-						pr_info
-						("decoding index %d ==> ",
+						hevc_print_cont(hevc, 0,
+						"decoding index %d ==> ",
 							 pic_display->
 							 decode_idx);
-						pr_info
-						("Debug or err,recycle it\n");
+						hevc_print_cont(hevc, 0,
+						"Debug or err,recycle it\n");
 					}
 				} else {
 					if (i_only_flag & 0x1
@@ -3716,12 +4338,13 @@ static inline void hevc_pre_pic(struct hevc_state_s *hevc,
 						prepare_display_buf
 							(hevc,
 							 pic_display);
-					if (debug & H265_DEBUG_BUFMGR) {
-						pr_info
-						("[BM] Display: POC %d, ",
+					if (get_dbg_flag(hevc) &
+						H265_DEBUG_BUFMGR) {
+						hevc_print(hevc, 0,
+						"[BM] Display: POC %d, ",
 							 pic_display->POC);
-							pr_info
-							("decoding index %d\n",
+							hevc_print_cont(hevc, 0,
+							"decoding index %d\n",
 							 pic_display->
 							 decode_idx);
 						}
@@ -3730,13 +4353,13 @@ static inline void hevc_pre_pic(struct hevc_state_s *hevc,
 			}
 		} while (pic_display);
 	} else {
-		if (debug & H265_DEBUG_BUFMGR) {
-			pr_info
-			("[BM] current pic is IDR, ");
-			pr_info
-			("clear referenced flag of all buffers\n");
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+			hevc_print(hevc, 0,
+			"[BM] current pic is IDR, ");
+			hevc_print(hevc, 0,
+			"clear referenced flag of all buffers\n");
 		}
-		if (debug & H265_DEBUG_BUFMGR)
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
 			dump_pic_list(hevc);
 		pic = get_pic_by_POC(hevc, hevc->iPrevPOC);
 		flush_output(hevc, pic);
@@ -3747,8 +4370,9 @@ static inline void hevc_pre_pic(struct hevc_state_s *hevc,
 static void check_pic_decoded_lcu_count(struct hevc_state_s *hevc)
 {
 	int current_lcu_idx = READ_VREG(HEVC_PARSER_LCU_START)&0xffffff;
-	if (debug & H265_DEBUG_BUFMGR) {
-		pr_info("cur lcu idx = %d, (total %d)\n",
+	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+		hevc_print(hevc, 0,
+			"cur lcu idx = %d, (total %d)\n",
 			current_lcu_idx, hevc->lcu_total);
 	}
 	if ((error_handle_policy & 0x20) == 0 && hevc->cur_pic != NULL) {
@@ -3765,7 +4389,8 @@ static void check_pic_decoded_lcu_count(struct hevc_state_s *hevc)
 				hevc->cur_pic->error_mark = 1;
 		}
 		if (hevc->cur_pic->error_mark)
-			pr_info("cur lcu idx = %d, (total %d), set error_mark\n",
+			hevc_print(hevc, 0,
+				"cur lcu idx = %d, (total %d), set error_mark\n",
 				current_lcu_idx,
 				hevc->lcu_x_num_pre*hevc->lcu_y_num_pre);
 
@@ -3778,6 +4403,9 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 		union param_u *rpm_param,
 		int decode_pic_begin)
 {
+#ifdef CONFIG_AM_VDEC_DV
+	struct vdec_s *vdec = hw_to_vdec(hevc);
+#endif
 	int i;
 	int lcu_x_num_div;
 	int lcu_y_num_div;
@@ -3826,7 +4454,8 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 		if (hevc->pic_w != rpm_param->p.pic_width_in_luma_samples
 			|| hevc->pic_h !=
 			rpm_param->p.pic_height_in_luma_samples) {
-			pr_info("Pic Width/Height Change (%d,%d)=>(%d,%d), interlace %d\n",
+			hevc_print(hevc, 0,
+				"Pic Width/Height Change (%d,%d)=>(%d,%d), interlace %d\n",
 				   hevc->pic_w, hevc->pic_h,
 				   rpm_param->p.pic_width_in_luma_samples,
 				   rpm_param->p.pic_height_in_luma_samples,
@@ -3838,15 +4467,27 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 			hevc->frame_height = hevc->pic_h;
 #ifdef LOSLESS_COMPRESS_MODE
 			if (re_config_pic_flag == 0 &&
-				(double_write_mode & 0x10) == 0)
+				(get_double_write_mode(hevc) & 0x10) == 0)
 				init_decode_head_hw(hevc);
 #endif
 		}
 
+		if (HEVC_SIZE < hevc->pic_w * hevc->pic_h) {
+			pr_info("over size : %u x %u.\n",
+				hevc->pic_w, hevc->pic_h);
+			if (!hevc->m_ins_flag)
+				debug |= (H265_DEBUG_DIS_LOC_ERROR_PROC |
+				H265_DEBUG_DIS_SYS_ERROR_PROC);
+
+			hevc->fatal_error |= DECODER_FATAL_ERROR_SIZE_OVERFLOW;
+			return -1;
+		}
+
 		/* it will cause divide 0 error */
 		if (hevc->pic_w == 0 || hevc->pic_h == 0) {
-			if (debug) {
-				pr_info("Fatal Error, pic_w = %d, pic_h = %d\n",
+			if (get_dbg_flag(hevc)) {
+				hevc_print(hevc, 0,
+					"Fatal Error, pic_w = %d, pic_h = %d\n",
 					   hevc->pic_w, hevc->pic_h);
 			}
 			return 3;
@@ -3856,7 +4497,8 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 					3 + rpm_param->
 					p.log2_diff_max_min_coding_block_size);
 		if (hevc->lcu_size == 0) {
-			pr_info("Error, lcu_size = 0 (%d,%d)\n",
+			hevc_print(hevc, 0,
+				"Error, lcu_size = 0 (%d,%d)\n",
 				   rpm_param->p.
 				   log2_min_coding_block_size_minus3,
 				   rpm_param->p.
@@ -3889,7 +4531,8 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 			int iPOCmsb;
 			int iPOClsb = rpm_param->p.POClsb;
 			if (iMaxPOClsb == 0) {
-				pr_info("error iMaxPOClsb is 0\n");
+				hevc_print(hevc, 0,
+					"error iMaxPOClsb is 0\n");
 				return 3;
 			}
 
@@ -3906,9 +4549,9 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 				iPOCmsb = iPrevPOCmsb - iMaxPOClsb;
 			else
 				iPOCmsb = iPrevPOCmsb;
-			if (debug & H265_DEBUG_BUFMGR) {
-				pr_info
-				("iPrePOC%d iMaxPOClsb%d iPOCmsb%d iPOClsb%d\n",
+			if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+				hevc_print(hevc, 0,
+				"iPrePOC%d iMaxPOClsb%d iPOCmsb%d iPOClsb%d\n",
 				 hevc->iPrevTid0POC, iMaxPOClsb, iPOCmsb,
 				 iPOClsb);
 			}
@@ -3924,8 +4567,9 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 			if ((hevc->m_temporalId - 1) == 0)
 				hevc->iPrevTid0POC = hevc->curr_POC;
 			else {
-				if (debug & H265_DEBUG_BUFMGR) {
-					pr_info("m_temporalID is %d\n",
+				if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+					hevc_print(hevc, 0,
+						"m_temporalID is %d\n",
 						   hevc->m_temporalId);
 				}
 			}
@@ -3964,11 +4608,12 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 				  NAL_UNIT_CODED_SLICE_RASL_N ||
 				  hevc->m_nalUnitType ==
 				  NAL_UNIT_CODED_SLICE_TFD)) {	/* skip */
-			if (debug) {
-				pr_info
-				("RASL picture with POC %d < %d ",
+			if (get_dbg_flag(hevc)) {
+				hevc_print(hevc, 0,
+				"RASL picture with POC %d < %d ",
 				 hevc->curr_POC, hevc->m_pocRandomAccess);
-				pr_info("RandomAccess point POC), skip it\n");
+				hevc_print(hevc, 0,
+					"RandomAccess point POC), skip it\n");
 			}
 			return 1;
 			}
@@ -3993,7 +4638,7 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 				}
 			}
 			hevc->first_pic_after_recover = 0;
-			if (debug & H265_DEBUG_BUFMGR_MORE)
+			if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR_MORE)
 				dump_pic_list(hevc);
 			/* prev pic */
 			hevc_pre_pic(hevc, pic);
@@ -4001,15 +4646,50 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 			   (cur_pic->referenced is 1 and not updated) */
 			apply_ref_pic_set(hevc, hevc->curr_POC,
 							  rpm_param);
+		if (mmu_enable && hevc->cur_pic != NULL) {
+			if (!(hevc->cur_pic->error_mark
+				&& ((hevc->ignore_bufmgr_error & 0x1) == 0))) {
+				long used_4k_num =
+					(READ_VREG(HEVC_SAO_MMU_STATUS) >> 16);
+				decoder_mmu_box_free_idx_tail(hevc->mmu_box,
+				hevc->cur_pic->index, used_4k_num);
+				}
+
+			}
+#ifdef CONFIG_AM_VDEC_DV
+			if (vdec->master) {
+				struct hevc_state_s *hevc_ba =
+				(struct hevc_state_s *)
+					vdec->master->private;
+				if (hevc_ba->cur_pic != NULL)
+					hevc_ba->cur_pic->dv_enhance_exist = 1;
+			}
+			if (vdec->master == NULL &&
+				vdec->slave == NULL) {
+				if (hevc->cur_pic != NULL)
+					set_aux_data(hevc, hevc->cur_pic, 1);
+			}
+#else
+			if (hevc->cur_pic != NULL)
+				set_aux_data(hevc, hevc->cur_pic, 1);
+#endif
 			/* new pic */
 			hevc->cur_pic = get_new_pic(hevc, rpm_param);
 			if (hevc->cur_pic == NULL) {
-				if (debug & H265_DEBUG_BUFMGR)
+				if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
 					dump_pic_list(hevc);
 				hevc->wait_buf = 1;
 				return -1;
 			}
-			if (debug & H265_DEBUG_DISPLAY_CUR_FRAME) {
+#ifdef CONFIG_AM_VDEC_DV
+			hevc->cur_pic->dv_enhance_exist = 0;
+			if (vdec->master == NULL &&
+				vdec->slave == NULL)
+				set_aux_data(hevc, hevc->cur_pic, 0);
+#else
+			set_aux_data(hevc, hevc->cur_pic, 0);
+#endif
+			if (get_dbg_flag(hevc) & H265_DEBUG_DISPLAY_CUR_FRAME) {
 				hevc->cur_pic->output_ready = 1;
 				hevc->cur_pic->stream_offset =
 					READ_VREG(HEVC_SHIFT_BYTE_COUNT);
@@ -4018,6 +4698,20 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 				return -1;
 			}
 		} else {
+#ifdef CONFIG_AM_VDEC_DV
+			if (vdec->master == NULL &&
+				vdec->slave == NULL) {
+				if (hevc->cur_pic != NULL) {
+					set_aux_data(hevc, hevc->cur_pic, 1);
+					set_aux_data(hevc, hevc->cur_pic, 0);
+				}
+			}
+#else
+			if (hevc->cur_pic != NULL) {
+				set_aux_data(hevc, hevc->cur_pic, 1);
+				set_aux_data(hevc, hevc->cur_pic, 0);
+			}
+#endif
 			if (hevc->pic_list_init_flag != 3
 				|| hevc->cur_pic == NULL) {
 				/* make it dec from the first slice segment */
@@ -4027,10 +4721,28 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 			hevc->new_pic = 0;
 		}
 	} else {
-		if (hevc->wait_buf == 1) {
+	if (hevc->wait_buf == 1) {
+		/*
+		if (mmu_enable && hevc->cur_pic != NULL) {
+			long used_4k_num =
+				(READ_VREG(HEVC_SAO_MMU_STATUS) >> 16);
+			decoder_mmu_box_free_idx_tail(hevc->mmu_box,
+				hevc->cur_pic->index, used_4k_num);
+
+			}
+		*/
 			hevc->cur_pic = get_new_pic(hevc, rpm_param);
 			if (hevc->cur_pic == NULL)
 				return -1;
+
+#ifdef CONFIG_AM_VDEC_DV
+			hevc->cur_pic->dv_enhance_exist = 0;
+			if (vdec->master == NULL &&
+				vdec->slave == NULL)
+				set_aux_data(hevc, hevc->cur_pic, 0);
+#else
+			set_aux_data(hevc, hevc->cur_pic, 0);
+#endif
 			hevc->wait_buf = 0;
 		} else if (hevc->wait_buf ==
 				   2) {
@@ -4039,7 +4751,7 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 				return -1;
 			hevc->wait_buf = 0;
 		}
-		if (debug & H265_DEBUG_BUFMGR_MORE)
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR_MORE)
 			dump_pic_list(hevc);
 	}
 
@@ -4059,8 +4771,9 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 			(hevc->pic_w + hevc->lcu_size - 1) / hevc->lcu_size;
 		int sao_vb_size = (sao_mem_unit + (2 << 4)) * pic_height_cu;
 		/* int sao_abv_size = sao_mem_unit*pic_width_cu; */
-		if (debug & H265_DEBUG_BUFMGR) {
-			pr_info("==>%s dec idx %d, struct %d interlace %d\n",
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+			hevc_print(hevc, 0,
+				"==>%s dec idx %d, struct %d interlace %d\n",
 				__func__,
 				hevc->decode_idx,
 				hevc->curr_pic_struct,
@@ -4082,13 +4795,15 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 		hevc->tile_x = 0;
 		hevc->tile_y = 0;
 		hevc->tile_y_x = 0;
-		if (debug & H265_DEBUG_BUFMGR) {
-			pr_info("new_tile (new_pic) tile_x=%d, tile_y=%d\n",
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+			hevc_print(hevc, 0,
+				"new_tile (new_pic) tile_x=%d, tile_y=%d\n",
 				   hevc->tile_x, hevc->tile_y);
 		}
 	} else if (hevc->tile_enabled) {
-		if (debug & H265_DEBUG_BUFMGR) {
-			pr_info("slice_segment_address is %d\n",
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+			hevc_print(hevc, 0,
+				"slice_segment_address is %d\n",
 				   rpm_param->p.slice_segment_address);
 		}
 		hevc->tile_y_x =
@@ -4100,9 +4815,9 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 			hevc->new_tile = 1;
 			hevc->tile_x = hevc->tile_y_x & 0xff;
 			hevc->tile_y = (hevc->tile_y_x >> 8) & 0xff;
-			if (debug & H265_DEBUG_BUFMGR) {
-				pr_info
-				("new_tile seg adr %d tile_x=%d, tile_y=%d\n",
+			if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+				hevc_print(hevc, 0,
+				"new_tile seg adr %d tile_x=%d, tile_y=%d\n",
 				 rpm_param->p.slice_segment_address,
 				 hevc->tile_x, hevc->tile_y);
 			}
@@ -4122,7 +4837,7 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 			hevc->m_tile[hevc->tile_y][hevc->tile_x].height;
 	}
 
-	set_ref_pic_list(hevc->cur_pic, rpm_param);
+	set_ref_pic_list(hevc, rpm_param);
 
 	Col_ref = rpm_param->p.collocated_ref_idx;
 
@@ -4186,22 +4901,20 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 			hevc->col_pic = get_ref_pic_by_POC(hevc, hevc->Col_POC);
 			if (hevc->col_pic == NULL) {
 				hevc->cur_pic->error_mark = 1;
-				if (debug) {
-					pr_info
-					("WRONG,fail to get the pic Col_POC\n");
+				if (get_dbg_flag(hevc)) {
+					hevc_print(hevc, 0,
+					"WRONG,fail to get the pic Col_POC\n");
 				}
 			} else if (hevc->col_pic->error_mark) {
 				hevc->cur_pic->error_mark = 1;
-				if (debug) {
-					pr_info
-					("WRONG, Col_POC error_mark is 1\n");
+				if (get_dbg_flag(hevc)) {
+					hevc_print(hevc, 0,
+					"WRONG, Col_POC error_mark is 1\n");
 				}
 			}
 
 			if (hevc->cur_pic->error_mark
 				&& ((hevc->ignore_bufmgr_error & 0x1) == 0)) {
-				if (debug)
-					pr_info("Discard this picture\n");
 				return 2;
 			}
 		} else
@@ -4221,8 +4934,10 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 
 	if (hevc->cur_pic->error_mark
 		&& ((hevc->ignore_bufmgr_error & 0x1) == 0)) {
-		if (debug)
-			pr_info("Discard this picture\n");
+		if (get_dbg_flag(hevc))
+			hevc_print(hevc, 0,
+			"Discard this picture index %d\n",
+					hevc->cur_pic->index);
 		return 2;
 	}
 #ifdef MCRCC_ENABLE
@@ -4238,6 +4953,33 @@ static int hevc_slice_segment_header_process(struct hevc_state_s *hevc,
 	return 0;
 }
 
+
+
+static int H265_alloc_mmu(struct hevc_state_s *hevc, struct PIC_s *new_pic,
+		unsigned short bit_depth, unsigned int *mmu_index_adr) {
+	int cur_buf_idx = new_pic->index;
+	int bit_depth_10 = (bit_depth != 0x00);
+	int picture_size;
+	int cur_mmu_4k_number;
+	picture_size = compute_losless_comp_body_size(new_pic->width,
+				new_pic->height, !bit_depth_10);
+	cur_mmu_4k_number = ((picture_size+(1<<12)-1) >> 12);
+
+	/*hevc_print(hevc, 0,
+	"alloc_mmu cur_idx : %d picture_size : %d mmu_4k_number : %d\r\n",
+	cur_buf_idx, picture_size, cur_mmu_4k_number);*/
+	return decoder_mmu_box_alloc_idx(
+	  hevc->mmu_box,
+	  cur_buf_idx,
+	  cur_mmu_4k_number,
+	  mmu_index_adr);
+}
+
+
+
+
+
+
 /**************************************************
 
 h265 buffer management end
@@ -4250,6 +4992,14 @@ static void hevc_local_uninit(struct hevc_state_s *hevc)
 	hevc->rpm_ptr = NULL;
 	hevc->lmem_ptr = NULL;
 
+	if (hevc->aux_addr) {
+		dma_unmap_single(amports_get_dma_device(),
+			hevc->aux_phy_addr,
+			hevc->prefix_aux_size + hevc->suffix_aux_size,
+			DMA_FROM_DEVICE);
+		kfree(hevc->aux_addr);
+		hevc->aux_addr = NULL;
+	}
 	if (hevc->rpm_addr) {
 		dma_unmap_single(amports_get_dma_device(),
 			hevc->rpm_phy_addr, RPM_BUF_SIZE, DMA_FROM_DEVICE);
@@ -4263,6 +5013,15 @@ static void hevc_local_uninit(struct hevc_state_s *hevc)
 		hevc->lmem_addr = NULL;
 	}
 
+	if (mmu_enable && hevc->frame_mmu_map_addr) {
+		if (hevc->frame_mmu_map_phy_addr)
+			dma_free_coherent(amports_get_dma_device(),
+				FRAME_MMU_MAP_SIZE, hevc->frame_mmu_map_addr,
+					hevc->frame_mmu_map_phy_addr);
+			hevc->frame_mmu_map_addr = NULL;
+	}
+
+
 }
 
 static int hevc_local_init(struct hevc_state_s *hevc)
@@ -4271,13 +5030,19 @@ static int hevc_local_init(struct hevc_state_s *hevc)
 	struct BuffInfo_s *cur_buf_info = NULL;
 	memset(&hevc->param, 0, sizeof(union param_u));
 
+	cur_buf_info = &hevc->work_space_buf_store;
 #ifdef SUPPORT_4K2K
-	cur_buf_info = &amvh265_workbuff_spec[1];	/* 4k2k work space */
+	memcpy(cur_buf_info, &amvh265_workbuff_spec[1],	/* 4k2k work space */
+		sizeof(struct BuffInfo_s));
 #else
-	cur_buf_info = &amvh265_workbuff_spec[0];	/* 1080p work space */
+	memcpy(cur_buf_info, &amvh265_workbuff_spec[0],	/* 1080p work space */
+		sizeof(struct BuffInfo_s));
 #endif
+	cur_buf_info->start_adr = hevc->buf_start;
+	hevc->mc_buf_spec.buf_end = hevc->buf_start + hevc->buf_size;
+	init_buff_spec(hevc, cur_buf_info);
+
 
-	init_buff_spec(cur_buf_info);
 
 	hevc->mc_buf_spec.buf_start = (cur_buf_info->end_adr + 0xffff)
 	    & (~0xffff);
@@ -4293,7 +5058,7 @@ static int hevc_local_init(struct hevc_state_s *hevc)
 	bit_depth_chroma = hevc->bit_depth_chroma;
 	video_signal_type = hevc->video_signal_type;
 
-	if ((debug & H265_DEBUG_SEND_PARAM_WITH_REG) == 0) {
+	if ((get_dbg_flag(hevc) & H265_DEBUG_SEND_PARAM_WITH_REG) == 0) {
 		hevc->rpm_addr = kmalloc(RPM_BUF_SIZE, GFP_KERNEL);
 		if (hevc->rpm_addr == NULL) {
 			pr_err("%s: failed to alloc rpm buffer\n", __func__);
@@ -4313,7 +5078,30 @@ static int hevc_local_init(struct hevc_state_s *hevc)
 		hevc->rpm_ptr = hevc->rpm_addr;
 	}
 
-	if (debug & H265_DEBUG_UCODE) {
+	if (prefix_aux_buf_size > 0 ||
+		suffix_aux_buf_size > 0) {
+		u32 aux_buf_size;
+		hevc->prefix_aux_size = AUX_BUF_ALIGN(prefix_aux_buf_size);
+		hevc->suffix_aux_size = AUX_BUF_ALIGN(suffix_aux_buf_size);
+		aux_buf_size = hevc->prefix_aux_size + hevc->suffix_aux_size;
+		hevc->aux_addr = kmalloc(aux_buf_size, GFP_KERNEL);
+		if (hevc->aux_addr == NULL) {
+			pr_err("%s: failed to alloc rpm buffer\n", __func__);
+			return -1;
+		}
+
+		hevc->aux_phy_addr = dma_map_single(amports_get_dma_device(),
+			hevc->aux_addr, aux_buf_size, DMA_FROM_DEVICE);
+		if (dma_mapping_error(amports_get_dma_device(),
+			hevc->aux_phy_addr)) {
+			pr_err("%s: failed to map rpm buffer\n", __func__);
+			kfree(hevc->aux_addr);
+			hevc->aux_addr = NULL;
+			return -1;
+		}
+	}
+
+	if (get_dbg_flag(hevc) & H265_DEBUG_UCODE) {
 		hevc->lmem_addr = kmalloc(LMEM_BUF_SIZE, GFP_KERNEL);
 		if (hevc->lmem_addr == NULL) {
 			pr_err("%s: failed to alloc lmem buffer\n", __func__);
@@ -4332,6 +5120,18 @@ static int hevc_local_init(struct hevc_state_s *hevc)
 
 		hevc->lmem_ptr = hevc->lmem_addr;
 	}
+
+	if (mmu_enable) {
+		hevc->frame_mmu_map_addr =
+				dma_alloc_coherent(amports_get_dma_device(),
+				FRAME_MMU_MAP_SIZE,
+				&hevc->frame_mmu_map_phy_addr, GFP_KERNEL);
+		if (hevc->frame_mmu_map_addr == NULL) {
+			pr_err("%s: failed to alloc count_buffer\n", __func__);
+			return -1;
+		}
+		memset(hevc->frame_mmu_map_addr, 0, FRAME_MMU_MAP_SIZE);
+	}
 	ret = 0;
 	return ret;
 }
@@ -4357,18 +5157,18 @@ static int hevc_local_init(struct hevc_state_s *hevc)
 	 ((x)->y_canvas_index << 0))
 
 
-static void set_canvas(struct PIC_s *pic)
+static void set_canvas(struct hevc_state_s *hevc, struct PIC_s *pic)
 {
 	int canvas_w = ALIGN(pic->width, 64)/4;
 	int canvas_h = ALIGN(pic->height, 32)/4;
 	int blkmode = mem_map_mode;
 	/*CANVAS_BLKMODE_64X32*/
 #ifdef SUPPORT_10BIT
-	if	(double_write_mode) {
+	if	(get_double_write_mode(hevc)) {
 		canvas_w = pic->width;
 		canvas_h = pic->height;
-		if ((double_write_mode == 2) ||
-			(double_write_mode == 3)) {
+		if ((get_double_write_mode(hevc) == 2) ||
+			(get_double_write_mode(hevc) == 3)) {
 			canvas_w >>= 2;
 			canvas_h >>= 2;
 		}
@@ -4388,19 +5188,40 @@ static void set_canvas(struct PIC_s *pic)
 		canvas_config_ex(pic->uv_canvas_index, pic->dw_u_v_adr,
 			canvas_w, canvas_h,
 			CANVAS_ADDR_NOWRAP, blkmode, 0x7);
-	} else {
-#if 1
-	/* to change after 10bit VPU is ready ... */
-		pic->y_canvas_index = 128 + pic->index;
-		pic->uv_canvas_index = 128 + pic->index;
-
-		canvas_config_ex(pic->y_canvas_index,
-			pic->mc_y_adr, canvas_w, canvas_h,
-			CANVAS_ADDR_NOWRAP, blkmode, 0x7);
-		canvas_config_ex(pic->uv_canvas_index, pic->mc_u_v_adr,
-			canvas_w, canvas_h,
-			CANVAS_ADDR_NOWRAP, blkmode, 0x7);
+#ifdef MULTI_INSTANCE_SUPPORT
+		pic->canvas_config[0].phy_addr =
+				pic->dw_y_adr;
+		pic->canvas_config[0].width =
+				canvas_w;
+		pic->canvas_config[0].height =
+				canvas_h;
+		pic->canvas_config[0].block_mode =
+				blkmode;
+		pic->canvas_config[0].endian = 7;
+
+		pic->canvas_config[1].phy_addr =
+				pic->dw_u_v_adr;
+		pic->canvas_config[1].width =
+				canvas_w;
+		pic->canvas_config[1].height =
+				canvas_h;
+		pic->canvas_config[1].block_mode =
+				blkmode;
+		pic->canvas_config[1].endian = 7;
 #endif
+	} else {
+		if (!mmu_enable) {
+			/* to change after 10bit VPU is ready ... */
+			pic->y_canvas_index = 128 + pic->index;
+			pic->uv_canvas_index = 128 + pic->index;
+
+			canvas_config_ex(pic->y_canvas_index,
+				pic->mc_y_adr, canvas_w, canvas_h,
+				CANVAS_ADDR_NOWRAP, blkmode, 0x7);
+			canvas_config_ex(pic->uv_canvas_index, pic->mc_u_v_adr,
+				canvas_w, canvas_h,
+				CANVAS_ADDR_NOWRAP, blkmode, 0x7);
+		}
 	}
 #else
 	pic->y_canvas_index = 128 + pic->index * 2;
@@ -4419,8 +5240,10 @@ static int init_buf_spec(struct hevc_state_s *hevc)
 	int pic_width = hevc->pic_w;
 	int pic_height = hevc->pic_h;
 
-	/* pr_info("%s1: %d %d\n", __func__, hevc->pic_w, hevc->pic_h); */
-	pr_info("%s2 %d %d\n", __func__, pic_width, pic_height);
+	/* hevc_print(hevc, 0,
+	"%s1: %d %d\n", __func__, hevc->pic_w, hevc->pic_h); */
+	hevc_print(hevc, 0,
+		"%s2 %d %d\n", __func__, pic_width, pic_height);
 	/* pic_width = hevc->pic_w; */
 	/* pic_height = hevc->pic_h; */
 
@@ -4433,13 +5256,116 @@ static int init_buf_spec(struct hevc_state_s *hevc)
 	return 0;
 }
 
+static int parse_sei(struct hevc_state_s *hevc, char *sei_buf, uint32_t size)
+{
+	char *p = sei_buf;
+	char *p_sei;
+	uint16_t header;
+	uint8_t nal_unit_type;
+	uint8_t payload_type, payload_size;
+	int i, j;
+
+	if (size < 2)
+		return 0;
+	header = *p++;
+	header <<= 8;
+	header += *p++;
+	nal_unit_type = header >> 9;
+	if ((nal_unit_type != NAL_UNIT_SEI)
+	&& (nal_unit_type != NAL_UNIT_SEI_SUFFIX))
+		return 0;
+	while (p+2 <= sei_buf+size) {
+		payload_type = *p++;
+		payload_size = *p++;
+		if (p+payload_size <= sei_buf+size) {
+			switch (payload_type) {
+			case SEI_MasteringDisplayColorVolume:
+				hevc_print(hevc, 0,
+					"sei type: primary display color volume %d, size %d\n",
+					payload_type,
+					payload_size);
+				/* master_display_colour */
+				p_sei = p;
+				for (i = 0; i < 3; i++) {
+					for (j = 0; j < 2; j++) {
+						hevc->primaries[i][j]
+							= (*p_sei<<8)
+							| *(p_sei+1);
+						p_sei += 2;
+					}
+				}
+				for (i = 0; i < 2; i++) {
+					hevc->white_point[i]
+						= (*p_sei<<8)
+						| *(p_sei+1);
+					p_sei += 2;
+				}
+				for (i = 0; i < 2; i++) {
+					hevc->luminance[i]
+						= (*p_sei<<24)
+						| (*(p_sei+1)<<16)
+						| (*(p_sei+2)<<8)
+						| *(p_sei+3);
+					p_sei += 4;
+				}
+				hevc->sei_present_flag |=
+					SEI_MASTER_DISPLAY_COLOR_MASK;
+				for (i = 0; i < 3; i++)
+					for (j = 0; j < 2; j++)
+						hevc_print(hevc, 0,
+						"\tprimaries[%1d][%1d] = %04x\n",
+						i, j,
+						hevc->primaries[i][j]);
+				hevc_print(hevc, 0,
+					"\twhite_point = (%04x, %04x)\n",
+					hevc->white_point[0],
+					hevc->white_point[1]);
+				hevc_print(hevc, 0,
+					"\tmax,min luminance = %08x, %08x\n",
+					hevc->luminance[0],
+					hevc->luminance[1]);
+				break;
+			case SEI_ContentLightLevel:
+				hevc_print(hevc, 0,
+					"sei type: max content light level %d, size %d\n",
+					payload_type, payload_size);
+				/* content_light_level */
+				p_sei = p;
+				hevc->content_light_level[0]
+					= (*p_sei<<8) | *(p_sei+1);
+				p_sei += 2;
+				hevc->content_light_level[1]
+					= (*p_sei<<8) | *(p_sei+1);
+				p_sei += 2;
+				hevc->sei_present_flag |=
+					SEI_CONTENT_LIGHT_LEVEL_MASK;
+				hevc_print(hevc, 0,
+					"\tmax cll = %04x, max_pa_cll = %04x\n",
+					hevc->content_light_level[0],
+					hevc->content_light_level[1]);
+				break;
+			default:
+				break;
+			}
+		}
+		p += payload_size;
+	}
+	return 0;
+}
+
 static void set_frame_info(struct hevc_state_s *hevc, struct vframe_s *vf)
 {
 	unsigned int ar;
 	int i, j;
-
-	if ((double_write_mode == 2) ||
-		(double_write_mode == 3)) {
+	unsigned char index;
+	char *p;
+	unsigned size = 0;
+	unsigned type = 0;
+	struct vframe_master_display_colour_s *vf_dp
+		= &vf->prop.master_display_colour;
+
+	if ((get_double_write_mode(hevc) == 2) ||
+		(get_double_write_mode(hevc) == 3)) {
 		vf->width = hevc->frame_width/4;
 		vf->height = hevc->frame_height/4;
 	} else {
@@ -4459,29 +5385,67 @@ static void set_frame_info(struct hevc_state_s *hevc, struct vframe_s *vf)
 	else
 		vf->signal_type = 0;
 
+	/* parser sei */
+	index = vf->index & 0xff;
+	if (index != 0xff && index >= 0
+		&& index < MAX_REF_PIC_NUM
+		&& hevc->m_PIC[index]
+		&& hevc->m_PIC[index]->aux_data_buf
+		&& hevc->m_PIC[index]->aux_data_size) {
+		p = hevc->m_PIC[index]->aux_data_buf;
+		while (p < hevc->m_PIC[index]->aux_data_buf
+			+ hevc->m_PIC[index]->aux_data_size - 8) {
+			size = *p++;
+			size = (size << 8) | *p++;
+			size = (size << 8) | *p++;
+			size = (size << 8) | *p++;
+			type = *p++;
+			type = (type << 8) | *p++;
+			type = (type << 8) | *p++;
+			type = (type << 8) | *p++;
+			if (type == 0x02000000) {
+				/* hevc_print(hevc, 0, "sei(%d)\n", size); */
+				parse_sei(hevc, p, size);
+			}
+			p += size;
+		}
+	}
+
 	/* master_display_colour */
 	if (hevc->sei_present_flag & SEI_MASTER_DISPLAY_COLOR_MASK) {
 		for (i = 0; i < 3; i++)
 			for (j = 0; j < 2; j++)
-				vf->prop.master_display_colour.primaries[i][j]
-					= hevc->primaries[i][j];
+				vf_dp->primaries[i][j] = hevc->primaries[i][j];
 		for (i = 0; i < 2; i++) {
-			vf->prop.master_display_colour.white_point[i]
-				= hevc->white_point[i];
-			vf->prop.master_display_colour.luminance[i]
+			vf_dp->white_point[i] = hevc->white_point[i];
+			vf_dp->luminance[i]
 				= hevc->luminance[i];
 		}
-		vf->prop.master_display_colour.present_flag = 1;
+		vf_dp->present_flag = 1;
 	} else
-		vf->prop.master_display_colour.present_flag = 0;
-
+		vf_dp->present_flag = 0;
+
+	/* content_light_level */
+	if (hevc->sei_present_flag & SEI_CONTENT_LIGHT_LEVEL_MASK) {
+		vf_dp->content_light_level.max_content
+			= hevc->content_light_level[0];
+		vf_dp->content_light_level.max_pic_average
+			= hevc->content_light_level[1];
+		vf_dp->content_light_level.present_flag = 1;
+	} else
+		vf_dp->content_light_level.present_flag = 0;
 	return;
 }
 
 static int vh265_vf_states(struct vframe_states *states, void *op_arg)
 {
 	unsigned long flags;
+#ifdef MULTI_INSTANCE_SUPPORT
+	struct vdec_s *vdec = op_arg;
+	struct hevc_state_s *hevc = (struct hevc_state_s *)vdec->private;
+#else
 	struct hevc_state_s *hevc = (struct hevc_state_s *)op_arg;
+#endif
 	spin_lock_irqsave(&lock, flags);
 
 	states->vf_pool_size = VF_POOL_SIZE;
@@ -4497,7 +5461,12 @@ static int vh265_vf_states(struct vframe_states *states, void *op_arg)
 static struct vframe_s *vh265_vf_peek(void *op_arg)
 {
 	struct vframe_s *vf;
+#ifdef MULTI_INSTANCE_SUPPORT
+	struct vdec_s *vdec = op_arg;
+	struct hevc_state_s *hevc = (struct hevc_state_s *)vdec->private;
+#else
 	struct hevc_state_s *hevc = (struct hevc_state_s *)op_arg;
+#endif
 	if (step == 2)
 		return NULL;
 
@@ -4510,13 +5479,23 @@ static struct vframe_s *vh265_vf_peek(void *op_arg)
 static struct vframe_s *vh265_vf_get(void *op_arg)
 {
 	struct vframe_s *vf;
+#ifdef MULTI_INSTANCE_SUPPORT
+	struct vdec_s *vdec = op_arg;
+	struct hevc_state_s *hevc = (struct hevc_state_s *)vdec->private;
+#else
 	struct hevc_state_s *hevc = (struct hevc_state_s *)op_arg;
+#endif
 	if (step == 2)
 		return NULL;
 	else if (step == 1)
 		step = 2;
 
 	if (kfifo_get(&hevc->display_q, &vf)) {
+		if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
+			hevc_print(hevc, 0,
+				"%s(type %d index 0x%x)\n",
+				__func__, vf->type, vf->index);
+
 		hevc->show_frame_num++;
 		return vf;
 	}
@@ -4526,19 +5505,35 @@ static struct vframe_s *vh265_vf_get(void *op_arg)
 
 static void vh265_vf_put(struct vframe_s *vf, void *op_arg)
 {
+	unsigned long flags;
+#ifdef MULTI_INSTANCE_SUPPORT
+	struct vdec_s *vdec = op_arg;
+	struct hevc_state_s *hevc = (struct hevc_state_s *)vdec->private;
+#else
 	struct hevc_state_s *hevc = (struct hevc_state_s *)op_arg;
-	unsigned char index1 = vf->index & 0xff;
-	unsigned char index2 = (vf->index >> 8) & 0xff;
+#endif
+	unsigned char index_top = vf->index & 0xff;
+	unsigned char index_bot = (vf->index >> 8) & 0xff;
+	if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
+		hevc_print(hevc, 0,
+			"%s(type %d index 0x%x)\n",
+			__func__, vf->type, vf->index);
 
 	kfifo_put(&hevc->newframe_q, (const struct vframe_s *)vf);
+	spin_lock_irqsave(&lock, flags);
 
-	if (index1 != 0xff && index1 >= 0
-		&& index1 < MAX_REF_PIC_NUM) {
-		if (hevc->m_PIC[index1].vf_ref > 0) {
-			hevc->m_PIC[index1].vf_ref--;
-
-			if (hevc->m_PIC[index1].vf_ref == 0) {
-				hevc->m_PIC[index1].output_ready = 0;
+	if (index_top != 0xff && index_top >= 0
+		&& index_top < MAX_REF_PIC_NUM
+		&& hevc->m_PIC[index_top]) {
+		if (hevc->m_PIC[index_top]->vf_ref > 0) {
+			hevc->m_PIC[index_top]->vf_ref--;
+
+			if (hevc->m_PIC[index_top]->vf_ref == 0) {
+				hevc->m_PIC[index_top]->output_ready = 0;
+				if (mmu_enable)
+					hevc->m_PIC[index_top]->
+						used_by_display	= 0;
+				hevc->last_put_idx_a = index_top;
 				if (hevc->wait_buf != 0)
 					WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG,
 						0x1);
@@ -4546,27 +5541,36 @@ static void vh265_vf_put(struct vframe_s *vf, void *op_arg)
 		}
 	}
 
-	if (index2 != 0xff && index2 >= 0
-		&& index2 < MAX_REF_PIC_NUM) {
-		if (hevc->m_PIC[index2].vf_ref > 0) {
-			hevc->m_PIC[index2].vf_ref--;
+	if (index_bot != 0xff && index_bot >= 0
+		&& index_bot < MAX_REF_PIC_NUM
+		&& hevc->m_PIC[index_bot]) {
+		if (hevc->m_PIC[index_bot]->vf_ref > 0) {
+			hevc->m_PIC[index_bot]->vf_ref--;
 
-			if (hevc->m_PIC[index2].vf_ref == 0) {
+			if (hevc->m_PIC[index_bot]->vf_ref == 0) {
 				clear_used_by_display_flag(hevc);
-					hevc->m_PIC[index2].output_ready = 0;
+				hevc->m_PIC[index_bot]->output_ready = 0;
+				hevc->last_put_idx_b = index_bot;
 				if (hevc->wait_buf != 0)
 					WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG,
 						0x1);
 			}
 		}
 	}
+	spin_unlock_irqrestore(&lock, flags);
 }
 
-static int vh265_event_cb(int type, void *data, void *private_data)
+static int vh265_event_cb(int type, void *data, void *op_arg)
 {
+	unsigned long flags;
+#ifdef MULTI_INSTANCE_SUPPORT
+	struct vdec_s *vdec = op_arg;
+	struct hevc_state_s *hevc = (struct hevc_state_s *)vdec->private;
+#else
+	struct hevc_state_s *hevc = (struct hevc_state_s *)op_arg;
+#endif
 	if (type & VFRAME_EVENT_RECEIVER_RESET) {
 #if 0
-		unsigned long flags;
 		amhevc_stop();
 #ifndef CONFIG_POST_PROCESS_MANAGER
 		vf_light_unreg_provider(&vh265_vf_prov);
@@ -4580,6 +5584,34 @@ static int vh265_event_cb(int type, void *data, void *private_data)
 #endif
 		amhevc_start();
 #endif
+	} else if (type & VFRAME_EVENT_RECEIVER_GET_AUX_DATA) {
+		struct provider_aux_req_s *req =
+			(struct provider_aux_req_s *)data;
+		unsigned char index;
+		spin_lock_irqsave(&lock, flags);
+		index = req->vf->index & 0xff;
+		req->aux_buf = NULL;
+		req->aux_size = 0;
+		if (req->bot_flag)
+			index = (req->vf->index >> 8) & 0xff;
+		if (index != 0xff && index >= 0
+			&& index < MAX_REF_PIC_NUM
+			&& hevc->m_PIC[index]) {
+			req->aux_buf = hevc->m_PIC[index]->aux_data_buf;
+			req->aux_size = hevc->m_PIC[index]->aux_data_size;
+#ifdef CONFIG_AM_VDEC_DV
+			req->dv_enhance_exist =
+				hevc->m_PIC[index]->dv_enhance_exist;
+#else
+			req->dv_enhance_exist = 0;
+#endif
+		}
+		spin_unlock_irqrestore(&lock, flags);
+
+		if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
+			hevc_print(hevc, 0,
+			"%s(type 0x%x vf index 0x%x)=>size 0x%x\n",
+			__func__, type, index, req->aux_size);
 	}
 
 	return 0;
@@ -4590,12 +5622,24 @@ static int process_pending_vframe(struct hevc_state_s *hevc,
 	struct PIC_s *pair_pic, unsigned char pair_frame_top_flag)
 {
 	struct vframe_s *vf;
+	if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
+		hevc_print(hevc, 0,
+			"%s: pair_pic index 0x%x %s\n",
+			__func__, pair_pic->index,
+			pair_frame_top_flag ?
+			"top" : "bot");
+
 	if (kfifo_len(&hevc->pending_q) > 1) {
 		/* do not pending more than 1 frame */
 		if (kfifo_get(&hevc->pending_q, &vf) == 0) {
-			pr_info("fatal error, no available buffer slot.");
+			hevc_print(hevc, 0,
+			"fatal error, no available buffer slot.");
 			return -1;
 		}
+		if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
+			hevc_print(hevc, 0,
+			"%s warning(1), vf=>display_q: (index 0x%x)\n",
+				__func__, vf->index);
 		kfifo_put(&hevc->display_q, (const struct vframe_s *)vf);
 	}
 
@@ -4604,48 +5648,79 @@ static int process_pending_vframe(struct hevc_state_s *hevc,
 			/* if pair_pic is recycled (pair_pic->vf_ref <= 0),
 			do not use it */
 			if (kfifo_get(&hevc->pending_q, &vf) == 0) {
-				pr_info("fatal error, no available buffer slot.");
+				hevc_print(hevc, 0,
+				"fatal error, no available buffer slot.");
 				return -1;
 			}
+			if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
+				hevc_print(hevc, 0,
+				"%s warning(2), vf=>display_q: (index 0x%x)\n",
+				__func__, vf->index);
 			if (vf)
 				kfifo_put(&hevc->display_q,
 				(const struct vframe_s *)vf);
 		} else if ((!pair_frame_top_flag) &&
 			(((vf->index >> 8) & 0xff) == 0xff)) {
 			if (kfifo_get(&hevc->pending_q, &vf) == 0) {
-				pr_info("fatal error, no available buffer slot.");
+				hevc_print(hevc, 0,
+				"fatal error, no available buffer slot.");
 				return -1;
 			}
 			if (vf) {
 				vf->type = VIDTYPE_PROGRESSIVE
 				| VIDTYPE_VIU_NV21;
+				vf->index &= 0xff;
 				vf->index |= (pair_pic->index << 8);
 				vf->canvas1Addr = spec2canvas(pair_pic);
 				pair_pic->vf_ref++;
 				kfifo_put(&hevc->display_q,
 				(const struct vframe_s *)vf);
+				if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
+					hevc_print(hevc, 0,
+					"%s vf => display_q: (index 0x%x)\n",
+					__func__, vf->index);
 			}
 		} else if (pair_frame_top_flag &&
 			((vf->index & 0xff) == 0xff)) {
 			if (kfifo_get(&hevc->pending_q, &vf) == 0) {
-				pr_info("fatal error, no available buffer slot.");
+				hevc_print(hevc, 0,
+				"fatal error, no available buffer slot.");
 				return -1;
 			}
 			if (vf) {
 				vf->type = VIDTYPE_PROGRESSIVE
 				| VIDTYPE_VIU_NV21;
+				vf->index &= 0xff00;
 				vf->index |= pair_pic->index;
 				vf->canvas0Addr = spec2canvas(pair_pic);
 				pair_pic->vf_ref++;
 				kfifo_put(&hevc->display_q,
 				(const struct vframe_s *)vf);
+				if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
+					hevc_print(hevc, 0,
+					"%s vf => display_q: (index 0x%x)\n",
+					__func__, vf->index);
 			}
 		}
 	}
 	return 0;
 }
 #endif
-
+static void update_vf_memhandle(struct hevc_state_s *hevc,
+	struct vframe_s *vf, int index)
+{
+	if (index < 0)
+		vf->mem_handle = NULL;
+	else if (vf->type & VIDTYPE_SCATTER)
+		vf->mem_handle =
+			decoder_mmu_box_get_mem_handle(
+				hevc->mmu_box, index);
+	else
+		vf->mem_handle =
+			decoder_bmmu_box_get_mem_handle(
+				hevc->bmmu_box, index);
+	return;
+}
 static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 {
 	struct vframe_s *vf = NULL;
@@ -4653,14 +5728,19 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 	unsigned short slice_type = pic->slice_type;
 
 	if (kfifo_get(&hevc->newframe_q, &vf) == 0) {
-		pr_info("fatal error, no available buffer slot.");
+		hevc_print(hevc, 0,
+			"fatal error, no available buffer slot.");
 		return -1;
 	}
 
 	if (vf) {
+		if (hevc->m_ins_flag) {
+			vf->pts = pic->pts;
+			vf->pts_us64 = pic->pts64;
+		}
 		/* if (pts_lookup_offset(PTS_TYPE_VIDEO,
 		   stream_offset, &vf->pts, 0) != 0) { */
-		if (pts_lookup_offset_us64
+		else if (pts_lookup_offset_us64
 			(PTS_TYPE_VIDEO, stream_offset, &vf->pts, 0,
 			 &vf->pts_us64) != 0) {
 #ifdef DEBUG_PTS
@@ -4673,9 +5753,8 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 		else
 			hevc->pts_hit++;
 #endif
-		if (pts_unstable && (hevc->frame_dur > 0)) {
+		if (pts_unstable && (hevc->frame_dur > 0))
 			hevc->pts_mode = PTS_NONE_REF_USE_DURATION;
-		}
 
 		if ((hevc->pts_mode == PTS_NORMAL) && (vf->pts != 0)
 			&& hevc->get_frame_dur) {
@@ -4689,8 +5768,8 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 					PTS_MODE_SWITCHING_THRESHOLD) {
 					hevc->pts_mode =
 						PTS_NONE_REF_USE_DURATION;
-					pr_info
-					("HEVC: switch to n_d mode.\n");
+					hevc_print(hevc, 0,
+					"HEVC: switch to n_d mode.\n");
 				}
 
 			} else {
@@ -4721,39 +5800,77 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 				(DUR2PTS(hevc->frame_dur) * 100 / 9);
 		}
 		hevc->last_pts_us64 = vf->pts_us64;
-		if ((debug & H265_DEBUG_OUT_PTS) != 0) {
-			pr_info
-			("H265 dec out pts: vf->pts=%d, vf->pts_us64 = %lld\n",
+		if ((get_dbg_flag(hevc) & H265_DEBUG_OUT_PTS) != 0) {
+			hevc_print(hevc, 0,
+			"H265 dec out pts: vf->pts=%d, vf->pts_us64 = %lld\n",
 			 vf->pts, vf->pts_us64);
 		}
 
+		/*
+		vf->index:
+		(1) vf->type is VIDTYPE_PROGRESSIVE
+			and vf->canvas0Addr !=  vf->canvas1Addr,
+			vf->index[7:0] is the index of top pic
+			vf->index[15:8] is the index of bot pic
+		(2) other cases,
+			only vf->index[7:0] is used
+			vf->index[15:8] == 0xff
+		*/
 		vf->index = 0xff00 | pic->index;
 #if 1
 /*SUPPORT_10BIT*/
-		if (double_write_mode & 0x10) {
+		if (get_double_write_mode(hevc) & 0x10) {
 			/* double write only */
 			vf->compBodyAddr = 0;
 			vf->compHeadAddr = 0;
 		} else {
+
+		if (mmu_enable) {
+			vf->compBodyAddr = 0;
+			vf->compHeadAddr = pic->header_adr;
+		} else {
 			vf->compBodyAddr = pic->mc_y_adr; /*body adr*/
 			vf->compHeadAddr = pic->mc_y_adr +
 						pic->losless_comp_body_size;
+		}
+
 					/*head adr*/
 			vf->canvas0Addr = vf->canvas1Addr = 0;
 		}
-		if (double_write_mode) {
+		if (get_double_write_mode(hevc)) {
 			vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
 			vf->type |= VIDTYPE_VIU_NV21;
-			if (double_write_mode == 3)
+			if (get_double_write_mode(hevc) == 3)
 				vf->type |= VIDTYPE_COMPRESS;
-			vf->canvas0Addr = vf->canvas1Addr = spec2canvas(pic);
+			if (mmu_enable)
+				vf->type |= VIDTYPE_SCATTER;
+#ifdef MULTI_INSTANCE_SUPPORT
+			if (hevc->m_ins_flag) {
+					vf->canvas0Addr = vf->canvas1Addr = -1;
+					vf->plane_num = 2;
+					vf->canvas0_config[0] =
+						pic->canvas_config[0];
+					vf->canvas0_config[1] =
+						pic->canvas_config[1];
+
+					vf->canvas1_config[0] =
+						pic->canvas_config[0];
+					vf->canvas1_config[1] =
+						pic->canvas_config[1];
+
+			} else
+#endif
+				vf->canvas0Addr = vf->canvas1Addr
+				= spec2canvas(pic);
 		} else {
 			vf->canvas0Addr = vf->canvas1Addr = 0;
 			vf->type = VIDTYPE_COMPRESS | VIDTYPE_VIU_FIELD;
+			if (mmu_enable)
+				vf->type |= VIDTYPE_SCATTER;
 		}
 		vf->compWidth = pic->width;
 		vf->compHeight = pic->height;
-
+		update_vf_memhandle(hevc, vf, pic->index);
 		switch (hevc->bit_depth_luma) {
 		case 9:
 			vf->bitdepth = BITDEPTH_Y9;
@@ -4785,10 +5902,11 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 #endif
 		set_frame_info(hevc, vf);
 		/* if((vf->width!=pic->width)||(vf->height!=pic->height)) */
-		/* pr_info("aaa: %d/%d, %d/%d\n",
+		/* hevc_print(hevc, 0,
+			"aaa: %d/%d, %d/%d\n",
 		   vf->width,vf->height, pic->width, pic->height); */
-		if ((double_write_mode == 2) ||
-			(double_write_mode == 3)) {
+		if ((get_double_write_mode(hevc) == 2) ||
+			(get_double_write_mode(hevc) == 3)) {
 			vf->width = pic->width/4;
 			vf->height = pic->height/4;
 		}	else {
@@ -4813,7 +5931,8 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 			hevc->xxx can only be used by current decoded pic
 		*/
 		if (hevc->param.p.conformance_window_flag &&
-			(debug & H265_DEBUG_IGNORE_CONFORMANCE_WINDOW) == 0) {
+			(get_dbg_flag(hevc) &
+				H265_DEBUG_IGNORE_CONFORMANCE_WINDOW) == 0) {
 			unsigned SubWidthC, SubHeightC;
 			switch (hevc->param.p.chroma_format_idc) {
 			case 1:
@@ -4835,8 +5954,9 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 			vf->height -= SubHeightC *
 				(hevc->param.p.conf_win_top_offset +
 				hevc->param.p.conf_win_bottom_offset);
-			if (debug & H265_DEBUG_BUFMGR)
-				pr_info("conformance_window %d, %d, %d, %d, %d => cropped width %d, height %d\n",
+			if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+				hevc_print(hevc, 0,
+					"conformance_window %d, %d, %d, %d, %d => cropped width %d, height %d\n",
 					hevc->param.p.chroma_format_idc,
 					hevc->param.p.conf_win_left_offset,
 					hevc->param.p.conf_win_right_offset,
@@ -4848,8 +5968,15 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 #ifdef HEVC_PIC_STRUCT_SUPPORT
 		if (pic->pic_struct == 3 || pic->pic_struct == 4) {
 			struct vframe_s *vf2;
+			if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
+				hevc_print(hevc, 0,
+					"pic_struct = %d index 0x%x\n",
+					pic->pic_struct,
+					pic->index);
+
 			if (kfifo_get(&hevc->newframe_q, &vf2) == 0) {
-				pr_info("fatal error, no available buffer slot.");
+				hevc_print(hevc, 0,
+					"fatal error, no available buffer slot.");
 				return -1;
 			}
 			pic->vf_ref = 2;
@@ -4874,12 +6001,20 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 		} else if (pic->pic_struct == 5
 			|| pic->pic_struct == 6) {
 			struct vframe_s *vf2, *vf3;
+			if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
+				hevc_print(hevc, 0,
+					"pic_struct = %d index 0x%x\n",
+					pic->pic_struct,
+					pic->index);
+
 			if (kfifo_get(&hevc->newframe_q, &vf2) == 0) {
-				pr_info("fatal error, no available buffer slot.");
+				hevc_print(hevc, 0,
+				"fatal error, no available buffer slot.");
 				return -1;
 			}
 			if (kfifo_get(&hevc->newframe_q, &vf3) == 0) {
-				pr_info("fatal error, no available buffer slot.");
+				hevc_print(hevc, 0,
+				"fatal error, no available buffer slot.");
 				return -1;
 			}
 			pic->vf_ref = 3;
@@ -4908,8 +6043,16 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 			(const struct vframe_s *)vf2);
 			kfifo_put(&hevc->display_q,
 			(const struct vframe_s *)vf3);
+
 		} else if (pic->pic_struct == 9
 			|| pic->pic_struct == 10) {
+			if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
+				hevc_print(hevc, 0,
+					"pic_struct = %d index 0x%x\n",
+					pic->pic_struct,
+					pic->index);
+
+			pic->vf_ref = 1;
 			/* process previous pending vf*/
 			process_pending_vframe(hevc,
 			pic, (pic->pic_struct == 9));
@@ -4936,8 +6079,15 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 				hevc->pre_top_pic = pic;
 			else
 				hevc->pre_bot_pic = pic;
+
 		} else if (pic->pic_struct == 11
 		    || pic->pic_struct == 12) {
+			if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
+				hevc_print(hevc, 0,
+				"pic_struct = %d index 0x%x\n",
+				pic->pic_struct,
+				pic->index);
+			pic->vf_ref = 1;
 			/* process previous pending vf*/
 			process_pending_vframe(hevc, pic,
 			(pic->pic_struct == 11));
@@ -4960,8 +6110,16 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 				hevc->pre_top_pic = pic;
 			else
 				hevc->pre_bot_pic = pic;
+
 		} else {
 			pic->vf_ref = 1;
+
+			if (get_dbg_flag(hevc) & H265_DEBUG_PIC_STRUCT)
+				hevc_print(hevc, 0,
+				"pic_struct = %d index 0x%x\n",
+				pic->pic_struct,
+				pic->index);
+
 			switch (pic->pic_struct) {
 			case 7:
 				vf->duration <<= 1;
@@ -4994,7 +6152,7 @@ static int prepare_display_buf(struct hevc_state_s *hevc, struct PIC_s *pic)
 		kfifo_put(&hevc->display_q, (const struct vframe_s *)vf);
 #endif
 
-		vf_notify_receiver(PROVIDER_NAME,
+		vf_notify_receiver(hevc->provider_name,
 				VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
 	}
 
@@ -5005,16 +6163,18 @@ static void process_nal_sei(struct hevc_state_s *hevc,
 	int payload_type, int payload_size)
 {
 	unsigned short data;
-	if (debug & H265_DEBUG_PRINT_SEI)
-		pr_info("\tsei message: payload_type = 0x%02x, payload_size = 0x%02x\n",
+	if (get_dbg_flag(hevc) & H265_DEBUG_PRINT_SEI)
+		hevc_print(hevc, 0,
+			"\tsei message: payload_type = 0x%02x, payload_size = 0x%02x\n",
 		payload_type, payload_size);
 
 	if (payload_type == 137) {
 		int i, j;
 		/* MASTERING_DISPLAY_COLOUR_VOLUME */
 		if (payload_size >= 24) {
-			if (debug & H265_DEBUG_PRINT_SEI)
-				pr_info("\tsei MASTERING_DISPLAY_COLOUR_VOLUME available\n");
+			if (get_dbg_flag(hevc) & H265_DEBUG_PRINT_SEI)
+				hevc_print(hevc, 0,
+					"\tsei MASTERING_DISPLAY_COLOUR_VOLUME available\n");
 			for (i = 0; i < 3; i++) {
 				for (j = 0; j < 2; j++) {
 					data =
@@ -5022,8 +6182,10 @@ static void process_nal_sei(struct hevc_state_s *hevc,
 					hevc->primaries[i][j] = data;
 					WRITE_HREG(HEVC_SHIFT_COMMAND,
 					(1<<7)|16);
-					if (debug & H265_DEBUG_PRINT_SEI)
-						pr_info("\t\tprimaries[%1d][%1d] = %04x\n",
+					if (get_dbg_flag(hevc) &
+						H265_DEBUG_PRINT_SEI)
+						hevc_print(hevc, 0,
+							"\t\tprimaries[%1d][%1d] = %04x\n",
 						i, j, hevc->primaries[i][j]);
 				}
 			}
@@ -5031,8 +6193,9 @@ static void process_nal_sei(struct hevc_state_s *hevc,
 				data = (READ_HREG(HEVC_SHIFTED_DATA) >> 16);
 				hevc->white_point[i] = data;
 				WRITE_HREG(HEVC_SHIFT_COMMAND, (1<<7)|16);
-				if (debug & H265_DEBUG_PRINT_SEI)
-					pr_info("\t\twhite_point[%1d] = %04x\n",
+				if (get_dbg_flag(hevc) & H265_DEBUG_PRINT_SEI)
+					hevc_print(hevc, 0,
+						"\t\twhite_point[%1d] = %04x\n",
 					i, hevc->white_point[i]);
 			}
 			for (i = 0; i < 2; i++) {
@@ -5046,8 +6209,10 @@ static void process_nal_sei(struct hevc_state_s *hevc,
 					hevc->luminance[i] |= data;
 					WRITE_HREG(HEVC_SHIFT_COMMAND,
 					(1<<7)|16);
-					if (debug & H265_DEBUG_PRINT_SEI)
-						pr_info("\t\tluminance[%1d] = %08x\n",
+					if (get_dbg_flag(hevc) &
+						H265_DEBUG_PRINT_SEI)
+						hevc_print(hevc, 0,
+							"\t\tluminance[%1d] = %08x\n",
 						i, hevc->luminance[i]);
 			}
 			hevc->sei_present_flag |= SEI_MASTER_DISPLAY_COLOR_MASK;
@@ -5057,13 +6222,14 @@ static void process_nal_sei(struct hevc_state_s *hevc,
 			data = (READ_HREG(HEVC_SHIFTED_DATA) >> 24);
 			payload_size--;
 			WRITE_HREG(HEVC_SHIFT_COMMAND, (1<<7)|8);
-			pr_info("\t\tskip byte %02x\n", data);
+			hevc_print(hevc, 0, "\t\tskip byte %02x\n", data);
 		}
 	}
 }
 
-static void hevc_recover(struct hevc_state_s *hevc)
+static int hevc_recover(struct hevc_state_s *hevc)
 {
+	int ret = -1;
 	u32 rem;
 	u64 shift_byte_count64;
 	unsigned hevc_shift_byte_count;
@@ -5074,19 +6240,25 @@ static void hevc_recover(struct hevc_state_s *hevc)
 	unsigned hevc_stream_control;
 	unsigned hevc_stream_fifo_ctl;
 	unsigned hevc_stream_buf_size;
+	mutex_lock(&vh265_mutex);
 #if 0
 	for (i = 0; i < (hevc->debug_ptr_size / 2); i += 4) {
 		int ii;
 		for (ii = 0; ii < 4; ii++)
-			pr_info("%04x ", hevc->debug_ptr[i + 3 - ii]);
+			hevc_print(hevc, 0,
+			"%04x ", hevc->debug_ptr[i + 3 - ii]);
 		if (((i + ii) & 0xf) == 0)
-			pr_info("\n");
+			hevc_print(hevc, 0, "\n");
 	}
 #endif
 #define ES_VID_MAN_RD_PTR            (1<<0)
-
+	if (!hevc->init_flag) {
+		hevc_print(hevc, 0, "h265 has stopped, recover return!\n");
+		mutex_unlock(&vh265_mutex);
+		return ret;
+	}
 	amhevc_stop();
-
+	ret = 0;
 	/* reset */
 	WRITE_MPEG_REG(PARSER_VIDEO_RP, READ_VREG(HEVC_STREAM_RD_PTR));
 	SET_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
@@ -5144,7 +6316,7 @@ static void hevc_recover(struct hevc_state_s *hevc)
 
 	hevc->have_valid_start_slice = 0;
 
-	if (double_write_mode & 0x10)
+	if (get_double_write_mode(hevc) & 0x10)
 		WRITE_VREG(HEVCD_MPP_DECOMP_CTL1,
 			0x1 << 31  /*/Enable NV21 reference read mode for MC*/
 			);
@@ -5159,7 +6331,7 @@ static void hevc_recover(struct hevc_state_s *hevc)
 
 	CLEAR_MPEG_REG_MASK(PARSER_ES_CONTROL, ES_VID_MAN_RD_PTR);
 
-	if (debug & H265_DEBUG_UCODE)
+	if (get_dbg_flag(hevc) & H265_DEBUG_UCODE)
 		WRITE_VREG(DEBUG_REG1, 0x1);
 	else
 		WRITE_VREG(DEBUG_REG1, 0x0);
@@ -5176,11 +6348,17 @@ static void hevc_recover(struct hevc_state_s *hevc)
 		WRITE_VREG(NAL_SEARCH_CTL, 0x1);/* manual parser NAL */
 	}
 
-	if (debug & H265_DEBUG_NO_EOS_SEARCH_DONE)
+	if (get_dbg_flag(hevc) & H265_DEBUG_NO_EOS_SEARCH_DONE)
 		WRITE_VREG(NAL_SEARCH_CTL, READ_VREG(NAL_SEARCH_CTL) | 0x10000);
-	if (parser_sei_enable & 0x1)
-		WRITE_VREG(NAL_SEARCH_CTL,
-			READ_VREG(NAL_SEARCH_CTL) | 0x20000);
+	WRITE_VREG(NAL_SEARCH_CTL,
+		READ_VREG(NAL_SEARCH_CTL)
+		| ((parser_sei_enable & 0x7) << 17));
+#ifdef CONFIG_AM_VDEC_DV
+	WRITE_VREG(NAL_SEARCH_CTL,
+		READ_VREG(NAL_SEARCH_CTL) |
+		((parser_dolby_vision_enable & 0x1) << 20));
+#endif
+	config_decode_mode(hevc);
 	WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
 
 	/* if (amhevc_loadmc(vh265_mc) < 0) { */
@@ -5192,15 +6370,16 @@ static void hevc_recover(struct hevc_state_s *hevc)
 		int ii;
 		for (ii = 0; ii < 4; ii++) {
 			/* hevc->debug_ptr[i+3-ii]=ttt++; */
-			pr_info("%04x ", hevc->debug_ptr[i + 3 - ii]);
+			hevc_print(hevc, 0,
+			"%04x ", hevc->debug_ptr[i + 3 - ii]);
 		}
 		if (((i + ii) & 0xf) == 0)
-			pr_info("\n");
+			hevc_print(hevc, 0, "\n");
 	}
 #endif
 	init_pic_list_hw(hevc);
 
-	pr_info("%s HEVC_SHIFT_BYTE_COUNT=%x\n", __func__,
+	hevc_print(hevc, 0, "%s HEVC_SHIFT_BYTE_COUNT=%x\n", __func__,
 		   READ_VREG(HEVC_SHIFT_BYTE_COUNT));
 
 	amhevc_start();
@@ -5211,63 +6390,74 @@ static void hevc_recover(struct hevc_state_s *hevc)
 #ifdef ERROR_HANDLE_DEBUG
 	if (dbg_nal_skip_count & 0x20000) {
 		dbg_nal_skip_count &= ~0x20000;
-		return;
+		mutex_unlock(&vh265_mutex);
+		return ret;
 	}
 #endif
 	WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
 	/* Interrupt Amrisc to excute */
 	WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
-
-	hevc->first_pic_after_recover = 1;
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (!hevc->m_ins_flag)
+#endif
+		hevc->first_pic_after_recover = 1;
+	mutex_unlock(&vh265_mutex);
+	return ret;
 }
 
-
-static irqreturn_t vh265_isr(int irq, void *data)
+static void dump_aux_buf(struct hevc_state_s *hevc)
 {
-	int ret;
 	int i;
-	unsigned int dec_status;
-	struct hevc_state_s *hevc = (struct hevc_state_s *)data;
-	dec_status = READ_VREG(HEVC_DEC_STATUS_REG);
-	if (hevc->init_flag == 0)
-		return IRQ_HANDLED;
-
-	if (debug & H265_DEBUG_BUFMGR)
-		pr_info("265 isr dec status = %d\n", dec_status);
-
-	if (debug & H265_DEBUG_UCODE) {
-		if (READ_HREG(DEBUG_REG1) & 0x10000) {
-			dma_sync_single_for_cpu(
-				amports_get_dma_device(),
-				hevc->lmem_phy_addr,
-				LMEM_BUF_SIZE,
-				DMA_FROM_DEVICE);
-
-			pr_info("LMEM<tag %x>:\n", READ_HREG(DEBUG_REG1));
-			for (i = 0; i < 0x400; i += 4) {
-				int ii;
-				if ((i & 0xf) == 0)
-					pr_info("%03x: ", i);
-				for (ii = 0; ii < 4; ii++) {
-					pr_info("%04x ",
-						   hevc->lmem_ptr[i + 3 - ii]);
-				}
-				if (((i + ii) & 0xf) == 0)
-					pr_info("\n");
-			}
-			WRITE_HREG(DEBUG_REG1, 0);
-		} else if (READ_HREG(DEBUG_REG1) != 0) {
-			pr_info("dbg%x: %x\n", READ_HREG(DEBUG_REG1),
-				   READ_HREG(DEBUG_REG2));
-			WRITE_HREG(DEBUG_REG1, 0);
-			return IRQ_HANDLED;
+	unsigned short *aux_adr =
+		(unsigned short *)
+		hevc->aux_addr;
+	unsigned aux_size =
+		(READ_VREG(HEVC_AUX_DATA_SIZE)
+		>> 16) << 4;
+
+	if (hevc->prefix_aux_size > 0) {
+		hevc_print(hevc, 0,
+			"prefix aux: (size %d)\n",
+			aux_size);
+		for (i = 0; i <
+		(aux_size >> 1); i++) {
+			hevc_print_cont(hevc, 0,
+				"%04x ",
+				*(aux_adr + i));
+			if (((i + 1) & 0xf)
+				== 0)
+				hevc_print_cont(hevc,
+				0, "\n");
 		}
-
 	}
+	if (hevc->suffix_aux_size > 0) {
+		aux_adr = (unsigned short *)
+			(hevc->aux_addr +
+			hevc->prefix_aux_size);
+		aux_size =
+		(READ_VREG(HEVC_AUX_DATA_SIZE) & 0xffff)
+			<< 4;
+		hevc_print(hevc, 0,
+			"suffix aux: (size %d)\n",
+			aux_size);
+		for (i = 0; i <
+		(aux_size >> 1); i++) {
+			hevc_print_cont(hevc, 0,
+				"%04x ", *(aux_adr + i));
+			if (((i + 1) & 0xf) == 0)
+				hevc_print_cont(hevc, 0, "\n");
+		}
+	}
+}
 
-	if (hevc->pic_list_init_flag == 1)
-		return IRQ_HANDLED;
-
+static irqreturn_t vh265_isr_thread_fn(int irq, void *data)
+{
+	struct hevc_state_s *hevc = (struct hevc_state_s *) data;
+	unsigned int dec_status = hevc->dec_status;
+	int i, ret;
+#ifdef CONFIG_AM_VDEC_DV
+	struct vdec_s *vdec = hw_to_vdec(hevc);
+#endif
 	if (hevc->error_flag == 1) {
 		if ((error_handle_policy & 0x10) == 0) {
 			if (hevc->cur_pic) {
@@ -5290,23 +6480,30 @@ static irqreturn_t vh265_isr(int irq, void *data)
 			hevc->error_skip_nal_count = error_skip_nal_count;
 			WRITE_VREG(NAL_SEARCH_CTL, 0x1);/* manual parser NAL */
 		}
-		if (debug & H265_DEBUG_NO_EOS_SEARCH_DONE) {
+		if (get_dbg_flag(hevc) & H265_DEBUG_NO_EOS_SEARCH_DONE) {
 			WRITE_VREG(NAL_SEARCH_CTL,
 					   READ_VREG(NAL_SEARCH_CTL) | 0x10000);
 		}
-		if (parser_sei_enable & 0x1)
-			WRITE_VREG(NAL_SEARCH_CTL,
-				READ_VREG(NAL_SEARCH_CTL) | 0x20000);
+		WRITE_VREG(NAL_SEARCH_CTL,
+			READ_VREG(NAL_SEARCH_CTL)
+			| ((parser_sei_enable & 0x7) << 17));
+#ifdef CONFIG_AM_VDEC_DV
+		WRITE_VREG(NAL_SEARCH_CTL,
+			READ_VREG(NAL_SEARCH_CTL) |
+			((parser_dolby_vision_enable & 0x1) << 20));
+#endif
+		config_decode_mode(hevc);
 		/* search new nal */
 		WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
 		/* Interrupt Amrisc to excute */
 		WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
 
-		/* pr_info("%s: error handle\n", __func__); */
+		/* hevc_print(hevc, 0,
+		"%s: error handle\n", __func__); */
 		hevc->error_flag = 2;
 		return IRQ_HANDLED;
 	} else if (hevc->error_flag == 3) {
-		pr_info("error_flag=3, hevc_recover");
+		hevc_print(hevc, 0, "error_flag=3, hevc_recover\n");
 		hevc_recover(hevc);
 		hevc->error_flag = 0;
 
@@ -5346,11 +6543,151 @@ static irqreturn_t vh265_isr(int irq, void *data)
 		hevc->shift_byte_count_hi++;
 	hevc->shift_byte_count_lo = i;
 
+#ifdef MULTI_INSTANCE_SUPPORT
+	if ((dec_status == HEVC_DECPIC_DATA_DONE ||
+		dec_status == HEVC_FIND_NEXT_PIC_NAL ||
+		dec_status == HEVC_FIND_NEXT_DVEL_NAL)
+		&& (hevc->m_ins_flag)) {
+		if (hevc->chunk) {
+			hevc->cur_pic->pts = hevc->chunk->pts;
+			hevc->cur_pic->pts64 = hevc->chunk->pts64;
+		} else if (pts_lookup_offset_us64
+			(PTS_TYPE_VIDEO,
+			hevc->cur_pic->stream_offset,
+			&hevc->cur_pic->pts,
+			0,
+			&hevc->cur_pic->pts64) != 0) {
+#ifdef DEBUG_PTS
+			hevc->pts_missed++;
+#endif
+			hevc->cur_pic->pts = 0;
+			hevc->cur_pic->pts64 = 0;
+		}
+	}
+
+	if ((dec_status == HEVC_SEARCH_BUFEMPTY) ||
+		(dec_status == HEVC_DECODE_BUFEMPTY) ||
+		(dec_status == HEVC_NAL_DECODE_DONE)
+		) {
+		if (hevc->m_ins_flag) {
+#if 1
+			if (!vdec_frame_based(hw_to_vdec(hevc))) {
+				hevc->dec_result = DEC_RESULT_AGAIN;
+				amhevc_stop();
+			} else
+				hevc->dec_result = DEC_RESULT_GET_DATA;
+#else
+			if (!vdec_frame_based(hw_to_vdec(hevc)))
+				hevc->dec_result = DEC_RESULT_AGAIN;
+			else
+				hevc->dec_result = DEC_RESULT_DONE;
+			amhevc_stop();
+#endif
+			reset_process_time(hevc);
+			schedule_work(&hevc->work);
+		}
+
+		return IRQ_HANDLED;
+	} else if (dec_status == HEVC_DECPIC_DATA_DONE) {
+		if (hevc->m_ins_flag) {
+			hevc->dec_result = DEC_RESULT_DONE;
+			amhevc_stop();
+
+			reset_process_time(hevc);
+			schedule_work(&hevc->work);
+		}
+
+		return IRQ_HANDLED;
+#ifdef CONFIG_AM_VDEC_DV
+	} else if (dec_status == HEVC_FIND_NEXT_PIC_NAL ||
+		dec_status == HEVC_FIND_NEXT_DVEL_NAL) {
+		if (hevc->m_ins_flag) {
+			unsigned next_parser_type =
+					READ_HREG(CUR_NAL_UNIT_TYPE);
+			if (vdec->slave &&
+				dec_status == HEVC_FIND_NEXT_DVEL_NAL) {
+				/*cur is base, found enhance*/
+				struct hevc_state_s *hevc_el =
+				(struct hevc_state_s *)
+					vdec->slave->private;
+				hevc->switch_dvlayer_flag = 1;
+				hevc_el->start_parser_type =
+					next_parser_type;
+			} else if (vdec->master &&
+				dec_status == HEVC_FIND_NEXT_PIC_NAL) {
+				/*cur is enhance, found base*/
+				struct hevc_state_s *hevc_ba =
+				(struct hevc_state_s *)
+					vdec->master->private;
+				hevc->switch_dvlayer_flag = 1;
+				hevc_ba->start_parser_type =
+					next_parser_type;
+			} else {
+				hevc->switch_dvlayer_flag = 0;
+				hevc->start_parser_type =
+					next_parser_type;
+			}
+			hevc->dec_result = DEC_RESULT_DONE;
+			amhevc_stop();
+			reset_process_time(hevc);
+			if (READ_VREG(HEVC_AUX_DATA_SIZE) != 0) {
+				dma_sync_single_for_cpu(
+				amports_get_dma_device(),
+				hevc->aux_phy_addr,
+				hevc->prefix_aux_size + hevc->suffix_aux_size,
+				DMA_FROM_DEVICE);
+				if (get_dbg_flag(hevc) &
+					H265_DEBUG_BUFMGR_MORE)
+					dump_aux_buf(hevc);
+				if (hevc->cur_pic)
+					set_aux_data(hevc, hevc->cur_pic, 0);
+			}
+
+			schedule_work(&hevc->work);
+		}
+
+		return IRQ_HANDLED;
+#endif
+	} else if (dec_status == HEVC_DECODE_TIMEOUT) {
+		if (vdec_frame_based(hw_to_vdec(hevc)) ||
+			(READ_VREG(HEVC_STREAM_LEVEL) > 0x200)) {
+			if ((get_dbg_flag(hevc)
+				& H265_DEBUG_DIS_LOC_ERROR_PROC)) {
+				hevc_print(hevc, 0,
+					"%s decoding error, level 0x%x\n",
+					__func__, READ_VREG(HEVC_STREAM_LEVEL));
+				goto send_again;
+			}
+			amhevc_stop();
+			hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
+				"%s %s\n", __func__,
+				(dec_status == HEVC_SEARCH_BUFEMPTY) ?
+				"HEVC_SEARCH_BUFEMPTY" :
+				(dec_status == HEVC_DECODE_BUFEMPTY) ?
+				"HEVC_DECODE_BUFEMPTY" : "HEVC_DECODE_TIMEOUT");
+			hevc->dec_result = DEC_RESULT_DONE;
+
+			reset_process_time(hevc);
+			schedule_work(&hevc->work);
+		} else {
+			/* WRITE_VREG(dec_status_REG, H264_ACTION_INIT); */
+			hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
+				"%s DEC_RESULT_AGAIN\n", __func__);
+send_again:
+			hevc->dec_result = DEC_RESULT_AGAIN;
+			reset_process_time(hevc);
+			schedule_work(&hevc->work);
+		}
+		return IRQ_HANDLED;
+	}
+
+#endif
+
 	if (dec_status == HEVC_SEI_DAT) {
 		int payload_type = READ_HREG(CUR_NAL_UNIT_TYPE) & 0xffff;
 		int payload_size =
-		(READ_HREG(CUR_NAL_UNIT_TYPE) >> 16) & 0xffff;
-		process_nal_sei(hevc, payload_type, payload_size);
+			(READ_HREG(CUR_NAL_UNIT_TYPE) >> 16) & 0xffff;
+			process_nal_sei(hevc, payload_type, payload_size);
 
 		WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_SEI_DAT_DONE);
 	} else if (dec_status == HEVC_NAL_SEARCH_DONE) {
@@ -5358,15 +6695,17 @@ static irqreturn_t vh265_isr(int irq, void *data)
 		int parse_type = HEVC_DISCARD_NAL;
 		hevc->error_watchdog_count = 0;
 		hevc->error_skip_nal_wt_cnt = 0;
-		if (slice_parse_begin > 0 && debug & H265_DEBUG_DISCARD_NAL) {
-			pr_info("nal type %d, discard %d\n", naltype,
-				   slice_parse_begin);
+		if (slice_parse_begin > 0 &&
+			get_dbg_flag(hevc) & H265_DEBUG_DISCARD_NAL) {
+			hevc_print(hevc, 0,
+				"nal type %d, discard %d\n", naltype,
+				slice_parse_begin);
 			if (naltype <= NAL_UNIT_CODED_SLICE_CRA)
 				slice_parse_begin--;
 		}
 		if (naltype == NAL_UNIT_EOS) {
 			struct PIC_s *pic;
-			pr_info("get NAL_UNIT_EOS, flush output");
+			hevc_print(hevc, 0, "get NAL_UNIT_EOS, flush output\n");
 			pic = get_pic_by_POC(hevc, hevc->curr_POC);
 			hevc->curr_POC = INVALID_POC;
 			/* add to fix RAP_B_Bossen_1 */
@@ -5379,8 +6718,9 @@ static irqreturn_t vh265_isr(int irq, void *data)
 		}
 
 		if (hevc->error_skip_nal_count > 0) {
-			pr_info("nal type %d, discard %d\n", naltype,
-				   hevc->error_skip_nal_count);
+			hevc_print(hevc, 0,
+				"nal type %d, discard %d\n", naltype,
+				hevc->error_skip_nal_count);
 			hevc->error_skip_nal_count--;
 			if (hevc->error_skip_nal_count == 0) {
 				hevc_recover(hevc);
@@ -5393,11 +6733,11 @@ static irqreturn_t vh265_isr(int irq, void *data)
 				return IRQ_HANDLED;
 			}
 		} else if (naltype == NAL_UNIT_VPS) {
-			parse_type = HEVC_NAL_UNIT_VPS;
-			hevc->have_vps = 1;
+				parse_type = HEVC_NAL_UNIT_VPS;
+				hevc->have_vps = 1;
 #ifdef ERROR_HANDLE_DEBUG
-			if (dbg_nal_skip_flag & 1)
-				parse_type = HEVC_DISCARD_NAL;
+				if (dbg_nal_skip_flag & 1)
+					parse_type = HEVC_DISCARD_NAL;
 #endif
 		} else if (hevc->have_vps) {
 			if (naltype == NAL_UNIT_SPS) {
@@ -5418,7 +6758,7 @@ static irqreturn_t vh265_isr(int irq, void *data)
 				int seg = HEVC_NAL_UNIT_CODED_SLICE_SEGMENT;
 				if ((naltype == NAL_UNIT_CODED_SLICE_IDR) ||
 					(naltype ==
-					 NAL_UNIT_CODED_SLICE_IDR_N_LP)
+					NAL_UNIT_CODED_SLICE_IDR_N_LP)
 					|| (naltype ==
 						NAL_UNIT_CODED_SLICE_CRA)
 					|| (naltype ==
@@ -5427,10 +6767,10 @@ static irqreturn_t vh265_isr(int irq, void *data)
 						NAL_UNIT_CODED_SLICE_BLANT)
 					|| (naltype ==
 						NAL_UNIT_CODED_SLICE_BLA_N_LP)
-				   ) {
+				) {
 					if (slice_parse_begin > 0) {
-						pr_info
-						("discard %d, for debugging\n",
+						hevc_print(hevc, 0,
+						"discard %d, for debugging\n",
 						 slice_parse_begin);
 						slice_parse_begin--;
 					} else {
@@ -5442,9 +6782,9 @@ static irqreturn_t vh265_isr(int irq, void *data)
 						&& (hevc->have_valid_start_slice
 						|| (hevc->PB_skip_mode != 3))) {
 					if (slice_parse_begin > 0) {
-						pr_info
-						("discard %d, dd\n",
-						 slice_parse_begin);
+						hevc_print(hevc, 0,
+						"discard %d, dd\n",
+						slice_parse_begin);
 						slice_parse_begin--;
 					} else
 						parse_type = seg;
@@ -5455,27 +6795,37 @@ static irqreturn_t vh265_isr(int irq, void *data)
 		if (hevc->have_vps && hevc->have_sps && hevc->have_pps
 			&& hevc->have_valid_start_slice &&
 			hevc->error_flag == 0) {
-			if ((debug & H265_DEBUG_MAN_SEARCH_NAL) == 0) {
+			if ((get_dbg_flag(hevc) &
+				H265_DEBUG_MAN_SEARCH_NAL) == 0 /*&&
+				(!hevc->m_ins_flag)*/) {
 				/* auot parser NAL; do not check
-				   vps/sps/pps/idr */
+				vps/sps/pps/idr */
 				WRITE_VREG(NAL_SEARCH_CTL, 0x2);
 			}
 
-			if (debug & H265_DEBUG_NO_EOS_SEARCH_DONE) {
+			if (get_dbg_flag(hevc) &
+				H265_DEBUG_NO_EOS_SEARCH_DONE) {
 				WRITE_VREG(NAL_SEARCH_CTL,
-						   READ_VREG(NAL_SEARCH_CTL) |
-						   0x10000);
+						READ_VREG(NAL_SEARCH_CTL) |
+						0x10000);
 			}
-			if (parser_sei_enable & 0x1)
-				WRITE_VREG(NAL_SEARCH_CTL,
-					READ_VREG(NAL_SEARCH_CTL) | 0x20000);
+			WRITE_VREG(NAL_SEARCH_CTL,
+				READ_VREG(NAL_SEARCH_CTL)
+				| ((parser_sei_enable & 0x7) << 17));
+#ifdef CONFIG_AM_VDEC_DV
+			WRITE_VREG(NAL_SEARCH_CTL,
+				READ_VREG(NAL_SEARCH_CTL) |
+				((parser_dolby_vision_enable & 0x1) << 20));
+#endif
+			config_decode_mode(hevc);
 		}
 
-		if (debug & H265_DEBUG_BUFMGR) {
-			pr_info("naltype = %d  parse_type %d\n %d %d %d %d\n",
-				   naltype, parse_type, hevc->have_vps,
-				   hevc->have_sps, hevc->have_pps,
-				   hevc->have_valid_start_slice);
+		if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR) {
+			hevc_print(hevc, 0,
+				"naltype = %d  parse_type %d\n %d %d %d %d\n",
+				naltype, parse_type, hevc->have_vps,
+				hevc->have_sps, hevc->have_pps,
+				hevc->have_valid_start_slice);
 		}
 
 		WRITE_VREG(HEVC_DEC_STATUS_REG, parse_type);
@@ -5485,7 +6835,7 @@ static irqreturn_t vh265_isr(int irq, void *data)
 	} else if (dec_status == HEVC_SLICE_SEGMENT_DONE) {
 		if (hevc->start_decoding_time > 0) {
 			u32 process_time = 1000*
-			    (jiffies - hevc->start_decoding_time)/HZ;
+				(jiffies - hevc->start_decoding_time)/HZ;
 			if (process_time > max_decoding_time)
 				max_decoding_time = process_time;
 		}
@@ -5493,19 +6843,19 @@ static irqreturn_t vh265_isr(int irq, void *data)
 		hevc->error_watchdog_count = 0;
 		if (hevc->pic_list_init_flag == 2) {
 			hevc->pic_list_init_flag = 3;
-			pr_info("set pic_list_init_flag to 3\n");
+			hevc_print(hevc, 0, "set pic_list_init_flag to 3\n");
 		} else if (hevc->wait_buf == 0) {
 			u32 vui_time_scale;
 			u32 vui_num_units_in_tick;
 
-			if (debug & H265_DEBUG_SEND_PARAM_WITH_REG)
+			if (get_dbg_flag(hevc) & H265_DEBUG_SEND_PARAM_WITH_REG)
 				get_rpm_param(&hevc->param);
 			else {
 				dma_sync_single_for_cpu(
-					amports_get_dma_device(),
-					hevc->rpm_phy_addr,
-					RPM_BUF_SIZE,
-					DMA_FROM_DEVICE);
+				amports_get_dma_device(),
+				hevc->rpm_phy_addr,
+				RPM_BUF_SIZE,
+				DMA_FROM_DEVICE);
 
 				for (i = 0; i < (RPM_END - RPM_BEGIN); i += 4) {
 					int ii;
@@ -5516,46 +6866,62 @@ static irqreturn_t vh265_isr(int irq, void *data)
 					}
 				}
 			}
-			if (debug & H265_DEBUG_BUFMGR_MORE) {
-				pr_info("rpm_param: (%d)\n", hevc->slice_idx);
+			if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR_MORE) {
+				hevc_print(hevc, 0,
+					"rpm_param: (%d)\n", hevc->slice_idx);
 				hevc->slice_idx++;
 				for (i = 0; i < (RPM_END - RPM_BEGIN); i++) {
-					pr_info("%04x ", hevc->param.l.data[i]);
+					hevc_print_cont(hevc, 0,
+						"%04x ", hevc->param.l.data[i]);
 					if (((i + 1) & 0xf) == 0)
-						pr_info("\n");
+						hevc_print_cont(hevc, 0, "\n");
 				}
 
-				pr_info("vui_timing_info: %x, %x, %x, %x\n",
-					   hevc->
-					   param.p.vui_num_units_in_tick_hi,
-					   hevc->
-					   param.p.vui_num_units_in_tick_lo,
-					   hevc->param.p.vui_time_scale_hi,
-					   hevc->param.p.vui_time_scale_lo);
+				hevc_print(hevc, 0,
+					"vui_timing_info: %x, %x, %x, %x\n",
+					hevc->param.p.vui_num_units_in_tick_hi,
+					hevc->param.p.vui_num_units_in_tick_lo,
+					hevc->param.p.vui_time_scale_hi,
+					hevc->param.p.vui_time_scale_lo);
 			}
-
-			vui_time_scale =
-				(u32)(hevc->param.p.
-					  vui_time_scale_hi << 16) |
-				hevc->param.p.vui_time_scale_lo;
+			if (
+#ifdef CONFIG_AM_VDEC_DV
+				vdec->master == NULL &&
+				vdec->slave == NULL &&
+#endif
+				READ_VREG(HEVC_AUX_DATA_SIZE) != 0
+				) {
+				dma_sync_single_for_cpu(
+				amports_get_dma_device(),
+				hevc->aux_phy_addr,
+				hevc->prefix_aux_size + hevc->suffix_aux_size,
+				DMA_FROM_DEVICE);
+				if (get_dbg_flag(hevc) &
+					H265_DEBUG_BUFMGR_MORE)
+					dump_aux_buf(hevc);
+			}
+
+			vui_time_scale =
+				(u32)(hevc->param.p.vui_time_scale_hi << 16) |
+				hevc->param.p.vui_time_scale_lo;
 			vui_num_units_in_tick =
-				(u32)(hevc->param.p.
-					  vui_num_units_in_tick_hi << 16) |
+				(u32)(hevc->param.
+				p.vui_num_units_in_tick_hi << 16) |
 				hevc->param.
 				p.vui_num_units_in_tick_lo;
 			if (hevc->bit_depth_luma !=
 				((hevc->param.p.bit_depth & 0xf) + 8)) {
-				pr_info("Bit depth luma = %d\n",
-					   (hevc->param.p.bit_depth & 0xf) + 8);
+				hevc_print(hevc, 0, "Bit depth luma = %d\n",
+					(hevc->param.p.bit_depth & 0xf) + 8);
 			}
 			if (hevc->bit_depth_chroma !=
 				(((hevc->param.p.bit_depth >> 4) & 0xf) + 8)) {
-				pr_info("Bit depth chroma = %d\n",
-					   ((hevc->param.p.bit_depth >> 4) &
-					    0xf) + 8);
+				hevc_print(hevc, 0, "Bit depth chroma = %d\n",
+					((hevc->param.p.bit_depth >> 4) &
+					0xf) + 8);
 			}
 			hevc->bit_depth_luma =
-			    (hevc->param.p.bit_depth & 0xf) + 8;
+				(hevc->param.p.bit_depth & 0xf) + 8;
 			hevc->bit_depth_chroma =
 				((hevc->param.p.bit_depth >> 4) & 0xf) + 8;
 			bit_depth_luma = hevc->bit_depth_luma;
@@ -5572,8 +6938,8 @@ static irqreturn_t vh265_isr(int irq, void *data)
 				&& (vui_num_units_in_tick != 0)) {
 				hevc->frame_dur =
 					div_u64(96000ULL *
-							vui_num_units_in_tick,
-							vui_time_scale);
+						vui_num_units_in_tick,
+						vui_time_scale);
 				hevc->get_frame_dur = true;
 			}
 
@@ -5583,100 +6949,206 @@ static irqreturn_t vh265_isr(int irq, void *data)
 				u32 v = hevc->param.p.video_signal_type;
 				u32 c = hevc->param.p.color_description;
 #if 0
-				if (v & 0x2000) {
-					pr_info("video_signal_type present:\n");
-					pr_info(" %s %s\n",
-					video_format_names[(v >> 10) & 7],
-						((v >> 9) & 1) ?
-						"full_range" : "limited");
-					if (v & 0x100) {
-						pr_info(" color_description present:\n");
-						pr_info("  color_primarie = %s\n",
-						color_primaries_names
-						[v & 0xff]);
-						pr_info("  transfer_characteristic = %s\n",
-						transfer_characteristics_names
-						[(c >> 8) & 0xff]);
-						pr_info("  matrix_coefficient = %s\n",
-						matrix_coeffs_names[c & 0xff]);
-					}
+			if (v & 0x2000) {
+				hevc_print(hevc, 0,
+				"video_signal_type present:\n");
+				hevc_print(hevc, 0, " %s %s\n",
+				video_format_names[(v >> 10) & 7],
+					((v >> 9) & 1) ?
+					"full_range" : "limited");
+				if (v & 0x100) {
+					hevc_print(hevc, 0,
+					" color_description present:\n");
+					hevc_print(hevc, 0,
+					"  color_primarie = %s\n",
+					color_primaries_names
+					[v & 0xff]);
+					hevc_print(hevc, 0,
+					"  transfer_characteristic = %s\n",
+					transfer_characteristics_names
+					[(c >> 8) & 0xff]);
+					hevc_print(hevc, 0,
+					"  matrix_coefficient = %s\n",
+					matrix_coeffs_names[c & 0xff]);
 				}
-#endif
-				hevc->video_signal_type = (v << 16) | c;
-				video_signal_type = hevc->video_signal_type;
 			}
+#endif
+		hevc->video_signal_type = (v << 16) | c;
+		video_signal_type = hevc->video_signal_type;
+	}
+
+	if (use_cma &&
+		(hevc->param.p.slice_segment_address == 0)
+		&& (hevc->pic_list_init_flag == 0)) {
+		int log = hevc->param.p.log2_min_coding_block_size_minus3;
+		int log_s = hevc->param.p.log2_diff_max_min_coding_block_size;
+		hevc->pic_w = hevc->param.p.pic_width_in_luma_samples;
+		hevc->pic_h = hevc->param.p.pic_height_in_luma_samples;
+		hevc->lcu_size = 1 << (log + 3 + log_s);
+		hevc->lcu_size_log2 = log2i(hevc->lcu_size);
+		if (hevc->pic_w == 0 || hevc->pic_h == 0
+						|| hevc->lcu_size == 0) {
+			/* skip search next start code */
+			WRITE_VREG(HEVC_WAIT_FLAG, READ_VREG(HEVC_WAIT_FLAG)
+						& (~0x2));
+			hevc->skip_flag = 1;
+			WRITE_VREG(HEVC_DEC_STATUS_REG,	HEVC_ACTION_DONE);
+			/* Interrupt Amrisc to excute */
+			WRITE_VREG(HEVC_MCPU_INTR_REQ,	AMRISC_MAIN_REQ);
 
-			if (use_cma &&
-			    (hevc->param.p.slice_segment_address == 0)
-				&& (hevc->pic_list_init_flag == 0)) {
-				int log = hevc->param.p.
-					log2_min_coding_block_size_minus3;
-				int log_s = hevc->param.p.
-					log2_diff_max_min_coding_block_size;
-				hevc->pic_w =
-					hevc->param.p.pic_width_in_luma_samples;
-				hevc->pic_h =
-				hevc->param.p.pic_height_in_luma_samples;
-				hevc->lcu_size =
-					1 << (log + 3 + log_s);
-				hevc->lcu_size_log2 = log2i(hevc->lcu_size);
-				if (hevc->pic_w == 0 || hevc->pic_h == 0
-					|| hevc->lcu_size == 0) {
-					/* skip, search next start code */
-					WRITE_VREG(HEVC_WAIT_FLAG,
-						READ_VREG(HEVC_WAIT_FLAG) &
-						(~0x2));
-					hevc->skip_flag = 1;
-					WRITE_VREG(HEVC_DEC_STATUS_REG,
-							   HEVC_ACTION_DONE);
-					/* Interrupt Amrisc to excute */
-					WRITE_VREG(HEVC_MCPU_INTR_REQ,
-							   AMRISC_MAIN_REQ);
-
-				} else {
-					hevc->sps_num_reorder_pics_0 =
-					hevc->param.p.sps_num_reorder_pics_0;
-					hevc->pic_list_init_flag = 1;
-					up(&hevc->h265_sema);
-					pr_info("set pic_list_init_flag 1\n");
-				}
-				return IRQ_HANDLED;
-			}
+		} else {
+			hevc->sps_num_reorder_pics_0 =
+			hevc->param.p.sps_num_reorder_pics_0;
+			hevc->pic_list_init_flag = 1;
+#ifdef MULTI_INSTANCE_SUPPORT
+			if (hevc->m_ins_flag) {
+				reset_process_time(hevc);
+				schedule_work(&hevc->work);
+			} else
+#endif
+				up(&hevc->h265_sema);
+			hevc_print(hevc, 0, "set pic_list_init_flag 1\n");
+		}
+		return IRQ_HANDLED;
+	}
 
+}
+	ret =
+		hevc_slice_segment_header_process(hevc,
+			&hevc->param, decode_pic_begin);
+	if (ret < 0)
+		;
+	else if (ret == 0) {
+		if ((hevc->new_pic) && (hevc->cur_pic)) {
+			hevc->cur_pic->stream_offset =
+			READ_VREG(HEVC_SHIFT_BYTE_COUNT);
 		}
-		ret =
-			hevc_slice_segment_header_process(hevc, &hevc->param,
-					decode_pic_begin);
-		if (ret < 0)
-			;
-		else if (ret == 0) {
-			if ((hevc->new_pic) && (hevc->cur_pic)) {
-				hevc->cur_pic->stream_offset =
-					READ_VREG(HEVC_SHIFT_BYTE_COUNT);
-			}
 
-			WRITE_VREG(HEVC_DEC_STATUS_REG,
-					   HEVC_CODED_SLICE_SEGMENT_DAT);
-			/* Interrupt Amrisc to excute */
-			WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
+		WRITE_VREG(HEVC_DEC_STATUS_REG,
+			HEVC_CODED_SLICE_SEGMENT_DAT);
+		/* Interrupt Amrisc to excute */
+		WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
 
-			hevc->start_decoding_time = jiffies;
-		} else {
-			/* skip, search next start code */
-			WRITE_VREG(HEVC_WAIT_FLAG,
-					   READ_VREG(HEVC_WAIT_FLAG) & (~0x2));
+		hevc->start_decoding_time = jiffies;
+#if 1
+		/*to do..., copy aux data to hevc->cur_pic*/
+#endif
+#ifdef MULTI_INSTANCE_SUPPORT
+	} else if (hevc->m_ins_flag) {
+		hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
+			"%s, bufmgr ret %d skip, DEC_RESULT_DONE\n",
+			__func__, ret);
+		hevc->dec_result = DEC_RESULT_DONE;
+		amhevc_stop();
+		reset_process_time(hevc);
+		schedule_work(&hevc->work);
+#endif
+	} else {
+		/* skip, search next start code */
+		WRITE_VREG(HEVC_WAIT_FLAG, READ_VREG(HEVC_WAIT_FLAG) & (~0x2));
 			hevc->skip_flag = 1;
-			WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
-			/* Interrupt Amrisc to excute */
-			WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
-		}
+		WRITE_VREG(HEVC_DEC_STATUS_REG,	HEVC_ACTION_DONE);
+		/* Interrupt Amrisc to excute */
+		WRITE_VREG(HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
+	}
 
 	}
 
+	if (mmu_enable) {
+		if (hevc->last_put_idx_a >= 0
+			&& hevc->last_put_idx_a < MAX_REF_PIC_NUM) {
+			int i = hevc->last_put_idx_a;
+			struct PIC_s *pic = hevc->m_PIC[i];
+
+			/*free not used buffers.*/
+			if (pic &&
+				pic->output_mark == 0 && pic->referenced == 0
+				&& pic->output_ready == 0
+				&& pic->used_by_display == 0
+				&& (pic->index != -1)) {
+				decoder_mmu_box_free_idx(hevc->mmu_box, i);
+				hevc->last_put_idx_a = -1;
+			/*	hevc_print(hevc, 0, "release pic buf %x\n",i);*/
+				}
+		}
+		if (hevc->last_put_idx_b >= 0
+			&& hevc->last_put_idx_b < MAX_REF_PIC_NUM) {
+			int i = hevc->last_put_idx_b;
+			struct PIC_s *pic = hevc->m_PIC[i];
+
+			/*free not used buffers.*/
+			if (pic &&
+				pic->output_mark == 0 && pic->referenced == 0
+				&& pic->output_ready == 0
+				&& pic->used_by_display == 0
+				&& (pic->index != -1)) {
+				decoder_mmu_box_free_idx(hevc->mmu_box, i);
+				hevc->last_put_idx_b = -1;
+				}
+		}
+	}
+
 	return IRQ_HANDLED;
 }
 
-static void vh265_put_timer_func(unsigned long arg)
+static irqreturn_t vh265_isr(int irq, void *data)
+{
+	int i, temp;
+	unsigned int dec_status;
+	struct hevc_state_s *hevc = (struct hevc_state_s *)data;
+	dec_status = READ_VREG(HEVC_DEC_STATUS_REG);
+	if (hevc->init_flag == 0)
+		return IRQ_HANDLED;
+	hevc->dec_status = dec_status;
+	if (get_dbg_flag(hevc) & H265_DEBUG_BUFMGR)
+		hevc_print(hevc, 0,
+			"265 isr dec status = 0x%x\n", dec_status);
+
+	if (get_dbg_flag(hevc) & H265_DEBUG_UCODE) {
+		if (READ_HREG(DEBUG_REG1) & 0x10000) {
+			dma_sync_single_for_cpu(
+				amports_get_dma_device(),
+				hevc->lmem_phy_addr,
+				LMEM_BUF_SIZE,
+				DMA_FROM_DEVICE);
+
+			hevc_print(hevc, 0,
+				"LMEM<tag %x>:\n", READ_HREG(DEBUG_REG1));
+
+			if (mmu_enable)
+				temp = 0x500;
+			else
+				temp = 0x400;
+			for (i = 0; i < temp; i += 4) {
+				int ii;
+				if ((i & 0xf) == 0)
+					hevc_print_cont(hevc, 0, "%03x: ", i);
+				for (ii = 0; ii < 4; ii++) {
+					hevc_print_cont(hevc, 0, "%04x ",
+						   hevc->lmem_ptr[i + 3 - ii]);
+				}
+				if (((i + ii) & 0xf) == 0)
+					hevc_print_cont(hevc, 0, "\n");
+			}
+			WRITE_HREG(DEBUG_REG1, 0);
+		} else if (READ_HREG(DEBUG_REG1) != 0) {
+			hevc_print(hevc, 0,
+				"dbg%x: %x\n", READ_HREG(DEBUG_REG1),
+				   READ_HREG(DEBUG_REG2));
+			WRITE_HREG(DEBUG_REG1, 0);
+			return IRQ_HANDLED;
+		}
+
+	}
+
+	if (hevc->pic_list_init_flag == 1)
+		return IRQ_HANDLED;
+
+	return IRQ_WAKE_THREAD;
+
+}
+
+static void vh265_check_timer_func(unsigned long arg)
 {
 	struct hevc_state_s *hevc = (struct hevc_state_s *)arg;
 	struct timer_list *timer = &hevc->timer;
@@ -5691,11 +7163,49 @@ static void vh265_put_timer_func(unsigned long arg)
 		}
 		return;
 	}
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (hevc->m_ins_flag &&
+		hw_to_vdec(hevc)->next_status ==
+		VDEC_STATUS_DISCONNECTED) {
+		hevc->dec_result = DEC_RESULT_DONE;
+		schedule_work(&hevc->work);
+		hevc_print(hevc,
+			0, "vdec requested to be disconnected\n");
+		return;
+	}
 
-	if (vf_get_receiver(PROVIDER_NAME)) {
+	if (hevc->m_ins_flag) {
+		if ((input_frame_based(hw_to_vdec(hevc)) ||
+			(READ_VREG(HEVC_STREAM_LEVEL) > 0x200)) &&
+			((get_dbg_flag(hevc) &
+			H265_DEBUG_DIS_LOC_ERROR_PROC) == 0) &&
+			(decode_timeout_val > 0) &&
+			(hevc->start_process_time > 0) &&
+			((1000 * (jiffies - hevc->start_process_time) / HZ)
+				> decode_timeout_val)
+		) {
+			u32 dec_status = READ_VREG(HEVC_DEC_STATUS_REG);
+			int current_lcu_idx =
+				READ_VREG(HEVC_PARSER_LCU_START)&0xffffff;
+			if (dec_status == HEVC_CODED_SLICE_SEGMENT_DAT) {
+				if (hevc->last_lcu_idx == current_lcu_idx) {
+					if (hevc->decode_timeout_count > 0)
+						hevc->decode_timeout_count--;
+					if (hevc->decode_timeout_count == 0)
+						timeout_process(hevc);
+				}
+				hevc->last_lcu_idx = current_lcu_idx;
+			} else
+				timeout_process(hevc);
+		}
+	} else {
+#endif
+	if (hevc->m_ins_flag == 0 &&
+		vf_get_receiver(hevc->provider_name)) {
 		state =
-			vf_notify_receiver(PROVIDER_NAME,
-				VFRAME_EVENT_PROVIDER_QUREY_STATE, NULL);
+			vf_notify_receiver(hevc->provider_name,
+				VFRAME_EVENT_PROVIDER_QUREY_STATE,
+				NULL);
 		if ((state == RECEIVER_STATE_NULL)
 			|| (state == RECEIVER_STATE_NONE))
 			state = RECEIVER_INACTIVE;
@@ -5704,24 +7214,27 @@ static void vh265_put_timer_func(unsigned long arg)
 
 	empty_flag = (READ_VREG(HEVC_PARSER_INT_STATUS) >> 6) & 0x1;
 	/* error watchdog */
-	if ((empty_flag == 0)
+	if (hevc->m_ins_flag == 0 &&
+		(empty_flag == 0)
 		&& (hevc->pic_list_init_flag == 0
-			|| hevc->pic_list_init_flag == 3)) {
+			|| hevc->pic_list_init_flag
+			== 3)) {
 		/* decoder has input */
-		if ((debug & H265_DEBUG_DIS_LOC_ERROR_PROC) == 0) {
+		if ((get_dbg_flag(hevc) &
+			H265_DEBUG_DIS_LOC_ERROR_PROC) == 0) {
 
 			buf_level = READ_VREG(HEVC_STREAM_LEVEL);
 			/* receiver has no buffer to recycle */
 			if ((state == RECEIVER_INACTIVE) &&
 				(kfifo_is_empty(&hevc->display_q) &&
-				 buf_level > 0x200)
-			   ) {
+				buf_level > 0x200)
+				) {
 				if (hevc->error_flag == 0) {
 					hevc->error_watchdog_count++;
 					if (hevc->error_watchdog_count ==
 						error_handle_threshold) {
-						pr_info
-						("H265 dec err local reset.\n");
+						hevc_print(hevc, 0,
+						"H265 dec err local reset.\n");
 						hevc->error_flag = 1;
 						hevc->error_watchdog_count = 0;
 						hevc->error_skip_nal_wt_cnt = 0;
@@ -5729,7 +7242,7 @@ static void vh265_put_timer_func(unsigned long arg)
 						error_system_watchdog_count++;
 						WRITE_VREG
 						(HEVC_ASSIST_MBOX1_IRQ_REG,
-						 0x1);
+						0x1);
 					}
 				} else if (hevc->error_flag == 2) {
 					int th =
@@ -5749,49 +7262,55 @@ static void vh265_put_timer_func(unsigned long arg)
 			}
 		}
 
-		if ((debug & H265_DEBUG_DIS_SYS_ERROR_PROC) == 0)
+		if ((get_dbg_flag(hevc)
+			& H265_DEBUG_DIS_SYS_ERROR_PROC) == 0)
 			/* receiver has no buffer to recycle */
 			if ((state == RECEIVER_INACTIVE) &&
 				(kfifo_is_empty(&hevc->display_q))
 			   ) {	/* no buffer to recycle */
-				if ((debug & H265_DEBUG_DIS_LOC_ERROR_PROC) !=
+				if ((get_dbg_flag(hevc) &
+					H265_DEBUG_DIS_LOC_ERROR_PROC) !=
 					0)
 					hevc->error_system_watchdog_count++;
-				if (hevc->error_system_watchdog_count ==
+				if (hevc->error_system_watchdog_count
+					==
 					error_handle_system_threshold) {
 					/* and it lasts for a while */
-					pr_info
-					("H265 dec fatal error watchdog.\n");
-					hevc->error_system_watchdog_count = 0;
+					hevc_print(hevc, 0,
+					"H265 dec fatal error watchdog.\n");
+					hevc->
+					error_system_watchdog_count = 0;
 					hevc->fatal_error =
-						DECODER_FATAL_ERROR_UNKNOW;
+					DECODER_FATAL_ERROR_UNKNOW;
 				}
 			}
 	} else {
 		hevc->error_watchdog_count = 0;
 		hevc->error_system_watchdog_count = 0;
 	}
-
+#ifdef MULTI_INSTANCE_SUPPORT
+	}
+#endif
 	if (decode_stop_pos != decode_stop_pos_pre) {
 		WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
 		decode_stop_pos_pre = decode_stop_pos;
 	}
 
-	if (debug & H265_DEBUG_DUMP_PIC_LIST) {
+	if (get_dbg_flag(hevc) & H265_DEBUG_DUMP_PIC_LIST) {
 		dump_pic_list(hevc);
 		debug &= ~H265_DEBUG_DUMP_PIC_LIST;
 	}
-	if (debug & H265_DEBUG_TRIG_SLICE_SEGMENT_PROC) {
+	if (get_dbg_flag(hevc) & H265_DEBUG_TRIG_SLICE_SEGMENT_PROC) {
 		WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1);
 		debug &= ~H265_DEBUG_TRIG_SLICE_SEGMENT_PROC;
 	}
-	if (debug & H265_DEBUG_HW_RESET) {
+	if (get_dbg_flag(hevc) & H265_DEBUG_HW_RESET) {
 		hevc->error_skip_nal_count = error_skip_nal_count;
 		WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
 
 		debug &= ~H265_DEBUG_HW_RESET;
 	}
-	if (debug & H265_DEBUG_ERROR_TRIG) {
+	if (get_dbg_flag(hevc) & H265_DEBUG_ERROR_TRIG) {
 		WRITE_VREG(DECODE_STOP_POS, 1);
 		debug &= ~H265_DEBUG_ERROR_TRIG;
 	}
@@ -5806,9 +7325,11 @@ static void vh265_put_timer_func(unsigned long arg)
 	if (radr != 0) {
 		if (rval != 0) {
 			WRITE_VREG(radr, rval);
-			pr_info("WRITE_VREG(%x,%x)\n", radr, rval);
+			hevc_print(hevc, 0,
+				"WRITE_VREG(%x,%x)\n", radr, rval);
 		} else
-			pr_info("READ_VREG(%x)=%x\n", radr, READ_VREG(radr));
+			hevc_print(hevc, 0,
+				"READ_VREG(%x)=%x\n", radr, READ_VREG(radr));
 		rval = 0;
 		radr = 0;
 	}
@@ -5816,7 +7337,7 @@ static void vh265_put_timer_func(unsigned long arg)
 		if (dbg_cmd == 1) {
 			u32 disp_laddr;
 			if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB &&
-				double_write_mode == 0) {
+				get_double_write_mode(hevc) == 0) {
 				disp_laddr =
 					READ_VCBUS_REG(AFBC_BODY_BADDR) << 4;
 			} else {
@@ -5825,13 +7346,15 @@ static void vh265_put_timer_func(unsigned long arg)
 					& 0xff), &cur_canvas);
 				disp_laddr = cur_canvas.addr;
 			}
-			pr_info("current displayed buffer address %x\r\n",
+			hevc_print(hevc, 0,
+				"current displayed buffer address %x\r\n",
 				disp_laddr);
 		}
 		dbg_cmd = 0;
 	}
 	/*don't changed at start.*/
-	if (hevc->get_frame_dur && hevc->show_frame_num > 60 &&
+	if (hevc->m_ins_flag == 0 &&
+		hevc->get_frame_dur && hevc->show_frame_num > 60 &&
 		hevc->frame_dur > 0 && hevc->saved_resolution !=
 		hevc->frame_width * hevc->frame_height *
 			(96000 / hevc->frame_dur)) {
@@ -5854,8 +7377,8 @@ static int h265_task_handle(void *data)
 	set_user_nice(current, -10);
 	while (1) {
 		if (use_cma == 0) {
-			pr_info
-			("ERROR: use_cma can not be changed dynamically\n");
+			hevc_print(hevc, 0,
+			"ERROR: use_cma can not be changed dynamically\n");
 		}
 		ret = down_interruptible(&hevc->h265_sema);
 		if ((hevc->init_flag != 0) && (hevc->pic_list_init_flag == 1)) {
@@ -5866,7 +7389,7 @@ static int h265_task_handle(void *data)
 			init_pic_list_hw(hevc);
 			init_buf_spec(hevc);
 			hevc->pic_list_init_flag = 2;
-			pr_info("set pic_list_init_flag to 2\n");
+			hevc_print(hevc, 0, "set pic_list_init_flag to 2\n");
 
 			WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1);
 
@@ -5874,9 +7397,12 @@ static int h265_task_handle(void *data)
 
 		if (hevc->uninit_list) {
 			/*USE_BUF_BLOCK*/
-			uninit_buf_list(hevc, false);
-			pr_info("uninit list\n");
+			uninit_pic_list(hevc);
+			hevc_print(hevc, 0, "uninit list\n");
 			hevc->uninit_list = 0;
+#ifdef USE_UNINIT_SEMA
+			up(&hevc->h265_uninit_done_sema);
+#endif
 		}
 
 	}
@@ -5896,15 +7422,14 @@ void vh265_free_cmabuf(void)
 		return;
 	}
 
-	if (use_cma) {
-		pr_info("force uninit_buf_list\n");
-		uninit_buf_list(hevc, true);
-	}
-
 	mutex_unlock(&vh265_mutex);
 }
 
+#ifdef MULTI_INSTANCE_SUPPORT
+int vh265_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+#else
 int vh265_dec_status(struct vdec_status *vstatus)
+#endif
 {
 	struct hevc_state_s *hevc = &gHevc;
 	vstatus->width = hevc->frame_width;
@@ -5939,13 +7464,39 @@ static void H265_DECODE_INIT(void)
 }
 #endif
 
+static void config_decode_mode(struct hevc_state_s *hevc)
+{
+#ifdef CONFIG_AM_VDEC_DV
+	struct vdec_s *vdec = hw_to_vdec(hevc);
+#endif
+	if (!hevc->m_ins_flag)
+		WRITE_VREG(HEVC_DECODE_MODE,
+			DECODE_MODE_SINGLE);
+	else if (vdec_frame_based(hw_to_vdec(hevc)))
+		WRITE_VREG(HEVC_DECODE_MODE,
+			DECODE_MODE_MULTI_FRAMEBASE);
+#ifdef CONFIG_AM_VDEC_DV
+	else if (vdec->slave)
+		WRITE_VREG(HEVC_DECODE_MODE,
+			(hevc->start_parser_type << 8)
+			| DECODE_MODE_MULTI_DVBAL);
+	else if (vdec->master)
+		WRITE_VREG(HEVC_DECODE_MODE,
+			(hevc->start_parser_type << 8)
+			| DECODE_MODE_MULTI_DVENL);
+#endif
+	else
+		WRITE_VREG(HEVC_DECODE_MODE,
+			DECODE_MODE_MULTI_STREAMBASE);
+}
+
 static void vh265_prot_init(struct hevc_state_s *hevc)
 {
 	/* H265_DECODE_INIT(); */
 
 	hevc_config_work_space_hw(hevc);
 
-	hevc_init_decoder_hw(0, 0xffffffff);
+	hevc_init_decoder_hw(hevc, 0, 0xffffffff);
 
 	WRITE_VREG(HEVC_WAIT_FLAG, 1);
 
@@ -5960,42 +7511,71 @@ static void vh265_prot_init(struct hevc_state_s *hevc)
 	/* disable PSCALE for hardware sharing */
 	WRITE_VREG(HEVC_PSCALE_CTRL, 0);
 
-	if (debug & H265_DEBUG_UCODE)
+	if (get_dbg_flag(hevc) & H265_DEBUG_UCODE)
 		WRITE_VREG(DEBUG_REG1, 0x1);
 	else
 		WRITE_VREG(DEBUG_REG1, 0x0);
 
-	if (debug & (H265_DEBUG_MAN_SKIP_NAL | H265_DEBUG_MAN_SEARCH_NAL)) {
+	if ((get_dbg_flag(hevc) &
+		(H265_DEBUG_MAN_SKIP_NAL |
+		H265_DEBUG_MAN_SEARCH_NAL))/* ||
+		hevc->m_ins_flag*/) {
 		WRITE_VREG(NAL_SEARCH_CTL, 0x1);	/* manual parser NAL */
 	} else {
-		unsigned ctl_val = 0x8;	/* check vps/sps/pps/i-slice in ucode */
+		/* check vps/sps/pps/i-slice in ucode */
+		unsigned ctl_val = 0x8;
+#ifdef MULTI_INSTANCE_SUPPORT
+		if (hevc->m_ins_flag &&
+			hevc->init_flag) {
+			/* do not check vps/sps/pps/i-slice in ucode
+			from the 2nd picture*/
+			ctl_val = 0x2;
+		} else
+#endif
 		if (hevc->PB_skip_mode == 0)
 			ctl_val = 0x4;	/* check vps/sps/pps only in ucode */
 		else if (hevc->PB_skip_mode == 3)
 			ctl_val = 0x0;	/* check vps/sps/pps/idr in ucode */
 		WRITE_VREG(NAL_SEARCH_CTL, ctl_val);
 	}
-	if (debug & H265_DEBUG_NO_EOS_SEARCH_DONE)
+	if (get_dbg_flag(hevc) & H265_DEBUG_NO_EOS_SEARCH_DONE)
 		WRITE_VREG(NAL_SEARCH_CTL, READ_VREG(NAL_SEARCH_CTL) | 0x10000);
 
-	if (parser_sei_enable & 0x1)
-		WRITE_VREG(NAL_SEARCH_CTL, READ_VREG(NAL_SEARCH_CTL) | 0x20000);
+	WRITE_VREG(NAL_SEARCH_CTL,
+		READ_VREG(NAL_SEARCH_CTL)
+		| ((parser_sei_enable & 0x7) << 17));
+#ifdef CONFIG_AM_VDEC_DV
+	WRITE_VREG(NAL_SEARCH_CTL,
+		READ_VREG(NAL_SEARCH_CTL) |
+		((parser_dolby_vision_enable & 0x1) << 20));
+#endif
 	WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
 
+	config_decode_mode(hevc);
+	config_aux_buf(hevc);
 }
 
 static int vh265_local_init(struct hevc_state_s *hevc)
 {
 	int i;
-	int ret;
+	int ret = -1;
 #ifdef DEBUG_PTS
 	hevc->pts_missed = 0;
 	hevc->pts_hit = 0;
 #endif
+
+	hevc->last_put_idx_a = -1;
+	hevc->last_put_idx_b = -1;
 	hevc->saved_resolution = 0;
 	hevc->get_frame_dur = false;
 	hevc->frame_width = hevc->vh265_amstream_dec_info.width;
 	hevc->frame_height = hevc->vh265_amstream_dec_info.height;
+	if (HEVC_SIZE < hevc->frame_width * hevc->frame_height) {
+		pr_info("over size : %u x %u.\n",
+			hevc->frame_width, hevc->frame_height);
+		hevc->fatal_error |= DECODER_FATAL_ERROR_SIZE_OVERFLOW;
+		return ret;
+	}
 	hevc->frame_dur =
 		(hevc->vh265_amstream_dec_info.rate ==
 		 0) ? 3600 : hevc->vh265_amstream_dec_info.rate;
@@ -6005,11 +7585,13 @@ static int vh265_local_init(struct hevc_state_s *hevc)
 	hevc->sei_present_flag = 0;
 	pts_unstable = ((unsigned long)hevc->vh265_amstream_dec_info.param
 		& 0x40) >> 6;
-	pr_info("h265:pts_unstable=%d\n", pts_unstable);
+	hevc_print(hevc, 0,
+		"h265:pts_unstable=%d\n", pts_unstable);
 /*
 TODO:FOR VERSION
 */
-	pr_info("h265: ver (%d,%d) decinfo: %dx%d rate=%d\n", h265_version,
+	hevc_print(hevc, 0,
+		"h265: ver (%d,%d) decinfo: %dx%d rate=%d\n", h265_version,
 		   0, hevc->frame_width, hevc->frame_height, hevc->frame_dur);
 
 	if (hevc->frame_dur == 0)
@@ -6030,33 +7612,43 @@ TODO:FOR VERSION
 
 	return ret;
 }
-
+#ifdef MULTI_INSTANCE_SUPPORT
+static s32 vh265_init(struct vdec_s *vdec)
+{
+	struct hevc_state_s *hevc = (struct hevc_state_s *)vdec->private;
+#else
 static s32 vh265_init(struct hevc_state_s *hevc)
 {
+#endif
 	init_timer(&hevc->timer);
 
 	hevc->stat |= STAT_TIMER_INIT;
-
 	if (vh265_local_init(hevc) < 0)
 		return -EBUSY;
 
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (hevc->m_ins_flag) {
+		hevc->timer.data = (ulong) hevc;
+		hevc->timer.function = vh265_check_timer_func;
+		hevc->timer.expires = jiffies + PUT_INTERVAL;
+
+		/*add_timer(&hevc->timer);
+
+		hevc->stat |= STAT_TIMER_ARM;*/
+
+		INIT_WORK(&hevc->work, vh265_work);
+
+		return 0;
+	}
+#endif
 	amhevc_enable();
-	if (debug & H265_DEBUG_LOAD_UCODE_FROM_FILE) {
-		pr_info("load ucode from file of vh265_mc_debug\n");
-		if (amhevc_loadmc_ex(VFORMAT_HEVC,
-				"vh265_mc_debug", NULL) < 0) {
-			amhevc_disable();
-			return -EBUSY;
-		}
-#if 0
-	} else if (double_write_mode & 0x10) {
-		pr_info("load ucode from file of vh265_mc_dw\n");
-		if (amhevc_loadmc_ex(VFORMAT_HEVC,
-				"vh265_mc_dw", NULL) < 0) {
+	if (mmu_enable && (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)) {
+		if (amhevc_loadmc_ex(VFORMAT_HEVC, "vh265_mc_mmu", NULL)
+			< 0) {
 			amhevc_disable();
 			return -EBUSY;
 		}
-#endif
+		hevc_print(hevc, 0, "vh265 mmu ucode loaded!\n");
 	} else if (amhevc_loadmc_ex(VFORMAT_HEVC, "vh265_mc", NULL) < 0) {
 		amhevc_disable();
 		return -EBUSY;
@@ -6066,27 +7658,38 @@ static s32 vh265_init(struct hevc_state_s *hevc)
 	/* enable AMRISC side protocol */
 	vh265_prot_init(hevc);
 
-	if (vdec_request_irq(VDEC_IRQ_1, vh265_isr,
+	if (vdec_request_threaded_irq(VDEC_IRQ_1, vh265_isr,
+				vh265_isr_thread_fn,
+				IRQF_ONESHOT,/*run thread on this irq disabled*/
 				"vh265-irq", (void *)hevc)) {
-		pr_info("vh265 irq register error.\n");
+		hevc_print(hevc, 0, "vh265 irq register error.\n");
 		amhevc_disable();
 		return -ENOENT;
 	}
 
 	hevc->stat |= STAT_ISR_REG;
+	hevc->provider_name = PROVIDER_NAME;
 
+#ifdef MULTI_INSTANCE_SUPPORT
+	vf_provider_init(&vh265_vf_prov, hevc->provider_name,
+				&vh265_vf_provider, vdec);
+	vf_reg_provider(&vh265_vf_prov);
+	vf_notify_receiver(hevc->provider_name, VFRAME_EVENT_PROVIDER_START,
+				NULL);
+	vf_notify_receiver(hevc->provider_name, VFRAME_EVENT_PROVIDER_FR_HINT,
+				(void *)((unsigned long)hevc->frame_dur));
+#else
 	vf_provider_init(&vh265_vf_prov, PROVIDER_NAME, &vh265_vf_provider,
 					 hevc);
 	vf_reg_provider(&vh265_vf_prov);
 	vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_START, NULL);
-
 	vf_notify_receiver(PROVIDER_NAME, VFRAME_EVENT_PROVIDER_FR_HINT,
 				(void *)((unsigned long)hevc->frame_dur));
-
+#endif
 	hevc->stat |= STAT_VF_HOOK;
 
 	hevc->timer.data = (ulong) hevc;
-	hevc->timer.function = vh265_put_timer_func;
+	hevc->timer.function = vh265_check_timer_func;
 	hevc->timer.expires = jiffies + PUT_INTERVAL;
 
 	add_timer(&hevc->timer);
@@ -6096,6 +7699,10 @@ static s32 vh265_init(struct hevc_state_s *hevc)
 	if (use_cma) {
 		if (h265_task == NULL) {
 			sema_init(&hevc->h265_sema, 1);
+#ifdef USE_UNINIT_SEMA
+			sema_init(
+			&hevc->h265_uninit_done_sema, 0);
+#endif
 			h265_task =
 				kthread_run(h265_task_handle, hevc,
 						"kthread_h265");
@@ -6103,8 +7710,8 @@ static s32 vh265_init(struct hevc_state_s *hevc)
 	}
 	/* hevc->stat |= STAT_KTHREAD; */
 
-	if (debug & H265_DEBUG_FORCE_CLK) {
-		pr_info("%s force clk\n", __func__);
+	if (get_dbg_flag(hevc) & H265_DEBUG_FORCE_CLK) {
+		hevc_print(hevc, 0, "%s force clk\n", __func__);
 		WRITE_VREG(HEVC_IQIT_CLK_RST_CTRL,
 				   READ_VREG(HEVC_IQIT_CLK_RST_CTRL) |
 				   ((1 << 2) | (1 << 1)));
@@ -6139,11 +7746,14 @@ static s32 vh265_init(struct hevc_state_s *hevc)
 	amhevc_start();
 
 	hevc->stat |= STAT_VDEC_RUN;
-
+#ifndef MULTI_INSTANCE_SUPPORT
 	set_vdec_func(&vh265_dec_status);
-
+#endif
 	hevc->init_flag = 1;
-
+	if (mmu_enable)
+		error_handle_threshold = 300;
+	else
+		error_handle_threshold = 30;
 	/* pr_info("%d, vh265_init, RP=0x%x\n",
 	   __LINE__, READ_VREG(HEVC_STREAM_RD_PTR)); */
 
@@ -6155,7 +7765,8 @@ static int vh265_stop(struct hevc_state_s *hevc)
 
 	hevc->init_flag = 0;
 
-	if ((debug & H265_DEBUG_NOWAIT_DECODE_DONE_WHEN_STOP) == 0) {
+	if (get_dbg_flag(hevc) &
+		H265_DEBUG_WAIT_DECODE_DONE_WHEN_STOP) {
 		int wait_timeout_count = 0;
 		while (READ_VREG(HEVC_DEC_STATUS_REG) ==
 			   HEVC_CODED_SLICE_SEGMENT_DAT &&
@@ -6164,7 +7775,6 @@ static int vh265_stop(struct hevc_state_s *hevc)
 			msleep(20);
 		}
 	}
-
 	if (hevc->stat & STAT_VDEC_RUN) {
 		amhevc_stop();
 		hevc->stat &= ~STAT_VDEC_RUN;
@@ -6183,7 +7793,7 @@ static int vh265_stop(struct hevc_state_s *hevc)
 	}
 
 	if (hevc->stat & STAT_VF_HOOK) {
-		vf_notify_receiver(PROVIDER_NAME,
+		vf_notify_receiver(hevc->provider_name,
 				VFRAME_EVENT_PROVIDER_FR_END_HINT, NULL);
 
 		vf_unreg_provider(&vh265_vf_prov);
@@ -6193,49 +7803,548 @@ static int vh265_stop(struct hevc_state_s *hevc)
 	hevc_local_uninit(hevc);
 
 	if (use_cma) {
+#ifdef USE_UNINIT_SEMA
+		int ret;
+#endif
 		hevc->uninit_list = 1;
 		up(&hevc->h265_sema);
+#ifdef USE_UNINIT_SEMA
+		ret = down_interruptible(
+			&hevc->h265_uninit_done_sema);
+#else
 		while (hevc->uninit_list)	/* wait uninit complete */
 			msleep(20);
-	}
-#if 0
-	if (h265_task)
-		kthread_stop(h265_task);
-	h265_task = NULL;
 #endif
+
+	}
+	uninit_mmu_buffers(hevc);
 	amhevc_disable();
 
 	return 0;
 }
 
+#ifdef MULTI_INSTANCE_SUPPORT
+static void reset_process_time(struct hevc_state_s *hevc)
+{
+	if (hevc->start_process_time) {
+		unsigned process_time =
+			1000 * (jiffies - hevc->start_process_time) / HZ;
+		hevc->start_process_time = 0;
+		if (process_time > max_process_time[hevc->index])
+			max_process_time[hevc->index] = process_time;
+	}
+}
+
+static void start_process_time(struct hevc_state_s *hevc)
+{
+	hevc->start_process_time = jiffies;
+	hevc->decode_timeout_count = 2;
+	hevc->last_lcu_idx = 0;
+}
+
+static void timeout_process(struct hevc_state_s *hevc)
+{
+	hevc->timeout_num++;
+	amhevc_stop();
+	hevc_print(hevc,
+		0, "%s decoder timeout\n", __func__);
+
+	hevc->dec_result = DEC_RESULT_DONE;
+	reset_process_time(hevc);
+	schedule_work(&hevc->work);
+}
+
+static unsigned char is_new_pic_available(struct hevc_state_s *hevc)
+{
+	struct PIC_s *new_pic = NULL;
+	struct PIC_s *pic;
+	/* recycle un-used pic */
+	int i;
+	/*return 1 if pic_list is not initialized yet*/
+	if (hevc->pic_list_init_flag != 3)
+		return 1;
+
+	for (i = 0; i < MAX_REF_PIC_NUM; i++) {
+		pic = hevc->m_PIC[i];
+		if (pic == NULL || pic->index == -1)
+			continue;
+		if ((pic->used_by_display)
+			&& ((READ_VCBUS_REG(AFBC_BODY_BADDR) << 4) !=
+				pic->mc_y_adr))
+			pic->used_by_display = 0;
+		if (pic->output_mark == 0 && pic->referenced == 0
+			&& pic->output_ready == 0
+			&& pic->used_by_display == 0) {
+			if (new_pic) {
+				if (pic->POC < new_pic->POC)
+					new_pic = pic;
+			} else
+				new_pic = pic;
+		}
+	}
+	return (new_pic != NULL) ? 1 : 0;
+}
+
+static int vmh265_stop(struct hevc_state_s *hevc)
+{
+	hevc->init_flag = 0;
+
+	if (hevc->stat & STAT_TIMER_ARM) {
+		del_timer_sync(&hevc->timer);
+		hevc->stat &= ~STAT_TIMER_ARM;
+	}
+
+	if (hevc->stat & STAT_VF_HOOK) {
+		vf_notify_receiver(hevc->provider_name,
+				VFRAME_EVENT_PROVIDER_FR_END_HINT, NULL);
+
+		vf_unreg_provider(&vh265_vf_prov);
+		hevc->stat &= ~STAT_VF_HOOK;
+	}
+
+	hevc_local_uninit(hevc);
+
+	if (use_cma) {
+#ifdef USE_UNINIT_SEMA
+		int ret;
+#endif
+		hevc->uninit_list = 1;
+		reset_process_time(hevc);
+		schedule_work(&hevc->work);
+#ifdef USE_UNINIT_SEMA
+		ret = down_interruptible(
+			&hevc->h265_uninit_done_sema);
+#else
+		while (hevc->uninit_list)	/* wait uninit complete */
+			msleep(20);
+#endif
+	}
+	cancel_work_sync(&hevc->work);
+	uninit_mmu_buffers(hevc);
+	return 0;
+}
+
+static unsigned int start_decode_buf_level; /* = 0x80000;*/
+
+static unsigned char get_data_check_sum
+	(struct hevc_state_s *hevc, int size)
+{
+	int jj;
+	int sum = 0;
+	u8 *data = ((u8 *)hevc->chunk->block->start_virt) +
+		hevc->chunk->offset;
+	for (jj = 0; jj < size; jj++)
+		sum += data[jj];
+	return sum;
+}
+
+static void vh265_work(struct work_struct *work)
+{
+	struct hevc_state_s *hevc = container_of(work,
+		struct hevc_state_s, work);
+	struct vdec_s *vdec = hw_to_vdec(hevc);
+	/* finished decoding one frame or error,
+	 * notify vdec core to switch context
+	 */
+	if ((hevc->init_flag != 0) && (hevc->pic_list_init_flag == 1)) {
+		/*USE_BUF_BLOCK*/
+		init_buf_list(hevc);
+		/**/
+		init_pic_list(hevc);
+		init_pic_list_hw(hevc);
+		init_buf_spec(hevc);
+		hevc->pic_list_init_flag = 2;
+		hevc_print(hevc, 0,
+			"set pic_list_init_flag to 2\n");
+
+		start_process_time(hevc);
+		WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG, 0x1);
+		return;
+	}
+
+	if (hevc->uninit_list) {
+		/*USE_BUF_BLOCK*/
+		uninit_pic_list(hevc);
+		hevc_print(hevc, 0, "uninit list\n");
+		hevc->uninit_list = 0;
+#ifdef USE_UNINIT_SEMA
+		up(&hevc->h265_uninit_done_sema);
+#endif
+		return;
+	}
+
+	if ((hevc->dec_result == DEC_RESULT_GET_DATA) ||
+		(hevc->dec_result == DEC_RESULT_GET_DATA_RETRY)) {
+		if (hevc->dec_result == DEC_RESULT_GET_DATA) {
+			hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
+				"%s DEC_RESULT_GET_DATA %x %x %x mpc %x\n",
+				__func__,
+				READ_VREG(HEVC_STREAM_LEVEL),
+				READ_VREG(HEVC_STREAM_WR_PTR),
+				READ_VREG(HEVC_STREAM_RD_PTR),
+				READ_VREG(HEVC_MPC_E));
+			vdec_vframe_dirty(vdec, hevc->chunk);
+			vdec_clean_input(vdec);
+		}
+
+		/*if (is_new_pic_available(hevc)) {*/
+		if (run_ready(vdec)) {
+			int r;
+			r = vdec_prepare_input(vdec, &hevc->chunk);
+			if (r < 0) {
+				hevc->dec_result = DEC_RESULT_GET_DATA_RETRY;
+
+				hevc_print(hevc,
+					PRINT_FLAG_VDEC_DETAIL,
+					"amvdec_vh265: Insufficient data\n");
+
+				schedule_work(&hevc->work);
+				return;
+			}
+			hevc->dec_result = DEC_RESULT_NONE;
+			hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
+				"%s: chunk size 0x%x sum 0x%x mpc %x\n",
+				__func__, r,
+				(get_dbg_flag(hevc) & PRINT_FLAG_VDEC_STATUS) ?
+				get_data_check_sum(hevc, r) : 0,
+				READ_VREG(HEVC_MPC_E));
+			if ((get_dbg_flag(hevc) & PRINT_FRAMEBASE_DATA) &&
+				input_frame_based(vdec)) {
+				int jj;
+				u8 *data =
+				((u8 *)hevc->chunk->block->start_virt) +
+					hevc->chunk->offset;
+				for (jj = 0; jj < r; jj++) {
+					if ((jj & 0xf) == 0)
+						hevc_print(hevc,
+						PRINT_FRAMEBASE_DATA,
+							"%06x:", jj);
+					hevc_print_cont(hevc,
+					PRINT_FRAMEBASE_DATA,
+						"%02x ", data[jj]);
+					if (((jj + 1) & 0xf) == 0)
+						hevc_print_cont(hevc,
+						PRINT_FRAMEBASE_DATA,
+							"\n");
+				}
+			}
+
+			WRITE_VREG(HEVC_DECODE_SIZE, r);
+
+			vdec_enable_input(vdec);
+
+			hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
+				"%s: mpc %x\n",
+				__func__, READ_VREG(HEVC_MPC_E));
+
+			start_process_time(hevc);
+			WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
+		} else{
+			hevc->dec_result = DEC_RESULT_GET_DATA_RETRY;
+
+			/*hevc_print(hevc, PRINT_FLAG_VDEC_DETAIL,
+				"amvdec_vh265: Insufficient data\n");
+			*/
+
+			schedule_work(&hevc->work);
+		}
+		return;
+	} else if (hevc->dec_result == DEC_RESULT_DONE) {
+		/* if (!hevc->ctx_valid)
+			hevc->ctx_valid = 1; */
+		hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
+			"%s dec_result %d %x %x %x\n",
+			__func__,
+			hevc->dec_result,
+			READ_VREG(HEVC_STREAM_LEVEL),
+			READ_VREG(HEVC_STREAM_WR_PTR),
+			READ_VREG(HEVC_STREAM_RD_PTR));
+#ifdef CONFIG_AM_VDEC_DV
+#if 1
+		if (vdec->slave) {
+			if (dv_debug & 0x1)
+				vdec_set_flag(vdec->slave, 0);
+			else
+				vdec_set_flag(vdec->slave,
+				VDEC_FLAG_INPUT_KEEP_CONTEXT);
+		}
+#else
+		if (vdec->slave) {
+			if (no_interleaved_el_slice)
+				vdec_set_flag(vdec->slave,
+				VDEC_FLAG_INPUT_KEEP_CONTEXT);
+				/* this will move real HW pointer for input */
+			else
+				vdec_set_flag(vdec->slave, 0);
+				/* this will not move real HW pointer
+				and SL layer decoding
+				will start from same stream position
+				as current BL decoder */
+		}
+#endif
+#endif
+		vdec_vframe_dirty(hw_to_vdec(hevc), hevc->chunk);
+	} else {
+		hevc_print(hevc, PRINT_FLAG_VDEC_DETAIL,
+			"%s dec_result %d %x %x %x\n",
+			__func__,
+			hevc->dec_result,
+			READ_VREG(HEVC_STREAM_LEVEL),
+			READ_VREG(HEVC_STREAM_WR_PTR),
+			READ_VREG(HEVC_STREAM_RD_PTR));
+	}
+
+	if (hevc->stat & STAT_TIMER_ARM) {
+		del_timer_sync(&hevc->timer);
+		hevc->stat &= ~STAT_TIMER_ARM;
+	}
+	/* mark itself has all HW resource released and input released */
+	vdec_set_status(hw_to_vdec(hevc), VDEC_STATUS_CONNECTED);
+
+#ifdef CONFIG_AM_VDEC_DV
+	if (hevc->switch_dvlayer_flag) {
+		if (vdec->slave)
+			vdec_set_next_sched(vdec, vdec->slave);
+		else if (vdec->master)
+			vdec_set_next_sched(vdec, vdec->master);
+	} else if (vdec->slave || vdec->master)
+		vdec_set_next_sched(vdec, vdec);
+#endif
+
+	if (hevc->vdec_cb)
+		hevc->vdec_cb(hw_to_vdec(hevc), hevc->vdec_cb_arg);
+}
+
+static int vh265_hw_ctx_restore(struct hevc_state_s *hevc)
+{
+	/* new to do ... */
+	vh265_prot_init(hevc);
+	return 0;
+}
+
+static bool run_ready(struct vdec_s *vdec)
+{
+	struct hevc_state_s *hevc =
+		(struct hevc_state_s *)vdec->private;
+
+	/*hevc_print(hevc,
+		PRINT_FLAG_VDEC_DETAIL, "%s\r\n", __func__);
+	*/
+	if ((!vdec_frame_based(vdec)) && (start_decode_buf_level > 0)) {
+		u32 rp, wp;
+		u32 level;
+
+		rp = READ_MPEG_REG(PARSER_VIDEO_RP);
+		wp = READ_MPEG_REG(PARSER_VIDEO_WP);
+
+		if (wp < rp)
+			level = vdec->input.size + wp - rp;
+		else
+			level = wp - rp;
+
+		if (level < start_decode_buf_level) {
+			hevc_print(hevc, 0,
+				"level %d not run_ready\n", level);
+			return false;
+		}
+	} else if (vdec_frame_based(vdec)) {
+		if (!vdec_input_next_input_chunk(&vdec->input))
+			return false;
+	}
+
+	return is_new_pic_available(hevc);
+}
+
+static void reset_dec_hw(struct vdec_s *vdec)
+{
+	if (input_frame_based(vdec))
+		WRITE_VREG(HEVC_STREAM_CONTROL, 0);
+
+		/*
+	 * 2: assist
+	 * 3: parser
+	 * 4: parser_state
+	 * 8: dblk
+	 * 11:mcpu
+	 * 12:ccpu
+	 * 13:ddr
+	 * 14:iqit
+	 * 15:ipp
+	 * 17:qdct
+	 * 18:mpred
+	 * 19:sao
+	 * 24:hevc_afifo
+	 */
+	WRITE_VREG(DOS_SW_RESET3,
+		(1<<3)|(1<<4)|(1<<8)|(1<<11)|(1<<12)|(1<<14)|(1<<15)|
+		(1<<17)|(1<<18)|(1<<19));
+	WRITE_VREG(DOS_SW_RESET3, 0);
+}
+
+static void run(struct vdec_s *vdec,
+	void (*callback)(struct vdec_s *, void *), void *arg)
+{
+	struct hevc_state_s *hevc =
+		(struct hevc_state_s *)vdec->private;
+	int r;
+
+	hevc->vdec_cb_arg = arg;
+	hevc->vdec_cb = callback;
+
+	reset_dec_hw(vdec);
+
+	r = vdec_prepare_input(vdec, &hevc->chunk);
+	if (r < 0) {
+		hevc->dec_result = DEC_RESULT_AGAIN;
+
+		hevc_print(hevc, PRINT_FLAG_VDEC_DETAIL,
+			"ammvdec_vh265: Insufficient data\n");
+
+		schedule_work(&hevc->work);
+		return;
+	}
+	hevc->dec_result = DEC_RESULT_NONE;
+
+	hevc_print(hevc, PRINT_FLAG_VDEC_STATUS,
+		"%s: size 0x%x sum 0x%x (%x %x %x)\n",
+		__func__, r,
+		(vdec_frame_based(vdec) &&
+		(get_dbg_flag(hevc) & PRINT_FLAG_VDEC_STATUS)) ?
+		get_data_check_sum(hevc, r) : 0,
+		READ_VREG(HEVC_STREAM_LEVEL),
+		READ_VREG(HEVC_STREAM_WR_PTR),
+		READ_VREG(HEVC_STREAM_RD_PTR));
+	if ((get_dbg_flag(hevc) & PRINT_FRAMEBASE_DATA) &&
+		input_frame_based(vdec)) {
+		int jj;
+		u8 *data = ((u8 *)hevc->chunk->block->start_virt) +
+			hevc->chunk->offset;
+		for (jj = 0; jj < r; jj++) {
+			if ((jj & 0xf) == 0)
+				hevc_print(hevc, PRINT_FRAMEBASE_DATA,
+					"%06x:", jj);
+			hevc_print_cont(hevc, PRINT_FRAMEBASE_DATA,
+				"%02x ", data[jj]);
+			if (((jj + 1) & 0xf) == 0)
+				hevc_print_cont(hevc, PRINT_FRAMEBASE_DATA,
+					"\n");
+		}
+	}
+	if (hevc->init_flag == 0) {
+		if (amhevc_vdec_loadmc_ex(vdec, "vh265_mc") < 0) {
+			amhevc_disable();
+			hevc_print(hevc, 0,
+				"%s: Error amvdec_loadmc fail\n", __func__);
+			return;
+		}
+	}
+	if (vh265_hw_ctx_restore(hevc) < 0) {
+		schedule_work(&hevc->work);
+		return;
+	}
+
+	vdec_enable_input(vdec);
+
+	WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
+
+	if (vdec_frame_based(vdec))
+		WRITE_VREG(HEVC_SHIFT_BYTE_COUNT, 0);
+
+	WRITE_VREG(HEVC_DECODE_SIZE, r);
+	/*WRITE_VREG(HEVC_DECODE_COUNT, hevc->decode_idx);*/
+	hevc->init_flag = 1;
+
+	if (hevc->pic_list_init_flag == 3)
+		init_pic_list_hw(hevc);
+
+	start_process_time(hevc);
+	add_timer(&hevc->timer);
+	hevc->stat |= STAT_TIMER_ARM;
+	amhevc_start();
+
+}
+
+static void reset(struct vdec_s *vdec)
+{
+	struct hevc_state_s *hevc =
+		(struct hevc_state_s *)vdec->private;
+
+	hevc_print(hevc,
+		PRINT_FLAG_VDEC_DETAIL, "%s\r\n", __func__);
+
+}
+
+static irqreturn_t vh265_irq_cb(struct vdec_s *vdec)
+{
+	struct hevc_state_s *hevc =
+		(struct hevc_state_s *)vdec->private;
+	return vh265_isr(0, hevc);
+}
+
+static irqreturn_t vh265_threaded_irq_cb(struct vdec_s *vdec)
+{
+	struct hevc_state_s *hevc =
+		(struct hevc_state_s *)vdec->private;
+	return vh265_isr_thread_fn(0, hevc);
+}
+#endif
+
+
+
+
 static int amvdec_h265_probe(struct platform_device *pdev)
 {
+#ifdef MULTI_INSTANCE_SUPPORT
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
+#else
 	struct vdec_dev_reg_s *pdata =
 		(struct vdec_dev_reg_s *)pdev->dev.platform_data;
-	int i;
+#endif
 	struct hevc_state_s *hevc = &gHevc;
+
+	if (get_dbg_flag(hevc))
+		hevc_print(hevc, 0, "%s\r\n", __func__);
 	mutex_lock(&vh265_mutex);
 
 	if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) &&
 		(parser_sei_enable & 0x100) == 0)
 		parser_sei_enable = 1;
+	hevc->m_ins_flag = 0;
 	hevc->init_flag = 0;
 	hevc->uninit_list = 0;
 	hevc->fatal_error = 0;
 	hevc->show_frame_num = 0;
 	if (pdata == NULL) {
-		pr_info("\namvdec_h265 memory resource undefined.\n");
+		hevc_print(hevc, 0,
+			"\namvdec_h265 memory resource undefined.\n");
 		mutex_unlock(&vh265_mutex);
 		return -EFAULT;
 	}
-
+#ifndef CONFIG_MULTI_DEC
+	if (get_cpu_type() < MESON_CPU_MAJOR_ID_GXL
+		|| double_write_mode == 0x10)
+		mmu_enable = 0;
+	else
+		mmu_enable = 1;
+#endif
+	if (init_mmu_buffers(hevc)) {
+		hevc_print(hevc, 0,
+			"\n 265 mmu init failed!\n");
+		mutex_unlock(&vh265_mutex);
+		return -EFAULT;
+	}
+	hevc->buf_start = pdata->mem_start;
+	hevc->buf_size = pdata->mem_end - pdata->mem_start + 1;
+	/*
 	hevc->mc_buf_spec.buf_end = pdata->mem_end + 1;
 	for (i = 0; i < WORK_BUF_SPEC_NUM; i++)
 		amvh265_workbuff_spec[i].start_adr = pdata->mem_start;
+	*/
 
-	if (debug) {
-		pr_info("===H.265 decoder mem resource 0x%lx -- 0x%lx\n",
-			   pdata->mem_start, pdata->mem_end + 1);
+	if (get_dbg_flag(hevc)) {
+		hevc_print(hevc, 0,
+			"===H.265 decoder mem resource 0x%lx -- 0x%lx\n",
+			pdata->mem_start, pdata->mem_end + 1);
 	}
 
 	if (pdata->sys_info)
@@ -6245,24 +8354,32 @@ static int amvdec_h265_probe(struct platform_device *pdev)
 		hevc->vh265_amstream_dec_info.height = 0;
 		hevc->vh265_amstream_dec_info.rate = 30;
 	}
-
+#ifndef MULTI_INSTANCE_SUPPORT
 	if (pdata->flag & DEC_FLAG_HEVC_WORKAROUND) {
 		workaround_enable |= 3;
-		pr_info("amvdec_h265 HEVC_WORKAROUND flag set.\n");
+		hevc_print(hevc, 0,
+			"amvdec_h265 HEVC_WORKAROUND flag set.\n");
 	} else
 		workaround_enable &= ~3;
-
-	cma_dev = pdata->cma_dev;
-
+#endif
+	hevc->cma_dev = pdata->cma_dev;
+#ifdef MULTI_INSTANCE_SUPPORT
+	pdata->private = hevc;
+	pdata->dec_status = vh265_dec_status;
+	if (vh265_init(pdata) < 0) {
+#else
 	if (vh265_init(hevc) < 0) {
-		pr_info("\namvdec_h265 init failed.\n");
+#endif
+		hevc_print(hevc, 0,
+			"\namvdec_h265 init failed.\n");
 		hevc_local_uninit(hevc);
+		uninit_mmu_buffers(hevc);
 		mutex_unlock(&vh265_mutex);
 		return -ENODEV;
 	}
 	/*set the max clk for smooth playing...*/
 	hevc_source_changed(VFORMAT_HEVC,
-			4096, 2048, 30);
+			3840, 2160, 60);
 	mutex_unlock(&vh265_mutex);
 
 	return 0;
@@ -6271,40 +8388,259 @@ static int amvdec_h265_probe(struct platform_device *pdev)
 static int amvdec_h265_remove(struct platform_device *pdev)
 {
 	struct hevc_state_s *hevc = &gHevc;
-	if (debug)
-		pr_info("amvdec_h265_remove\n");
+
+	if (get_dbg_flag(hevc))
+		hevc_print(hevc, 0, "%s\r\n", __func__);
 
 	mutex_lock(&vh265_mutex);
 
 	vh265_stop(hevc);
 
-
 	hevc_source_changed(VFORMAT_HEVC, 0, 0, 0);
 
 
 #ifdef DEBUG_PTS
-	pr_info("pts missed %ld, pts hit %ld, duration %d\n",
-		   hevc->pts_missed, hevc->pts_hit, hevc->frame_dur);
+	hevc_print(hevc, 0,
+		"pts missed %ld, pts hit %ld, duration %d\n",
+		hevc->pts_missed, hevc->pts_hit, hevc->frame_dur);
 #endif
 
 	mutex_unlock(&vh265_mutex);
 
 	return 0;
 }
-
 /****************************************/
 
 static struct platform_driver amvdec_h265_driver = {
 	.probe = amvdec_h265_probe,
 	.remove = amvdec_h265_remove,
 #ifdef CONFIG_PM
+	.suspend = amhevc_suspend,
+	.resume = amhevc_resume,
+#endif
+	.driver = {
+		.name = DRIVER_NAME,
+	}
+};
+
+#ifdef MULTI_INSTANCE_SUPPORT
+static int ammvdec_h265_probe(struct platform_device *pdev)
+{
+
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
+	struct hevc_state_s *hevc = NULL;
+#ifdef CONFIG_MULTI_DEC
+	int config_val;
+#endif
+	if (pdata == NULL) {
+		pr_info("\nammvdec_h265 memory resource undefined.\n");
+		return -EFAULT;
+	}
+
+	hevc = (struct hevc_state_s *)devm_kzalloc(&pdev->dev,
+		sizeof(struct hevc_state_s), GFP_KERNEL);
+	if (hevc == NULL) {
+		pr_info("\nammvdec_h265 device data allocation failed\n");
+		return -ENOMEM;
+	}
+	pdata->private = hevc;
+	pdata->dec_status = vh265_dec_status;
+	/* pdata->set_trickmode = set_trickmode; */
+	pdata->run_ready = run_ready;
+	pdata->run = run;
+	pdata->reset = reset;
+	pdata->irq_handler = vh265_irq_cb;
+	pdata->threaded_irq_handler = vh265_threaded_irq_cb;
+
+	pdata->id = pdev->id;
+	hevc->index = pdev->id;
+
+	if (pdata->use_vfm_path)
+		snprintf(pdata->vf_provider_name,
+		VDEC_PROVIDER_NAME_SIZE,
+			VFM_DEC_PROVIDER_NAME);
+#ifdef CONFIG_AM_VDEC_DV
+	else if (vdec_dual(pdata)) {
+		if (dv_toggle_prov_name) /*debug purpose*/
+			snprintf(pdata->vf_provider_name,
+			VDEC_PROVIDER_NAME_SIZE,
+				(pdata->master) ? VFM_DEC_DVBL_PROVIDER_NAME :
+				VFM_DEC_DVEL_PROVIDER_NAME);
+		else
+			snprintf(pdata->vf_provider_name,
+			VDEC_PROVIDER_NAME_SIZE,
+				(pdata->master) ? VFM_DEC_DVEL_PROVIDER_NAME :
+				VFM_DEC_DVBL_PROVIDER_NAME);
+		hevc->dolby_enhance_flag = pdata->master ? 1 : 0;
+	}
+#endif
+	else
+		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
+			MULTI_INSTANCE_PROVIDER_NAME ".%02x", pdev->id & 0xff);
+
+	vf_provider_init(&pdata->vframe_provider, pdata->vf_provider_name,
+		&vh265_vf_provider, pdata);
+
+	hevc->provider_name = pdata->vf_provider_name;
+	platform_set_drvdata(pdev, pdata);
+
+	hevc->platform_dev = pdev;
+	if (init_mmu_buffers(hevc) < 0) {
+		hevc_print(hevc, 0,
+			"\n 265 mmu init failed!\n");
+		mutex_unlock(&vh265_mutex);
+		devm_kfree(&pdev->dev, (void *)hevc);
+		return -EFAULT;
+	}
+#if 0
+	hevc->buf_start = pdata->mem_start;
+	hevc->buf_size = pdata->mem_end - pdata->mem_start + 1;
+#else
+
+	if (decoder_bmmu_box_alloc_idx_wait(
+		hevc->bmmu_box,
+		BMMU_WORKSPACE_ID,
+		work_buf_size,
+		-1,
+		-1,
+		BMMU_ALLOC_FLAGS_WAITCLEAR) < 0) {
+		hevc_print(hevc, 0,
+			"workbuf alloc failed, request buf size 0x%lx\n",
+				work_buf_size);
+		uninit_mmu_buffers(hevc);
+		devm_kfree(&pdev->dev, (void *)hevc);
+		return -ENOMEM;
+	}
+	hevc->buf_start = decoder_bmmu_box_get_phy_addr(
+		hevc->bmmu_box,
+		BMMU_WORKSPACE_ID);
+	hevc->buf_size = work_buf_size;
+#endif
+	if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) &&
+		(parser_sei_enable & 0x100) == 0)
+		parser_sei_enable = 1;
+	hevc->m_ins_flag = 1;
+	hevc->init_flag = 0;
+	hevc->uninit_list = 0;
+	hevc->fatal_error = 0;
+	hevc->show_frame_num = 0;
+	if (pdata == NULL) {
+		hevc_print(hevc, 0,
+			"\namvdec_h265 memory resource undefined.\n");
+		uninit_mmu_buffers(hevc);
+		devm_kfree(&pdev->dev, (void *)hevc);
+		return -EFAULT;
+	}
+	/*
+	hevc->mc_buf_spec.buf_end = pdata->mem_end + 1;
+	for (i = 0; i < WORK_BUF_SPEC_NUM; i++)
+		amvh265_workbuff_spec[i].start_adr = pdata->mem_start;
+	*/
+	if (get_dbg_flag(hevc)) {
+		hevc_print(hevc, 0,
+			"===H.265 decoder mem resource 0x%lx -- 0x%lx\n",
+			   hevc->buf_start, hevc->buf_start + hevc->buf_size);
+	}
+
+	if (((get_dbg_flag(hevc) & IGNORE_PARAM_FROM_CONFIG) == 0) &&
+			pdata->config && pdata->config_len) {
+#ifdef CONFIG_MULTI_DEC
+		/*use ptr config for doubel_write_mode, etc*/
+		hevc_print(hevc, 0, "pdata->config=%s\n", pdata->config);
+		if (get_config_int(pdata->config, "hevc_buf_width",
+				&config_val) == 0)
+			hevc->buf_alloc_width = config_val;
+		else
+			hevc->buf_alloc_width = buf_alloc_width;
+
+		if (get_config_int(pdata->config, "hevc_buf_height",
+				&config_val) == 0)
+			hevc->buf_alloc_height = config_val;
+		else
+			hevc->buf_alloc_height = buf_alloc_height;
+
+		if (get_config_int(pdata->config, "hevc_buf_margin",
+				&config_val) == 0)
+			hevc->dynamic_buf_num_margin = config_val;
+		else
+			hevc->dynamic_buf_num_margin = dynamic_buf_num_margin;
+
+		if (get_config_int(pdata->config, "hevc_double_write_mode",
+				&config_val) == 0)
+			hevc->double_write_mode = config_val;
+		else
+			hevc->double_write_mode = double_write_mode;
+#endif
+	} else {
+		hevc->vh265_amstream_dec_info.width = 0;
+		hevc->vh265_amstream_dec_info.height = 0;
+		hevc->vh265_amstream_dec_info.rate = 30;
+		hevc->buf_alloc_width = buf_alloc_width;
+		hevc->buf_alloc_height = buf_alloc_height;
+		hevc->dynamic_buf_num_margin = dynamic_buf_num_margin;
+		hevc->double_write_mode = double_write_mode;
+	}
+	hevc_print(hevc, 0,
+		"buf_alloc_width=%d\n",
+		hevc->buf_alloc_width);
+	hevc_print(hevc, 0,
+		"buf_alloc_height=%d\n",
+		hevc->buf_alloc_height);
+	hevc_print(hevc, 0,
+		"dynamic_buf_num_margin=%d\n",
+		hevc->dynamic_buf_num_margin);
+	hevc_print(hevc, 0,
+		"double_write_mode=%d\n",
+		hevc->double_write_mode);
+
+	hevc->cma_dev = pdata->cma_dev;
+
+	if (vh265_init(pdata) < 0) {
+		hevc_print(hevc, 0,
+			"\namvdec_h265 init failed.\n");
+		hevc_local_uninit(hevc);
+		uninit_mmu_buffers(hevc);
+		devm_kfree(&pdev->dev, (void *)hevc);
+		return -ENODEV;
+	}
+
+	/*set the max clk for smooth playing...*/
+	hevc_source_changed(VFORMAT_HEVC,
+			3840, 2160, 60);
+
+	return 0;
+}
+
+static int ammvdec_h265_remove(struct platform_device *pdev)
+{
+	struct hevc_state_s *hevc =
+		(struct hevc_state_s *)
+		(((struct vdec_s *)(platform_get_drvdata(pdev)))->private);
+
+	if (get_dbg_flag(hevc))
+		hevc_print(hevc, 0, "%s\r\n", __func__);
+
+	vmh265_stop(hevc);
+
+	/* vdec_source_changed(VFORMAT_H264, 0, 0, 0); */
+
+	vdec_set_status(hw_to_vdec(hevc), VDEC_STATUS_DISCONNECTED);
+
+	return 0;
+}
+
+static struct platform_driver ammvdec_h265_driver = {
+	.probe = ammvdec_h265_probe,
+	.remove = ammvdec_h265_remove,
+#ifdef CONFIG_PM
 	.suspend = amvdec_suspend,
 	.resume = amvdec_resume,
 #endif
 	.driver = {
-		.name = DRIVER_NAME,
+		.name = MULTI_DRIVER_NAME,
 	}
 };
+#endif
 
 static struct codec_profile_t amvdec_h265_profile = {
 	.name = "hevc",
@@ -6327,11 +8663,15 @@ static int __init amvdec_h265_driver_init_module(void)
 	step = 0;
 	buf_alloc_size = 0;
 
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (platform_driver_register(&ammvdec_h265_driver))
+		pr_err("failed to register ammvdec_h265 driver\n");
+
+#endif
 	if (platform_driver_register(&amvdec_h265_driver)) {
 		pr_err("failed to register amvdec_h265 driver\n");
 		return -ENODEV;
 	}
-
 #if 1/*MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8*/
 	if (!has_hevc_vdec()) {
 		/* not support hevc */
@@ -6345,7 +8685,10 @@ static int __init amvdec_h265_driver_init_module(void)
 	} else if (get_cpu_type() >= MESON_CPU_MAJOR_ID_MG9TV)
 		amvdec_h265_profile.profile = "4k";
 #endif
-
+	if (codec_mm_get_total_size() < 80 * SZ_1M) {
+		pr_info("amvdec_h265 default mmu enabled.\n");
+		mmu_enable = 1;
+	}
 
 	vcodec_profile_register(&amvdec_h265_profile);
 
@@ -6356,6 +8699,9 @@ static void __exit amvdec_h265_driver_remove_module(void)
 {
 	pr_debug("amvdec_h265 module remove.\n");
 
+#ifdef MULTI_INSTANCE_SUPPORT
+	platform_driver_unregister(&ammvdec_h265_driver);
+#endif
 	platform_driver_unregister(&amvdec_h265_driver);
 }
 
@@ -6376,9 +8722,6 @@ MODULE_PARM_DESC(bit_depth_chroma, "\n amvdec_h265 bit_depth_chroma\n");
 module_param(video_signal_type, uint, 0664);
 MODULE_PARM_DESC(video_signal_type, "\n amvdec_h265 video_signal_type\n");
 
-module_param(debug, uint, 0664);
-MODULE_PARM_DESC(debug, "\n amvdec_h265 debug\n");
-
 #ifdef ERROR_HANDLE_DEBUG
 module_param(dbg_nal_skip_flag, uint, 0664);
 MODULE_PARM_DESC(dbg_nal_skip_flag, "\n amvdec_h265 dbg_nal_skip_flag\n");
@@ -6439,44 +8782,47 @@ module_param(error_skip_nal_count, uint, 0664);
 MODULE_PARM_DESC(error_skip_nal_count,
 				 "\n amvdec_h265 error_skip_nal_count\n");
 
+module_param(debug, uint, 0664);
+MODULE_PARM_DESC(debug, "\n amvdec_h265 debug\n");
+
+module_param(debug_mask, uint, 0664);
+MODULE_PARM_DESC(debug_mask, "\n amvdec_h265 debug mask\n");
+
+module_param(buffer_mode, uint, 0664);
+MODULE_PARM_DESC(buffer_mode, "\n buffer_mode\n");
+
+module_param(double_write_mode, uint, 0664);
+MODULE_PARM_DESC(double_write_mode, "\n double_write_mode\n");
+
 module_param(buf_alloc_width, uint, 0664);
 MODULE_PARM_DESC(buf_alloc_width, "\n buf_alloc_width\n");
 
 module_param(buf_alloc_height, uint, 0664);
 MODULE_PARM_DESC(buf_alloc_height, "\n buf_alloc_height\n");
 
+module_param(dynamic_buf_num_margin, uint, 0664);
+MODULE_PARM_DESC(dynamic_buf_num_margin, "\n dynamic_buf_num_margin\n");
+
+module_param(max_buf_num, uint, 0664);
+MODULE_PARM_DESC(max_buf_num, "\n max_buf_num\n");
+
 module_param(buf_alloc_size, uint, 0664);
 MODULE_PARM_DESC(buf_alloc_size, "\n buf_alloc_size\n");
 
 module_param(re_config_pic_flag, uint, 0664);
 MODULE_PARM_DESC(re_config_pic_flag, "\n re_config_pic_flag\n");
 
-module_param(buffer_mode, uint, 0664);
-MODULE_PARM_DESC(buffer_mode, "\n buffer_mode\n");
-
 module_param(buffer_mode_dbg, uint, 0664);
 MODULE_PARM_DESC(buffer_mode_dbg, "\n buffer_mode_dbg\n");
-/*USE_BUF_BLOCK*/
-module_param(max_buf_num, uint, 0664);
-MODULE_PARM_DESC(max_buf_num, "\n max_buf_num\n");
-
-module_param(dynamic_buf_num_margin, uint, 0664);
-MODULE_PARM_DESC(dynamic_buf_num_margin, "\n dynamic_buf_num_margin\n");
-/**/
 
 module_param(mem_map_mode, uint, 0664);
 MODULE_PARM_DESC(mem_map_mode, "\n mem_map_mode\n");
 
-#ifdef SUPPORT_10BIT
-module_param(double_write_mode, uint, 0664);
-MODULE_PARM_DESC(double_write_mode, "\n double_write_mode\n");
-
 module_param(enable_mem_saving, uint, 0664);
 MODULE_PARM_DESC(enable_mem_saving, "\n enable_mem_saving\n");
 
 module_param(force_w_h, uint, 0664);
 MODULE_PARM_DESC(force_w_h, "\n force_w_h\n");
-#endif
 
 module_param(force_fps, uint, 0664);
 MODULE_PARM_DESC(force_fps, "\n force_fps\n");
@@ -6484,6 +8830,12 @@ MODULE_PARM_DESC(force_fps, "\n force_fps\n");
 module_param(max_decoding_time, uint, 0664);
 MODULE_PARM_DESC(max_decoding_time, "\n max_decoding_time\n");
 
+module_param(prefix_aux_buf_size, uint, 0664);
+MODULE_PARM_DESC(prefix_aux_buf_size, "\n prefix_aux_buf_size\n");
+
+module_param(suffix_aux_buf_size, uint, 0664);
+MODULE_PARM_DESC(suffix_aux_buf_size, "\n suffix_aux_buf_size\n");
+
 module_param(interlace_enable, uint, 0664);
 MODULE_PARM_DESC(interlace_enable, "\n interlace_enable\n");
 module_param(pts_unstable, uint, 0664);
@@ -6491,6 +8843,38 @@ MODULE_PARM_DESC(pts_unstable, "\n amvdec_h265 pts_unstable\n");
 module_param(parser_sei_enable, uint, 0664);
 MODULE_PARM_DESC(parser_sei_enable, "\n parser_sei_enable\n");
 
+#ifdef CONFIG_AM_VDEC_DV
+module_param(parser_dolby_vision_enable, uint, 0664);
+MODULE_PARM_DESC(parser_dolby_vision_enable,
+	"\n parser_dolby_vision_enable\n");
+#endif
+
+#ifdef MULTI_INSTANCE_SUPPORT
+module_param(start_decode_buf_level, uint, 0664);
+MODULE_PARM_DESC(start_decode_buf_level,
+		"\n h265 start_decode_buf_level\n");
+
+module_param(decode_timeout_val, uint, 0664);
+MODULE_PARM_DESC(decode_timeout_val,
+	"\n h265 decode_timeout_val\n");
+
+module_param_array(decode_frame_count, uint,
+	&max_decode_instance_num, 0664);
+
+module_param_array(max_process_time, uint,
+	&max_decode_instance_num, 0664);
+
+module_param_array(max_get_frame_interval,
+	uint, &max_decode_instance_num, 0664);
+
+#endif
+#ifdef CONFIG_AM_VDEC_DV
+module_param(dv_toggle_prov_name, uint, 0664);
+MODULE_PARM_DESC(dv_toggle_prov_name, "\n dv_toggle_prov_name\n");
+
+module_param(dv_debug, uint, 0664);
+MODULE_PARM_DESC(dv_debug, "\n dv_debug\n");
+#endif
 module_init(amvdec_h265_driver_init_module);
 module_exit(amvdec_h265_driver_remove_module);
 
diff --git a/drivers/amlogic/amports/video.c b/drivers/amlogic/amports/video.c
index b31f103..f8b60a5 100644
--- a/drivers/amlogic/amports/video.c
+++ b/drivers/amlogic/amports/video.c
@@ -50,12 +50,14 @@
 #include <linux/dma-contiguous.h>
 #include <linux/switch.h>
 
+
+
 #include "amports_priv.h"
+#include "video_keeper.h"
+#include "video_priv.h"
+
+
 
-#ifdef CONFIG_GE2D_KEEP_FRAME
-#include <linux/amlogic/ge2d/ge2d.h>
-#include <linux/amlogic/canvas/canvas_mgr.h>
-#endif
 #if defined(CONFIG_AM_VECM)
 #include <linux/amlogic/amvecm/amvecm.h>
 #endif
@@ -101,8 +103,10 @@ MODULE_AMLOG(LOG_LEVEL_ERROR, 0, LOG_DEFAULT_LEVEL_DESC, LOG_MASK_DESC);
 #include <linux/amlogic/amports/video_prot.h>
 #include "video.h"
 
-#include <linux/amlogic/codec_mm/codec_mm.h>
-#define MEM_NAME "video-keep"
+static u32 osd_vpp_misc;
+static u32 osd_vpp_misc_mask;
+static bool update_osd_vpp_misc;
+
 #ifdef CONFIG_GE2D_KEEP_FRAME
 /* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
 /* #include <mach/mod_gate.h> */
@@ -158,6 +162,9 @@ static struct vframe_receiver_s video4osd_vf_recv;
 
 static struct vframe_provider_s *osd_prov;
 
+static struct device *amvideo_dev;
+static struct device *amvideo_poll_dev;
+
 #define DRIVER_NAME "amvideo"
 #define MODULE_NAME "amvideo"
 #define DEVICE_NAME "amvideo"
@@ -196,7 +203,7 @@ static int video2_onoff_state = VIDEO_ENABLE_STATE_IDLE;
 #define BRIDGE_IRQ_SET() WRITE_CBUS_REG(ISA_TIMERC, 1)
 #endif
 
-#define RESERVE_CLR_FRAME
+
 
 #if 1	/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
 
@@ -411,13 +418,7 @@ static struct switch_dev video1_state_sdev = {
 };
 
 
-#define VOUT_TYPE_TOP_FIELD 0
-#define VOUT_TYPE_BOT_FIELD 1
-#define VOUT_TYPE_PROG      2
 
-#define VIDEO_DISABLE_NONE    0
-#define VIDEO_DISABLE_NORMAL  1
-#define VIDEO_DISABLE_FORNEXT 2
 
 #define MAX_ZOOM_RATIO 300
 
@@ -439,16 +440,12 @@ static int vpts_chase_counter;
 static int vpts_chase_pts_diff;
 #endif
 
-#define DEBUG_FLAG_BLACKOUT     0x1
-#define DEBUG_FLAG_PRINT_TOGGLE_FRAME 0x2
-#define DEBUG_FLAG_PRINT_RDMA                0x4
-#define DEBUG_FLAG_LOG_RDMA_LINE_MAX         0x100
-#define DEBUG_FLAG_TOGGLE_SKIP_KEEP_CURRENT  0x10000
-#define DEBUG_FLAG_TOGGLE_FRAME_PER_VSYNC    0x20000
-#define DEBUG_FLAG_RDMA_WAIT_1		     0x40000
-#define DEBUG_FLAG_VSYNC_DONONE                0x80000
-#define DEBUG_FLAG_GOFIELD_MANUL             0x100000
+/*seek values on.video_define.h*/
 static int debug_flag;
+int get_video_debug_flags(void)
+{
+	return debug_flag;
+}
 
 /* DEBUG_FLAG_BLACKOUT; */
 
@@ -458,7 +455,10 @@ static int vsync_exit_line_max;
 #ifdef CONFIG_VSYNC_RDMA
 static int vsync_rdma_line_max;
 #endif
-
+static u32 framepacking_support __nosavedata;
+static unsigned int framepacking_width = 1920;
+static unsigned int framepacking_height = 2205;
+static unsigned int framepacking_blank = 45;
 static unsigned int process_3d_type;
 static unsigned int last_process_3d_type;
 #ifdef TV_3D_FUNCTION_OPEN
@@ -492,17 +492,17 @@ const char video_dev_id[] = "amvideo-dev";
 const char video_dev_id2[] = "amvideo-dev2";
 
 int onwaitendframe = 0;
-struct video_dev_s {
-	int vpp_off;
-	int viu_off;
-};
+
 struct video_dev_s video_dev[2] = {
 	{0x1d00 - 0x1d00, 0x1a00 - 0x1a00},
 	{0x1900 - 0x1d00, 0x1e00 - 0x1a00}
 };
 
 struct video_dev_s *cur_dev = &video_dev[0];
-
+struct video_dev_s *get_video_cur_dev(void)
+{
+	return cur_dev;
+}
 static int cur_dev_idx;
 
 #ifdef CONFIG_PM
@@ -547,13 +547,16 @@ u32 get_prot_status(void)
 }
 EXPORT_SYMBOL(get_prot_status);
 #endif
-static inline ulong keep_phy_addr(unsigned long addr)
+
+/*for video related files only.*/
+void video_module_lock(void)
+{
+	mutex_lock(&video_module_mutex);
+}
+void video_module_unlock(void)
 {
-	return addr;
+	mutex_unlock(&video_module_mutex);
 }
-static int free_alloced_keep_buffer(void);
-static int alloc_keep_buffer(void);
-static int _video_set_disable(u32 val);
 
 int video_property_notify(int flag)
 {
@@ -624,7 +627,7 @@ static int enable_rdma_log_count;
 
 bool rdma_enable_pre = false;
 
-static u32 disp_canvas_index[2][6] = {
+u32 disp_canvas_index[2][6] = {
 	{
 	 DISPLAY_CANVAS_BASE_INDEX,
 	 DISPLAY_CANVAS_BASE_INDEX + 1,
@@ -666,15 +669,6 @@ static u32 disp_canvas[2];
 static u32 post_canvas;
 
 
-unsigned long keep_y_addr, keep_u_addr, keep_v_addr;
-static int keep_video_on;
-
-#define Y_BUFFER_SIZE   0x400000	/* for 1920*1088 */
-#define U_BUFFER_SIZE   0x100000	/* compatible with NV21 */
-#define V_BUFFER_SIZE   0x80000
-
-
-
 /* zoom information */
 static u32 zoom_start_x_lines;
 static u32 zoom_end_x_lines;
@@ -686,6 +680,16 @@ static u32 ori_end_x_lines;
 static u32 ori_start_y_lines;
 static u32 ori_end_y_lines;
 
+static u32 zoom2_start_x_lines;
+static u32 zoom2_end_x_lines;
+static u32 zoom2_start_y_lines;
+static u32 zoom2_end_y_lines;
+
+static u32 ori2_start_x_lines;
+static u32 ori2_end_x_lines;
+static u32 ori2_start_y_lines;
+static u32 ori2_end_y_lines;
+
 /* wide settings */
 static u32 wide_setting;
 
@@ -700,6 +704,10 @@ static u32 force_blackout;
 /* disable video */
 static u32 disable_video = VIDEO_DISABLE_NONE;
 static u32 video_enabled __nosavedata;
+u32 get_video_enabled(void)
+{
+	return video_enabled;
+}
 /* show first frame*/
 static bool show_first_frame_nosync;
 bool show_first_picture = false;
@@ -718,6 +726,24 @@ static const struct vinfo_s *vinfo;
 
 /* config */
 static struct vframe_s *cur_dispbuf;
+static struct vframe_s *cur_dispbuf2;
+void update_cur_dispbuf(void *buf)
+{
+	cur_dispbuf = buf;
+}
+int get_video0_frame_info(struct vframe_s *vf)
+{
+	unsigned long flags;
+	int ret = -1;
+	spin_lock_irqsave(&lock, flags);
+	if (is_vpp_postblend() && cur_dispbuf && vf) {
+		*vf = *cur_dispbuf;
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&lock, flags);
+	return ret;
+}
+
 static struct vframe_s vf_local;
 static u32 vsync_pts_inc;
 static u32 vsync_pts_inc_scale;
@@ -744,6 +770,9 @@ static struct vpp_frame_par_s frame_parms[2];
 /* vsync pass flag */
 static u32 wait_sync;
 
+/* is fffb or seeking*/
+static u32 video_seek_flag;
+
 #ifdef FIQ_VSYNC
 static bridge_item_t vsync_fiq_bridge;
 #endif
@@ -827,497 +856,6 @@ void safe_disble_videolayer(void)
 #endif
 }
 
-#ifdef CONFIG_GE2D_KEEP_FRAME
-static int display_canvas_y_dup;
-static int display_canvas_u_dup;
-static int display_canvas_v_dup;
-static struct ge2d_context_s *ge2d_video_context;
-static int ge2d_videotask_init(void)
-{
-	const char *keep_owner = "keepframe";
-	if (ge2d_video_context == NULL)
-		ge2d_video_context = create_ge2d_work_queue();
-
-	if (ge2d_video_context == NULL) {
-		pr_info("create_ge2d_work_queue video task failed\n");
-		return -1;
-	}
-	if (!display_canvas_y_dup)
-		display_canvas_y_dup = canvas_pool_map_alloc_canvas(keep_owner);
-	if (!display_canvas_u_dup)
-		display_canvas_u_dup = canvas_pool_map_alloc_canvas(keep_owner);
-	if (!display_canvas_v_dup)
-		display_canvas_v_dup = canvas_pool_map_alloc_canvas(keep_owner);
-	pr_info("create_ge2d_work_queue video task ok\n");
-
-	return 0;
-}
-
-static int ge2d_videotask_release(void)
-{
-	if (ge2d_video_context) {
-		destroy_ge2d_work_queue(ge2d_video_context);
-		ge2d_video_context = NULL;
-	}
-	if (display_canvas_y_dup)
-		canvas_pool_map_free_canvas(display_canvas_y_dup);
-	if (display_canvas_u_dup)
-		canvas_pool_map_free_canvas(display_canvas_u_dup);
-	if (display_canvas_v_dup)
-		canvas_pool_map_free_canvas(display_canvas_v_dup);
-
-	return 0;
-}
-
-static int ge2d_store_frame_YUV444(u32 cur_index)
-{
-	u32 y_index, des_index, src_index;
-	struct canvas_s cs, cd;
-	ulong yaddr;
-	u32 ydupindex;
-	struct config_para_ex_s ge2d_config;
-	memset(&ge2d_config, 0, sizeof(struct config_para_ex_s));
-
-	ydupindex = display_canvas_y_dup;
-
-	pr_info("ge2d_store_frame_YUV444 cur_index:s:0x%x\n", cur_index);
-	/* pr_info("ge2d_store_frame cur_index:d:0x%x\n", canvas_tab[0]); */
-	y_index = cur_index & 0xff;
-	canvas_read(y_index, &cs);
-
-	yaddr = keep_phy_addr(keep_y_addr);
-	canvas_config(ydupindex,
-		      (ulong) yaddr,
-		      cs.width, cs.height, CANVAS_ADDR_NOWRAP, cs.blkmode);
-
-	canvas_read(ydupindex, &cd);
-	src_index = y_index;
-	des_index = ydupindex;
-
-	pr_info("ge2d_canvas_dup ADDR srcy[0x%lx] des[0x%lx]\n", cs.addr,
-	       cd.addr);
-
-	ge2d_config.alu_const_color = 0;
-	ge2d_config.bitmask_en = 0;
-	ge2d_config.src1_gb_alpha = 0;
-
-	ge2d_config.src_planes[0].addr = cs.addr;
-	ge2d_config.src_planes[0].w = cs.width;
-	ge2d_config.src_planes[0].h = cs.height;
-
-	ge2d_config.dst_planes[0].addr = cd.addr;
-	ge2d_config.dst_planes[0].w = cd.width;
-	ge2d_config.dst_planes[0].h = cd.height;
-
-	ge2d_config.src_para.canvas_index = src_index;
-	ge2d_config.src_para.mem_type = CANVAS_TYPE_INVALID;
-	ge2d_config.src_para.format = GE2D_FORMAT_M24_YUV444;
-	ge2d_config.src_para.fill_color_en = 0;
-	ge2d_config.src_para.fill_mode = 0;
-	ge2d_config.src_para.color = 0;
-	ge2d_config.src_para.top = 0;
-	ge2d_config.src_para.left = 0;
-	ge2d_config.src_para.width = cs.width;
-	ge2d_config.src_para.height = cs.height;
-
-	ge2d_config.dst_para.canvas_index = des_index;
-	ge2d_config.dst_para.mem_type = CANVAS_TYPE_INVALID;
-	ge2d_config.dst_para.format = GE2D_FORMAT_M24_YUV444;
-	ge2d_config.dst_para.fill_color_en = 0;
-	ge2d_config.dst_para.fill_mode = 0;
-	ge2d_config.dst_para.color = 0;
-	ge2d_config.dst_para.top = 0;
-	ge2d_config.dst_para.left = 0;
-	ge2d_config.dst_para.width = cs.width;
-	ge2d_config.dst_para.height = cs.height;
-
-	if (ge2d_context_config_ex(ge2d_video_context, &ge2d_config) < 0) {
-		pr_info("ge2d_context_config_ex failed\n");
-		return -1;
-	}
-
-	stretchblt_noalpha(ge2d_video_context, 0, 0, cs.width, cs.height,
-			   0, 0, cs.width, cs.height);
-
-	return 0;
-}
-
-/* static u32 canvas_tab[1]; */
-static int ge2d_store_frame_NV21(u32 cur_index)
-{
-	u32 y_index, u_index, des_index, src_index;
-	struct canvas_s cs0, cs1, cd;
-	ulong yaddr, uaddr;
-	u32 ydupindex, udupindex;
-	struct config_para_ex_s ge2d_config;
-	memset(&ge2d_config, 0, sizeof(struct config_para_ex_s));
-
-	ydupindex = display_canvas_y_dup;
-	udupindex = display_canvas_u_dup;
-
-	pr_info("ge2d_store_frame_NV21 cur_index:s:0x%x\n", cur_index);
-
-	/* pr_info("ge2d_store_frame cur_index:d:0x%x\n", canvas_tab[0]); */
-	yaddr = keep_phy_addr(keep_y_addr);
-	uaddr = keep_phy_addr(keep_u_addr);
-
-	y_index = cur_index & 0xff;
-	u_index = (cur_index >> 8) & 0xff;
-
-	canvas_read(y_index, &cs0);
-	canvas_read(u_index, &cs1);
-	canvas_config(ydupindex,
-		      (ulong) yaddr,
-		      cs0.width, cs0.height, CANVAS_ADDR_NOWRAP, cs0.blkmode);
-	canvas_config(udupindex,
-		      (ulong) uaddr,
-		      cs1.width, cs1.height, CANVAS_ADDR_NOWRAP, cs1.blkmode);
-
-	canvas_read(ydupindex, &cd);
-	src_index = ((y_index & 0xff) | ((u_index << 8) & 0x0000ff00));
-	des_index = ((ydupindex & 0xff) | ((udupindex << 8) & 0x0000ff00));
-
-	pr_info("ge2d_store_frame d:0x%x\n", des_index);
-
-	ge2d_config.alu_const_color = 0;
-	ge2d_config.bitmask_en = 0;
-	ge2d_config.src1_gb_alpha = 0;
-
-	ge2d_config.src_planes[0].addr = cs0.addr;
-	ge2d_config.src_planes[0].w = cs0.width;
-	ge2d_config.src_planes[0].h = cs0.height;
-	ge2d_config.src_planes[1].addr = cs1.addr;
-	ge2d_config.src_planes[1].w = cs1.width;
-	ge2d_config.src_planes[1].h = cs1.height;
-
-	ge2d_config.dst_planes[0].addr = cd.addr;
-	ge2d_config.dst_planes[0].w = cd.width;
-	ge2d_config.dst_planes[0].h = cd.height;
-
-	ge2d_config.src_para.canvas_index = src_index;
-	ge2d_config.src_para.mem_type = CANVAS_TYPE_INVALID;
-	ge2d_config.src_para.format = GE2D_FORMAT_M24_NV21;
-	ge2d_config.src_para.fill_color_en = 0;
-	ge2d_config.src_para.fill_mode = 0;
-	ge2d_config.src_para.color = 0;
-	ge2d_config.src_para.top = 0;
-	ge2d_config.src_para.left = 0;
-	ge2d_config.src_para.width = cs0.width;
-	ge2d_config.src_para.height = cs0.height;
-
-	ge2d_config.dst_para.canvas_index = des_index;
-	ge2d_config.dst_para.mem_type = CANVAS_TYPE_INVALID;
-	ge2d_config.dst_para.format = GE2D_FORMAT_M24_NV21;
-	ge2d_config.dst_para.fill_color_en = 0;
-	ge2d_config.dst_para.fill_mode = 0;
-	ge2d_config.dst_para.color = 0;
-	ge2d_config.dst_para.top = 0;
-	ge2d_config.dst_para.left = 0;
-	ge2d_config.dst_para.width = cs0.width;
-	ge2d_config.dst_para.height = cs0.height;
-
-	if (ge2d_context_config_ex(ge2d_video_context, &ge2d_config) < 0) {
-		pr_info("ge2d_context_config_ex failed\n");
-		return -1;
-	}
-
-	stretchblt_noalpha(ge2d_video_context, 0, 0, cs0.width, cs0.height,
-			   0, 0, cs0.width, cs0.height);
-
-	return 0;
-}
-
-/* static u32 canvas_tab[1]; */
-static int ge2d_store_frame_YUV420(u32 cur_index)
-{
-	u32 y_index, u_index, v_index;
-	struct canvas_s cs, cd;
-	ulong yaddr, uaddr, vaddr;
-	u32 ydupindex, udupindex, vdupindex;
-	struct config_para_ex_s ge2d_config;
-	memset(&ge2d_config, 0, sizeof(struct config_para_ex_s));
-
-	ydupindex = display_canvas_y_dup;
-	udupindex = display_canvas_u_dup;
-	vdupindex = display_canvas_v_dup;
-
-	pr_info("ge2d_store_frame_YUV420 cur_index:s:0x%x\n", cur_index);
-	/* operation top line */
-	/* Y data */
-	ge2d_config.alu_const_color = 0;
-	ge2d_config.bitmask_en = 0;
-	ge2d_config.src1_gb_alpha = 0;
-
-	y_index = cur_index & 0xff;
-	canvas_read(y_index, &cs);
-	ge2d_config.src_planes[0].addr = cs.addr;
-	ge2d_config.src_planes[0].w = cs.width;
-	ge2d_config.src_planes[0].h = cs.height;
-	ge2d_config.src_planes[1].addr = 0;
-	ge2d_config.src_planes[1].w = 0;
-	ge2d_config.src_planes[1].h = 0;
-	ge2d_config.src_planes[2].addr = 0;
-	ge2d_config.src_planes[2].w = 0;
-	ge2d_config.src_planes[2].h = 0;
-
-	yaddr = keep_phy_addr(keep_y_addr);
-	canvas_config(ydupindex,
-		      (ulong) yaddr,
-		      cs.width, cs.height, CANVAS_ADDR_NOWRAP, cs.blkmode);
-	canvas_read(ydupindex, &cd);
-	ge2d_config.dst_planes[0].addr = cd.addr;
-	ge2d_config.dst_planes[0].w = cd.width;
-	ge2d_config.dst_planes[0].h = cd.height;
-	ge2d_config.dst_planes[1].addr = 0;
-	ge2d_config.dst_planes[1].w = 0;
-	ge2d_config.dst_planes[1].h = 0;
-	ge2d_config.dst_planes[2].addr = 0;
-	ge2d_config.dst_planes[2].w = 0;
-	ge2d_config.dst_planes[2].h = 0;
-
-	ge2d_config.src_key.key_enable = 0;
-	ge2d_config.src_key.key_mask = 0;
-	ge2d_config.src_key.key_mode = 0;
-	ge2d_config.src_key.key_color = 0;
-
-	ge2d_config.src_para.canvas_index = y_index;
-	ge2d_config.src_para.mem_type = CANVAS_TYPE_INVALID;
-	ge2d_config.src_para.format = GE2D_FMT_S8_Y;
-	ge2d_config.src_para.fill_color_en = 0;
-	ge2d_config.src_para.fill_mode = 0;
-	ge2d_config.src_para.x_rev = 0;
-	ge2d_config.src_para.y_rev = 0;
-	ge2d_config.src_para.color = 0;
-	ge2d_config.src_para.top = 0;
-	ge2d_config.src_para.left = 0;
-	ge2d_config.src_para.width = cs.width;
-	ge2d_config.src_para.height = cs.height;
-
-	ge2d_config.dst_para.canvas_index = ydupindex;
-	ge2d_config.dst_para.mem_type = CANVAS_TYPE_INVALID;
-	ge2d_config.dst_para.format = GE2D_FMT_S8_Y;
-	ge2d_config.dst_para.fill_color_en = 0;
-	ge2d_config.dst_para.fill_mode = 0;
-	ge2d_config.dst_para.x_rev = 0;
-	ge2d_config.dst_para.y_rev = 0;
-	ge2d_config.dst_xy_swap = 0;
-	ge2d_config.dst_para.color = 0;
-	ge2d_config.dst_para.top = 0;
-	ge2d_config.dst_para.left = 0;
-	ge2d_config.dst_para.width = cs.width;
-	ge2d_config.dst_para.height = cs.height;
-
-	if (ge2d_context_config_ex(ge2d_video_context, &ge2d_config) < 0) {
-		pr_info("++ge2d configing error.\n");
-		return -1;
-	}
-	stretchblt_noalpha(ge2d_video_context, 0, 0, cs.width, cs.height, 0, 0,
-			   cs.width, cs.height);
-
-	/* U data */
-	ge2d_config.alu_const_color = 0;
-	ge2d_config.bitmask_en = 0;
-	ge2d_config.src1_gb_alpha = 0;
-
-	u_index = (cur_index >> 8) & 0xff;
-	canvas_read(u_index, &cs);
-	ge2d_config.src_planes[0].addr = cs.addr;
-	ge2d_config.src_planes[0].w = cs.width;
-	ge2d_config.src_planes[0].h = cs.height;
-	ge2d_config.src_planes[1].addr = 0;
-	ge2d_config.src_planes[1].w = 0;
-	ge2d_config.src_planes[1].h = 0;
-	ge2d_config.src_planes[2].addr = 0;
-	ge2d_config.src_planes[2].w = 0;
-	ge2d_config.src_planes[2].h = 0;
-
-	uaddr = keep_phy_addr(keep_u_addr);
-	canvas_config(udupindex,
-		      (ulong) uaddr,
-		      cs.width, cs.height, CANVAS_ADDR_NOWRAP, cs.blkmode);
-	canvas_read(udupindex, &cd);
-	ge2d_config.dst_planes[0].addr = cd.addr;
-	ge2d_config.dst_planes[0].w = cd.width;
-	ge2d_config.dst_planes[0].h = cd.height;
-	ge2d_config.dst_planes[1].addr = 0;
-	ge2d_config.dst_planes[1].w = 0;
-	ge2d_config.dst_planes[1].h = 0;
-	ge2d_config.dst_planes[2].addr = 0;
-	ge2d_config.dst_planes[2].w = 0;
-	ge2d_config.dst_planes[2].h = 0;
-
-	ge2d_config.src_key.key_enable = 0;
-	ge2d_config.src_key.key_mask = 0;
-	ge2d_config.src_key.key_mode = 0;
-	ge2d_config.src_key.key_color = 0;
-
-	ge2d_config.src_para.canvas_index = u_index;
-	ge2d_config.src_para.mem_type = CANVAS_TYPE_INVALID;
-	ge2d_config.src_para.format = GE2D_FMT_S8_CB;
-	ge2d_config.src_para.fill_color_en = 0;
-	ge2d_config.src_para.fill_mode = 0;
-	ge2d_config.src_para.x_rev = 0;
-	ge2d_config.src_para.y_rev = 0;
-	ge2d_config.src_para.color = 0;
-	ge2d_config.src_para.top = 0;
-	ge2d_config.src_para.left = 0;
-	ge2d_config.src_para.width = cs.width;
-	ge2d_config.src_para.height = cs.height;
-
-	ge2d_config.dst_para.canvas_index = udupindex;
-	ge2d_config.dst_para.mem_type = CANVAS_TYPE_INVALID;
-	ge2d_config.dst_para.format = GE2D_FMT_S8_CB;
-	ge2d_config.dst_para.fill_color_en = 0;
-	ge2d_config.dst_para.fill_mode = 0;
-	ge2d_config.dst_para.x_rev = 0;
-	ge2d_config.dst_para.y_rev = 0;
-	ge2d_config.dst_xy_swap = 0;
-	ge2d_config.dst_para.color = 0;
-	ge2d_config.dst_para.top = 0;
-	ge2d_config.dst_para.left = 0;
-	ge2d_config.dst_para.width = cs.width;
-	ge2d_config.dst_para.height = cs.height;
-
-	if (ge2d_context_config_ex(ge2d_video_context, &ge2d_config) < 0) {
-		pr_info("++ge2d configing error.\n");
-		return -1;
-	}
-	stretchblt_noalpha(ge2d_video_context, 0, 0, cs.width, cs.height, 0, 0,
-			   cs.width, cs.height);
-
-	/* operation top line */
-	/* V data */
-	ge2d_config.alu_const_color = 0;
-	ge2d_config.bitmask_en = 0;
-	ge2d_config.src1_gb_alpha = 0;
-
-	v_index = (cur_index >> 16) & 0xff;
-	canvas_read(v_index, &cs);
-	ge2d_config.src_planes[0].addr = cs.addr;
-	ge2d_config.src_planes[0].w = cs.width;
-	ge2d_config.src_planes[0].h = cs.height;
-	ge2d_config.src_planes[1].addr = 0;
-	ge2d_config.src_planes[1].w = 0;
-	ge2d_config.src_planes[1].h = 0;
-	ge2d_config.src_planes[2].addr = 0;
-	ge2d_config.src_planes[2].w = 0;
-	ge2d_config.src_planes[2].h = 0;
-
-	vaddr = keep_phy_addr(keep_v_addr);
-	canvas_config(vdupindex,
-		      (ulong) vaddr,
-		      cs.width, cs.height, CANVAS_ADDR_NOWRAP, cs.blkmode);
-	ge2d_config.dst_planes[0].addr = cd.addr;
-	ge2d_config.dst_planes[0].w = cd.width;
-	ge2d_config.dst_planes[0].h = cd.height;
-	ge2d_config.dst_planes[1].addr = 0;
-	ge2d_config.dst_planes[1].w = 0;
-	ge2d_config.dst_planes[1].h = 0;
-	ge2d_config.dst_planes[2].addr = 0;
-	ge2d_config.dst_planes[2].w = 0;
-	ge2d_config.dst_planes[2].h = 0;
-
-	ge2d_config.src_key.key_enable = 0;
-	ge2d_config.src_key.key_mask = 0;
-	ge2d_config.src_key.key_mode = 0;
-	ge2d_config.src_key.key_color = 0;
-
-	ge2d_config.src_para.canvas_index = v_index;
-	ge2d_config.src_para.mem_type = CANVAS_TYPE_INVALID;
-	ge2d_config.src_para.format = GE2D_FMT_S8_CR;
-	ge2d_config.src_para.fill_color_en = 0;
-	ge2d_config.src_para.fill_mode = 0;
-	ge2d_config.src_para.x_rev = 0;
-	ge2d_config.src_para.y_rev = 0;
-	ge2d_config.src_para.color = 0;
-	ge2d_config.src_para.top = 0;
-	ge2d_config.src_para.left = 0;
-	ge2d_config.src_para.width = cs.width;
-	ge2d_config.src_para.height = cs.height;
-
-	ge2d_config.dst_para.canvas_index = vdupindex;
-	ge2d_config.dst_para.mem_type = CANVAS_TYPE_INVALID;
-	ge2d_config.dst_para.format = GE2D_FMT_S8_CR;
-	ge2d_config.dst_para.fill_color_en = 0;
-	ge2d_config.dst_para.fill_mode = 0;
-	ge2d_config.dst_para.x_rev = 0;
-	ge2d_config.dst_para.y_rev = 0;
-	ge2d_config.dst_xy_swap = 0;
-	ge2d_config.dst_para.color = 0;
-	ge2d_config.dst_para.top = 0;
-	ge2d_config.dst_para.left = 0;
-	ge2d_config.dst_para.width = cs.width;
-	ge2d_config.dst_para.height = cs.height;
-
-	if (ge2d_context_config_ex(ge2d_video_context, &ge2d_config) < 0) {
-		pr_info("++ge2d configing error.\n");
-		return -1;
-	}
-	stretchblt_noalpha(ge2d_video_context, 0, 0, cs.width, cs.height, 0, 0,
-			   cs.width, cs.height);
-	return 0;
-}
-
-static void ge2d_keeplastframe_block(int cur_index, int format)
-{
-	/* u32 cur_index; */
-	u32 y_index, u_index, v_index;
-#ifdef CONFIG_VSYNC_RDMA
-	u32 y_index2, u_index2, v_index2;
-#endif
-
-	mutex_lock(&video_module_mutex);
-
-#ifdef CONFIG_VSYNC_RDMA
-	y_index = disp_canvas_index[0][0];
-	y_index2 = disp_canvas_index[1][0];
-	u_index = disp_canvas_index[0][1];
-	u_index2 = disp_canvas_index[1][1];
-	v_index = disp_canvas_index[0][2];
-	v_index2 = disp_canvas_index[1][2];
-#else
-	/* cur_index = READ_VCBUS_REG(VD1_IF0_CANVAS0 + cur_dev->viu_off); */
-	y_index = cur_index & 0xff;
-	u_index = (cur_index >> 8) & 0xff;
-	v_index = (cur_index >> 16) & 0xff;
-#endif
-
-	switch (format) {
-	case GE2D_FORMAT_M24_YUV444:
-		ge2d_store_frame_YUV444(cur_index);
-		canvas_update_addr(y_index, keep_phy_addr(keep_y_addr));
-#ifdef CONFIG_VSYNC_RDMA
-		canvas_update_addr(y_index2, keep_phy_addr(keep_y_addr));
-#endif
-		break;
-	case GE2D_FORMAT_M24_NV21:
-		ge2d_store_frame_NV21(cur_index);
-		canvas_update_addr(y_index, keep_phy_addr(keep_y_addr));
-		canvas_update_addr(u_index, keep_phy_addr(keep_u_addr));
-#ifdef CONFIG_VSYNC_RDMA
-		canvas_update_addr(y_index2, keep_phy_addr(keep_y_addr));
-		canvas_update_addr(u_index2, keep_phy_addr(keep_u_addr));
-#endif
-		break;
-	case GE2D_FORMAT_M24_YUV420:
-		ge2d_store_frame_YUV420(cur_index);
-		canvas_update_addr(y_index, keep_phy_addr(keep_y_addr));
-		canvas_update_addr(u_index, keep_phy_addr(keep_u_addr));
-		canvas_update_addr(v_index, keep_phy_addr(keep_v_addr));
-#ifdef CONFIG_VSYNC_RDMA
-		canvas_update_addr(y_index2, keep_phy_addr(keep_y_addr));
-		canvas_update_addr(u_index2, keep_phy_addr(keep_u_addr));
-		canvas_update_addr(v_index2, keep_phy_addr(keep_v_addr));
-#endif
-		break;
-	default:
-		break;
-	}
-	mutex_unlock(&video_module_mutex);
-
-}
-
-#endif
 
 /*********************************************************/
 static inline struct vframe_s *video_vf_peek(void)
@@ -1334,7 +872,11 @@ static inline struct vframe_s *video_vf_get(void)
 		video_notify_flag |= VIDEO_NOTIFY_PROVIDER_GET;
 		atomic_set(&vf->use_cnt, 1);
 		/*always to 1,for first get from vfm provider */
-
+		if ((vf->type & VIDTYPE_MVC) && (framepacking_support)
+		&&(framepacking_width) && (framepacking_height)) {
+			vf->width = framepacking_width;
+			vf->height = framepacking_height;
+		}
 #ifdef TV_3D_FUNCTION_OPEN
 		/*can be moved to h264mvc.c */
 		if ((vf->type & VIDTYPE_MVC)
@@ -1346,7 +888,8 @@ static inline struct vframe_s *video_vf_get(void)
 			process_3d_type &= (~MODE_3D_MVC);
 			mvc_flag = 0;
 		}
-		if ((process_3d_type & MODE_FORCE_3D_TO_2D_LR)
+		if (((process_3d_type & MODE_FORCE_3D_TO_2D_LR)
+		|| (process_3d_type & MODE_FORCE_3D_LR))
 		&& (!(vf->type & VIDTYPE_MVC))) {
 			vf->trans_fmt = TVIN_TFMT_3D_DET_LR;
 			vf->left_eye.start_x = 0;
@@ -1358,7 +901,8 @@ static inline struct vframe_s *video_vf_get(void)
 			vf->right_eye.start_y = 0;
 			vf->right_eye.width = vf->width / 2;
 		}
-		if ((process_3d_type & MODE_FORCE_3D_TO_2D_TB)
+		if (((process_3d_type & MODE_FORCE_3D_TO_2D_TB)
+		|| (process_3d_type & MODE_FORCE_3D_TB))
 		&& (!(vf->type & VIDTYPE_MVC))) {
 			vf->trans_fmt = TVIN_TFMT_3D_TB;
 			vf->left_eye.start_x = 0;
@@ -1396,6 +940,8 @@ static inline void video_vf_put(struct vframe_s *vf)
 	struct vframe_provider_s *vfp = vf_get_provider(RECEIVER_NAME);
 	if (vfp && atomic_dec_and_test(&vf->use_cnt)) {
 		vf_put(vf, RECEIVER_NAME);
+		if (is_dolby_vision_enable())
+			dolby_vision_vf_put(vf);
 		video_notify_flag |= VIDEO_NOTIFY_PROVIDER_PUT;
 	}
 }
@@ -1409,6 +955,7 @@ int ext_get_cur_video_frame(struct vframe_s **vf, int *canvas_index)
 	*vf = cur_dispbuf;
 	return 0;
 }
+#ifdef CONFIG_AM_VIDEOCAPTURE
 
 int ext_put_video_frame(struct vframe_s *vf)
 {
@@ -1417,6 +964,16 @@ int ext_put_video_frame(struct vframe_s *vf)
 	video_vf_put(vf);
 	return 0;
 }
+int is_need_framepacking_output(void)
+{
+	int ret = 0;
+	if ((framepacking_support) &&
+	(cur_dispbuf) && (cur_dispbuf->type & VIDTYPE_MVC)) {
+		ret = 1;
+	}
+	return ret;
+}
+
 
 int ext_register_end_frame_callback(struct amvideocap_req *req)
 {
@@ -1425,9 +982,7 @@ int ext_register_end_frame_callback(struct amvideocap_req *req)
 	mutex_unlock(&video_module_mutex);
 	return 0;
 }
-
-#ifdef CONFIG_AM_VIDEOCAPTURE
-static int ext_frame_capture_poll(int endflags)
+int ext_frame_capture_poll(int endflags)
 {
 	mutex_lock(&video_module_mutex);
 	if (capture_frame_req && capture_frame_req->callback) {
@@ -1445,6 +1000,8 @@ static int ext_frame_capture_poll(int endflags)
 	return 0;
 }
 #endif
+
+
 static void vpp_settings_h(struct vpp_frame_par_s *framePtr)
 {
 	struct vppfilter_mode_s *vpp_filter = &framePtr->vpp_filter;
@@ -1551,11 +1108,34 @@ static void vpp_settings_h(struct vpp_frame_par_s *framePtr)
 			framePtr->VPP_line_in_length_);
 }
 
+
+static void vd2_settings_h(struct vframe_s *vf)
+{
+	u32 VPP_hd_start_lines_;
+	u32 VPP_hd_end_lines_;
+
+	if (vf) {
+		VPP_hd_start_lines_ = 0;
+		VPP_hd_end_lines_ = ((vf->type & VIDTYPE_COMPRESS) ?
+		vf->compWidth : vf->width) - 1;
+		VSYNC_WR_MPEG_REG(VPP_BLEND_VD2_H_START_END +
+		cur_dev->vpp_off,
+		((VPP_hd_start_lines_ &
+		VPP_VD_SIZE_MASK) << VPP_VD1_START_BIT) |
+		((VPP_hd_end_lines_ &
+		VPP_VD_SIZE_MASK) << VPP_VD1_END_BIT));
+	}
+}
+
+
 static void vpp_settings_v(struct vpp_frame_par_s *framePtr)
 {
 	struct vppfilter_mode_s *vpp_filter = &framePtr->vpp_filter;
 	u32 r, afbc_enble_flag;
 	u32 y_lines;
+	u32 v_phase;
+	u32 v_skip_flag = 0;
+	int x, y, w, h;
 	r = framePtr->VPP_vsc_endp - framePtr->VPP_vsc_startp;
 	afbc_enble_flag = 0;
 	if (is_meson_gxbb_cpu())
@@ -1567,12 +1147,34 @@ static void vpp_settings_v(struct vpp_frame_par_s *framePtr)
 			VPP_VD_SIZE_MASK) << VPP_VD1_START_BIT)
 			| (((framePtr->VPP_vsc_endp + 1) & VPP_VD_SIZE_MASK) <<
 			VPP_VD1_END_BIT));
-	else
-		VSYNC_WR_MPEG_REG(VPP_POSTBLEND_VD1_V_START_END +
+	else {
+		afbc_enble_flag = READ_VCBUS_REG(AFBC_ENABLE) & 0x100;
+		v_phase = vpp_filter->vpp_vsc_start_phase_step;
+		vpp_get_video_layer_position(&x, &y, &w, &h);
+		if (v_phase * (framePtr->vscale_skip_count + 1) > 0x1000000) {
+			if ((afbc_enble_flag) && (y < 0)) {
+				if ((framePtr->VPP_vsc_endp < 0x250) ||
+				(framePtr->VPP_vsc_endp <
+				framePtr->VPP_post_blend_vd_v_end_/2)) {
+					if (framePtr->VPP_vsc_endp > 0x6)
+						v_skip_flag = 1;
+				}
+			}
+		}
+		if (v_skip_flag == 1) {
+			VSYNC_WR_MPEG_REG(VPP_POSTBLEND_VD1_V_START_END +
+			cur_dev->vpp_off, ((framePtr->VPP_vsc_startp &
+			VPP_VD_SIZE_MASK) << VPP_VD1_START_BIT)
+			| (((framePtr->VPP_vsc_endp - 6) & VPP_VD_SIZE_MASK) <<
+			VPP_VD1_END_BIT));
+		} else {
+			VSYNC_WR_MPEG_REG(VPP_POSTBLEND_VD1_V_START_END +
 			cur_dev->vpp_off, ((framePtr->VPP_vsc_startp &
 			VPP_VD_SIZE_MASK) << VPP_VD1_START_BIT)
 			| ((framePtr->VPP_vsc_endp & VPP_VD_SIZE_MASK) <<
 			VPP_VD1_END_BIT));
+		}
+	}
 
 	if (platform_type == 1) {
 		y_lines = zoom_end_y_lines / (framePtr->vscale_skip_count + 1);
@@ -1618,12 +1220,23 @@ static void vpp_settings_v(struct vpp_frame_par_s *framePtr)
 				VPP_VD_SIZE_MASK) <<
 				VPP_VD1_END_BIT));
 			}
-			VSYNC_WR_MPEG_REG(VPP_BLEND_VD2_V_START_END +
-			cur_dev->vpp_off,
-			(((framePtr->VPP_vd_end_lines_ / 2) &
-			VPP_VD_SIZE_MASK) << VPP_VD1_START_BIT) |
-			(((framePtr->VPP_vd_end_lines_) &
-			VPP_VD_SIZE_MASK) << VPP_VD1_END_BIT));
+			if (is_need_framepacking_output()) {
+				VSYNC_WR_MPEG_REG(VPP_BLEND_VD2_V_START_END +
+				cur_dev->vpp_off,
+				(((((framePtr->VPP_vd_end_lines_ -
+			framepacking_blank + 1) / 2) + framepacking_blank) &
+				VPP_VD_SIZE_MASK) << VPP_VD1_START_BIT) |
+				(((framePtr->VPP_vd_end_lines_) &
+				VPP_VD_SIZE_MASK) << VPP_VD1_END_BIT));
+			} else {
+				VSYNC_WR_MPEG_REG(VPP_BLEND_VD2_V_START_END +
+				cur_dev->vpp_off,
+				((((framePtr->VPP_vd_end_lines_ + 1) / 2) &
+				VPP_VD_SIZE_MASK) << VPP_VD1_START_BIT) |
+				(((framePtr->VPP_vd_end_lines_) &
+				VPP_VD_SIZE_MASK) << VPP_VD1_END_BIT));
+			}
+
 		}
 	} else {
 			if ((framePtr->VPP_post_blend_vd_v_end_ -
@@ -1646,12 +1259,23 @@ static void vpp_settings_v(struct vpp_frame_par_s *framePtr)
 					VPP_VD_SIZE_MASK) <<
 					VPP_VD1_END_BIT));
 			}
-			VSYNC_WR_MPEG_REG(VPP_BLEND_VD2_V_START_END +
-			cur_dev->vpp_off,
-			((((framePtr->VPP_vd_end_lines_ + 1) / 2) &
-			VPP_VD_SIZE_MASK) << VPP_VD1_START_BIT) |
-			(((framePtr->VPP_vd_end_lines_) &
-			VPP_VD_SIZE_MASK) << VPP_VD1_END_BIT));
+			if (is_need_framepacking_output()) {
+				VSYNC_WR_MPEG_REG(VPP_BLEND_VD2_V_START_END +
+				cur_dev->vpp_off,
+				(((((framePtr->VPP_vd_end_lines_ -
+			framepacking_blank + 1) / 2) + framepacking_blank) &
+				VPP_VD_SIZE_MASK) << VPP_VD1_START_BIT) |
+				(((framePtr->VPP_vd_end_lines_) &
+				VPP_VD_SIZE_MASK) << VPP_VD1_END_BIT));
+			} else {
+				VSYNC_WR_MPEG_REG(VPP_BLEND_VD2_V_START_END +
+				cur_dev->vpp_off,
+				((((framePtr->VPP_vd_end_lines_ + 1) / 2) &
+				VPP_VD_SIZE_MASK) << VPP_VD1_START_BIT) |
+				(((framePtr->VPP_vd_end_lines_) &
+				VPP_VD_SIZE_MASK) << VPP_VD1_END_BIT));
+			}
+
 	}
 	VSYNC_WR_MPEG_REG(VPP_VSC_REGION12_STARTP + cur_dev->vpp_off, 0);
 	VSYNC_WR_MPEG_REG(VPP_VSC_REGION34_STARTP + cur_dev->vpp_off,
@@ -1668,6 +1292,26 @@ static void vpp_settings_v(struct vpp_frame_par_s *framePtr)
 			vpp_filter->vpp_vsc_start_phase_step);
 }
 
+
+static void vd2_settings_v(struct vframe_s *vf)
+{
+	u32 VPP_vd_start_lines_;
+	u32 VPP_vd_end_lines_;
+
+	if (vf) {
+		VPP_vd_start_lines_ = 0;
+		VPP_vd_end_lines_ = ((vf->type & VIDTYPE_COMPRESS) ?
+			vf->compHeight : vf->height) - 1;
+
+		VSYNC_WR_MPEG_REG(VPP_BLEND_VD2_V_START_END +
+			cur_dev->vpp_off,
+			((VPP_vd_start_lines_ &
+			VPP_VD_SIZE_MASK) << VPP_VD1_START_BIT) |
+			(((VPP_vd_end_lines_) &
+			VPP_VD_SIZE_MASK) << VPP_VD1_END_BIT));
+	}
+}
+
 #ifdef TV_3D_FUNCTION_OPEN
 
 static void zoom_get_horz_pos(struct vframe_s *vf, u32 vpp_3d_mode, u32 *ls,
@@ -1944,6 +1588,79 @@ static void zoom_display_horz(int hscale)
 			     1) >> hscale) << VD1_FMT_CHROMA_WIDTH_BIT));
 }
 
+static void vd2_zoom_display_horz(int hscale)
+{
+	u32 ls, le, rs, re;
+	int content_w, content_l, content_r;
+
+	ls = rs = zoom2_start_x_lines;
+	le = re = zoom2_end_x_lines;
+
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
+		int l_aligned;
+		int r_aligned;
+		if ((zoom2_start_x_lines > 0) ||
+		(zoom2_end_x_lines < ori2_end_x_lines)) {
+			l_aligned = round_down(ori2_start_x_lines, 32);
+			r_aligned = round_up(ori2_end_x_lines + 1, 32);
+		} else {
+			l_aligned = round_down(ori2_start_x_lines, 32);
+			r_aligned = round_up(ori2_end_x_lines + 1, 32);
+		}
+		VSYNC_WR_MPEG_REG(VD2_AFBC_VD_CFMT_W,
+			  ((r_aligned - l_aligned) << 16) |
+			  (r_aligned / 2 - l_aligned / 2));
+		VSYNC_WR_MPEG_REG(VD2_AFBC_MIF_HOR_SCOPE,
+			  ((l_aligned / 32) << 16) |
+			  ((r_aligned / 32) - 1));
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
+			VSYNC_WR_MPEG_REG(VD2_AFBC_SIZE_OUT,
+				(VSYNC_RD_MPEG_REG(VD2_AFBC_SIZE_OUT) &
+				0xffff) | ((r_aligned - l_aligned) << 16));
+		}
+#ifdef TV_REVERSE
+		if (reverse) {
+			content_w = zoom2_end_x_lines - zoom2_start_x_lines + 1;
+			content_l = (r_aligned - zoom2_end_x_lines - 1) +
+			(zoom2_start_x_lines - l_aligned);
+			content_r = content_l + content_w - 1;
+			VSYNC_WR_MPEG_REG(VD2_AFBC_PIXEL_HOR_SCOPE,
+				  (content_l << 16) | content_r);
+		} else
+#endif
+		{
+			VSYNC_WR_MPEG_REG(VD2_AFBC_PIXEL_HOR_SCOPE,
+				  ((zoom2_start_x_lines - l_aligned) << 16) |
+				  (zoom2_end_x_lines - l_aligned));
+		}
+		VSYNC_WR_MPEG_REG(VD2_AFBC_SIZE_IN,
+			 (VSYNC_RD_MPEG_REG(VD2_AFBC_SIZE_IN) & 0xffff) |
+			 ((r_aligned - l_aligned) << 16));
+	}
+
+	VSYNC_WR_MPEG_REG(VD2_IF0_LUMA_X0,
+			  (ls << VDIF_PIC_START_BIT) |
+			  (le << VDIF_PIC_END_BIT));
+
+	VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA_X0,
+			  (ls / 2 << VDIF_PIC_START_BIT) |
+			  (le / 2 << VDIF_PIC_END_BIT));
+
+	VSYNC_WR_MPEG_REG(VD2_IF0_LUMA_X1,
+			  (rs << VDIF_PIC_START_BIT) |
+			  (re << VDIF_PIC_END_BIT));
+
+	VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA_X1,
+			  (rs / 2 << VDIF_PIC_START_BIT) |
+			  (re / 2 << VDIF_PIC_END_BIT));
+
+	VSYNC_WR_MPEG_REG(VIU_VD2_FMT_W + cur_dev->viu_off,
+			  (((zoom2_end_x_lines - zoom2_start_x_lines +
+			     1) >> hscale) << VD1_FMT_LUMA_WIDTH_BIT) |
+			  (((zoom2_end_x_lines / 2 - zoom2_start_x_lines / 2 +
+			     1) >> hscale) << VD1_FMT_CHROMA_WIDTH_BIT));
+}
+
 static void zoom_display_vert(void)
 {
 
@@ -1969,21 +1686,39 @@ static void zoom_display_vert(void)
 	}
 
 	if ((cur_dispbuf) && (cur_dispbuf->type & VIDTYPE_MVC)) {
-		VSYNC_WR_MPEG_REG(VD1_IF0_LUMA_Y0 + cur_dev->viu_off,
-				(ls * 2 << VDIF_PIC_START_BIT) |
-				((le * 2 - 1) << VDIF_PIC_END_BIT));
+		if (is_need_framepacking_output()) {
+			VSYNC_WR_MPEG_REG(VD1_IF0_LUMA_Y0,
+					(ls << VDIF_PIC_START_BIT) |
+					(le << VDIF_PIC_END_BIT));
 
-		VSYNC_WR_MPEG_REG(VD1_IF0_CHROMA_Y0 + cur_dev->viu_off,
-				((ls) << VDIF_PIC_START_BIT) |
-				((le - 1) << VDIF_PIC_END_BIT));
+			VSYNC_WR_MPEG_REG(VD1_IF0_CHROMA_Y0,
+					((ls / 2) << VDIF_PIC_START_BIT) |
+					((le / 2) << VDIF_PIC_END_BIT));
+
+			VSYNC_WR_MPEG_REG(VD2_IF0_LUMA_Y0,
+					(rs << VDIF_PIC_START_BIT) |
+					(re << VDIF_PIC_END_BIT));
+
+			VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA_Y0,
+					((rs / 2) << VDIF_PIC_START_BIT) |
+					((re / 2) << VDIF_PIC_END_BIT));
+		} else {
+			VSYNC_WR_MPEG_REG(VD1_IF0_LUMA_Y0 + cur_dev->viu_off,
+					(ls * 2 << VDIF_PIC_START_BIT) |
+					((le * 2 - 1) << VDIF_PIC_END_BIT));
+
+			VSYNC_WR_MPEG_REG(VD1_IF0_CHROMA_Y0 + cur_dev->viu_off,
+					((ls) << VDIF_PIC_START_BIT) |
+					((le - 1) << VDIF_PIC_END_BIT));
 
-		VSYNC_WR_MPEG_REG(VD2_IF0_LUMA_Y0,
-				(ls * 2 << VDIF_PIC_START_BIT) |
-				((le * 2 - 1) << VDIF_PIC_END_BIT));
+			VSYNC_WR_MPEG_REG(VD2_IF0_LUMA_Y0,
+					(ls * 2 << VDIF_PIC_START_BIT) |
+					((le * 2 - 1) << VDIF_PIC_END_BIT));
 
-		VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA_Y0,
-				((ls) << VDIF_PIC_START_BIT) |
-				((le - 1) << VDIF_PIC_END_BIT));
+			VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA_Y0,
+					((ls) << VDIF_PIC_START_BIT) |
+					((le - 1) << VDIF_PIC_END_BIT));
+		}
 	} else {
 		VSYNC_WR_MPEG_REG(VD1_IF0_LUMA_Y0 + cur_dev->viu_off,
 				(ls << VDIF_PIC_START_BIT) |
@@ -2023,14 +1758,8 @@ static void zoom_display_vert(void)
 	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
 		int t_aligned;
 		int b_aligned;
-		if ((zoom_start_y_lines > 0) ||
-		(zoom_end_y_lines < ori_end_y_lines)) {
-			t_aligned = round_down(ori_start_y_lines, 4);
-			b_aligned = round_up(ori_end_y_lines + 1, 4);
-		} else {
-			t_aligned = round_down(zoom_start_y_lines, 4);
-			b_aligned = round_up(zoom_end_y_lines + 1, 4);
-		}
+		t_aligned = round_down(zoom_start_y_lines, 4);
+		b_aligned = round_up(zoom_end_y_lines + 1, 4);
 		VSYNC_WR_MPEG_REG(AFBC_VD_CFMT_H,
 		    b_aligned - t_aligned);
 
@@ -2047,24 +1776,78 @@ static void zoom_display_vert(void)
 		(b_aligned - t_aligned));
 	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
 			VSYNC_WR_MPEG_REG(AFBC_SIZE_OUT,
-				(VSYNC_RD_MPEG_REG(AFBC_SIZE_OUT) & 0xffff0000)
-				| (b_aligned - t_aligned));
+				(VSYNC_RD_MPEG_REG(AFBC_SIZE_OUT) &
+				0xffff0000) | (b_aligned - t_aligned));
 		}
 	}
 }
 
-#ifdef TV_3D_FUNCTION_OPEN
-/* judge the out mode is 240:LBRBLRBR  or 120:LRLRLR */
-static void judge_3d_fa_out_mode(void)
+static void vd2_zoom_display_vert(void)
 {
-	if ((process_3d_type & MODE_3D_OUT_FA_MASK)
-	    && pause_one_3d_fl_frame == 2)
-		toggle_3d_fa_frame = OUT_FA_B_FRAME;
-	else if ((process_3d_type & MODE_3D_OUT_FA_MASK)
-		 && pause_one_3d_fl_frame == 1)
-		toggle_3d_fa_frame = OUT_FA_A_FRAME;
-	else if ((process_3d_type & MODE_3D_OUT_FA_MASK)
-		 && pause_one_3d_fl_frame == 0) {
+
+	u32 ls, le, rs, re;
+
+	ls = rs = zoom2_start_x_lines;
+	le = re = zoom2_end_x_lines;
+
+	/* vd2 */
+	VSYNC_WR_MPEG_REG(VD2_IF0_LUMA_Y0,
+			(ls << VDIF_PIC_START_BIT) |
+			(le << VDIF_PIC_END_BIT));
+
+	VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA_Y0,
+			((ls / 2) << VDIF_PIC_START_BIT) |
+			((le / 2) << VDIF_PIC_END_BIT));
+
+	VSYNC_WR_MPEG_REG(VD2_IF0_LUMA_Y1,
+			(rs << VDIF_PIC_START_BIT) |
+			(re << VDIF_PIC_END_BIT));
+
+	VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA_Y1,
+			((rs / 2) << VDIF_PIC_START_BIT) |
+			((re / 2) << VDIF_PIC_END_BIT));
+
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
+		int t_aligned;
+		int b_aligned;
+
+		t_aligned = round_down(zoom2_start_y_lines, 4);
+		b_aligned = round_up(zoom2_end_y_lines + 1, 4);
+
+		VSYNC_WR_MPEG_REG(VD2_AFBC_VD_CFMT_H,
+		    b_aligned - t_aligned);
+
+		VSYNC_WR_MPEG_REG(VD2_AFBC_MIF_VER_SCOPE,
+		    ((t_aligned / 4) << 16) |
+		    ((b_aligned / 4) - 1));
+
+		VSYNC_WR_MPEG_REG(VD2_AFBC_PIXEL_VER_SCOPE,
+		    ((zoom2_start_y_lines - t_aligned) << 16) |
+		    (zoom2_end_y_lines - t_aligned));
+
+		VSYNC_WR_MPEG_REG(VD2_AFBC_SIZE_IN,
+			(VSYNC_RD_MPEG_REG(VD2_AFBC_SIZE_IN) & 0xffff0000) |
+			(b_aligned - t_aligned));
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
+			VSYNC_WR_MPEG_REG(VD2_AFBC_SIZE_OUT,
+			(VSYNC_RD_MPEG_REG(VD2_AFBC_SIZE_OUT) & 0xffff0000)
+			| (b_aligned - t_aligned));
+		}
+	}
+}
+
+#ifdef TV_3D_FUNCTION_OPEN
+/* judge the out mode is 240:LBRBLRBR  or 120:LRLRLR */
+static void judge_3d_fa_out_mode(void)
+{
+	if ((process_3d_type & MODE_3D_OUT_FA_MASK)
+	    && pause_one_3d_fl_frame == 2)
+		toggle_3d_fa_frame = OUT_FA_B_FRAME;
+	else if ((process_3d_type & MODE_3D_OUT_FA_MASK)
+		 && pause_one_3d_fl_frame == 1)
+		toggle_3d_fa_frame = OUT_FA_A_FRAME;
+	else if ((process_3d_type & MODE_3D_OUT_FA_MASK)
+		 && pause_one_3d_fl_frame == 0) {
 		/* toggle_3d_fa_frame  determine
 		the out frame is L or R or blank */
 		if ((process_3d_type & MODE_3D_OUT_FA_L_FIRST)) {
@@ -2098,6 +1881,17 @@ static void judge_3d_fa_out_mode(void)
 
 #endif
 
+static void vframe_canvas_set(struct canvas_config_s *config, u32 planes,
+				u32 *index)
+{
+	int i;
+	u32 *canvas_index = index;
+	struct canvas_config_s *cfg = config;
+
+	for (i = 0; i < planes; i++, canvas_index++, cfg++)
+		canvas_config_config(*canvas_index, cfg);
+}
+
 u32 property_changed_true = 0;
 static void vsync_toggle_frame(struct vframe_s *vf)
 {
@@ -2122,7 +1916,7 @@ static void vsync_toggle_frame(struct vframe_s *vf)
 			first_picture = 1;
 		}
 	} else {
-		if (READ_VCBUS_REG(DI_IF1_GEN_REG) & 0x1) {
+		if (VSYNC_RD_MPEG_REG(DI_IF1_GEN_REG) & 0x1) {
 			/* disable post di */
 			VSYNC_WR_MPEG_REG(DI_POST_CTRL, 0x3 << 30);
 			VSYNC_WR_MPEG_REG(DI_POST_SIZE,
@@ -2222,18 +2016,30 @@ static void vsync_toggle_frame(struct vframe_s *vf)
 	if ((vf->canvas0Addr != 0) &&
 	(VSYNC_RD_MPEG_REG(DI_IF1_GEN_REG) & 0x1) == 0) {
 #ifdef CONFIG_VSYNC_RDMA
-		canvas_copy(vf->canvas0Addr & 0xff,
-			    disp_canvas_index[rdma_canvas_id][0]);
-		canvas_copy((vf->canvas0Addr >> 8) & 0xff,
-			    disp_canvas_index[rdma_canvas_id][1]);
-		canvas_copy((vf->canvas0Addr >> 16) & 0xff,
-			    disp_canvas_index[rdma_canvas_id][2]);
-		canvas_copy(vf->canvas1Addr & 0xff,
-			    disp_canvas_index[rdma_canvas_id][3]);
-		canvas_copy((vf->canvas1Addr >> 8) & 0xff,
-			    disp_canvas_index[rdma_canvas_id][4]);
-		canvas_copy((vf->canvas1Addr >> 16) & 0xff,
-			    disp_canvas_index[rdma_canvas_id][5]);
+		if (vf->canvas0Addr != (u32)-1) {
+			canvas_copy(vf->canvas0Addr & 0xff,
+				disp_canvas_index[rdma_canvas_id][0]);
+			canvas_copy((vf->canvas0Addr >> 8) & 0xff,
+				disp_canvas_index[rdma_canvas_id][1]);
+			canvas_copy((vf->canvas0Addr >> 16) & 0xff,
+				disp_canvas_index[rdma_canvas_id][2]);
+		} else {
+			vframe_canvas_set(&vf->canvas0_config[0],
+				vf->plane_num,
+				&disp_canvas_index[rdma_canvas_id][0]);
+		}
+		if (vf->canvas1Addr != (u32)-1) {
+			canvas_copy(vf->canvas1Addr & 0xff,
+				disp_canvas_index[rdma_canvas_id][3]);
+			canvas_copy((vf->canvas1Addr >> 8) & 0xff,
+				disp_canvas_index[rdma_canvas_id][4]);
+			canvas_copy((vf->canvas1Addr >> 16) & 0xff,
+				disp_canvas_index[rdma_canvas_id][5]);
+		} else {
+			vframe_canvas_set(&vf->canvas1_config[0],
+				vf->plane_num,
+				&disp_canvas_index[rdma_canvas_id][3]);
+		}
 
 		VSYNC_WR_MPEG_REG(VD1_IF0_CANVAS0 + cur_dev->viu_off,
 				  disp_canvas[rdma_canvas_id][0]);
@@ -2403,18 +2209,19 @@ static void vsync_toggle_frame(struct vframe_s *vf)
 	    (cur_dispbuf->width != vf->width) ||
 	    (cur_dispbuf->height != vf->height) ||
 	    (cur_dispbuf->bitdepth != vf->bitdepth) ||
-	     (cur_dispbuf->trans_fmt != vf->trans_fmt) ||
-	     (last_process_3d_type != process_3d_type) ||
+	    (cur_dispbuf->trans_fmt != vf->trans_fmt) ||
+	    (last_process_3d_type != process_3d_type) ||
 	    (cur_dispbuf->ratio_control != vf->ratio_control) ||
 	    ((cur_dispbuf->type_backup & VIDTYPE_INTERLACE) !=
 	     (vf->type_backup & VIDTYPE_INTERLACE)) ||
 	    (cur_dispbuf->type != vf->type)
 #if HAS_VPU_PROT
 	    || (cur_dispbuf->video_angle != vf->video_angle)
-	    || video_prot.angle_changed
-#endif
+	    || video_prot.angle_changed) {
+#else
 	    ) {
-	    last_process_3d_type = process_3d_type;
+#endif
+		last_process_3d_type = process_3d_type;
 		atomic_inc(&video_sizechange);
 		wake_up_interruptible(&amvideo_sizechange_wait);
 		amlog_mask(LOG_MASK_FRAMEINFO,
@@ -2579,21 +2386,19 @@ static void vsync_toggle_frame(struct vframe_s *vf)
 		if (first_picture && (disable_video != VIDEO_DISABLE_NORMAL)) {
 			EnableVideoLayer();
 
-			if (vf->type & VIDTYPE_MVC)
+			if ((vf->type & VIDTYPE_MVC) ||
+			(cur_dispbuf2 && (cur_dispbuf2->type & VIDTYPE_VD2)))
 				EnableVideoLayer2();
 		}
 	}
 	if (cur_dispbuf && (cur_dispbuf->type != vf->type)) {
-		if (vf->type & VIDTYPE_MVC)
+		if ((vf->type & VIDTYPE_MVC) ||
+		(cur_dispbuf2 && (cur_dispbuf2->type & VIDTYPE_VD2)))
 			EnableVideoLayer2();
 		else
 			DisableVideoLayer2();
 	}
 	cur_dispbuf = vf;
-	if (keep_video_on && cur_dispbuf != &vf_local) {
-		pr_info("toggle new frame after keep.\n");
-		keep_video_on = 0;
-	}
 	if (first_picture) {
 		frame_par_ready_to_set = 1;
 
@@ -2601,6 +2406,8 @@ static void vsync_toggle_frame(struct vframe_s *vf)
 		av_sync_flag = 0;
 #endif
 	}
+	if (cur_dispbuf != &vf_local)
+		video_keeper_new_frame_notify();
 }
 
 static void viu_set_dcu(struct vpp_frame_par_s *frame_par, struct vframe_s *vf)
@@ -2632,6 +2439,8 @@ static void viu_set_dcu(struct vpp_frame_par_s *frame_par, struct vframe_s *vf)
 #endif
 			if (vf->bitdepth & BITDEPTH_SAVING_MODE)
 				r |= (1<<28); /* mem_saving_mode */
+			if (type & VIDTYPE_SCATTER)
+				r |= (1<<29);
 			VSYNC_WR_MPEG_REG(AFBC_MODE, r);
 			VSYNC_WR_MPEG_REG(AFBC_ENABLE, 0x1700);
 			VSYNC_WR_MPEG_REG(AFBC_CONV_CTRL, 0x100);
@@ -2664,7 +2473,7 @@ static void viu_set_dcu(struct vpp_frame_par_s *frame_par, struct vframe_s *vf)
 					(0x8 << VFORMATTER_PHASE_BIT) |
 					VFORMATTER_EN);
 			}
-			if ((READ_VCBUS_REG(DI_POST_CTRL) & 0x100) == 0)
+			if ((VSYNC_RD_MPEG_REG(DI_POST_CTRL) & 0x100) == 0)
 				VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL0 +
 					cur_dev->viu_off, 0, 16, 3);
 
@@ -2686,14 +2495,14 @@ static void viu_set_dcu(struct vpp_frame_par_s *frame_par, struct vframe_s *vf)
 			} else {
 				bit_mode = 0;
 			}
-			VSYNC_WR_MPEG_REG_BITS(VD1_IF0_GEN_REG3,
-				(bit_mode&0x3), 8, 2);
-			VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG3,
-				(bit_mode&0x3), 8, 2);
+			VSYNC_WR_MPEG_REG(VD1_IF0_GEN_REG3,
+				((bit_mode&0x3)<<8) | (3<<4) | 3);
+			VSYNC_WR_MPEG_REG(DI_IF1_GEN_REG3,
+				((bit_mode&0x3)<<8) | (3<<4) | 3);
 			if (is_meson_txl_cpu())
-				VSYNC_WR_MPEG_REG_BITS(DI_IF2_GEN_REG3,
-				(bit_mode&0x3), 8, 2);
-			if ((READ_VCBUS_REG(DI_POST_CTRL) & 0x100) == 0)
+				VSYNC_WR_MPEG_REG(DI_IF2_GEN_REG3,
+				((bit_mode&0x3)<<8) | (3<<4) | 3);
+			if ((VSYNC_RD_MPEG_REG(DI_POST_CTRL) & 0x100) == 0)
 				VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL0 +
 					cur_dev->viu_off, 0, 16, 3);
 
@@ -2899,7 +2708,11 @@ static void viu_set_dcu(struct vpp_frame_par_s *frame_par, struct vframe_s *vf)
 			pat = vpat[frame_par->vscale_skip_count >> 1];
 	} else if (type & VIDTYPE_MVC) {
 		loop = 0x11;
-		pat = 0x80;
+		if (is_need_framepacking_output()) {
+			pat = 0;
+		} else {
+			pat = 0x80;
+		}
 	} else if ((type & VIDTYPE_TYPEMASK) == VIDTYPE_INTERLACE_TOP) {
 		loop = 0x11;
 		pat <<= 4;
@@ -2923,8 +2736,12 @@ static void viu_set_dcu(struct vpp_frame_par_s *frame_par, struct vframe_s *vf)
 	VSYNC_WR_MPEG_REG(VD1_IF0_LUMA1_RPT_PAT + cur_dev->viu_off, pat);
 	VSYNC_WR_MPEG_REG(VD1_IF0_CHROMA1_RPT_PAT + cur_dev->viu_off, pat);
 
-	if (type & VIDTYPE_MVC)
-		pat = 0x88;
+	if (type & VIDTYPE_MVC) {
+		if (is_need_framepacking_output())
+			pat = 0;
+		else
+			pat = 0x88;
+	}
 
 	VSYNC_WR_MPEG_REG(VD2_IF0_LUMA0_RPT_PAT, pat);
 	VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA0_RPT_PAT, pat);
@@ -3003,23 +2820,251 @@ static void viu_set_dcu(struct vpp_frame_par_s *frame_par, struct vframe_s *vf)
 				/* loop pattern */
 			}
 		} else {
-			if (frame_par->vpp_2pic_mode & VPP_SELECT_PIC1) {
-				VSYNC_WR_MPEG_REG(VD1_IF0_LUMA_PSEL +
-				cur_dev->viu_off, 0);
-				VSYNC_WR_MPEG_REG(VD1_IF0_CHROMA_PSEL +
-				cur_dev->viu_off, 0);
-				VSYNC_WR_MPEG_REG(VD2_IF0_LUMA_PSEL +
-				cur_dev->viu_off, 0);
-				VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA_PSEL +
-				cur_dev->viu_off, 0);
-			} else {
-				VSYNC_WR_MPEG_REG(VD1_IF0_LUMA_PSEL +
-				cur_dev->viu_off, 0);
-				VSYNC_WR_MPEG_REG(VD1_IF0_CHROMA_PSEL +
-						  cur_dev->viu_off, 0);
-				VSYNC_WR_MPEG_REG(VD2_IF0_LUMA_PSEL, 0);
-				VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA_PSEL, 0);
-			}
+			if (frame_par->vpp_2pic_mode & VPP_SELECT_PIC1) {
+				VSYNC_WR_MPEG_REG(VD1_IF0_LUMA_PSEL +
+				cur_dev->viu_off, 0);
+				VSYNC_WR_MPEG_REG(VD1_IF0_CHROMA_PSEL +
+				cur_dev->viu_off, 0);
+				VSYNC_WR_MPEG_REG(VD2_IF0_LUMA_PSEL +
+				cur_dev->viu_off, 0);
+				VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA_PSEL +
+				cur_dev->viu_off, 0);
+			} else {
+				VSYNC_WR_MPEG_REG(VD1_IF0_LUMA_PSEL +
+				cur_dev->viu_off, 0);
+				VSYNC_WR_MPEG_REG(VD1_IF0_CHROMA_PSEL +
+				cur_dev->viu_off, 0);
+				VSYNC_WR_MPEG_REG(VD2_IF0_LUMA_PSEL, 0);
+				VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA_PSEL, 0);
+			}
+		}
+	}
+}
+
+static void vd2_set_dcu(struct vframe_s *vf)
+{
+	u32 r;
+	u32 vphase, vini_phase;
+	u32 pat, loop;
+	static const u32 vpat[] = { 0, 0x8, 0x9, 0xa, 0xb, 0xc };
+	u32 u, v;
+	u32 type = vf->type;
+	u32 skip_count = 0;
+
+	pr_info("set dcu for vd2\n");
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
+		if (type & VIDTYPE_COMPRESS) {
+			r = (3 << 24) |
+			    (17 << 16) |
+			    (1 << 14) | /*burst1 1*/
+			    (vf->bitdepth & BITDEPTH_MASK);
+
+			if (skip_count)
+				r |= 0x33;
+			if (skip_count)
+				r |= 0xcc;
+
+#ifdef TV_REVERSE
+			if (reverse)
+				r |= (1<<26)|(1<<27);
+#endif
+			if (vf->bitdepth & BITDEPTH_SAVING_MODE)
+				r |= (1<<28); /* mem_saving_mode */
+			VSYNC_WR_MPEG_REG(VD2_AFBC_MODE, r);
+			VSYNC_WR_MPEG_REG(VD2_AFBC_ENABLE, 0x1700);
+			VSYNC_WR_MPEG_REG(VD2_AFBC_CONV_CTRL, 0x100);
+			u = (vf->bitdepth >> (BITDEPTH_U_SHIFT)) & 0x3;
+			v = (vf->bitdepth >> (BITDEPTH_V_SHIFT)) & 0x3;
+			VSYNC_WR_MPEG_REG(VD2_AFBC_DEC_DEF_COLOR,
+				0x3FF00000 | /*Y,bit20+*/
+				0x80 << (u + 10) |
+				0x80 << v);
+			/* chroma formatter */
+#ifdef TV_REVERSE
+			if (reverse) {
+				VSYNC_WR_MPEG_REG(VD2_AFBC_VD_CFMT_CTRL,
+					/*HFORMATTER_RRT_PIXEL0 |*/
+					HFORMATTER_YC_RATIO_2_1 |
+					HFORMATTER_EN |
+					VFORMATTER_RPTLINE0_EN |
+					/*(0xa << VFORMATTER_INIPHASE_BIT) |*/
+					(0x8 << VFORMATTER_PHASE_BIT) |
+					VFORMATTER_EN);
+			} else
+#endif
+			{
+				VSYNC_WR_MPEG_REG(VD2_AFBC_VD_CFMT_CTRL,
+					HFORMATTER_RRT_PIXEL0 |
+					HFORMATTER_YC_RATIO_2_1 |
+					HFORMATTER_EN |
+					VFORMATTER_RPTLINE0_EN |
+					/*(0xa << VFORMATTER_INIPHASE_BIT) |*/
+					(0x8 << VFORMATTER_PHASE_BIT) |
+					VFORMATTER_EN);
+			}
+			VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL1 +
+					cur_dev->viu_off, 1, 1, 1);
+			return;
+
+		} else {
+			VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL1 +
+					cur_dev->viu_off, 0, 1, 1);
+			VSYNC_WR_MPEG_REG(VD2_AFBC_ENABLE, 0);
+		}
+	}
+
+	r = (3 << VDIF_URGENT_BIT) |
+	    (17 << VDIF_HOLD_LINES_BIT) |
+	    VDIF_FORMAT_SPLIT |
+	    VDIF_CHRO_RPT_LAST | VDIF_ENABLE;
+	/*  | VDIF_RESET_ON_GO_FIELD;*/
+	if (debug_flag & DEBUG_FLAG_GOFIELD_MANUL)
+		r |= 1<<7; /*for manul triggle gofiled.*/
+
+	if ((type & VIDTYPE_VIU_SINGLE_PLANE) == 0)
+		r |= VDIF_SEPARATE_EN;
+	else {
+		if (type & VIDTYPE_VIU_422)
+			r |= VDIF_FORMAT_422;
+		else {
+			r |= VDIF_FORMAT_RGB888_YUV444 |
+			    VDIF_DEMUX_MODE_RGB_444;
+		}
+	}
+
+	if (skip_count)
+		r |= VDIF_CHROMA_HZ_AVG | VDIF_LUMA_HZ_AVG;
+
+	VSYNC_WR_MPEG_REG(VD2_IF0_GEN_REG, r);
+
+#ifdef TV_REVERSE
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M6) {
+		if (reverse) {
+				VSYNC_WR_MPEG_REG_BITS((VD2_IF0_GEN_REG2 +
+					cur_dev->viu_off), 0xf, 2, 4);
+		} else {
+				VSYNC_WR_MPEG_REG_BITS((VD2_IF0_GEN_REG2 +
+					cur_dev->viu_off), 0, 2, 4);
+		}
+	}
+#endif
+
+	/* chroma formatter */
+	if (type & VIDTYPE_VIU_444) {
+		VSYNC_WR_MPEG_REG(VIU_VD2_FMT_CTRL + cur_dev->viu_off,
+				  HFORMATTER_YC_RATIO_1_1);
+	} else if (type & VIDTYPE_VIU_FIELD) {
+		vini_phase = 0xc << VFORMATTER_INIPHASE_BIT;
+		vphase =
+		    ((type & VIDTYPE_VIU_422) ? 0x10 : 0x08) <<
+		    VFORMATTER_PHASE_BIT;
+	if (is_meson_gxtvbb_cpu() || is_meson_txl_cpu()) {
+		if ((vf->width >= 3840) &&
+			(vf->height >= 2160) &&
+			(type & VIDTYPE_VIU_422)) {
+
+			VSYNC_WR_MPEG_REG(VIU_VD2_FMT_CTRL + cur_dev->viu_off,
+			HFORMATTER_RRT_PIXEL0 | HFORMATTER_YC_RATIO_2_1 |
+			HFORMATTER_EN | VFORMATTER_RPTLINE0_EN |
+			vini_phase | vphase);
+			} else {
+			VSYNC_WR_MPEG_REG(VIU_VD2_FMT_CTRL + cur_dev->viu_off,
+			HFORMATTER_YC_RATIO_2_1 | HFORMATTER_EN |
+			VFORMATTER_RPTLINE0_EN | vini_phase | vphase |
+			VFORMATTER_EN);
+			}
+		} else {
+
+			VSYNC_WR_MPEG_REG(VIU_VD2_FMT_CTRL + cur_dev->viu_off,
+				HFORMATTER_YC_RATIO_2_1 | HFORMATTER_EN |
+				VFORMATTER_RPTLINE0_EN | vini_phase | vphase |
+				VFORMATTER_EN);
+		}
+	} else if (type & VIDTYPE_MVC) {
+		VSYNC_WR_MPEG_REG(VIU_VD1_FMT_CTRL + cur_dev->viu_off,
+				HFORMATTER_YC_RATIO_2_1 |
+				HFORMATTER_EN |
+				VFORMATTER_RPTLINE0_EN |
+				(0xe << VFORMATTER_INIPHASE_BIT) |
+				(((type & VIDTYPE_VIU_422) ? 0x10 : 0x08)
+				<< VFORMATTER_PHASE_BIT) | VFORMATTER_EN);
+		VSYNC_WR_MPEG_REG(VIU_VD2_FMT_CTRL + cur_dev->viu_off,
+				HFORMATTER_YC_RATIO_2_1 | HFORMATTER_EN |
+				VFORMATTER_RPTLINE0_EN | (0xa <<
+				VFORMATTER_INIPHASE_BIT) |
+				(((type & VIDTYPE_VIU_422) ? 0x10 : 0x08)
+				<< VFORMATTER_PHASE_BIT) | VFORMATTER_EN);
+	} else if ((type & VIDTYPE_INTERLACE)
+		   &&
+		   (((type & VIDTYPE_TYPEMASK) == VIDTYPE_INTERLACE_TOP))) {
+		VSYNC_WR_MPEG_REG(VIU_VD2_FMT_CTRL + cur_dev->viu_off,
+				HFORMATTER_YC_RATIO_2_1 |
+				HFORMATTER_EN |
+				VFORMATTER_RPTLINE0_EN |
+				(0xe << VFORMATTER_INIPHASE_BIT) |
+				(((type & VIDTYPE_VIU_422) ? 0x10 : 0x08)
+				<< VFORMATTER_PHASE_BIT) | VFORMATTER_EN);
+	} else {
+		VSYNC_WR_MPEG_REG(VIU_VD2_FMT_CTRL + cur_dev->viu_off,
+				HFORMATTER_YC_RATIO_2_1 |
+				HFORMATTER_EN |
+				VFORMATTER_RPTLINE0_EN |
+				(0xa << VFORMATTER_INIPHASE_BIT) |
+				(((type & VIDTYPE_VIU_422) ? 0x10 : 0x08)
+				<< VFORMATTER_PHASE_BIT) | VFORMATTER_EN);
+	}
+	/* LOOP/SKIP pattern */
+	pat = vpat[skip_count];
+
+	if (type & VIDTYPE_VIU_FIELD) {
+		loop = 0;
+
+	if (type & VIDTYPE_INTERLACE)
+			pat = vpat[skip_count >> 1];
+	} else if (type & VIDTYPE_MVC) {
+		loop = 0x11;
+		pat = 0x80;
+	} else if ((type & VIDTYPE_TYPEMASK) == VIDTYPE_INTERLACE_TOP) {
+		loop = 0x11;
+		pat <<= 4;
+	} else
+		loop = 0;
+
+	VSYNC_WR_MPEG_REG(VD2_IF0_RPT_LOOP,
+			(loop << VDIF_CHROMA_LOOP1_BIT) |
+			(loop << VDIF_LUMA_LOOP1_BIT) |
+			(loop << VDIF_CHROMA_LOOP0_BIT) |
+			(loop << VDIF_LUMA_LOOP0_BIT));
+
+	if (type & VIDTYPE_MVC)
+		pat = 0x88;
+
+	VSYNC_WR_MPEG_REG(VD2_IF0_LUMA0_RPT_PAT, pat);
+	VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA0_RPT_PAT, pat);
+	VSYNC_WR_MPEG_REG(VD2_IF0_LUMA1_RPT_PAT, pat);
+	VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA1_RPT_PAT, pat);
+
+	if (platform_type == 0) {
+		/* picture 0/1 control */
+		if (((type & VIDTYPE_INTERLACE) == 0) &&
+			((type & VIDTYPE_VIU_FIELD) == 0) &&
+			((type & VIDTYPE_MVC) == 0)) {
+			/* progressive frame in two pictures */
+
+		} else {
+			VSYNC_WR_MPEG_REG(VD2_IF0_LUMA_PSEL, 0);
+			VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA_PSEL, 0);
+		}
+	} else {
+		/* picture 0/1 control */
+		if ((((type & VIDTYPE_INTERLACE) == 0) &&
+			 ((type & VIDTYPE_VIU_FIELD) == 0) &&
+			 ((type & VIDTYPE_MVC) == 0))) {
+			/* progressive frame in two pictures */
+
+		} else {
+			VSYNC_WR_MPEG_REG(VD2_IF0_LUMA_PSEL, 0);
+			VSYNC_WR_MPEG_REG(VD2_IF0_CHROMA_PSEL, 0);
 		}
 	}
 }
@@ -3200,10 +3245,16 @@ static inline bool vpts_expire(struct vframe_s *cur_vf,
 		    (cur_vf ? DUR2PTS(cur_vf->duration) : 0);
 	}
 	/* check video PTS discontinuity */
-	else if (timestamp_pcrscr_enable_state() > 0 &&
-		 (enable_video_discontinue_report) &&
+	else if ((enable_video_discontinue_report) &&
 		 (abs(systime - pts) > tsync_vpts_discontinuity_margin()) &&
 		 ((next_vf->flag & VFRAME_FLAG_NO_DISCONTINUE) == 0)) {
+		/**
+		* if paused ignore discontinue
+		*/
+		if (!timestamp_pcrscr_enable_state()) {
+			pr_info("video pts discontinue, but pcrscr is disabled, return false\n");
+			return false;
+		}
 		pts =
 		    timestamp_vpts_get() +
 		    (cur_vf ? DUR2PTS(cur_vf->duration) : 0);
@@ -3504,6 +3555,10 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 #ifdef CONFIG_AM_VIDEO_LOG
 	int toggle_cnt;
 #endif
+	struct vframe_s *toggle_vf = NULL;
+	int ret;
+	int video1_off_req = 0;
+
 	if (debug_flag & DEBUG_FLAG_VSYNC_DONONE)
 		return IRQ_HANDLED;
 
@@ -3793,6 +3848,12 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 			amlog_mask_if(toggle_cnt > 0, LOG_MASK_FRAMESKIP,
 				      "skipped\n");
 
+			if (is_dolby_vision_enable()) {
+				ret = dolby_vision_wait_metadata(vf);
+				if (ret == 2)
+					break;
+			}
+
 #if defined(CONFIG_AM_VECM)
 			refresh_on_vs(vf);
 #endif
@@ -3816,6 +3877,45 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 				}
 			}
 			vsync_toggle_frame(vf);
+			if (is_dolby_vision_enable()) {
+				ret = dolby_vision_update_metadata(vf);
+				cur_dispbuf2 = dolby_vision_vf_peek_el(vf);
+				if (cur_dispbuf2) {
+					VSYNC_WR_MPEG_REG(VD2_AFBC_HEAD_BADDR,
+						cur_dispbuf2->compHeadAddr>>4);
+					VSYNC_WR_MPEG_REG(VD2_AFBC_BODY_BADDR,
+						cur_dispbuf2->compBodyAddr>>4);
+					ori2_start_x_lines = 0;
+					ori2_end_x_lines =
+						((cur_dispbuf2->type
+						& VIDTYPE_COMPRESS) ?
+						cur_dispbuf2->compWidth :
+						cur_dispbuf2->width) - 1;
+					ori2_start_y_lines = 0;
+					ori2_end_y_lines =
+						((cur_dispbuf2->type
+						& VIDTYPE_COMPRESS) ?
+						cur_dispbuf2->compHeight :
+						cur_dispbuf2->height) - 1;
+				}
+				if (ret == 0) {
+					toggle_vf = vf;
+					dolby_vision_set_toggle_flag(1);
+				} else if (ret == -1) {
+					/* not enough meta, wait */
+					toggle_vf = NULL;
+					dolby_vision_set_toggle_flag(0);
+					break;
+				} else if (ret == -2) {
+					/* no meta, mostly SDR */
+					toggle_vf = NULL;
+					dolby_vision_set_toggle_flag(1);
+					dolby_vision_process(toggle_vf);
+					break;
+				}
+			} else
+				cur_dispbuf2 = NULL;
+
 			if (trickmode_fffb == 1) {
 				trickmode_vpts = vf->pts;
 #ifdef CONFIG_VSYNC_RDMA
@@ -3904,6 +4004,8 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 		toggle_cnt++;
 #endif
 	}
+	if (toggle_vf && is_dolby_vision_enable())
+		dolby_vision_process(toggle_vf);
 
 #ifdef INTERLACE_FIELD_MATCH_PROCESS
 	if (interlace_field_type_need_match(vout_type, vf)) {
@@ -3932,10 +4034,16 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 	if (cur_dispbuf) {
 		struct f2v_vphase_s *vphase;
 		u32 vin_type = cur_dispbuf->type & VIDTYPE_TYPEMASK;
-
 		{
-			if (frame_par_ready_to_set)
+			int need_afbc = (cur_dispbuf->type & VIDTYPE_COMPRESS);
+			int afbc_need_reset = video_enabled && need_afbc &&
+			(!(READ_VCBUS_REG(AFBC_ENABLE) & 0x100));
+			/*video on && afbc is off && is compress frame.*/
+			if (frame_par_ready_to_set || afbc_need_reset)
 				viu_set_dcu(cur_frame_par, cur_dispbuf);
+			if ((cur_dispbuf2)
+			&& (frame_par_ready_to_set || afbc_need_reset))
+					vd2_set_dcu(cur_dispbuf2);
 		}
 		{
 #if 0
@@ -4137,12 +4245,18 @@ cur_dev->vpp_off,0,VPP_VD2_ALPHA_BIT,9);//vd2 alpha must set
 					zoom_end_y =
 					cur_frame_par->VPP_vd_end_lines_;
 				} else {
-					zoom_start_y =
-					cur_frame_par->VPP_vd_start_lines_
-					>> 1;
-					zoom_end_y =
-					((cur_frame_par->VPP_vd_end_lines_ +
-					1) >> 1) - 1;
+					if (is_need_framepacking_output()) {
+						zoom_start_y =
+	cur_frame_par->VPP_vd_start_lines_ >> 1;
+						zoom_end_y =
+	((cur_frame_par->VPP_vd_end_lines_
+	- framepacking_blank + 1) >> 1) - 1;
+					} else {
+						zoom_start_y =
+	cur_frame_par->VPP_vd_start_lines_ >> 1;
+						zoom_end_y =
+	((cur_frame_par->VPP_vd_end_lines_ + 1) >> 1) - 1;
+					}
 				}
 			}
 
@@ -4154,6 +4268,15 @@ cur_dev->vpp_off,0,VPP_VD2_ALPHA_BIT,9);//vd2 alpha must set
 			zoom_start_y_lines = zoom_start_y;
 			zoom_end_y_lines = zoom_end_y;
 			zoom_display_vert();
+
+			if (is_dolby_vision_enable() && cur_dispbuf2) {
+				zoom2_start_x_lines = ori2_start_x_lines;
+				zoom2_end_x_lines = ori2_end_x_lines;
+				vd2_zoom_display_horz(0);
+				zoom2_start_y_lines = ori2_start_y_lines;
+				zoom2_end_y_lines = ori2_end_y_lines;
+				vd2_zoom_display_vert();
+			}
 		}
 
 		/* vpp super scaler */
@@ -4265,7 +4388,7 @@ cur_dev->vpp_off,0,VPP_VD2_ALPHA_BIT,9);//vd2 alpha must set
 		}
 
 #if (!HAS_VPU_PROT)
-		if (is_meson_gxbb_cpu()) {
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB && cur_dispbuf) {
 			if (cur_dispbuf->type & VIDTYPE_INTERLACE) {
 				cur_frame_par->VPP_pic_in_height_ =
 				zoom_end_y_lines - zoom_start_y_lines + 1;
@@ -4277,12 +4400,17 @@ cur_dev->vpp_off,0,VPP_VD2_ALPHA_BIT,9);//vd2 alpha must set
 				(cur_frame_par->vscale_skip_count + 1);
 				if (cur_dispbuf->type & VIDTYPE_MVC)
 					cur_frame_par->VPP_pic_in_height_ *= 2;
+				if (is_need_framepacking_output()) {
+					cur_frame_par->VPP_pic_in_height_ +=
+					framepacking_blank;
+				}
 				cur_frame_par->VPP_line_in_length_ =
 				(zoom_end_x_lines - zoom_start_x_lines + 1) /
 				(cur_frame_par->hscale_skip_count + 1);
 			}
 		}
-		if (is_meson_gxtvbb_cpu() || is_meson_txl_cpu()) {
+		if ((is_meson_gxtvbb_cpu() || is_meson_txl_cpu()) &&
+			cur_dispbuf) {
 			if (cur_dispbuf->type & VIDTYPE_INTERLACE) {
 				cur_frame_par->VPP_pic_in_height_ =
 				(zoom_end_y_lines - zoom_start_y_lines + 1)  <<
@@ -4297,6 +4425,10 @@ cur_dev->vpp_off,0,VPP_VD2_ALPHA_BIT,9);//vd2 alpha must set
 				cur_frame_par->supsc0_vert_ratio;
 				if (cur_dispbuf->type & VIDTYPE_MVC)
 					cur_frame_par->VPP_pic_in_height_ *= 2;
+				if (is_need_framepacking_output()) {
+					cur_frame_par->VPP_pic_in_height_ +=
+					framepacking_blank;
+				}
 				cur_frame_par->VPP_line_in_length_ =
 				((zoom_end_x_lines - zoom_start_x_lines + 1) /
 				(cur_frame_par->hscale_skip_count + 1)) <<
@@ -4352,6 +4484,10 @@ cur_dev->vpp_off,0,VPP_VD2_ALPHA_BIT,9);//vd2 alpha must set
 
 		vpp_settings_h(cur_frame_par);
 		vpp_settings_v(cur_frame_par);
+		if (is_dolby_vision_enable() && cur_dispbuf2) {
+			vd2_settings_h(cur_dispbuf2);
+			vd2_settings_v(cur_dispbuf2);
+		}
 		frame_par_ready_to_set = 0;
 		frame_par_force_to_set = 0;
 		first_set = 1;
@@ -4378,6 +4514,17 @@ cur_dev->vpp_off,0,VPP_VD2_ALPHA_BIT,9);//vd2 alpha must set
  exit:
 	vpp_misc_save = READ_VCBUS_REG(VPP_MISC + cur_dev->vpp_off);
 	vpp_misc_set = vpp_misc_save;
+#ifdef CONFIG_AM_VECM
+	vpp_misc_set |= VPP_CM_ENABLE;
+#endif
+	if (update_osd_vpp_misc) {
+		vpp_misc_set &= ~osd_vpp_misc_mask;
+		vpp_misc_set |=
+			(osd_vpp_misc & osd_vpp_misc_mask);
+		if (vpp_misc_set &
+			(VPP_OSD1_POSTBLEND | VPP_OSD2_POSTBLEND))
+			vpp_misc_set |= VPP_POSTBLEND_EN;
+	}
 	if ((video_enabled == 1) && ((vpp_misc_save & VPP_VD1_POSTBLEND) == 0)
 	&& (video_onoff_state == VIDEO_ENABLE_STATE_IDLE)) {
 		SET_VCBUS_REG_MASK(VPP_MISC + cur_dev->vpp_off,
@@ -4464,6 +4611,7 @@ cur_dev->vpp_off,0,VPP_VD2_ALPHA_BIT,9);//vd2 alpha must set
 				VPU_VIDEO_LAYER1_CHANGED;
 			if (debug_flag & DEBUG_FLAG_BLACKOUT)
 				pr_info("VsyncDisableVideoLayer\n");
+			video1_off_req = 1;
 		}
 
 		spin_unlock_irqrestore(&video_onoff_lock, flags);
@@ -4525,7 +4673,6 @@ cur_dev->vpp_off,0,VPP_VD2_ALPHA_BIT,9);//vd2 alpha must set
 			if (debug_flag & DEBUG_FLAG_BLACKOUT)
 				pr_info("VsyncDisableVideoLayer2\n");
 		}
-
 		spin_unlock_irqrestore(&video2_onoff_lock, flags);
 	}
 
@@ -4533,15 +4680,20 @@ cur_dev->vpp_off,0,VPP_VD2_ALPHA_BIT,9);//vd2 alpha must set
 		VSYNC_WR_MPEG_REG(VPP_MISC + cur_dev->vpp_off,
 			vpp_misc_set);
 	}
+	/*vpp_misc_set maybe have same,but need off.*/
+	if (video1_off_req) {
+		/*video layer off, swith off afbc,
+		will enabled on new frame coming.
+		*/
+		if (debug_flag & DEBUG_FLAG_BLACKOUT)
+			pr_info("AFBC off now.\n");
+		VSYNC_WR_MPEG_REG(AFBC_ENABLE, 0);
+	}
 
 #ifdef CONFIG_VSYNC_RDMA
 	cur_rdma_buf = cur_dispbuf;
 	/* vsync_rdma_config(); */
 	vsync_rdma_process();
-	if (frame_par_di_set) {
-		start_rdma();
-		/* work around, need set one frame without RDMA??? */
-	}
 	if (debug_flag & DEBUG_FLAG_PRINT_RDMA) {
 		if (enable_rdma_log_count == 0)
 			enable_rdma_log(0);
@@ -4599,121 +4751,8 @@ cur_dev->vpp_off,0,VPP_VD2_ALPHA_BIT,9);//vd2 alpha must set
 
 }
 
-#ifdef RESERVE_CLR_FRAME
-static int free_alloced_keep_buffer(void)
-{
-	pr_info("free_alloced_keep_buffer %p.%p.%p\n",
-		(void *)keep_y_addr, (void *)keep_u_addr, (void *)keep_v_addr);
-	if (keep_y_addr) {
-		codec_mm_free_for_dma(MEM_NAME, keep_y_addr);
-		keep_y_addr = 0;
-	}
-
-	if (keep_u_addr) {
-		codec_mm_free_for_dma(MEM_NAME, keep_u_addr);
-		keep_u_addr = 0;
-	}
-
-	if (keep_v_addr) {
-		codec_mm_free_for_dma(MEM_NAME, keep_v_addr);
-		keep_v_addr = 0;
-	}
-	return 0;
-}
-
-static int alloc_keep_buffer(void)
-{
-	int flags = CODEC_MM_FLAGS_DMA |
-		CODEC_MM_FLAGS_FOR_VDECODER;
-#ifndef CONFIG_GE2D_KEEP_FRAME
-	/*
-		if not used ge2d.
-		need CPU access.
-	*/
-	flags = CODEC_MM_FLAGS_DMA_CPU |
-	CODEC_MM_FLAGS_FOR_VDECODER;
-#endif
-	if (!keep_y_addr) {
-		keep_y_addr = codec_mm_alloc_for_dma(
-				MEM_NAME,
-				PAGE_ALIGN(Y_BUFFER_SIZE)/PAGE_SIZE, 0, flags);
-		if (!keep_y_addr) {
-			pr_err("%s: failed to alloc y addr\n", __func__);
-			goto err1;
-		}
-	}
-
-	if (!keep_u_addr) {
-		keep_u_addr = codec_mm_alloc_for_dma(
-				MEM_NAME,
-				PAGE_ALIGN(U_BUFFER_SIZE)/PAGE_SIZE, 0, flags);
-		if (!keep_u_addr) {
-			pr_err("%s: failed to alloc u addr\n", __func__);
-			goto err1;
-		}
-	}
-
-	if (!keep_v_addr) {
-		keep_v_addr = codec_mm_alloc_for_dma(
-				MEM_NAME,
-				PAGE_ALIGN(V_BUFFER_SIZE)/PAGE_SIZE, 0, flags);
-		if (!keep_v_addr) {
-			pr_err("%s: failed to alloc v addr\n", __func__);
-			goto err1;
-		}
-	}
-	pr_info("alloced keep buffer yaddr=%p,u_addr=%p,v_addr=%p\n",
-		(void *)keep_y_addr,
-		(void *)keep_u_addr,
-		(void *)keep_v_addr);
-	return 0;
-
- err1:
-	free_alloced_keep_buffer();
-	return -ENOMEM;
-}
-
-void try_free_keep_video(void)
-{
-	if (keep_video_on) {
-		pr_info("disbled keep video before free keep buffer.\n");
-		keep_video_on = 0;
-		cur_dispbuf = NULL;
-		if (!disable_video) {
-			/*if not disable video,changed to 2 for */
-			pr_info("disbled video for next before free keep buffer!\n");
-			_video_set_disable(VIDEO_DISABLE_FORNEXT);
-		} else if (video_enabled) {
-			safe_disble_videolayer();
-		}
-	}
-	free_alloced_keep_buffer();
-	return;
-}
-#endif
 
-void get_video_keep_buffer(ulong *addr, ulong *phys_addr)
-{
-#if 1
-	if (addr) {
-		addr[0] = (ulong) 0;
-		addr[1] = (ulong) 0;
-		addr[2] = (ulong) 0;
-	}
 
-	if (phys_addr) {
-		if (!keep_y_addr || !keep_u_addr || !keep_v_addr)
-			alloc_keep_buffer();
-		phys_addr[0] = keep_y_addr;
-		phys_addr[1] = keep_u_addr;
-		phys_addr[2] = keep_v_addr;
-	}
-#endif
-	if (debug_flag & DEBUG_FLAG_BLACKOUT) {
-		pr_info("%s: y=%lx u=%lx v=%lx\n", __func__, phys_addr[0],
-		       phys_addr[1], phys_addr[2]);
-	}
-}
 
 /*********************************************************
  * FIQ Routines
@@ -4792,6 +4831,9 @@ int query_video_status(int type, int *value)
 	case 0:
 		*value = trickmode_fffb;
 		break;
+	case 1:
+		*value = trickmode_i;
+		break;
 	default:
 		break;
 	}
@@ -4828,7 +4870,7 @@ static void video_vf_unreg_provider(void)
 
 	if (blackout | force_blackout) {
 		safe_disble_videolayer();
-		try_free_keep_video();
+		try_free_keep_video(1);
 	}
 
 	vsync_pts_100 = 0;
@@ -4842,7 +4884,7 @@ static void video_vf_unreg_provider(void)
 	if (cur_dispbuf) {
 		/* TODO: mod gate */
 		/* switch_mod_gate_by_name("ge2d", 1); */
-		vf_keep_current();
+		vf_keep_current(cur_dispbuf);
 		/* TODO: mod gate */
 		/* switch_mod_gate_by_name("ge2d", 0); */
 	}
@@ -4851,7 +4893,7 @@ static void video_vf_unreg_provider(void)
 #else
 	/* if (!trickmode_fffb) */
 	if (cur_dispbuf)
-		vf_keep_current();
+		vf_keep_current(cur_dispbuf);
 	if (hdmi_in_onvideo == 0)
 		tsync_avevent(VIDEO_STOP, 0);
 #endif
@@ -4934,6 +4976,8 @@ static int  get_display_info(void *data)
 
 static int video_receiver_event_fun(int type, void *data, void *private_data)
 {
+	char *configured[2];
+	char framerate[20] = {0};
 #ifdef CONFIG_AM_VIDEO2
 	char *provider_name;
 #endif
@@ -4977,12 +5021,31 @@ alternative mode,passing two buffer in one frame */
 		}
 	} else if (type == VFRAME_EVENT_PROVIDER_FR_HINT) {
 #ifdef CONFIG_AM_VOUT
-		if (data != NULL)
-			set_vframe_rate_hint((unsigned long)(data));
+		if (data != NULL) {
+			if (video_seek_flag == 0) {
+				/*set_vframe_rate_hint((unsigned long)(data));*/
+				sprintf(framerate, "FRAME_RATE_HINT=%lu",
+						(unsigned long)data);
+				configured[0] = framerate;
+				configured[1] = NULL;
+				kobject_uevent_env(&(amvideo_dev->kobj),
+						KOBJ_CHANGE, configured);
+				pr_info("%s: sent uevent %s\n",
+					__func__, configured[0]);
+			}
+		}
 #endif
 	} else if (type == VFRAME_EVENT_PROVIDER_FR_END_HINT) {
 #ifdef CONFIG_AM_VOUT
-		set_vframe_rate_end_hint();
+		if (video_seek_flag == 0) {
+			configured[0] = "FRAME_RATE_END_HINT";
+			configured[1] = NULL;
+			/*set_vframe_rate_end_hint();*/
+			kobject_uevent_env(&(amvideo_dev->kobj),
+					KOBJ_CHANGE, configured);
+			pr_info("%s: sent uevent %s\n",
+				__func__, configured[0]);
+		}
 #endif
 	} else if (type == VFRAME_EVENT_PROVIDER_QUREY_DISPLAY_INFO) {
 		get_display_info(data);
@@ -5011,249 +5074,12 @@ unsigned int get_post_canvas(void)
 	return post_canvas;
 }
 
-static int canvas_dup(ulong dst, ulong src_paddr, ulong size)
-{
-	void *src_addr = codec_mm_phys_to_virt(src_paddr);
-	void *dst_addr = codec_mm_phys_to_virt(dst);
-
-	if (src_paddr && dst && src_addr && dst_addr) {
-		dma_addr_t dma_addr = 0;
-		memcpy(dst_addr, src_addr, size);
-		dma_addr = dma_map_single(
-					amports_get_dma_device(), dst_addr,
-					size, DMA_TO_DEVICE);
-		dma_unmap_single(amports_get_dma_device(), dma_addr,
-					FETCHBUF_SIZE, DMA_TO_DEVICE);
-		return 1;
-	}
-
-	return 0;
-}
-unsigned int vf_keep_current(void)
-{
-	u32 cur_index;
-	u32 y_index, u_index, v_index;
-	struct canvas_s cs0, cs1, cs2, cd;
-
-	if (!cur_dispbuf) {
-		pr_info("keep exit without cur_dispbuf\n");
-		return 0;
-	}
-
-	if (cur_dispbuf->source_type == VFRAME_SOURCE_TYPE_OSD) {
-		pr_info("keep exit is osd\n");
-		return 0;
-	}
-	if (READ_VCBUS_REG(DI_IF1_GEN_REG) & 0x1) {
-		pr_info("keep exit is di\n");
-		return 0;
-	}
-	if (debug_flag & DEBUG_FLAG_TOGGLE_SKIP_KEEP_CURRENT) {
-		pr_info("keep exit is skip current\n");
-		return 0;
-	}
-
-#ifdef CONFIG_AM_VIDEOCAPTURE
-	ext_frame_capture_poll(1);	/*pull  if have capture end frame */
-#endif
-	if (blackout | force_blackout) {
-		pr_info("keep exit is skip current\n");
-		return 0;
-	}
-
-	if (0 == (READ_VCBUS_REG(VPP_MISC + cur_dev->vpp_off) &
-		VPP_VD1_POSTBLEND)) {
-		pr_info("keep exit is skip VPP_VD1_POSTBLEND\n");
-		return 0;
-	}
-
-	if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) &&
-		(cur_dispbuf->type & VIDTYPE_COMPRESS)) {
-		/* todo: duplicate compressed video frame */
-		pr_info("keep exit is skip VIDTYPE_COMPRESS\n");
-		return -1;
-	}
-	cur_index = READ_VCBUS_REG(VD1_IF0_CANVAS0 + cur_dev->viu_off);
-	y_index = cur_index & 0xff;
-	u_index = (cur_index >> 8) & 0xff;
-	v_index = (cur_index >> 16) & 0xff;
-	canvas_read(y_index, &cd);
-
-	if ((cd.width * cd.height) <= 2048 * 1088 &&
-			!keep_y_addr) {
-		alloc_keep_buffer();
-	}
-	if (!keep_y_addr
-	    || (cur_dispbuf->type & VIDTYPE_VIU_422) == VIDTYPE_VIU_422) {
-		/* no support VIDTYPE_VIU_422... */
-		pr_info("%s:no support VIDTYPE_VIU_422\n", __func__);
-		return -1;
-	}
-
-
-	if (debug_flag & DEBUG_FLAG_BLACKOUT) {
-		pr_info("%s keep_y_addr=%p %x\n", __func__, (void *)keep_y_addr,
-		       canvas_get_addr(y_index));
-	}
-
-	if ((cur_dispbuf->type & VIDTYPE_VIU_422) == VIDTYPE_VIU_422) {
-		return -1;
-		/* no VIDTYPE_VIU_422 type frame need keep,avoid memcpy crash*/
-		if ((Y_BUFFER_SIZE < (cd.width * cd.height))) {
-			pr_info("[%s::%d]data > buf size: %x,%x,%x, %x,%x\n",
-				__func__, __LINE__, Y_BUFFER_SIZE,
-				U_BUFFER_SIZE, V_BUFFER_SIZE,
-				cd.width, cd.height);
-			return -1;
-		}
-		if (keep_phy_addr(keep_y_addr) != canvas_get_addr(y_index) &&
-				canvas_dup(keep_phy_addr(keep_y_addr),
-				canvas_get_addr(y_index),
-				(cd.width) * (cd.height))) {
-#ifdef CONFIG_VSYNC_RDMA
-			canvas_update_addr(disp_canvas_index[0][0],
-					   keep_phy_addr(keep_y_addr));
-			canvas_update_addr(disp_canvas_index[1][0],
-					   keep_phy_addr(keep_y_addr));
-#else
-			canvas_update_addr(y_index,
-				keep_phy_addr(keep_y_addr));
-#endif
-			if (debug_flag & DEBUG_FLAG_BLACKOUT)
-				pr_info("%s: VIDTYPE_VIU_422\n", __func__);
-		}
-	} else if ((cur_dispbuf->type & VIDTYPE_VIU_444) == VIDTYPE_VIU_444) {
-		if ((Y_BUFFER_SIZE < (cd.width * cd.height))) {
-			pr_info
-			    ("[%s::%d] error:data>buf size: %x,%x,%x, %x,%x\n",
-			     __func__, __LINE__, Y_BUFFER_SIZE,
-			     U_BUFFER_SIZE, V_BUFFER_SIZE,
-				cd.width, cd.height);
-			return -1;
-		}
-#ifdef CONFIG_GE2D_KEEP_FRAME
-		ge2d_keeplastframe_block(cur_index, GE2D_FORMAT_M24_YUV444);
-#else
-		if (keep_phy_addr(keep_y_addr) != canvas_get_addr(y_index) &&
-				canvas_dup(keep_phy_addr(keep_y_addr),
-				canvas_get_addr(y_index),
-				(cd.width) * (cd.height))) {
-#ifdef CONFIG_VSYNC_RDMA
-			canvas_update_addr(disp_canvas_index[0][0],
-					   keep_phy_addr(keep_y_addr));
-			canvas_update_addr(disp_canvas_index[1][0],
-					   keep_phy_addr(keep_y_addr));
-#else
-			canvas_update_addr(y_index,
-					keep_phy_addr(keep_y_addr));
-#endif
-		}
-#endif
-		if (debug_flag & DEBUG_FLAG_BLACKOUT)
-			pr_info("%s: VIDTYPE_VIU_444\n", __func__);
-	} else if ((cur_dispbuf->type & VIDTYPE_VIU_NV21) == VIDTYPE_VIU_NV21) {
-		canvas_read(y_index, &cs0);
-		canvas_read(u_index, &cs1);
-		if ((Y_BUFFER_SIZE < (cs0.width * cs0.height))
-		    || (U_BUFFER_SIZE < (cs1.width * cs1.height))) {
-			pr_info("## [%s::%d] error: yuv data size larger",
-				__func__, __LINE__);
-			return -1;
-		}
-#ifdef CONFIG_GE2D_KEEP_FRAME
-		ge2d_keeplastframe_block(cur_index, GE2D_FORMAT_M24_NV21);
-#else
-		if (keep_phy_addr(keep_y_addr) != canvas_get_addr(y_index) &&
-		    canvas_dup(keep_phy_addr(keep_y_addr),
-					canvas_get_addr(y_index),
-					(cs0.width * cs0.height))
-		    && canvas_dup(keep_phy_addr(keep_u_addr),
-					canvas_get_addr(u_index),
-					(cs1.width * cs1.height))) {
-#ifdef CONFIG_VSYNC_RDMA
-			canvas_update_addr(disp_canvas_index[0][0],
-					   keep_phy_addr(keep_y_addr));
-			canvas_update_addr(disp_canvas_index[1][0],
-					   keep_phy_addr(keep_y_addr));
-			canvas_update_addr(disp_canvas_index[0][1],
-					   keep_phy_addr(keep_u_addr));
-			canvas_update_addr(disp_canvas_index[1][1],
-					   keep_phy_addr(keep_u_addr));
-#else
-			canvas_update_addr(y_index,
-				keep_phy_addr(keep_y_addr));
-			canvas_update_addr(u_index,
-				keep_phy_addr(keep_u_addr));
-#endif
-		}
-#endif
-		if (debug_flag & DEBUG_FLAG_BLACKOUT)
-			pr_info("%s: VIDTYPE_VIU_NV21\n", __func__);
-	} else {
-		canvas_read(y_index, &cs0);
-		canvas_read(u_index, &cs1);
-		canvas_read(v_index, &cs2);
-
-		if ((Y_BUFFER_SIZE < (cs0.width * cs0.height))
-		    || (U_BUFFER_SIZE < (cs1.width * cs1.height))
-		    || (V_BUFFER_SIZE < (cs2.width * cs2.height))) {
-			pr_info("## [%s::%d] error: yuv data size larger than buf size: %x,%x,%x, %x,%x, %x,%x, %x,%x,\n",
-			__func__, __LINE__, Y_BUFFER_SIZE,
-			U_BUFFER_SIZE, V_BUFFER_SIZE, cs0.width,
-			cs0.height, cs1.width, cs1.height, cs2.width,
-			cs2.height);
-			return -1;
-		}
-#ifdef CONFIG_GE2D_KEEP_FRAME
-		ge2d_keeplastframe_block(cur_index, GE2D_FORMAT_M24_YUV420);
-#else
-		if (keep_phy_addr(keep_y_addr) != canvas_get_addr(y_index) &&
-			/*must not the same address */
-		    canvas_dup(keep_phy_addr(keep_y_addr),
-					canvas_get_addr(y_index),
-					(cs0.width * cs0.height))
-		    && canvas_dup(keep_phy_addr(keep_u_addr),
-					canvas_get_addr(u_index),
-					(cs1.width * cs1.height))
-			&& canvas_dup(keep_phy_addr(keep_v_addr),
-					canvas_get_addr(v_index),
-					(cs2.width * cs2.height))) {
-#ifdef CONFIG_VSYNC_RDMA
-			canvas_update_addr(disp_canvas_index[0][0],
-					   keep_phy_addr(keep_y_addr));
-			canvas_update_addr(disp_canvas_index[1][0],
-					   keep_phy_addr(keep_y_addr));
-			canvas_update_addr(disp_canvas_index[0][1],
-					   keep_phy_addr(keep_u_addr));
-			canvas_update_addr(disp_canvas_index[1][1],
-					   keep_phy_addr(keep_u_addr));
-			canvas_update_addr(disp_canvas_index[0][2],
-					   keep_phy_addr(keep_v_addr));
-			canvas_update_addr(disp_canvas_index[1][2],
-					   keep_phy_addr(keep_v_addr));
-#else
-			canvas_update_addr(y_index,
-				keep_phy_addr(keep_y_addr));
-			canvas_update_addr(u_index,
-				keep_phy_addr(keep_u_addr));
-			canvas_update_addr(v_index,
-				keep_phy_addr(keep_v_addr));
-#endif
-		}
 
-		if (debug_flag & DEBUG_FLAG_BLACKOUT)
-			pr_info("%s: VIDTYPE_VIU_420\n", __func__);
-#endif
-	}
-	keep_video_on = 1;
-	pr_info("%s: keep video on with keep\n", __func__);
-	return 0;
 
-}
 
 u32 get_blackout_policy(void)
 {
-	return blackout;
+	return blackout | force_blackout;
 }
 EXPORT_SYMBOL(get_blackout_policy);
 
@@ -5293,7 +5119,7 @@ int _video_set_disable(u32 val)
 		if ((disable_video == VIDEO_DISABLE_FORNEXT) && cur_dispbuf
 		    && (cur_dispbuf != &vf_local))
 			video_property_changed = true;
-
+		try_free_keep_video(0);
 	} else {
 		if (cur_dispbuf && (cur_dispbuf != &vf_local))
 			EnableVideoLayer();
@@ -5692,8 +5518,8 @@ static long amvideo_ioctl(struct file *file, unsigned int cmd, ulong arg)
 			source_video_3d_type =
 		VPP_3D_MODE_NULL;
 		else
-			get_vpp_3d_mode(cur_frame_par->trans_fmt,
-		&source_video_3d_type);
+			get_vpp_3d_mode(process_3d_type,
+			cur_frame_par->trans_fmt, &source_video_3d_type);
 		put_user(source_video_3d_type, (u32 __user *)argp);
 	}
 #endif
@@ -5976,12 +5802,16 @@ static ssize_t video_state_show(struct class *cla,
 	len +=
 	    sprintf(buf + len, "pps pre vsc enable %d.\n",
 		    vpp_filter->vpp_pre_vsc_en);
+	len +=
 	    sprintf(buf + len, "hscale filter coef %d.\n",
 		    vpp_filter->vpp_horz_filter);
 	len +=
 	    sprintf(buf + len, "vscale filter coef %d.\n",
 		    vpp_filter->vpp_vert_filter);
 	len +=
+	    sprintf(buf + len, "vpp_vert_chroma_filter_en %d.\n",
+		    vpp_filter->vpp_vert_chroma_filter_en);
+	len +=
 	    sprintf(buf + len, "post_blend_vd_h_start 0x%x.\n",
 		    cur_frame_par->VPP_post_blend_vd_h_start_);
 	len +=
@@ -6171,6 +6001,26 @@ static ssize_t video_blackout_policy_store(struct class *cla,
 	return count;
 }
 
+static ssize_t video_seek_flag_show(struct class *cla,
+					  struct class_attribute *attr,
+					  char *buf)
+{
+	return sprintf(buf, "%d\n", video_seek_flag);
+}
+
+static ssize_t video_seek_flag_store(struct class *cla,
+					   struct class_attribute *attr,
+					   const char *buf, size_t count)
+{
+	size_t r;
+
+	r = sscanf(buf, "%d", &video_seek_flag);
+	if (r != 1)
+		return -EINVAL;
+
+	return count;
+}
+
 static ssize_t video_brightness_show(struct class *cla,
 				     struct class_attribute *attr, char *buf)
 {
@@ -6193,7 +6043,13 @@ static ssize_t video_brightness_store(struct class *cla,
 	if ((r != 1) || (val < -255) || (val > 255))
 		return -EINVAL;
 
-	WRITE_VCBUS_REG_BITS(VPP_VADJ1_Y + cur_dev->vpp_off, val, 8, 9);
+	if (get_cpu_type() <= MESON_CPU_MAJOR_ID_GXTVBB)
+		WRITE_VCBUS_REG_BITS(VPP_VADJ1_Y +
+			cur_dev->vpp_off, val, 8, 9);
+	else
+		WRITE_VCBUS_REG_BITS(VPP_VADJ1_Y +
+			cur_dev->vpp_off, val << 1, 8, 10);
+
 	WRITE_VCBUS_REG(VPP_VADJ_CTRL + cur_dev->vpp_off, VPP_VADJ1_EN);
 
 	return count;
@@ -6248,7 +6104,13 @@ static ssize_t vpp_brightness_store(struct class *cla,
 	if ((r != 1) || (val < -255) || (val > 255))
 		return -EINVAL;
 
-	WRITE_VCBUS_REG_BITS(VPP_VADJ2_Y + cur_dev->vpp_off, val, 8, 9);
+	if (get_cpu_type() <= MESON_CPU_MAJOR_ID_GXTVBB)
+		WRITE_VCBUS_REG_BITS(VPP_VADJ2_Y +
+			cur_dev->vpp_off, val, 8, 9);
+	else
+		WRITE_VCBUS_REG_BITS(VPP_VADJ2_Y +
+			cur_dev->vpp_off, val << 1, 8, 10);
+
 	WRITE_VCBUS_REG(VPP_VADJ_CTRL + cur_dev->vpp_off, VPP_VADJ2_EN);
 
 	return count;
@@ -6502,6 +6364,20 @@ static u32 eight2ten(u32 yuv)
 	return  (y << 20) | (cb << 10) | cr;
 }
 
+static u32 rgb2yuv(u32 rgb)
+{
+	int r = (rgb >> 16) & 0xff;
+	int g = (rgb >> 8) & 0xff;
+	int b = rgb & 0xff;
+	int y, u, v;
+
+	y = ((66*r + 129*g + 25*b + 128) >> 8) + 16;
+	u = ((-38*r - 74*g + 112*b + 128) >> 8) + 128;
+	v = ((112*r - 94*g - 18*b + 128) >> 8) + 128;
+
+	return  (y << 16) | (u << 8) | v;
+}
+
 static ssize_t video_test_screen_store(struct class *cla,
 				       struct class_attribute *attr,
 				       const char *buf, size_t count)
@@ -6511,7 +6387,7 @@ static ssize_t video_test_screen_store(struct class *cla,
 	r = sscanf(buf, "0x%x", &test_screen);
 	if (r != 1)
 		return -EINVAL;
-
+#if 0/*no use now*/
 	/* vdin0 pre post blend enable or disabled */
 	data = READ_VCBUS_REG(VPP_MISC);
 	if (test_screen & 0x01000000)
@@ -6523,6 +6399,7 @@ static ssize_t video_test_screen_store(struct class *cla,
 		data |= VPP_VD1_POSTBLEND;
 	else
 		data &= (~VPP_VD1_POSTBLEND);
+#endif
 	/*
 	   if (test_screen & 0x04000000)
 	   data |= VPP_VD2_PREBLEND;
@@ -6535,28 +6412,25 @@ static ssize_t video_test_screen_store(struct class *cla,
 	   data &= (~VPP_VD2_POSTBLEND);
 	 */
 	/* show test screen  YUV blend*/
-	if (is_meson_gxm_cpu()) {/* bit width change to 10bit in gxm */
+	if (is_meson_gxm_cpu()) /* bit width change to 10bit in gxm */
+		WRITE_VCBUS_REG(VPP_DUMMY_DATA1,
+			eight2ten(test_screen & 0x00ffffff));
+	else if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB)
+		WRITE_VCBUS_REG(VPP_DUMMY_DATA1,
+			yuv2rgb(test_screen & 0x00ffffff));
+	else if (get_cpu_type() < MESON_CPU_MAJOR_ID_GXTVBB)
 		if (READ_VCBUS_REG(VIU_OSD1_BLK0_CFG_W0) & 0x80)
 			WRITE_VCBUS_REG(VPP_DUMMY_DATA1,
-				eight2ten(test_screen & 0x00ffffff));
+				test_screen & 0x00ffffff);
 		else /* RGB blend */
 			WRITE_VCBUS_REG(VPP_DUMMY_DATA1,
-				eight2ten(yuv2rgb(test_screen & 0x00ffffff)));
-	} else {
-		if (READ_VCBUS_REG(VIU_OSD1_BLK0_CFG_W0) & 0x80)
-			WRITE_VCBUS_REG(VPP_DUMMY_DATA1,
-				test_screen & 0x00ffffff);
-		else {/* RGB blend */
-			if (is_meson_txl_cpu())
-				WRITE_VCBUS_REG(VPP_DUMMY_DATA1,
-					test_screen & 0x00ffffff);
-			else
-				WRITE_VCBUS_REG(VPP_DUMMY_DATA1,
 				yuv2rgb(test_screen & 0x00ffffff));
-		}
-	}
+	else
+		WRITE_VCBUS_REG(VPP_DUMMY_DATA1,
+			test_screen & 0x00ffffff);
+#if 0/*no use*/
 	WRITE_VCBUS_REG(VPP_MISC, data);
-
+#endif
 	if (debug_flag & DEBUG_FLAG_BLACKOUT) {
 		pr_info("%s write(VPP_MISC,%x) write(VPP_DUMMY_DATA1, %x)\n",
 		       __func__, data, test_screen & 0x00ffffff);
@@ -6569,12 +6443,13 @@ static ssize_t video_rgb_screen_store(struct class *cla,
 				       const char *buf, size_t count)
 {
 	size_t r;
-	unsigned data = 0x0;
+	/* unsigned data = 0x0; */
 	r = sscanf(buf, "0x%x", &rgb_screen);
 	if (r != 1)
 		return -EINVAL;
 
 	/* vdin0 pre post blend enable or disabled */
+	/*
 	data = READ_VCBUS_REG(VPP_MISC);
 	if (rgb_screen & 0x01000000)
 		data |= VPP_VD1_PREBLEND;
@@ -6585,6 +6460,7 @@ static ssize_t video_rgb_screen_store(struct class *cla,
 		data |= VPP_VD1_POSTBLEND;
 	else
 		data &= (~VPP_VD1_POSTBLEND);
+	*/
 	/*
 	   if (test_screen & 0x04000000)
 	   data |= VPP_VD2_PREBLEND;
@@ -6598,15 +6474,17 @@ static ssize_t video_rgb_screen_store(struct class *cla,
 	 */
 	/* show test screen  YUV blend*/
 	if (is_meson_gxtvbb_cpu())   {
-		if (!(READ_VCBUS_REG(VIU_OSD1_BLK0_CFG_W0) & 0x80))
-			WRITE_VCBUS_REG(VPP_DUMMY_DATA1,
-				rgb_screen & 0x00ffffff);
+		WRITE_VCBUS_REG(VPP_DUMMY_DATA1,
+			rgb_screen & 0x00ffffff);
+	} else if (cpu_after_eq(MESON_CPU_MAJOR_ID_TXL)) {
+		WRITE_VCBUS_REG(VPP_DUMMY_DATA1,
+			rgb2yuv(rgb_screen & 0x00ffffff));
 	}
-	WRITE_VCBUS_REG(VPP_MISC, data);
+	/* WRITE_VCBUS_REG(VPP_MISC, data); */
 
 	if (debug_flag & DEBUG_FLAG_BLACKOUT) {
-		pr_info("%s write(VPP_MISC,%x) write(VPP_DUMMY_DATA1, %x)\n",
-		       __func__, data, rgb_screen & 0x00ffffff);
+		pr_info("%s write(VPP_DUMMY_DATA1, %x)\n",
+		       __func__, rgb_screen & 0x00ffffff);
 	}
 	return count;
 }
@@ -6948,21 +6826,35 @@ static ssize_t vframe_states_show(struct class *cla,
 				"cur vpts=%d\n",
 				timestamp_vpts_get());
 			ret += sprintf(buf + ret,
-				"vf canvas0Addr=%x\n", vf->canvas0Addr);
-			ret += sprintf(buf + ret,
-				"vf canvas1Addr=%x\n", vf->canvas1Addr);
-			ret += sprintf(buf + ret,
-				"vf canvas0Addr.y.addr=%x(%d)\n",
-				canvas_get_addr(
-				canvasY(vf->canvas0Addr)),
-				canvas_get_addr(
-				canvasY(vf->canvas0Addr)));
-			ret += sprintf(buf + ret,
-				"vf canvas0Adr.uv.adr=%x(%d)\n",
-				canvas_get_addr(
-				canvasUV(vf->canvas0Addr)),
-				canvas_get_addr(
-				canvasUV(vf->canvas0Addr)));
+				"vf type=%d\n",
+				vf->type);
+			if (vf->type & VIDTYPE_COMPRESS) {
+				ret += sprintf(buf + ret,
+					"vf compHeadAddr=%x\n",
+						vf->compHeadAddr);
+				ret += sprintf(buf + ret,
+					"vf compBodyAddr =%x\n",
+						vf->compBodyAddr);
+			} else {
+				ret += sprintf(buf + ret,
+					"vf canvas0Addr=%x\n",
+						vf->canvas0Addr);
+				ret += sprintf(buf + ret,
+					"vf canvas1Addr=%x\n",
+						vf->canvas1Addr);
+				ret += sprintf(buf + ret,
+					"vf canvas0Addr.y.addr=%x(%d)\n",
+					canvas_get_addr(
+					canvasY(vf->canvas0Addr)),
+					canvas_get_addr(
+					canvasY(vf->canvas0Addr)));
+				ret += sprintf(buf + ret,
+					"vf canvas0Adr.uv.adr=%x(%d)\n",
+					canvas_get_addr(
+					canvasUV(vf->canvas0Addr)),
+					canvas_get_addr(
+					canvasUV(vf->canvas0Addr)));
+			}
 		}
 		spin_unlock_irqrestore(&lock, flags);
 
@@ -7267,7 +7159,7 @@ static ssize_t video_free_keep_buffer_store(struct class *cla,
 	if (r != 1)
 		return -EINVAL;
 	if (val == 1)
-		try_free_keep_video();
+		try_free_keep_video(1);
 	return count;
 }
 
@@ -7312,6 +7204,10 @@ static struct class_attribute amvideo_class_attrs[] = {
 	       S_IRUGO | S_IWUSR | S_IWGRP,
 	       video_blackout_policy_show,
 	       video_blackout_policy_store),
+	__ATTR(video_seek_flag,
+	       S_IRUGO | S_IWUSR | S_IWGRP,
+	       video_seek_flag_show,
+	       video_seek_flag_store),
 	__ATTR(disable_video,
 	       S_IRUGO | S_IWUSR | S_IWGRP,
 	       video_disable_show,
@@ -7589,10 +7485,6 @@ struct vframe_s *get_cur_dispbuf(void)
 	return cur_dispbuf;
 }
 
-static struct device *amvideo_dev;
-static struct device *amvideo_poll_dev;
-
-
 #ifdef CONFIG_AM_VOUT
 int vout_notify_callback(struct notifier_block *block, unsigned long cmd,
 			 void *para)
@@ -7711,6 +7603,53 @@ static void vout_hook(void)
 }
 #endif
 
+static int amvideo_notify_callback(
+	struct notifier_block *block,
+	unsigned long cmd,
+	void *para)
+{
+	u32 *p, val;
+	switch (cmd) {
+	case AMVIDEO_UPDATE_OSD_MODE:
+		p = (u32 *)para;
+		if (!update_osd_vpp_misc)
+			osd_vpp_misc_mask = p[1];
+		val = osd_vpp_misc
+			& (~osd_vpp_misc_mask);
+		val |= (p[0] & osd_vpp_misc_mask);
+		osd_vpp_misc = val;
+		if (!update_osd_vpp_misc)
+			update_osd_vpp_misc = true;
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static struct notifier_block amvideo_notifier = {
+	.notifier_call = amvideo_notify_callback,
+};
+
+static BLOCKING_NOTIFIER_HEAD(amvideo_notifier_list);
+int amvideo_register_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&amvideo_notifier_list, nb);
+}
+EXPORT_SYMBOL(amvideo_register_client);
+
+int amvideo_unregister_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&amvideo_notifier_list, nb);
+}
+EXPORT_SYMBOL(amvideo_unregister_client);
+
+int amvideo_notifier_call_chain(unsigned long val, void *v)
+{
+	return blocking_notifier_call_chain(&amvideo_notifier_list, val, v);
+}
+EXPORT_SYMBOL_GPL(amvideo_notifier_call_chain);
+
 #if 1		/* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
 
 static void do_vpu_delay_work(struct work_struct *work)
@@ -7917,12 +7856,16 @@ static int __init video_init(void)
 
 	/* check super scaler support status */
 	vpp_super_scaler_support();
+	/* adaptive config bypass ratio */
+	vpp_bypass_ratio_config();
 
 #ifndef CONFIG_AM_VIDEO2
 	/*DisableVPP2VideoLayer();*/
 #endif
 
 	cur_dispbuf = NULL;
+	cur_dispbuf2 = NULL;
+	amvideo_register_client(&amvideo_notifier);
 
 #ifdef FIQ_VSYNC
 	/* enable fiq bridge */
@@ -8050,11 +7993,8 @@ static int __init video_init(void)
 	vf_reg_receiver(&video4osd_vf_recv);
 	switch_dev_register(&video1_state_sdev);
 	switch_set_state(&video1_state_sdev, 0);
-#ifdef CONFIG_GE2D_KEEP_FRAME
-	/* video_frame_getmem(); */
-	ge2d_videotask_init();
-#endif
 
+	video_keeper_init();
 #ifdef CONFIG_AM_VIDEO2
 	set_clone_frame_rate(android_clone_rate, 0);
 #endif
@@ -8077,6 +8017,7 @@ static int __init video_init(void)
 #ifdef FIQ_VSYNC
  err0:
 #endif
+	amvideo_unregister_client(&amvideo_notifier);
 	return r;
 }
 
@@ -8105,10 +8046,7 @@ static void __exit video_exit(void)
 
 	class_unregister(&amvideo_class);
 	class_unregister(&amvideo_poll_class);
-
-#ifdef CONFIG_GE2D_KEEP_FRAME
-	ge2d_videotask_release();
-#endif
+	amvideo_unregister_client(&amvideo_notifier);
 }
 
 
@@ -8192,6 +8130,18 @@ MODULE_PARM_DESC(process_3d_type, "\n process_3d_type\n");
 module_param(process_3d_type, uint, 0664);
 
 
+MODULE_PARM_DESC(framepacking_support, "\n framepacking_support\n");
+module_param(framepacking_support, uint, 0664);
+
+MODULE_PARM_DESC(framepacking_width, "\n framepacking_width\n");
+module_param(framepacking_width, uint, 0664);
+
+MODULE_PARM_DESC(framepacking_height, "\n framepacking_height\n");
+module_param(framepacking_height, uint, 0664);
+
+MODULE_PARM_DESC(framepacking_blank, "\n framepacking_blank\n");
+module_param(framepacking_blank, uint, 0664);
+
 #ifdef TV_REVERSE
 module_param(reverse, bool, 0644);
 MODULE_PARM_DESC(reverse, "reverse /disable reverse");
diff --git a/drivers/amlogic/amports/video.h b/drivers/amlogic/amports/video.h
index e7cd7cf..333202b 100644
--- a/drivers/amlogic/amports/video.h
+++ b/drivers/amlogic/amports/video.h
@@ -71,6 +71,7 @@ extern bool pre_scaler_en;
 
 #define VIU_MISC_AFBC_VD1           (1 << 20)
 
+#define VPP_CM_ENABLE            (1 << 28)
 #define VPP_VD2_ALPHA_WID           9
 #define VPP_VD2_ALPHA_MASK          0x1ff
 #define VPP_VD2_ALPHA_BIT           18
@@ -254,6 +255,10 @@ extern void set_clone_frame_rate(unsigned int frame_rate, unsigned int delay);
 extern void prot_get_parameter(u32 wide_mode, struct vframe_s *vf,
 			       struct vpp_frame_par_s *next_frame_par,
 			       const struct vinfo_s *vinfo);
+u32 get_blackout_policy(void);
+int get_video0_frame_info(struct vframe_s *vf);
+
+
 #endif				/* VIDEO_H */
 
-u32 get_blackout_policy(void);
+
diff --git a/drivers/amlogic/amports/video_keeper.c b/drivers/amlogic/amports/video_keeper.c
new file mode 100644
index 0000000..d89a1b7
--- /dev/null
+++ b/drivers/amlogic/amports/video_keeper.c
@@ -0,0 +1,993 @@
+/*
+ * drivers/amlogic/amports/video_keeper.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/ctype.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/timestamp.h>
+#include <linux/amlogic/amports/tsync.h>
+
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/amlogic/amports/amstream.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/clk.h>
+#include <linux/amlogic/gpio-amlogic.h>
+#include <linux/amlogic/canvas/canvas.h>
+#include <linux/amlogic/canvas/canvas_mgr.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-contiguous.h>
+#ifdef CONFIG_GE2D_KEEP_FRAME
+#include <linux/amlogic/ge2d/ge2d.h>
+#include <linux/amlogic/canvas/canvas_mgr.h>
+#endif
+#include <linux/amlogic/codec_mm/codec_mm.h>
+#include <linux/amlogic/codec_mm/codec_mm_keeper.h>
+
+#include "amports_priv.h"
+#include "video_priv.h"
+#include "video_keeper.h"
+#include "arch/register.h"
+#include "vpp.h"
+#include "video.h"
+#include "vdec_reg.h"
+
+#define MEM_NAME "video-keeper"
+
+static unsigned long keep_y_addr, keep_u_addr, keep_v_addr;
+static int keep_video_on;
+static int keep_id;
+
+#define Y_BUFFER_SIZE   0x400000	/* for 1920*1088 */
+#define U_BUFFER_SIZE   0x100000	/* compatible with NV21 */
+#define V_BUFFER_SIZE   0x80000
+
+#define RESERVE_CLR_FRAME
+
+static inline ulong keep_phy_addr(unsigned long addr)
+{
+	return addr;
+}
+
+#ifdef CONFIG_GE2D_KEEP_FRAME
+static int display_canvas_y_dup;
+static int display_canvas_u_dup;
+static int display_canvas_v_dup;
+static struct ge2d_context_s *ge2d_video_context;
+
+static int ge2d_videotask_init(void)
+{
+	const char *keep_owner = "keepframe";
+	if (ge2d_video_context == NULL)
+		ge2d_video_context = create_ge2d_work_queue();
+
+	if (ge2d_video_context == NULL) {
+		pr_info("create_ge2d_work_queue video task failed\n");
+		return -1;
+	}
+	if (!display_canvas_y_dup)
+		display_canvas_y_dup = canvas_pool_map_alloc_canvas(keep_owner);
+	if (!display_canvas_u_dup)
+		display_canvas_u_dup = canvas_pool_map_alloc_canvas(keep_owner);
+	if (!display_canvas_v_dup)
+		display_canvas_v_dup = canvas_pool_map_alloc_canvas(keep_owner);
+	pr_info("create_ge2d_work_queue video task ok\n");
+
+	return 0;
+}
+
+
+
+static int ge2d_videotask_release(void)
+{
+	if (ge2d_video_context) {
+		destroy_ge2d_work_queue(ge2d_video_context);
+		ge2d_video_context = NULL;
+	}
+	if (display_canvas_y_dup)
+		canvas_pool_map_free_canvas(display_canvas_y_dup);
+	if (display_canvas_u_dup)
+		canvas_pool_map_free_canvas(display_canvas_u_dup);
+	if (display_canvas_v_dup)
+		canvas_pool_map_free_canvas(display_canvas_v_dup);
+
+	return 0;
+}
+
+static int ge2d_store_frame_YUV444(u32 cur_index)
+{
+	u32 y_index, des_index, src_index;
+	struct canvas_s cs, cd;
+	ulong yaddr;
+	u32 ydupindex;
+	struct config_para_ex_s ge2d_config;
+	memset(&ge2d_config, 0, sizeof(struct config_para_ex_s));
+
+	ydupindex = display_canvas_y_dup;
+
+	pr_info("ge2d_store_frame_YUV444 cur_index:s:0x%x\n", cur_index);
+	/* pr_info("ge2d_store_frame cur_index:d:0x%x\n", canvas_tab[0]); */
+	y_index = cur_index & 0xff;
+	canvas_read(y_index, &cs);
+
+	yaddr = keep_phy_addr(keep_y_addr);
+	canvas_config(ydupindex,
+		      (ulong) yaddr,
+		      cs.width, cs.height, CANVAS_ADDR_NOWRAP, cs.blkmode);
+
+	canvas_read(ydupindex, &cd);
+	src_index = y_index;
+	des_index = ydupindex;
+
+	pr_info("ge2d_canvas_dup ADDR srcy[0x%lx] des[0x%lx]\n", cs.addr,
+	       cd.addr);
+
+	ge2d_config.alu_const_color = 0;
+	ge2d_config.bitmask_en = 0;
+	ge2d_config.src1_gb_alpha = 0;
+
+	ge2d_config.src_planes[0].addr = cs.addr;
+	ge2d_config.src_planes[0].w = cs.width;
+	ge2d_config.src_planes[0].h = cs.height;
+
+	ge2d_config.dst_planes[0].addr = cd.addr;
+	ge2d_config.dst_planes[0].w = cd.width;
+	ge2d_config.dst_planes[0].h = cd.height;
+
+	ge2d_config.src_para.canvas_index = src_index;
+	ge2d_config.src_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config.src_para.format = GE2D_FORMAT_M24_YUV444;
+	ge2d_config.src_para.fill_color_en = 0;
+	ge2d_config.src_para.fill_mode = 0;
+	ge2d_config.src_para.color = 0;
+	ge2d_config.src_para.top = 0;
+	ge2d_config.src_para.left = 0;
+	ge2d_config.src_para.width = cs.width;
+	ge2d_config.src_para.height = cs.height;
+	ge2d_config.src2_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config.dst_para.canvas_index = des_index;
+	ge2d_config.dst_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config.dst_para.format = GE2D_FORMAT_M24_YUV444;
+	ge2d_config.dst_para.fill_color_en = 0;
+	ge2d_config.dst_para.fill_mode = 0;
+	ge2d_config.dst_para.color = 0;
+	ge2d_config.dst_para.top = 0;
+	ge2d_config.dst_para.left = 0;
+	ge2d_config.dst_para.width = cs.width;
+	ge2d_config.dst_para.height = cs.height;
+
+	if (ge2d_context_config_ex(ge2d_video_context, &ge2d_config) < 0) {
+		pr_info("ge2d_context_config_ex failed\n");
+		return -1;
+	}
+
+	stretchblt_noalpha(ge2d_video_context, 0, 0, cs.width, cs.height,
+			   0, 0, cs.width, cs.height);
+
+	return 0;
+}
+
+/* static u32 canvas_tab[1]; */
+static int ge2d_store_frame_NV21(u32 cur_index)
+{
+	u32 y_index, u_index, des_index, src_index;
+	struct canvas_s cs0, cs1, cd;
+	ulong yaddr, uaddr;
+	u32 ydupindex, udupindex;
+	struct config_para_ex_s ge2d_config;
+	memset(&ge2d_config, 0, sizeof(struct config_para_ex_s));
+
+	ydupindex = display_canvas_y_dup;
+	udupindex = display_canvas_u_dup;
+
+	pr_info("ge2d_store_frame_NV21 cur_index:s:0x%x\n", cur_index);
+
+	/* pr_info("ge2d_store_frame cur_index:d:0x%x\n", canvas_tab[0]); */
+	yaddr = keep_phy_addr(keep_y_addr);
+	uaddr = keep_phy_addr(keep_u_addr);
+
+	y_index = cur_index & 0xff;
+	u_index = (cur_index >> 8) & 0xff;
+
+	canvas_read(y_index, &cs0);
+	canvas_read(u_index, &cs1);
+	canvas_config(ydupindex,
+		      (ulong) yaddr,
+		      cs0.width, cs0.height, CANVAS_ADDR_NOWRAP, cs0.blkmode);
+	canvas_config(udupindex,
+		      (ulong) uaddr,
+		      cs1.width, cs1.height, CANVAS_ADDR_NOWRAP, cs1.blkmode);
+
+	canvas_read(ydupindex, &cd);
+	src_index = ((y_index & 0xff) | ((u_index << 8) & 0x0000ff00));
+	des_index = ((ydupindex & 0xff) | ((udupindex << 8) & 0x0000ff00));
+
+	pr_info("ge2d_store_frame d:0x%x\n", des_index);
+
+	ge2d_config.alu_const_color = 0;
+	ge2d_config.bitmask_en = 0;
+	ge2d_config.src1_gb_alpha = 0;
+
+	ge2d_config.src_planes[0].addr = cs0.addr;
+	ge2d_config.src_planes[0].w = cs0.width;
+	ge2d_config.src_planes[0].h = cs0.height;
+	ge2d_config.src_planes[1].addr = cs1.addr;
+	ge2d_config.src_planes[1].w = cs1.width;
+	ge2d_config.src_planes[1].h = cs1.height;
+
+	ge2d_config.dst_planes[0].addr = cd.addr;
+	ge2d_config.dst_planes[0].w = cd.width;
+	ge2d_config.dst_planes[0].h = cd.height;
+
+	ge2d_config.src_para.canvas_index = src_index;
+	ge2d_config.src_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config.src_para.format = GE2D_FORMAT_M24_NV21;
+	ge2d_config.src_para.fill_color_en = 0;
+	ge2d_config.src_para.fill_mode = 0;
+	ge2d_config.src_para.color = 0;
+	ge2d_config.src_para.top = 0;
+	ge2d_config.src_para.left = 0;
+	ge2d_config.src_para.width = cs0.width;
+	ge2d_config.src_para.height = cs0.height;
+	ge2d_config.src2_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config.dst_para.canvas_index = des_index;
+	ge2d_config.dst_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config.dst_para.format = GE2D_FORMAT_M24_NV21;
+	ge2d_config.dst_para.fill_color_en = 0;
+	ge2d_config.dst_para.fill_mode = 0;
+	ge2d_config.dst_para.color = 0;
+	ge2d_config.dst_para.top = 0;
+	ge2d_config.dst_para.left = 0;
+	ge2d_config.dst_para.width = cs0.width;
+	ge2d_config.dst_para.height = cs0.height;
+
+	if (ge2d_context_config_ex(ge2d_video_context, &ge2d_config) < 0) {
+		pr_info("ge2d_context_config_ex failed\n");
+		return -1;
+	}
+
+	stretchblt_noalpha(ge2d_video_context, 0, 0, cs0.width, cs0.height,
+			   0, 0, cs0.width, cs0.height);
+
+	return 0;
+}
+
+/* static u32 canvas_tab[1]; */
+static int ge2d_store_frame_YUV420(u32 cur_index)
+{
+	u32 y_index, u_index, v_index;
+	struct canvas_s cs, cd;
+	ulong yaddr, uaddr, vaddr;
+	u32 ydupindex, udupindex, vdupindex;
+	struct config_para_ex_s ge2d_config;
+	memset(&ge2d_config, 0, sizeof(struct config_para_ex_s));
+
+	ydupindex = display_canvas_y_dup;
+	udupindex = display_canvas_u_dup;
+	vdupindex = display_canvas_v_dup;
+
+	pr_info("ge2d_store_frame_YUV420 cur_index:s:0x%x\n", cur_index);
+	/* operation top line */
+	/* Y data */
+	ge2d_config.alu_const_color = 0;
+	ge2d_config.bitmask_en = 0;
+	ge2d_config.src1_gb_alpha = 0;
+
+	y_index = cur_index & 0xff;
+	canvas_read(y_index, &cs);
+	ge2d_config.src_planes[0].addr = cs.addr;
+	ge2d_config.src_planes[0].w = cs.width;
+	ge2d_config.src_planes[0].h = cs.height;
+	ge2d_config.src_planes[1].addr = 0;
+	ge2d_config.src_planes[1].w = 0;
+	ge2d_config.src_planes[1].h = 0;
+	ge2d_config.src_planes[2].addr = 0;
+	ge2d_config.src_planes[2].w = 0;
+	ge2d_config.src_planes[2].h = 0;
+
+	yaddr = keep_phy_addr(keep_y_addr);
+	canvas_config(ydupindex,
+		      (ulong) yaddr,
+		      cs.width, cs.height, CANVAS_ADDR_NOWRAP, cs.blkmode);
+	canvas_read(ydupindex, &cd);
+	ge2d_config.dst_planes[0].addr = cd.addr;
+	ge2d_config.dst_planes[0].w = cd.width;
+	ge2d_config.dst_planes[0].h = cd.height;
+	ge2d_config.dst_planes[1].addr = 0;
+	ge2d_config.dst_planes[1].w = 0;
+	ge2d_config.dst_planes[1].h = 0;
+	ge2d_config.dst_planes[2].addr = 0;
+	ge2d_config.dst_planes[2].w = 0;
+	ge2d_config.dst_planes[2].h = 0;
+
+	ge2d_config.src_key.key_enable = 0;
+	ge2d_config.src_key.key_mask = 0;
+	ge2d_config.src_key.key_mode = 0;
+	ge2d_config.src_key.key_color = 0;
+
+	ge2d_config.src_para.canvas_index = y_index;
+	ge2d_config.src_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config.src_para.format = GE2D_FMT_S8_Y;
+	ge2d_config.src_para.fill_color_en = 0;
+	ge2d_config.src_para.fill_mode = 0;
+	ge2d_config.src_para.x_rev = 0;
+	ge2d_config.src_para.y_rev = 0;
+	ge2d_config.src_para.color = 0;
+	ge2d_config.src_para.top = 0;
+	ge2d_config.src_para.left = 0;
+	ge2d_config.src_para.width = cs.width;
+	ge2d_config.src_para.height = cs.height;
+	ge2d_config.src2_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config.dst_para.canvas_index = ydupindex;
+	ge2d_config.dst_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config.dst_para.format = GE2D_FMT_S8_Y;
+	ge2d_config.dst_para.fill_color_en = 0;
+	ge2d_config.dst_para.fill_mode = 0;
+	ge2d_config.dst_para.x_rev = 0;
+	ge2d_config.dst_para.y_rev = 0;
+	ge2d_config.dst_xy_swap = 0;
+	ge2d_config.dst_para.color = 0;
+	ge2d_config.dst_para.top = 0;
+	ge2d_config.dst_para.left = 0;
+	ge2d_config.dst_para.width = cs.width;
+	ge2d_config.dst_para.height = cs.height;
+
+	if (ge2d_context_config_ex(ge2d_video_context, &ge2d_config) < 0) {
+		pr_info("++ge2d configing error.\n");
+		return -1;
+	}
+	stretchblt_noalpha(ge2d_video_context, 0, 0, cs.width, cs.height, 0, 0,
+			   cs.width, cs.height);
+
+	/* U data */
+	ge2d_config.alu_const_color = 0;
+	ge2d_config.bitmask_en = 0;
+	ge2d_config.src1_gb_alpha = 0;
+
+	u_index = (cur_index >> 8) & 0xff;
+	canvas_read(u_index, &cs);
+	ge2d_config.src_planes[0].addr = cs.addr;
+	ge2d_config.src_planes[0].w = cs.width;
+	ge2d_config.src_planes[0].h = cs.height;
+	ge2d_config.src_planes[1].addr = 0;
+	ge2d_config.src_planes[1].w = 0;
+	ge2d_config.src_planes[1].h = 0;
+	ge2d_config.src_planes[2].addr = 0;
+	ge2d_config.src_planes[2].w = 0;
+	ge2d_config.src_planes[2].h = 0;
+
+	uaddr = keep_phy_addr(keep_u_addr);
+	canvas_config(udupindex,
+		      (ulong) uaddr,
+		      cs.width, cs.height, CANVAS_ADDR_NOWRAP, cs.blkmode);
+	canvas_read(udupindex, &cd);
+	ge2d_config.dst_planes[0].addr = cd.addr;
+	ge2d_config.dst_planes[0].w = cd.width;
+	ge2d_config.dst_planes[0].h = cd.height;
+	ge2d_config.dst_planes[1].addr = 0;
+	ge2d_config.dst_planes[1].w = 0;
+	ge2d_config.dst_planes[1].h = 0;
+	ge2d_config.dst_planes[2].addr = 0;
+	ge2d_config.dst_planes[2].w = 0;
+	ge2d_config.dst_planes[2].h = 0;
+
+	ge2d_config.src_key.key_enable = 0;
+	ge2d_config.src_key.key_mask = 0;
+	ge2d_config.src_key.key_mode = 0;
+	ge2d_config.src_key.key_color = 0;
+
+	ge2d_config.src_para.canvas_index = u_index;
+	ge2d_config.src_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config.src_para.format = GE2D_FMT_S8_CB;
+	ge2d_config.src_para.fill_color_en = 0;
+	ge2d_config.src_para.fill_mode = 0;
+	ge2d_config.src_para.x_rev = 0;
+	ge2d_config.src_para.y_rev = 0;
+	ge2d_config.src_para.color = 0;
+	ge2d_config.src_para.top = 0;
+	ge2d_config.src_para.left = 0;
+	ge2d_config.src_para.width = cs.width;
+	ge2d_config.src_para.height = cs.height;
+
+	ge2d_config.dst_para.canvas_index = udupindex;
+	ge2d_config.dst_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config.dst_para.format = GE2D_FMT_S8_CB;
+	ge2d_config.dst_para.fill_color_en = 0;
+	ge2d_config.dst_para.fill_mode = 0;
+	ge2d_config.dst_para.x_rev = 0;
+	ge2d_config.dst_para.y_rev = 0;
+	ge2d_config.dst_xy_swap = 0;
+	ge2d_config.dst_para.color = 0;
+	ge2d_config.dst_para.top = 0;
+	ge2d_config.dst_para.left = 0;
+	ge2d_config.dst_para.width = cs.width;
+	ge2d_config.dst_para.height = cs.height;
+
+	if (ge2d_context_config_ex(ge2d_video_context, &ge2d_config) < 0) {
+		pr_info("++ge2d configing error.\n");
+		return -1;
+	}
+	stretchblt_noalpha(ge2d_video_context, 0, 0, cs.width, cs.height, 0, 0,
+			   cs.width, cs.height);
+
+	/* operation top line */
+	/* V data */
+	ge2d_config.alu_const_color = 0;
+	ge2d_config.bitmask_en = 0;
+	ge2d_config.src1_gb_alpha = 0;
+
+	v_index = (cur_index >> 16) & 0xff;
+	canvas_read(v_index, &cs);
+	ge2d_config.src_planes[0].addr = cs.addr;
+	ge2d_config.src_planes[0].w = cs.width;
+	ge2d_config.src_planes[0].h = cs.height;
+	ge2d_config.src_planes[1].addr = 0;
+	ge2d_config.src_planes[1].w = 0;
+	ge2d_config.src_planes[1].h = 0;
+	ge2d_config.src_planes[2].addr = 0;
+	ge2d_config.src_planes[2].w = 0;
+	ge2d_config.src_planes[2].h = 0;
+
+	vaddr = keep_phy_addr(keep_v_addr);
+	canvas_config(vdupindex,
+		      (ulong) vaddr,
+		      cs.width, cs.height, CANVAS_ADDR_NOWRAP, cs.blkmode);
+	ge2d_config.dst_planes[0].addr = cd.addr;
+	ge2d_config.dst_planes[0].w = cd.width;
+	ge2d_config.dst_planes[0].h = cd.height;
+	ge2d_config.dst_planes[1].addr = 0;
+	ge2d_config.dst_planes[1].w = 0;
+	ge2d_config.dst_planes[1].h = 0;
+	ge2d_config.dst_planes[2].addr = 0;
+	ge2d_config.dst_planes[2].w = 0;
+	ge2d_config.dst_planes[2].h = 0;
+
+	ge2d_config.src_key.key_enable = 0;
+	ge2d_config.src_key.key_mask = 0;
+	ge2d_config.src_key.key_mode = 0;
+	ge2d_config.src_key.key_color = 0;
+
+	ge2d_config.src_para.canvas_index = v_index;
+	ge2d_config.src_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config.src_para.format = GE2D_FMT_S8_CR;
+	ge2d_config.src_para.fill_color_en = 0;
+	ge2d_config.src_para.fill_mode = 0;
+	ge2d_config.src_para.x_rev = 0;
+	ge2d_config.src_para.y_rev = 0;
+	ge2d_config.src_para.color = 0;
+	ge2d_config.src_para.top = 0;
+	ge2d_config.src_para.left = 0;
+	ge2d_config.src_para.width = cs.width;
+	ge2d_config.src_para.height = cs.height;
+
+	ge2d_config.dst_para.canvas_index = vdupindex;
+	ge2d_config.dst_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config.dst_para.format = GE2D_FMT_S8_CR;
+	ge2d_config.dst_para.fill_color_en = 0;
+	ge2d_config.dst_para.fill_mode = 0;
+	ge2d_config.dst_para.x_rev = 0;
+	ge2d_config.dst_para.y_rev = 0;
+	ge2d_config.dst_xy_swap = 0;
+	ge2d_config.dst_para.color = 0;
+	ge2d_config.dst_para.top = 0;
+	ge2d_config.dst_para.left = 0;
+	ge2d_config.dst_para.width = cs.width;
+	ge2d_config.dst_para.height = cs.height;
+
+	if (ge2d_context_config_ex(ge2d_video_context, &ge2d_config) < 0) {
+		pr_info("++ge2d configing error.\n");
+		return -1;
+	}
+	stretchblt_noalpha(ge2d_video_context, 0, 0, cs.width, cs.height, 0, 0,
+			   cs.width, cs.height);
+	return 0;
+}
+
+static void ge2d_keeplastframe_block(int cur_index, int format)
+{
+	/* u32 cur_index; */
+	u32 y_index, u_index, v_index;
+#ifdef CONFIG_VSYNC_RDMA
+	u32 y_index2, u_index2, v_index2;
+#endif
+
+	video_module_lock();
+
+#ifdef CONFIG_VSYNC_RDMA
+	y_index = disp_canvas_index[0][0];
+	y_index2 = disp_canvas_index[1][0];
+	u_index = disp_canvas_index[0][1];
+	u_index2 = disp_canvas_index[1][1];
+	v_index = disp_canvas_index[0][2];
+	v_index2 = disp_canvas_index[1][2];
+#else
+	/* cur_index = READ_VCBUS_REG(VD1_IF0_CANVAS0 +
+		get_video_cur_dev->viu_off); */
+	y_index = cur_index & 0xff;
+	u_index = (cur_index >> 8) & 0xff;
+	v_index = (cur_index >> 16) & 0xff;
+#endif
+
+	switch (format) {
+	case GE2D_FORMAT_M24_YUV444:
+		ge2d_store_frame_YUV444(cur_index);
+		canvas_update_addr(y_index, keep_phy_addr(keep_y_addr));
+#ifdef CONFIG_VSYNC_RDMA
+		canvas_update_addr(y_index2, keep_phy_addr(keep_y_addr));
+#endif
+		break;
+	case GE2D_FORMAT_M24_NV21:
+		ge2d_store_frame_NV21(cur_index);
+		canvas_update_addr(y_index, keep_phy_addr(keep_y_addr));
+		canvas_update_addr(u_index, keep_phy_addr(keep_u_addr));
+#ifdef CONFIG_VSYNC_RDMA
+		canvas_update_addr(y_index2, keep_phy_addr(keep_y_addr));
+		canvas_update_addr(u_index2, keep_phy_addr(keep_u_addr));
+#endif
+		break;
+	case GE2D_FORMAT_M24_YUV420:
+		ge2d_store_frame_YUV420(cur_index);
+		canvas_update_addr(y_index, keep_phy_addr(keep_y_addr));
+		canvas_update_addr(u_index, keep_phy_addr(keep_u_addr));
+		canvas_update_addr(v_index, keep_phy_addr(keep_v_addr));
+#ifdef CONFIG_VSYNC_RDMA
+		canvas_update_addr(y_index2, keep_phy_addr(keep_y_addr));
+		canvas_update_addr(u_index2, keep_phy_addr(keep_u_addr));
+		canvas_update_addr(v_index2, keep_phy_addr(keep_v_addr));
+#endif
+		break;
+	default:
+		break;
+	}
+	video_module_unlock();
+
+}
+
+#endif
+static int canvas_dup(ulong dst, ulong src_paddr, ulong size)
+{
+	void *src_addr = codec_mm_phys_to_virt(src_paddr);
+	void *dst_addr = codec_mm_phys_to_virt(dst);
+
+	if (src_paddr && dst && src_addr && dst_addr) {
+		dma_addr_t dma_addr = 0;
+		memcpy(dst_addr, src_addr, size);
+		dma_addr = dma_map_single(
+					amports_get_dma_device(), dst_addr,
+					size, DMA_TO_DEVICE);
+		dma_unmap_single(amports_get_dma_device(), dma_addr,
+					FETCHBUF_SIZE, DMA_TO_DEVICE);
+		return 1;
+	}
+
+	return 0;
+}
+
+
+
+#ifdef RESERVE_CLR_FRAME
+static int free_alloced_keep_buffer(void)
+{
+	pr_info("free_alloced_keep_buffer %p.%p.%p\n",
+		(void *)keep_y_addr, (void *)keep_u_addr, (void *)keep_v_addr);
+	if (keep_y_addr) {
+		codec_mm_free_for_dma(MEM_NAME, keep_y_addr);
+		keep_y_addr = 0;
+	}
+
+	if (keep_u_addr) {
+		codec_mm_free_for_dma(MEM_NAME, keep_u_addr);
+		keep_u_addr = 0;
+	}
+
+	if (keep_v_addr) {
+		codec_mm_free_for_dma(MEM_NAME, keep_v_addr);
+		keep_v_addr = 0;
+	}
+	return 0;
+}
+
+static int alloc_keep_buffer(void)
+{
+	int flags = CODEC_MM_FLAGS_DMA |
+		CODEC_MM_FLAGS_FOR_VDECODER;
+#ifndef CONFIG_GE2D_KEEP_FRAME
+	/*
+		if not used ge2d.
+		need CPU access.
+	*/
+	flags = CODEC_MM_FLAGS_DMA_CPU |
+	CODEC_MM_FLAGS_FOR_VDECODER;
+#endif
+	if (!keep_y_addr) {
+		keep_y_addr = codec_mm_alloc_for_dma(
+				MEM_NAME,
+				PAGE_ALIGN(Y_BUFFER_SIZE)/PAGE_SIZE, 0, flags);
+		if (!keep_y_addr) {
+			pr_err("%s: failed to alloc y addr\n", __func__);
+			goto err1;
+		}
+	}
+
+	if (!keep_u_addr) {
+		keep_u_addr = codec_mm_alloc_for_dma(
+				MEM_NAME,
+				PAGE_ALIGN(U_BUFFER_SIZE)/PAGE_SIZE, 0, flags);
+		if (!keep_u_addr) {
+			pr_err("%s: failed to alloc u addr\n", __func__);
+			goto err1;
+		}
+	}
+
+	if (!keep_v_addr) {
+		keep_v_addr = codec_mm_alloc_for_dma(
+				MEM_NAME,
+				PAGE_ALIGN(V_BUFFER_SIZE)/PAGE_SIZE, 0, flags);
+		if (!keep_v_addr) {
+			pr_err("%s: failed to alloc v addr\n", __func__);
+			goto err1;
+		}
+	}
+	pr_info("alloced keep buffer yaddr=%p,u_addr=%p,v_addr=%p\n",
+		(void *)keep_y_addr,
+		(void *)keep_u_addr,
+		(void *)keep_v_addr);
+	return 0;
+
+ err1:
+	free_alloced_keep_buffer();
+	return -ENOMEM;
+}
+
+
+/*
+flags,used per bit:
+deflaut free alloced keeper buffer.
+0x1: free scatters keeper..
+0x2:
+*/
+void try_free_keep_video(int flags)
+{
+	int free_scatter_keeper = flags & 0x1;
+	if (keep_video_on || free_scatter_keeper) {
+		pr_info("disbled keep video before free keep buffer.\n");
+		keep_video_on = 0;
+		update_cur_dispbuf(NULL);
+		if (!get_video_enabled()) {
+			/*if not disable video,changed to 2 for */
+			pr_info("disbled video for next before free keep buffer!\n");
+			_video_set_disable(VIDEO_DISABLE_FORNEXT);
+		} else if (get_video_enabled()) {
+			safe_disble_videolayer();
+		}
+	}
+	if (free_scatter_keeper && keep_id > 0) {
+		pr_info("try_free_keep_video keepid\n");
+		codec_mm_keeper_unmask_keeper(keep_id, 0);
+		keep_id = -1;
+	}
+	free_alloced_keep_buffer();
+	return;
+}
+#endif
+
+void get_video_keep_buffer(ulong *addr, ulong *phys_addr)
+{
+#if 1
+	if (addr) {
+		addr[0] = (ulong) 0;
+		addr[1] = (ulong) 0;
+		addr[2] = (ulong) 0;
+	}
+
+	if (phys_addr) {
+		if (!keep_y_addr || !keep_u_addr || !keep_v_addr)
+			alloc_keep_buffer();
+		phys_addr[0] = keep_y_addr;
+		phys_addr[1] = keep_u_addr;
+		phys_addr[2] = keep_v_addr;
+	}
+#endif
+	if (get_video_debug_flags() & DEBUG_FLAG_BLACKOUT) {
+		pr_info("%s: y=%lx u=%lx v=%lx\n", __func__, phys_addr[0],
+		       phys_addr[1], phys_addr[2]);
+	}
+}
+
+void video_keeper_new_frame_notify(void)
+{
+	if (keep_video_on) {
+		pr_info("new toggle keep_id\n");
+		keep_video_on = 0;
+	}
+	if (keep_id > 0) {
+		/*wait 80 ms for vsync post.*/
+		pr_info("new frame show, free keeper\n");
+		codec_mm_keeper_unmask_keeper(keep_id, 120);
+		keep_id = -1;
+	}
+	return;
+}
+unsigned int vf_keep_current(struct vframe_s *cur_dispbuf)
+{
+	u32 cur_index;
+	u32 y_index, u_index, v_index;
+	struct canvas_s cs0, cs1, cs2, cd;
+
+	if (!cur_dispbuf) {
+		pr_info("keep exit without cur_dispbuf\n");
+		return 0;
+	}
+
+	if (cur_dispbuf->source_type == VFRAME_SOURCE_TYPE_OSD) {
+		pr_info("keep exit is osd\n");
+		return 0;
+	}
+	if (READ_VCBUS_REG(DI_IF1_GEN_REG) & 0x1) {
+		pr_info("keep exit is di\n");
+		return 0;
+	}
+	if (get_video_debug_flags() & DEBUG_FLAG_TOGGLE_SKIP_KEEP_CURRENT) {
+		pr_info("keep exit is skip current\n");
+		return 0;
+	}
+
+#ifdef CONFIG_AM_VIDEOCAPTURE
+	ext_frame_capture_poll(1);	/*pull  if have capture end frame */
+#endif
+	if (get_blackout_policy()) {
+		pr_info("keep exit is skip current\n");
+		return 0;
+	}
+
+	if (0 == (READ_VCBUS_REG(VPP_MISC + get_video_cur_dev()->vpp_off) &
+		VPP_VD1_POSTBLEND)) {
+		pr_info("keep exit is skip VPP_VD1_POSTBLEND\n");
+		return 0;
+	}
+	if (1) {
+		int ret;
+		int old_keep = keep_id;
+		int type = MEM_TYPE_CODEC_MM;
+		if (cur_dispbuf->type & VIDTYPE_SCATTER)
+			type = MEM_TYPE_CODEC_MM_SCATTER;
+		ret = codec_mm_keeper_mask_keep_mem(cur_dispbuf->mem_handle,
+			type);
+		if (ret > 0) {
+			keep_id = ret;
+			if (old_keep > 0 && keep_id != old_keep) {
+				/*wait 80 ms for vsync post.*/
+				codec_mm_keeper_unmask_keeper(old_keep, 120);
+			}
+		}
+	}
+	if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) &&
+		(cur_dispbuf->type & VIDTYPE_COMPRESS)) {
+		/* todo: duplicate compressed video frame */
+		pr_info("keep exit is skip VIDTYPE_COMPRESS\n");
+		return -1;
+	}
+	cur_index = READ_VCBUS_REG(VD1_IF0_CANVAS0 +
+					get_video_cur_dev()->viu_off);
+	y_index = cur_index & 0xff;
+	u_index = (cur_index >> 8) & 0xff;
+	v_index = (cur_index >> 16) & 0xff;
+	canvas_read(y_index, &cd);
+
+	if ((cd.width * cd.height) <= 2048 * 1088 &&
+			!keep_y_addr) {
+		alloc_keep_buffer();
+	}
+	if (!keep_y_addr
+	    || (cur_dispbuf->type & VIDTYPE_VIU_422) == VIDTYPE_VIU_422) {
+		/* no support VIDTYPE_VIU_422... */
+		pr_info("%s:no support VIDTYPE_VIU_422\n", __func__);
+		return -1;
+	}
+
+
+	if (get_video_debug_flags() & DEBUG_FLAG_BLACKOUT) {
+		pr_info("%s keep_y_addr=%p %x\n", __func__, (void *)keep_y_addr,
+		       canvas_get_addr(y_index));
+	}
+
+	if ((cur_dispbuf->type & VIDTYPE_VIU_422) == VIDTYPE_VIU_422) {
+		return -1;
+		/* no VIDTYPE_VIU_422 type frame need keep,avoid memcpy crash*/
+		if ((Y_BUFFER_SIZE < (cd.width * cd.height))) {
+			pr_info("[%s::%d]data > buf size: %x,%x,%x, %x,%x\n",
+				__func__, __LINE__, Y_BUFFER_SIZE,
+				U_BUFFER_SIZE, V_BUFFER_SIZE,
+				cd.width, cd.height);
+			return -1;
+		}
+		if (keep_phy_addr(keep_y_addr) != canvas_get_addr(y_index) &&
+				canvas_dup(keep_phy_addr(keep_y_addr),
+				canvas_get_addr(y_index),
+				(cd.width) * (cd.height))) {
+#ifdef CONFIG_VSYNC_RDMA
+			canvas_update_addr(disp_canvas_index[0][0],
+					   keep_phy_addr(keep_y_addr));
+			canvas_update_addr(disp_canvas_index[1][0],
+					   keep_phy_addr(keep_y_addr));
+#else
+			canvas_update_addr(y_index,
+				keep_phy_addr(keep_y_addr));
+#endif
+			if (get_video_debug_flags() & DEBUG_FLAG_BLACKOUT)
+				pr_info("%s: VIDTYPE_VIU_422\n", __func__);
+		}
+	} else if ((cur_dispbuf->type & VIDTYPE_VIU_444) == VIDTYPE_VIU_444) {
+		if ((Y_BUFFER_SIZE < (cd.width * cd.height))) {
+			pr_info
+			    ("[%s::%d] error:data>buf size: %x,%x,%x, %x,%x\n",
+			     __func__, __LINE__, Y_BUFFER_SIZE,
+			     U_BUFFER_SIZE, V_BUFFER_SIZE,
+				cd.width, cd.height);
+			return -1;
+		}
+#ifdef CONFIG_GE2D_KEEP_FRAME
+		ge2d_keeplastframe_block(cur_index, GE2D_FORMAT_M24_YUV444);
+#else
+		if (keep_phy_addr(keep_y_addr) != canvas_get_addr(y_index) &&
+				canvas_dup(keep_phy_addr(keep_y_addr),
+				canvas_get_addr(y_index),
+				(cd.width) * (cd.height))) {
+#ifdef CONFIG_VSYNC_RDMA
+			canvas_update_addr(disp_canvas_index[0][0],
+					   keep_phy_addr(keep_y_addr));
+			canvas_update_addr(disp_canvas_index[1][0],
+					   keep_phy_addr(keep_y_addr));
+#else
+			canvas_update_addr(y_index,
+					keep_phy_addr(keep_y_addr));
+#endif
+		}
+#endif
+		if (get_video_debug_flags() & DEBUG_FLAG_BLACKOUT)
+			pr_info("%s: VIDTYPE_VIU_444\n", __func__);
+	} else if ((cur_dispbuf->type & VIDTYPE_VIU_NV21) == VIDTYPE_VIU_NV21) {
+		canvas_read(y_index, &cs0);
+		canvas_read(u_index, &cs1);
+		if ((Y_BUFFER_SIZE < (cs0.width * cs0.height))
+		    || (U_BUFFER_SIZE < (cs1.width * cs1.height))) {
+			pr_info("## [%s::%d] error: yuv data size larger",
+				__func__, __LINE__);
+			return -1;
+		}
+#ifdef CONFIG_GE2D_KEEP_FRAME
+		ge2d_keeplastframe_block(cur_index, GE2D_FORMAT_M24_NV21);
+#else
+		if (keep_phy_addr(keep_y_addr) != canvas_get_addr(y_index) &&
+		    canvas_dup(keep_phy_addr(keep_y_addr),
+					canvas_get_addr(y_index),
+					(cs0.width * cs0.height))
+		    && canvas_dup(keep_phy_addr(keep_u_addr),
+					canvas_get_addr(u_index),
+					(cs1.width * cs1.height))) {
+#ifdef CONFIG_VSYNC_RDMA
+			canvas_update_addr(disp_canvas_index[0][0],
+					   keep_phy_addr(keep_y_addr));
+			canvas_update_addr(disp_canvas_index[1][0],
+					   keep_phy_addr(keep_y_addr));
+			canvas_update_addr(disp_canvas_index[0][1],
+					   keep_phy_addr(keep_u_addr));
+			canvas_update_addr(disp_canvas_index[1][1],
+					   keep_phy_addr(keep_u_addr));
+#else
+			canvas_update_addr(y_index,
+				keep_phy_addr(keep_y_addr));
+			canvas_update_addr(u_index,
+				keep_phy_addr(keep_u_addr));
+#endif
+		}
+#endif
+		if (get_video_debug_flags() & DEBUG_FLAG_BLACKOUT)
+			pr_info("%s: VIDTYPE_VIU_NV21\n", __func__);
+	} else {
+		canvas_read(y_index, &cs0);
+		canvas_read(u_index, &cs1);
+		canvas_read(v_index, &cs2);
+
+		if ((Y_BUFFER_SIZE < (cs0.width * cs0.height))
+		    || (U_BUFFER_SIZE < (cs1.width * cs1.height))
+		    || (V_BUFFER_SIZE < (cs2.width * cs2.height))) {
+			pr_info("## [%s::%d] error: yuv data size larger than buf size: %x,%x,%x, %x,%x, %x,%x, %x,%x,\n",
+			__func__, __LINE__, Y_BUFFER_SIZE,
+			U_BUFFER_SIZE, V_BUFFER_SIZE, cs0.width,
+			cs0.height, cs1.width, cs1.height, cs2.width,
+			cs2.height);
+			return -1;
+		}
+#ifdef CONFIG_GE2D_KEEP_FRAME
+		ge2d_keeplastframe_block(cur_index, GE2D_FORMAT_M24_YUV420);
+#else
+		if (keep_phy_addr(keep_y_addr) != canvas_get_addr(y_index) &&
+			/*must not the same address */
+		    canvas_dup(keep_phy_addr(keep_y_addr),
+					canvas_get_addr(y_index),
+					(cs0.width * cs0.height))
+		    && canvas_dup(keep_phy_addr(keep_u_addr),
+					canvas_get_addr(u_index),
+					(cs1.width * cs1.height))
+			&& canvas_dup(keep_phy_addr(keep_v_addr),
+					canvas_get_addr(v_index),
+					(cs2.width * cs2.height))) {
+#ifdef CONFIG_VSYNC_RDMA
+			canvas_update_addr(disp_canvas_index[0][0],
+					   keep_phy_addr(keep_y_addr));
+			canvas_update_addr(disp_canvas_index[1][0],
+					   keep_phy_addr(keep_y_addr));
+			canvas_update_addr(disp_canvas_index[0][1],
+					   keep_phy_addr(keep_u_addr));
+			canvas_update_addr(disp_canvas_index[1][1],
+					   keep_phy_addr(keep_u_addr));
+			canvas_update_addr(disp_canvas_index[0][2],
+					   keep_phy_addr(keep_v_addr));
+			canvas_update_addr(disp_canvas_index[1][2],
+					   keep_phy_addr(keep_v_addr));
+#else
+			canvas_update_addr(y_index,
+				keep_phy_addr(keep_y_addr));
+			canvas_update_addr(u_index,
+				keep_phy_addr(keep_u_addr));
+			canvas_update_addr(v_index,
+				keep_phy_addr(keep_v_addr));
+#endif
+		}
+
+		if (get_video_debug_flags() & DEBUG_FLAG_BLACKOUT)
+			pr_info("%s: VIDTYPE_VIU_420\n", __func__);
+#endif
+	}
+	keep_video_on = 1;
+	pr_info("%s: keep video on with keep\n", __func__);
+	return 0;
+
+}
+
+int __init video_keeper_init(void)
+{
+#ifdef CONFIG_GE2D_KEEP_FRAME
+	/* video_frame_getmem(); */
+	ge2d_videotask_init();
+#endif
+	return 0;
+}
+void __exit video_keeper_exit(void)
+{
+#ifdef CONFIG_GE2D_KEEP_FRAME
+	ge2d_videotask_release();
+#endif
+	return;
+}
+
diff --git a/drivers/amlogic/amports/video_keeper.h b/drivers/amlogic/amports/video_keeper.h
new file mode 100644
index 0000000..bee9d0a
--- /dev/null
+++ b/drivers/amlogic/amports/video_keeper.h
@@ -0,0 +1,30 @@
+/*
+ * drivers/amlogic/amports/video_keeper.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef VIDEO_KEEPER_HEADER___
+#define VIDEO_KEEPER_HEADER___
+#include <linux/amlogic/amports/vframe.h>
+
+void video_keeper_new_frame_notify(void);
+void try_free_keep_video(int flags);
+
+int __init video_keeper_init(void);
+void __exit video_keeper_exit(void);
+unsigned int vf_keep_current(struct vframe_s *cur_dispbuf);
+
+#endif
+
diff --git a/drivers/amlogic/amports/video_priv.h b/drivers/amlogic/amports/video_priv.h
new file mode 100644
index 0000000..bf71438
--- /dev/null
+++ b/drivers/amlogic/amports/video_priv.h
@@ -0,0 +1,49 @@
+#ifndef VIDEO_PRIV_HEADER_HH
+#define VIDEO_PRIV_HEADER_HH
+#define DEBUG_FLAG_BLACKOUT     0x1
+#define DEBUG_FLAG_PRINT_TOGGLE_FRAME 0x2
+#define DEBUG_FLAG_PRINT_RDMA                0x4
+#define DEBUG_FLAG_LOG_RDMA_LINE_MAX         0x100
+#define DEBUG_FLAG_TOGGLE_SKIP_KEEP_CURRENT  0x10000
+#define DEBUG_FLAG_TOGGLE_FRAME_PER_VSYNC    0x20000
+#define DEBUG_FLAG_RDMA_WAIT_1		     0x40000
+#define DEBUG_FLAG_VSYNC_DONONE                0x80000
+#define DEBUG_FLAG_GOFIELD_MANUL             0x100000
+/*for video.c's static int debug_flag;*/
+
+
+#define VOUT_TYPE_TOP_FIELD 0
+#define VOUT_TYPE_BOT_FIELD 1
+#define VOUT_TYPE_PROG      2
+
+#define VIDEO_DISABLE_NONE    0
+#define VIDEO_DISABLE_NORMAL  1
+#define VIDEO_DISABLE_FORNEXT 2
+
+struct video_dev_s {
+	int vpp_off;
+	int viu_off;
+};
+void safe_disble_videolayer(void);
+void update_cur_dispbuf(void *buf);
+
+
+/*for video related files only.*/
+void video_module_lock(void);
+void video_module_unlock(void);
+struct video_dev_s *get_video_cur_dev(void);
+struct vframe_s *get_cur_dispbuf(void);
+
+int get_video_debug_flags(void);
+int _video_set_disable(u32 val);
+u32 get_video_enabled(void);
+
+
+#ifdef CONFIG_AM_VIDEOCAPTURE
+int ext_frame_capture_poll(int endflags);
+#endif
+
+extern u32 disp_canvas_index[2][6];
+#endif
+/*VIDEO_PRIV_HEADER_HH*/
+
diff --git a/drivers/amlogic/amports/vmh264.c b/drivers/amlogic/amports/vmh264.c
new file mode 100644
index 0000000..a9d6553
--- /dev/null
+++ b/drivers/amlogic/amports/vmh264.c
@@ -0,0 +1,2788 @@
+/*
+ * drivers/amlogic/amports/vh264.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/kfifo.h>
+#include <linux/platform_device.h>
+
+#include <linux/amlogic/amports/amstream.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/amlogic/amports/vformat.h>
+#include <linux/amlogic/amports/tsync.h>
+#include <linux/workqueue.h>
+#include <linux/dma-mapping.h>
+#include <linux/atomic.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-contiguous.h>
+#include "amports_priv.h"
+#include <linux/amlogic/codec_mm/codec_mm.h>
+#include <linux/amlogic/canvas/canvas.h>
+
+#include "vdec_input.h"
+
+#include "vdec.h"
+#include "vdec_reg.h"
+#include "amvdec.h"
+#include "vh264.h"
+#include "streambuf.h"
+#include <linux/delay.h>
+
+#undef pr_info
+#define pr_info printk
+
+#define DEBUG_UCODE
+#define USE_CMA
+#define MEM_NAME "codec_m264"
+#define MULTI_INSTANCE_FRAMEWORK
+/* #define ONE_COLOCATE_BUF_PER_DECODE_BUF */
+#include "h264_dpb.h"
+/* #define SEND_PARAM_WITH_REG */
+
+#define DRIVER_NAME "ammvdec_h264"
+#define MODULE_NAME "ammvdec_h264"
+
+#define CHECK_INTERVAL        (HZ/100)
+
+#define RATE_MEASURE_NUM 8
+#define RATE_CORRECTION_THRESHOLD 5
+#define RATE_2397_FPS  4004   /* 23.97 */
+#define RATE_25_FPS  3840   /* 25 */
+#define RATE_2997_FPS  3203   /* 29.97 */
+#define DUR2PTS(x) ((x)*90/96)
+#define PTS2DUR(x) ((x)*96/90)
+#define DUR2PTS_REM(x) (x*90 - DUR2PTS(x)*96)
+#define FIX_FRAME_RATE_CHECK_IFRAME_NUM 2
+
+#define FIX_FRAME_RATE_OFF                0
+#define FIX_FRAME_RATE_ON                 1
+#define FIX_FRAME_RATE_SMOOTH_CHECKING    2
+
+#define DEC_CONTROL_FLAG_FORCE_2997_1080P_INTERLACE 0x0001
+#define DEC_CONTROL_FLAG_FORCE_2500_576P_INTERLACE  0x0002
+#define DEC_CONTROL_FLAG_FORCE_RATE_2397_FPS_FIX_FRAME_RATE  0x0010
+#define DEC_CONTROL_FLAG_FORCE_RATE_2997_FPS_FIX_FRAME_RATE  0x0020
+
+
+#define RATE_MEASURE_NUM 8
+#define RATE_CORRECTION_THRESHOLD 5
+#define RATE_24_FPS  4004	/* 23.97 */
+#define RATE_25_FPS  3840	/* 25 */
+#define DUR2PTS(x) ((x)*90/96)
+#define PTS2DUR(x) ((x)*96/90)
+#define DUR2PTS_REM(x) (x*90 - DUR2PTS(x)*96)
+#define FIX_FRAME_RATE_CHECK_IDRFRAME_NUM 2
+
+#define H264_DEV_NUM        5
+
+unsigned int h264_debug_flag; /* 0xa0000000; */
+unsigned int h264_debug_mask = 0xff;
+	/*
+	h264_debug_cmd:
+		0x1xx, force decoder id of xx to be disconnected
+	*/
+unsigned int h264_debug_cmd;
+static unsigned int dec_control;
+static unsigned int force_rate_streambase;
+static unsigned int force_rate_framebase;
+static unsigned int fixed_frame_rate_mode;
+static unsigned int error_recovery_mode_in;
+static unsigned int start_decode_buf_level = 0x8000;
+
+static unsigned int reorder_dpb_size_margin = 6;
+static unsigned int reference_buf_margin = 4;
+
+static unsigned int decode_timeout_val = 50;
+static unsigned int radr;
+static unsigned int rval;
+static unsigned int max_decode_instance_num = H264_DEV_NUM;
+static unsigned int decode_frame_count[H264_DEV_NUM];
+static unsigned int max_process_time[H264_DEV_NUM];
+static unsigned int max_get_frame_interval[H264_DEV_NUM];
+		/* bit[3:0]:
+		0, run ; 1, pause; 3, step
+		bit[4]:
+		1, schedule run
+		*/
+static unsigned int step[H264_DEV_NUM];
+
+#define is_in_parsing_state(status) \
+		((status == H264_ACTION_SEARCH_HEAD) || \
+			((status & 0xf0) == 0x80))
+
+static inline bool close_to(int a, int b, int m)
+{
+	return (abs(a - b) < m) ? true : false;
+}
+
+/* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
+#define NV21
+/* #endif */
+
+/* 12M for L41 */
+#define MAX_DPB_BUFF_SIZE       (12*1024*1024)
+#define DEFAULT_MEM_SIZE        (32*1024*1024)
+#define AVIL_DPB_BUFF_SIZE      0x01ec2000
+
+#define DEF_BUF_START_ADDR            0x1000000
+#define V_BUF_ADDR_OFFSET             (0x13e000)
+
+#define PIC_SINGLE_FRAME        0
+#define PIC_TOP_BOT_TOP         1
+#define PIC_BOT_TOP_BOT         2
+#define PIC_DOUBLE_FRAME        3
+#define PIC_TRIPLE_FRAME        4
+#define PIC_TOP_BOT              5
+#define PIC_BOT_TOP              6
+#define PIC_INVALID              7
+
+#define EXTEND_SAR                      0xff
+
+#define VF_POOL_SIZE        64
+#define MAX_VF_BUF_NUM          28
+#define PUT_INTERVAL        (HZ/100)
+#define NO_DISP_WD_COUNT    (3 * HZ / PUT_INTERVAL)
+
+#define SWITCHING_STATE_OFF       0
+#define SWITCHING_STATE_ON_CMD3   1
+#define SWITCHING_STATE_ON_CMD1   2
+
+#define DEC_CONTROL_FLAG_FORCE_2997_1080P_INTERLACE 0x0001
+#define DEC_CONTROL_FLAG_FORCE_2500_576P_INTERLACE  0x0002
+
+#define INCPTR(p) ptr_atomic_wrap_inc(&p)
+
+#define SLICE_TYPE_I 2
+#define SLICE_TYPE_P 5
+#define SLICE_TYPE_B 6
+
+struct buffer_spec_s {
+	/*
+	used:
+	0, free; 1, used by dpb; 2,
+	used for display;
+	3 isolated (do not use for dpb when vf_put)
+	*/
+	unsigned int used;
+	unsigned int info0;
+	unsigned int info1;
+	unsigned int info2;
+	unsigned int y_addr;
+	unsigned int u_addr;
+	unsigned int v_addr;
+
+	int y_canvas_index;
+	int u_canvas_index;
+	int v_canvas_index;
+
+#ifdef NV21
+	struct canvas_config_s canvas_config[2];
+#else
+	struct canvas_config_s canvas_config[3];
+#endif
+#ifdef USE_CMA
+	/* struct page *cma_alloc_pages; */
+	unsigned long cma_alloc_addr;
+	int cma_alloc_count;
+#endif
+	unsigned int buf_adr;
+};
+
+#define spec2canvas(x)  \
+	(((x)->v_canvas_index << 16) | \
+	 ((x)->u_canvas_index << 8)  | \
+	 ((x)->y_canvas_index << 0))
+
+static struct vframe_s *vh264_vf_peek(void *);
+static struct vframe_s *vh264_vf_get(void *);
+static void vh264_vf_put(struct vframe_s *, void *);
+static int vh264_vf_states(struct vframe_states *states, void *);
+static int vh264_event_cb(int type, void *data, void *private_data);
+static void vh264_work(struct work_struct *work);
+
+static const char vh264_dec_id[] = "vh264-dev";
+
+#define PROVIDER_NAME "vdec.h264"
+
+static const struct vframe_operations_s vf_provider_ops = {
+	.peek = vh264_vf_peek,
+	.get = vh264_vf_get,
+	.put = vh264_vf_put,
+	.event_cb = vh264_event_cb,
+	.vf_states = vh264_vf_states,
+};
+
+#define DEC_RESULT_NONE             0
+#define DEC_RESULT_DONE             1
+#define DEC_RESULT_AGAIN            2
+#define DEC_RESULT_CONFIG_PARAM     3
+#define DEC_RESULT_GET_DATA         4
+#define DEC_RESULT_GET_DATA_RETRY   5
+#define DEC_RESULT_ERROR            6
+
+/*
+static const char *dec_result_str[] = {
+    "DEC_RESULT_NONE        ",
+    "DEC_RESULT_DONE        ",
+    "DEC_RESULT_AGAIN       ",
+    "DEC_RESULT_CONFIG_PARAM",
+    "DEC_RESULT_GET_DATA    ",
+    "DEC_RESULT_GET_DA_RETRY",
+    "DEC_RESULT_ERROR       ",
+};
+*/
+
+#define UCODE_IP_ONLY 2
+#define UCODE_IP_ONLY_PARAM 1
+
+#define MC_OFFSET_HEADER    0x0000
+#define MC_OFFSET_DATA      0x1000
+#define MC_OFFSET_MMCO      0x2000
+#define MC_OFFSET_LIST      0x3000
+#define MC_OFFSET_SLICE     0x4000
+#define MC_OFFSET_MAIN      0x5000
+
+#define MC_TOTAL_SIZE       ((20+16)*SZ_1K)
+#define MC_SWAP_SIZE        (4*SZ_1K)
+#define MODE_ERROR 0
+#define MODE_FULL  1
+
+#define DFS_HIGH_THEASHOLD 3
+
+#define INIT_FLAG_REG       AV_SCRATCH_2
+#define HEAD_PADING_REG     AV_SCRATCH_3
+#define UCODE_WATCHDOG_REG   AV_SCRATCH_7
+#define LMEM_DUMP_ADR       AV_SCRATCH_L
+#define DEBUG_REG1          AV_SCRATCH_M
+#define DEBUG_REG2          AV_SCRATCH_N
+#define FRAME_COUNTER_REG       AV_SCRATCH_I
+#define RPM_CMD_REG          AV_SCRATCH_A
+#define H264_DECODE_SIZE	AV_SCRATCH_E
+#define H264_DECODE_INFO          M4_CONTROL_REG /* 0xc29 */
+#define DPB_STATUS_REG       AV_SCRATCH_J
+#define MBY_MBX                 MB_MOTION_MODE /*0xc07*/
+
+struct vdec_h264_hw_s {
+	spinlock_t lock;
+
+	struct platform_device *platform_dev;
+	struct device *cma_dev;
+	/* struct page *cma_alloc_pages; */
+	unsigned long cma_alloc_addr;
+	int cma_alloc_count;
+	/* struct page *collocate_cma_alloc_pages; */
+	unsigned long collocate_cma_alloc_addr;
+	int collocate_cma_alloc_count;
+
+	ulong lmem_addr;
+	dma_addr_t lmem_addr_remap;
+
+	DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
+	DECLARE_KFIFO(display_q, struct vframe_s *, VF_POOL_SIZE);
+
+	struct vframe_s vfpool[VF_POOL_SIZE];
+	struct buffer_spec_s buffer_spec[MAX_VF_BUF_NUM];
+	int buffer_spec_num;
+	struct vframe_s switching_fense_vf;
+	struct h264_dpb_stru dpb;
+	u8 init_flag;
+	u8 set_params_done;
+	u32 max_reference_size;
+	u32 decode_pic_count;
+	int start_search_pos;
+
+	unsigned char buffer_empty_flag;
+
+	u32 frame_width;
+	u32 frame_height;
+	u32 frame_dur;
+	u32 frame_prog;
+	u32 frame_packing_type;
+
+	struct vframe_chunk_s *chunk;
+
+	u32 stat;
+	unsigned long buf_start;
+	u32 buf_offset;
+	u32 buf_size;
+	/* u32 ucode_map_start; */
+	u32 pts_outside;
+	u32 sync_outside;
+	u32 vh264_ratio;
+	u32 vh264_rotation;
+	u32 use_idr_framerate;
+
+	u32 seq_info;
+	u32 timing_info_present_flag;
+	u32 fixed_frame_rate_flag;
+	u32 fixed_frame_rate_check_count;
+	u32 iframe_count;
+	u32 aspect_ratio_info;
+	u32 num_units_in_tick;
+	u32 time_scale;
+	u32 h264_ar;
+	bool h264_first_valid_pts_ready;
+	u32 h264pts1;
+	u32 h264pts2;
+	u32 pts_duration;
+	u32 h264_pts_count;
+	u32 duration_from_pts_done;
+	u32 pts_unstable;	u32 duration_on_correcting;
+	u32 last_checkout_pts;
+	u32 fatal_error_flag;
+	u32 fatal_error_reset;
+	u32 max_refer_buf;
+
+	s32 vh264_stream_switching_state;
+	struct vframe_s *p_last_vf;
+	u32 last_pts;
+	u32 last_pts_remainder;
+	u32 last_duration;
+	u32 saved_resolution;
+	u32 last_mb_width, last_mb_height;
+	bool check_pts_discontinue;
+	bool pts_discontinue;
+	u32 wait_buffer_counter;
+	u32 first_offset;
+	u32 first_pts;
+	u64 first_pts64;
+	bool first_pts_cached;
+
+	void *sei_data_buffer;
+	dma_addr_t sei_data_buffer_phys;
+
+	uint error_recovery_mode;
+	uint mb_total;
+	uint mb_width;
+	uint mb_height;
+
+	uint ucode_type;
+	dma_addr_t mc_dma_handle;
+	void *mc_cpu_addr;
+	int vh264_reset;
+
+	atomic_t vh264_active;
+
+	struct dec_sysinfo vh264_amstream_dec_info;
+
+	struct work_struct error_wd_work;
+
+	int dec_result;
+	struct work_struct work;
+
+	void (*vdec_cb)(struct vdec_s *, void *);
+	void *vdec_cb_arg;
+
+	struct timer_list check_timer;
+
+	/**/
+	unsigned last_frame_time;
+
+	/* timeout handle */
+	unsigned long int start_process_time;
+	unsigned last_mby_mbx;
+	unsigned last_ucode_watchdog_reg_val;
+	unsigned decode_timeout_count;
+	unsigned timeout_num;
+	unsigned search_dataempty_num;
+	unsigned decode_timeout_num;
+	unsigned decode_dataempty_num;
+	unsigned buffer_empty_recover_num;
+
+	/**/
+
+	/*log*/
+	unsigned int packet_write_success_count;
+	unsigned int packet_write_EAGAIN_count;
+	unsigned int packet_write_ENOMEM_count;
+	unsigned int packet_write_EFAULT_count;
+	unsigned int total_read_size_pre;
+	unsigned int total_read_size;
+	unsigned int frame_count_pre;
+};
+
+
+static void vh264_local_init(struct vdec_h264_hw_s *hw);
+static int vh264_hw_ctx_restore(struct vdec_h264_hw_s *hw);
+static int vh264_stop(struct vdec_h264_hw_s *hw, int mode);
+static s32 vh264_init(struct vdec_h264_hw_s *hw);
+static void set_frame_info(struct vdec_h264_hw_s *hw, struct vframe_s *vf,
+			u32 index);
+
+unsigned char have_free_buf_spec(struct vdec_s *vdec)
+{
+	int i;
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
+	if ((h264_debug_flag&OUTPUT_CURRENT_BUF) == 0) {
+		for (i = 0; i < hw->buffer_spec_num; i++) {
+			if (hw->buffer_spec[i].used == 0)
+				return 1;
+		}
+		return 0;
+	} else
+		return 1;
+}
+
+#if 0
+static void buf_spec_recover(struct vdec_h264_hw_s *hw)
+{ /* do not clear buf_spec used by display */
+	int i;
+	dpb_print(hw->dpb.decoder_index,
+	PRINT_FLAG_DPB, "%s\n", __func__);
+	for (i = 0; i < hw->buffer_spec_num; i++) {
+		if (hw->buffer_spec[i].used == 2)
+			hw->buffer_spec[i].used = 3;
+		else
+			hw->buffer_spec[i].used = 0;
+	}
+}
+#endif
+
+int get_free_buf_idx(struct vdec_s *vdec)
+{
+	int i;
+	int index = -1;
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
+
+	if ((h264_debug_flag&OUTPUT_CURRENT_BUF) == 0) {
+		for (i = hw->start_search_pos; i < hw->buffer_spec_num; i++) {
+			if (hw->buffer_spec[i].used == 0) {
+				hw->buffer_spec[i].used = 1;
+				hw->start_search_pos = i+1;
+				index = i;
+				break;
+			}
+		}
+		if (index < 0) {
+			for (i = 0; i < hw->start_search_pos; i++) {
+				if (hw->buffer_spec[i].used == 0) {
+					hw->buffer_spec[i].used = 1;
+					hw->start_search_pos = i+1;
+					index = i;
+					break;
+				}
+			}
+		}
+	} else {
+		index = hw->start_search_pos;
+		hw->start_search_pos++;
+	}
+
+	if (hw->start_search_pos >= hw->buffer_spec_num)
+		hw->start_search_pos = 0;
+
+	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_DPB_DETAIL,
+			"%s, buf_spec_num %d\n", __func__, index);
+
+	return index;
+}
+
+int release_buf_spec_num(struct vdec_s *vdec, int buf_spec_num)
+{
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
+	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_DPB_DETAIL,
+		"%s buf_spec_num %d\n",
+		__func__, buf_spec_num);
+	if (buf_spec_num >= 0 && buf_spec_num < hw->buffer_spec_num)
+		hw->buffer_spec[buf_spec_num].used = 0;
+	return 0;
+}
+
+static int get_buf_spec_idx_by_canvas_config(struct vdec_h264_hw_s *hw,
+	struct canvas_config_s *cfg)
+{
+	int i;
+	for (i = 0; i < hw->buffer_spec_num; i++) {
+		if (hw->buffer_spec[i].canvas_config[0].phy_addr
+			== cfg->phy_addr)
+			return i;
+	}
+	return -1;
+}
+
+int prepare_display_buf(struct vdec_s *vdec, struct FrameStore *frame)
+{
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
+	struct vframe_s *vf = NULL;
+
+	if (kfifo_get(&hw->newframe_q, &vf) == 0) {
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
+			"%s fatal error, no available buffer slot.\n",
+			__func__);
+		return -1;
+	}
+
+	if (vf) {
+		int buffer_index = frame->buf_spec_num;
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_DPB_DETAIL,
+			"%s, fs[%d] poc %d, buf_spec_num %d\n",
+			__func__, frame->index, frame->poc,
+			frame->buf_spec_num);
+		vf->index = frame->index;
+		vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD |
+				VIDTYPE_VIU_NV21;
+		vf->duration_pulldown = 0;
+		vf->pts = frame->pts;
+		vf->pts_us64 = frame->pts64;
+		vf->canvas0Addr = vf->canvas1Addr =
+			spec2canvas(&hw->buffer_spec[buffer_index]);
+		set_frame_info(hw, vf, buffer_index);
+		kfifo_put(&hw->display_q, (const struct vframe_s *)vf);
+		hw->buffer_spec[buffer_index].used = 2;
+
+		vf_notify_receiver(vdec->vf_provider_name,
+			VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
+		decode_frame_count[hw->dpb.decoder_index]++;
+	}
+
+	return 0;
+}
+
+/******************
+ * Hardware config
+ */
+char *slice_type_name[] = {
+	"P_SLICE ",
+	"B_SLICE ",
+	"I_SLICE ",
+	"SP_SLICE",
+	"SI_SLICE",
+};
+
+char *picture_structure_name[] = {
+	"FRAME",
+	"TOP_FIELD",
+	"BOTTOM_FIELD"
+};
+
+void print_pic_info(int decindex, const char *info,
+			struct StorablePicture *pic,
+			int slice_type)
+{
+	dpb_print(decindex, PRINT_FLAG_UCODE_EVT,
+		"%s: %s (original %s), %s, mb_aff_frame_flag %d  poc %d, pic_num %d, buf_spec_num %d\n",
+		info,
+		picture_structure_name[pic->structure],
+		pic->coded_frame ? "Frame" : "Field",
+		(slice_type < 0) ? "" : slice_type_name[slice_type],
+		pic->mb_aff_frame_flag,
+		pic->poc,
+		pic->pic_num,
+		pic->buf_spec_num);
+}
+
+static void reset_process_time(struct vdec_h264_hw_s *hw)
+{
+	if (hw->start_process_time) {
+		unsigned process_time =
+			1000 * (jiffies - hw->start_process_time) / HZ;
+		hw->start_process_time = 0;
+		if (process_time > max_process_time[hw->dpb.decoder_index])
+			max_process_time[hw->dpb.decoder_index] = process_time;
+	}
+}
+
+void config_decode_buf(struct vdec_h264_hw_s *hw, struct StorablePicture *pic)
+{
+	/* static int count = 0; */
+	struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
+	struct Slice *pSlice = &(p_H264_Dpb->mSlice);
+	unsigned int colocate_adr_offset;
+	unsigned int val;
+
+#define H264_BUFFER_INFO_INDEX    PMV3_X /* 0xc24 */
+#define H264_BUFFER_INFO_DATA   PMV2_X  /* 0xc22 */
+#define H264_CURRENT_POC_IDX_RESET LAST_SLICE_MV_ADDR /* 0xc30 */
+#define H264_CURRENT_POC          LAST_MVY /* 0xc32 shared with conceal MV */
+
+#define H264_CO_MB_WR_ADDR        VLD_C38 /* 0xc38 */
+/* bit 31:30 -- L1[0] picture coding structure,
+	00 - top field,	01 - bottom field,
+	10 - frame, 11 - mbaff frame
+   bit 29 - L1[0] top/bot for B field pciture , 0 - top, 1 - bot
+   bit 28:0 h264_co_mb_mem_rd_addr[31:3]
+	-- only used for B Picture Direct mode [2:0] will set to 3'b000
+*/
+#define H264_CO_MB_RD_ADDR        VLD_C39 /* 0xc39 */
+
+/* bit 15 -- flush co_mb_data to DDR -- W-Only
+   bit 14 -- h264_co_mb_mem_wr_addr write Enable -- W-Only
+   bit 13 -- h264_co_mb_info_wr_ptr write Enable -- W-Only
+   bit 9 -- soft_reset -- W-Only
+   bit 8 -- upgent
+   bit 7:2 -- h264_co_mb_mem_wr_addr
+   bit 1:0 -- h264_co_mb_info_wr_ptr
+*/
+#define H264_CO_MB_RW_CTL         VLD_C3D /* 0xc3d */
+
+	unsigned long canvas_adr;
+	unsigned ref_reg_val;
+	unsigned one_ref_cfg = 0;
+	int h264_buffer_info_data_write_count;
+	int i, j;
+	unsigned colocate_wr_adr;
+	unsigned colocate_rd_adr;
+	unsigned char use_direct_8x8;
+
+	WRITE_VREG(H264_CURRENT_POC_IDX_RESET, 0);
+	WRITE_VREG(H264_CURRENT_POC, pic->frame_poc);
+	WRITE_VREG(H264_CURRENT_POC, pic->top_poc);
+	WRITE_VREG(H264_CURRENT_POC, pic->bottom_poc);
+
+	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		"%s: pic_num is %d, poc is %d (%d, %d, %d), buf_spec_num %d\n",
+		__func__, pic->pic_num, pic->poc, pic->frame_poc,
+		pic->top_poc, pic->bottom_poc, pic->buf_spec_num);
+	print_pic_info(hw->dpb.decoder_index, "cur", pic, pSlice->slice_type);
+
+	WRITE_VREG(CURR_CANVAS_CTRL, pic->buf_spec_num << 24);
+
+	canvas_adr = READ_VREG(CURR_CANVAS_CTRL) & 0xffffff;
+
+	WRITE_VREG(REC_CANVAS_ADDR, canvas_adr);
+	WRITE_VREG(DBKR_CANVAS_ADDR, canvas_adr);
+	WRITE_VREG(DBKW_CANVAS_ADDR, canvas_adr);
+
+	if (pic->mb_aff_frame_flag)
+		hw->buffer_spec[pic->buf_spec_num].info0 = 0xf4c0;
+	else if (pic->structure == TOP_FIELD)
+		hw->buffer_spec[pic->buf_spec_num].info0 = 0xf400;
+	else if (pic->structure == BOTTOM_FIELD)
+		hw->buffer_spec[pic->buf_spec_num].info0 = 0xf440;
+	else
+		hw->buffer_spec[pic->buf_spec_num].info0 = 0xf480;
+
+	if (pic->bottom_poc < pic->top_poc)
+		hw->buffer_spec[pic->buf_spec_num].info0 |= 0x100;
+
+	hw->buffer_spec[pic->buf_spec_num].info1 = pic->top_poc;
+	hw->buffer_spec[pic->buf_spec_num].info2 = pic->bottom_poc;
+	WRITE_VREG(H264_BUFFER_INFO_INDEX, 16);
+
+	for (i = 0; i < hw->buffer_spec_num; i++) {
+		int long_term_flag =
+			get_long_term_flag_by_buf_spec_num(p_H264_Dpb, i);
+		if (long_term_flag > 0) {
+			if (long_term_flag & 0x1)
+				hw->buffer_spec[i].info0 |= (1 << 4);
+			else
+				hw->buffer_spec[i].info0 &= ~(1 << 4);
+
+			if (long_term_flag & 0x2)
+				hw->buffer_spec[i].info0 |= (1 << 5);
+			else
+				hw->buffer_spec[i].info0 &= ~(1 << 5);
+		}
+
+		if (i == pic->buf_spec_num)
+			WRITE_VREG(H264_BUFFER_INFO_DATA,
+				hw->buffer_spec[i].info0 | 0xf);
+		else
+			WRITE_VREG(H264_BUFFER_INFO_DATA,
+				hw->buffer_spec[i].info0);
+		WRITE_VREG(H264_BUFFER_INFO_DATA, hw->buffer_spec[i].info1);
+		WRITE_VREG(H264_BUFFER_INFO_DATA, hw->buffer_spec[i].info2);
+	}
+
+	/* config reference buffer */
+	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		"list0 size %d\n", pSlice->listXsize[0]);
+	WRITE_VREG(H264_BUFFER_INFO_INDEX, 0);
+	ref_reg_val = 0;
+	j = 0;
+	h264_buffer_info_data_write_count = 0;
+
+	for (i = 0; i < (unsigned int)(pSlice->listXsize[0]); i++) {
+		/*ref list 0 */
+		struct StorablePicture *ref = pSlice->listX[0][i];
+		unsigned cfg;
+		/* bit[6:5] - frame/field info,
+		 * 01 - top, 10 - bottom, 11 - frame
+		 */
+#ifdef ERROR_CHECK
+		if (ref == NULL)
+			return;
+#endif
+		if (ref->structure == TOP_FIELD)
+			cfg = 0x1;
+		else if (ref->structure == BOTTOM_FIELD)
+			cfg = 0x2;
+		else /* FRAME */
+			cfg = 0x3;
+		one_ref_cfg = (ref->buf_spec_num & 0x1f) | (cfg << 5);
+		ref_reg_val <<= 8;
+		ref_reg_val |= one_ref_cfg;
+		j++;
+
+		if (j == 4) {
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+				"H264_BUFFER_INFO_DATA: %x\n", ref_reg_val);
+			WRITE_VREG(H264_BUFFER_INFO_DATA, ref_reg_val);
+			h264_buffer_info_data_write_count++;
+			j = 0;
+		}
+		print_pic_info(hw->dpb.decoder_index, "list0",
+			pSlice->listX[0][i], -1);
+	}
+	if (j != 0) {
+		while (j != 4) {
+			ref_reg_val <<= 8;
+			ref_reg_val |= one_ref_cfg;
+			j++;
+		}
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+			"H264_BUFFER_INFO_DATA: %x\n",
+					ref_reg_val);
+		WRITE_VREG(H264_BUFFER_INFO_DATA, ref_reg_val);
+		h264_buffer_info_data_write_count++;
+	}
+	ref_reg_val = (one_ref_cfg << 24) | (one_ref_cfg<<16) |
+				(one_ref_cfg << 8) | one_ref_cfg;
+	for (i = h264_buffer_info_data_write_count; i < 8; i++)
+		WRITE_VREG(H264_BUFFER_INFO_DATA, ref_reg_val);
+
+	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		"list1 size %d\n", pSlice->listXsize[1]);
+	WRITE_VREG(H264_BUFFER_INFO_INDEX, 8);
+	ref_reg_val = 0;
+	j = 0;
+
+	for (i = 0; i < (unsigned int)(pSlice->listXsize[1]); i++) {
+		/* ref list 0 */
+		struct StorablePicture *ref = pSlice->listX[1][i];
+		unsigned cfg;
+		/* bit[6:5] - frame/field info,
+		 * 01 - top, 10 - bottom, 11 - frame
+		 */
+#ifdef ERROR_CHECK
+		if (ref == NULL)
+			return;
+#endif
+		if (ref->structure == TOP_FIELD)
+			cfg = 0x1;
+		else if (ref->structure == BOTTOM_FIELD)
+			cfg = 0x2;
+		else /* FRAME */
+			cfg = 0x3;
+		one_ref_cfg = (ref->buf_spec_num & 0x1f) | (cfg << 5);
+		ref_reg_val <<= 8;
+		ref_reg_val |= one_ref_cfg;
+		j++;
+
+		if (j == 4) {
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+				"H264_BUFFER_INFO_DATA: %x\n",
+				ref_reg_val);
+			WRITE_VREG(H264_BUFFER_INFO_DATA, ref_reg_val);
+			j = 0;
+		}
+		print_pic_info(hw->dpb.decoder_index, "list1",
+			pSlice->listX[1][i], -1);
+	}
+	if (j != 0) {
+		while (j != 4) {
+			ref_reg_val <<= 8;
+			ref_reg_val |= one_ref_cfg;
+			j++;
+		}
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		"H264_BUFFER_INFO_DATA: %x\n", ref_reg_val);
+		WRITE_VREG(H264_BUFFER_INFO_DATA, ref_reg_val);
+	}
+
+	/* configure co-locate buffer */
+	while ((READ_VREG(H264_CO_MB_RW_CTL) >> 11) & 0x1)
+		;
+	if ((pSlice->mode_8x8_flags & 0x4) &&
+		(pSlice->mode_8x8_flags & 0x2))
+		use_direct_8x8 = 1;
+	else
+		use_direct_8x8 = 0;
+
+#ifndef ONE_COLOCATE_BUF_PER_DECODE_BUF
+	colocate_adr_offset =
+		((pic->structure == FRAME && pic->mb_aff_frame_flag == 0)
+		 ? 1 : 2) * 96;
+	if (use_direct_8x8)
+		colocate_adr_offset >>= 2;
+
+	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		"colocate buf size of each mb 0x%x first_mb_in_slice 0x%x colocate_adr_offset 0x%x\r\n",
+		colocate_adr_offset, pSlice->first_mb_in_slice,
+		colocate_adr_offset * pSlice->first_mb_in_slice);
+
+	colocate_adr_offset *= pSlice->first_mb_in_slice;
+
+	if ((pic->colocated_buf_index >= 0) &&
+		(pic->colocated_buf_index < p_H264_Dpb->colocated_buf_count)) {
+		colocate_wr_adr = p_H264_Dpb->colocated_mv_addr_start +
+			((p_H264_Dpb->colocated_buf_size *
+			pic->colocated_buf_index)
+			>> (use_direct_8x8 ? 2 : 0));
+		if ((colocate_wr_adr + p_H264_Dpb->colocated_buf_size) >
+			p_H264_Dpb->colocated_mv_addr_end)
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
+				"Error, colocate buf is not enough, index is %d\n",
+			pic->colocated_buf_index);
+		val = colocate_wr_adr + colocate_adr_offset;
+		WRITE_VREG(H264_CO_MB_WR_ADDR, val);
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+			"WRITE_VREG(H264_CO_MB_WR_ADDR) = %x, first_mb_in_slice %x pic_structure %x  colocate_adr_offset %x mode_8x8_flags %x colocated_buf_size %x\n",
+			val, pSlice->first_mb_in_slice, pic->structure,
+			colocate_adr_offset, pSlice->mode_8x8_flags,
+			p_H264_Dpb->colocated_buf_size);
+	} else {
+		WRITE_VREG(H264_CO_MB_WR_ADDR, 0xffffffff);
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+			"WRITE_VREG(H264_CO_MB_WR_ADDR) = 0xffffffff\n");
+	}
+#else
+	colocate_adr_offset =
+	((pic->structure == FRAME && pic->mb_aff_frame_flag == 0) ? 1 : 2) * 96;
+	if (use_direct_8x8)
+		colocate_adr_offset >>= 2;
+
+	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		"colocate buf size of each mb 0x%x first_mb_in_slice 0x%x colocate_adr_offset 0x%x\r\n",
+		colocate_adr_offset, pSlice->first_mb_in_slice,
+		colocate_adr_offset * pSlice->first_mb_in_slice);
+
+	colocate_adr_offset *= pSlice->first_mb_in_slice;
+
+	colocate_wr_adr = p_H264_Dpb->colocated_mv_addr_start +
+		((p_H264_Dpb->colocated_buf_size * pic->buf_spec_num) >>
+			(use_direct_8x8 ? 2 : 0));
+
+	if ((colocate_wr_adr + p_H264_Dpb->colocated_buf_size) >
+		p_H264_Dpb->colocated_mv_addr_end)
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
+		"Error, colocate buf is not enough, pic index is %d\n",
+				pic->buf_spec_num);
+	val = colocate_wr_adr + colocate_adr_offset;
+	WRITE_VREG(H264_CO_MB_WR_ADDR, val);
+	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		"WRITE_VREG(H264_CO_MB_WR_ADDR) = %x, first_mb_in_slice %x pic_structure %x colocate_adr_offset %x mode_8x8_flags %x colocated_buf_size %x\n",
+		val, pSlice->first_mb_in_slice, pic->structure,
+		colocate_adr_offset, pSlice->mode_8x8_flags,
+		p_H264_Dpb->colocated_buf_size);
+#endif
+	if (pSlice->listXsize[1] > 0) {
+		struct StorablePicture *colocate_pic = pSlice->listX[1][0];
+		/* H264_CO_MB_RD_ADDR[bit 31:30],
+		 * original picture structure of L1[0],
+		 * 00 - top field, 01 - bottom field,
+		 * 10 - frame, 11 - mbaff frame
+		 */
+		int l10_structure;
+		int cur_colocate_ref_type;
+		/* H264_CO_MB_RD_ADDR[bit 29], top/bot for B field pciture,
+		 * 0 - top, 1 - bot
+		 */
+		unsigned int val;
+#ifdef ERROR_CHECK
+		if (colocate_pic == NULL)
+			return;
+#endif
+
+		if (colocate_pic->mb_aff_frame_flag)
+			l10_structure = 3;
+		else {
+			if (colocate_pic->coded_frame)
+				l10_structure = 2;
+			else
+				l10_structure =	(colocate_pic->structure ==
+					BOTTOM_FIELD) ?	1 : 0;
+		}
+#if 0
+		/*case0016, p16,
+		cur_colocate_ref_type should be configured base on current pic*/
+		if (pic->structure == FRAME &&
+			pic->mb_aff_frame_flag)
+			cur_colocate_ref_type = 0;
+		else if (pic->structure == BOTTOM_FIELD)
+			cur_colocate_ref_type = 1;
+		else
+			cur_colocate_ref_type = 0;
+#else
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+			" CUR TMP DEBUG : mb_aff_frame_flag : %d, structure : %d coded_frame %d\n",
+			pic->mb_aff_frame_flag,
+			pic->structure,
+			pic->coded_frame);
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+			" COL TMP DEBUG : mb_aff_frame_flag : %d, structure : %d coded_frame %d\n",
+			colocate_pic->mb_aff_frame_flag,
+				colocate_pic->structure,
+				colocate_pic->coded_frame);
+		if (pic->structure == FRAME  || pic->mb_aff_frame_flag) {
+			cur_colocate_ref_type =
+				(abs(pic->poc - colocate_pic->top_poc)
+				< abs(pic->poc -
+				colocate_pic->bottom_poc)) ? 0 : 1;
+		} else
+			cur_colocate_ref_type =
+				(colocate_pic->structure
+					== BOTTOM_FIELD) ? 1 : 0;
+#endif
+
+#ifndef ONE_COLOCATE_BUF_PER_DECODE_BUF
+		if ((colocate_pic->colocated_buf_index >= 0) &&
+			(colocate_pic->colocated_buf_index <
+				p_H264_Dpb->colocated_buf_count)) {
+			colocate_rd_adr = p_H264_Dpb->colocated_mv_addr_start +
+				((p_H264_Dpb->colocated_buf_size *
+				colocate_pic->colocated_buf_index)
+				>> (use_direct_8x8 ? 2 : 0));
+			if ((colocate_rd_adr + p_H264_Dpb->colocated_buf_size) >
+				p_H264_Dpb->colocated_mv_addr_end)
+				dpb_print(hw->dpb.decoder_index,
+					PRINT_FLAG_ERROR,
+				"Error, colocate buf is not enough, index is %d\n",
+					colocate_pic->colocated_buf_index);
+			/* bit 31:30 -- L1[0] picture coding structure,
+			 * 00 - top field, 01 - bottom field,
+			 * 10 - frame, 11 - mbaff frame
+			 * bit 29 - L1[0] top/bot for B field pciture,
+			 * 0 - top, 1 - bot
+			 * bit 28:0 h264_co_mb_mem_rd_addr[31:3]
+			 * -- only used for B Picture Direct mode
+			 * [2:0] will set to 3'b000
+			 */
+			/* #define H264_CO_MB_RD_ADDR        VLD_C39 0xc39 */
+			val = ((colocate_rd_adr+colocate_adr_offset) >> 3) |
+				(l10_structure << 30) |
+				(cur_colocate_ref_type << 29);
+			WRITE_VREG(H264_CO_MB_RD_ADDR, val);
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+				"co idx %d, WRITE_VREG(H264_CO_MB_RD_ADDR) = %x, addr %x L1(0) pic_structure %d mbaff %d\n",
+				colocate_pic->colocated_buf_index,
+				val, colocate_rd_adr + colocate_adr_offset,
+				colocate_pic->structure,
+				colocate_pic->mb_aff_frame_flag);
+		} else
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
+			"Error, reference pic has no colocated buf\n");
+#else
+		colocate_rd_adr = p_H264_Dpb->colocated_mv_addr_start +
+			((p_H264_Dpb->colocated_buf_size *
+				colocate_pic->buf_spec_num)
+				>> (use_direct_8x8 ? 2 : 0));
+		if ((colocate_rd_adr + p_H264_Dpb->colocated_buf_size) >
+			p_H264_Dpb->colocated_mv_addr_end)
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
+				"Error, colocate buf is not enough, pic index is %d\n",
+				colocate_pic->buf_spec_num);
+		/* bit 31:30 -- L1[0] picture coding structure,
+		 * 00 - top field, 01 - bottom field,
+		 * 10 - frame, 11 - mbaff frame
+		 * bit 29 - L1[0] top/bot for B field pciture,
+		 * 0 - top, 1 - bot
+		 * bit 28:0 h264_co_mb_mem_rd_addr[31:3]
+		 * -- only used for B Picture Direct mode
+		 * [2:0] will set to 3'b000
+		 */
+		/* #define H264_CO_MB_RD_ADDR        VLD_C39 0xc39 */
+		val = ((colocate_rd_adr+colocate_adr_offset)>>3) |
+			(l10_structure << 30) | (cur_colocate_ref_type << 29);
+		WRITE_VREG(H264_CO_MB_RD_ADDR, val);
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+			"WRITE_VREG(H264_CO_MB_RD_ADDR) = %x, L1(0) pic_structure %d mbaff %d\n",
+			val, colocate_pic->structure,
+			colocate_pic->mb_aff_frame_flag);
+#endif
+	}
+}
+
+static int vh264_vf_states(struct vframe_states *states, void *op_arg)
+{
+	unsigned long flags;
+	struct vdec_s *vdec = op_arg;
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
+
+	spin_lock_irqsave(&hw->lock, flags);
+
+	states->vf_pool_size = VF_POOL_SIZE;
+	states->buf_free_num = kfifo_len(&hw->newframe_q);
+	states->buf_avail_num = kfifo_len(&hw->display_q);
+
+	spin_unlock_irqrestore(&hw->lock, flags);
+
+	return 0;
+}
+
+static struct vframe_s *vh264_vf_peek(void *op_arg)
+{
+	struct vframe_s *vf;
+	struct vdec_s *vdec = op_arg;
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
+
+	if (!hw)
+		return NULL;
+
+	if (kfifo_peek(&hw->display_q, &vf))
+		return vf;
+
+	return NULL;
+}
+
+static struct vframe_s *vh264_vf_get(void *op_arg)
+{
+	struct vframe_s *vf;
+	struct vdec_s *vdec = op_arg;
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
+
+	if (!hw)
+		return NULL;
+
+	if (kfifo_get(&hw->display_q, &vf)) {
+		int time = jiffies;
+		unsigned int frame_interval =
+			1000*(time - hw->last_frame_time)/HZ;
+		if ((h264_debug_flag & OUTPUT_CURRENT_BUF) == 0) {
+			struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+				"%s from fs[%d], poc %d buf_spec_num %d vf %p\n",
+				__func__, vf->index,
+				p_H264_Dpb->mFrameStore[vf->index].poc,
+				p_H264_Dpb->mFrameStore[vf->index]
+						.buf_spec_num, vf);
+		}
+		if (hw->last_frame_time > 0) {
+			dpb_print(hw->dpb.decoder_index,
+			PRINT_FLAG_TIME_STAMP,
+			"%s duration %d pts %d interval %dms\r\n",
+			__func__, vf->duration, vf->pts, frame_interval);
+			if (frame_interval >
+				max_get_frame_interval[hw->dpb.decoder_index])
+				max_get_frame_interval[hw->dpb.decoder_index]
+				= frame_interval;
+		}
+		hw->last_frame_time = time;
+		return vf;
+	}
+
+	return NULL;
+}
+
+static void vh264_vf_put(struct vframe_s *vf, void *op_arg)
+{
+	struct vdec_s *vdec = op_arg;
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
+	struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
+	int buf_spec_num;
+
+	if ((h264_debug_flag & OUTPUT_CURRENT_BUF) == 0) {
+		buf_spec_num =
+			get_buf_spec_idx_by_canvas_config(hw,
+				&vf->canvas0_config[0]);
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+			"%s to fs[%d], poc %d buf_spec_num %d used %d\n",
+			__func__, vf->index,
+			p_H264_Dpb->mFrameStore[vf->index].poc,
+			buf_spec_num,
+			hw->buffer_spec[buf_spec_num].used);
+
+		if (hw->buffer_spec[buf_spec_num].used != 3)
+			set_frame_output_flag(&hw->dpb, vf->index);
+	}
+
+	kfifo_put(&hw->newframe_q, (const struct vframe_s *)vf);
+
+#define ASSIST_MBOX1_IRQ_REG    VDEC_ASSIST_MBOX1_IRQ_REG
+	if (hw->buffer_empty_flag)
+		WRITE_VREG(ASSIST_MBOX1_IRQ_REG, 0x1);
+}
+
+static int vh264_event_cb(int type, void *data,	void *private_data)
+{
+	return 0;
+}
+
+static void set_frame_info(struct vdec_h264_hw_s *hw, struct vframe_s *vf,
+				u32 index)
+{
+	int force_rate = input_frame_based(hw_to_vdec(hw)) ?
+		force_rate_framebase : force_rate_streambase;
+	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		"%s (%d,%d) dur %d, vf %p, index %d\n", __func__,
+		hw->frame_width, hw->frame_height, hw->frame_dur, vf, index);
+
+	vf->width = hw->frame_width;
+	vf->height = hw->frame_height;
+	if (force_rate) {
+		if (force_rate == -1)
+			vf->duration = 0;
+		else
+			vf->duration = 96000/force_rate;
+	} else
+		vf->duration = hw->frame_dur;
+	vf->ratio_control =
+		(min(hw->h264_ar, (u32) DISP_RATIO_ASPECT_RATIO_MAX)) <<
+		DISP_RATIO_ASPECT_RATIO_BIT;
+	vf->orientation = hw->vh264_rotation;
+	vf->flag = 0;
+
+	vf->canvas0Addr = vf->canvas1Addr = -1;
+#ifdef NV21
+	vf->plane_num = 2;
+#else
+	vf->plane_num = 3;
+#endif
+	vf->canvas0_config[0] = hw->buffer_spec[index].canvas_config[0];
+	vf->canvas0_config[1] = hw->buffer_spec[index].canvas_config[1];
+#ifndef NV21
+	vf->canvas0_config[2] = hw->buffer_spec[index].canvas_config[2];
+#endif
+	vf->canvas1_config[0] = hw->buffer_spec[index].canvas_config[0];
+	vf->canvas1_config[1] = hw->buffer_spec[index].canvas_config[1];
+#ifndef NV21
+	vf->canvas1_config[2] = hw->buffer_spec[index].canvas_config[2];
+#endif
+
+	return;
+}
+
+static int get_max_dec_frame_buf_size(int level_idc,
+		int max_reference_frame_num, int mb_width,
+		int mb_height)
+{
+	int pic_size = mb_width * mb_height * 384;
+
+	int size = 0;
+
+	switch (level_idc) {
+	case 9:
+		size = 152064;
+		break;
+	case 10:
+		size = 152064;
+		break;
+	case 11:
+		size = 345600;
+		break;
+	case 12:
+		size = 912384;
+		break;
+	case 13:
+		size = 912384;
+		break;
+	case 20:
+		size = 912384;
+		break;
+	case 21:
+		size = 1824768;
+		break;
+	case 22:
+		size = 3110400;
+		break;
+	case 30:
+		size = 3110400;
+		break;
+	case 31:
+		size = 6912000;
+		break;
+	case 32:
+		size = 7864320;
+		break;
+	case 40:
+		size = 12582912;
+		break;
+	case 41:
+		size = 12582912;
+		break;
+	case 42:
+		size = 13369344;
+		break;
+	case 50:
+		size = 42393600;
+		break;
+	case 51:
+	case 52:
+	default:
+		size = 70778880;
+		break;
+	}
+
+	size /= pic_size;
+	size = size + 1;	/* need one more buffer */
+
+	if (max_reference_frame_num > size)
+		size = max_reference_frame_num;
+
+	return size;
+}
+
+static int vh264_set_params(struct vdec_h264_hw_s *hw)
+{
+	int mb_width, mb_total;
+	int max_reference_size, level_idc;
+	int i, mb_height, addr;
+	int mb_mv_byte;
+	struct vdec_s *vdec = hw_to_vdec(hw);
+	int reg_val;
+	int ret = 0;
+#ifdef USE_CMA
+	unsigned int buf_size;
+#endif
+
+	if (hw->set_params_done) {
+		WRITE_VREG(AV_SCRATCH_0,
+			(hw->max_reference_size << 24) |
+			(hw->buffer_spec_num << 16) |
+			(hw->buffer_spec_num << 8));
+		return 0;
+	}
+	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT, "%s\n",
+		__func__);
+
+#ifndef USE_CMA
+	addr = hw->buf_start;
+#endif
+
+	/* Read AV_SCRATCH_1 */
+	reg_val = READ_VREG(AV_SCRATCH_1);
+	hw->seq_info = READ_VREG(AV_SCRATCH_2);
+	hw->num_units_in_tick = READ_VREG(AV_SCRATCH_4);
+	hw->time_scale = READ_VREG(AV_SCRATCH_5);
+	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT, "get %x\n",
+		reg_val);
+	mb_mv_byte = (reg_val & 0x80000000) ? 24 : 96;
+
+	mb_width = reg_val & 0xff;
+	mb_total = (reg_val >> 8) & 0xffff;
+	if (!mb_width && mb_total) /*for 4k2k*/
+		mb_width = 256;
+
+	mb_height = mb_total/mb_width;
+#if 1
+	/* if (hw->frame_width == 0 || hw->frame_height == 0) { */
+	hw->frame_width = mb_width * 16;
+	hw->frame_height = mb_height * 16;
+	/* } */
+
+	if (hw->frame_dur == 0)
+		hw->frame_dur = 96000 / 30;
+#endif
+
+	mb_width = (mb_width+3) & 0xfffffffc;
+	mb_height = (mb_height+3) & 0xfffffffc;
+	mb_total = mb_width * mb_height;
+
+	reg_val = READ_VREG(AV_SCRATCH_B);
+	level_idc = reg_val & 0xff;
+	max_reference_size = (reg_val >> 8) & 0xff;
+	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		"mb height/widht/total: %x/%x/%x level_idc %x max_ref_num %x\n",
+		mb_height, mb_width, mb_total, level_idc, max_reference_size);
+
+
+	hw->mb_total = mb_total;
+	hw->mb_width = mb_width;
+	hw->mb_height = mb_height;
+
+	hw->dpb.reorder_pic_num =
+		get_max_dec_frame_buf_size(level_idc,
+		max_reference_size, mb_width, mb_height);
+	hw->buffer_spec_num =
+		hw->dpb.reorder_pic_num
+		+ reorder_dpb_size_margin;
+	hw->max_reference_size = max_reference_size + reference_buf_margin;
+
+	if (hw->buffer_spec_num > MAX_VF_BUF_NUM) {
+		hw->buffer_spec_num = MAX_VF_BUF_NUM;
+		hw->dpb.reorder_pic_num = hw->buffer_spec_num
+			- reorder_dpb_size_margin;
+	}
+	hw->dpb.mDPB.size = hw->buffer_spec_num;
+	hw->dpb.max_reference_size = hw->max_reference_size;
+
+	pr_info("%s buf_spec_num %d reorder_pic_num %d collocate_buf_num %d\r\n",
+		__func__, hw->buffer_spec_num,
+		hw->dpb.reorder_pic_num,
+		hw->max_reference_size);
+
+#ifdef USE_CMA
+	buf_size = (hw->mb_total << 8) + (hw->mb_total << 7);
+#endif
+	for (i = 0; i < hw->buffer_spec_num; i++) {
+		int canvas = vdec->get_canvas(i, 2);
+
+#ifdef USE_CMA
+		if (hw->buffer_spec[i].cma_alloc_count == 0) {
+			hw->buffer_spec[i].cma_alloc_count =
+				PAGE_ALIGN(buf_size) / PAGE_SIZE;
+			hw->buffer_spec[i].cma_alloc_addr =
+				codec_mm_alloc_for_dma(MEM_NAME,
+					hw->buffer_spec[i].cma_alloc_count,
+					16, CODEC_MM_FLAGS_FOR_VDECODER);
+		}
+
+		if (!hw->buffer_spec[i].cma_alloc_addr) {
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
+			"CMA alloc failed, request buf size 0x%lx\n",
+				hw->buffer_spec[i].cma_alloc_count * PAGE_SIZE);
+			hw->buffer_spec[i].cma_alloc_count = 0;
+			ret = -1;
+			break;
+		}
+		hw->buffer_spec[i].buf_adr =
+		hw->buffer_spec[i].cma_alloc_addr;
+		addr = hw->buffer_spec[i].buf_adr;
+#else
+		hw->buffer_spec[i].buf_adr = addr;
+#endif
+
+		hw->buffer_spec[i].used = 0;
+		hw->buffer_spec[i].y_addr = addr;
+		addr += hw->mb_total << 8;
+
+		hw->buffer_spec[i].u_addr = addr;
+		hw->buffer_spec[i].v_addr = addr;
+		addr += hw->mb_total << 7;
+
+		hw->buffer_spec[i].y_canvas_index = canvas_y(canvas);
+		hw->buffer_spec[i].u_canvas_index = canvas_u(canvas);
+		hw->buffer_spec[i].v_canvas_index = canvas_v(canvas);
+
+		canvas_config(hw->buffer_spec[i].y_canvas_index,
+			hw->buffer_spec[i].y_addr,
+			hw->mb_width << 4,
+			hw->mb_height << 4,
+			CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_32X32);
+
+		hw->buffer_spec[i].canvas_config[0].phy_addr =
+				hw->buffer_spec[i].y_addr;
+		hw->buffer_spec[i].canvas_config[0].width =
+				hw->mb_width << 4;
+		hw->buffer_spec[i].canvas_config[0].height =
+				hw->mb_height << 4;
+		hw->buffer_spec[i].canvas_config[0].block_mode =
+				CANVAS_BLKMODE_32X32;
+
+		canvas_config(hw->buffer_spec[i].u_canvas_index,
+			hw->buffer_spec[i].u_addr,
+			hw->mb_width << 4,
+			hw->mb_height << 3,
+			CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_32X32);
+
+		hw->buffer_spec[i].canvas_config[1].phy_addr =
+				hw->buffer_spec[i].u_addr;
+		hw->buffer_spec[i].canvas_config[1].width =
+				hw->mb_width << 4;
+		hw->buffer_spec[i].canvas_config[1].height =
+				hw->mb_height << 3;
+		hw->buffer_spec[i].canvas_config[1].block_mode =
+				CANVAS_BLKMODE_32X32;
+
+		WRITE_VREG(ANC0_CANVAS_ADDR + i,
+				spec2canvas(&hw->buffer_spec[i]));
+
+		pr_info("config canvas (%d)\r\n", i);
+	}
+
+
+#ifdef USE_CMA
+	if (hw->collocate_cma_alloc_count == 0) {
+		hw->collocate_cma_alloc_count =
+			PAGE_ALIGN(hw->mb_total * mb_mv_byte *
+				hw->max_reference_size) / PAGE_SIZE;
+		hw->collocate_cma_alloc_addr =
+			codec_mm_alloc_for_dma(MEM_NAME,
+				hw->collocate_cma_alloc_count,
+				16, CODEC_MM_FLAGS_FOR_VDECODER);
+	}
+
+	if (!hw->collocate_cma_alloc_addr) {
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
+		"codec_mm alloc failed, request buf size 0x%lx\n",
+			hw->collocate_cma_alloc_count * PAGE_SIZE);
+		hw->collocate_cma_alloc_count = 0;
+		ret = -1;
+	} else {
+		hw->dpb.colocated_mv_addr_start =
+			hw->collocate_cma_alloc_addr;
+		hw->dpb.colocated_mv_addr_end  =
+			hw->dpb.colocated_mv_addr_start +
+			(hw->mb_total * mb_mv_byte * hw->max_reference_size);
+		pr_info("callocate cma %d, %lx, %x\n",
+			hw->collocate_cma_alloc_count,
+			hw->collocate_cma_alloc_addr,
+			hw->dpb.colocated_mv_addr_start);
+	}
+#else
+	hw->dpb.colocated_mv_addr_start  = addr;
+	hw->dpb.colocated_mv_addr_end  = addr + (hw->mb_total * mb_mv_byte
+			* hw->max_reference_size);
+#endif
+	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		"colocated_mv_addr_start %x colocated_mv_addr_end %x\n",
+		hw->dpb.colocated_mv_addr_start,
+		hw->dpb.colocated_mv_addr_end);
+
+	hw->timing_info_present_flag = hw->seq_info & 0x2;
+	hw->fixed_frame_rate_flag = 0;
+	if (hw->timing_info_present_flag) {
+		hw->fixed_frame_rate_flag = hw->seq_info & 0x40;
+
+		if (((hw->num_units_in_tick * 120) >= hw->time_scale &&
+			((!hw->sync_outside) ||
+				(!hw->frame_dur)))
+			&& hw->num_units_in_tick && hw->time_scale) {
+			if (hw->use_idr_framerate ||
+				hw->fixed_frame_rate_flag ||
+				!hw->frame_dur ||
+				!hw->duration_from_pts_done
+				/*|| vh264_running*/) {
+				u32 frame_dur_es =
+				div_u64(96000ULL * 2 * hw->num_units_in_tick,
+					hw->time_scale);
+				if (hw->frame_dur != frame_dur_es) {
+					hw->h264_first_valid_pts_ready = false;
+					hw->h264pts1 = 0;
+					hw->h264pts2 = 0;
+					hw->h264_pts_count = 0;
+					hw->duration_from_pts_done = 0;
+					fixed_frame_rate_mode =
+						FIX_FRAME_RATE_OFF;
+					hw->pts_duration = 0;
+					hw->frame_dur = frame_dur_es;
+					pr_info("frame_dur %d from timing_info\n",
+						hw->frame_dur);
+				}
+
+				/*hack to avoid use ES frame duration when
+				it's half of the rate from system info
+				 sometimes the encoder is given a wrong
+				 frame rate but the system side infomation
+				 is more reliable
+				if ((frame_dur * 2) != frame_dur_es) {
+				    frame_dur = frame_dur_es;
+				}*/
+			}
+		}
+	} else {
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+			"H.264: timing_info not present\n");
+	}
+
+	if (hw->pts_unstable && (hw->fixed_frame_rate_flag == 0)) {
+		if (((RATE_2397_FPS == hw->frame_dur)
+		&& (dec_control
+		& DEC_CONTROL_FLAG_FORCE_RATE_2397_FPS_FIX_FRAME_RATE))
+			|| ((RATE_2997_FPS ==
+			hw->frame_dur) &&
+		(dec_control &
+			DEC_CONTROL_FLAG_FORCE_RATE_2997_FPS_FIX_FRAME_RATE))) {
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+				"force fix frame rate\n");
+			hw->fixed_frame_rate_flag = 0x40;
+		}
+	}
+
+	hw->set_params_done = 1;
+
+	WRITE_VREG(AV_SCRATCH_0, (hw->max_reference_size<<24) |
+		(hw->buffer_spec_num<<16) |
+		(hw->buffer_spec_num<<8));
+
+	return ret;
+}
+
+static bool is_buffer_available(struct vdec_s *vdec)
+{
+	bool buffer_available = 1;
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)(vdec->private);
+	struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
+
+	if ((kfifo_len(&hw->newframe_q) <= 0) ||
+	    ((hw->set_params_done) && (!have_free_buf_spec(vdec))) ||
+	    ((p_H264_Dpb->mDPB.init_done) &&
+	     (p_H264_Dpb->mDPB.used_size == p_H264_Dpb->mDPB.size) &&
+	     (is_there_unused_frame_from_dpb(&p_H264_Dpb->mDPB) == 0))) {
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+		"%s, empty, newq(%d), free_spec(%d), initdon(%d), used_size(%d/%d), unused_fr_dpb(%d)\n",
+		__func__,
+		kfifo_len(&hw->newframe_q),
+		have_free_buf_spec(vdec),
+		p_H264_Dpb->mDPB.init_done,
+		p_H264_Dpb->mDPB.used_size, p_H264_Dpb->mDPB.size,
+		is_there_unused_frame_from_dpb(&p_H264_Dpb->mDPB)
+		);
+		buffer_available = 0;
+
+		bufmgr_h264_remove_unused_frame(p_H264_Dpb);
+	}
+
+	return buffer_available;
+}
+
+static irqreturn_t vh264_isr(struct vdec_s *vdec)
+{
+	unsigned int dec_dpb_status;
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)(vdec->private);
+	struct h264_dpb_stru *p_H264_Dpb = &hw->dpb;
+	int i;
+
+	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
+
+	if (!hw) {
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
+			"decoder is not running\n");
+		return IRQ_HANDLED;
+	}
+
+	p_H264_Dpb->vdec = vdec;
+	dec_dpb_status = READ_VREG(DPB_STATUS_REG);
+
+	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+			"%s DPB_STATUS_REG: %x, sb (%x %x %x) bitcnt %x\n",
+			__func__,
+			dec_dpb_status,
+			READ_VREG(VLD_MEM_VIFIFO_LEVEL),
+			READ_VREG(VLD_MEM_VIFIFO_WP),
+			READ_VREG(VLD_MEM_VIFIFO_RP),
+			READ_VREG(VIFF_BIT_CNT));
+
+	if (dec_dpb_status == H264_CONFIG_REQUEST) {
+		WRITE_VREG(DPB_STATUS_REG, H264_ACTION_CONFIG_DONE);
+#ifdef USE_CMA
+		if (hw->set_params_done) {
+			WRITE_VREG(AV_SCRATCH_0,
+				(hw->max_reference_size<<24) |
+				(hw->buffer_spec_num<<16) |
+				(hw->buffer_spec_num<<8));
+		} else {
+			hw->dec_result = DEC_RESULT_CONFIG_PARAM;
+			schedule_work(&hw->work);
+		}
+#else
+		if (vh264_set_params(hw) < 0) {
+			hw->fatal_error_flag = DECODER_FATAL_ERROR_UNKNOW;
+			if (!hw->fatal_error_reset)
+				schedule_work(&hw->error_wd_work);
+		}
+#endif
+	} else if (dec_dpb_status == H264_SLICE_HEAD_DONE) {
+		int slice_header_process_status = 0;
+		unsigned short *p = (unsigned short *)hw->lmem_addr;
+
+		dma_sync_single_for_cpu(
+			amports_get_dma_device(),
+			hw->lmem_addr_remap,
+			PAGE_SIZE,
+			DMA_FROM_DEVICE);
+#if 0
+		if (p_H264_Dpb->mVideo.dec_picture == NULL) {
+			if (!is_buffer_available(vdec)) {
+				hw->buffer_empty_flag = 1;
+				dpb_print(hw->dpb.decoder_index,
+				PRINT_FLAG_UCODE_EVT,
+				"%s, buffer_empty, newframe_q(%d), have_free_buf_spec(%d), init_done(%d), used_size(%d/%d), is_there_unused_frame_from_dpb(%d)\n",
+					__func__,
+					kfifo_len(&hw->newframe_q),
+					have_free_buf_spec(vdec),
+					p_H264_Dpb->mDPB.init_done,
+					p_H264_Dpb->mDPB.used_size,
+					p_H264_Dpb->mDPB.size,
+					is_there_unused_frame_from_dpb(
+						&p_H264_Dpb->mDPB));
+				return IRQ_HANDLED;
+			}
+		}
+
+		hw->buffer_empty_flag = 0;
+#endif
+#ifdef SEND_PARAM_WITH_REG
+		for (i = 0; i < (RPM_END-RPM_BEGIN); i++) {
+			unsigned int data32;
+			do {
+				data32 = READ_VREG(RPM_CMD_REG);
+				/* printk("%x\n", data32); */
+			} while ((data32&0x10000) == 0);
+			p_H264_Dpb->dpb_param.l.data[i] = data32 & 0xffff;
+			WRITE_VREG(RPM_CMD_REG, 0);
+			/* printk("%x:%x\n", i,data32); */
+		}
+#else
+		for (i = 0; i < (RPM_END-RPM_BEGIN); i += 4) {
+			int ii;
+			for (ii = 0; ii < 4; ii++) {
+				p_H264_Dpb->dpb_param.l.data[i+ii] =
+					p[i+3-ii];
+			}
+		}
+#endif
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+			"current dpb index %d, poc %d, top/bot poc (%d,%d)\n",
+			p_H264_Dpb->dpb_param.dpb.current_dpb_index,
+			val(p_H264_Dpb->dpb_param.dpb.frame_pic_order_cnt),
+			val(p_H264_Dpb->dpb_param.dpb.top_field_pic_order_cnt),
+			val(p_H264_Dpb->dpb_param.dpb.top_field_pic_order_cnt));
+
+		slice_header_process_status =
+			h264_slice_header_process(p_H264_Dpb);
+
+		if (p_H264_Dpb->mVideo.dec_picture) {
+			if (slice_header_process_status == 1) {
+				dpb_print(hw->dpb.decoder_index,
+				PRINT_FLAG_UCODE_EVT,
+				"==================> frame count %d\n",
+				hw->decode_pic_count+1);
+			}
+			config_decode_buf(hw, p_H264_Dpb->mVideo.dec_picture);
+		}
+		if (slice_header_process_status == 1)
+			WRITE_VREG(DPB_STATUS_REG, H264_ACTION_DECODE_NEWPIC);
+		else
+			WRITE_VREG(DPB_STATUS_REG, H264_ACTION_DECODE_SLICE);
+		hw->last_mby_mbx = 0;
+		hw->last_ucode_watchdog_reg_val = 0;
+		hw->decode_timeout_count = 2;
+	} else if (dec_dpb_status == H264_PIC_DATA_DONE) {
+		if (p_H264_Dpb->mVideo.dec_picture) {
+			if (hw->chunk) {
+				p_H264_Dpb->mVideo.dec_picture->pts =
+					hw->chunk->pts;
+				p_H264_Dpb->mVideo.dec_picture->pts64 =
+					hw->chunk->pts64;
+			} else {
+				struct StorablePicture *pic =
+					p_H264_Dpb->mVideo.dec_picture;
+				u32 offset = pic->offset_delimiter_lo |
+					(pic->offset_delimiter_hi << 16);
+				if (pts_lookup_offset_us64(PTS_TYPE_VIDEO,
+					offset, &pic->pts, 0, &pic->pts64)) {
+					pic->pts = 0;
+					pic->pts64 = 0;
+				}
+			}
+			store_picture_in_dpb(p_H264_Dpb,
+				p_H264_Dpb->mVideo.dec_picture);
+
+			bufmgr_post(p_H264_Dpb);
+
+			p_H264_Dpb->mVideo.dec_picture = NULL;
+			/* dump_dpb(&p_H264_Dpb->mDPB); */
+		}
+
+		if ((h264_debug_flag&ONLY_RESET_AT_START) == 0)
+			amvdec_stop();
+		hw->decode_pic_count++,
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
+			"%s H264_PIC_DATA_DONE decode slice count %d\n",
+			__func__,
+			hw->decode_pic_count);
+		/* WRITE_VREG(DPB_STATUS_REG, H264_ACTION_SEARCH_HEAD); */
+		hw->dec_result = DEC_RESULT_DONE;
+		reset_process_time(hw);
+		schedule_work(&hw->work);
+	} else if (/*(dec_dpb_status == H264_DATA_REQUEST) ||*/
+			(dec_dpb_status == H264_SEARCH_BUFEMPTY) ||
+			(dec_dpb_status == H264_DECODE_BUFEMPTY) ||
+			(dec_dpb_status == H264_DECODE_TIMEOUT)) {
+empty_proc:
+		if (p_H264_Dpb->mVideo.dec_picture) {
+			remove_picture(p_H264_Dpb,
+				p_H264_Dpb->mVideo.dec_picture);
+			p_H264_Dpb->mVideo.dec_picture = NULL;
+		}
+
+		if (input_frame_based(vdec) ||
+			(READ_VREG(VLD_MEM_VIFIFO_LEVEL) > 0x200)) {
+			if (h264_debug_flag &
+				DISABLE_ERROR_HANDLE) {
+				dpb_print(hw->dpb.decoder_index,
+				PRINT_FLAG_ERROR,
+					"%s decoding error, level 0x%x\n",
+					__func__,
+					READ_VREG(VLD_MEM_VIFIFO_LEVEL));
+				goto send_again;
+			}
+			if ((h264_debug_flag & ONLY_RESET_AT_START) == 0)
+				amvdec_stop();
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_UCODE_EVT,
+				"%s %s\n", __func__,
+				(dec_dpb_status == H264_SEARCH_BUFEMPTY) ?
+				"H264_SEARCH_BUFEMPTY" :
+				(dec_dpb_status == H264_DECODE_BUFEMPTY) ?
+				"H264_DECODE_BUFEMPTY" : "H264_DECODE_TIMEOUT");
+			hw->dec_result = DEC_RESULT_DONE;
+
+			if (dec_dpb_status == H264_SEARCH_BUFEMPTY)
+				hw->search_dataempty_num++;
+			else if (dec_dpb_status == H264_DECODE_TIMEOUT)
+				hw->decode_timeout_num++;
+			else if (dec_dpb_status == H264_DECODE_BUFEMPTY)
+				hw->decode_dataempty_num++;
+
+
+			reset_process_time(hw);
+			schedule_work(&hw->work);
+		} else {
+			/* WRITE_VREG(DPB_STATUS_REG, H264_ACTION_INIT); */
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
+				"%s DEC_RESULT_AGAIN\n", __func__);
+send_again:
+			hw->dec_result = DEC_RESULT_AGAIN;
+			schedule_work(&hw->work);
+		}
+	} else if (dec_dpb_status == H264_DATA_REQUEST) {
+		if (input_frame_based(vdec)) {
+			dpb_print(hw->dpb.decoder_index,
+			PRINT_FLAG_VDEC_STATUS,
+			"%s H264_DATA_REQUEST\n", __func__);
+			hw->dec_result = DEC_RESULT_GET_DATA;
+			schedule_work(&hw->work);
+		} else
+			goto empty_proc;
+	}
+
+	/* ucode debug */
+	if (READ_VREG(DEBUG_REG1) & 0x10000) {
+		int i;
+		unsigned short *p = (unsigned short *)hw->lmem_addr;
+
+		dma_sync_single_for_cpu(
+			amports_get_dma_device(),
+			hw->lmem_addr_remap,
+			PAGE_SIZE,
+			DMA_FROM_DEVICE);
+
+		pr_info("LMEM<tag %x>:\n", READ_VREG(DEBUG_REG1));
+		for (i = 0; i < 0x400; i += 4) {
+			int ii;
+			if ((i & 0xf) == 0)
+				pr_info("%03x: ", i);
+			for (ii = 0; ii < 4; ii++)
+				pr_info("%04x ", p[i+3-ii]);
+			if (((i+ii) & 0xf) == 0)
+				pr_info("\n");
+		}
+		WRITE_VREG(DEBUG_REG1, 0);
+	} else if (READ_VREG(DEBUG_REG1) != 0) {
+		pr_info("dbg%x: %x\n", READ_VREG(DEBUG_REG1),
+			READ_VREG(DEBUG_REG2));
+		WRITE_VREG(DEBUG_REG1, 0);
+	}
+	/**/
+
+	return IRQ_HANDLED;
+}
+
+static void timeout_process(struct vdec_h264_hw_s *hw)
+{
+	hw->timeout_num++;
+	if ((h264_debug_flag & ONLY_RESET_AT_START) == 0)
+		amvdec_stop();
+	dpb_print(hw->dpb.decoder_index,
+		PRINT_FLAG_ERROR, "%s decoder timeout\n", __func__);
+	hw->dec_result = DEC_RESULT_DONE;
+	reset_process_time(hw);
+	schedule_work(&hw->work);
+}
+
+static void check_timer_func(unsigned long arg)
+{
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)arg;
+
+	if ((h264_debug_cmd & 0x100) != 0 &&
+		hw_to_vdec(hw)->id == (h264_debug_cmd & 0xff)) {
+		hw->dec_result = DEC_RESULT_DONE;
+		schedule_work(&hw->work);
+		pr_info("vdec %d is forced to be disconnected\n",
+			h264_debug_cmd & 0xff);
+		h264_debug_cmd = 0;
+		return;
+	}
+
+	if (hw_to_vdec(hw)->next_status == VDEC_STATUS_DISCONNECTED) {
+		hw->dec_result = DEC_RESULT_DONE;
+		schedule_work(&hw->work);
+		pr_info("vdec requested to be disconnected\n");
+		return;
+	}
+
+	if (radr != 0) {
+		if (rval != 0) {
+			WRITE_VREG(radr, rval);
+			pr_info("WRITE_VREG(%x,%x)\n", radr, rval);
+		} else
+			pr_info("READ_VREG(%x)=%x\n", radr, READ_VREG(radr));
+		rval = 0;
+		radr = 0;
+	}
+
+	if ((input_frame_based(hw_to_vdec(hw)) ||
+		(READ_VREG(VLD_MEM_VIFIFO_LEVEL) > 0x200)) &&
+		((h264_debug_flag & DISABLE_ERROR_HANDLE) == 0) &&
+		(decode_timeout_val > 0) &&
+		(hw->start_process_time > 0) &&
+		((1000 * (jiffies - hw->start_process_time) / HZ)
+			> decode_timeout_val)
+	) {
+		u32 dpb_status = READ_VREG(DPB_STATUS_REG);
+		u32 mby_mbx = READ_VREG(MBY_MBX);
+		if ((dpb_status == H264_ACTION_DECODE_NEWPIC) ||
+			(dpb_status == H264_ACTION_DECODE_SLICE)) {
+			if (hw->last_mby_mbx == mby_mbx) {
+				if (hw->decode_timeout_count > 0)
+					hw->decode_timeout_count--;
+				if (hw->decode_timeout_count == 0)
+					timeout_process(hw);
+			}
+		} else if (is_in_parsing_state(dpb_status)) {
+			if (hw->last_ucode_watchdog_reg_val ==
+				READ_VREG(UCODE_WATCHDOG_REG)) {
+				if (hw->decode_timeout_count > 0)
+					hw->decode_timeout_count--;
+				if (hw->decode_timeout_count == 0)
+					timeout_process(hw);
+			}
+		}
+		hw->last_ucode_watchdog_reg_val =
+			READ_VREG(UCODE_WATCHDOG_REG);
+		hw->last_mby_mbx = mby_mbx;
+	}
+
+	hw->check_timer.expires = jiffies + CHECK_INTERVAL;
+
+	add_timer(&hw->check_timer);
+}
+
+static int dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+{
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
+	vstatus->width = hw->frame_width;
+	vstatus->height = hw->frame_height;
+	if (hw->frame_dur != 0)
+		vstatus->fps = 96000 / hw->frame_dur;
+	else
+		vstatus->fps = -1;
+	vstatus->error_count = READ_VREG(AV_SCRATCH_D);
+	vstatus->status = hw->stat;
+	/* if (fatal_error_reset)
+		vstatus->status |= hw->fatal_error_flag; */
+	return 0;
+}
+
+static int vh264_hw_ctx_restore(struct vdec_h264_hw_s *hw)
+{
+	int i;
+
+	/* if (hw->init_flag == 0) { */
+	if (h264_debug_flag & 0x40000000) {
+		/* if (1) */
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
+		"%s, reset register\n", __func__);
+
+		while (READ_VREG(DCAC_DMA_CTRL) & 0x8000)
+			;
+		while (READ_VREG(LMEM_DMA_CTRL) & 0x8000)
+			;    /* reg address is 0x350 */
+
+#if 1 /* MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
+		WRITE_VREG(DOS_SW_RESET0, (1<<7) | (1<<6) | (1<<4));
+		WRITE_VREG(DOS_SW_RESET0, 0);
+
+		READ_VREG(DOS_SW_RESET0);
+		READ_VREG(DOS_SW_RESET0);
+		READ_VREG(DOS_SW_RESET0);
+
+		WRITE_VREG(DOS_SW_RESET0, (1<<7) | (1<<6) | (1<<4));
+		WRITE_VREG(DOS_SW_RESET0, 0);
+
+		WRITE_VREG(DOS_SW_RESET0, (1<<9) | (1<<8));
+		WRITE_VREG(DOS_SW_RESET0, 0);
+
+		READ_VREG(DOS_SW_RESET0);
+		READ_VREG(DOS_SW_RESET0);
+		READ_VREG(DOS_SW_RESET0);
+
+#else
+		WRITE_MPEG_REG(RESET0_REGISTER,
+			RESET_IQIDCT | RESET_MC | RESET_VLD_PART);
+		READ_MPEG_REG(RESET0_REGISTER);
+			WRITE_MPEG_REG(RESET0_REGISTER,
+			RESET_IQIDCT | RESET_MC | RESET_VLD_PART);
+
+		WRITE_MPEG_REG(RESET2_REGISTER, RESET_PIC_DC | RESET_DBLK);
+#endif
+		WRITE_VREG(POWER_CTL_VLD,
+			READ_VREG(POWER_CTL_VLD) | (0 << 10) |
+				(1 << 9) | (1 << 6));
+	} else {
+		/* WRITE_VREG(POWER_CTL_VLD,
+			READ_VREG(POWER_CTL_VLD) | (0 << 10) | (1 << 9) ); */
+		WRITE_VREG(POWER_CTL_VLD,
+			READ_VREG(POWER_CTL_VLD) |
+				(0 << 10) | (1 << 9) | (1 << 6));
+	}
+	/* disable PSCALE for hardware sharing */
+	WRITE_VREG(PSCALE_CTRL, 0);
+
+	/* clear mailbox interrupt */
+	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
+
+	/* enable mailbox interrupt */
+	WRITE_VREG(ASSIST_MBOX1_MASK, 1);
+
+#ifdef NV21
+	SET_VREG_MASK(MDEC_PIC_DC_CTRL, 1<<17);
+#endif
+
+#if 1 /* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
+	/* pr_info("vh264 meson8 prot init\n"); */
+	WRITE_VREG(MDEC_PIC_DC_THRESH, 0x404038aa);
+#endif
+	if (hw->decode_pic_count > 0) {
+		WRITE_VREG(AV_SCRATCH_7, (hw->max_reference_size << 24) |
+			(hw->buffer_spec_num << 16) |
+			(hw->buffer_spec_num << 8));
+		for (i = 0; i < hw->buffer_spec_num; i++) {
+			canvas_config(hw->buffer_spec[i].y_canvas_index,
+				hw->buffer_spec[i].y_addr,
+				hw->mb_width << 4,
+				hw->mb_height << 4,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_32X32);
+
+			canvas_config(hw->buffer_spec[i].u_canvas_index,
+				hw->buffer_spec[i].u_addr,
+				hw->mb_width << 4,
+				hw->mb_height << 3,
+				CANVAS_ADDR_NOWRAP,
+				CANVAS_BLKMODE_32X32);
+
+			WRITE_VREG(ANC0_CANVAS_ADDR + i,
+				spec2canvas(&hw->buffer_spec[i]));
+		}
+	} else {
+		WRITE_VREG(AV_SCRATCH_0, 0);
+		WRITE_VREG(AV_SCRATCH_9, 0);
+	}
+
+	if (hw->init_flag == 0)
+		WRITE_VREG(DPB_STATUS_REG, 0);
+	else
+		WRITE_VREG(DPB_STATUS_REG, H264_ACTION_DECODE_START);
+
+	WRITE_VREG(FRAME_COUNTER_REG, hw->decode_pic_count);
+	WRITE_VREG(AV_SCRATCH_8, hw->buf_offset);
+	WRITE_VREG(AV_SCRATCH_G, hw->mc_dma_handle);
+
+	/* hw->error_recovery_mode = (error_recovery_mode != 0) ?
+		error_recovery_mode : error_recovery_mode_in; */
+	/* WRITE_VREG(AV_SCRATCH_F,
+		(READ_VREG(AV_SCRATCH_F) & 0xffffffc3) ); */
+	WRITE_VREG(AV_SCRATCH_F, (READ_VREG(AV_SCRATCH_F) & 0xffffffc3) |
+		((error_recovery_mode_in & 0x1) << 4));
+	if (hw->ucode_type == UCODE_IP_ONLY_PARAM)
+		SET_VREG_MASK(AV_SCRATCH_F, 1 << 6);
+	else
+		CLEAR_VREG_MASK(AV_SCRATCH_F, 1 << 6);
+
+	WRITE_VREG(LMEM_DUMP_ADR, (u32)hw->lmem_addr_remap);
+#if 1 /* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
+	WRITE_VREG(MDEC_PIC_DC_THRESH, 0x404038aa);
+#endif
+
+	WRITE_VREG(DEBUG_REG1, 0);
+	WRITE_VREG(DEBUG_REG2, 0);
+	return 0;
+}
+
+static unsigned char amvdec_enable_flag;
+static void vh264_local_init(struct vdec_h264_hw_s *hw)
+{
+	int i;
+	hw->decode_timeout_count = 0;
+
+	hw->vh264_ratio = hw->vh264_amstream_dec_info.ratio;
+	/* vh264_ratio = 0x100; */
+
+	hw->vh264_rotation = (((unsigned long)
+			hw->vh264_amstream_dec_info.param) >> 16) & 0xffff;
+
+	hw->frame_prog = 0;
+	hw->frame_width = hw->vh264_amstream_dec_info.width;
+	hw->frame_height = hw->vh264_amstream_dec_info.height;
+	hw->frame_dur = hw->vh264_amstream_dec_info.rate;
+	hw->pts_outside = ((unsigned long)
+			hw->vh264_amstream_dec_info.param) & 0x01;
+	hw->sync_outside = ((unsigned long)
+			hw->vh264_amstream_dec_info.param & 0x02) >> 1;
+	hw->use_idr_framerate = ((unsigned long)
+			hw->vh264_amstream_dec_info.param & 0x04) >> 2;
+	hw->max_refer_buf = !(((unsigned long)
+			hw->vh264_amstream_dec_info.param & 0x10) >> 4);
+	if (hw->frame_dur < 96000/960) {
+		/*more than 960fps,it should not be a correct value,
+		give default 30fps*/
+		hw->frame_dur = 96000/30;
+	}
+
+	pr_info
+	("H264 sysinfo: %dx%d duration=%d, pts_outside=%d, ",
+	 hw->frame_width, hw->frame_height, hw->frame_dur, hw->pts_outside);
+	pr_info("sync_outside=%d, use_idr_framerate=%d\n",
+	 hw->sync_outside, hw->use_idr_framerate);
+
+	if ((unsigned long) hw->vh264_amstream_dec_info.param & 0x08)
+		hw->ucode_type = UCODE_IP_ONLY_PARAM;
+	else
+		hw->ucode_type = 0;
+
+	if ((unsigned long) hw->vh264_amstream_dec_info.param & 0x20)
+		error_recovery_mode_in = 1;
+	else
+		error_recovery_mode_in = 3;
+
+	INIT_KFIFO(hw->display_q);
+	INIT_KFIFO(hw->newframe_q);
+
+	for (i = 0; i < VF_POOL_SIZE; i++) {
+		const struct vframe_s *vf = &hw->vfpool[i];
+		hw->vfpool[i].index = -1; /* VF_BUF_NUM; */
+		hw->vfpool[i].bufWidth = 1920;
+		kfifo_put(&hw->newframe_q, vf);
+	}
+
+	hw->duration_from_pts_done = 0;
+
+	hw->p_last_vf = NULL;
+	hw->fatal_error_flag = 0;
+	hw->vh264_stream_switching_state = SWITCHING_STATE_OFF;
+
+	INIT_WORK(&hw->work, vh264_work);
+
+	return;
+}
+
+static s32 vh264_init(struct vdec_h264_hw_s *hw)
+{
+	/* int trickmode_fffb = 0; */
+	int firmwareloaded = 0;
+
+	hw->init_flag = 0;
+	hw->set_params_done = 0;
+	hw->start_process_time = 0;
+
+	/* pr_info("\nvh264_init\n"); */
+	/* init_timer(&hw->recycle_timer); */
+
+	/* timer init */
+	init_timer(&hw->check_timer);
+
+	hw->check_timer.data = (unsigned long)hw;
+	hw->check_timer.function = check_timer_func;
+	hw->check_timer.expires = jiffies + CHECK_INTERVAL;
+
+	/* add_timer(&hw->check_timer); */
+	hw->stat |= STAT_TIMER_ARM;
+
+	hw->duration_on_correcting = 0;
+	hw->fixed_frame_rate_check_count = 0;
+	hw->saved_resolution = 0;
+
+	vh264_local_init(hw);
+
+	if (!amvdec_enable_flag) {
+		amvdec_enable_flag = true;
+		amvdec_enable();
+	}
+
+	/* -- ucode loading (amrisc and swap code) */
+	hw->mc_cpu_addr =
+		dma_alloc_coherent(amports_get_dma_device(), MC_TOTAL_SIZE,
+				&hw->mc_dma_handle, GFP_KERNEL);
+	if (!hw->mc_cpu_addr) {
+		amvdec_enable_flag = false;
+		amvdec_disable();
+
+		pr_info("vh264_init: Can not allocate mc memory.\n");
+		return -ENOMEM;
+	}
+
+	pr_info("264 ucode swap area: phyaddr %p, cpu vaddr %p\n",
+		(void *)hw->mc_dma_handle, hw->mc_cpu_addr);
+	if (!firmwareloaded) {
+		int r0 , r1 , r2 , r3 , r4 , r5, r6, r7, r8;
+		pr_info("start load orignal firmware ...\n");
+		/* r0 = amvdec_loadmc_ex(VFORMAT_H264, "vmh264_mc", NULL); */
+		r0 = 0;
+
+		/*memcpy((u8 *) mc_cpu_addr + MC_OFFSET_HEADER, vh264_header_mc,
+			   MC_SWAP_SIZE);*/
+		r1 = get_decoder_firmware_data(VFORMAT_H264, "vmh264_header_mc",
+			(u8 *) hw->mc_cpu_addr + MC_OFFSET_HEADER,
+			MC_SWAP_SIZE);
+		/*memcpy((u8 *) mc_cpu_addr + MC_OFFSET_DATA, vh264_data_mc,
+			   MC_SWAP_SIZE);
+		*/
+		r2 = get_decoder_firmware_data(VFORMAT_H264, "vmh264_data_mc",
+			(u8 *) hw->mc_cpu_addr + MC_OFFSET_DATA,
+			MC_SWAP_SIZE);
+		/*memcpy((u8 *) mc_cpu_addr + MC_OFFSET_MMCO, vh264_mmco_mc,
+			   MC_SWAP_SIZE);
+		*/
+		r3 = get_decoder_firmware_data(VFORMAT_H264, "vmh264_mmco_mc",
+			(u8 *) hw->mc_cpu_addr + MC_OFFSET_MMCO,
+			MC_SWAP_SIZE);
+		/*memcpy((u8 *) mc_cpu_addr + MC_OFFSET_LIST, vmh264_list_mc,
+			   MC_SWAP_SIZE);
+		*/
+		r4 = get_decoder_firmware_data(VFORMAT_H264, "vmh264_list_mc",
+			(u8 *) hw->mc_cpu_addr + MC_OFFSET_LIST,
+			MC_SWAP_SIZE);
+		/*memcpy((u8 *) mc_cpu_addr + MC_OFFSET_SLICE, vh264_slice_mc,
+			   MC_SWAP_SIZE);
+		*/
+		r5 = get_decoder_firmware_data(VFORMAT_H264, "vmh264_slice_mc",
+			(u8 *) hw->mc_cpu_addr + MC_OFFSET_SLICE,
+			MC_SWAP_SIZE);
+		/*memcpy((u8 *) mc_cpu_addr + MC_OFFSET_MAIN, mbuf,
+		0x800*4)
+		*/
+		r6 = get_decoder_firmware_data(VFORMAT_H264, "vmh264_mc",
+			(u8 *) hw->mc_cpu_addr + MC_OFFSET_MAIN,
+			0x800 * 4);
+		/*memcpy((u8 *) mc_cpu_addr + MC_OFFSET_MAIN + 0x800*4,
+		pvh264_data_mc, 0x400*4);
+		*/
+		r7 = get_decoder_firmware_data(VFORMAT_H264, "vmh264_data_mc",
+			(u8 *) hw->mc_cpu_addr + MC_OFFSET_MAIN + 0x800 * 4,
+			0x400 * 4);
+		/*memcpy((u8 *) mc_cpu_addr + MC_OFFSET_MAIN + 0x800*4 +
+		0x400*4, pvh264_list_mc, 0x400*4);
+		*/
+		r8 = get_decoder_firmware_data(VFORMAT_H264, "vmh264_list_mc",
+			(u8 *) hw->mc_cpu_addr + MC_OFFSET_MAIN + 0x800 * 4
+			+ 0x400 * 4, 0x400 * 4);
+
+		if (r0 < 0 || r1 < 0 || r2 < 0 || r3 < 0 || r4 < 0 ||
+			r5 < 0 || r6 < 0 || r7 < 0 || r8 < 0) {
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
+			"264 load orignal firmware error %d,%d,%d,%d,%d,%d,%d,%d,%d\n",
+				r0 , r1 , r2 , r3 , r4 , r5, r6, r7, r8);
+			amvdec_disable();
+			if (hw->mc_cpu_addr) {
+				dma_free_coherent(amports_get_dma_device(),
+					MC_TOTAL_SIZE, hw->mc_cpu_addr,
+					hw->mc_dma_handle);
+				hw->mc_cpu_addr = NULL;
+			}
+			return -EBUSY;
+		}
+	}
+
+#if 1 /* #ifdef  BUFFER_MGR_IN_C */
+	dpb_init_global(&hw->dpb,
+		hw_to_vdec(hw)->id, 0, 0);
+	hw->lmem_addr = __get_free_page(GFP_KERNEL);
+	if (!hw->lmem_addr) {
+		pr_info("%s: failed to alloc lmem_addr\n", __func__);
+		return -ENOMEM;
+	} else {
+		hw->lmem_addr_remap = dma_map_single(
+				amports_get_dma_device(),
+				(void *)hw->lmem_addr,
+				PAGE_SIZE, DMA_FROM_DEVICE);
+		if (dma_mapping_error(amports_get_dma_device(),
+			hw->lmem_addr_remap)) {
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
+			"%s: failed to map lmem_addr\n", __func__);
+			free_page(hw->lmem_addr);
+			hw->lmem_addr = 0;
+			hw->lmem_addr_remap = 0;
+			return -ENOMEM;
+		}
+
+		pr_info("%s, vaddr=%lx phy_addr=%p\n",
+			__func__, hw->lmem_addr, (void *)hw->lmem_addr_remap);
+	}
+	/* BUFFER_MGR_IN_C */
+#endif
+	hw->stat |= STAT_MC_LOAD;
+
+	/* add memory barrier */
+	wmb();
+
+	return 0;
+}
+
+static int vh264_stop(struct vdec_h264_hw_s *hw, int mode)
+{
+	int i;
+
+	if (hw->stat & STAT_MC_LOAD) {
+		if (hw->mc_cpu_addr != NULL) {
+			dma_free_coherent(amports_get_dma_device(),
+					MC_TOTAL_SIZE, hw->mc_cpu_addr,
+					hw->mc_dma_handle);
+			hw->mc_cpu_addr = NULL;
+		}
+	}
+#ifdef USE_CMA
+	if (hw->cma_alloc_addr) {
+		pr_info("codec_mm release buffer 0x%lx\n", hw->cma_alloc_addr);
+		codec_mm_free_for_dma(MEM_NAME, hw->cma_alloc_addr);
+		 hw->cma_alloc_count = 0;
+	}
+
+	if (hw->collocate_cma_alloc_addr) {
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
+			"codec_mm release collocate buffer 0x%lx\n",
+			hw->collocate_cma_alloc_addr);
+		codec_mm_free_for_dma(MEM_NAME, hw->collocate_cma_alloc_addr);
+		hw->collocate_cma_alloc_count = 0;
+	}
+
+	for (i = 0; i < hw->buffer_spec_num; i++) {
+		if (hw->buffer_spec[i].cma_alloc_addr) {
+			pr_info("codec_mm release buffer_spec[%d], 0x%lx\n", i,
+				hw->buffer_spec[i].cma_alloc_addr);
+			codec_mm_free_for_dma(MEM_NAME,
+				hw->buffer_spec[i].cma_alloc_addr);
+			hw->buffer_spec[i].cma_alloc_count = 0;
+		}
+	}
+
+#endif
+
+	if (hw->lmem_addr_remap) {
+		dma_unmap_single(amports_get_dma_device(),
+			hw->lmem_addr_remap,
+			PAGE_SIZE, DMA_FROM_DEVICE);
+		hw->lmem_addr_remap = 0;
+	}
+	if (hw->lmem_addr) {
+		free_page(hw->lmem_addr);
+		hw->lmem_addr = 0;
+	}
+	cancel_work_sync(&hw->work);
+
+	/* amvdec_disable(); */
+
+	return 0;
+}
+
+static void vh264_work(struct work_struct *work)
+{
+	struct vdec_h264_hw_s *hw = container_of(work,
+		struct vdec_h264_hw_s, work);
+	struct vdec_s *vdec = hw_to_vdec(hw);
+
+	/* finished decoding one frame or error,
+	 * notify vdec core to switch context
+	 */
+	dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_DETAIL,
+		"%s  %x %x %x\n", __func__,
+		READ_VREG(0xc47), READ_VREG(0xc45), READ_VREG(0xc46));
+
+#ifdef USE_CMA
+	if (hw->dec_result == DEC_RESULT_CONFIG_PARAM) {
+		if (vh264_set_params(hw) < 0) {
+			hw->fatal_error_flag = DECODER_FATAL_ERROR_UNKNOW;
+			if (!hw->fatal_error_reset)
+				schedule_work(&hw->error_wd_work);
+		}
+		return;
+	} else
+#endif
+	if ((hw->dec_result == DEC_RESULT_GET_DATA) ||
+		(hw->dec_result == DEC_RESULT_GET_DATA_RETRY)) {
+		if (hw->dec_result == DEC_RESULT_GET_DATA) {
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
+				"%s DEC_RESULT_GET_DATA %x %x %x\n",
+				__func__,
+				READ_VREG(VLD_MEM_VIFIFO_LEVEL),
+				READ_VREG(VLD_MEM_VIFIFO_WP),
+				READ_VREG(VLD_MEM_VIFIFO_RP));
+			vdec_vframe_dirty(vdec, hw->chunk);
+			vdec_clean_input(vdec);
+		}
+
+		if (is_buffer_available(vdec)) {
+			int r;
+			r = vdec_prepare_input(vdec, &hw->chunk);
+			if (r < 0) {
+				hw->dec_result = DEC_RESULT_GET_DATA_RETRY;
+
+				dpb_print(hw->dpb.decoder_index,
+					PRINT_FLAG_VDEC_DETAIL,
+					"ammvdec_vh264: Insufficient data\n");
+
+				schedule_work(&hw->work);
+				return;
+			}
+			hw->dec_result = DEC_RESULT_NONE;
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
+				"%s: chunk size 0x%x\n",
+				__func__, hw->chunk->size);
+			WRITE_VREG(POWER_CTL_VLD,
+				READ_VREG(POWER_CTL_VLD) |
+					(0 << 10) | (1 << 9) | (1 << 6));
+			WRITE_VREG(H264_DECODE_INFO, (1<<13));
+			WRITE_VREG(H264_DECODE_SIZE, hw->chunk->size);
+			WRITE_VREG(VIFF_BIT_CNT, (hw->chunk->size * 8));
+			vdec_enable_input(vdec);
+
+			WRITE_VREG(DPB_STATUS_REG, H264_ACTION_SEARCH_HEAD);
+		} else{
+			hw->dec_result = DEC_RESULT_GET_DATA_RETRY;
+
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_DETAIL,
+				"ammvdec_vh264: Insufficient data\n");
+
+			schedule_work(&hw->work);
+		}
+		return;
+	} else if (hw->dec_result == DEC_RESULT_DONE) {
+		/* if (!hw->ctx_valid)
+			hw->ctx_valid = 1; */
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
+			"%s dec_result %d %x %x %x\n",
+			__func__,
+			hw->dec_result,
+			READ_VREG(VLD_MEM_VIFIFO_LEVEL),
+			READ_VREG(VLD_MEM_VIFIFO_WP),
+			READ_VREG(VLD_MEM_VIFIFO_RP));
+		vdec_vframe_dirty(hw_to_vdec(hw), hw->chunk);
+	} else {
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_DETAIL,
+			"%s dec_result %d %x %x %x\n",
+			__func__,
+			hw->dec_result,
+			READ_VREG(VLD_MEM_VIFIFO_LEVEL),
+			READ_VREG(VLD_MEM_VIFIFO_WP),
+			READ_VREG(VLD_MEM_VIFIFO_RP));
+	}
+
+	del_timer_sync(&hw->check_timer);
+	hw->stat &= ~STAT_TIMER_ARM;
+
+	/* mark itself has all HW resource released and input released */
+	vdec_set_status(hw_to_vdec(hw), VDEC_STATUS_CONNECTED);
+
+	if (hw->vdec_cb)
+		hw->vdec_cb(hw_to_vdec(hw), hw->vdec_cb_arg);
+}
+
+static bool run_ready(struct vdec_s *vdec)
+{
+	if (vdec->master)
+		return false;
+
+	if ((!input_frame_based(vdec)) && (start_decode_buf_level > 0)) {
+		u32 rp, wp;
+		u32 level;
+
+		rp = READ_MPEG_REG(PARSER_VIDEO_RP);
+		wp = READ_MPEG_REG(PARSER_VIDEO_WP);
+
+		if (wp < rp)
+			level = vdec->input.size + wp - rp;
+		else
+			level = wp - rp;
+
+		if (level < start_decode_buf_level) {
+			struct vdec_h264_hw_s *hw =
+				(struct vdec_h264_hw_s *)vdec->private;
+			dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_DETAIL,
+				"%s vififo level low %x(<%x) (lev%x wp%x rp%x)\n",
+				__func__, level,
+				start_decode_buf_level,
+				READ_VREG(VLD_MEM_VIFIFO_LEVEL),
+				READ_VREG(VLD_MEM_VIFIFO_WP),
+				READ_VREG(VLD_MEM_VIFIFO_RP));
+			return 0;
+		}
+	}
+
+	if (h264_debug_flag & 0x20000000) {
+		/* pr_info("%s, a\n", __func__); */
+		return 1;
+	} else {
+		return is_buffer_available(vdec);
+	}
+}
+
+static void run(struct vdec_s *vdec,
+	void (*callback)(struct vdec_s *, void *), void *arg)
+{
+	struct vdec_h264_hw_s *hw =
+		(struct vdec_h264_hw_s *)vdec->private;
+	int size;
+
+	hw->vdec_cb_arg = arg;
+	hw->vdec_cb = callback;
+
+	/* hw->chunk = vdec_prepare_input(vdec); */
+	size = vdec_prepare_input(vdec, &hw->chunk);
+	if ((size < 0) ||
+		(input_frame_based(vdec) && hw->chunk == NULL)) {
+		hw->dec_result = DEC_RESULT_AGAIN;
+
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_DETAIL,
+			"ammvdec_vh264: Insufficient data\n");
+
+		schedule_work(&hw->work);
+		return;
+	}
+
+	hw->dec_result = DEC_RESULT_NONE;
+#if 0
+	if ((!input_frame_based(vdec)) && (start_decode_buf_level > 0)) {
+		if (READ_VREG(VLD_MEM_VIFIFO_LEVEL) <
+			start_decode_buf_level) {
+			dpb_print(hw->dpb.decoder_index,
+				PRINT_FLAG_VDEC_DETAIL,
+				"%s: VIFIFO_LEVEL %x is low (<%x)\n",
+				__func__,
+				READ_VREG(VLD_MEM_VIFIFO_LEVEL),
+				start_decode_buf_level);
+
+			hw->dec_result = DEC_RESULT_AGAIN;
+			schedule_work(&hw->work);
+			return;
+		}
+	}
+#endif
+
+	if (input_frame_based(vdec)) {
+		u8 *data = ((u8 *)hw->chunk->block->start_virt) +
+			hw->chunk->offset;
+
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
+			"%s: size 0x%x %02x %02x %02x %02x %02x %02x .. %02x %02x %02x %02x\n",
+			__func__, size,
+			data[0], data[1], data[2], data[3],
+			data[4], data[5], data[size - 4],
+			data[size - 3],	data[size - 2],
+			data[size - 1]);
+	} else
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_VDEC_STATUS,
+			"%s: %x %x %x size 0x%x\n",
+			__func__,
+			READ_VREG(VLD_MEM_VIFIFO_LEVEL),
+			READ_VREG(VLD_MEM_VIFIFO_WP),
+			READ_VREG(VLD_MEM_VIFIFO_RP), size);
+
+	hw->start_process_time = jiffies;
+
+	if (((h264_debug_flag & ONLY_RESET_AT_START) == 0) ||
+		(hw->init_flag == 0)) {
+		if (amvdec_vdec_loadmc_ex(vdec, "vmh264_mc") < 0) {
+			amvdec_enable_flag = false;
+			amvdec_disable();
+			pr_info("%s: Error amvdec_vdec_loadmc fail\n",
+				__func__);
+			return;
+		}
+
+		if (vh264_hw_ctx_restore(hw) < 0) {
+			schedule_work(&hw->work);
+			return;
+		}
+		if (input_frame_based(vdec)) {
+			WRITE_VREG(H264_DECODE_INFO, (1<<13));
+			WRITE_VREG(H264_DECODE_SIZE, hw->chunk->size);
+			WRITE_VREG(VIFF_BIT_CNT, (hw->chunk->size * 8));
+		} else {
+			if (size <= 0)
+				size = 0x7fffffff; /*error happen*/
+			WRITE_VREG(H264_DECODE_INFO, (1<<13));
+			WRITE_VREG(H264_DECODE_SIZE, size);
+			WRITE_VREG(VIFF_BIT_CNT, size * 8);
+		}
+
+		vdec_enable_input(vdec);
+
+		add_timer(&hw->check_timer);
+
+		amvdec_start();
+
+		/* if (hw->init_flag) { */
+			WRITE_VREG(DPB_STATUS_REG, H264_ACTION_SEARCH_HEAD);
+		/* } */
+
+		hw->init_flag = 1;
+	} else {
+		WRITE_VREG(H264_DECODE_INFO, (1 << 13));
+		vdec_enable_input(vdec);
+
+		WRITE_VREG(DPB_STATUS_REG, H264_ACTION_SEARCH_HEAD);
+	}
+}
+
+static void reset(struct vdec_s *vdec)
+{
+	pr_info("ammvdec_h264: reset.\n");
+
+#if 0
+	struct vdec_h264_hw_s *hw = (struct vdec_h264_hw_s *)vdec->private;
+
+	hw->init_flag = 0;
+	hw->set_params_done = 0;
+
+	vh264_local_init(hw);
+
+	dpb_init_global(&hw->dpb);
+#endif
+}
+
+static int ammvdec_h264_probe(struct platform_device *pdev)
+{
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
+	struct vdec_h264_hw_s *hw = NULL;
+
+	if (pdata == NULL) {
+		pr_info("\nammvdec_h264 memory resource undefined.\n");
+		return -EFAULT;
+	}
+
+	hw = (struct vdec_h264_hw_s *)devm_kzalloc(&pdev->dev,
+		sizeof(struct vdec_h264_hw_s), GFP_KERNEL);
+	if (hw == NULL) {
+		pr_info("\nammvdec_h264 device data allocation failed\n");
+		return -ENOMEM;
+	}
+
+	pdata->private = hw;
+	pdata->dec_status = dec_status;
+	/* pdata->set_trickmode = set_trickmode; */
+	pdata->run_ready = run_ready;
+	pdata->run = run;
+	pdata->reset = reset;
+	pdata->irq_handler = vh264_isr;
+
+	pdata->id = pdev->id;
+
+	if (pdata->use_vfm_path)
+		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
+			VFM_DEC_PROVIDER_NAME);
+	else if (vdec_dual(pdata)) {
+		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
+			(pdata->master) ? VFM_DEC_DVEL_PROVIDER_NAME :
+			VFM_DEC_DVBL_PROVIDER_NAME);
+	} else
+		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
+			PROVIDER_NAME ".%02x", pdev->id & 0xff);
+
+	vf_provider_init(&pdata->vframe_provider, pdata->vf_provider_name,
+		&vf_provider_ops, pdata);
+
+	platform_set_drvdata(pdev, pdata);
+
+	hw->platform_dev = pdev;
+#ifndef USE_CMA
+	hw->buf_start = pdata->mem_start;
+	hw->buf_size = pdata->mem_end - pdata->mem_start + 1;
+	/* hw->ucode_map_start = pdata->mem_start; */
+	if (hw->buf_size < DEFAULT_MEM_SIZE) {
+		pr_info("\nammvdec_h264 memory size not enough.\n");
+		return -ENOMEM;
+	}
+#endif
+
+#ifdef USE_CMA
+	hw->cma_dev = pdata->cma_dev;
+	if (hw->cma_alloc_count == 0) {
+		hw->cma_alloc_count = PAGE_ALIGN(V_BUF_ADDR_OFFSET) / PAGE_SIZE;
+		hw->cma_alloc_addr = codec_mm_alloc_for_dma(MEM_NAME,
+					hw->cma_alloc_count,
+					4, CODEC_MM_FLAGS_FOR_VDECODER);
+	}
+	if (!hw->cma_alloc_addr) {
+		dpb_print(hw->dpb.decoder_index, PRINT_FLAG_ERROR,
+			"codec_mm alloc failed, request buf size 0x%lx\n",
+				hw->cma_alloc_count * PAGE_SIZE);
+		hw->cma_alloc_count = 0;
+		return -ENOMEM;
+	}
+	hw->buf_offset = hw->cma_alloc_addr - DEF_BUF_START_ADDR;
+#else
+	hw->buf_offset = pdata->mem_start - DEF_BUF_START_ADDR;
+	hw->buf_start = V_BUF_ADDR_OFFSET + pdata->mem_start;
+#endif
+
+	if (pdata->sys_info)
+		hw->vh264_amstream_dec_info = *pdata->sys_info;
+	if (NULL == hw->sei_data_buffer) {
+		hw->sei_data_buffer =
+			dma_alloc_coherent(amports_get_dma_device(),
+				USER_DATA_SIZE,
+				&hw->sei_data_buffer_phys, GFP_KERNEL);
+		if (!hw->sei_data_buffer) {
+			pr_info("%s: Can not allocate sei_data_buffer\n",
+				   __func__);
+			return -ENOMEM;
+		}
+		/* pr_info("buffer 0x%x, phys 0x%x, remap 0x%x\n",
+		   sei_data_buffer, sei_data_buffer_phys,
+		   (u32)sei_data_buffer_remap); */
+	}
+#ifdef USE_CMA
+	pr_info("ammvdec_h264 mem-addr=%lx,buff_offset=%x,buf_start=%lx\n",
+		pdata->mem_start, hw->buf_offset, hw->cma_alloc_addr);
+#else
+	pr_info("ammvdec_h264 mem-addr=%lx,buff_offset=%x,buf_start=%lx\n",
+		pdata->mem_start, hw->buf_offset, hw->buf_start);
+#endif
+
+	vdec_source_changed(VFORMAT_H264, 3840, 2160, 60);
+
+	if (vh264_init(hw) < 0) {
+		pr_info("\nammvdec_h264 init failed.\n");
+		return -ENODEV;
+	}
+	atomic_set(&hw->vh264_active, 1);
+
+	return 0;
+}
+
+static int ammvdec_h264_remove(struct platform_device *pdev)
+{
+	struct vdec_h264_hw_s *hw =
+		(struct vdec_h264_hw_s *)
+		(((struct vdec_s *)(platform_get_drvdata(pdev)))->private);
+
+	atomic_set(&hw->vh264_active, 0);
+
+	if (hw->stat & STAT_TIMER_ARM) {
+		del_timer_sync(&hw->check_timer);
+		hw->stat &= ~STAT_TIMER_ARM;
+	}
+
+	vh264_stop(hw, MODE_FULL);
+
+	/* vdec_source_changed(VFORMAT_H264, 0, 0, 0); */
+
+	atomic_set(&hw->vh264_active, 0);
+
+	vdec_set_status(hw_to_vdec(hw), VDEC_STATUS_DISCONNECTED);
+
+	return 0;
+}
+
+/****************************************/
+
+static struct platform_driver ammvdec_h264_driver = {
+	.probe = ammvdec_h264_probe,
+	.remove = ammvdec_h264_remove,
+#ifdef CONFIG_PM
+	.suspend = amvdec_suspend,
+	.resume = amvdec_resume,
+#endif
+	.driver = {
+		.name = DRIVER_NAME,
+	}
+};
+
+static struct codec_profile_t ammvdec_h264_profile = {
+	.name = "mh264",
+	.profile = ""
+};
+
+static int __init ammvdec_h264_driver_init_module(void)
+{
+	pr_info("ammvdec_h264 module init\n");
+	if (platform_driver_register(&ammvdec_h264_driver)) {
+		pr_info("failed to register ammvdec_h264 driver\n");
+		return -ENODEV;
+	}
+	vcodec_profile_register(&ammvdec_h264_profile);
+	return 0;
+}
+
+static void __exit ammvdec_h264_driver_remove_module(void)
+{
+	pr_info("ammvdec_h264 module remove.\n");
+
+	platform_driver_unregister(&ammvdec_h264_driver);
+}
+
+/****************************************/
+
+module_param(h264_debug_flag, uint, 0664);
+MODULE_PARM_DESC(h264_debug_flag, "\n ammvdec_h264 h264_debug_flag\n");
+
+module_param(start_decode_buf_level, uint, 0664);
+MODULE_PARM_DESC(start_decode_buf_level,
+		"\n ammvdec_h264 start_decode_buf_level\n");
+
+module_param(fixed_frame_rate_mode, uint, 0664);
+MODULE_PARM_DESC(fixed_frame_rate_mode, "\namvdec_h264 fixed_frame_rate_mode\n");
+
+module_param(decode_timeout_val, uint, 0664);
+MODULE_PARM_DESC(decode_timeout_val, "\n amvdec_h264 decode_timeout_val\n");
+
+module_param(reorder_dpb_size_margin, uint, 0664);
+MODULE_PARM_DESC(reorder_dpb_size_margin, "\n ammvdec_h264 reorder_dpb_size_margin\n");
+
+module_param(reference_buf_margin, uint, 0664);
+MODULE_PARM_DESC(reference_buf_margin, "\n ammvdec_h264 reference_buf_margin\n");
+
+module_param(radr, uint, 0664);
+MODULE_PARM_DESC(radr, "\nradr\n");
+
+module_param(rval, uint, 0664);
+MODULE_PARM_DESC(rval, "\nrval\n");
+
+module_param(h264_debug_mask, uint, 0664);
+MODULE_PARM_DESC(h264_debug_mask, "\n amvdec_h264 h264_debug_mask\n");
+
+module_param(h264_debug_cmd, uint, 0664);
+MODULE_PARM_DESC(h264_debug_cmd, "\n amvdec_h264 h264_debug_cmd\n");
+
+module_param(force_rate_streambase, int, 0664);
+MODULE_PARM_DESC(force_rate_streambase, "\n amvdec_h264 force_rate_streambase\n");
+
+module_param(dec_control, int, 0664);
+MODULE_PARM_DESC(dec_control, "\n amvdec_h264 dec_control\n");
+
+module_param(force_rate_framebase, int, 0664);
+MODULE_PARM_DESC(force_rate_framebase, "\n amvdec_h264 force_rate_framebase\n");
+
+/*
+module_param(trigger_task, uint, 0664);
+MODULE_PARM_DESC(trigger_task, "\n amvdec_h264 trigger_task\n");
+*/
+module_param_array(decode_frame_count, uint, &max_decode_instance_num, 0664);
+
+module_param_array(max_process_time, uint, &max_decode_instance_num, 0664);
+
+module_param_array(max_get_frame_interval, uint,
+	&max_decode_instance_num, 0664);
+
+module_param_array(step, uint, &max_decode_instance_num, 0664);
+
+module_init(ammvdec_h264_driver_init_module);
+module_exit(ammvdec_h264_driver_remove_module);
+
+MODULE_DESCRIPTION("AMLOGIC H264 Video Decoder Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/amports/vmjpeg.c b/drivers/amlogic/amports/vmjpeg.c
index 83b833d..4d0b6af 100644
--- a/drivers/amlogic/amports/vmjpeg.c
+++ b/drivers/amlogic/amports/vmjpeg.c
@@ -386,7 +386,7 @@ static void vmjpeg_put_timer_func(unsigned long arg)
 	add_timer(timer);
 }
 
-int vmjpeg_dec_status(struct vdec_status *vstatus)
+int vmjpeg_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
 {
 	vstatus->width = frame_width;
 	vstatus->height = frame_height;
@@ -773,15 +773,12 @@ static s32 vmjpeg_init(void)
 
 	stat |= STAT_VDEC_RUN;
 
-	set_vdec_func(&vmjpeg_dec_status);
-
 	return 0;
 }
 
 static int amvdec_mjpeg_probe(struct platform_device *pdev)
 {
-	struct vdec_dev_reg_s *pdata =
-		(struct vdec_dev_reg_s *)pdev->dev.platform_data;
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
 
 	mutex_lock(&vmjpeg_mutex);
 
@@ -801,6 +798,8 @@ static int amvdec_mjpeg_probe(struct platform_device *pdev)
 	if (pdata->sys_info)
 		vmjpeg_amstream_dec_info = *pdata->sys_info;
 
+	pdata->dec_status = vmjpeg_dec_status;
+
 	if (vmjpeg_init() < 0) {
 		amlog_level(LOG_LEVEL_ERROR, "amvdec_mjpeg init failed.\n");
 		mutex_unlock(&vmjpeg_mutex);
diff --git a/drivers/amlogic/amports/vmmjpeg.c b/drivers/amlogic/amports/vmmjpeg.c
new file mode 100644
index 0000000..4fcee61
--- /dev/null
+++ b/drivers/amlogic/amports/vmmjpeg.c
@@ -0,0 +1,712 @@
+/*
+ * drivers/amlogic/amports/vmjpeg.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/kfifo.h>
+#include <linux/platform_device.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/amstream.h>
+#include <linux/amlogic/canvas/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+
+#include "vdec_reg.h"
+#include "arch/register.h"
+#include "amports_priv.h"
+
+#include <linux/amlogic/codec_mm/codec_mm.h>
+
+#include "vdec_input.h"
+#include "vdec.h"
+#include "amvdec.h"
+
+#define MEM_NAME "codec_mmjpeg"
+
+#include "amvdec.h"
+
+#define DRIVER_NAME "ammvdec_mjpeg"
+#define MODULE_NAME "ammvdec_mjpeg"
+
+/* protocol register usage
+    AV_SCRATCH_4 : decode buffer spec
+    AV_SCRATCH_5 : decode buffer index
+*/
+
+#define MREG_DECODE_PARAM   AV_SCRATCH_2	/* bit 0-3: pico_addr_mode */
+/* bit 15-4: reference height */
+#define MREG_TO_AMRISC      AV_SCRATCH_8
+#define MREG_FROM_AMRISC    AV_SCRATCH_9
+#define MREG_FRAME_OFFSET   AV_SCRATCH_A
+
+#define PICINFO_BUF_IDX_MASK        0x0007
+#define PICINFO_AVI1                0x0080
+#define PICINFO_INTERLACE           0x0020
+#define PICINFO_INTERLACE_AVI1_BOT  0x0010
+#define PICINFO_INTERLACE_FIRST     0x0010
+
+#define VF_POOL_SIZE          16
+#define DECODE_BUFFER_NUM_MAX 4
+
+static struct vframe_s *vmjpeg_vf_peek(void *);
+static struct vframe_s *vmjpeg_vf_get(void *);
+static void vmjpeg_vf_put(struct vframe_s *, void *);
+static int vmjpeg_vf_states(struct vframe_states *states, void *);
+static int vmjpeg_event_cb(int type, void *data, void *private_data);
+static void vmjpeg_work(struct work_struct *work);
+
+static const char vmjpeg_dec_id[] = "vmmjpeg-dev";
+
+#define PROVIDER_NAME   "vdec.mjpeg"
+static const struct vframe_operations_s vf_provider_ops = {
+	.peek = vmjpeg_vf_peek,
+	.get = vmjpeg_vf_get,
+	.put = vmjpeg_vf_put,
+	.event_cb = vmjpeg_event_cb,
+	.vf_states = vmjpeg_vf_states,
+};
+
+#define DEC_RESULT_NONE             0
+#define DEC_RESULT_DONE             1
+#define DEC_RESULT_AGAIN            2
+
+struct buffer_spec_s {
+	unsigned int y_addr;
+	unsigned int u_addr;
+	unsigned int v_addr;
+
+	int y_canvas_index;
+	int u_canvas_index;
+	int v_canvas_index;
+
+	struct canvas_config_s canvas_config[3];
+	unsigned long cma_alloc_addr;
+	int cma_alloc_count;
+	unsigned int buf_adr;
+};
+
+#define spec2canvas(x)  \
+	(((x)->v_canvas_index << 16) | \
+	 ((x)->u_canvas_index << 8)  | \
+	 ((x)->y_canvas_index << 0))
+
+struct vdec_mjpeg_hw_s {
+	spinlock_t lock;
+	struct mutex vmjpeg_mutex;
+
+	struct platform_device *platform_dev;
+	DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
+	DECLARE_KFIFO(display_q, struct vframe_s *, VF_POOL_SIZE);
+
+	struct vframe_s vfpool[VF_POOL_SIZE];
+	struct buffer_spec_s buffer_spec[DECODE_BUFFER_NUM_MAX];
+	s32 vfbuf_use[DECODE_BUFFER_NUM_MAX];
+
+	u32 frame_width;
+	u32 frame_height;
+	u32 frame_dur;
+	u32 saved_resolution;
+
+	u32 stat;
+	u32 dec_result;
+	unsigned long buf_start;
+	u32 buf_size;
+
+	struct dec_sysinfo vmjpeg_amstream_dec_info;
+
+	struct vframe_chunk_s *chunk;
+	struct work_struct work;
+	void (*vdec_cb)(struct vdec_s *, void *);
+	void *vdec_cb_arg;
+};
+
+static void set_frame_info(struct vdec_mjpeg_hw_s *hw, struct vframe_s *vf)
+{
+	vf->width = hw->frame_width;
+	vf->height = hw->frame_height;
+	vf->duration = hw->frame_dur;
+	vf->ratio_control = 0;
+	vf->duration_pulldown = 0;
+	vf->flag = 0;
+
+	vf->canvas0Addr = vf->canvas1Addr = -1;
+	vf->plane_num = 3;
+
+	vf->canvas0_config[0] = hw->buffer_spec[vf->index].canvas_config[0];
+	vf->canvas0_config[1] = hw->buffer_spec[vf->index].canvas_config[1];
+	vf->canvas0_config[2] = hw->buffer_spec[vf->index].canvas_config[2];
+
+	vf->canvas1_config[0] = hw->buffer_spec[vf->index].canvas_config[0];
+	vf->canvas1_config[1] = hw->buffer_spec[vf->index].canvas_config[1];
+	vf->canvas1_config[2] = hw->buffer_spec[vf->index].canvas_config[2];
+}
+
+static irqreturn_t vmjpeg_isr(struct vdec_s *vdec)
+{
+	struct vdec_mjpeg_hw_s *hw = (struct vdec_mjpeg_hw_s *)(vdec->private);
+	u32 reg;
+	struct vframe_s *vf = NULL;
+	u32 index;
+
+	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
+
+	if (!hw)
+		return IRQ_HANDLED;
+
+	reg = READ_VREG(MREG_FROM_AMRISC);
+	index = READ_VREG(AV_SCRATCH_5);
+
+	if (index >= DECODE_BUFFER_NUM_MAX) {
+		pr_err("fatal error, invalid buffer index.");
+		return IRQ_HANDLED;
+	}
+
+	if (kfifo_get(&hw->newframe_q, &vf) == 0) {
+		pr_info(
+		"fatal error, no available buffer slot.");
+		return IRQ_HANDLED;
+	}
+
+	vf->index = index;
+	set_frame_info(hw, vf);
+
+	vf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
+	/* vf->pts = (pts_valid) ? pts : 0; */
+	/* vf->pts_us64 = (pts_valid) ? pts_us64 : 0; */
+	vf->pts = hw->chunk->pts;
+	vf->pts_us64 = hw->chunk->pts64;
+	vf->orientation = 0;
+	hw->vfbuf_use[index]++;
+
+	kfifo_put(&hw->display_q, (const struct vframe_s *)vf);
+
+	vf_notify_receiver(vdec->vf_provider_name,
+			VFRAME_EVENT_PROVIDER_VFRAME_READY,
+			NULL);
+
+	hw->dec_result = DEC_RESULT_DONE;
+
+	schedule_work(&hw->work);
+
+	return IRQ_HANDLED;
+}
+
+static struct vframe_s *vmjpeg_vf_peek(void *op_arg)
+{
+	struct vframe_s *vf;
+	struct vdec_s *vdec = op_arg;
+	struct vdec_mjpeg_hw_s *hw = (struct vdec_mjpeg_hw_s *)vdec->private;
+
+	if (!hw)
+		return NULL;
+
+	if (kfifo_peek(&hw->display_q, &vf))
+		return vf;
+
+	return NULL;
+}
+
+static struct vframe_s *vmjpeg_vf_get(void *op_arg)
+{
+	struct vframe_s *vf;
+	struct vdec_s *vdec = op_arg;
+	struct vdec_mjpeg_hw_s *hw = (struct vdec_mjpeg_hw_s *)vdec->private;
+
+	if (!hw)
+		return NULL;
+
+	if (kfifo_get(&hw->display_q, &vf))
+		return vf;
+
+	return NULL;
+}
+
+static void vmjpeg_vf_put(struct vframe_s *vf, void *op_arg)
+{
+	struct vdec_s *vdec = op_arg;
+	struct vdec_mjpeg_hw_s *hw = (struct vdec_mjpeg_hw_s *)vdec->private;
+
+	hw->vfbuf_use[vf->index]--;
+	kfifo_put(&hw->newframe_q, (const struct vframe_s *)vf);
+}
+
+static int vmjpeg_event_cb(int type, void *data, void *private_data)
+{
+	return 0;
+}
+
+static int vmjpeg_vf_states(struct vframe_states *states, void *op_arg)
+{
+	unsigned long flags;
+	struct vdec_s *vdec = op_arg;
+	struct vdec_mjpeg_hw_s *hw = (struct vdec_mjpeg_hw_s *)vdec->private;
+
+	spin_lock_irqsave(&hw->lock, flags);
+
+	states->vf_pool_size = VF_POOL_SIZE;
+	states->buf_free_num = kfifo_len(&hw->newframe_q);
+	states->buf_avail_num = kfifo_len(&hw->display_q);
+	states->buf_recycle_num = 0;
+
+	spin_unlock_irqrestore(&hw->lock, flags);
+
+	return 0;
+}
+
+static int vmjpeg_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+{
+	struct vdec_mjpeg_hw_s *hw = (struct vdec_mjpeg_hw_s *)vdec->private;
+	vstatus->width = hw->frame_width;
+	vstatus->height = hw->frame_height;
+	if (0 != hw->frame_dur)
+		vstatus->fps = 96000 / hw->frame_dur;
+	else
+		vstatus->fps = 96000;
+	vstatus->error_count = 0;
+	vstatus->status = hw->stat;
+
+	return 0;
+}
+
+/****************************************/
+static void vmjpeg_canvas_init(struct vdec_s *vdec)
+{
+	int i;
+	u32 canvas_width, canvas_height;
+	u32 decbuf_size, decbuf_y_size, decbuf_uv_size;
+	struct vdec_mjpeg_hw_s *hw =
+		(struct vdec_mjpeg_hw_s *)vdec->private;
+	ulong addr;
+
+	canvas_width = 1920;
+	canvas_height = 1088;
+	decbuf_y_size = 0x200000;
+	decbuf_uv_size = 0x80000;
+	decbuf_size = 0x300000;
+
+	for (i = 0; i < DECODE_BUFFER_NUM_MAX; i++) {
+		int canvas;
+
+		canvas = vdec->get_canvas(i, 3);
+		if (hw->buffer_spec[i].cma_alloc_count == 0) {
+			hw->buffer_spec[i].cma_alloc_count =
+				PAGE_ALIGN(decbuf_size) / PAGE_SIZE;
+			hw->buffer_spec[i].cma_alloc_addr =
+				codec_mm_alloc_for_dma(MEM_NAME,
+					hw->buffer_spec[i].cma_alloc_count,
+					16, CODEC_MM_FLAGS_FOR_VDECODER);
+		}
+
+		if (!hw->buffer_spec[i].cma_alloc_addr) {
+			pr_err("CMA alloc failed, request buf size 0x%lx\n",
+				hw->buffer_spec[i].cma_alloc_count * PAGE_SIZE);
+			hw->buffer_spec[i].cma_alloc_count = 0;
+			break;
+		}
+
+		hw->buffer_spec[i].buf_adr =
+			hw->buffer_spec[i].cma_alloc_addr;
+		addr = hw->buffer_spec[i].buf_adr;
+
+		hw->buffer_spec[i].y_addr = addr;
+		addr += decbuf_y_size;
+		hw->buffer_spec[i].u_addr = addr;
+		addr += decbuf_uv_size;
+		hw->buffer_spec[i].v_addr = addr;
+
+		hw->buffer_spec[i].y_canvas_index = canvas_y(canvas);
+		hw->buffer_spec[i].u_canvas_index = canvas_u(canvas);
+		hw->buffer_spec[i].v_canvas_index = canvas_v(canvas);
+
+		canvas_config(hw->buffer_spec[i].y_canvas_index,
+			hw->buffer_spec[i].y_addr,
+			canvas_width,
+			canvas_height,
+			CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_LINEAR);
+		hw->buffer_spec[i].canvas_config[0].phy_addr =
+			hw->buffer_spec[i].y_addr;
+		hw->buffer_spec[i].canvas_config[0].width =
+			canvas_width;
+		hw->buffer_spec[i].canvas_config[0].height =
+			canvas_height;
+		hw->buffer_spec[i].canvas_config[0].block_mode =
+			CANVAS_BLKMODE_LINEAR;
+
+		canvas_config(hw->buffer_spec[i].u_canvas_index,
+			hw->buffer_spec[i].u_addr,
+			canvas_width / 2,
+			canvas_height / 2,
+			CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_LINEAR);
+		hw->buffer_spec[i].canvas_config[1].phy_addr =
+			hw->buffer_spec[i].u_addr;
+		hw->buffer_spec[i].canvas_config[1].width =
+			canvas_width / 2;
+		hw->buffer_spec[i].canvas_config[1].height =
+			canvas_height / 2;
+		hw->buffer_spec[i].canvas_config[1].block_mode =
+			CANVAS_BLKMODE_LINEAR;
+
+		canvas_config(hw->buffer_spec[i].v_canvas_index,
+			hw->buffer_spec[i].v_addr,
+			canvas_width / 2,
+			canvas_height / 2,
+			CANVAS_ADDR_NOWRAP,
+			CANVAS_BLKMODE_LINEAR);
+		hw->buffer_spec[i].canvas_config[2].phy_addr =
+			hw->buffer_spec[i].v_addr;
+		hw->buffer_spec[i].canvas_config[2].width =
+			canvas_width / 2;
+		hw->buffer_spec[i].canvas_config[2].height =
+			canvas_height / 2;
+		hw->buffer_spec[i].canvas_config[2].block_mode =
+			CANVAS_BLKMODE_LINEAR;
+	}
+}
+
+static void init_scaler(void)
+{
+	/* 4 point triangle */
+	const unsigned filt_coef[] = {
+		0x20402000, 0x20402000, 0x1f3f2101, 0x1f3f2101,
+		0x1e3e2202, 0x1e3e2202, 0x1d3d2303, 0x1d3d2303,
+		0x1c3c2404, 0x1c3c2404, 0x1b3b2505, 0x1b3b2505,
+		0x1a3a2606, 0x1a3a2606, 0x19392707, 0x19392707,
+		0x18382808, 0x18382808, 0x17372909, 0x17372909,
+		0x16362a0a, 0x16362a0a, 0x15352b0b, 0x15352b0b,
+		0x14342c0c, 0x14342c0c, 0x13332d0d, 0x13332d0d,
+		0x12322e0e, 0x12322e0e, 0x11312f0f, 0x11312f0f,
+		0x10303010
+	};
+	int i;
+
+	/* pscale enable, PSCALE cbus bmem enable */
+	WRITE_VREG(PSCALE_CTRL, 0xc000);
+
+	/* write filter coefs */
+	WRITE_VREG(PSCALE_BMEM_ADDR, 0);
+	for (i = 0; i < 33; i++) {
+		WRITE_VREG(PSCALE_BMEM_DAT, 0);
+		WRITE_VREG(PSCALE_BMEM_DAT, filt_coef[i]);
+	}
+
+	/* Y horizontal initial info */
+	WRITE_VREG(PSCALE_BMEM_ADDR, 37 * 2);
+	/* [35]: buf repeat pix0,
+	 * [34:29] => buf receive num,
+	 * [28:16] => buf blk x,
+	 * [15:0] => buf phase
+	 */
+	WRITE_VREG(PSCALE_BMEM_DAT, 0x0008);
+	WRITE_VREG(PSCALE_BMEM_DAT, 0x60000000);
+
+	/* C horizontal initial info */
+	WRITE_VREG(PSCALE_BMEM_ADDR, 41 * 2);
+	WRITE_VREG(PSCALE_BMEM_DAT, 0x0008);
+	WRITE_VREG(PSCALE_BMEM_DAT, 0x60000000);
+
+	/* Y vertical initial info */
+	WRITE_VREG(PSCALE_BMEM_ADDR, 39 * 2);
+	WRITE_VREG(PSCALE_BMEM_DAT, 0x0008);
+	WRITE_VREG(PSCALE_BMEM_DAT, 0x60000000);
+
+	/* C vertical initial info */
+	WRITE_VREG(PSCALE_BMEM_ADDR, 43 * 2);
+	WRITE_VREG(PSCALE_BMEM_DAT, 0x0008);
+	WRITE_VREG(PSCALE_BMEM_DAT, 0x60000000);
+
+	/* Y horizontal phase step */
+	WRITE_VREG(PSCALE_BMEM_ADDR, 36 * 2 + 1);
+	/* [19:0] => Y horizontal phase step */
+	WRITE_VREG(PSCALE_BMEM_DAT, 0x10000);
+	/* C horizontal phase step */
+	WRITE_VREG(PSCALE_BMEM_ADDR, 40 * 2 + 1);
+	/* [19:0] => C horizontal phase step */
+	WRITE_VREG(PSCALE_BMEM_DAT, 0x10000);
+
+	/* Y vertical phase step */
+	WRITE_VREG(PSCALE_BMEM_ADDR, 38 * 2 + 1);
+	/* [19:0] => Y vertical phase step */
+	WRITE_VREG(PSCALE_BMEM_DAT, 0x10000);
+	/* C vertical phase step */
+	WRITE_VREG(PSCALE_BMEM_ADDR, 42 * 2 + 1);
+	/* [19:0] => C horizontal phase step */
+	WRITE_VREG(PSCALE_BMEM_DAT, 0x10000);
+
+	/* reset pscaler */
+#if 1/*MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6*/
+	WRITE_VREG(DOS_SW_RESET0, (1 << 10));
+	WRITE_VREG(DOS_SW_RESET0, 0);
+#else
+	WRITE_MPEG_REG(RESET2_REGISTER, RESET_PSCALE);
+#endif
+	READ_MPEG_REG(RESET2_REGISTER);
+	READ_MPEG_REG(RESET2_REGISTER);
+	READ_MPEG_REG(RESET2_REGISTER);
+
+	WRITE_VREG(PSCALE_RST, 0x7);
+	WRITE_VREG(PSCALE_RST, 0x0);
+}
+
+static void vmjpeg_hw_ctx_restore(struct vdec_s *vdec, int index)
+{
+	struct vdec_mjpeg_hw_s *hw =
+		(struct vdec_mjpeg_hw_s *)vdec->private;
+
+	WRITE_VREG(DOS_SW_RESET0, (1 << 7) | (1 << 6));
+	WRITE_VREG(DOS_SW_RESET0, 0);
+
+	vmjpeg_canvas_init(vdec);
+
+	/* find next decode buffer index */
+	WRITE_VREG(AV_SCRATCH_4, spec2canvas(&hw->buffer_spec[index]));
+	WRITE_VREG(AV_SCRATCH_5, index);
+
+	init_scaler();
+
+	/* clear buffer IN/OUT registers */
+	WRITE_VREG(MREG_TO_AMRISC, 0);
+	WRITE_VREG(MREG_FROM_AMRISC, 0);
+
+	WRITE_VREG(MCPU_INTR_MSK, 0xffff);
+	WRITE_VREG(MREG_DECODE_PARAM, (hw->frame_height << 4) | 0x8000);
+
+	/* clear mailbox interrupt */
+	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
+	/* enable mailbox interrupt */
+	WRITE_VREG(ASSIST_MBOX1_MASK, 1);
+	/* set interrupt mapping for vld */
+	WRITE_VREG(ASSIST_AMR1_INT8, 8);
+#if 1/*MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6*/
+	CLEAR_VREG_MASK(MDEC_PIC_DC_CTRL, 1 << 17);
+#endif
+}
+
+static s32 vmjpeg_init(struct vdec_s *vdec)
+{
+	int i;
+	struct vdec_mjpeg_hw_s *hw =
+		(struct vdec_mjpeg_hw_s *)vdec->private;
+
+	hw->frame_width = hw->vmjpeg_amstream_dec_info.width;
+	hw->frame_height = hw->vmjpeg_amstream_dec_info.height;
+	hw->frame_dur = hw->vmjpeg_amstream_dec_info.rate;
+	hw->saved_resolution = 0;
+
+	for (i = 0; i < DECODE_BUFFER_NUM_MAX; i++)
+		hw->vfbuf_use[i] = 0;
+
+	INIT_KFIFO(hw->display_q);
+	INIT_KFIFO(hw->newframe_q);
+
+	for (i = 0; i < VF_POOL_SIZE; i++) {
+		const struct vframe_s *vf = &hw->vfpool[i];
+		hw->vfpool[i].index = -1;
+		kfifo_put(&hw->newframe_q, vf);
+	}
+
+	INIT_WORK(&hw->work, vmjpeg_work);
+
+	return 0;
+}
+
+static bool run_ready(struct vdec_s *vdec)
+{
+	return true;
+}
+
+static void run(struct vdec_s *vdec,
+	void (*callback)(struct vdec_s *, void *), void *arg)
+{
+	struct vdec_mjpeg_hw_s *hw =
+		(struct vdec_mjpeg_hw_s *)vdec->private;
+	int i, r;
+
+	hw->vdec_cb_arg = arg;
+	hw->vdec_cb = callback;
+
+	for (i = 0; i < DECODE_BUFFER_NUM_MAX; i++) {
+		if (hw->vfbuf_use[i] == 0)
+			break;
+	}
+
+	if (i == DECODE_BUFFER_NUM_MAX) {
+		hw->dec_result = DEC_RESULT_AGAIN;
+		schedule_work(&hw->work);
+		return;
+	}
+
+	r = vdec_prepare_input(vdec, &hw->chunk);
+	if (r < 0) {
+		hw->dec_result = DEC_RESULT_AGAIN;
+		schedule_work(&hw->work);
+		return;
+	}
+
+	hw->dec_result = DEC_RESULT_NONE;
+
+	if (amvdec_vdec_loadmc_ex(vdec, "vmmjpeg_mc") < 0) {
+		pr_err("%s: Error amvdec_loadmc fail\n", __func__);
+		return;
+	}
+
+	vmjpeg_hw_ctx_restore(vdec, i);
+
+	vdec_enable_input(vdec);
+
+	amvdec_start();
+}
+
+static void vmjpeg_work(struct work_struct *work)
+{
+	struct vdec_mjpeg_hw_s *hw = container_of(work,
+		struct vdec_mjpeg_hw_s, work);
+
+	if (hw->dec_result == DEC_RESULT_DONE)
+		vdec_vframe_dirty(hw_to_vdec(hw), hw->chunk);
+
+	/* mark itself has all HW resource released and input released */
+	vdec_set_status(hw_to_vdec(hw), VDEC_STATUS_CONNECTED);
+
+	if (hw->vdec_cb)
+		hw->vdec_cb(hw_to_vdec(hw), hw->vdec_cb_arg);
+}
+
+static int amvdec_mjpeg_probe(struct platform_device *pdev)
+{
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
+	struct vdec_mjpeg_hw_s *hw = NULL;
+
+	if (pdata == NULL) {
+		pr_info("amvdec_mjpeg memory resource undefined.\n");
+		return -EFAULT;
+	}
+
+	hw = (struct vdec_mjpeg_hw_s *)devm_kzalloc(&pdev->dev,
+		sizeof(struct vdec_mjpeg_hw_s), GFP_KERNEL);
+	if (hw == NULL) {
+		pr_info("\nammvdec_mjpeg device data allocation failed\n");
+		return -ENOMEM;
+	}
+
+	pdata->private = hw;
+	pdata->dec_status = vmjpeg_dec_status;
+
+	pdata->run = run;
+	pdata->run_ready = run_ready;
+	pdata->irq_handler = vmjpeg_isr;
+
+	pdata->id = pdev->id;
+
+	if (pdata->use_vfm_path)
+		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
+			VFM_DEC_PROVIDER_NAME);
+	else
+		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
+			PROVIDER_NAME ".%02x", pdev->id & 0xff);
+
+	vf_provider_init(&pdata->vframe_provider, pdata->vf_provider_name,
+		&vf_provider_ops, pdata);
+
+	platform_set_drvdata(pdev, pdata);
+
+	hw->platform_dev = pdev;
+	hw->buf_start = pdata->mem_start;
+	hw->buf_size = pdata->mem_end - pdata->mem_start + 1;
+
+	if (pdata->sys_info)
+		hw->vmjpeg_amstream_dec_info = *pdata->sys_info;
+
+	if (vmjpeg_init(pdata) < 0) {
+		pr_info("amvdec_mjpeg init failed.\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int amvdec_mjpeg_remove(struct platform_device *pdev)
+{
+	struct vdec_mjpeg_hw_s *hw =
+		(struct vdec_mjpeg_hw_s *)
+		(((struct vdec_s *)(platform_get_drvdata(pdev)))->private);
+	int i;
+
+	for (i = 0; i < DECODE_BUFFER_NUM_MAX; i++) {
+		if (hw->buffer_spec[i].cma_alloc_addr) {
+			pr_info("codec_mm release buffer_spec[%d], 0x%lx\n", i,
+				hw->buffer_spec[i].cma_alloc_addr);
+			codec_mm_free_for_dma(MEM_NAME,
+				hw->buffer_spec[i].cma_alloc_addr);
+			hw->buffer_spec[i].cma_alloc_count = 0;
+		}
+	}
+
+	cancel_work_sync(&hw->work);
+
+	vdec_set_status(hw_to_vdec(hw), VDEC_STATUS_DISCONNECTED);
+
+	return 0;
+}
+
+/****************************************/
+
+static struct platform_driver amvdec_mjpeg_driver = {
+	.probe = amvdec_mjpeg_probe,
+	.remove = amvdec_mjpeg_remove,
+#ifdef CONFIG_PM
+	.suspend = amvdec_suspend,
+	.resume = amvdec_resume,
+#endif
+	.driver = {
+		.name = DRIVER_NAME,
+	}
+};
+
+static struct codec_profile_t amvdec_mjpeg_profile = {
+	.name = "mmjpeg",
+	.profile = ""
+};
+
+static int __init amvdec_mjpeg_driver_init_module(void)
+{
+	if (platform_driver_register(&amvdec_mjpeg_driver)) {
+		pr_err("failed to register amvdec_mjpeg driver\n");
+		return -ENODEV;
+	}
+	vcodec_profile_register(&amvdec_mjpeg_profile);
+	return 0;
+}
+
+static void __exit amvdec_mjpeg_driver_remove_module(void)
+{
+	platform_driver_unregister(&amvdec_mjpeg_driver);
+}
+
+/****************************************/
+
+module_init(amvdec_mjpeg_driver_init_module);
+module_exit(amvdec_mjpeg_driver_remove_module);
+
+MODULE_DESCRIPTION("AMLOGIC MJMPEG Video Decoder Driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Tim Yao <timyao@amlogic.com>");
diff --git a/drivers/amlogic/amports/vmmpeg4.c b/drivers/amlogic/amports/vmmpeg4.c
new file mode 100644
index 0000000..f8d8027
--- /dev/null
+++ b/drivers/amlogic/amports/vmmpeg4.c
@@ -0,0 +1,1303 @@
+/*
+ * drivers/amlogic/amports/vmpeg4.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/kfifo.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/amlogic/amports/amstream.h>
+#include <linux/amlogic/amports/ptsserv.h>
+
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/amlogic/canvas/canvas.h>
+#include <linux/amlogic/codec_mm/codec_mm.h>
+
+#include "vdec_reg.h"
+#include "vmpeg4.h"
+#include "arch/register.h"
+#include "amports_priv.h"
+
+#include "amvdec.h"
+
+#define DRIVER_NAME "ammvdec_mpeg4"
+#define MODULE_NAME "ammvdec_mpeg4"
+
+#define MEM_NAME "codec_mpeg4"
+
+#define DEBUG_PTS
+
+#define NV21
+#define I_PICTURE   0
+#define P_PICTURE   1
+#define B_PICTURE   2
+
+#define ORI_BUFFER_START_ADDR   0x01000000
+#define DEFAULT_MEM_SIZE	(32*SZ_1M)
+
+#define INTERLACE_FLAG          0x80
+#define TOP_FIELD_FIRST_FLAG    0x40
+
+/* protocol registers */
+#define MREG_REF0           AV_SCRATCH_1
+#define MREG_REF1           AV_SCRATCH_2
+#define MP4_PIC_RATIO       AV_SCRATCH_5
+#define MP4_RATE            AV_SCRATCH_3
+#define MP4_ERR_COUNT       AV_SCRATCH_6
+#define MP4_PIC_WH          AV_SCRATCH_7
+#define MREG_INPUT          AV_SCRATCH_8
+#define MREG_BUFFEROUT      AV_SCRATCH_9
+#define MP4_NOT_CODED_CNT   AV_SCRATCH_A
+#define MP4_VOP_TIME_INC    AV_SCRATCH_B
+#define MP4_OFFSET_REG      AV_SCRATCH_C
+#define MP4_SYS_RATE        AV_SCRATCH_E
+#define MEM_OFFSET_REG      AV_SCRATCH_F
+
+#define PARC_FORBIDDEN              0
+#define PARC_SQUARE                 1
+#define PARC_CIF                    2
+#define PARC_10_11                  3
+#define PARC_16_11                  4
+#define PARC_40_33                  5
+#define PARC_RESERVED               6
+/* values between 6 and 14 are reserved */
+#define PARC_EXTENDED              15
+
+#define VF_POOL_SIZE          16
+#define DECODE_BUFFER_NUM_MAX 4
+#define PUT_INTERVAL        (HZ/100)
+
+#define CTX_LMEM_SWAP_OFFSET    0
+#define CTX_QUANT_MATRIX_OFFSET 0x800
+/* dcac buffer must align at 4k boundary */
+#define CTX_DCAC_BUF_OFFSET     0x1000
+#define CTX_DECBUF_OFFSET       (0x0c0000 + 0x1000)
+
+#define RATE_DETECT_COUNT   5
+#define DURATION_UNIT       96000
+#define PTS_UNIT            90000
+
+#define DUR2PTS(x) ((x) - ((x) >> 4))
+
+#define DEC_RESULT_NONE     0
+#define DEC_RESULT_DONE     1
+#define DEC_RESULT_AGAIN    2
+#define DEC_RESULT_ERROR    3
+
+static struct vframe_s *vmpeg_vf_peek(void *);
+static struct vframe_s *vmpeg_vf_get(void *);
+static void vmpeg_vf_put(struct vframe_s *, void *);
+static int vmpeg_vf_states(struct vframe_states *states, void *);
+static int vmpeg_event_cb(int type, void *data, void *private_data);
+
+struct vdec_mpeg4_hw_s {
+	spinlock_t lock;
+	struct platform_device *platform_dev;
+	struct device *cma_dev;
+
+	DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
+	DECLARE_KFIFO(display_q, struct vframe_s *, VF_POOL_SIZE);
+	struct vframe_s vfpool[VF_POOL_SIZE];
+
+	s32 vfbuf_use[DECODE_BUFFER_NUM_MAX];
+	u32 frame_width;
+	u32 frame_height;
+	u32 frame_dur;
+	u32 frame_prog;
+
+	u32 ctx_valid;
+	u32 reg_vcop_ctrl_reg;
+	u32 reg_pic_head_info;
+	u32 reg_mpeg1_2_reg;
+	u32 reg_slice_qp;
+	u32 reg_mp4_pic_wh;
+	u32 reg_mp4_rate;
+	u32 reg_mb_info;
+	u32 reg_dc_ac_ctrl;
+	u32 reg_iqidct_control;
+	u32 reg_resync_marker_length;
+	u32 reg_rv_ai_mb_count;
+
+	struct vframe_chunk_s *chunk;
+	u32 stat;
+	u32 buf_start;
+	u32 buf_size;
+	unsigned long cma_alloc_addr;
+	int cma_alloc_count;
+	u32 vmpeg4_ratio;
+	u64 vmpeg4_ratio64;
+	u32 rate_detect;
+	u32 vmpeg4_rotation;
+	u32 total_frame;
+	u32 last_vop_time_inc;
+	u32 last_duration;
+	u32 last_anch_pts;
+	u32 vop_time_inc_since_last_anch;
+	u32 frame_num_since_last_anch;
+	u64 last_anch_pts_us64;
+
+	u32 pts_hit;
+	u32 pts_missed;
+	u32 pts_i_hit;
+	u32 pts_i_missed;
+
+	u32 buffer_info[DECODE_BUFFER_NUM_MAX];
+	u32 pts[DECODE_BUFFER_NUM_MAX];
+	u64 pts64[DECODE_BUFFER_NUM_MAX];
+	bool pts_valid[DECODE_BUFFER_NUM_MAX];
+	u32 canvas_spec[DECODE_BUFFER_NUM_MAX];
+#ifdef NV21
+	struct canvas_config_s canvas_config[DECODE_BUFFER_NUM_MAX][2];
+#else
+	struct canvas_config_s canvas_config[DECODE_BUFFER_NUM_MAX][3];
+#endif
+	struct dec_sysinfo vmpeg4_amstream_dec_info;
+
+	s32 refs[2];
+	int dec_result;
+	struct work_struct work;
+
+	void (*vdec_cb)(struct vdec_s *, void *);
+	void *vdec_cb_arg;
+
+};
+static void vmpeg4_local_init(struct vdec_mpeg4_hw_s *hw);
+static int vmpeg4_hw_ctx_restore(struct vdec_mpeg4_hw_s *hw);
+
+#define PROVIDER_NAME   "vdec.mpeg4"
+
+/*
+int query_video_status(int type, int *value);
+*/
+static const struct vframe_operations_s vf_provider_ops = {
+	.peek = vmpeg_vf_peek,
+	.get = vmpeg_vf_get,
+	.put = vmpeg_vf_put,
+	.event_cb = vmpeg_event_cb,
+	.vf_states = vmpeg_vf_states,
+};
+
+static unsigned char aspect_ratio_table[16] = {
+	PARC_FORBIDDEN,
+	PARC_SQUARE,
+	PARC_CIF,
+	PARC_10_11,
+	PARC_16_11,
+	PARC_40_33,
+	PARC_RESERVED, PARC_RESERVED, PARC_RESERVED, PARC_RESERVED,
+	PARC_RESERVED, PARC_RESERVED, PARC_RESERVED, PARC_RESERVED,
+	PARC_RESERVED, PARC_EXTENDED
+};
+
+static int find_buffer(struct vdec_mpeg4_hw_s *hw)
+{
+	int i;
+
+	for (i = 0; i < DECODE_BUFFER_NUM_MAX; i++) {
+		if (hw->vfbuf_use[i] == 0)
+			return i;
+	}
+
+	return -1;
+}
+
+static int spec_to_index(struct vdec_mpeg4_hw_s *hw, u32 spec)
+{
+	int i;
+
+	for (i = 0; i < DECODE_BUFFER_NUM_MAX; i++) {
+		if (hw->canvas_spec[i] == spec)
+			return i;
+	}
+
+	return -1;
+}
+
+static void set_frame_info(struct vdec_mpeg4_hw_s *hw, struct vframe_s *vf,
+			int buffer_index)
+{
+	int ar = 0;
+	unsigned int num = 0;
+	unsigned int den = 0;
+	unsigned pixel_ratio = READ_VREG(MP4_PIC_RATIO);
+
+	if (hw->vmpeg4_ratio64 != 0) {
+		num = hw->vmpeg4_ratio64>>32;
+		den = hw->vmpeg4_ratio64 & 0xffffffff;
+	} else {
+		num = hw->vmpeg4_ratio>>16;
+		den = hw->vmpeg4_ratio & 0xffff;
+
+	}
+	if ((num == 0) || (den == 0)) {
+		num = 1;
+		den = 1;
+	}
+
+	if (hw->vmpeg4_ratio == 0) {
+		vf->ratio_control |= (0x90 << DISP_RATIO_ASPECT_RATIO_BIT);
+		/* always stretch to 16:9 */
+	} else if (pixel_ratio > 0x0f) {
+		num = (pixel_ratio >> 8) *
+			hw->vmpeg4_amstream_dec_info.width * num;
+		ar = div_u64((pixel_ratio & 0xff) *
+			hw->vmpeg4_amstream_dec_info.height * den * 0x100ULL +
+			(num >> 1), num);
+	} else {
+		switch (aspect_ratio_table[pixel_ratio]) {
+		case 0:
+			num = hw->vmpeg4_amstream_dec_info.width * num;
+			ar = (hw->vmpeg4_amstream_dec_info.height * den *
+				0x100 + (num >> 1)) / num;
+			break;
+		case 1:
+			num = vf->width * num;
+			ar = (vf->height * den * 0x100 + (num >> 1)) / num;
+			break;
+		case 2:
+			num = (vf->width * 12) * num;
+			ar = (vf->height * den * 0x100 * 11 +
+				  ((num) >> 1)) / num;
+			break;
+		case 3:
+			num = (vf->width * 10) * num;
+			ar = (vf->height * den * 0x100 * 11 + (num >> 1)) /
+				num;
+			break;
+		case 4:
+			num = (vf->width * 16) * num;
+			ar = (vf->height * den * 0x100 * 11 + (num >> 1)) /
+				num;
+			break;
+		case 5:
+			num = (vf->width * 40) * num;
+			ar = (vf->height * den * 0x100 * 33 + (num >> 1)) /
+				num;
+			break;
+		default:
+			num = vf->width * num;
+			ar = (vf->height * den * 0x100 + (num >> 1)) / num;
+			break;
+		}
+	}
+
+	ar = min(ar, DISP_RATIO_ASPECT_RATIO_MAX);
+
+	vf->signal_type = 0;
+	vf->type_original = vf->type;
+	vf->ratio_control = (ar << DISP_RATIO_ASPECT_RATIO_BIT);
+	vf->canvas0Addr = vf->canvas1Addr = -1;
+#ifdef NV21
+	vf->plane_num = 2;
+#else
+	vf->plane_num = 3;
+#endif
+	vf->canvas0_config[0] = hw->canvas_config[buffer_index][0];
+	vf->canvas0_config[1] = hw->canvas_config[buffer_index][1];
+#ifndef NV21
+	vf->canvas0_config[2] = hw->canvas_config[buffer_index][2];
+#endif
+	vf->canvas1_config[0] = hw->canvas_config[buffer_index][0];
+	vf->canvas1_config[1] = hw->canvas_config[buffer_index][1];
+#ifndef NV21
+	vf->canvas1_config[2] = hw->canvas_config[buffer_index][2];
+#endif
+}
+
+static inline void vmpeg4_save_hw_context(struct vdec_mpeg4_hw_s *hw)
+{
+	hw->reg_mpeg1_2_reg = READ_VREG(MPEG1_2_REG);
+	hw->reg_vcop_ctrl_reg = READ_VREG(VCOP_CTRL_REG);
+	hw->reg_pic_head_info = READ_VREG(PIC_HEAD_INFO);
+	hw->reg_slice_qp = READ_VREG(SLICE_QP);
+	hw->reg_mp4_pic_wh = READ_VREG(MP4_PIC_WH);
+	hw->reg_mp4_rate = READ_VREG(MP4_RATE);
+	hw->reg_mb_info = READ_VREG(MB_INFO);
+	hw->reg_dc_ac_ctrl = READ_VREG(DC_AC_CTRL);
+	hw->reg_iqidct_control = READ_VREG(IQIDCT_CONTROL);
+	hw->reg_resync_marker_length = READ_VREG(RESYNC_MARKER_LENGTH);
+	hw->reg_rv_ai_mb_count = READ_VREG(RV_AI_MB_COUNT);
+}
+
+static irqreturn_t vmpeg4_isr(struct vdec_s *vdec)
+{
+	u32 reg;
+	struct vframe_s *vf = NULL;
+	u32 picture_type;
+	int index;
+	u32 pts, offset = 0;
+	bool pts_valid = false;
+	u64 pts_us64 = 0;
+	u32 time_increment_resolution, fixed_vop_rate, vop_time_inc;
+	u32 repeat_cnt, duration = 3200;
+	struct vdec_mpeg4_hw_s *hw = (struct vdec_mpeg4_hw_s *)(vdec->private);
+
+	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
+
+	reg = READ_VREG(MREG_BUFFEROUT);
+
+	time_increment_resolution = READ_VREG(MP4_RATE);
+	fixed_vop_rate = time_increment_resolution >> 16;
+	time_increment_resolution &= 0xffff;
+
+	if (hw->vmpeg4_amstream_dec_info.rate == 0) {
+		if ((fixed_vop_rate != 0) && (time_increment_resolution != 0)) {
+			/* fixed VOP rate */
+			hw->vmpeg4_amstream_dec_info.rate = fixed_vop_rate *
+					DURATION_UNIT /
+					time_increment_resolution;
+		}
+	}
+
+	if (reg == 2) {
+		/* timeout when decoding next frame */
+
+		/* for frame based case, insufficient result may happen
+		 * at the begining when only VOL head is available save
+		 * HW context also, such as for the QTable from VCOP register
+		 */
+		if (input_frame_based(vdec))
+			vmpeg4_save_hw_context(hw);
+
+		hw->dec_result = DEC_RESULT_AGAIN;
+
+		schedule_work(&hw->work);
+
+		return IRQ_HANDLED;
+	} else {
+		picture_type = (reg >> 3) & 7;
+		repeat_cnt = READ_VREG(MP4_NOT_CODED_CNT);
+		vop_time_inc = READ_VREG(MP4_VOP_TIME_INC);
+
+		index = spec_to_index(hw, READ_VREG(REC_CANVAS_ADDR));
+
+		if (index < 0) {
+			pr_err("invalid buffer index.");
+			hw->dec_result = DEC_RESULT_ERROR;
+
+			schedule_work(&hw->work);
+
+			return IRQ_HANDLED;
+		}
+
+		hw->dec_result = DEC_RESULT_DONE;
+
+		pr_debug("amvdec_mpeg4: offset = 0x%x\n",
+			READ_VREG(MP4_OFFSET_REG));
+
+		if (hw->vmpeg4_amstream_dec_info.width == 0) {
+			hw->vmpeg4_amstream_dec_info.width =
+				READ_VREG(MP4_PIC_WH) >> 16;
+		}
+#if 0
+		else {
+			pr_info("info width = %d, ucode width = %d\n",
+				   hw->vmpeg4_amstream_dec_info.width,
+				   READ_VREG(MP4_PIC_WH) >> 16);
+		}
+#endif
+
+		if (hw->vmpeg4_amstream_dec_info.height == 0) {
+			hw->vmpeg4_amstream_dec_info.height =
+				READ_VREG(MP4_PIC_WH) & 0xffff;
+		}
+#if 0
+		else {
+			pr_info("info height = %d, ucode height = %d\n",
+				   hw->vmpeg4_amstream_dec_info.height,
+				   READ_VREG(MP4_PIC_WH) & 0xffff);
+		}
+#endif
+		if (hw->vmpeg4_amstream_dec_info.rate == 0) {
+			if (vop_time_inc < hw->last_vop_time_inc) {
+				duration = vop_time_inc +
+					time_increment_resolution -
+					hw->last_vop_time_inc;
+			} else {
+				duration = vop_time_inc -
+					hw->last_vop_time_inc;
+			}
+
+			if (duration == hw->last_duration) {
+				hw->rate_detect++;
+				if (hw->rate_detect >= RATE_DETECT_COUNT) {
+					hw->vmpeg4_amstream_dec_info.rate =
+					duration * DURATION_UNIT /
+					time_increment_resolution;
+					duration =
+					hw->vmpeg4_amstream_dec_info.rate;
+				}
+			} else {
+				hw->rate_detect = 0;
+				hw->last_duration = duration;
+			}
+		} else {
+			duration = hw->vmpeg4_amstream_dec_info.rate;
+#if 0
+			pr_info("info rate = %d, ucode rate = 0x%x:0x%x\n",
+				   hw->vmpeg4_amstream_dec_info.rate,
+				   READ_VREG(MP4_RATE), vop_time_inc);
+#endif
+		}
+
+		if ((I_PICTURE == picture_type) ||
+			(P_PICTURE == picture_type)) {
+			offset = READ_VREG(MP4_OFFSET_REG);
+			if (hw->chunk) {
+				hw->pts_valid[index] = hw->chunk->pts_valid;
+				hw->pts[index] = hw->chunk->pts;
+				hw->pts64[index] = hw->chunk->pts64;
+			} else {
+				if (pts_lookup_offset_us64
+					(PTS_TYPE_VIDEO, offset, &pts, 3000,
+					&pts_us64) == 0) {
+					hw->pts_valid[index] = true;
+					hw->pts[index] = pts;
+					hw->pts64[index] = pts_us64;
+					hw->pts_hit++;
+				} else {
+					hw->pts_valid[index] = false;
+					hw->pts_missed++;
+				}
+			}
+			pr_debug("I/P offset 0x%x, pts_valid %d pts=0x%x\n",
+					offset, hw->pts_valid[index],
+					hw->pts[index]);
+		} else {
+			hw->pts_valid[index] = false;
+			hw->pts[index] = 0;
+			hw->pts64[index] = 0;
+		}
+
+		hw->buffer_info[index] = reg;
+		hw->vfbuf_use[index] = 0;
+
+		pr_debug("amvdec_mpeg4: decoded buffer %d, frame_type %s\n",
+			index,
+			(picture_type == I_PICTURE) ? "I" :
+			(picture_type == P_PICTURE) ? "P" : "B");
+
+		/* Buffer management
+		 * todo: add sequence-end flush
+		 */
+		if ((picture_type == I_PICTURE) ||
+			(picture_type == P_PICTURE)) {
+			hw->vfbuf_use[index]++;
+
+			if (hw->refs[1] == -1) {
+				hw->refs[1] = index;
+				index = -1;
+			} else if (hw->refs[0] == -1) {
+				hw->refs[0] = hw->refs[1];
+				hw->refs[1] = index;
+				index = hw->refs[0];
+			} else {
+				hw->vfbuf_use[hw->refs[0]]--;
+				hw->refs[0] = hw->refs[1];
+				hw->refs[1] = index;
+				index = hw->refs[0];
+			}
+		} else {
+			/* if this is a B frame, then drop (depending on if
+			 * there are two reference frames) or display
+			 * immediately
+			 */
+			if (hw->refs[1] == -1)
+				index = -1;
+		}
+
+		vmpeg4_save_hw_context(hw);
+
+		if (index < 0) {
+			schedule_work(&hw->work);
+			return IRQ_HANDLED;
+		}
+
+		reg = hw->buffer_info[index];
+		pts_valid = hw->pts_valid[index];
+		pts = hw->pts[index];
+		pts_us64 = hw->pts64[index];
+
+		pr_debug("queued buffer %d, pts = 0x%x, pts_valid=%d\n",
+				index, pts, pts_valid);
+
+		if (pts_valid) {
+			hw->last_anch_pts = pts;
+			hw->last_anch_pts_us64 = pts_us64;
+			hw->frame_num_since_last_anch = 0;
+			hw->vop_time_inc_since_last_anch = 0;
+		} else {
+			pts = hw->last_anch_pts;
+			pts_us64 = hw->last_anch_pts_us64;
+
+			if ((time_increment_resolution != 0) &&
+				(fixed_vop_rate == 0) &&
+				(hw->vmpeg4_amstream_dec_info.rate == 0)) {
+				/* variable PTS rate */
+				/*bug on variable pts calc,
+				do as dixed vop first if we
+				have rate setting before.
+				*/
+				if (vop_time_inc > hw->last_vop_time_inc) {
+					duration = vop_time_inc -
+						hw->last_vop_time_inc;
+				} else {
+					duration = vop_time_inc +
+						time_increment_resolution -
+						hw->last_vop_time_inc;
+				}
+
+				hw->vop_time_inc_since_last_anch += duration;
+
+				pts += hw->vop_time_inc_since_last_anch *
+					PTS_UNIT / time_increment_resolution;
+				pts_us64 += (hw->vop_time_inc_since_last_anch *
+					PTS_UNIT / time_increment_resolution) *
+					100 / 9;
+
+				if (hw->vop_time_inc_since_last_anch >
+					(1 << 14)) {
+					/* avoid overflow */
+					hw->last_anch_pts = pts;
+					hw->last_anch_pts_us64 = pts_us64;
+					hw->vop_time_inc_since_last_anch = 0;
+				}
+			} else {
+				/* fixed VOP rate */
+				hw->frame_num_since_last_anch++;
+				pts += DUR2PTS(hw->frame_num_since_last_anch *
+					hw->vmpeg4_amstream_dec_info.rate);
+				pts_us64 += DUR2PTS(
+					hw->frame_num_since_last_anch *
+					hw->vmpeg4_amstream_dec_info.rate) *
+					100 / 9;
+
+				if (hw->frame_num_since_last_anch > (1 << 15)) {
+					/* avoid overflow */
+					hw->last_anch_pts = pts;
+					hw->last_anch_pts_us64 = pts_us64;
+					hw->frame_num_since_last_anch = 0;
+				}
+			}
+		}
+
+		if (reg & INTERLACE_FLAG) {	/* interlace */
+			if (kfifo_get(&hw->newframe_q, &vf) == 0) {
+				pr_err
+				("fatal error, no available buffer slot.");
+				return IRQ_HANDLED;
+			}
+
+			vf->index = index;
+			vf->width = hw->vmpeg4_amstream_dec_info.width;
+			vf->height = hw->vmpeg4_amstream_dec_info.height;
+			vf->bufWidth = 1920;
+			vf->flag = 0;
+			vf->orientation = hw->vmpeg4_rotation;
+			vf->pts = pts;
+			vf->pts_us64 = pts_us64;
+			vf->duration = duration >> 1;
+			vf->duration_pulldown = 0;
+			vf->type = (reg & TOP_FIELD_FIRST_FLAG) ?
+				VIDTYPE_INTERLACE_TOP :
+				VIDTYPE_INTERLACE_BOTTOM;
+#ifdef NV21
+			vf->type |= VIDTYPE_VIU_NV21;
+#endif
+			set_frame_info(hw, vf, index);
+
+			hw->vfbuf_use[index]++;
+
+			kfifo_put(&hw->display_q, (const struct vframe_s *)vf);
+
+			vf_notify_receiver(vdec->vf_provider_name,
+					VFRAME_EVENT_PROVIDER_VFRAME_READY,
+					NULL);
+
+			if (kfifo_get(&hw->newframe_q, &vf) == 0) {
+				pr_err("fatal error, no available buffer slot.");
+				hw->dec_result = DEC_RESULT_ERROR;
+				schedule_work(&hw->work);
+				return IRQ_HANDLED;
+			}
+
+			vf->index = index;
+			vf->width = hw->vmpeg4_amstream_dec_info.width;
+			vf->height = hw->vmpeg4_amstream_dec_info.height;
+			vf->bufWidth = 1920;
+			vf->flag = 0;
+			vf->orientation = hw->vmpeg4_rotation;
+
+			vf->pts = 0;
+			vf->pts_us64 = 0;
+			vf->duration = duration >> 1;
+
+			vf->duration_pulldown = 0;
+			vf->type = (reg & TOP_FIELD_FIRST_FLAG) ?
+			VIDTYPE_INTERLACE_BOTTOM : VIDTYPE_INTERLACE_TOP;
+#ifdef NV21
+			vf->type |= VIDTYPE_VIU_NV21;
+#endif
+			set_frame_info(hw, vf, index);
+
+			hw->vfbuf_use[index]++;
+
+			kfifo_put(&hw->display_q, (const struct vframe_s *)vf);
+
+			vf_notify_receiver(vdec->vf_provider_name,
+				VFRAME_EVENT_PROVIDER_VFRAME_READY,
+				NULL);
+
+		} else {	/* progressive */
+			if (kfifo_get(&hw->newframe_q, &vf) == 0) {
+				pr_err("fatal error, no available buffer slot.");
+				return IRQ_HANDLED;
+			}
+
+			vf->index = index;
+			vf->width = hw->vmpeg4_amstream_dec_info.width;
+			vf->height = hw->vmpeg4_amstream_dec_info.height;
+			vf->bufWidth = 1920;
+			vf->flag = 0;
+			vf->orientation = hw->vmpeg4_rotation;
+			vf->pts = pts;
+			vf->pts_us64 = pts_us64;
+			vf->duration = duration;
+			vf->duration_pulldown = repeat_cnt * duration;
+#ifdef NV21
+			vf->type =
+				VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD |
+				VIDTYPE_VIU_NV21;
+#else
+			vf->type =
+				VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
+#endif
+			set_frame_info(hw, vf, index);
+
+
+			hw->vfbuf_use[index]++;
+
+			kfifo_put(&hw->display_q, (const struct vframe_s *)vf);
+
+			vf_notify_receiver(vdec->vf_provider_name,
+				VFRAME_EVENT_PROVIDER_VFRAME_READY,
+				NULL);
+		}
+
+		hw->total_frame += repeat_cnt + 1;
+		hw->last_vop_time_inc = vop_time_inc;
+
+		schedule_work(&hw->work);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void vmpeg4_work(struct work_struct *work)
+{
+	struct vdec_mpeg4_hw_s *hw =
+		container_of(work, struct vdec_mpeg4_hw_s, work);
+
+	/* finished decoding one frame or error,
+	 * notify vdec core to switch context
+	 */
+	amvdec_stop();
+
+	if ((hw->dec_result == DEC_RESULT_DONE) ||
+		((hw->chunk) &&
+		(input_frame_based(&(hw_to_vdec(hw))->input)))) {
+		if (!hw->ctx_valid)
+			hw->ctx_valid = 1;
+
+		vdec_vframe_dirty(hw_to_vdec(hw), hw->chunk);
+	}
+
+	/* mark itself has all HW resource released and input released */
+	vdec_set_status(hw_to_vdec(hw), VDEC_STATUS_CONNECTED);
+
+	if (hw->vdec_cb)
+		hw->vdec_cb(hw_to_vdec(hw), hw->vdec_cb_arg);
+}
+
+static struct vframe_s *vmpeg_vf_peek(void *op_arg)
+{
+	struct vframe_s *vf;
+	struct vdec_s *vdec = op_arg;
+	struct vdec_mpeg4_hw_s *hw = (struct vdec_mpeg4_hw_s *)vdec->private;
+
+	if (!hw)
+		return NULL;
+
+	if (kfifo_peek(&hw->display_q, &vf))
+		return vf;
+
+	return NULL;
+}
+
+static struct vframe_s *vmpeg_vf_get(void *op_arg)
+{
+	struct vframe_s *vf;
+	struct vdec_s *vdec = op_arg;
+	struct vdec_mpeg4_hw_s *hw = (struct vdec_mpeg4_hw_s *)vdec->private;
+
+	if (kfifo_get(&hw->display_q, &vf))
+		return vf;
+
+	return NULL;
+}
+
+static void vmpeg_vf_put(struct vframe_s *vf, void *op_arg)
+{
+	struct vdec_s *vdec = op_arg;
+	struct vdec_mpeg4_hw_s *hw = (struct vdec_mpeg4_hw_s *)vdec->private;
+
+	hw->vfbuf_use[vf->index]--;
+
+	kfifo_put(&hw->newframe_q, (const struct vframe_s *)vf);
+}
+
+static int vmpeg_event_cb(int type, void *data, void *private_data)
+{
+	return 0;
+}
+
+static int  vmpeg_vf_states(struct vframe_states *states, void *op_arg)
+{
+	unsigned long flags;
+	struct vdec_s *vdec = op_arg;
+	struct vdec_mpeg4_hw_s *hw = (struct vdec_mpeg4_hw_s *)vdec->private;
+
+	spin_lock_irqsave(&hw->lock, flags);
+
+	states->vf_pool_size = VF_POOL_SIZE;
+	states->buf_free_num = kfifo_len(&hw->newframe_q);
+	states->buf_avail_num = kfifo_len(&hw->display_q);
+	states->buf_recycle_num = 0;
+
+	spin_unlock_irqrestore(&hw->lock, flags);
+
+	return 0;
+}
+
+
+static int dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
+{
+	struct vdec_mpeg4_hw_s *hw = (struct vdec_mpeg4_hw_s *)vdec->private;
+
+	vstatus->width = hw->vmpeg4_amstream_dec_info.width;
+	vstatus->height = hw->vmpeg4_amstream_dec_info.height;
+	if (0 != hw->vmpeg4_amstream_dec_info.rate)
+		vstatus->fps = DURATION_UNIT /
+				hw->vmpeg4_amstream_dec_info.rate;
+	else
+		vstatus->fps = DURATION_UNIT;
+	vstatus->error_count = READ_VREG(MP4_ERR_COUNT);
+	vstatus->status = hw->stat;
+
+	return 0;
+}
+
+/****************************************/
+static int vmpeg4_canvas_init(struct vdec_mpeg4_hw_s *hw)
+{
+	int i;
+	u32 decbuf_size, decbuf_y_size;
+	struct vdec_s *vdec = hw_to_vdec(hw);
+	u32 decbuf_start;
+
+	int w = hw->vmpeg4_amstream_dec_info.width;
+	int h = hw->vmpeg4_amstream_dec_info.height;
+
+	if (w == 0)
+		w = 1920;
+	if (h == 0)
+		h = 1088;
+
+	w = ALIGN(w, 64);
+	h = ALIGN(h, 64);
+	decbuf_y_size = ALIGN(w * h, SZ_64K);
+	decbuf_size = ALIGN(w * h * 3/2, SZ_64K);
+
+	decbuf_start = hw->buf_start + CTX_DECBUF_OFFSET;
+
+	for (i = 0; i < DECODE_BUFFER_NUM_MAX; i++) {
+#ifdef NV21
+		unsigned int canvas = vdec->get_canvas(i, 2);
+#else
+		unsigned int canvas = vdec->get_canvas(i, 3);
+#endif
+
+		hw->canvas_spec[i] = canvas;
+
+#ifdef NV21
+		hw->canvas_config[i][0].phy_addr = decbuf_start +
+					i * decbuf_size;
+		hw->canvas_config[i][0].width = w;
+		hw->canvas_config[i][0].height = h;
+		hw->canvas_config[i][0].block_mode = CANVAS_BLKMODE_32X32;
+
+		canvas_config_config(canvas_y(canvas),
+					&hw->canvas_config[i][0]);
+
+		hw->canvas_config[i][1].phy_addr = decbuf_start +
+					i * decbuf_size + decbuf_y_size;
+		hw->canvas_config[i][1].width = w;
+		hw->canvas_config[i][1].height = h / 2;
+		hw->canvas_config[i][1].block_mode = CANVAS_BLKMODE_32X32;
+
+		canvas_config_config(canvas_u(canvas),
+					&hw->canvas_config[i][1]);
+#else
+		hw->canvas_config[i][0].phy_addr = decbuf_start +
+					i * decbuf_size;
+		hw->canvas_config[i][0].width = w;
+		hw->canvas_config[i][0].height = h;
+		hw->canvas_config[i][0].block_mode = CANVAS_BLKMODE_32X32;
+
+		canvas_config_config(canvas_y(canvas),
+					&hw->canvas_config[i][0]);
+
+		hw->canvas_config[i][1].phy_addr = decbuf_start +
+					i * decbuf_size + decbuf_y_size;
+		hw->canvas_config[i][1].width = w / 2;
+		hw->canvas_config[i][1].height = h / 2;
+		hw->canvas_config[i][1].block_mode = CANVAS_BLKMODE_32X32;
+
+		canvas_config_config(canvas_u(canvas),
+					&hw->canvas_config[i][1]);
+
+		hw->canvas_config[i][2].phy_addr = decbuf_start +
+					i * decbuf_size + decbuf_y_size +
+					decbuf_uv_size;
+		hw->canvas_config[i][2].width = w / 2;
+		hw->canvas_config[i][2].height = h / 2;
+		hw->canvas_config[i][2].block_mode = CANVAS_BLKMODE_32X32;
+
+		canvas_config_config(canvas_v(canvas),
+					&hw->canvas_config[i][2]);
+#endif
+	}
+
+	return 0;
+}
+
+static int vmpeg4_hw_ctx_restore(struct vdec_mpeg4_hw_s *hw)
+{
+	int index;
+
+
+	index = find_buffer(hw);
+	if (index < 0)
+		return -1;
+
+
+	if (vmpeg4_canvas_init(hw) < 0)
+		return -1;
+
+	/* prepare REF0 & REF1
+	 * points to the past two IP buffers
+	 * prepare REC_CANVAS_ADDR and ANC2_CANVAS_ADDR
+	 * points to the output buffer
+	 */
+	if (hw->refs[0] == -1) {
+		WRITE_VREG(MREG_REF0, (hw->refs[1] == -1) ? 0xffffffff :
+					hw->canvas_spec[hw->refs[1]]);
+	} else {
+		WRITE_VREG(MREG_REF0, (hw->refs[0] == -1) ? 0xffffffff :
+					hw->canvas_spec[hw->refs[0]]);
+	}
+	WRITE_VREG(MREG_REF1, (hw->refs[1] == -1) ? 0xffffffff :
+				hw->canvas_spec[hw->refs[1]]);
+
+	WRITE_VREG(MREG_REF0, (hw->refs[0] == -1) ? 0xffffffff :
+				hw->canvas_spec[hw->refs[0]]);
+	WRITE_VREG(MREG_REF1, (hw->refs[1] == -1) ? 0xffffffff :
+				hw->canvas_spec[hw->refs[1]]);
+	WRITE_VREG(REC_CANVAS_ADDR, hw->canvas_spec[index]);
+	WRITE_VREG(ANC2_CANVAS_ADDR, hw->canvas_spec[index]);
+
+	pr_debug("vmpeg4_hw_ctx_restore ref0=0x%x, ref1=0x%x, rec=0x%x, ctx_valid=%d\n",
+	   READ_VREG(MREG_REF0),
+	   READ_VREG(MREG_REF1),
+	   READ_VREG(REC_CANVAS_ADDR),
+	   hw->ctx_valid);
+
+	/* notify ucode the buffer start address */
+	WRITE_VREG(MEM_OFFSET_REG, hw->buf_start);
+
+	/* disable PSCALE for hardware sharing */
+	WRITE_VREG(PSCALE_CTRL, 0);
+
+	WRITE_VREG(MREG_BUFFEROUT, 0);
+
+	/* clear mailbox interrupt */
+	WRITE_VREG(ASSIST_MBOX1_CLR_REG, 1);
+
+	/* enable mailbox interrupt */
+	WRITE_VREG(ASSIST_MBOX1_MASK, 1);
+
+	/* clear repeat count */
+	WRITE_VREG(MP4_NOT_CODED_CNT, 0);
+
+#ifdef NV21
+	SET_VREG_MASK(MDEC_PIC_DC_CTRL, 1 << 17);
+#endif
+
+#if 1/* /MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8 */
+	WRITE_VREG(MDEC_PIC_DC_THRESH, 0x404038aa);
+#endif
+
+	WRITE_VREG(MP4_PIC_WH, (hw->ctx_valid) ?
+		hw->reg_mp4_pic_wh :
+			((hw->vmpeg4_amstream_dec_info.width << 16) |
+				hw->vmpeg4_amstream_dec_info.height));
+	WRITE_VREG(MP4_SYS_RATE, hw->vmpeg4_amstream_dec_info.rate);
+
+	if (hw->ctx_valid) {
+		WRITE_VREG(DC_AC_CTRL, hw->reg_dc_ac_ctrl);
+		WRITE_VREG(IQIDCT_CONTROL, hw->reg_iqidct_control);
+		WRITE_VREG(RESYNC_MARKER_LENGTH, hw->reg_resync_marker_length);
+		WRITE_VREG(RV_AI_MB_COUNT, hw->reg_rv_ai_mb_count);
+	}
+	WRITE_VREG(MPEG1_2_REG, (hw->ctx_valid) ? hw->reg_mpeg1_2_reg : 1);
+	WRITE_VREG(VCOP_CTRL_REG, hw->reg_vcop_ctrl_reg);
+	WRITE_VREG(PIC_HEAD_INFO, hw->reg_pic_head_info);
+	WRITE_VREG(SLICE_QP, hw->reg_slice_qp);
+	WRITE_VREG(MB_INFO, hw->reg_mb_info);
+
+	if (hw->chunk) {
+		/* frame based input */
+		WRITE_VREG(MREG_INPUT, (hw->chunk->offset & 7) | (1<<7) |
+							(hw->ctx_valid<<6));
+	} else {
+		/* stream based input */
+		WRITE_VREG(MREG_INPUT, (hw->ctx_valid<<6));
+	}
+
+	return 0;
+}
+
+static void vmpeg4_local_init(struct vdec_mpeg4_hw_s *hw)
+{
+	int i;
+
+	hw->vmpeg4_ratio = hw->vmpeg4_amstream_dec_info.ratio;
+
+	hw->vmpeg4_ratio64 = hw->vmpeg4_amstream_dec_info.ratio64;
+
+	hw->vmpeg4_rotation =
+		(((unsigned long) hw->vmpeg4_amstream_dec_info.param)
+			>> 16) & 0xffff;
+
+	hw->frame_width = hw->frame_height = hw->frame_dur = hw->frame_prog = 0;
+
+	hw->total_frame = 0;
+
+	hw->last_anch_pts = 0;
+
+	hw->last_anch_pts_us64 = 0;
+
+	hw->last_vop_time_inc = hw->last_duration = 0;
+
+	hw->vop_time_inc_since_last_anch = 0;
+
+	hw->frame_num_since_last_anch = 0;
+
+	hw->pts_hit = hw->pts_missed = hw->pts_i_hit = hw->pts_i_missed = 0;
+
+	for (i = 0; i < DECODE_BUFFER_NUM_MAX; i++)
+		hw->vfbuf_use[i] = 0;
+
+	INIT_KFIFO(hw->display_q);
+	INIT_KFIFO(hw->newframe_q);
+
+	for (i = 0; i < VF_POOL_SIZE; i++) {
+		const struct vframe_s *vf = &hw->vfpool[i];
+		hw->vfpool[i].index = DECODE_BUFFER_NUM_MAX;
+		kfifo_put(&hw->newframe_q, (const struct vframe_s *)vf);
+	}
+
+	INIT_WORK(&hw->work, vmpeg4_work);
+}
+
+static s32 vmpeg4_init(struct vdec_mpeg4_hw_s *hw)
+{
+	int trickmode_fffb = 0;
+
+	query_video_status(0, &trickmode_fffb);
+
+	pr_info("vmpeg4_init\n");
+
+	amvdec_enable();
+
+	vmpeg4_local_init(hw);
+
+	return 0;
+}
+
+static bool run_ready(struct vdec_s *vdec)
+{
+	int index;
+	struct vdec_mpeg4_hw_s *hw = (struct vdec_mpeg4_hw_s *)vdec->private;
+
+	index = find_buffer(hw);
+
+	return index >= 0;
+}
+
+static void run(struct vdec_s *vdec, void (*callback)(struct vdec_s *, void *),
+		void *arg)
+{
+	struct vdec_mpeg4_hw_s *hw = (struct vdec_mpeg4_hw_s *)vdec->private;
+	int save_reg = READ_VREG(POWER_CTL_VLD);
+	int r;
+
+	/* reset everything except DOS_TOP[1] and APB_CBUS[0] */
+	WRITE_VREG(DOS_SW_RESET0, 0xfffffff0);
+	WRITE_VREG(DOS_SW_RESET0, 0);
+	WRITE_VREG(POWER_CTL_VLD, save_reg);
+
+	hw->vdec_cb_arg = arg;
+	hw->vdec_cb = callback;
+
+	r = vdec_prepare_input(vdec, &hw->chunk);
+	if (r < 0) {
+		pr_debug("amvdec_mpeg4: Input not ready\n");
+		hw->dec_result = DEC_RESULT_AGAIN;
+		schedule_work(&hw->work);
+		return;
+	}
+
+	vdec_enable_input(vdec);
+
+	if (hw->chunk)
+		pr_debug("input chunk offset %d, size %d\n",
+			hw->chunk->offset, hw->chunk->size);
+
+	hw->dec_result = DEC_RESULT_NONE;
+
+	if (hw->vmpeg4_amstream_dec_info.format ==
+		VIDEO_DEC_FORMAT_MPEG4_3) {
+		pr_info("load VIDEO_DEC_FORMAT_MPEG4_3\n");
+		if (amvdec_vdec_loadmc_ex(vdec,
+					"vmmpeg4_mc_311") < 0) {
+			pr_err("VIDEO_DEC_FORMAT_MPEG4_3 ucode loading failed\n");
+			hw->dec_result = DEC_RESULT_ERROR;
+			schedule_work(&hw->work);
+			return;
+		}
+	} else if (hw->vmpeg4_amstream_dec_info.format ==
+			VIDEO_DEC_FORMAT_MPEG4_4) {
+		pr_info("load VIDEO_DEC_FORMAT_MPEG4_4\n");
+		if (amvdec_vdec_loadmc_ex(vdec,
+					"vmmpeg4_mc_4") < 0) {
+			hw->dec_result = DEC_RESULT_ERROR;
+			schedule_work(&hw->work);
+			pr_err("VIDEO_DEC_FORMAT_MPEG4_4 ucode loading failed\n");
+			return;
+		}
+	} else if (hw->vmpeg4_amstream_dec_info.format ==
+			VIDEO_DEC_FORMAT_MPEG4_5) {
+		/* pr_info("load VIDEO_DEC_FORMAT_MPEG4_5\n"); */
+		if (amvdec_vdec_loadmc_ex(vdec,
+					"vmmpeg4_mc_5") < 0) {
+			hw->dec_result = DEC_RESULT_ERROR;
+			schedule_work(&hw->work);
+			pr_err("VIDEO_DEC_FORMAT_MPEG4_5 ucode loading failed\n");
+			return;
+		}
+	} else if (hw->vmpeg4_amstream_dec_info.format ==
+			VIDEO_DEC_FORMAT_H263) {
+		pr_info("load VIDEO_DEC_FORMAT_H263\n");
+		if (amvdec_vdec_loadmc_ex(vdec,
+					"mh263_mc") < 0) {
+			hw->dec_result = DEC_RESULT_ERROR;
+			schedule_work(&hw->work);
+			pr_err("VIDEO_DEC_FORMAT_H263 ucode loading failed\n");
+			return;
+		}
+	}
+
+	if (vmpeg4_hw_ctx_restore(hw) < 0) {
+		hw->dec_result = DEC_RESULT_ERROR;
+		pr_err("amvdec_mpeg4: error HW context restore\n");
+		schedule_work(&hw->work);
+		return;
+	}
+
+	/* wmb before ISR is handled */
+	wmb();
+
+	amvdec_start();
+}
+
+static void reset(struct vdec_s *vdec)
+{
+	struct vdec_mpeg4_hw_s *hw = (struct vdec_mpeg4_hw_s *)vdec->private;
+
+	pr_info("amvdec_mpeg4: reset.\n");
+
+	vmpeg4_local_init(hw);
+
+	hw->ctx_valid = false;
+}
+
+static int amvdec_mpeg4_probe(struct platform_device *pdev)
+{
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
+	struct vdec_mpeg4_hw_s *hw = NULL;
+
+	pr_info("amvdec_mpeg4[%d] probe start.\n", pdev->id);
+
+	if (pdata == NULL) {
+		pr_err("ammvdec_mpeg4 memory resource undefined.\n");
+		return -EFAULT;
+	}
+
+	hw = (struct vdec_mpeg4_hw_s *)devm_kzalloc(&pdev->dev,
+		sizeof(struct vdec_mpeg4_hw_s), GFP_KERNEL);
+	if (hw == NULL) {
+		pr_info("\namvdec_mpeg4 decoder driver alloc failed\n");
+		return -ENOMEM;
+	}
+
+	pdata->private = hw;
+	pdata->dec_status = dec_status;
+	/* pdata->set_trickmode = set_trickmode; */
+	pdata->run_ready = run_ready;
+	pdata->run = run;
+	pdata->reset = reset;
+	pdata->irq_handler = vmpeg4_isr;
+
+	pdata->id = pdev->id;
+
+	if (pdata->use_vfm_path)
+		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
+			VFM_DEC_PROVIDER_NAME);
+	else
+		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
+			PROVIDER_NAME ".%02x", pdev->id & 0xff);
+
+	vf_provider_init(&pdata->vframe_provider, pdata->vf_provider_name,
+		&vf_provider_ops, pdata);
+
+	platform_set_drvdata(pdev, pdata);
+
+	hw->platform_dev = pdev;
+	hw->cma_dev = pdata->cma_dev;
+
+	hw->cma_alloc_count = PAGE_ALIGN(DEFAULT_MEM_SIZE) / PAGE_SIZE;
+	hw->cma_alloc_addr = codec_mm_alloc_for_dma(MEM_NAME,
+				hw->cma_alloc_count,
+				4, CODEC_MM_FLAGS_FOR_VDECODER);
+
+	if (!hw->cma_alloc_addr) {
+		pr_err("codec_mm alloc failed, request buf size 0x%lx\n",
+			hw->cma_alloc_count * PAGE_SIZE);
+		hw->cma_alloc_count = 0;
+		return -ENOMEM;
+	}
+	hw->buf_start = hw->cma_alloc_addr;
+	hw->buf_size = DEFAULT_MEM_SIZE;
+
+	if (pdata->sys_info)
+		hw->vmpeg4_amstream_dec_info = *pdata->sys_info;
+
+	if (vmpeg4_init(hw) < 0) {
+		pr_err("amvdec_mpeg4 init failed.\n");
+
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int amvdec_mpeg4_remove(struct platform_device *pdev)
+{
+	struct vdec_mpeg4_hw_s *hw =
+		(struct vdec_mpeg4_hw_s *)
+		(((struct vdec_s *)(platform_get_drvdata(pdev)))->private);
+
+
+	amvdec_disable();
+
+	if (hw->cma_alloc_addr) {
+		pr_info("codec_mm release buffer 0x%lx\n", hw->cma_alloc_addr);
+		codec_mm_free_for_dma(MEM_NAME, hw->cma_alloc_addr);
+		hw->cma_alloc_count = 0;
+	}
+
+	pr_info("pts hit %d, pts missed %d, i hit %d, missed %d\n", hw->pts_hit,
+		   hw->pts_missed, hw->pts_i_hit, hw->pts_i_missed);
+	pr_info("total frame %d, rate %d\n", hw->total_frame,
+		   hw->vmpeg4_amstream_dec_info.rate);
+
+	return 0;
+}
+
+/****************************************/
+
+static struct platform_driver amvdec_mpeg4_driver = {
+	.probe = amvdec_mpeg4_probe,
+	.remove = amvdec_mpeg4_remove,
+#ifdef CONFIG_PM
+	.suspend = amvdec_suspend,
+	.resume = amvdec_resume,
+#endif
+	.driver = {
+		.name = DRIVER_NAME,
+	}
+};
+
+static struct codec_profile_t amvdec_mpeg4_profile = {
+	.name = "mmpeg4",
+	.profile = ""
+};
+
+static int __init amvdec_mmpeg4_driver_init_module(void)
+{
+	pr_info("amvdec_mmpeg4 module init\n");
+
+	if (platform_driver_register(&amvdec_mpeg4_driver)) {
+		pr_err("failed to register amvdec_mpeg4 driver\n");
+		return -ENODEV;
+	}
+	vcodec_profile_register(&amvdec_mpeg4_profile);
+	return 0;
+}
+
+static void __exit amvdec_mmpeg4_driver_remove_module(void)
+{
+	pr_info("amvdec_mmpeg4 module remove.\n");
+
+	platform_driver_unregister(&amvdec_mpeg4_driver);
+}
+
+/****************************************/
+
+module_init(amvdec_mmpeg4_driver_init_module);
+module_exit(amvdec_mmpeg4_driver_remove_module);
+
+MODULE_DESCRIPTION("AMLOGIC MPEG4 Video Decoder Driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Tim Yao <timyao@amlogic.com>");
+
diff --git a/drivers/amlogic/amports/vmpeg12.c b/drivers/amlogic/amports/vmpeg12.c
index 8296e01..982d4e1 100644
--- a/drivers/amlogic/amports/vmpeg12.c
+++ b/drivers/amlogic/amports/vmpeg12.c
@@ -673,7 +673,7 @@ static void vmpeg_put_timer_func(unsigned long arg)
 	add_timer(timer);
 }
 
-int vmpeg12_dec_status(struct vdec_status *vstatus)
+int vmpeg12_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
 {
 	vstatus->width = frame_width;
 	vstatus->height = frame_height;
@@ -969,15 +969,12 @@ static s32 vmpeg12_init(void)
 
 	stat |= STAT_VDEC_RUN;
 
-	set_vdec_func(&vmpeg12_dec_status);
-
 	return 0;
 }
 
 static int amvdec_mpeg12_probe(struct platform_device *pdev)
 {
-	struct vdec_dev_reg_s *pdata =
-		(struct vdec_dev_reg_s *)pdev->dev.platform_data;
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
 
 	amlog_level(LOG_LEVEL_INFO, "amvdec_mpeg12 probe start.\n");
 
@@ -993,6 +990,8 @@ static int amvdec_mpeg12_probe(struct platform_device *pdev)
 	buf_start = pdata->mem_start;
 	buf_size = pdata->mem_end - pdata->mem_start + 1;
 
+	pdata->dec_status = vmpeg12_dec_status;
+
 	if (vmpeg12_init() < 0) {
 		amlog_level(LOG_LEVEL_ERROR, "amvdec_mpeg12 init failed.\n");
 
diff --git a/drivers/amlogic/amports/vmpeg4.c b/drivers/amlogic/amports/vmpeg4.c
index fe0b9ca..12a213d 100644
--- a/drivers/amlogic/amports/vmpeg4.c
+++ b/drivers/amlogic/amports/vmpeg4.c
@@ -672,7 +672,7 @@ static void vmpeg_put_timer_func(unsigned long arg)
 	add_timer(timer);
 }
 
-int vmpeg4_dec_status(struct vdec_status *vstatus)
+int vmpeg4_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
 {
 	vstatus->width = vmpeg4_amstream_dec_info.width;
 	vstatus->height = vmpeg4_amstream_dec_info.height;
@@ -1011,15 +1011,12 @@ static s32 vmpeg4_init(void)
 
 	stat |= STAT_VDEC_RUN;
 
-	set_vdec_func(&vmpeg4_dec_status);
-
 	return 0;
 }
 
 static int amvdec_mpeg4_probe(struct platform_device *pdev)
 {
-	struct vdec_dev_reg_s *pdata =
-		(struct vdec_dev_reg_s *)pdev->dev.platform_data;
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
 
 	if (pdata == NULL) {
 		amlog_level(LOG_LEVEL_ERROR,
@@ -1034,6 +1031,8 @@ static int amvdec_mpeg4_probe(struct platform_device *pdev)
 	if (pdata->sys_info)
 		vmpeg4_amstream_dec_info = *pdata->sys_info;
 
+	pdata->dec_status = vmpeg4_dec_status;
+
 	if (vmpeg4_init() < 0) {
 		amlog_level(LOG_LEVEL_ERROR, "amvdec_mpeg4 init failed.\n");
 
diff --git a/drivers/amlogic/amports/vpp.c b/drivers/amlogic/amports/vpp.c
index f6a4514..a2f1a80 100644
--- a/drivers/amlogic/amports/vpp.c
+++ b/drivers/amlogic/amports/vpp.c
@@ -220,7 +220,7 @@ static const u32 *filter_table[] = {
 };
 
 static int chroma_filter_table[] = {
-	COEF_4POINT_TRIANGLE, /* bicubic */
+	COEF_BICUBIC, /* bicubic */
 	COEF_3POINT_TRIANGLE,
 	COEF_4POINT_TRIANGLE,
 	COEF_4POINT_TRIANGLE, /* bilinear */
@@ -240,6 +240,10 @@ static unsigned int sharpness1_sr2_ctrl_3280 = 0xffffffff;
 MODULE_PARM_DESC(sharpness1_sr2_ctrl_3280, "sharpness1_sr2_ctrl_3280");
 module_param(sharpness1_sr2_ctrl_3280, uint, 0664);
 
+static unsigned int vpp_filter_fix;
+MODULE_PARM_DESC(vpp_filter_fix, "vpp_filter_fix");
+module_param(vpp_filter_fix, uint, 0664);
+
 #define MAX_COEFF_LEVEL 5
 uint num_coeff_level = MAX_COEFF_LEVEL;
 uint vert_coeff_settings[MAX_COEFF_LEVEL] = {
@@ -282,7 +286,8 @@ uint horz_coeff_settings[MAX_COEFF_LEVEL] = {
 	/* this setting is most smooth */
 };
 
-static uint coeff(uint *settings, uint ratio, uint phase, bool interlace)
+static uint coeff(uint *settings, uint ratio, uint phase,
+	bool interlace, int combing_lev)
 {
 	uint coeff_select = 0;
 	uint coeff_type = 0;
@@ -307,8 +312,11 @@ static uint coeff(uint *settings, uint ratio, uint phase, bool interlace)
 	} else {
 		/* gxtvbb use dejaggy in SR0 to reduce intelace combing
 		   other chip no dejaggy, need swtich to more blur filter */
-		if (interlace && (coeff_select < 3))
+		if (interlace && (coeff_select < 3) && vpp_filter_fix)
 			coeff_type = COEF_4POINT_BSPLINE;
+		/* use bicubic for static scene */
+		if (combing_lev == 0)
+			coeff_type = COEF_BICUBIC;
 	}
 	return coeff_type;
 }
@@ -329,6 +337,10 @@ module_param(vert_chroma_filter_force_en, bool, 0664);
 MODULE_PARM_DESC(vert_chroma_filter_force_en,
 	"force enable vertical chromafilter\n");
 
+uint vert_chroma_filter_limit = 480;
+module_param(vert_chroma_filter_limit, uint, 0664);
+MODULE_PARM_DESC(vert_chroma_filter_limit, "vertical chromafilter limit\n");
+
 uint num_chroma_filter = TOTAL_FILTERS;
 module_param_array(chroma_filter_table, uint, &num_chroma_filter, 0664);
 MODULE_PARM_DESC(chroma_filter_table, "\n chroma_filter_table\n");
@@ -357,6 +369,14 @@ static u32 skip_policy = 0x81;
 module_param(skip_policy, uint, 0664);
 MODULE_PARM_DESC(skip_policy, "\n skip_policy\n");
 
+unsigned int scaler_filter_cnt_limit = 10;
+MODULE_PARM_DESC(scaler_filter_cnt_limit, "scaler_filter_cnt_limit");
+module_param(scaler_filter_cnt_limit, uint, 0664);
+
+static uint last_vert_filter;
+static uint last_horz_filter;
+static uint scaler_filter_cnt;
+
 static u32 vpp_wide_mode;
 static u32 vpp_zoom_ratio = 100;
 static s32 vpp_zoom_center_x, vpp_zoom_center_y;
@@ -403,6 +423,10 @@ static unsigned int vert_scaler_filter = 0xff;
 module_param(vert_scaler_filter, uint, 0664);
 MODULE_PARM_DESC(vert_scaler_filter, "vert_scaler_filter");
 
+static unsigned int vert_chroma_scaler_filter = 0xff;
+module_param(vert_chroma_scaler_filter, uint, 0664);
+MODULE_PARM_DESC(vert_chroma_scaler_filter, "vert_chroma_scaler_filter");
+
 static unsigned int horz_scaler_filter = 0xff;
 module_param(horz_scaler_filter, uint, 0664);
 MODULE_PARM_DESC(horz_scaler_filter, "horz_scaler_filter");
@@ -586,8 +610,6 @@ vpp_process_speed_check(s32 width_in,
 			}
 			if (vf->type & VIDTYPE_VIU_422) {
 				/*TODO vpu */
-				if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB)
-					bypass_ratio = 125;
 				if (height_out == 0
 					|| div_u64((u64)VPP_SPEED_FACTOR *
 						(u64)width_in *
@@ -622,7 +644,9 @@ vpp_process_speed_check(s32 width_in,
 					 (vinfo->sync_duration_num >
 					  (30 * vinfo->sync_duration_den)) &&
 					 (get_cpu_type() !=
-						MESON_CPU_MAJOR_ID_GXTVBB))
+						MESON_CPU_MAJOR_ID_GXTVBB) &&
+					 (get_cpu_type() !=
+						MESON_CPU_MAJOR_ID_GXM))
 					return SPEED_CHECK_VSKIP;
 				else
 					return SPEED_CHECK_DONE;
@@ -1257,8 +1281,9 @@ vpp_set_filters2(u32 process_3d_type, u32 width_in,
 			next_frame_par->vscale_skip_count = skip_policy & 0xf;
 			goto RESTART;
 		} else if (skip_policy & 0x80) {
-			if ((vf->width >= 4096) &&
-			(!(vf->type & VIDTYPE_COMPRESS))
+			if ((((vf->width >= 4096) &&
+			(!(vf->type & VIDTYPE_COMPRESS))) ||
+			(vf->flag & VFRAME_FLAG_HIGH_BANDWITH))
 			&& (next_frame_par->vscale_skip_count == 0)) {
 				next_frame_par->vscale_skip_count =
 				skip_policy & 0xf;
@@ -1276,7 +1301,8 @@ vpp_set_filters2(u32 process_3d_type, u32 width_in,
 				(next_frame_par->vscale_skip_count + 1),
 			1,
 			((vf->type_original & VIDTYPE_TYPEMASK)
-				!= VIDTYPE_PROGRESSIVE));
+				!= VIDTYPE_PROGRESSIVE),
+			vf->combing_cur_lev);
 	filter->vpp_vert_coeff =
 		filter_table[filter->vpp_vert_filter];
 
@@ -1284,7 +1310,8 @@ vpp_set_filters2(u32 process_3d_type, u32 width_in,
 	/* TODO: add 420 check for local */
 	if (vert_chroma_filter_force_en || (vert_chroma_filter_en
 	&& (((vf->source_type == VFRAME_SOURCE_TYPE_OTHERS)
-	 && ((vf->type_original & VIDTYPE_TYPEMASK) != VIDTYPE_PROGRESSIVE))
+	 && (((vf->type_original & VIDTYPE_TYPEMASK) != VIDTYPE_PROGRESSIVE) ||
+	 (vf->height < vert_chroma_filter_limit)))
 	|| (vf->source_type == VFRAME_SOURCE_TYPE_CVBS)
 	|| (vf->source_type == VFRAME_SOURCE_TYPE_TUNER)))) {
 		cur_vert_chroma_filter
@@ -1296,13 +1323,14 @@ vpp_set_filters2(u32 process_3d_type, u32 width_in,
 		cur_vert_chroma_filter = COEF_NULL;
 		filter->vpp_vert_chroma_filter_en = false;
 	}
-
+	/* avoid hscaler fitler adjustion affect on picture shift*/
 	filter->vpp_horz_filter =
 		coeff(horz_coeff_settings,
 			filter->vpp_hf_start_phase_step,
 			next_frame_par->VPP_hf_ini_phase_,
 			((vf->type_original & VIDTYPE_TYPEMASK)
-				!= VIDTYPE_PROGRESSIVE));
+				!= VIDTYPE_PROGRESSIVE),
+			vf->combing_cur_lev);
 	/*for gxl cvbs out index*/
 	if ((vinfo->mode == VMODE_576CVBS) &&
 		(filter->vpp_hf_start_phase_step == (1 << 24)))
@@ -1355,16 +1383,17 @@ vpp_set_filters2(u32 process_3d_type, u32 width_in,
 		(vert_scaler_filter <= COEF_3D_FILTER)) {
 		filter->vpp_vert_coeff = filter_table[vert_scaler_filter];
 		filter->vpp_vert_filter = vert_scaler_filter;
-		if (vert_chroma_filter_force_en) {
-			cur_vert_chroma_filter
-				= chroma_filter_table[vert_scaler_filter];
+	}
+	if (vert_chroma_filter_force_en &&
+		(vert_chroma_scaler_filter >= COEF_BICUBIC) &&
+		(vert_chroma_scaler_filter <= COEF_3D_FILTER)) {
+		cur_vert_chroma_filter = vert_chroma_scaler_filter;
 			filter->vpp_vert_chroma_coeff
 				= filter_table[cur_vert_chroma_filter];
 			filter->vpp_vert_chroma_filter_en = true;
-		} else {
-			cur_vert_chroma_filter = COEF_NULL;
-			filter->vpp_vert_chroma_filter_en = false;
-		}
+	} else {
+		cur_vert_chroma_filter = COEF_NULL;
+		filter->vpp_vert_chroma_filter_en = false;
 	}
 
 	if ((horz_scaler_filter >= COEF_BICUBIC) &&
@@ -1380,9 +1409,22 @@ vpp_set_filters2(u32 process_3d_type, u32 width_in,
 		filter->vpp_vert_filter = COEF_3D_FILTER;
 	}
 #endif
-
-	cur_vert_filter = filter->vpp_vert_filter;
-	cur_horz_filter = filter->vpp_horz_filter;
+	if ((last_vert_filter != filter->vpp_vert_filter) ||
+		(last_horz_filter != filter->vpp_horz_filter)) {
+		last_vert_filter = filter->vpp_vert_filter;
+		last_horz_filter = filter->vpp_horz_filter;
+		scaler_filter_cnt = 0;
+	} else {
+		scaler_filter_cnt++;
+	}
+	if ((scaler_filter_cnt >= scaler_filter_cnt_limit) &&
+		((cur_vert_filter != filter->vpp_vert_filter) ||
+		(cur_horz_filter != filter->vpp_horz_filter))) {
+		video_property_notify(1);
+		cur_vert_filter = filter->vpp_vert_filter;
+		cur_horz_filter = filter->vpp_horz_filter;
+		scaler_filter_cnt = scaler_filter_cnt_limit;
+	}
 	cur_skip_line = next_frame_par->vscale_skip_count;
 
 #if HAS_VPU_PROT
@@ -1547,13 +1589,20 @@ int vpp_set_super_scaler_regs(int scaler_path_sel,
 		VSYNC_WR_MPEG_REG(SRSHARP1_SHARP_HVSIZE, tmp_data);
 		sharpness1_sr2_ctrl_3280 = tmp_data;
 	}
-
+	/*ve input size setting*/
+	tmp_data = ((reg_srscl1_hsize & 0x1fff) << 16) |
+		(reg_srscl1_vsize & 0x1fff);
+	tmp_data2 = READ_VCBUS_REG(VPP_VE_H_V_SIZE);
+	if (tmp_data != tmp_data2)
+		VSYNC_WR_MPEG_REG(VPP_VE_H_V_SIZE, tmp_data);
+	/*chroma blue stretch size setting*/
 	if (scaler_path_sel == sup0_pp_sp1_scpath) {
-		tmp_data = ((reg_srscl1_hsize & 0x1fff) << 16) |
-				   (reg_srscl1_vsize & 0x1fff);
-		tmp_data2 = READ_VCBUS_REG(VPP_VE_H_V_SIZE);
+		tmp_data = (((reg_srscl1_hsize & 0x1fff) <<
+			reg_srscl1_hori_ratio) << 16) |
+			((reg_srscl1_vsize & 0x1fff) << reg_srscl1_vert_ratio);
+		tmp_data2 = READ_VCBUS_REG(VPP_PSR_H_V_SIZE);
 		if (tmp_data != tmp_data2)
-			VSYNC_WR_MPEG_REG(VPP_VE_H_V_SIZE, tmp_data);
+			VSYNC_WR_MPEG_REG(VPP_PSR_H_V_SIZE, tmp_data);
 	} else if (scaler_path_sel == sup0_pp_post_blender) {
 		tmp_data = ((reg_srscl1_hsize & 0x1fff) << 16) |
 				   (reg_srscl1_vsize & 0x1fff);
@@ -1611,64 +1660,68 @@ static void vpp_set_scaler(u32 process_3d_type, u32 src_width,
 	ver_sc_multiple_num = height_out*SUPER_SCALER_V_FACTOR / src_height;
 
 	/* just calcuate the enable sclaer module */
-	if ((hor_sc_multiple_num >= 4) || (ver_sc_multiple_num >=
-				(4*SUPER_SCALER_V_FACTOR))) {
-		if (bypass_spscl0 == 0)
-			next_frame_par->supsc0_enable = 1;
-		if (bypass_spscl1 == 0)
-			next_frame_par->supsc1_enable = 1;
-	} else if ((hor_sc_multiple_num >= 2) || (ver_sc_multiple_num >=
-				(2*SUPER_SCALER_V_FACTOR))) {
-		if (((src_width > SUPER_CORE0_WIDTH_MAX/2)
-			&& (src_width <= SUPER_CORE0_WIDTH_MAX)
-			&& (bypass_spscl1 == 0))
-			|| (bypass_spscl0 == 1)) {
-			next_frame_par->supsc0_enable = 0;
-			next_frame_par->supsc1_enable = 1;
-		} else if ((src_width > SUPER_CORE0_WIDTH_MAX/2)
-			&& (src_width <= SUPER_CORE0_WIDTH_MAX)
-			&& (bypass_spscl1 == 1)) {
-			next_frame_par->supsc0_enable = 0;
-			next_frame_par->supsc1_enable = 0;
-		} else {
-			next_frame_par->supsc0_enable = 1;
-			next_frame_par->supsc1_enable = 0;
-		}
-	} else {
-		next_frame_par->supsc0_enable = 0;
-		next_frame_par->supsc1_enable = 0;
-	}
-	if (src_width > SUPER_CORE0_WIDTH_MAX)
-		next_frame_par->supsc0_enable = 0;
-	if (width_out > SUPER_CORE1_WIDTH_MAX*2)
-		next_frame_par->supsc1_enable = 0;
-
-	if (ver_sc_multiple_num >= (2*SUPER_SCALER_V_FACTOR)) {
-		if (src_width > SUPER_CORE0_WIDTH_MAX/2)
-			next_frame_par->supsc0_vert_ratio = 0;
-		else
-			next_frame_par->supsc0_vert_ratio =
-				next_frame_par->supsc0_enable ? 1 : 0;
-		if (width_out > SUPER_CORE1_WIDTH_MAX*2)
+	/* note:if first check h may cause v can't do scaling;
+	* for example: 1920x1080(input),3840x2160(ouput);
+	* todo:if you have better idea,you can improve it*/
+	/* step1: judge core0&core1 vertical enable or disable*/
+	if (ver_sc_multiple_num >= 2*SUPER_SCALER_V_FACTOR) {
+		next_frame_par->supsc0_vert_ratio =
+			(src_width < SUPER_CORE0_WIDTH_MAX/2) ? 1 : 0;
+		next_frame_par->supsc1_vert_ratio =
+			((width_out < SUPER_CORE1_WIDTH_MAX) &&
+			(src_width < SUPER_CORE1_WIDTH_MAX/2)) ? 1 : 0;
+		if (next_frame_par->supsc0_vert_ratio &&
+			(ver_sc_multiple_num < 4*SUPER_SCALER_V_FACTOR))
 			next_frame_par->supsc1_vert_ratio = 0;
-		else
-			next_frame_par->supsc1_vert_ratio =
-				next_frame_par->supsc1_enable ? 1 : 0;
+		next_frame_par->supsc0_enable =
+			next_frame_par->supsc0_vert_ratio ? 1 : 0;
+		next_frame_par->supsc1_enable =
+			next_frame_par->supsc1_vert_ratio ? 1 : 0;
 	} else {
+		next_frame_par->supsc0_enable = 0;
 		next_frame_par->supsc0_vert_ratio = 0;
+		next_frame_par->supsc1_enable = 0;
 		next_frame_par->supsc1_vert_ratio = 0;
 	}
+	/* step2: judge core0&core1 horizontal enable or disable*/
 	if (hor_sc_multiple_num >= 2) {
-		next_frame_par->supsc0_hori_ratio =
-			next_frame_par->supsc0_enable ? 1 : 0;
-		next_frame_par->supsc1_hori_ratio =
-			next_frame_par->supsc1_enable ? 1 : 0;
+		if ((src_width > SUPER_CORE0_WIDTH_MAX) ||
+			((src_width > SUPER_CORE0_WIDTH_MAX/2) &&
+			next_frame_par->supsc0_vert_ratio) ||
+			(((src_width << 1) > SUPER_CORE1_WIDTH_MAX/2) &&
+			next_frame_par->supsc1_vert_ratio))
+			next_frame_par->supsc0_hori_ratio = 0;
+		else
+			next_frame_par->supsc0_hori_ratio = 1;
+		if (((width_out >> 1) > SUPER_CORE1_WIDTH_MAX) ||
+			(((width_out >> 1) > SUPER_CORE1_WIDTH_MAX/2) &&
+			next_frame_par->supsc1_vert_ratio) ||
+			(next_frame_par->supsc0_hori_ratio &&
+			(hor_sc_multiple_num < 4)))
+			next_frame_par->supsc1_hori_ratio = 0;
+		else
+			next_frame_par->supsc1_hori_ratio = 1;
+		next_frame_par->supsc0_enable =
+			(next_frame_par->supsc0_hori_ratio ||
+			next_frame_par->supsc0_enable) ? 1 : 0;
+		next_frame_par->supsc1_enable =
+			(next_frame_par->supsc1_hori_ratio ||
+			next_frame_par->supsc1_enable) ? 1 : 0;
 	} else {
+		next_frame_par->supsc0_enable = 0;
 		next_frame_par->supsc0_hori_ratio = 0;
+		next_frame_par->supsc1_enable = 0;
 		next_frame_par->supsc1_hori_ratio = 0;
-		next_frame_par->supsc0_vert_ratio = 0;
+	}
+	/*double check core1 input width for core1_vert_ratio!!!*/
+	if (next_frame_par->supsc1_vert_ratio &&
+		(width_out >> next_frame_par->supsc1_hori_ratio >
+		SUPER_CORE1_WIDTH_MAX/2)) {
 		next_frame_par->supsc1_vert_ratio = 0;
+		if (next_frame_par->supsc1_hori_ratio == 0)
+			next_frame_par->supsc1_enable = 0;
 	}
+	/* option add patch */
 	if ((ver_sc_multiple_num <= super_scaler_v_ratio) &&
 		(src_height >= SUPER_CORE0_WIDTH_MAX/2) &&
 		(src_height <= 1088) &&
@@ -1811,7 +1864,7 @@ static void vpp_set_scaler(u32 process_3d_type, u32 src_width,
 }
 
 #ifdef TV_3D_FUNCTION_OPEN
-void get_vpp_3d_mode(u32 trans_fmt, u32 *vpp_3d_mode)
+void get_vpp_3d_mode(u32 process_3d_type, u32 trans_fmt, u32 *vpp_3d_mode)
 {
 	switch (trans_fmt) {
 	case TVIN_TFMT_3D_LRH_OLOR:
@@ -1826,6 +1879,8 @@ void get_vpp_3d_mode(u32 trans_fmt, u32 *vpp_3d_mode)
 	case TVIN_TFMT_3D_DET_TB:
 	case TVIN_TFMT_3D_FA:
 		*vpp_3d_mode = VPP_3D_MODE_TB;
+		if (process_3d_type & MODE_3D_MVC)
+			*vpp_3d_mode = VPP_3D_MODE_FA;
 		break;
 	case TVIN_TFMT_3D_LA:
 	case TVIN_TFMT_3D_DET_INTERLACE:
@@ -1894,7 +1949,8 @@ vpp_get_video_source_size(u32 *src_width, u32 *src_height,
 			break;
 		}
 
-	} else if (process_3d_type & MODE_3D_LR) {
+	} else if ((process_3d_type & MODE_3D_LR) ||
+	(process_3d_type & MODE_FORCE_3D_LR)) {
 		next_frame_par->vpp_3d_mode = VPP_3D_MODE_LR;
 		if (process_3d_type & MODE_3D_TO_2D_MASK) {
 			*src_width = vf->width >> 1;
@@ -1909,7 +1965,8 @@ vpp_get_video_source_size(u32 *src_width, u32 *src_height,
 			next_frame_par->vpp_2pic_mode = 1;
 		}
 
-	} else if (process_3d_type & MODE_3D_TB) {
+	} else if ((process_3d_type & MODE_3D_TB) ||
+	(process_3d_type & MODE_FORCE_3D_TB)) {
 		next_frame_par->vpp_3d_mode = VPP_3D_MODE_TB;
 		if (process_3d_type & MODE_3D_TO_2D_MASK) {
 			*src_width = vf->width;
@@ -1923,6 +1980,12 @@ vpp_get_video_source_size(u32 *src_width, u32 *src_height,
 			*src_height = vf->height;
 			next_frame_par->vpp_2pic_mode = 1;
 		}
+		if (process_3d_type & MODE_3D_MVC) {
+			*src_width = vf->width;
+			*src_height = vf->height << 1;
+			next_frame_par->vpp_2pic_mode = 2;
+			next_frame_par->vpp_3d_mode = VPP_3D_MODE_FA;
+		}
 	} else if (process_3d_type & MODE_3D_LA) {
 		next_frame_par->vpp_3d_mode = VPP_3D_MODE_LA;
 		*src_height = vf->height - 1;
@@ -2029,7 +2092,7 @@ vpp_set_filters(u32 process_3d_type, u32 wide_mode,
 		next_frame_par->vpp_3d_scale = 0;
 	}
 	next_frame_par->trans_fmt = vf->trans_fmt;
-	get_vpp_3d_mode(next_frame_par->trans_fmt,
+	get_vpp_3d_mode(process_3d_type, next_frame_par->trans_fmt,
 		&next_frame_par->vpp_3d_mode);
 	if (vpp_3d_scale)
 		next_frame_par->vpp_3d_scale = 1;
@@ -2328,5 +2391,14 @@ void vpp_super_scaler_support(void)
 		super_scaler = 0;
 }
 
+void vpp_bypass_ratio_config(void)
+{
+	if ((get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB)
+		|| (get_cpu_type() == MESON_CPU_MAJOR_ID_GXL)
+		|| (get_cpu_type() == MESON_CPU_MAJOR_ID_GXM))
+		bypass_ratio = 125;
+	else
+		bypass_ratio = 205;
+}
 
 
diff --git a/drivers/amlogic/amports/vpp.h b/drivers/amlogic/amports/vpp.h
index 3e35c16..0742b42 100644
--- a/drivers/amlogic/amports/vpp.h
+++ b/drivers/amlogic/amports/vpp.h
@@ -152,6 +152,13 @@ enum select_scaler_path_e {
 	sup0_pp_sp1_scpath,
 	sup0_pp_post_blender,
 };
+/*
+* note frome vlsi!!!
+* if core0 v enable,core0 input width max=1024;
+* if core0 v disable,core0 input width max=2048;
+* if core1 v enable,core1 input width max=2048;
+* if core1 v disable,core1 input width max=4096;
+*/
 #define SUPER_CORE0_WIDTH_MAX  2048
 #define SUPER_CORE1_WIDTH_MAX  4096
 
@@ -174,6 +181,9 @@ enum select_scaler_path_e {
 #define MODE_3D_OUT_LR	0x00020000
 #define MODE_FORCE_3D_TO_2D_LR	0x00100000
 #define MODE_FORCE_3D_TO_2D_TB	0x00200000
+#define MODE_FORCE_3D_LR	0x01000000
+#define MODE_FORCE_3D_TB	0x02000000
+#define MODE_3D_FP			0x04000000
 
 /*when the output mode is field alterlative*/
 /* LRLRLRLRL mode */
@@ -206,7 +216,7 @@ enum select_scaler_path_e {
 extern
 void vpp_set_3d_scale(bool enable);
 extern
-void get_vpp_3d_mode(u32 trans_fmt, u32 *vpp_3d_mode);
+void get_vpp_3d_mode(u32 process_3d_type, u32 trans_fmt, u32 *vpp_3d_mode);
 #endif
 
 extern void
@@ -232,22 +242,19 @@ extern u32 vpp_get_zoom_ratio(void);
 
 extern void vpp_set_osd_layer_preblend(u32 *);
 
-extern
-void vpp_set_osd_layer_position(s32 *);
+extern void vpp_set_osd_layer_position(s32 *);
 
-extern
-s32 vpp_set_nonlinear_factor(u32 f);
+extern s32 vpp_set_nonlinear_factor(u32 f);
 
-extern
-u32 vpp_get_nonlinear_factor(void);
-extern
-void vpp_set_video_speed_check(u32 h, u32 w);
+extern u32 vpp_get_nonlinear_factor(void);
 
-extern
-void vpp_get_video_speed_check(u32 *h, u32 *w);
+extern void vpp_set_video_speed_check(u32 h, u32 w);
 
-extern
-void vpp_super_scaler_support(void);
+extern void vpp_get_video_speed_check(u32 *h, u32 *w);
+
+extern void vpp_super_scaler_support(void);
+
+extern void vpp_bypass_ratio_config(void);
 
 #ifdef CONFIG_AM_VIDEO2
 extern void
@@ -263,6 +270,7 @@ extern void vpp2_set_zoom_ratio(u32 r);
 
 extern u32 vpp2_get_zoom_ratio(void);
 #endif
+extern int video_property_notify(int flag);
 
 extern int vpp_set_super_scaler_regs(int scaler_path_sel,
 		int reg_srscl0_enable,
diff --git a/drivers/amlogic/amports/vreal.c b/drivers/amlogic/amports/vreal.c
index fdf9468..b18e4d2 100644
--- a/drivers/amlogic/amports/vreal.c
+++ b/drivers/amlogic/amports/vreal.c
@@ -49,7 +49,6 @@
 #include "vreal.h"
 #include "arch/register.h"
 
-
 #define DRIVER_NAME "amvdec_real"
 #define MODULE_NAME "amvdec_real"
 
@@ -490,7 +489,7 @@ static void vreal_put_timer_func(unsigned long arg)
 	add_timer(timer);
 }
 
-int vreal_dec_status(struct vdec_status *vstatus)
+int vreal_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
 {
 	vstatus->width = vreal_amstream_dec_info.width;
 	vstatus->height = vreal_amstream_dec_info.height;
@@ -761,7 +760,7 @@ static void load_block_data(void *dest, unsigned int count)
 	return;
 }
 
-s32 vreal_init(void)
+s32 vreal_init(struct vdec_s *vdec)
 {
 	int r;
 
@@ -775,7 +774,7 @@ s32 vreal_init(void)
 
 	vreal_local_init();
 
-	r = rmparser_init();
+	r = rmparser_init(vdec);
 	if (r) {
 		amvdec_disable();
 
@@ -853,8 +852,6 @@ s32 vreal_init(void)
 
 	stat |= STAT_VDEC_RUN;
 
-	set_vdec_func(&vreal_dec_status);
-
 	pr_info("vreal init finished\n");
 
 	return 0;
@@ -871,8 +868,7 @@ void vreal_set_fatal_flag(int flag)
 
 static int amvdec_real_probe(struct platform_device *pdev)
 {
-	struct vdec_dev_reg_s *pdata =
-		(struct vdec_dev_reg_s *)pdev->dev.platform_data;
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
 
 	if (pdata == NULL) {
 		pr_info("amvdec_real memory resource undefined.\n");
@@ -907,8 +903,9 @@ static int amvdec_real_probe(struct platform_device *pdev)
 	/* } */
 	/* #endif */
 
+	pdata->dec_status = vreal_dec_status;
 
-	if (vreal_init() < 0) {
+	if (vreal_init(pdata) < 0) {
 		pr_info("amvdec_real init failed.\n");
 		/* #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)&&(HAS_HDEC) */
 		/* if(IS_MESON_M8_CPU) */
diff --git a/drivers/amlogic/amports/vvc1.c b/drivers/amlogic/amports/vvc1.c
index efa894b..0dd5f1a 100644
--- a/drivers/amlogic/amports/vvc1.c
+++ b/drivers/amlogic/amports/vvc1.c
@@ -65,8 +65,8 @@
 #define VC1_OFFSET_REG      AV_SCRATCH_C
 #define MEM_OFFSET_REG      AV_SCRATCH_F
 
-#define VF_POOL_SIZE          16
-#define DECODE_BUFFER_NUM_MAX 4
+#define VF_POOL_SIZE          32
+#define DECODE_BUFFER_NUM_MAX 8
 #define PUT_INTERVAL        (HZ/100)
 
 #if 1	/* /MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
@@ -171,9 +171,10 @@ static inline bool close_to(int a, int b, int m)
 
 static inline u32 index2canvas(u32 index)
 {
-	const u32 canvas_tab[4] = {
+	const u32 canvas_tab[DECODE_BUFFER_NUM_MAX] = {
 #if 1	/* ALWASY.MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
-		0x010100, 0x030302, 0x050504, 0x070706
+		0x010100, 0x030302, 0x050504, 0x070706,
+		0x090908, 0x0b0b0a, 0x0d0d0c, 0x0f0f0e
 #else
 		0x020100, 0x050403, 0x080706, 0x0b0a09
 #endif
@@ -304,6 +305,10 @@ static irqreturn_t vvc1_isr(int irq, void *dev_id)
 			}
 		}
 
+		repeat_count = READ_VREG(VC1_REPEAT_COUNT);
+		buffer_index = reg & 0x7;
+		picture_type = (reg >> 3) & 7;
+
 		if (buffer_index >= DECODE_BUFFER_NUM_MAX) {
 			pr_info("fatal error, invalid buffer index.");
 			return IRQ_HANDLED;
@@ -683,7 +688,7 @@ static int vvc1_event_cb(int type, void *data, void *private_data)
 	return 0;
 }
 
-int vvc1_dec_status(struct vdec_status *vstatus)
+int vvc1_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
 {
 	vstatus->width = vvc1_amstream_dec_info.width;
 	vstatus->height = vvc1_amstream_dec_info.height;
@@ -729,30 +734,30 @@ static void vvc1_canvas_init(void)
 		disp_addr = (cur_canvas.addr + 7) >> 3;
 	}
 
-	for (i = 0; i < 4; i++) {
+	for (i = 0; i < 8; i++) {
 		if (((buf_start + i * decbuf_size + 7) >> 3) == disp_addr) {
 #ifdef NV21
 			canvas_config(2 * i + 0,
-				buf_start + 4 * decbuf_size,
+				buf_start + 8 * decbuf_size,
 				canvas_width, canvas_height,
 				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
 			canvas_config(2 * i + 1,
-				buf_start + 4 * decbuf_size +
+				buf_start + 8 * decbuf_size +
 				decbuf_y_size, canvas_width,
 				canvas_height / 2, CANVAS_ADDR_NOWRAP,
 				CANVAS_BLKMODE_32X32);
 #else
 			canvas_config(3 * i + 0,
-				buf_start + 4 * decbuf_size,
+				buf_start + 8 * decbuf_size,
 				canvas_width, canvas_height,
 				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
 			canvas_config(3 * i + 1,
-				buf_start + 4 * decbuf_size +
+				buf_start + 8 * decbuf_size +
 				decbuf_y_size, canvas_width / 2,
 				canvas_height / 2, CANVAS_ADDR_NOWRAP,
 				CANVAS_BLKMODE_32X32);
 			canvas_config(3 * i + 2,
-				buf_start + 4 * decbuf_size +
+				buf_start + 8 * decbuf_size +
 				decbuf_y_size + decbuf_uv_size,
 				canvas_width / 2, canvas_height / 2,
 				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_32X32);
@@ -824,11 +829,19 @@ static void vvc1_prot_init(void)
 	WRITE_VREG(AV_SCRATCH_1, 0x030302);
 	WRITE_VREG(AV_SCRATCH_2, 0x050504);
 	WRITE_VREG(AV_SCRATCH_3, 0x070706);
+	WRITE_VREG(AV_SCRATCH_G, 0x090908);
+	WRITE_VREG(AV_SCRATCH_H, 0x0b0b0a);
+	WRITE_VREG(AV_SCRATCH_I, 0x0d0d0c);
+	WRITE_VREG(AV_SCRATCH_J, 0x0f0f0e);
 #else
 	WRITE_VREG(AV_SCRATCH_0, 0x020100);
 	WRITE_VREG(AV_SCRATCH_1, 0x050403);
 	WRITE_VREG(AV_SCRATCH_2, 0x080706);
 	WRITE_VREG(AV_SCRATCH_3, 0x0b0a09);
+	WRITE_VREG(AV_SCRATCH_G, 0x090908);
+	WRITE_VREG(AV_SCRATCH_H, 0x0b0b0a);
+	WRITE_VREG(AV_SCRATCH_I, 0x0d0d0c);
+	WRITE_VREG(AV_SCRATCH_J, 0x0f0f0e);
 #endif
 
 	/* notify ucode the buffer offset */
@@ -859,7 +872,7 @@ static void vvc1_local_init(void)
 	/* vvc1_ratio = vvc1_amstream_dec_info.ratio; */
 	vvc1_ratio = 0x100;
 
-	avi_flag = (unsigned long) vvc1_amstream_dec_info.param & 0x1;
+	avi_flag = (unsigned long) vvc1_amstream_dec_info.param;
 	keyframe_pts_only = (u32)vvc1_amstream_dec_info.param & 0x100;
 
 	total_frame = 0;
@@ -1025,15 +1038,12 @@ static s32 vvc1_init(void)
 
 	stat |= STAT_VDEC_RUN;
 
-	set_vdec_func(&vvc1_dec_status);
-
 	return 0;
 }
 
 static int amvdec_vc1_probe(struct platform_device *pdev)
 {
-	struct vdec_dev_reg_s *pdata =
-		(struct vdec_dev_reg_s *)pdev->dev.platform_data;
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
 
 	if (pdata == NULL) {
 		pr_info("amvdec_vc1 memory resource undefined.\n");
@@ -1047,6 +1057,8 @@ static int amvdec_vc1_probe(struct platform_device *pdev)
 	if (pdata->sys_info)
 		vvc1_amstream_dec_info = *pdata->sys_info;
 
+	pdata->dec_status = vvc1_dec_status;
+
 	if (vvc1_init() < 0) {
 		pr_info("amvdec_vc1 init failed.\n");
 
diff --git a/drivers/amlogic/amports/vvp9.c b/drivers/amlogic/amports/vvp9.c
index 822f65c..0decf45 100644
--- a/drivers/amlogic/amports/vvp9.c
+++ b/drivers/amlogic/amports/vvp9.c
@@ -39,17 +39,19 @@
 #include <linux/slab.h>
 #include "amports_priv.h"
 #include <linux/amlogic/codec_mm/codec_mm.h>
+#include "decoder/decoder_mmu_box.h"
+#include "decoder/decoder_bmmu_box.h"
 
 #define MEM_NAME "codec_vp9"
 /* #include <mach/am_regs.h> */
 #include "vdec_reg.h"
+#include "video.h"
 
 #include "vdec.h"
 #include "amvdec.h"
 
 #define MIX_STREAM_SUPPORT
 #define SUPPORT_4K2K
-/*#define VP9_10B_MMU*/
 
 #include "vvp9.h"
 #define VP9D_MPP_REFINFO_TBL_ACCCONFIG             0x3442
@@ -70,6 +72,12 @@
 #define VP9_10B_DECODE_SLICE                     5
 #define VP9_10B_DISCARD_NAL                  6
 #define VP9_DUMP_LMEM                7
+#define HEVC_DECPIC_DATA_DONE            0xa
+#define HEVC_DECPIC_DATA_ERROR            0xb
+#define HEVC_NAL_DECODE_DONE            0xe
+#define HEVC_DECODE_BUFEMPTY        0x20
+#define HEVC_DECODE_TIMEOUT         0x21
+#define HEVC_SEARCH_BUFEMPTY        0x22
 #define VP9_HEAD_PARSER_DONE            0xf0
 #define VP9_HEAD_SEARCH_DONE          0xf1
 #define VP9_EOS                        0xf2
@@ -82,6 +90,10 @@
 #undef pr_info
 #define pr_info printk
 
+#define DECODE_MODE_SINGLE				0
+#define DECODE_MODE_MULTI_STREAMBASE	1
+#define DECODE_MODE_MULTI_FRAMEBASE		2
+
 /*---------------------------------------------------
  Include "parser_cmd.h"
 ---------------------------------------------------*/
@@ -137,7 +149,7 @@ unsigned short parser_cmd[PARSER_CMD_NUMBER] = {
 
 /*#define CODEC_MM_FLAGS_FOR_VDECODER  0*/
 
-
+#define MULTI_INSTANCE_SUPPORT
 #define SUPPORT_10BIT
 /* #define ERROR_HANDLE_DEBUG */
 #if 0 /* MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B*/
@@ -150,6 +162,11 @@ unsigned short parser_cmd[PARSER_CMD_NUMBER] = {
 #define STAT_KTHREAD 0x40
 #endif
 
+#ifdef MULTI_INSTANCE_SUPPORT
+#define MAX_DECODE_INSTANCE_NUM     5
+#define MULTI_DRIVER_NAME "ammvdec_vp9"
+#endif
+
 #define DRIVER_NAME "amvdec_vp9"
 #define MODULE_NAME "amvdec_vp9"
 
@@ -176,11 +193,20 @@ static s32 vvp9_init(struct VP9Decoder_s *pbi);
 static void vvp9_prot_init(struct VP9Decoder_s *pbi);
 static int vvp9_local_init(struct VP9Decoder_s *pbi);
 static void vvp9_put_timer_func(unsigned long arg);
-
+#ifdef VP9_10B_MMU
+static int vp9_alloc_mmu(
+		struct VP9Decoder_s *pbi,
+		int cur_buf_idx,
+		int pic_width,
+		int pic_height,
+		unsigned short bit_depth,
+		unsigned int *mmu_index_adr);
+#endif
 
 static const char vvp9_dec_id[] = "vvp9-dev";
 
 #define PROVIDER_NAME   "decoder.vp9"
+#define MULTI_INSTANCE_PROVIDER_NAME    "vdec.vp9"
 
 static const struct vframe_operations_s vvp9_vf_provider = {
 	.peek = vvp9_vf_peek,
@@ -294,7 +320,13 @@ typedef unsigned short u16;
 #define VP9_DEBUG_LOAD_UCODE_FROM_FILE   0x200000
 #define VP9_DEBUG_ERROR_TRIG             0x400000
 #define VP9_DEBUG_NOWAIT_DECODE_DONE_WHEN_STOP   0x4000000
-
+#ifdef MULTI_INSTANCE_SUPPORT
+#define PRINT_FLAG_ERROR				0
+#define PRINT_FLAG_UCODE_EVT             0x10000000
+#define PRINT_FLAG_VDEC_STATUS             0x20000000
+#define PRINT_FLAG_VDEC_DETAIL             0x40000000
+#define PRINT_FLAG_VDEC_DATA             0x80000000
+#endif
 
 static u32 debug;
 
@@ -320,9 +352,7 @@ VP9 buffer management start
 #ifdef VP9_10B_MMU
 #define MMU_COMPRESS_HEADER_SIZE  0x48000
 #endif
-static DEFINE_SPINLOCK(lock);
-#define   lock_buffer_pool(pool)
-#define   unlock_buffer_pool(pool)
+
 #define INVALID_IDX -1  /* Invalid buffer index.*/
 
 #define RPM_BEGIN                                              0x200
@@ -408,7 +438,9 @@ struct PIC_BUFFER_CONFIG_s {
 	int vf_ref;
 	int y_canvas_index;
 	int uv_canvas_index;
-
+#ifdef MULTI_INSTANCE_SUPPORT
+	struct canvas_config_s canvas_config[2];
+#endif
 	int decode_idx;
 	int slice_type;
 	int num_reorder_pic;
@@ -467,6 +499,7 @@ struct PIC_BUFFER_CONFIG_s {
 
 	int corrupted;
 	int flags;
+	unsigned long cma_alloc_addr;
 } PIC_BUFFER_CONFIG;
 
 enum BITSTREAM_PROFILE {
@@ -512,7 +545,8 @@ normal reference pool.*/
 
 #define FRAME_CONTEXTS_LOG2 2
 #define FRAME_CONTEXTS (1 << FRAME_CONTEXTS_LOG2)
-
+#define MAX_BMMU_BUFFER_NUM (FRAME_BUFFERS + 1)
+#define WORK_SPACE_BUF_ID (FRAME_BUFFERS)
 
 struct RefCntBuffer_s {
 	int ref_count;
@@ -569,8 +603,20 @@ vpx_release_frame_buffer_cb_fn_t release_fb_cb;*/
 
 /*Frame buffers allocated internally by the codec.*/
 	struct InternalFrameBufferList_s int_frame_buffers;
+	unsigned long flags;
+	spinlock_t lock;
+
 } BufferPool;
 
+static void lock_buffer_pool(struct BufferPool_s *pool)
+{
+	spin_lock_irqsave(&pool->lock, pool->flags);
+}
+static void unlock_buffer_pool(struct BufferPool_s *pool)
+{
+	spin_unlock_irqrestore(&pool->lock, pool->flags);
+}
+
 struct VP9_Common_s {
 	enum vpx_color_space_t color_space;
 	int width;
@@ -760,6 +806,9 @@ int vp9_release_frame_buffer(struct vpx_codec_frame_buffer_s *fb)
 	return 0;
 }
 
+static int  compute_losless_comp_body_size(int width, int height,
+				uint8_t is_bit_depth_10);
+
 static void setup_display_size(struct VP9_Common_s *cm, union param_u *params,
 						int print_header_info)
 {
@@ -815,12 +864,17 @@ static int valid_ref_frame_img_fmt(enum vpx_bit_depth_t ref_bit_depth,
 }
 */
 
-static void setup_frame_size(struct VP9_Common_s *cm, union param_u *params,
-				unsigned int *mmu_index_adr,
-				int print_header_info) {
+
+static int setup_frame_size(
+		struct VP9Decoder_s *pbi,
+		struct VP9_Common_s *cm, union param_u *params,
+		unsigned int *mmu_index_adr,
+		int print_header_info) {
 	int width, height;
 	struct BufferPool_s * const pool = cm->buffer_pool;
 	struct PIC_BUFFER_CONFIG_s *ybf;
+	int ret = 0;
+
 	width = params->p.width;
 	height = params->p.height;
 	/*vp9_read_frame_size(rb, &width, &height);*/
@@ -835,11 +889,21 @@ static void setup_frame_size(struct VP9_Common_s *cm, union param_u *params,
 #ifdef VP9_10B_MMU
 	/* if(cm->prev_fb_idx >= 0) release_unused_4k(cm->prev_fb_idx);*/
 	/* cm->prev_fb_idx = cm->new_fb_idx;*/
-	pr_info
+	/*pr_info
 	("[DEBUG DEBUG]Before alloc_mmu, prev_fb_idx : %d, new_fb_idx : %d\r\n",
-	cm->prev_fb_idx, cm->new_fb_idx);
-	alloc_mmu(cm->new_fb_idx, params->p.width, params->p.height,
-	params->p.bit_depth, mmu_index_adr);
+	cm->prev_fb_idx, cm->new_fb_idx);*/
+	ret = vp9_alloc_mmu(pbi,
+		cm->new_fb_idx,
+		params->p.width,
+		params->p.height,
+		params->p.bit_depth,
+		mmu_index_adr);
+	if (ret != 0) {
+		pr_err("can't alloc need mmu1,idx %d ret =%d\n",
+			cm->new_fb_idx,
+			ret);
+		return ret;
+	}
 #endif
 
 	resize_context_buffers(cm, width, height);
@@ -873,17 +937,23 @@ static void setup_frame_size(struct VP9_Common_s *cm, union param_u *params,
 	pool->frame_bufs[cm->new_fb_idx].buf.bit_depth =
 						(unsigned int)cm->bit_depth;
 	pool->frame_bufs[cm->new_fb_idx].buf.color_space = cm->color_space;
+	return ret;
 }
 
-static int setup_frame_size_with_refs(struct VP9_Common_s *cm,
-					union param_u *params,
-					unsigned int *mmu_index_adr,
-					int print_header_info) {
+static int setup_frame_size_with_refs(
+		struct VP9Decoder_s *pbi,
+		struct VP9_Common_s *cm,
+		union param_u *params,
+		unsigned int *mmu_index_adr,
+		int print_header_info) {
+
 	int width, height;
 	int found = 0, i;
 	int has_valid_ref_frame = 0;
 	struct PIC_BUFFER_CONFIG_s *ybf;
 	struct BufferPool_s * const pool = cm->buffer_pool;
+	int ret = 0;
+
 	for (i = 0; i < REFS_PER_FRAME; ++i) {
 		if ((params->p.same_frame_size >>
 				(REFS_PER_FRAME - i - 1)) & 0x1) {
@@ -935,11 +1005,17 @@ static int setup_frame_size_with_refs(struct VP9_Common_s *cm,
 #ifdef VP9_10B_MMU
 	/*if(cm->prev_fb_idx >= 0) release_unused_4k(cm->prev_fb_idx);
 	cm->prev_fb_idx = cm->new_fb_idx;*/
-	pr_info
+/*	pr_info
 	("[DEBUG DEBUG]Before alloc_mmu, prev_fb_idx : %d, new_fb_idx : %d\r\n",
-	cm->prev_fb_idx, cm->new_fb_idx);
-	alloc_mmu(cm->new_fb_idx, params->p.width, params->p.height,
+	cm->prev_fb_idx, cm->new_fb_idx);*/
+	ret = vp9_alloc_mmu(pbi, cm->new_fb_idx,
+			params->p.width, params->p.height,
 	params->p.bit_depth, mmu_index_adr);
+	if (ret != 0) {
+		pr_err("can't alloc need mmu,idx %d\r\n",
+			cm->new_fb_idx);
+		return ret;
+	}
 #endif
 
 	/*Check to make sure at least one of frames that this frame references
@@ -1004,7 +1080,7 @@ static int setup_frame_size_with_refs(struct VP9_Common_s *cm,
 	pool->frame_bufs[cm->new_fb_idx].buf.bit_depth =
 						(unsigned int)cm->bit_depth;
 	pool->frame_bufs[cm->new_fb_idx].buf.color_space = cm->color_space;
-	return 0;
+	return ret;
 }
 
 uint8_t print_header_info = 0;
@@ -1044,7 +1120,40 @@ struct BuffInfo_s {
 	struct buff_s lmem;
 } BuffInfo_t;
 
+#ifdef MULTI_INSTANCE_SUPPORT
+#define DEC_RESULT_NONE             0
+#define DEC_RESULT_DONE             1
+#define DEC_RESULT_AGAIN            2
+#define DEC_RESULT_CONFIG_PARAM     3
+#define DEC_RESULT_ERROR            4
+#define DEC_INIT_PICLIST			5
+#define DEC_UNINIT_PICLIST			6
+#define DEC_RESULT_GET_DATA         7
+#define DEC_RESULT_GET_DATA_RETRY   8
+
+static void vp9_work(struct work_struct *work);
+#endif
+
 struct VP9Decoder_s {
+#ifdef MULTI_INSTANCE_SUPPORT
+	unsigned char index;
+
+	struct device *cma_dev;
+	struct platform_device *platform_dev;
+	void (*vdec_cb)(struct vdec_s *, void *);
+	void *vdec_cb_arg;
+	struct vframe_chunk_s *chunk;
+	int dec_result;
+	struct work_struct work;
+
+	struct BuffInfo_s work_space_buf_store;
+	unsigned long buf_start;
+	u32 buf_size;
+	u32 cma_alloc_count;
+	unsigned long cma_alloc_addr;
+#endif
+	unsigned char m_ins_flag;
+	char *provider_name;
 	union param_u param;
 	int frame_count;
 	int pic_count;
@@ -1077,11 +1186,6 @@ struct VP9Decoder_s {
 #endif
 	unsigned int use_cma_flag;
 
-	unsigned long pre_last_frame_alloc_addr;
-	unsigned long pre_last_frame_alloc_size;
-	u32 predisp_addr;
-	u32 predisp_size;
-
 	struct BUF_s m_BUF[MAX_BUF_NUM];
 	u32 used_buf_num;
 	DECLARE_KFIFO(newframe_q, struct vframe_s *, VF_POOL_SIZE);
@@ -1146,15 +1250,180 @@ struct VP9Decoder_s {
 	/*hw*/
 
 	u32 pre_stream_offset;
+
+	unsigned int dec_status;
+	u32 last_put_idx;
+	int new_frame_displayed;
+	void *mmu_box;
+	void *bmmu_box;
 } VP9Decoder;
 
+static int vp9_print(struct VP9Decoder_s *pbi,
+	int flag, const char *fmt, ...)
+{
+#define HEVC_PRINT_BUF		128
+	unsigned char buf[HEVC_PRINT_BUF];
+	int len = 0;
+	if (pbi == NULL ||
+		(flag == 0) ||
+		(debug & flag)) {
+		va_list args;
+		va_start(args, fmt);
+		if (pbi)
+			len = sprintf(buf, "[%d]", pbi->index);
+		vsnprintf(buf + len, HEVC_PRINT_BUF - len, fmt, args);
+		pr_info("%s", buf);
+		va_end(args);
+	}
+	return 0;
+}
+
+#ifdef MULTI_INSTANCE_SUPPORT
+static int vp9_print_cont(struct VP9Decoder_s *pbi,
+	int flag, const char *fmt, ...)
+{
+	unsigned char buf[HEVC_PRINT_BUF];
+	int len = 0;
+	if (pbi == NULL ||
+		(flag == 0) ||
+		(debug & flag)) {
+		va_list args;
+		va_start(args, fmt);
+		vsnprintf(buf + len, HEVC_PRINT_BUF - len, fmt, args);
+		pr_info("%s", buf);
+		va_end(args);
+	}
+	return 0;
+}
+#endif
+
+#ifdef VP9_10B_MMU
+int vp9_alloc_mmu(
+	struct VP9Decoder_s *pbi,
+	int cur_buf_idx,
+	int pic_width,
+	int pic_height,
+	unsigned short bit_depth,
+	unsigned int *mmu_index_adr)
+{
+	int bit_depth_10 = (bit_depth == VPX_BITS_10);
+	int picture_size;
+	int cur_mmu_4k_number;
+
+	picture_size = compute_losless_comp_body_size(pic_width, pic_height,
+				   bit_depth_10);
+	cur_mmu_4k_number = ((picture_size + (1 << 12) - 1) >> 12);
+	return decoder_mmu_box_alloc_idx(
+		pbi->mmu_box,
+		cur_buf_idx,
+		cur_mmu_4k_number,
+		mmu_index_adr);
+}
+#endif
+static void decrease_ref_count(int idx, struct RefCntBuffer_s *const frame_bufs,
+					struct BufferPool_s *const pool)
+{
+	if (idx >= 0) {
+		--frame_bufs[idx].ref_count;
+		/*pr_info("[MMU DEBUG 7] dec ref_count[%d] : %d\r\n", idx,
+			frame_bufs[idx].ref_count);*/
+		/*A worker may only get a free framebuffer index when
+		calling get_free_fb. But the private buffer is not set up
+		until finish decoding header. So any error happens during
+		decoding header, the frame_bufs will not have valid priv
+		buffer.*/
+
+		if (frame_bufs[idx].ref_count == 0 &&
+			frame_bufs[idx].raw_frame_buffer.priv)
+			vp9_release_frame_buffer
+			(&frame_bufs[idx].raw_frame_buffer);
+	}
+}
+
+static void generate_next_ref_frames(struct VP9Decoder_s *pbi)
+{
+	struct VP9_Common_s *const cm = &pbi->common;
+	struct RefCntBuffer_s *frame_bufs = cm->buffer_pool->frame_bufs;
+	struct BufferPool_s *const pool = cm->buffer_pool;
+	int mask, ref_index = 0;
+
+	/* Generate next_ref_frame_map.*/
+	lock_buffer_pool(pool);
+	for (mask = pbi->refresh_frame_flags; mask; mask >>= 1) {
+		if (mask & 1) {
+			cm->next_ref_frame_map[ref_index] = cm->new_fb_idx;
+			++frame_bufs[cm->new_fb_idx].ref_count;
+			/*pr_info("[MMU DEBUG 4] inc ref_count[%d] : %d\r\n",
+			cm->new_fb_idx, frame_bufs[cm->new_fb_idx].ref_count);*/
+		} else
+			cm->next_ref_frame_map[ref_index] =
+				cm->ref_frame_map[ref_index];
+		/* Current thread holds the reference frame.*/
+		if (cm->ref_frame_map[ref_index] >= 0) {
+			++frame_bufs[cm->ref_frame_map[ref_index]].ref_count;
+			/*pr_info
+			("[MMU DEBUG 5] inc ref_count[%d] : %d\r\n",
+			cm->ref_frame_map[ref_index],
+			frame_bufs[cm->ref_frame_map[ref_index]].ref_count);*/
+		}
+		++ref_index;
+	}
+
+	for (; ref_index < REF_FRAMES; ++ref_index) {
+		cm->next_ref_frame_map[ref_index] =
+			cm->ref_frame_map[ref_index];
+		/* Current thread holds the reference frame.*/
+		if (cm->ref_frame_map[ref_index] >= 0) {
+			++frame_bufs[cm->ref_frame_map[ref_index]].ref_count;
+			/*pr_info("[MMU DEBUG 6] inc ref_count[%d] : %d\r\n",
+			cm->ref_frame_map[ref_index],
+			frame_bufs[cm->ref_frame_map[ref_index]].ref_count);*/
+		}
+	}
+	unlock_buffer_pool(pool);
+	return;
+}
+
+static void refresh_ref_frames(struct VP9Decoder_s *pbi)
+
+{
+	struct VP9_Common_s *const cm = &pbi->common;
+	struct BufferPool_s *pool = cm->buffer_pool;
+	struct RefCntBuffer_s *frame_bufs = cm->buffer_pool->frame_bufs;
+	int mask, ref_index = 0;
+
+	lock_buffer_pool(pool);
+	for (mask = pbi->refresh_frame_flags; mask; mask >>= 1) {
+		const int old_idx = cm->ref_frame_map[ref_index];
+		/*Current thread releases the holding of reference frame.*/
+		decrease_ref_count(old_idx, frame_bufs, pool);
+
+		/*Release the reference frame in reference map.*/
+		if ((mask & 1) && old_idx >= 0)
+			decrease_ref_count(old_idx, frame_bufs, pool);
+		cm->ref_frame_map[ref_index] =
+			cm->next_ref_frame_map[ref_index];
+		++ref_index;
+	}
 
+	/*Current thread releases the holding of reference frame.*/
+	for (; ref_index < REF_FRAMES && !cm->show_existing_frame;
+		++ref_index) {
+		const int old_idx = cm->ref_frame_map[ref_index];
+		decrease_ref_count(old_idx, frame_bufs, pool);
+		cm->ref_frame_map[ref_index] =
+			cm->next_ref_frame_map[ref_index];
+	}
+	unlock_buffer_pool(pool);
+	return;
+}
 int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
 {
 	struct VP9_Common_s *const cm = &pbi->common;
 	struct BufferPool_s *pool = cm->buffer_pool;
 	struct RefCntBuffer_s *frame_bufs = cm->buffer_pool->frame_bufs;
-	int i, mask, ref_index = 0;
+	int i;
+	int ret;
 
 	pbi->ready_for_new_data = 0;
 
@@ -1168,16 +1437,14 @@ int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
 #ifdef VP9_10B_MMU
 	if (cm->prev_fb_idx >= 0) {
 		long used_4k_num = (READ_VREG(HEVC_SAO_MMU_STATUS) >> 16);
-		release_unused_4k(used_4k_num, cm->prev_fb_idx);
+		decoder_mmu_box_free_idx_tail(pbi->mmu_box,
+		cm->prev_fb_idx, used_4k_num);
 	}
 #endif
 	if (cm->new_fb_idx >= 0
 		&& frame_bufs[cm->new_fb_idx].ref_count == 0){
 		vp9_release_frame_buffer
 			(&frame_bufs[cm->new_fb_idx].raw_frame_buffer);
-#ifdef VP9_10B_MMU
-		release_buffer_4k(cm->new_fb_idx);
-#endif
 	}
 	/*pr_info("Before get_free_fb, prev_fb_idx : %d, new_fb_idx : %d\r\n",
 		cm->prev_fb_idx, cm->new_fb_idx);*/
@@ -1257,8 +1524,11 @@ int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
 			cm->frame_refs[i].buf = NULL;
 		}
 
-		setup_frame_size(cm, params,  pbi->frame_mmu_map_addr,
-					print_header_info);
+		ret = setup_frame_size(pbi,
+			cm, params,  pbi->frame_mmu_map_addr,
+				print_header_info);
+		if (ret)
+			return -1;
 		if (pbi->need_resync) {
 			memset(&cm->ref_frame_map, -1,
 				sizeof(cm->ref_frame_map));
@@ -1310,8 +1580,14 @@ int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
 			/*if (print_header_info)
 				pr_info("*%d-bits refresh_frame read:0x%x\n",
 				REF_FRAMES, pbi->refresh_frame_flags);*/
-			setup_frame_size(cm, params,  pbi->frame_mmu_map_addr,
+			ret = setup_frame_size(pbi,
+				cm,
+				params,
+				pbi->frame_mmu_map_addr,
 				print_header_info);
+			if (ret) {
+				return -1;
+			}
 			if (pbi->need_resync) {
 				memset(&cm->ref_frame_map, -1,
 					sizeof(cm->ref_frame_map));
@@ -1356,9 +1632,15 @@ int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
 
 				}
 
-				setup_frame_size_with_refs(cm, params,
+				ret = setup_frame_size_with_refs(
+					pbi,
+					cm,
+					params,
 					pbi->frame_mmu_map_addr,
 					print_header_info);
+				if (ret) {
+					return -1;
+				}
 				for (i = 0; i < REFS_PER_FRAME; ++i) {
 					/*struct RefBuffer_s *const ref_buf =
 					&cm->frame_refs[i];*/
@@ -1375,40 +1657,7 @@ int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
 	if (pbi->need_resync)
 		pr_err
 		("Error: Keyframe/intra-only frame required to reset\r\n");
-	/* Generate next_ref_frame_map.*/
-	lock_buffer_pool(pool);
-	for (mask = pbi->refresh_frame_flags; mask; mask >>= 1) {
-		if (mask & 1) {
-			cm->next_ref_frame_map[ref_index] = cm->new_fb_idx;
-			++frame_bufs[cm->new_fb_idx].ref_count;
-			/*pr_info("[MMU DEBUG 4] inc ref_count[%d] : %d\r\n",
-			cm->new_fb_idx, frame_bufs[cm->new_fb_idx].ref_count);*/
-		} else
-			cm->next_ref_frame_map[ref_index] =
-				cm->ref_frame_map[ref_index];
-		/* Current thread holds the reference frame.*/
-		if (cm->ref_frame_map[ref_index] >= 0) {
-			++frame_bufs[cm->ref_frame_map[ref_index]].ref_count;
-			/*pr_info
-			("[MMU DEBUG 5] inc ref_count[%d] : %d\r\n",
-			cm->ref_frame_map[ref_index],
-			frame_bufs[cm->ref_frame_map[ref_index]].ref_count);*/
-		}
-		++ref_index;
-	}
-
-	for (; ref_index < REF_FRAMES; ++ref_index) {
-		cm->next_ref_frame_map[ref_index] =
-			cm->ref_frame_map[ref_index];
-		/* Current thread holds the reference frame.*/
-		if (cm->ref_frame_map[ref_index] >= 0) {
-			++frame_bufs[cm->ref_frame_map[ref_index]].ref_count;
-			/*pr_info("[MMU DEBUG 6] inc ref_count[%d] : %d\r\n",
-			cm->ref_frame_map[ref_index],
-			frame_bufs[cm->ref_frame_map[ref_index]].ref_count);*/
-		}
-	}
-	unlock_buffer_pool(pool);
+	generate_next_ref_frames(pbi);
 	pbi->hold_ref_buf = 1;
 
 #if 0
@@ -1445,59 +1694,14 @@ int vp9_bufmgr_process(struct VP9Decoder_s *pbi, union param_u *params)
 	return 0;
 }
 
-static void decrease_ref_count(int idx, struct RefCntBuffer_s *const frame_bufs,
-					struct BufferPool_s *const pool)
-{
-	if (idx >= 0) {
-		--frame_bufs[idx].ref_count;
-		/*pr_info("[MMU DEBUG 7] dec ref_count[%d] : %d\r\n", idx,
-			frame_bufs[idx].ref_count);*/
-		/*A worker may only get a free framebuffer index when
-		calling get_free_fb. But the private buffer is not set up
-		until finish decoding header. So any error happens during
-		decoding header, the frame_bufs will not have valid priv
-		buffer.*/
-#ifdef VP9_10B_MMU
-		if (frame_bufs[idx].ref_count == 0)
-			release_buffer_4k(idx);
-#endif
-		if (frame_bufs[idx].ref_count == 0 &&
-			frame_bufs[idx].raw_frame_buffer.priv)
-			vp9_release_frame_buffer
-			(&frame_bufs[idx].raw_frame_buffer);
-	}
-}
 
 void swap_frame_buffers(struct VP9Decoder_s *pbi)
 {
-	int ref_index = 0, mask;
+	int ref_index = 0;
 	struct VP9_Common_s *const cm = &pbi->common;
 	struct BufferPool_s *const pool = cm->buffer_pool;
 	struct RefCntBuffer_s *const frame_bufs = cm->buffer_pool->frame_bufs;
-
-	lock_buffer_pool(pool);
-	for (mask = pbi->refresh_frame_flags; mask; mask >>= 1) {
-		const int old_idx = cm->ref_frame_map[ref_index];
-		/*Current thread releases the holding of reference frame.*/
-		decrease_ref_count(old_idx, frame_bufs, pool);
-
-		/*Release the reference frame in reference map.*/
-		if ((mask & 1) && old_idx >= 0)
-			decrease_ref_count(old_idx, frame_bufs, pool);
-		cm->ref_frame_map[ref_index] =
-			cm->next_ref_frame_map[ref_index];
-		++ref_index;
-	}
-
-	/*Current thread releases the holding of reference frame.*/
-	for (; ref_index < REF_FRAMES && !cm->show_existing_frame;
-		++ref_index) {
-		const int old_idx = cm->ref_frame_map[ref_index];
-		decrease_ref_count(old_idx, frame_bufs, pool);
-		cm->ref_frame_map[ref_index] =
-			cm->next_ref_frame_map[ref_index];
-	}
-	unlock_buffer_pool(pool);
+	refresh_ref_frames(pbi);
 	pbi->hold_ref_buf = 0;
 	cm->frame_to_show = get_frame_new_buffer(cm);
 
@@ -1556,6 +1760,7 @@ int vp9_bufmgr_init(struct VP9Decoder_s *pbi, struct BuffInfo_s *buf_spec_i,
 	pbi->pic_count = 0;
 	pbi->pre_stream_offset = 0;
 	cm->buffer_pool = &pbi->vp9_buffer_pool;
+	spin_lock_init(&cm->buffer_pool->lock);
 	cm->prev_fb_idx = INVALID_IDX;
 	cm->new_fb_idx = INVALID_IDX;
 	pr_info
@@ -1667,6 +1872,7 @@ const u32 vp9_version = 201602101;
 static u32 debug;
 static u32 radr;
 static u32 rval;
+static u32 pop_shorts;
 static u32 dbg_cmd;
 static u32 dbg_skip_decode_index;
 static u32 endian = 0xff0;
@@ -1759,9 +1965,9 @@ static u32 max_buf_num = 12;
 
 
 static DEFINE_MUTEX(vvp9_mutex);
-
+#ifndef MULTI_INSTANCE_SUPPORT
 static struct device *cma_dev;
-
+#endif
 
 #define HEVC_DEC_STATUS_REG       HEVC_ASSIST_SCRATCH_0
 #define HEVC_RPM_BUFFER           HEVC_ASSIST_SCRATCH_1
@@ -1780,9 +1986,13 @@ static struct device *cma_dev;
 #define RPM_CMD_REG               HEVC_ASSIST_SCRATCH_F
 #define LMEM_DUMP_ADR                 HEVC_ASSIST_SCRATCH_F
 #define HEVC_STREAM_SWAP_TEST     HEVC_ASSIST_SCRATCH_L
+#ifdef MULTI_INSTANCE_SUPPORT
+#define HEVC_DECODE_COUNT       HEVC_ASSIST_SCRATCH_M
+#define HEVC_DECODE_SIZE		HEVC_ASSIST_SCRATCH_N
+#else
 #define HEVC_DECODE_PIC_BEGIN_REG HEVC_ASSIST_SCRATCH_M
 #define HEVC_DECODE_PIC_NUM_REG   HEVC_ASSIST_SCRATCH_N
-
+#endif
 #define DEBUG_REG1              HEVC_ASSIST_SCRATCH_G
 #define DEBUG_REG2              HEVC_ASSIST_SCRATCH_H
 
@@ -1806,10 +2016,14 @@ bit [17]: for NAL_SEI when bit0 is 0:
 bit [31:20]: used by ucode for debug purpose
 */
 #define NAL_SEARCH_CTL            HEVC_ASSIST_SCRATCH_I
-#define CUR_NAL_UNIT_TYPE       HEVC_ASSIST_SCRATCH_J
+#define DECODE_MODE              HEVC_ASSIST_SCRATCH_J
 #define DECODE_STOP_POS         HEVC_ASSIST_SCRATCH_K
 
+#ifdef MULTI_INSTANCE_SUPPORT
+#define RPM_BUF_SIZE (0x400 * 2)
+#else
 #define RPM_BUF_SIZE (0x80*2)
+#endif
 #define LMEM_BUF_SIZE (0x400 * 2)
 
 #define WORK_BUF_SPEC_NUM 2
@@ -1885,7 +2099,9 @@ static struct BuffInfo_s amvvp9_workbuff_spec[WORK_BUF_SPEC_NUM] = {
 			.buf_size = 0x5000, /*2*16*(more than 2304)/4, 4K*/
 		},
 		.cm_header = {
-			.buf_size = MMU_COMPRESS_HEADER_SIZE*8,
+			/*add one for keeper.*/
+			.buf_size = MMU_COMPRESS_HEADER_SIZE *
+						(FRAME_BUFFERS + 1),
 			/* 0x44000 = ((1088*2*1024*4)/32/4)*(32/8) */
 		},
 #endif
@@ -1972,7 +2188,9 @@ static struct BuffInfo_s amvvp9_workbuff_spec[WORK_BUF_SPEC_NUM] = {
 			.buf_size = 0x5000,/*2*16*(more than 2304)/4, 4K*/
 		},
 		.cm_header = {
-			.buf_size = MMU_COMPRESS_HEADER_SIZE*8,
+			/*add one for keeper.*/
+			.buf_size = MMU_COMPRESS_HEADER_SIZE *
+						(FRAME_BUFFERS + 1),
 			/* 0x44000 = ((1088*2*1024*4)/32/4)*(32/8) */
 		},
 #endif
@@ -2039,8 +2257,10 @@ static  int  compute_losless_comp_header_size(int width, int height)
 	return  hsize;
 }
 
-static void init_buff_spec(struct BuffInfo_s *buf_spec)
+static void init_buff_spec(struct VP9Decoder_s *pbi,
+	struct BuffInfo_s *buf_spec)
 {
+	void *mem_start_virt;
 	buf_spec->ipp.buf_start = buf_spec->start_adr;
 	buf_spec->sao_abv.buf_start =
 		buf_spec->ipp.buf_start + buf_spec->ipp.buf_size;
@@ -2105,7 +2325,17 @@ static void init_buff_spec(struct BuffInfo_s *buf_spec)
 				buf_spec->rpm.buf_size;
 		}
 	}
-
+	mem_start_virt = codec_mm_phys_to_virt(buf_spec->dblk_para.buf_start);
+	if (mem_start_virt) {
+		memset(mem_start_virt, 0, buf_spec->dblk_para.buf_size);
+		codec_mm_dma_flush(mem_start_virt,
+			buf_spec->dblk_para.buf_size,
+			DMA_TO_DEVICE);
+	} else {
+		/*not virt for tvp playing,
+		may need clear on ucode.*/
+		pr_err("mem_start_virt failed\n");
+	}
 	if (debug) {
 		pr_info("%s workspace (%x %x) size = %x\n", __func__,
 			   buf_spec->start_adr, buf_spec->end_adr,
@@ -3111,130 +3341,25 @@ if (cur_kf == 0) {
 }
 
 
-
-/*USE_BUF_BLOCK*/
-static void uninit_buf_list(struct VP9Decoder_s *pbi)
+static void uninit_mmu_buffers(struct VP9Decoder_s *pbi)
 {
-	int i;
-	struct VP9_Common_s *cm = &pbi->common;
-	uint8_t release_cma_flag = 0;
-	uint8_t blackout = get_blackout_policy();
-	u32 buffer_mode_real =
-		(buffer_mode & ((buffer_mode_dbg >> 16) & 0xfff)) |
-		(buffer_mode_dbg & 0xfff);
-	blackout &= ((buffer_mode_dbg >> 28) & 0xf);
-	blackout |=  ((buffer_mode_dbg >> 12) & 0xf);
-
-	pbi->predisp_addr = 0;
-
-	if (buffer_mode_real & 1) {
-		if (blackout == 1)
-			release_cma_flag = 1;
-	} else {
-		if (buffer_mode_real & 2)
-			;
-		else
-			release_cma_flag = 1;
-	}
 
-	if (blackout != 1) {
-		struct PIC_BUFFER_CONFIG_s *pic_config;
-		if ((release_cma_flag == 1) &&
-				(buffer_mode_real & 8)) {
-			release_cma_flag = 2;
-		}
+	decoder_mmu_box_free(pbi->mmu_box);
+	pbi->mmu_box = NULL;
 
-		msleep(50); /* ensure RDMA for display is done */
-		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB &&
-			double_write_mode == 0) {
-			pbi->predisp_addr =
-			READ_VCBUS_REG(AFBC_BODY_BADDR) << 4;
-		} else {
-			struct canvas_s cur_canvas;
-			canvas_read((READ_VCBUS_REG(VD1_IF0_CANVAS0) & 0xff),
-				 &cur_canvas);
-			pbi->predisp_addr = cur_canvas.addr;
-		}
-
-		for (i = 0; i < FRAME_BUFFERS; i++) {
-			pic_config = &cm->buffer_pool->frame_bufs[i].buf;
-			if (pic_config->index == -1)
-				continue;
-			if (pbi->predisp_addr == pic_config->mc_y_adr) {
-				pbi->predisp_size = pic_config->buf_size;
-				pr_info("%s, set  pbi->predisp_size = %d\n",
-					__func__, pic_config->buf_size);
-				break;
-			}
-		}
-	}
-
-	if (pbi->pre_last_frame_alloc_addr) {
-		if (blackout == 1 || pbi->predisp_addr == 0
-			|| pbi->predisp_addr < pbi->pre_last_frame_alloc_addr
-			|| pbi->predisp_addr >=
-			(pbi->pre_last_frame_alloc_addr
-				+ pbi->pre_last_frame_alloc_size)
-			) {
-			codec_mm_free_for_dma(MEM_NAME,
-				pbi->pre_last_frame_alloc_addr);
-			pr_info("release pre_last_frame cma buffer %ld\n",
-				pbi->pre_last_frame_alloc_addr);
-			pbi->pre_last_frame_alloc_addr = 0;
-			pbi->pre_last_frame_alloc_size = 0;
-		}
-	}
-
-	if (release_cma_flag) {
-		for (i = 0; i < pbi->used_buf_num; i++) {
-			if (pbi->m_BUF[i].alloc_addr != 0
-				&& pbi->m_BUF[i].cma_page_count > 0) {
-				if ((release_cma_flag == 2)
-					&& (pbi->predisp_addr >=
-						pbi->m_BUF[i].start_adr)
-					&& (pbi->predisp_addr <
-					(pbi->m_BUF[i].start_adr +
-						pbi->m_BUF[i].size))) {
-					if (pbi->pre_last_frame_alloc_addr)
-						pr_info("last buf not free\n");
-					else {
-						pbi->pre_last_frame_alloc_addr
-						=
-						pbi->m_BUF[i].alloc_addr;
-						pbi->pre_last_frame_alloc_size
-						    = pbi->m_BUF[i].size;
-						pbi->m_BUF[i].alloc_addr = 0;
-						pbi->m_BUF[i].
-						cma_page_count = 0;
-						continue;
-					}
-				}
-
-				pr_info("release cma buffer[%d] (%d %ld)\n", i,
-					pbi->m_BUF[i].cma_page_count,
-					pbi->m_BUF[i].alloc_addr);
-				codec_mm_free_for_dma(MEM_NAME,
-					pbi->m_BUF[i].alloc_addr);
-				pbi->m_BUF[i].alloc_addr = 0;
-				pbi->m_BUF[i].cma_page_count = 0;
-
-			}
-		}
-	}
-	pr_info("%s, blackout %x r%x buf_mode %x r%x rel_cma_flag %x pbi->predisp_addr %d pre_alloc_addr(%ld, %ld)\n",
-		__func__, get_blackout_policy(), blackout,
-		buffer_mode, buffer_mode_real, release_cma_flag,
-		pbi->predisp_addr, pbi->pre_last_frame_alloc_addr,
-		pbi->pre_last_frame_alloc_size);
-	pbi->buf_num = 0;
+	if (pbi->bmmu_box)
+		decoder_bmmu_box_free(pbi->bmmu_box);
+	pbi->bmmu_box = NULL;
 }
 
+#ifndef VP9_10B_MMU
 static void init_buf_list(struct VP9Decoder_s *pbi)
 {
 	int i;
 	int buf_size;
+#ifndef VP9_10B_MMU
 	int mc_buffer_end = pbi->mc_buf->buf_start + pbi->mc_buf->buf_size;
-
+#endif
 	pbi->used_buf_num = max_buf_num;
 
 	if (pbi->used_buf_num > MAX_BUF_NUM)
@@ -3282,8 +3407,7 @@ static void init_buf_list(struct VP9Decoder_s *pbi)
 	}
 	if ((double_write_mode & 0x10) == 0)
 		buf_size += (mc_buffer_size_h << 16);
-
-	if (debug) {
+		if (debug) {
 			pr_info
 			("init_buf_list num %d (width %d height %d):\n",
 			 pbi->used_buf_num, pic_width, pic_height);
@@ -3302,74 +3426,35 @@ static void init_buf_list(struct VP9Decoder_s *pbi)
 				break;
 			}
 		}
+#ifndef VP9_10B_MMU
 		pbi->m_BUF[i].alloc_flag = 0;
 		pbi->m_BUF[i].index = i;
 
 		if (use_cma == 2)
 			pbi->use_cma_flag = 1;
 		if (pbi->use_cma_flag) {
-			if ((pbi->m_BUF[i].cma_page_count != 0)
-				&& (pbi->m_BUF[i].alloc_addr != 0)
-				&& (pbi->m_BUF[i].size != buf_size)) {
-				if ((pbi->predisp_addr >=
-						pbi->m_BUF[i].alloc_addr)
-					&& (pbi->predisp_addr <
-					(pbi->m_BUF[i].alloc_addr +
-						pbi->m_BUF[i].size))) {
-					pbi->pre_last_frame_alloc_addr =
-						pbi->m_BUF[i].alloc_addr;
-					pbi->pre_last_frame_alloc_size =
-						pbi->m_BUF[i].size;
-				} else {
-					codec_mm_free_for_dma(MEM_NAME,
-						pbi->m_BUF[i].alloc_addr);
-					pr_info("release cma buffer[%d] (%d %ld)\n",
-					i, pbi->m_BUF[i].cma_page_count,
-						pbi->m_BUF[i].alloc_addr);
-				}
-				pbi->m_BUF[i].alloc_addr = 0;
-				pbi->m_BUF[i].cma_page_count = 0;
-			}
-			if (pbi->m_BUF[i].alloc_addr == 0) {
-				if (!codec_mm_enough_for_size(buf_size)) {
-					/*
-					not enough mem for buffer.
-					*/
-					pr_info("not enought buffer for [%d],%d\n",
-						i, buf_size);
-					pbi->m_BUF[i].cma_page_count = 0;
-					if (i <= 8) {
-						/*if alloced (i+1)>=9
-						don't send errors.*/
-						/*pbi->fatal_error |=
-						DECODER_FATAL_ERROR_NO_MEM;*/
-					}
-					break;
-				}
+			if (!decoder_bmmu_box_alloc_idx_wait(
+					pbi->bmmu_box,
+					i,
+					buf_size,
+					-1,
+					-1,
+					BMMU_ALLOC_FLAGS_WAITCLEAR)) {
+				pbi->m_BUF[i].alloc_addr =
+					decoder_bmmu_box_get_phy_addr(
+						pbi->bmmu_box,
+						i);
 				pbi->m_BUF[i].cma_page_count =
 					PAGE_ALIGN(buf_size) / PAGE_SIZE;
-				pbi->m_BUF[i].alloc_addr =
-				    codec_mm_alloc_for_dma(
-					MEM_NAME, pbi->m_BUF[i].cma_page_count,
-					4 + PAGE_SHIFT,
-					CODEC_MM_FLAGS_FOR_VDECODER);
-				if (pbi->m_BUF[i].alloc_addr == 0) {
-					pr_info("alloc cma buffer[%d] fail\n",
-					i);
-					pbi->m_BUF[i].cma_page_count = 0;
-					break;
-				}
-				pr_info("allocate cma buffer[%d] (%d,%ld,%ld)\n",
-						i,
-						pbi->m_BUF[i].cma_page_count,
-						pbi->m_BUF[i].alloc_addr,
-						pbi->m_BUF[i].start_adr);
+				pr_info("CMA malloc ok  %d\n", i);
 			} else {
-				pr_info("reuse cma buffer[%d] (%d,%ld,%ld)\n",
-						i,
-						pbi->m_BUF[i].cma_page_count,
-						pbi->m_BUF[i].alloc_addr,
-						pbi->m_BUF[i].start_adr);
+				pbi->m_BUF[i].cma_page_count = 0;
+				pr_info("CMA malloc failed  %d\n", i);
+				if (i <= 5) {
+					pbi->fatal_error |=
+					DECODER_FATAL_ERROR_NO_MEM;
+				}
+				break;
 			}
 			pbi->m_BUF[i].start_adr =  pbi->m_BUF[i].alloc_addr;
 		} else {
@@ -3395,14 +3480,14 @@ static void init_buf_list(struct VP9Decoder_s *pbi)
 				   (void *)pbi->m_BUF[i].start_adr,
 				   pbi->m_BUF[i].size);
 		}
+#endif
 	}
-
 	pbi->buf_num = i;
-
 }
-
+#endif
 static int config_pic(struct VP9Decoder_s *pbi,
-				struct PIC_BUFFER_CONFIG_s *pic_config)
+				struct PIC_BUFFER_CONFIG_s *pic_config,
+				unsigned long last_disp_addr)
 {
 	int ret = -1;
 	int i;
@@ -3420,9 +3505,9 @@ static int config_pic(struct VP9Decoder_s *pbi,
 				: pic_height_32 / lcu_size;
 	int lcu_total       = pic_width_lcu * pic_height_lcu;
 
-	int mpred_mv_end = pbi->work_space_buf->mpred_mv.buf_start +
+	u32 mpred_mv_end = pbi->work_space_buf->mpred_mv.buf_start +
 			pbi->work_space_buf->mpred_mv.buf_size;
-	int y_adr = 0;
+	u32 y_adr = 0;
 	int buf_size = 0;
 
 	int losless_comp_header_size =
@@ -3453,14 +3538,18 @@ static int config_pic(struct VP9Decoder_s *pbi,
 		mc_buffer_size_u_v_h = (mc_buffer_size_u_v + 0xffff) >> 16;
 		/*64k alignment*/
 		buf_size = ((mc_buffer_size_u_v_h << 16) * 3);
+		buf_size = ((buf_size + 0xffff) >> 16) << 16;
 	}
 	if (mc_buffer_size & 0xffff) /*64k alignment*/
 		mc_buffer_size_h += 1;
+#ifndef VP9_10B_MMU
 	if ((double_write_mode & 0x10) == 0)
 		buf_size += (mc_buffer_size_h << 16);
+#endif
 
 #ifdef VP9_10B_MMU
-	if ((pbi->work_space_buf->cm_header.buf_start + ((pic_config->index + 1)
+	if ((pbi->work_space_buf->cm_header.buf_start +
+		((pic_config->index + 2)
 		* MMU_COMPRESS_HEADER_SIZE))
 		> (pbi->work_space_buf->cm_header.buf_start +
 		pbi->work_space_buf->cm_header.buf_size)) {
@@ -3470,15 +3559,34 @@ static int config_pic(struct VP9Decoder_s *pbi,
 
 	pic_config->header_adr = pbi->work_space_buf->cm_header.buf_start
 		+ (pic_config->index * MMU_COMPRESS_HEADER_SIZE);
+	if (last_disp_addr && pic_config->header_adr == last_disp_addr) {
+		/*if same as disp add used last one.*/
+		pr_info("same as disp %d: %ld\n",
+			pic_config->index, pic_config->header_adr);
+		pic_config->header_adr =
+			pbi->work_space_buf->cm_header.buf_start +
+			(FRAME_BUFFERS * MMU_COMPRESS_HEADER_SIZE);
+	}
 	if (debug & VP9_DEBUG_BUFMGR) {
 		pr_info("MMU header_adr %d: %ld\n",
 			pic_config->index, pic_config->header_adr);
 	}
 #endif
 
+	i = pic_config->index;
 	if ((pbi->work_space_buf->mpred_mv.buf_start +
-		(((pic_config->index + 1) * lcu_total) * MV_MEM_UNIT))
-		<= mpred_mv_end) {
+		(((i + 1) * lcu_total) * MV_MEM_UNIT))
+		<= mpred_mv_end
+#ifdef VP9_10B_MMU
+#endif
+	) {
+		if (debug) {
+			pr_err("start %x  .size=%d\n",
+				pbi->mc_buf_spec.buf_start + i * buf_size,
+				buf_size);
+		}
+
+#ifndef VP9_10B_MMU
 		for (i = 0; i < pbi->buf_num; i++) {
 			y_adr = ((pbi->m_BUF[i].free_start_adr
 				+ 0xffff) >> 16) << 16;
@@ -3490,7 +3598,34 @@ static int config_pic(struct VP9Decoder_s *pbi,
 				break;
 			}
 		}
-		if (i < pbi->buf_num) {
+		if (i < pbi->buf_num)
+#else
+		if ((pbi->mc_buf->buf_start + (i + 1) * buf_size) <
+			pbi->mc_buf->buf_end)
+			y_adr = pbi->mc_buf->buf_start + i * buf_size;
+		else {
+			if (!decoder_bmmu_box_alloc_idx_wait(
+					pbi->bmmu_box,
+					i,
+					buf_size,
+					-1,
+					-1,
+					BMMU_ALLOC_FLAGS_WAITCLEAR
+					)) {
+				pic_config->cma_alloc_addr =
+					decoder_bmmu_box_get_phy_addr(
+						pbi->bmmu_box,
+						i);
+			} else {
+				pr_err("alloc cma buffer failed %d\n", i);
+			}
+			if (pic_config->cma_alloc_addr)
+				y_adr = pic_config->cma_alloc_addr;
+			else
+				return -1;
+		}
+#endif
+		{
 			/*ensure get_pic_by_POC()
 			not get the buffer not decoded*/
 			pic_config->BUF_index = i;
@@ -3498,10 +3633,12 @@ static int config_pic(struct VP9Decoder_s *pbi,
 
 			pic_config->comp_body_size = losless_comp_body_size;
 			pic_config->buf_size = buf_size;
+#ifndef VP9_10B_MMU
 			pic_config->mc_y_adr = y_adr;
-
+#endif
 			pic_config->mc_canvas_y = pic_config->index;
 			pic_config->mc_canvas_u_v = pic_config->index;
+#ifndef VP9_10B_MMU
 			if (double_write_mode & 0x10) {
 				pic_config->mc_u_v_adr = y_adr +
 				((mc_buffer_size_u_v_h << 16) << 1);
@@ -3513,9 +3650,14 @@ static int config_pic(struct VP9Decoder_s *pbi,
 
 				pic_config->dw_y_adr = y_adr;
 				pic_config->dw_u_v_adr = pic_config->mc_u_v_adr;
-			} else if (double_write_mode) {
-				pic_config->dw_y_adr = y_adr +
-					(mc_buffer_size_h << 16);
+			} else
+#endif
+			if (double_write_mode) {
+				pic_config->dw_y_adr = y_adr
+#ifndef VP9_10B_MMU
+				+ (mc_buffer_size_h << 16)
+#endif
+				;
 				pic_config->dw_u_v_adr = pic_config->dw_y_adr +
 					((mc_buffer_size_u_v_h << 16) << 1);
 			}
@@ -3525,25 +3667,6 @@ static int config_pic(struct VP9Decoder_s *pbi,
 					((pic_config->index * lcu_total)
 					* MV_MEM_UNIT);
 
-			if ((pbi->predisp_addr != 0) &&
-				(pbi->predisp_size != 0) &&
-				(buffer_mode & 0x4) == 0) {
-				if ((pic_config->mc_y_adr >=
-					(pbi->predisp_addr +
-					pbi->predisp_size)) ||
-					((pic_config->mc_y_adr
-					+ pic_config->buf_size)
-					<= pbi->predisp_addr)) {
-					pic_config->used_by_display = 0;
-				} else {
-					pic_config->used_by_display = 1;
-					pr_info
-					("%s,pic_config%d is displayed\n",
-						__func__, i);
-				}
-			} else
-				pic_config->used_by_display = 0;
-
 			if (debug) {
 				pr_info
 				("%s index %d BUF_index %d mc_y_adr %lx ",
@@ -3557,6 +3680,9 @@ static int config_pic(struct VP9Decoder_s *pbi,
 				pr_info
 				("mpred_mv_wr_start_adr %ld\n",
 				pic_config->mpred_mv_wr_start_addr);
+				pr_info("dw_y_adr %d, pic_config->dw_u_v_adr =%d\n",
+					pic_config->dw_y_adr,
+					pic_config->dw_u_v_adr);
 			}
 			ret = 0;
 		}
@@ -3569,12 +3695,26 @@ static void init_pic_list(struct VP9Decoder_s *pbi)
 	int i;
 	struct VP9_Common_s *cm = &pbi->common;
 	struct PIC_BUFFER_CONFIG_s *pic_config;
-
+	struct vframe_s vf;
+	unsigned long disp_addr = 0;
+	if (!get_video0_frame_info(&vf)) {
+		if (vf.type & VIDTYPE_SCATTER) {
+			/*sc only used header.*/
+			disp_addr = vf.compHeadAddr;
+		} else if (vf.type & VIDTYPE_COMPRESS) {
+			/*sc checked body.*/
+			disp_addr = vf.compBodyAddr;
+		} else {
+			struct canvas_s cur_canvas;
+			canvas_read(vf.canvas0Addr & 0xff, &cur_canvas);
+			disp_addr = cur_canvas.addr;
+		}
+	}
 	for (i = 0; i < FRAME_BUFFERS; i++) {
 		pic_config = &cm->buffer_pool->frame_bufs[i].buf;
 		pic_config->index = i;
 		pic_config->BUF_index = -1;
-		if (config_pic(pbi, pic_config) < 0) {
+		if (config_pic(pbi, pic_config, disp_addr) < 0) {
 			if (debug)
 				pr_info("Config_pic %d fail\n",
 					pic_config->index);
@@ -3827,10 +3967,10 @@ static void config_sao_hw(struct VP9Decoder_s *pbi, union param_u *params)
 	int mc_buffer_size_u_v_h =
 		(mc_buffer_size_u_v + 0xffff) >> 16;/*64k alignment*/
 
-
+#ifndef VP9_10B_MMU
 	if ((double_write_mode & 0x10) == 0)
 		WRITE_VREG(HEVC_CM_BODY_START_ADDR, pic_config->mc_y_adr);
-
+#endif
 	if (double_write_mode) {
 		WRITE_VREG(HEVC_SAO_Y_START_ADDR, pic_config->dw_y_adr);
 		WRITE_VREG(HEVC_SAO_C_START_ADDR, pic_config->dw_u_v_adr);
@@ -3910,8 +4050,11 @@ static void config_sao_hw(struct VP9Decoder_s *pbi, union param_u *params)
 	data32 &= (~0x3); /*[1]:dw_disable [0]:cm_disable*/
 	if (double_write_mode == 0)
 		data32 |= 0x2; /*disable double write*/
-	else if (double_write_mode & 0x10)
+#ifndef VP9_10B_MMU
+	else
+	if (double_write_mode & 0x10)
 		data32 |= 0x1; /*disable cm*/
+#endif
 	WRITE_VREG(HEVC_SAO_CTRL1, data32);
 
 	if (double_write_mode & 0x10) {
@@ -4173,14 +4316,19 @@ struct segmentation *seg_4lf;
 void vp9_loop_filter_init(void)
 {
 	int i;
-	lfi = kmalloc(sizeof(struct loop_filter_info_n), GFP_KERNEL);
-	lf = kmalloc(sizeof(struct loopfilter), GFP_KERNEL);
-	seg_4lf = kmalloc(sizeof(struct segmentation), GFP_KERNEL);
+	if (!lfi)
+		lfi = kmalloc(sizeof(struct loop_filter_info_n), GFP_KERNEL);
+	if (!lf)
+		lf = kmalloc(sizeof(struct loopfilter), GFP_KERNEL);
+	if (!seg_4lf)
+		seg_4lf = kmalloc(sizeof(struct segmentation), GFP_KERNEL);
 	if (lfi == NULL || lf == NULL || seg_4lf == NULL) {
 		pr_err("[test.c] vp9_loop_filter init malloc error!!!\n");
 		return;
 	}
-
+	memset(lfi, 0, sizeof(struct loop_filter_info_n));
+	memset(lf, 0, sizeof(struct loopfilter));
+	memset(seg_4lf, 0, sizeof(struct segmentation));
 	lf->sharpness_level = 0; /*init to 0 */
 	/*init limits for given sharpness*/
 	vp9_update_sharpness(lfi, lf->sharpness_level);
@@ -4307,13 +4455,11 @@ void vp9_loop_filter_frame_init(struct segmentation *seg,
 /* VP9_LPF_LVL_UPDATE */
 #endif
 
-static void vp9_init_decoder_hw(void)
+static void vp9_init_decoder_hw(struct VP9Decoder_s *pbi)
 {
 	unsigned int data32;
 	int i;
 
-	pr_info("[test.c] Entering vp9_init_decoder_hw\n");
-
 	if (debug & VP9_DEBUG_BUFMGR)
 		pr_info("[test.c] Enable HEVC Parser Interrupt\n");
 		data32 = READ_VREG(HEVC_PARSER_INT_CONTROL);
@@ -4377,10 +4523,18 @@ static void vp9_init_decoder_hw(void)
 #else
 	WRITE_VREG(HEVC_STREAM_SWAP_TEST, 0);
 #endif
-
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (pbi->platform_dev && vdec_frame_based(hw_to_vdec(pbi)))
+		WRITE_VREG(DECODE_MODE, DECODE_MODE_MULTI_FRAMEBASE);
+	else
+		WRITE_VREG(DECODE_MODE, DECODE_MODE_MULTI_STREAMBASE);
+	WRITE_VREG(HEVC_DECODE_SIZE, 0);
+	WRITE_VREG(HEVC_DECODE_COUNT, 0);
+#else
+	WRITE_VREG(DECODE_MODE, DECODE_MODE_SINGLE);
 	WRITE_VREG(HEVC_DECODE_PIC_BEGIN_REG, 0);
 	WRITE_VREG(HEVC_DECODE_PIC_NUM_REG, 0x7fffffff); /*to remove*/
-
+#endif
 	/*Send parser_cmd*/
 	if (debug)
 		pr_info("[test.c] SEND Parser Command ...\n");
@@ -4423,7 +4577,6 @@ static void vp9_init_decoder_hw(void)
 	/*Initialize mcrcc and decomp perf counters
 	mcrcc_perfcount_reset();
 	decomp_perfcount_reset();*/
-	pr_info("[test.c] Leaving vp9_init_decoder_hw\n");
 	return;
 }
 
@@ -4520,7 +4673,6 @@ static void vp9_local_uninit(struct VP9Decoder_s *pbi)
 {
 	pbi->rpm_ptr = NULL;
 	pbi->lmem_ptr = NULL;
-
 	if (pbi->rpm_addr) {
 		dma_unmap_single(amports_get_dma_device(),
 			pbi->rpm_phy_addr, RPM_BUF_SIZE,
@@ -4558,6 +4710,15 @@ static void vp9_local_uninit(struct VP9Decoder_s *pbi)
 			pbi->frame_mmu_map_addr = NULL;
 	}
 #endif
+
+#ifdef VP9_LPF_LVL_UPDATE
+	kfree(lfi);
+	lfi = NULL;
+	kfree(lf);
+	lf = NULL;
+	kfree(seg_4lf);
+	seg_4lf = NULL;
+#endif
 }
 
 static int vp9_local_init(struct VP9Decoder_s *pbi)
@@ -4567,23 +4728,38 @@ static int vp9_local_init(struct VP9Decoder_s *pbi)
 
 	struct BuffInfo_s *cur_buf_info = NULL;
 	memset(&pbi->param, 0, sizeof(union param_u));
-
+	memset(&pbi->common, 0, sizeof(struct VP9_Common_s));
+#ifdef MULTI_INSTANCE_SUPPORT
+	cur_buf_info = &pbi->work_space_buf_store;
 #ifdef SUPPORT_4K2K
-	cur_buf_info = &amvvp9_workbuff_spec[1];/* 4k2k work space */
+	memcpy(cur_buf_info, &amvvp9_workbuff_spec[1],	/* 4k2k work space */
+		sizeof(struct BuffInfo_s));
 #else
-	cur_buf_info = &amvvp9_workbuff_spec[0];/* 1080p work space */
+	memcpy(cur_buf_info, &amvvp9_workbuff_spec[0],	/* 1080p work space */
+		sizeof(struct BuffInfo_s));
+#endif
+	cur_buf_info->start_adr = pbi->buf_start;
+	pbi->mc_buf_spec.buf_end = pbi->buf_start + pbi->buf_size;
+#else
+/*! MULTI_INSTANCE_SUPPORT*/
+#ifdef SUPPORT_4K2K
+	cur_buf_info = &amvvp9_workbuff_spec[1];	/* 4k2k work space */
+#else
+	cur_buf_info = &amvvp9_workbuff_spec[0];	/* 1080p work space */
 #endif
-
-	init_buff_spec(cur_buf_info);
-#ifdef VP9_10B_MMU
-	init_mmu_spec();
 #endif
 
+	init_buff_spec(pbi, cur_buf_info);
 	pbi->mc_buf_spec.buf_start = (cur_buf_info->end_adr + 0xffff)
 	    & (~0xffff);
 	pbi->mc_buf_spec.buf_size = (pbi->mc_buf_spec.buf_end
 	    - pbi->mc_buf_spec.buf_start);
-
+	if (debug) {
+		pr_err("pbi->mc_buf_spec.buf_start %x-%x\n",
+			pbi->mc_buf_spec.buf_start,
+			pbi->mc_buf_spec.buf_start +
+			pbi->mc_buf_spec.buf_size);
+	}
 	vp9_bufmgr_init(pbi, cur_buf_info, &pbi->mc_buf_spec);
 
 	pbi->init_pic_w = buf_alloc_width ? buf_alloc_width :
@@ -4594,7 +4770,9 @@ static int vp9_local_init(struct VP9Decoder_s *pbi)
 		(pbi->vvp9_amstream_dec_info.height ?
 		pbi->vvp9_amstream_dec_info.height :
 		pbi->work_space_buf->max_height);
+#ifndef VP9_10B_MMU
 	init_buf_list(pbi);
+#endif
 	init_pic_list(pbi);
 
 	pts_unstable = ((unsigned long)(pbi->vvp9_amstream_dec_info.param)
@@ -4651,6 +4829,7 @@ static int vp9_local_init(struct VP9Decoder_s *pbi)
 		pr_err("%s: failed to alloc prob_buffer\n", __func__);
 		return -1;
 	}
+	memset(pbi->prob_buffer_addr, 0, PROB_BUF_SIZE);
 /*	pbi->prob_buffer_phy_addr = dma_map_single(amports_get_dma_device(),
 	pbi->prob_buffer_addr, PROB_BUF_SIZE, DMA_BIDIRECTIONAL);
 	if (dma_mapping_error(amports_get_dma_device(),
@@ -4668,6 +4847,7 @@ static int vp9_local_init(struct VP9Decoder_s *pbi)
 		pr_err("%s: failed to alloc count_buffer\n", __func__);
 		return -1;
 	}
+	memset(pbi->count_buffer_addr, 0, COUNT_BUF_SIZE);
 /*	pbi->count_buffer_phy_addr = dma_map_single(amports_get_dma_device(),
 	pbi->count_buffer_addr, COUNT_BUF_SIZE, DMA_BIDIRECTIONAL);
 	if (dma_mapping_error(amports_get_dma_device(),
@@ -4686,6 +4866,7 @@ static int vp9_local_init(struct VP9Decoder_s *pbi)
 		pr_err("%s: failed to alloc count_buffer\n", __func__);
 		return -1;
 	}
+	memset(pbi->frame_mmu_map_addr, 0, COUNT_BUF_SIZE);
 /*	pbi->frame_mmu_map_phy_addr = dma_map_single(amports_get_dma_device(),
 	pbi->frame_mmu_map_addr, FRAME_MMU_MAP_SIZE, DMA_BIDIRECTIONAL);
 	if (dma_mapping_error(amports_get_dma_device(),
@@ -4751,7 +4932,29 @@ static void set_canvas(struct PIC_BUFFER_CONFIG_s *pic_config)
 		canvas_config_ex(pic_config->uv_canvas_index,
 			pic_config->dw_u_v_adr,	canvas_w, canvas_h,
 			CANVAS_ADDR_NOWRAP, blkmode, 0x7);
+#ifdef MULTI_INSTANCE_SUPPORT
+		pic_config->canvas_config[0].phy_addr =
+				pic_config->dw_y_adr;
+		pic_config->canvas_config[0].width =
+				canvas_w;
+		pic_config->canvas_config[0].height =
+				canvas_h;
+		pic_config->canvas_config[0].block_mode =
+				blkmode;
+		pic_config->canvas_config[0].endian = 7;
+
+		pic_config->canvas_config[1].phy_addr =
+				pic_config->dw_u_v_adr;
+		pic_config->canvas_config[1].width =
+				canvas_w;
+		pic_config->canvas_config[1].height =
+				canvas_h;
+		pic_config->canvas_config[1].block_mode =
+				blkmode;
+		pic_config->canvas_config[1].endian = 7;
+#endif
 	} else {
+	#ifndef VP9_10B_MMU
 		pic_config->y_canvas_index = 128 + pic_config->index;
 		pic_config->uv_canvas_index = 128 + pic_config->index;
 
@@ -4761,6 +4964,7 @@ static void set_canvas(struct PIC_BUFFER_CONFIG_s *pic_config)
 		canvas_config_ex(pic_config->uv_canvas_index,
 		pic_config->mc_u_v_adr,	canvas_w, canvas_h,
 			CANVAS_ADDR_NOWRAP, blkmode, 0x7);
+	#endif
 	}
 
 }
@@ -4832,17 +5036,18 @@ static void vvp9_vf_put(struct vframe_s *vf, void *op_arg)
 
 	if (index >= 0
 		&& index < FRAME_BUFFERS) {
-		ulong spin_flags;
 		struct VP9_Common_s *cm = &pbi->common;
-		struct BufferPool_s *const pool = cm->buffer_pool;
-		spin_lock_irqsave(&lock, spin_flags);
+		struct BufferPool_s *pool = cm->buffer_pool;
+		lock_buffer_pool(pool);
 		if (pool->frame_bufs[index].buf.vf_ref > 0)
 			pool->frame_bufs[index].buf.vf_ref--;
-		spin_unlock_irqrestore(&lock, spin_flags);
+
 		if (pbi->wait_buf)
 			WRITE_VREG(HEVC_ASSIST_MBOX1_IRQ_REG,
 						0x1);
-
+		pbi->last_put_idx = index;
+		pbi->new_frame_displayed++;
+		unlock_buffer_pool(pool);
 	}
 
 }
@@ -4976,20 +5181,44 @@ static int prepare_display_buf(struct VP9Decoder_s *pbi,
 			vf->compBodyAddr = 0;
 			vf->compHeadAddr = 0;
 		} else {
-			vf->compBodyAddr = pic_config->mc_y_adr; /*body adr*/
-			vf->compHeadAddr = pic_config->mc_y_adr +
-						pic_config->comp_body_size;
-					/*head adr*/
+#ifdef VP9_10B_MMU
+		vf->compBodyAddr = 0;
+		vf->compHeadAddr = pic_config->header_adr;
+#else
+		vf->compBodyAddr = pic_config->mc_y_adr; /*body adr*/
+		vf->compHeadAddr = pic_config->mc_y_adr +
+					pic_config->comp_body_size;
+		/*head adr*/
+#endif
 		}
 		if (double_write_mode) {
 			vf->type = VIDTYPE_PROGRESSIVE |
 				VIDTYPE_VIU_FIELD;
 			vf->type |= VIDTYPE_VIU_NV21;
-			vf->canvas0Addr = vf->canvas1Addr =
-				spec2canvas(pic_config);
+#ifdef MULTI_INSTANCE_SUPPORT
+			if (pbi->m_ins_flag) {
+					vf->canvas0Addr = vf->canvas1Addr = -1;
+					vf->plane_num = 2;
+					vf->canvas0_config[0] =
+						pic_config->canvas_config[0];
+					vf->canvas0_config[1] =
+						pic_config->canvas_config[1];
+
+					vf->canvas1_config[0] =
+						pic_config->canvas_config[0];
+					vf->canvas1_config[1] =
+						pic_config->canvas_config[1];
+
+			} else
+#endif
+				vf->canvas0Addr = vf->canvas1Addr =
+					spec2canvas(pic_config);
 		} else {
 			vf->canvas0Addr = vf->canvas1Addr = 0;
 			vf->type = VIDTYPE_COMPRESS | VIDTYPE_VIU_FIELD;
+#ifdef VP9_10B_MMU
+			vf->type |= VIDTYPE_SCATTER;
+#endif
 			switch (pic_config->bit_depth) {
 			case VPX_BITS_8:
 				vf->bitdepth = BITDEPTH_Y8 |
@@ -5039,10 +5268,18 @@ static int prepare_display_buf(struct VP9Decoder_s *pbi,
 			else
 				vf->duration = 0;
 		}
-		if ((debug & VP9_DEBUG_VF_REF) == 0)
-			inc_vf_ref(pbi, pic_config->index);
+		if (vf->type & VIDTYPE_SCATTER) {
+			vf->mem_handle = decoder_mmu_box_get_mem_handle(
+				pbi->mmu_box,
+				pic_config->index);
+		} else {
+			vf->mem_handle = decoder_bmmu_box_get_mem_handle(
+				pbi->bmmu_box,
+				pic_config->index);
+		}
+		inc_vf_ref(pbi, pic_config->index);
 		kfifo_put(&pbi->display_q, (const struct vframe_s *)vf);
-		vf_notify_receiver(PROVIDER_NAME,
+		vf_notify_receiver(pbi->provider_name,
 				VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
 	}
 
@@ -5067,101 +5304,88 @@ static void get_rpm_param(union param_u *params)
 	if (debug & VP9_DEBUG_BUFMGR)
 		pr_info("leave %s\r\n", __func__);
 }
-
-static irqreturn_t vvp9_isr(int irq, void *data)
+static void debug_buffer_mgr_more(struct VP9Decoder_s *pbi)
 {
 	int i;
-	unsigned int dec_status;
-	int ret;
-	struct VP9Decoder_s *pbi = (struct VP9Decoder_s *)data;
-	unsigned int adapt_prob_status;
-	struct VP9_Common_s *const cm = &pbi->common;
-	dec_status = READ_VREG(HEVC_DEC_STATUS_REG);
-	adapt_prob_status = READ_VREG(VP9_ADAPT_PROB_REG);
-	if (pbi->init_flag == 0)
-		return IRQ_HANDLED;
-
-	pbi->process_busy = 1;
-	if (debug & VP9_DEBUG_BUFMGR)
-		pr_info("vp9 isr dec status  = %d\n", dec_status);
-
-	if (debug & VP9_DEBUG_UCODE) {
-		if (READ_HREG(DEBUG_REG1) & 0x10000) {
-			dma_sync_single_for_cpu(
-				amports_get_dma_device(),
-				pbi->lmem_phy_addr,
-				LMEM_BUF_SIZE,
-				DMA_FROM_DEVICE);
-
-			pr_info("LMEM<tag %x>:\n", READ_HREG(DEBUG_REG1));
-			for (i = 0; i < 0x400; i += 4) {
-				int ii;
-				if ((i & 0xf) == 0)
-					pr_info("%03x: ", i);
-				for (ii = 0; ii < 4; ii++) {
-					pr_info("%04x ",
-						   pbi->lmem_ptr[i + 3 - ii]);
-				}
-				if (((i + ii) & 0xf) == 0)
-					pr_info("\n");
-			}
-			WRITE_HREG(DEBUG_REG1, 0);
-		} else if (READ_HREG(DEBUG_REG1) != 0) {
-			pr_info("dbg%x: %x\n", READ_HREG(DEBUG_REG1),
-				   READ_HREG(DEBUG_REG2));
-			WRITE_HREG(DEBUG_REG1, 0);
-			pbi->process_busy = 0;
-			return IRQ_HANDLED;
-		}
-
+	if (!(debug & VP9_DEBUG_BUFMGR_MORE))
+		return;
+	pr_info("vp9_param: (%d)\n", pbi->slice_idx);
+	for (i = 0; i < (RPM_END-RPM_BEGIN); i++) {
+		pr_info("%04x ", vp9_param.l.data[i]);
+		if (((i + 1) & 0xf) == 0)
+			pr_info("\n");
 	}
+	pr_info("=============param==========\r\n");
+	pr_info("profile               %x\r\n", vp9_param.p.profile);
+	pr_info("show_existing_frame   %x\r\n",
+	vp9_param.p.show_existing_frame);
+	pr_info("frame_to_show_idx     %x\r\n",
+	vp9_param.p.frame_to_show_idx);
+	pr_info("frame_type            %x\r\n", vp9_param.p.frame_type);
+	pr_info("show_frame            %x\r\n", vp9_param.p.show_frame);
+	pr_info("e.r.r.o.r_resilient_mode  %x\r\n",
+	vp9_param.p.error_resilient_mode);
+	pr_info("intra_only            %x\r\n", vp9_param.p.intra_only);
+	pr_info("display_size_present  %x\r\n",
+	vp9_param.p.display_size_present);
+	pr_info("reset_frame_context   %x\r\n",
+	vp9_param.p.reset_frame_context);
+	pr_info("refresh_frame_flags   %x\r\n",
+	vp9_param.p.refresh_frame_flags);
+	pr_info("bit_depth             %x\r\n", vp9_param.p.bit_depth);
+	pr_info("width                 %x\r\n", vp9_param.p.width);
+	pr_info("height                %x\r\n", vp9_param.p.height);
+	pr_info("display_width         %x\r\n", vp9_param.p.display_width);
+	pr_info("display_height        %x\r\n", vp9_param.p.display_height);
+	pr_info("ref_info              %x\r\n", vp9_param.p.ref_info);
+	pr_info("same_frame_size       %x\r\n", vp9_param.p.same_frame_size);
+	if (!(debug & VP9_DEBUG_DBG_LF_PRINT))
+		return;
+	pr_info("mode_ref_delta_enabled: 0x%x\r\n",
+	vp9_param.p.mode_ref_delta_enabled);
+	pr_info("sharpness_level: 0x%x\r\n",
+	vp9_param.p.sharpness_level);
+	pr_info("ref_deltas: 0x%x, 0x%x, 0x%x, 0x%x\r\n",
+	vp9_param.p.ref_deltas[0], vp9_param.p.ref_deltas[1],
+	vp9_param.p.ref_deltas[2], vp9_param.p.ref_deltas[3]);
+	pr_info("mode_deltas: 0x%x, 0x%x\r\n", vp9_param.p.mode_deltas[0],
+	vp9_param.p.mode_deltas[1]);
+	pr_info("filter_level: 0x%x\r\n", vp9_param.p.filter_level);
+	pr_info("seg_enabled: 0x%x\r\n", vp9_param.p.seg_enabled);
+	pr_info("seg_abs_delta: 0x%x\r\n", vp9_param.p.seg_abs_delta);
+	pr_info("seg_lf_feature_enabled: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n",
+	(vp9_param.p.seg_lf_info[0]>>15 & 1),
+	(vp9_param.p.seg_lf_info[1]>>15 & 1),
+	(vp9_param.p.seg_lf_info[2]>>15 & 1),
+	(vp9_param.p.seg_lf_info[3]>>15 & 1),
+	(vp9_param.p.seg_lf_info[4]>>15 & 1),
+	(vp9_param.p.seg_lf_info[5]>>15 & 1),
+	(vp9_param.p.seg_lf_info[6]>>15 & 1),
+	(vp9_param.p.seg_lf_info[7]>>15 & 1));
+	pr_info("seg_lf_feature_data: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n",
+	(vp9_param.p.seg_lf_info[0] & 0x13f),
+	(vp9_param.p.seg_lf_info[1] & 0x13f),
+	(vp9_param.p.seg_lf_info[2] & 0x13f),
+	(vp9_param.p.seg_lf_info[3] & 0x13f),
+	(vp9_param.p.seg_lf_info[4] & 0x13f),
+	(vp9_param.p.seg_lf_info[5] & 0x13f),
+	(vp9_param.p.seg_lf_info[6] & 0x13f),
+	(vp9_param.p.seg_lf_info[7] & 0x13f));
 
-	if (pbi->error_flag == 1) {
-		pbi->error_flag = 2;
-		pbi->process_busy = 0;
-		return IRQ_HANDLED;
-	} else if (pbi->error_flag == 3) {
-		pbi->process_busy = 0;
-		return IRQ_HANDLED;
-	}
+}
 
-	if (is_buffer_empty(cm)) {
-		/*
-		if (pbi->wait_buf == 0)
-			pr_info("set wait_buf to 1\r\n");
-		*/
-		pbi->wait_buf = 1;
-		pbi->process_busy = 0;
-		return IRQ_HANDLED;
-	}
+static irqreturn_t vvp9_isr_thread_fn(int irq, void *data)
+{
+	struct VP9Decoder_s *pbi = (struct VP9Decoder_s *)data;
+	unsigned int dec_status = pbi->dec_status;
+	struct VP9_Common_s *const cm = &pbi->common;
+	int i, ret;
 
 	/*if (pbi->wait_buf)
 		pr_info("set wait_buf to 0\r\n");
 	*/
 	pbi->wait_buf = 0;
 
-	if ((adapt_prob_status & 0xff) == 0xfd) {
-		/*VP9_REQ_ADAPT_PROB*/
-	int pre_fc = (cm->frame_type == KEY_FRAME) ? 1 : 0;
-	uint8_t *prev_prob_b =
-		((uint8_t *)pbi->prob_buffer_addr) +
-		((adapt_prob_status >> 8) * 0x1000);
-	uint8_t *cur_prob_b =
-		((uint8_t *)pbi->prob_buffer_addr) + 0x4000;
-	uint8_t *count_b = (uint8_t *)pbi->count_buffer_addr;
-
-	adapt_coef_probs(pbi->pic_count, (cm->last_frame_type == KEY_FRAME),
-			pre_fc, (adapt_prob_status >> 8),
-			(unsigned int *)prev_prob_b,
-			(unsigned int *)cur_prob_b, (unsigned int *)count_b);
-
-	memcpy(prev_prob_b, cur_prob_b, PROB_SIZE);
-	WRITE_VREG(VP9_ADAPT_PROB_REG, 0);
-	pbi->pic_count += 1;
-
-	/*return IRQ_HANDLED;*/
-	}
-
 	if (dec_status == VP9_EOS) {
 		pr_info("VP9_EOS, flush buffer\r\n");
 
@@ -5196,93 +5420,29 @@ static irqreturn_t vvp9_isr(int irq, void *data)
 					pbi->rpm_ptr[i + 3 - ii];
 		   }
 	}
-if (debug & VP9_DEBUG_BUFMGR_MORE) {
-	pr_info("vp9_param: (%d)\n", pbi->slice_idx);
+	debug_buffer_mgr_more(pbi);
+
+	bit_depth_luma = vp9_param.p.bit_depth;
+	bit_depth_chroma = vp9_param.p.bit_depth;
+
+	ret = vp9_bufmgr_process(pbi, &vp9_param);
 	pbi->slice_idx++;
-	for (i = 0; i < (RPM_END-RPM_BEGIN); i++) {
-		pr_info("%04x ", vp9_param.l.data[i]);
-		if (((i + 1) & 0xf) == 0)
-			pr_info("\n");
-	}
-	pr_info("=============param==========\r\n");
-	pr_info("profile               %x\r\n", vp9_param.p.profile);
-	pr_info("show_existing_frame   %x\r\n",
-		vp9_param.p.show_existing_frame);
-	pr_info("frame_to_show_idx     %x\r\n",
-		vp9_param.p.frame_to_show_idx);
-	pr_info("frame_type            %x\r\n", vp9_param.p.frame_type);
-	pr_info("show_frame            %x\r\n", vp9_param.p.show_frame);
-	pr_info("e.r.r.o.r_resilient_mode  %x\r\n",
-		vp9_param.p.error_resilient_mode);
-	pr_info("intra_only            %x\r\n", vp9_param.p.intra_only);
-	pr_info("display_size_present  %x\r\n",
-		vp9_param.p.display_size_present);
-	pr_info("reset_frame_context   %x\r\n",
-		vp9_param.p.reset_frame_context);
-	pr_info("refresh_frame_flags   %x\r\n",
-		vp9_param.p.refresh_frame_flags);
-	pr_info("bit_depth             %x\r\n", vp9_param.p.bit_depth);
-	pr_info("width                 %x\r\n", vp9_param.p.width);
-	pr_info("height                %x\r\n", vp9_param.p.height);
-	pr_info("display_width         %x\r\n", vp9_param.p.display_width);
-	pr_info("display_height        %x\r\n", vp9_param.p.display_height);
-	pr_info("ref_info              %x\r\n", vp9_param.p.ref_info);
-	pr_info("same_frame_size       %x\r\n", vp9_param.p.same_frame_size);
-if (debug & VP9_DEBUG_DBG_LF_PRINT) {
-	pr_info("mode_ref_delta_enabled: 0x%x\r\n",
-		vp9_param.p.mode_ref_delta_enabled);
-	pr_info("sharpness_level: 0x%x\r\n",
-		vp9_param.p.sharpness_level);
-	pr_info("ref_deltas: 0x%x, 0x%x, 0x%x, 0x%x\r\n",
-		vp9_param.p.ref_deltas[0], vp9_param.p.ref_deltas[1],
-		vp9_param.p.ref_deltas[2], vp9_param.p.ref_deltas[3]);
-	pr_info("mode_deltas: 0x%x, 0x%x\r\n", vp9_param.p.mode_deltas[0],
-		vp9_param.p.mode_deltas[1]);
-	pr_info("filter_level: 0x%x\r\n", vp9_param.p.filter_level);
-	pr_info("seg_enabled: 0x%x\r\n", vp9_param.p.seg_enabled);
-	pr_info("seg_abs_delta: 0x%x\r\n", vp9_param.p.seg_abs_delta);
-	pr_info("seg_lf_feature_enabled: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n",
-		(vp9_param.p.seg_lf_info[0]>>15 & 1),
-		(vp9_param.p.seg_lf_info[1]>>15 & 1),
-		(vp9_param.p.seg_lf_info[2]>>15 & 1),
-		(vp9_param.p.seg_lf_info[3]>>15 & 1),
-		(vp9_param.p.seg_lf_info[4]>>15 & 1),
-		(vp9_param.p.seg_lf_info[5]>>15 & 1),
-		(vp9_param.p.seg_lf_info[6]>>15 & 1),
-		(vp9_param.p.seg_lf_info[7]>>15 & 1));
-		pr_info("seg_lf_feature_data: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n",
-		(vp9_param.p.seg_lf_info[0] & 0x13f),
-		(vp9_param.p.seg_lf_info[1] & 0x13f),
-		(vp9_param.p.seg_lf_info[2] & 0x13f),
-		(vp9_param.p.seg_lf_info[3] & 0x13f),
-		(vp9_param.p.seg_lf_info[4] & 0x13f),
-		(vp9_param.p.seg_lf_info[5] & 0x13f),
-		(vp9_param.p.seg_lf_info[6] & 0x13f),
-		(vp9_param.p.seg_lf_info[7] & 0x13f));
-	}
-	pr_info("\r\n");
-	}
-
-	bit_depth_luma = vp9_param.p.bit_depth;
-	bit_depth_chroma = vp9_param.p.bit_depth;
-
-	ret = vp9_bufmgr_process(pbi, &vp9_param);
-	if (ret < 0) {
-		pr_info("vp9_bufmgr_process=> %d, VP9_10B_DISCARD_NAL\r\n",
-		 ret);
-		WRITE_VREG(HEVC_DEC_STATUS_REG, VP9_10B_DISCARD_NAL);
-		pbi->process_busy = 0;
-		return IRQ_HANDLED;
-	} else if (ret == 0) {
-		pbi->frame_count++;
-		/*pr_info("Decode Frame Data %d\n", pbi->frame_count);*/
-		config_pic_size(pbi, vp9_param.p.bit_depth);
-		if ((pbi->common.frame_type != KEY_FRAME)
-			&& (!pbi->common.intra_only)) {
-			config_mc_buffer(pbi, vp9_param.p.bit_depth);
-			config_mpred_hw(pbi);
-	} else {
-		clear_mpred_hw(pbi);
+	if (ret < 0) {
+		pr_info("vp9_bufmgr_process=> %d, VP9_10B_DISCARD_NAL\r\n",
+		 ret);
+		WRITE_VREG(HEVC_DEC_STATUS_REG, VP9_10B_DISCARD_NAL);
+		pbi->process_busy = 0;
+		return IRQ_HANDLED;
+	} else if (ret == 0) {
+		pbi->frame_count++;
+		/*pr_info("Decode Frame Data %d\n", pbi->frame_count);*/
+		config_pic_size(pbi, vp9_param.p.bit_depth);
+		if ((pbi->common.frame_type != KEY_FRAME)
+			&& (!pbi->common.intra_only)) {
+			config_mc_buffer(pbi, vp9_param.p.bit_depth);
+			config_mpred_hw(pbi);
+	} else {
+		clear_mpred_hw(pbi);
 	}
 #ifdef MCRCC_ENABLE
 	config_mcrcc_axi_hw(pbi);
@@ -5327,9 +5487,200 @@ if (debug & VP9_DEBUG_DBG_LF_PRINT) {
 	WRITE_VREG(HEVC_DEC_STATUS_REG, VP9_10B_DECODE_SLICE);
 	}
 	pbi->process_busy = 0;
+#ifdef VP9_10B_MMU
+	if (pbi->last_put_idx >= 0 && pbi->last_put_idx < FRAME_BUFFERS) {
+		struct RefCntBuffer_s *frame_bufs = cm->buffer_pool->frame_bufs;
+		int i = pbi->last_put_idx;
+		/*free not used buffers.*/
+		if ((frame_bufs[i].ref_count == 0) &&
+			(frame_bufs[i].buf.vf_ref == 0) &&
+			(frame_bufs[i].buf.used_by_display == 0) &&
+			(frame_bufs[i].buf.index != -1)) {
+			decoder_mmu_box_free_idx(pbi->mmu_box, i);
+		}
+		pbi->last_put_idx = -1;
+	}
+#endif
 	return IRQ_HANDLED;
 }
 
+static irqreturn_t vvp9_isr(int irq, void *data)
+{
+	int i;
+	unsigned int dec_status;
+	struct VP9Decoder_s *pbi = (struct VP9Decoder_s *)data;
+	unsigned int adapt_prob_status;
+	struct VP9_Common_s *const cm = &pbi->common;
+	dec_status = READ_VREG(HEVC_DEC_STATUS_REG);
+	adapt_prob_status = READ_VREG(VP9_ADAPT_PROB_REG);
+	if (pbi->init_flag == 0)
+		return IRQ_HANDLED;
+	if (pbi->process_busy)/*on process.*/
+		return IRQ_HANDLED;
+	pbi->dec_status = dec_status;
+	pbi->process_busy = 1;
+	if (debug & VP9_DEBUG_BUFMGR)
+		pr_info("vp9 isr dec status  = %d\n", dec_status);
+
+	if (debug & VP9_DEBUG_UCODE) {
+		if (READ_HREG(DEBUG_REG1) & 0x10000) {
+			dma_sync_single_for_cpu(
+				amports_get_dma_device(),
+				pbi->lmem_phy_addr,
+				LMEM_BUF_SIZE,
+				DMA_FROM_DEVICE);
+
+			pr_info("LMEM<tag %x>:\n", READ_HREG(DEBUG_REG1));
+			for (i = 0; i < 0x400; i += 4) {
+				int ii;
+				if ((i & 0xf) == 0)
+					pr_info("%03x: ", i);
+				for (ii = 0; ii < 4; ii++) {
+					pr_info("%04x ",
+						   pbi->lmem_ptr[i + 3 - ii]);
+				}
+				if (((i + ii) & 0xf) == 0)
+					pr_info("\n");
+			}
+			WRITE_HREG(DEBUG_REG1, 0);
+		} else if (READ_HREG(DEBUG_REG1) != 0) {
+			pr_info("dbg%x: %x\n", READ_HREG(DEBUG_REG1),
+				   READ_HREG(DEBUG_REG2));
+			WRITE_HREG(DEBUG_REG1, 0);
+			pbi->process_busy = 0;
+			return IRQ_HANDLED;
+		}
+
+	}
+
+	if (pbi->error_flag == 1) {
+		pbi->error_flag = 2;
+		pbi->process_busy = 0;
+		return IRQ_HANDLED;
+	} else if (pbi->error_flag == 3) {
+		pbi->process_busy = 0;
+		return IRQ_HANDLED;
+	}
+
+	if (is_buffer_empty(cm)) {
+		/*
+		if (pbi->wait_buf == 0)
+			pr_info("set wait_buf to 1\r\n");
+		*/
+		pbi->wait_buf = 1;
+		pbi->process_busy = 0;
+		return IRQ_HANDLED;
+	}
+	if ((adapt_prob_status & 0xff) == 0xfd) {
+		/*VP9_REQ_ADAPT_PROB*/
+		int pre_fc = (cm->frame_type == KEY_FRAME) ? 1 : 0;
+		uint8_t *prev_prob_b =
+		((uint8_t *)pbi->prob_buffer_addr) +
+		((adapt_prob_status >> 8) * 0x1000);
+		uint8_t *cur_prob_b =
+		((uint8_t *)pbi->prob_buffer_addr) + 0x4000;
+		uint8_t *count_b = (uint8_t *)pbi->count_buffer_addr;
+
+		adapt_coef_probs(pbi->pic_count,
+			(cm->last_frame_type == KEY_FRAME),
+			pre_fc, (adapt_prob_status >> 8),
+			(unsigned int *)prev_prob_b,
+			(unsigned int *)cur_prob_b, (unsigned int *)count_b);
+
+		memcpy(prev_prob_b, cur_prob_b, PROB_SIZE);
+		WRITE_VREG(VP9_ADAPT_PROB_REG, 0);
+		pbi->pic_count += 1;
+
+		/*return IRQ_HANDLED;*/
+	}
+#ifdef MULTI_INSTANCE_SUPPORT
+#if 0
+	if ((dec_status == HEVC_DECPIC_DATA_DONE) && (pbi->m_ins_flag)) {
+		if (pbi->chunk) {
+			pbi->cur_pic->pts = pbi->chunk->pts;
+			pbi->cur_pic->pts64 = pbi->chunk->pts64;
+		} else if (pts_lookup_offset_us64
+			(PTS_TYPE_VIDEO,
+			pbi->cur_pic->stream_offset,
+			&pbi->cur_pic->pts,
+			0,
+			&pbi->cur_pic->pts64) != 0) {
+#ifdef DEBUG_PTS
+			pbi->pts_missed++;
+#endif
+			pbi->cur_pic->pts = 0;
+			pbi->cur_pic->pts64 = 0;
+		}
+	}
+#endif
+	if (dec_status == HEVC_NAL_DECODE_DONE) {
+		if (pbi->m_ins_flag) {
+#if 0
+			if (!vdec_frame_based(hw_to_vdec(hevc))) {
+				pbi->dec_result = DEC_RESULT_AGAIN;
+				if ((debug &
+				ONLY_RESET_AT_START) == 0)
+					amhevc_stop();
+			} else
+				pbi->dec_result = DEC_RESULT_GET_DATA;
+#else
+			if (!vdec_frame_based(hw_to_vdec(pbi)))
+				pbi->dec_result = DEC_RESULT_AGAIN;
+			else
+				pbi->dec_result = DEC_RESULT_DONE;
+			amhevc_stop();
+#endif
+			schedule_work(&pbi->work);
+		}
+		pbi->process_busy = 0;
+		return IRQ_HANDLED;
+	} else if (dec_status == HEVC_DECPIC_DATA_DONE) {
+		if (pbi->m_ins_flag) {
+			pbi->dec_result = DEC_RESULT_DONE;
+			amhevc_stop();
+			schedule_work(&pbi->work);
+		}
+
+		pbi->process_busy = 0;
+		return IRQ_HANDLED;
+	} else if (
+			(dec_status == HEVC_SEARCH_BUFEMPTY) ||
+			(dec_status == HEVC_DECODE_BUFEMPTY) ||
+			(dec_status == HEVC_DECODE_TIMEOUT)) {
+		if (vdec_frame_based(hw_to_vdec(pbi)) ||
+			(READ_VREG(HEVC_STREAM_LEVEL) > 0x200)) {
+			if (debug & VP9_DEBUG_DIS_LOC_ERROR_PROC) {
+				vp9_print(pbi, PRINT_FLAG_ERROR,
+					"%s decoding error, level 0x%x\n",
+					__func__, READ_VREG(HEVC_STREAM_LEVEL));
+				goto send_again;
+			}
+			amhevc_stop();
+			vp9_print(pbi, PRINT_FLAG_UCODE_EVT,
+				"%s %s\n", __func__,
+				(dec_status == HEVC_SEARCH_BUFEMPTY) ?
+				"HEVC_SEARCH_BUFEMPTY" :
+				(dec_status == HEVC_DECODE_BUFEMPTY) ?
+				"HEVC_DECODE_BUFEMPTY" : "HEVC_DECODE_TIMEOUT");
+			pbi->dec_result = DEC_RESULT_DONE;
+
+			schedule_work(&pbi->work);
+		} else {
+			/* WRITE_VREG(DPB_STATUS_REG, H264_ACTION_INIT); */
+			vp9_print(pbi, PRINT_FLAG_VDEC_STATUS,
+				"%s DEC_RESULT_AGAIN\n", __func__);
+send_again:
+			pbi->dec_result = DEC_RESULT_AGAIN;
+			schedule_work(&pbi->work);
+		}
+		pbi->process_busy = 0;
+		return IRQ_HANDLED;
+	}
+#endif
+
+	return IRQ_WAKE_THREAD;
+}
+
 static void vvp9_put_timer_func(unsigned long arg)
 {
 	struct VP9Decoder_s *pbi = (struct VP9Decoder_s *)arg;
@@ -5338,6 +5689,16 @@ static void vvp9_put_timer_func(unsigned long arg)
 	unsigned int buf_level;
 
 	enum receviver_start_e state = RECEIVER_INACTIVE;
+	if (pbi->m_ins_flag) {
+		if (hw_to_vdec(pbi)->next_status
+			== VDEC_STATUS_DISCONNECTED) {
+			pbi->dec_result = DEC_RESULT_DONE;
+			schedule_work(&pbi->work);
+			pr_info(
+			"vdec requested to be disconnected\n");
+			return;
+		}
+	}
 	if (pbi->init_flag == 0) {
 		if (pbi->stat & STAT_TIMER_ARM) {
 			timer->expires = jiffies + PUT_INTERVAL;
@@ -5345,40 +5706,43 @@ static void vvp9_put_timer_func(unsigned long arg)
 		}
 		return;
 	}
-	if (vf_get_receiver(PROVIDER_NAME)) {
-		state =
-			vf_notify_receiver(PROVIDER_NAME,
-				VFRAME_EVENT_PROVIDER_QUREY_STATE, NULL);
-		if ((state == RECEIVER_STATE_NULL)
-			|| (state == RECEIVER_STATE_NONE))
+	if (pbi->m_ins_flag == 0) {
+		if (vf_get_receiver(pbi->provider_name)) {
+			state =
+				vf_notify_receiver(pbi->provider_name,
+					VFRAME_EVENT_PROVIDER_QUREY_STATE,
+					NULL);
+			if ((state == RECEIVER_STATE_NULL)
+				|| (state == RECEIVER_STATE_NONE))
+				state = RECEIVER_INACTIVE;
+		} else
 			state = RECEIVER_INACTIVE;
-	} else
-		state = RECEIVER_INACTIVE;
-
-	empty_flag = (READ_VREG(HEVC_PARSER_INT_STATUS) >> 6) & 0x1;
-	/* error watchdog */
-	if (empty_flag == 0) {
-		/* decoder has input */
-		if ((debug & VP9_DEBUG_DIS_LOC_ERROR_PROC) == 0) {
-
-			buf_level = READ_VREG(HEVC_STREAM_LEVEL);
-			/* receiver has no buffer to recycle */
-			if ((state == RECEIVER_INACTIVE) &&
-				(kfifo_is_empty(&pbi->display_q) &&
-				 buf_level > 0x200)
-				) {
-					WRITE_VREG
-					(HEVC_ASSIST_MBOX1_IRQ_REG,
-					 0x1);
+
+		empty_flag = (READ_VREG(HEVC_PARSER_INT_STATUS) >> 6) & 0x1;
+		/* error watchdog */
+		if (empty_flag == 0) {
+			/* decoder has input */
+			if ((debug & VP9_DEBUG_DIS_LOC_ERROR_PROC) == 0) {
+
+				buf_level = READ_VREG(HEVC_STREAM_LEVEL);
+				/* receiver has no buffer to recycle */
+				if ((state == RECEIVER_INACTIVE) &&
+					(kfifo_is_empty(&pbi->display_q) &&
+					 buf_level > 0x200)
+					) {
+						WRITE_VREG
+						(HEVC_ASSIST_MBOX1_IRQ_REG,
+						 0x1);
+				}
 			}
-		}
 
-		if ((debug & VP9_DEBUG_DIS_SYS_ERROR_PROC) == 0) {
-			/* receiver has no buffer to recycle */
-			/*if ((state == RECEIVER_INACTIVE) &&
-				(kfifo_is_empty(&pbi->display_q))) {
-			pr_info("vp9 something error,need reset\n");
-			}*/
+			if ((debug & VP9_DEBUG_DIS_SYS_ERROR_PROC) == 0) {
+				/* receiver has no buffer to recycle */
+				/*if ((state == RECEIVER_INACTIVE) &&
+					(kfifo_is_empty(&pbi->display_q))) {
+				pr_info("vp9 something error,need reset\n");
+				}*/
+			}
 		}
 	}
 
@@ -5411,6 +5775,25 @@ static void vvp9_put_timer_func(unsigned long arg)
 		rval = 0;
 		radr = 0;
 	}
+	if (pop_shorts != 0) {
+		int i;
+		u32 sum = 0;
+		pr_info("pop stream 0x%x shorts\r\n", pop_shorts);
+		for (i = 0; i < pop_shorts; i++) {
+			u32 data =
+			(READ_HREG(HEVC_SHIFTED_DATA) >> 16);
+			WRITE_HREG(HEVC_SHIFT_COMMAND,
+			(1<<7)|16);
+			if ((i & 0xf) == 0)
+				pr_info("%04x:", i);
+			pr_info("%04x ", data);
+			if (((i + 1) & 0xf) == 0)
+				pr_info("\r\n");
+			sum += data;
+		}
+		pr_info("\r\nsum = %x\r\n", sum);
+		pop_shorts = 0;
+	}
 	if (dbg_cmd != 0) {
 		if (dbg_cmd == 1) {
 			u32 disp_laddr;
@@ -5446,7 +5829,7 @@ static void vvp9_put_timer_func(unsigned long arg)
 }
 
 
-int vvp9_dec_status(struct vdec_status *vstatus)
+int vvp9_dec_status(struct vdec_s *vdec, struct vdec_status *vstatus)
 {
 	struct VP9Decoder_s *pbi = &gHevc;
 	vstatus->width = frame_width;
@@ -5488,44 +5871,46 @@ static void vvp9_prot_init(struct VP9Decoder_s *pbi)
 	vp9_config_work_space_hw(pbi);
 	init_pic_list_hw(pbi);
 
-	vp9_init_decoder_hw();
+	vp9_init_decoder_hw(pbi);
 
 #ifdef VP9_LPF_LVL_UPDATE
 	vp9_loop_filter_init();
 #endif
 
 #if 1
-		if (debug & VP9_DEBUG_BUFMGR)
-			pr_info("[test.c] Enable BitStream Fetch\n");
-			data32 = READ_VREG(HEVC_STREAM_CONTROL);
-			data32 = data32 |
-				(1 << 0)/*stream_fetch_enable*/
-				;
-			WRITE_VREG(HEVC_STREAM_CONTROL, data32);
-			data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
-			if (data32 != 0x00000100) {
-				/*print_scratch_error(29);*/
-				return;
-			}
-			data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
-			if (data32 != 0x00000300) {
-				/*print_scratch_error(30);*/
-				return;
-			}
-			WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x12345678);
-			WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x9abcdef0);
-			data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
-			if (data32 != 0x12345678) {
-				/*print_scratch_error(31);*/
-				return;
-			}
-			data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
-			if (data32 != 0x9abcdef0) {
-				/*print_scratch_error(32);*/
-				return;
-			}
-			WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x000000001);
-			WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x00000300);
+	if (debug & VP9_DEBUG_BUFMGR)
+		pr_info("[test.c] Enable BitStream Fetch\n");
+	data32 = READ_VREG(HEVC_STREAM_CONTROL);
+	data32 = data32 |
+		(1 << 0)/*stream_fetch_enable*/
+		;
+	WRITE_VREG(HEVC_STREAM_CONTROL, data32);
+#if 0
+	data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
+	if (data32 != 0x00000100) {
+		pr_info("vp9 prot init error %d\n", __LINE__);
+		return;
+	}
+	data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
+	if (data32 != 0x00000300) {
+		pr_info("vp9 prot init error %d\n", __LINE__);
+		return;
+	}
+	WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x12345678);
+	WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x9abcdef0);
+	data32 = READ_VREG(HEVC_SHIFT_STARTCODE);
+	if (data32 != 0x12345678) {
+		pr_info("vp9 prot init error %d\n", __LINE__);
+		return;
+	}
+	data32 = READ_VREG(HEVC_SHIFT_EMULATECODE);
+	if (data32 != 0x9abcdef0) {
+		pr_info("vp9 prot init error %d\n", __LINE__);
+		return;
+	}
+#endif
+	WRITE_VREG(HEVC_SHIFT_STARTCODE, 0x000000001);
+	WRITE_VREG(HEVC_SHIFT_EMULATECODE, 0x00000300);
 #endif
 
 
@@ -5551,7 +5936,6 @@ static void vvp9_prot_init(struct VP9Decoder_s *pbi)
 	WRITE_VREG(NAL_SEARCH_CTL, 0x8);
 
 	WRITE_VREG(DECODE_STOP_POS, decode_stop_pos);
-	pr_info("vp9 prot init done\n");
 
 }
 
@@ -5564,6 +5948,8 @@ static int vvp9_local_init(struct VP9Decoder_s *pbi)
 	pbi->pts_missed = 0;
 	pbi->pts_hit = 0;
 #endif
+	pbi->new_frame_displayed = 0;
+	pbi->last_put_idx = -1;
 	pbi->saved_resolution = 0;
 	pbi->get_frame_dur = false;
 	on_no_keyframe_skiped = 0;
@@ -5604,10 +5990,24 @@ static s32 vvp9_init(struct VP9Decoder_s *pbi)
 	init_timer(&pbi->timer);
 
 	pbi->stat |= STAT_TIMER_INIT;
-
 	if (vvp9_local_init(pbi) < 0)
 		return -EBUSY;
 
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (pbi->m_ins_flag) {
+		pbi->timer.data = (ulong) pbi;
+		pbi->timer.function = vvp9_put_timer_func;
+		pbi->timer.expires = jiffies + PUT_INTERVAL;
+
+		add_timer(&pbi->timer);
+
+		pbi->stat |= STAT_TIMER_ARM;
+
+		INIT_WORK(&pbi->work, vp9_work);
+		return 0;
+	}
+#endif
+
 	amhevc_enable();
 	if (debug & VP9_DEBUG_LOAD_UCODE_FROM_FILE) {
 		pr_info("load ucode from file of vvp9_mc_debug\n");
@@ -5634,7 +6034,10 @@ static s32 vvp9_init(struct VP9Decoder_s *pbi)
 	/* enable AMRISC side protocol */
 	vvp9_prot_init(pbi);
 
-	if (vdec_request_irq(VDEC_IRQ_1, vvp9_isr,
+	if (vdec_request_threaded_irq(VDEC_IRQ_1,
+				vvp9_isr,
+				vvp9_isr_thread_fn,
+				IRQF_ONESHOT,/*run thread on this irq disabled*/
 				"vvp9-irq", (void *)pbi)) {
 		pr_info("vvp9 irq register error.\n");
 		amhevc_disable();
@@ -5643,6 +6046,7 @@ static s32 vvp9_init(struct VP9Decoder_s *pbi)
 
 	pbi->stat |= STAT_ISR_REG;
 
+	pbi->provider_name = PROVIDER_NAME;
 	vf_provider_init(&vvp9_vf_prov, PROVIDER_NAME, &vvp9_vf_provider,
 					 pbi);
 	vf_reg_provider(&vvp9_vf_prov);
@@ -5668,8 +6072,6 @@ static s32 vvp9_init(struct VP9Decoder_s *pbi)
 
 	pbi->stat |= STAT_VDEC_RUN;
 
-	set_vdec_func(&vvp9_dec_status);
-
 	pbi->init_flag = 1;
 	pbi->process_busy = 0;
 	pr_info("%d, vvp9_init, RP=0x%x\n",
@@ -5681,7 +6083,7 @@ static int vvp9_stop(struct VP9Decoder_s *pbi)
 {
 
 	pbi->init_flag = 0;
-
+	/*
 	if ((debug & VP9_DEBUG_NOWAIT_DECODE_DONE_WHEN_STOP) == 0) {
 		int wait_timeout_count = 0;
 		while ((READ_VREG(HEVC_DEC_STATUS_REG) ==
@@ -5692,7 +6094,7 @@ static int vvp9_stop(struct VP9Decoder_s *pbi)
 			msleep(20);
 		}
 	}
-
+	*/
 	if (pbi->stat & STAT_VDEC_RUN) {
 		amhevc_stop();
 		pbi->stat &= ~STAT_VDEC_RUN;
@@ -5710,45 +6112,64 @@ static int vvp9_stop(struct VP9Decoder_s *pbi)
 	}
 
 	if (pbi->stat & STAT_VF_HOOK) {
-		vf_notify_receiver(PROVIDER_NAME,
+		vf_notify_receiver(pbi->provider_name,
 				VFRAME_EVENT_PROVIDER_FR_END_HINT, NULL);
 
 		vf_unreg_provider(&vvp9_vf_prov);
 		pbi->stat &= ~STAT_VF_HOOK;
 	}
-
 	vp9_local_uninit(pbi);
 
-	if (use_cma) {
-		/*USE_BUF_BLOCK*/
-		uninit_buf_list(pbi);
-		pr_info("uninit list\n");
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (pbi->m_ins_flag) {
+		cancel_work_sync(&pbi->work);
+	} else {
+		amhevc_disable();
 	}
-
+#else
 	amhevc_disable();
+#endif
+	uninit_mmu_buffers(pbi);
 
 	return 0;
 }
 
+static int amvdec_vp9_mmu_init(struct VP9Decoder_s *pbi)
+{
+#ifdef VP9_10B_MMU
+	pbi->mmu_box = decoder_mmu_box_alloc_box(DRIVER_NAME,
+		0, FRAME_BUFFERS,
+		48 * SZ_1M
+		);
+	if (!pbi->mmu_box) {
+		pr_err("vp9 alloc mmu box failed!!\n");
+		return -1;
+	}
+#endif
+	pbi->bmmu_box = decoder_bmmu_box_alloc_box(
+			DRIVER_NAME,
+			pbi->index,
+			MAX_BMMU_BUFFER_NUM,
+			4 + PAGE_SHIFT,
+			CODEC_MM_FLAGS_CMA_CLEAR |
+			CODEC_MM_FLAGS_FOR_VDECODER);
+	if (!pbi->bmmu_box) {
+		pr_err("vp9 alloc bmmu box failed!!\n");
+		return -1;
+	}
+	return 0;
+}
 static int amvdec_vp9_probe(struct platform_device *pdev)
 {
-	struct vdec_dev_reg_s *pdata =
-		(struct vdec_dev_reg_s *)pdev->dev.platform_data;
-	int i;
-	u32 predisp_addr;
-	unsigned long pre_last_frame_alloc_addr, pre_last_frame_alloc_size;
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
 	struct BUF_s BUF[MAX_BUF_NUM];
 	struct VP9Decoder_s *pbi = &gHevc;
+	pr_info("%s\n", __func__);
 	mutex_lock(&vvp9_mutex);
-	predisp_addr = pbi->predisp_addr;
-	pre_last_frame_alloc_addr = pbi->pre_last_frame_alloc_addr;
-	pre_last_frame_alloc_size = pbi->pre_last_frame_alloc_size;
+
 	memcpy(&BUF[0], &pbi->m_BUF[0], sizeof(struct BUF_s) * MAX_BUF_NUM);
 	memset(pbi, 0, sizeof(VP9Decoder));
 	memcpy(&pbi->m_BUF[0], &BUF[0], sizeof(struct BUF_s) * MAX_BUF_NUM);
-	pbi->predisp_addr = predisp_addr;
-	pbi->pre_last_frame_alloc_addr = pre_last_frame_alloc_addr;
-	pbi->pre_last_frame_alloc_size = pre_last_frame_alloc_size;
 
 	pbi->init_flag = 0;
 	pbi->fatal_error = 0;
@@ -5758,11 +6179,19 @@ static int amvdec_vp9_probe(struct platform_device *pdev)
 		mutex_unlock(&vvp9_mutex);
 		return -EFAULT;
 	}
-
+	pbi->m_ins_flag = 0;
+#ifdef MULTI_INSTANCE_SUPPORT
+	pbi->buf_start = pdata->mem_start;
+	pbi->buf_size = pdata->mem_end - pdata->mem_start + 1;
+#else
 	pbi->mc_buf_spec.buf_end = pdata->mem_end + 1;
 	for (i = 0; i < WORK_BUF_SPEC_NUM; i++)
 		amvvp9_workbuff_spec[i].start_adr = pdata->mem_start;
-
+#endif
+	if (amvdec_vp9_mmu_init(pbi) < 0) {
+		pr_err("vp9 alloc bmmu box failed!!\n");
+		return -1;
+	}
 	if (debug) {
 		pr_info("===VP9 decoder mem resource 0x%lx -- 0x%lx\n",
 			   pdata->mem_start, pdata->mem_end + 1);
@@ -5775,8 +6204,12 @@ static int amvdec_vp9_probe(struct platform_device *pdev)
 		pbi->vvp9_amstream_dec_info.height = 0;
 		pbi->vvp9_amstream_dec_info.rate = 30;
 	}
-
+#ifdef MULTI_INSTANCE_SUPPORT
+	pbi->cma_dev = pdata->cma_dev;
+#else
 	cma_dev = pdata->cma_dev;
+#endif
+	pdata->dec_status = vvp9_dec_status;
 
 	if (vvp9_init(pbi) < 0) {
 		pr_info("\namvdec_vp9 init failed.\n");
@@ -5822,8 +6255,8 @@ static struct platform_driver amvdec_vp9_driver = {
 	.probe = amvdec_vp9_probe,
 	.remove = amvdec_vp9_remove,
 #ifdef CONFIG_PM
-	.suspend = amvdec_suspend,
-	.resume = amvdec_resume,
+	.suspend = amhevc_suspend,
+	.resume = amhevc_resume,
 #endif
 	.driver = {
 		.name = DRIVER_NAME,
@@ -5835,6 +6268,471 @@ static struct codec_profile_t amvdec_vp9_profile = {
 	.profile = ""
 };
 
+#ifdef MULTI_INSTANCE_SUPPORT
+static unsigned int start_decode_buf_level = 0x8000;
+#ifdef VP9_10B_MMU
+static u32 work_buf_size = 24 * 1024 * 1024;
+#else
+static u32 work_buf_size = 32 * 1024 * 1024;
+#endif
+
+static unsigned char decoder_id_used[MAX_DECODE_INSTANCE_NUM];
+static unsigned int get_free_decoder_id(struct vdec_s *vdec)
+{
+	/*stream base decoder always has id of 0*/
+	int i;
+	if (vdec_frame_based(vdec)) {
+		for (i = 1; i < decoder_id_used[i]; i++) {
+			if (!decoder_id_used[i]) {
+				decoder_id_used[i] = 1;
+				return i;
+			}
+		}
+	}
+	return 0;
+}
+
+static unsigned char get_data_check_sum
+	(struct VP9Decoder_s *pbi, int size)
+{
+	int jj;
+	int sum = 0;
+	u8 *data = ((u8 *)pbi->chunk->block->start_virt) +
+		pbi->chunk->offset;
+	for (jj = 0; jj < size; jj++)
+		sum += data[jj];
+	return sum;
+}
+
+static void dump_data(struct VP9Decoder_s *pbi, int size)
+{
+	int jj;
+	u8 *data = ((u8 *)pbi->chunk->block->start_virt) +
+		pbi->chunk->offset;
+	for (jj = 0; jj < size; jj++) {
+		if ((jj & 0xf) == 0)
+			vp9_print(pbi,
+				0,
+				"%06x:", jj);
+		vp9_print_cont(pbi,
+			0,
+			"%02x ", data[jj]);
+		if (((jj + 1) & 0xf) == 0)
+			vp9_print(pbi,
+			 0,
+				"\n");
+	}
+	vp9_print(pbi,
+	 0,
+		"\n");
+}
+
+static void vp9_work(struct work_struct *work)
+{
+	struct VP9Decoder_s *pbi = container_of(work,
+		struct VP9Decoder_s, work);
+	struct VP9_Common_s *const cm = &pbi->common;
+	struct vdec_s *vdec = hw_to_vdec(pbi);
+	/* finished decoding one frame or error,
+	 * notify vdec core to switch context
+	 */
+
+	if ((pbi->dec_result == DEC_RESULT_GET_DATA) ||
+		(pbi->dec_result == DEC_RESULT_GET_DATA_RETRY)) {
+		if (pbi->dec_result == DEC_RESULT_GET_DATA) {
+			vp9_print(pbi, PRINT_FLAG_VDEC_STATUS,
+				"%s DEC_RESULT_GET_DATA %x %x %x\n",
+				__func__,
+				READ_VREG(HEVC_STREAM_LEVEL),
+				READ_VREG(HEVC_STREAM_WR_PTR),
+				READ_VREG(HEVC_STREAM_RD_PTR));
+			vdec_vframe_dirty(vdec, pbi->chunk);
+			vdec_clean_input(vdec);
+		}
+
+		if (!is_buffer_empty(cm)) {
+			int r;
+			r = vdec_prepare_input(vdec, &pbi->chunk);
+			if (r < 0) {
+				pbi->dec_result = DEC_RESULT_GET_DATA_RETRY;
+
+				vp9_print(pbi,
+					PRINT_FLAG_VDEC_DETAIL,
+					"amvdec_vh265: Insufficient data\n");
+
+				schedule_work(&pbi->work);
+				return;
+			}
+			pbi->dec_result = DEC_RESULT_NONE;
+			vp9_print(pbi, PRINT_FLAG_VDEC_STATUS,
+				"%s: chunk size 0x%x sum 0x%x\n",
+				__func__, r,
+				(debug & PRINT_FLAG_VDEC_STATUS) ?
+				get_data_check_sum(pbi, r) : 0
+				);
+
+			if (debug & PRINT_FLAG_VDEC_DATA)
+				dump_data(pbi, pbi->chunk->size);
+			WRITE_VREG(HEVC_DECODE_SIZE, r);
+
+			vdec_enable_input(vdec);
+
+			WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
+		} else{
+			pbi->dec_result = DEC_RESULT_GET_DATA_RETRY;
+
+			vp9_print(pbi, PRINT_FLAG_VDEC_DETAIL,
+				"amvdec_vh265: Insufficient data\n");
+
+			schedule_work(&pbi->work);
+		}
+		return;
+	} else if (pbi->dec_result == DEC_RESULT_DONE) {
+		/* if (!pbi->ctx_valid)
+			pbi->ctx_valid = 1; */
+		vp9_print(pbi, PRINT_FLAG_VDEC_STATUS,
+			"%s dec_result %d %x %x %x\n",
+			__func__,
+			pbi->dec_result,
+			READ_VREG(HEVC_STREAM_LEVEL),
+			READ_VREG(HEVC_STREAM_WR_PTR),
+			READ_VREG(HEVC_STREAM_RD_PTR));
+		vdec_vframe_dirty(hw_to_vdec(pbi), pbi->chunk);
+	} else {
+		vp9_print(pbi, PRINT_FLAG_VDEC_DETAIL,
+			"%s dec_result %d %x %x %x\n",
+			__func__,
+			pbi->dec_result,
+			READ_VREG(HEVC_STREAM_LEVEL),
+			READ_VREG(HEVC_STREAM_WR_PTR),
+			READ_VREG(HEVC_STREAM_RD_PTR));
+	}
+
+	/* mark itself has all HW resource released and input released */
+	vdec_set_status(hw_to_vdec(pbi), VDEC_STATUS_CONNECTED);
+
+	if (pbi->vdec_cb)
+		pbi->vdec_cb(hw_to_vdec(pbi), pbi->vdec_cb_arg);
+}
+
+static int vp9_hw_ctx_restore(struct VP9Decoder_s *pbi)
+{
+	/* new to do ... */
+	vvp9_prot_init(pbi);
+	return 0;
+}
+
+static bool run_ready(struct vdec_s *vdec)
+{
+	struct VP9Decoder_s *pbi =
+		(struct VP9Decoder_s *)vdec->private;
+	struct VP9_Common_s *const cm = &pbi->common;
+
+	vp9_print(pbi,
+		PRINT_FLAG_VDEC_DETAIL, "%s\r\n", __func__);
+
+	if ((!vdec_frame_based(vdec)) && (start_decode_buf_level > 0)) {
+		u32 rp, wp;
+		u32 level;
+
+		rp = READ_MPEG_REG(PARSER_VIDEO_RP);
+		wp = READ_MPEG_REG(PARSER_VIDEO_WP);
+
+		if (wp < rp)
+			level = vdec->input.size + wp - rp;
+		else
+			level = wp - rp;
+
+		if (level < start_decode_buf_level) {
+			vp9_print(pbi, 0,
+				"level %d not run_ready\n", level);
+			return false;
+		}
+	} else if (vdec_frame_based(vdec)) {
+		if (!vdec_input_next_input_chunk(&vdec->input))
+			return false;
+	}
+
+	return !is_buffer_empty(cm);
+}
+
+static void reset_dec_hw(struct vdec_s *vdec)
+{
+	if (input_frame_based(vdec))
+		WRITE_VREG(HEVC_STREAM_CONTROL, 0);
+
+		/*
+	 * 2: assist
+	 * 3: parser
+	 * 4: parser_state
+	 * 8: dblk
+	 * 11:mcpu
+	 * 12:ccpu
+	 * 13:ddr
+	 * 14:iqit
+	 * 15:ipp
+	 * 17:qdct
+	 * 18:mpred
+	 * 19:sao
+	 * 24:hevc_afifo
+	 */
+	WRITE_VREG(DOS_SW_RESET3,
+		(1<<3)|(1<<4)|(1<<8)|(1<<11)|(1<<12)|(1<<14)|(1<<15)|
+		(1<<17)|(1<<18)|(1<<19));
+	WRITE_VREG(DOS_SW_RESET3, 0);
+}
+
+static void run(struct vdec_s *vdec,
+	void (*callback)(struct vdec_s *, void *), void *arg)
+{
+	struct VP9Decoder_s *pbi =
+		(struct VP9Decoder_s *)vdec->private;
+	int r;
+
+	pbi->vdec_cb_arg = arg;
+	pbi->vdec_cb = callback;
+	/* pbi->chunk = vdec_prepare_input(vdec); */
+	reset_dec_hw(vdec);
+
+	r = vdec_prepare_input(vdec, &pbi->chunk);
+	if (r < 0) {
+		pbi->dec_result = DEC_RESULT_AGAIN;
+
+		vp9_print(pbi, PRINT_FLAG_VDEC_DETAIL,
+			"ammvdec_vh265: Insufficient data\n");
+
+		schedule_work(&pbi->work);
+		return;
+	}
+	pbi->dec_result = DEC_RESULT_NONE;
+
+	vp9_print(pbi, PRINT_FLAG_VDEC_STATUS,
+		"%s: size 0x%x sum 0x%x (%x %x %x)\n",
+		__func__, r,
+		(vdec_frame_based(vdec) &&
+		(debug & PRINT_FLAG_VDEC_STATUS)) ?
+		get_data_check_sum(pbi, r) : 0,
+	READ_VREG(HEVC_STREAM_LEVEL),
+	READ_VREG(HEVC_STREAM_WR_PTR),
+	READ_VREG(HEVC_STREAM_RD_PTR));
+
+	if (amhevc_loadmc_ex(VFORMAT_VP9, "vvp9_mc", NULL) < 0) {
+		amhevc_disable();
+		vp9_print(pbi, 0,
+			"%s: Error amvdec_loadmc fail\n", __func__);
+		return;
+	}
+
+	if (vp9_hw_ctx_restore(pbi) < 0) {
+		schedule_work(&pbi->work);
+		return;
+	}
+
+	vdec_enable_input(vdec);
+
+	WRITE_VREG(HEVC_DEC_STATUS_REG, HEVC_ACTION_DONE);
+
+	if (vdec_frame_based(vdec)) {
+		if (debug & PRINT_FLAG_VDEC_DATA)
+			dump_data(pbi, pbi->chunk->size);
+
+		WRITE_VREG(HEVC_SHIFT_BYTE_COUNT, 0);
+	}
+	WRITE_VREG(HEVC_DECODE_SIZE, r);
+	WRITE_VREG(HEVC_DECODE_COUNT, pbi->slice_idx);
+	pbi->init_flag = 1;
+
+	vp9_print(pbi, PRINT_FLAG_VDEC_STATUS,
+		"%s: start hevc (%x %x %x)\n",
+		__func__,
+		READ_VREG(HEVC_DEC_STATUS_REG),
+		READ_VREG(HEVC_MPC_E),
+		READ_VREG(HEVC_MPSR));
+
+	amhevc_start();
+
+}
+
+static void reset(struct vdec_s *vdec)
+{
+
+	struct VP9Decoder_s *pbi =
+		(struct VP9Decoder_s *)vdec->private;
+
+	vp9_print(pbi,
+		PRINT_FLAG_VDEC_DETAIL, "%s\r\n", __func__);
+
+}
+
+static irqreturn_t vp9_irq_cb(struct vdec_s *vdec)
+{
+	struct VP9Decoder_s *pbi =
+		(struct VP9Decoder_s *)vdec->private;
+	return vvp9_isr(0, pbi);
+}
+
+static irqreturn_t vp9_threaded_irq_cb(struct vdec_s *vdec)
+{
+	struct VP9Decoder_s *pbi =
+		(struct VP9Decoder_s *)vdec->private;
+	return vvp9_isr_thread_fn(0, pbi);
+}
+
+
+static int ammvdec_vp9_probe(struct platform_device *pdev)
+{
+	struct vdec_s *pdata = *(struct vdec_s **)pdev->dev.platform_data;
+
+	struct BUF_s BUF[MAX_BUF_NUM];
+	struct VP9Decoder_s *pbi = NULL;
+	pr_info("%s\n", __func__);
+	if (pdata == NULL) {
+		pr_info("\nammvdec_vp9 memory resource undefined.\n");
+		return -EFAULT;
+	}
+	pbi = (struct VP9Decoder_s *)devm_kzalloc(&pdev->dev,
+		sizeof(struct VP9Decoder_s), GFP_KERNEL);
+	if (pbi == NULL) {
+		pr_info("\nammvdec_vp9 device data allocation failed\n");
+		return -ENOMEM;
+	}
+	pdata->private = pbi;
+	pdata->dec_status = vvp9_dec_status;
+	/* pdata->set_trickmode = set_trickmode; */
+	pdata->run_ready = run_ready;
+	pdata->run = run;
+	pdata->reset = reset;
+	pdata->irq_handler = vp9_irq_cb;
+	pdata->threaded_irq_handler = vp9_threaded_irq_cb;
+
+	pdata->id = pdev->id;
+
+
+	memcpy(&BUF[0], &pbi->m_BUF[0], sizeof(struct BUF_s) * MAX_BUF_NUM);
+	memset(pbi, 0, sizeof(VP9Decoder));
+	memcpy(&pbi->m_BUF[0], &BUF[0], sizeof(struct BUF_s) * MAX_BUF_NUM);
+
+	pbi->index = get_free_decoder_id(pdata);
+
+	if (pdata->use_vfm_path)
+		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
+			VFM_DEC_PROVIDER_NAME);
+	else
+		snprintf(pdata->vf_provider_name, VDEC_PROVIDER_NAME_SIZE,
+			MULTI_INSTANCE_PROVIDER_NAME ".%02x", pdev->id & 0xff);
+
+	vf_provider_init(&pdata->vframe_provider, pdata->vf_provider_name,
+		&vvp9_vf_provider, pbi);
+
+	pbi->provider_name = pdata->vf_provider_name;
+	platform_set_drvdata(pdev, pdata);
+
+	pbi->platform_dev = pdev;
+#if 0
+	pbi->buf_start = pdata->mem_start;
+	pbi->buf_size = pdata->mem_end - pdata->mem_start + 1;
+#else
+	if (amvdec_vp9_mmu_init(pbi) < 0) {
+		pr_err("vp9 alloc bmmu box failed!!\n");
+		devm_kfree(&pdev->dev, (void *)pbi);
+		return -1;
+	}
+
+	pbi->cma_alloc_count = PAGE_ALIGN(work_buf_size) / PAGE_SIZE;
+	if (!decoder_bmmu_box_alloc_idx_wait(
+			pbi->bmmu_box,
+			WORK_SPACE_BUF_ID,
+			pbi->cma_alloc_count * PAGE_SIZE,
+			-1,
+			-1,
+			BMMU_ALLOC_FLAGS_WAITCLEAR
+			))	{
+		pbi->cma_alloc_addr = decoder_bmmu_box_get_phy_addr(
+					pbi->bmmu_box,
+					WORK_SPACE_BUF_ID);
+	} else {
+		vp9_print(pbi, 0,
+			"codec_mm alloc failed, request buf size 0x%lx\n",
+				pbi->cma_alloc_count * PAGE_SIZE);
+		pbi->cma_alloc_count = 0;
+		uninit_mmu_buffers(pbi);
+		devm_kfree(&pdev->dev, (void *)pbi);
+		return -ENOMEM;
+	}
+	pbi->buf_start = pbi->cma_alloc_addr;
+	pbi->buf_size = work_buf_size;
+#endif
+	pbi->m_ins_flag = 1;
+
+	pbi->init_flag = 0;
+	pbi->fatal_error = 0;
+	pbi->show_frame_num = 0;
+	if (pdata == NULL) {
+		pr_info("\namvdec_vp9 memory resource undefined.\n");
+		uninit_mmu_buffers(pbi);
+		devm_kfree(&pdev->dev, (void *)pbi);
+		return -EFAULT;
+	}
+
+	if (debug) {
+		pr_info("===VP9 decoder mem resource 0x%lx -- 0x%lx\n",
+			   pbi->buf_start,
+			   pbi->buf_start + pbi->buf_size);
+	}
+
+	if (pdata->sys_info)
+		pbi->vvp9_amstream_dec_info = *pdata->sys_info;
+	else {
+		pbi->vvp9_amstream_dec_info.width = 0;
+		pbi->vvp9_amstream_dec_info.height = 0;
+		pbi->vvp9_amstream_dec_info.rate = 30;
+	}
+
+	pbi->cma_dev = pdata->cma_dev;
+
+	if (vvp9_init(pbi) < 0) {
+		pr_info("\namvdec_vp9 init failed.\n");
+		vp9_local_uninit(pbi);
+		uninit_mmu_buffers(pbi);
+		devm_kfree(&pdev->dev, (void *)pbi);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static int ammvdec_vp9_remove(struct platform_device *pdev)
+{
+	struct VP9Decoder_s *pbi = (struct VP9Decoder_s *)
+		(((struct vdec_s *)(platform_get_drvdata(pdev)))->private);
+	if (debug)
+		pr_info("amvdec_vp9_remove\n");
+
+	vvp9_stop(pbi);
+
+	vdec_set_status(hw_to_vdec(pbi), VDEC_STATUS_DISCONNECTED);
+
+
+#ifdef DEBUG_PTS
+	pr_info("pts missed %ld, pts hit %ld, duration %d\n",
+		   pbi->pts_missed, pbi->pts_hit, pbi->frame_dur);
+#endif
+	devm_kfree(&pdev->dev, (void *)pbi);
+	return 0;
+}
+
+static struct platform_driver ammvdec_vp9_driver = {
+	.probe = ammvdec_vp9_probe,
+	.remove = ammvdec_vp9_remove,
+#ifdef CONFIG_PM
+	.suspend = amvdec_suspend,
+	.resume = amvdec_resume,
+#endif
+	.driver = {
+		.name = MULTI_DRIVER_NAME,
+	}
+};
+#endif
+
 static int __init amvdec_vp9_driver_init_module(void)
 {
 	pr_debug("amvdec_vp9 module init\n");
@@ -5850,7 +6748,11 @@ static int __init amvdec_vp9_driver_init_module(void)
 	slice_parse_begin = 0;
 	step = 0;
 	buf_alloc_size = 0;
+#ifdef MULTI_INSTANCE_SUPPORT
+	if (platform_driver_register(&ammvdec_vp9_driver))
+		pr_err("failed to register ammvdec_vp9 driver\n");
 
+#endif
 	if (platform_driver_register(&amvdec_vp9_driver)) {
 		pr_err("failed to register amvdec_vp9 driver\n");
 		return -ENODEV;
@@ -5871,7 +6773,9 @@ static int __init amvdec_vp9_driver_init_module(void)
 static void __exit amvdec_vp9_driver_remove_module(void)
 {
 	pr_debug("amvdec_vp9 module remove.\n");
-
+#ifdef MULTI_INSTANCE_SUPPORT
+	platform_driver_unregister(&ammvdec_vp9_driver);
+#endif
 	platform_driver_unregister(&amvdec_vp9_driver);
 }
 
@@ -5904,6 +6808,9 @@ MODULE_PARM_DESC(radr, "\nradr\n");
 module_param(rval, uint, 0664);
 MODULE_PARM_DESC(rval, "\nrval\n");
 
+module_param(pop_shorts, uint, 0664);
+MODULE_PARM_DESC(pop_shorts, "\nrval\n");
+
 module_param(dbg_cmd, uint, 0664);
 MODULE_PARM_DESC(dbg_cmd, "\dbg_cmd\n");
 
@@ -5979,6 +6886,12 @@ MODULE_PARM_DESC(max_decoding_time, "\n max_decoding_time\n");
 module_param(on_no_keyframe_skiped, uint, 0664);
 MODULE_PARM_DESC(on_no_keyframe_skiped, "\n on_no_keyframe_skiped\n");
 
+#ifdef MULTI_INSTANCE_SUPPORT
+module_param(start_decode_buf_level, uint, 0664);
+MODULE_PARM_DESC(start_decode_buf_level,
+		"\n ammvdec_h264 start_decode_buf_level\n");
+#endif
+
 module_init(amvdec_vp9_driver_init_module);
 module_exit(amvdec_vp9_driver_remove_module);
 
diff --git a/drivers/amlogic/amports/vvp9.h b/drivers/amlogic/amports/vvp9.h
index 1413f71..4cf3254 100644
--- a/drivers/amlogic/amports/vvp9.h
+++ b/drivers/amlogic/amports/vvp9.h
@@ -17,15 +17,8 @@
 
 #ifndef VVP9_H
 #define VVP9_H
-
-#ifdef VP9_10B_MMU
-void init_mmu_spec(void);
-void alloc_mmu(int cur_buf_idx, int pic_width, int pic_height,
-		unsigned short bit_depth, unsigned int *mmu_index_adr);
-void release_unused_4k(long used_4k_num, int cur_buf_idx);
-void release_buffer_4k(int cur_buf_idx);
-int  compute_losless_comp_body_size(int width, int height,
-		unsigned char bit_depth_10);
+#ifndef CONFIG_MULTI_DEC
+#define VP9_10B_MMU
 #endif
 void adapt_coef_probs(int pic_count, int prev_kf, int cur_kf, int pre_fc,
 unsigned int *prev_prob, unsigned int *cur_prob, unsigned int *count);
diff --git a/drivers/amlogic/amvecm/Makefile b/drivers/amlogic/amvecm/Makefile
index 59cb2a1..c98b58e 100644
--- a/drivers/amlogic/amvecm/Makefile
+++ b/drivers/amlogic/amvecm/Makefile
@@ -2,6 +2,7 @@
 # AMLOGIC VE & CM.
 #
 
+ccflags-y := -I$(PWD)/$(src)/dolby_vision/
 obj-$(CONFIG_AM_VECM) += am_vecm.o
-am_vecm-objs := amve.o amcm.o amcsc.o amvecm.o
+am_vecm-objs := amve.o amcm.o amcsc.o amvecm.o amdolby_vision.o
 
diff --git a/drivers/amlogic/amvecm/amcm.c b/drivers/amlogic/amvecm/amcm.c
index 5005d45..84dee3d 100644
--- a/drivers/amlogic/amvecm/amcm.c
+++ b/drivers/amlogic/amvecm/amcm.c
@@ -203,11 +203,14 @@ void am_set_regmap(struct am_regs_s *p)
 						sr1_regs[sr1_temp].val;
 				aml_write_vcbus(p->am_reg[i].addr,
 					sr1_regs[sr1_temp].val);
-			} else
+			} else {
+				if (p->am_reg[i].addr == 0x1d26)
+					break;
 				aml_write_vcbus(p->am_reg[i].addr,
 					(aml_read_vcbus(p->am_reg[i].addr) &
 					(~(p->am_reg[i].mask))) |
 					(p->am_reg[i].val & p->am_reg[i].mask));
+			}
 			break;
 /* #endif */
 		default:
@@ -219,12 +222,26 @@ void am_set_regmap(struct am_regs_s *p)
 
 void amcm_disable(void)
 {
-	WRITE_VPP_REG_BITS(VPP_MISC, 0, 28, 1);
+	int temp;
+	WRITE_VPP_REG(VPP_CHROMA_ADDR_PORT, 0x208);
+	temp = READ_VPP_REG(VPP_CHROMA_DATA_PORT);
+	if (temp & 0x2) {
+		WRITE_VPP_REG(VPP_CHROMA_ADDR_PORT, 0x208);
+		WRITE_VPP_REG(VPP_CHROMA_DATA_PORT, temp & 0xfffffffd);
+	}
 }
 
 void amcm_enable(void)
 {
-	WRITE_VPP_REG_BITS(VPP_MISC, 1, 28, 1);
+	int temp;
+	if (!(READ_VPP_REG(VPP_MISC) & (0x1 << 28)))
+		WRITE_VPP_REG_BITS(VPP_MISC, 1, 28, 1);
+	WRITE_VPP_REG(VPP_CHROMA_ADDR_PORT, 0x208);
+	temp = READ_VPP_REG(VPP_CHROMA_DATA_PORT);
+	if (!(temp & 0x2)) {
+		WRITE_VPP_REG(VPP_CHROMA_ADDR_PORT, 0x208);
+		WRITE_VPP_REG(VPP_CHROMA_DATA_PORT, temp | 0x2);
+	}
 }
 
 
@@ -237,6 +254,7 @@ void cm_regmap_latch(struct am_regs_s *am_regs, unsigned int reg_map)
 
 void amcm_level_sel(unsigned int cm_level)
 {
+	int temp;
 	if (cm_level == 1)
 		am_set_regmap(&cmreg_lever1);
 	else if (cm_level == 2)
@@ -247,7 +265,17 @@ void amcm_level_sel(unsigned int cm_level)
 		am_set_regmap(&cmreg_enhancement);
 	else
 		am_set_regmap(&cmreg_optimize);
-	WRITE_VPP_REG_BITS(VPP_MISC, 1, 28, 1);
+
+	if (!(READ_VPP_REG(VPP_MISC) & (0x1 << 28)))
+		WRITE_VPP_REG_BITS(VPP_MISC, 1, 28, 1);
+
+	WRITE_VPP_REG(VPP_CHROMA_ADDR_PORT, 0x208);
+	temp = READ_VPP_REG(VPP_CHROMA_DATA_PORT);
+	if (!(temp & 0x2)) {
+		WRITE_VPP_REG(VPP_CHROMA_ADDR_PORT, 0x208);
+		WRITE_VPP_REG(VPP_CHROMA_DATA_PORT, temp | 0x2);
+	}
+
 }
 
 void cm2_frame_size_patch(unsigned int width, unsigned int height)
@@ -255,11 +283,9 @@ void cm2_frame_size_patch(unsigned int width, unsigned int height)
 	unsigned int vpp_size;
 	if (width < cm_width_limit)
 		amcm_disable();
-	else if (cm_en)
-		amcm_enable();
-	/*check if the cm2 enable/disable to config the cm2 size*/
-	if (!(READ_VPP_REG(VPP_MISC)&(0x1<<28)))
+	if (!cm_en)
 		return;
+
 	vpp_size = width|(height << 16);
 	if (cm_size != vpp_size) {
 		WRITE_VPP_REG(VPP_CHROMA_ADDR_PORT, 0x205);
@@ -322,7 +348,7 @@ void cm_latch_process(void)
 	} while (0);
 	if (cm_en && (cm_level_last != cm_level)) {
 		cm_level_last = cm_level;
-		if (!is_meson_gxtvbb_cpu())
+		if ((!is_meson_gxtvbb_cpu()) && (!is_meson_txl_cpu()))
 			amcm_level_sel(cm_level);
 		amcm_enable();
 		pr_amcm_dbg("\n[amcm..] set cm2 load OK!!!\n");
diff --git a/drivers/amlogic/amvecm/amcsc.c b/drivers/amlogic/amvecm/amcsc.c
index 3209eaf..cb0d7ba 100644
--- a/drivers/amlogic/amvecm/amcsc.c
+++ b/drivers/amlogic/amvecm/amcsc.c
@@ -20,6 +20,7 @@
 #include "arch/vpp_regs.h"
 #include "../tvin/tvin_global.h"
 #include "arch/vpp_hdr_regs.h"
+#include "arch/hdr_curve.h"
 
 /* use osd rdma reg w/r */
 #include "../display/osd/osd_rdma.h"
@@ -34,6 +35,8 @@
 
 signed int vd1_contrast_offset;
 
+signed int saturation_offset;
+
 struct hdr_osd_reg_s hdr_osd_reg = {
 	0x00000001, /* VIU_OSD1_MATRIX_CTRL 0x1a90 */
 	0x00ba0273, /* VIU_OSD1_MATRIX_COEF00_01 0x1a91 */
@@ -41,7 +44,7 @@ struct hdr_osd_reg_s hdr_osd_reg = {
 	0x1ea801c0, /* VIU_OSD1_MATRIX_COEF11_12 0x1a93 */
 	0x01c01e6a, /* VIU_OSD1_MATRIX_COEF20_21 0x1a94 */
 	0x00000000, /* VIU_OSD1_MATRIX_COLMOD_COEF42 0x1a95 */
-	0x00000200, /* VIU_OSD1_MATRIX_OFFSET0_1 0x1a96 */
+	0x00400200, /* VIU_OSD1_MATRIX_OFFSET0_1 0x1a96 */
 	0x00000200, /* VIU_OSD1_MATRIX_PRE_OFFSET2 0x1a97 */
 	0x00000000, /* VIU_OSD1_MATRIX_PRE_OFFSET0_1 0x1a98 */
 	0x00000000, /* VIU_OSD1_MATRIX_PRE_OFFSET2 0x1a99 */
@@ -54,7 +57,7 @@ struct hdr_osd_reg_s hdr_osd_reg = {
 	0x08000000, /* VIU_OSD1_EOTF_COEF11_12 0x1ad7 */
 	0x00000000, /* VIU_OSD1_EOTF_COEF20_21 0x1ad8 */
 	0x08000001, /* VIU_OSD1_EOTF_COEF22_RS 0x1ad9 */
-	0x00000000, /* VIU_OSD1_OETF_CTL 0x1adc */
+	0x01c00000, /* VIU_OSD1_OETF_CTL 0x1adc */
 	{
 		/* eotf table */
 		{ /* r map */
@@ -82,7 +85,7 @@ struct hdr_osd_reg_s hdr_osd_reg = {
 			0x3c00, 0x3e00, 0x4000
 		},
 		/* oetf table */
-		{ /* ob map */
+		{ /* or map */
 			0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 			0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 			0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
@@ -91,7 +94,7 @@ struct hdr_osd_reg_s hdr_osd_reg = {
 			0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 			0x0000, 0x0000, 0x0000, 0x0000, 0x0000
 		},
-		{ /* ob map */
+		{ /* og map */
 			0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 			0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 			0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
@@ -157,6 +160,17 @@ static uint cur_hdr_process_mode = 2; /* 0: hdr->hdr, 1:hdr->sdr */
 module_param(hdr_process_mode, uint, 0444);
 MODULE_PARM_DESC(hdr_process_mode, "\n current hdr_process_mode\n");
 
+uint sdr_mode = 0; /* 0: sdr->sdr, 1:sdr->hdr, 2:auto */
+static uint sdr_process_mode = 2; /* 0: sdr->sdr, 1:sdr->hdr */
+static uint cur_sdr_process_mode = 2; /* 0: sdr->sdr, 1:sdr->hdr */
+static int sdr_saturation_offset = 20; /* 0: sdr->sdr, 1:sdr->hdr */
+module_param(sdr_mode, uint, 0664);
+MODULE_PARM_DESC(sdr_mode, "\n set sdr_mode\n");
+module_param(sdr_process_mode, uint, 0444);
+MODULE_PARM_DESC(sdr_process_mode, "\n current hdr_process_mode\n");
+module_param(sdr_saturation_offset, int, 0664);
+MODULE_PARM_DESC(sdr_saturation_offset, "\n add saturation\n");
+
 static uint force_csc_type = 0xff;
 module_param(force_csc_type, uint, 0664);
 MODULE_PARM_DESC(force_csc_type, "\n force colour space convert type\n");
@@ -165,31 +179,123 @@ static uint cur_hdr_support;
 module_param(cur_hdr_support, uint, 0664);
 MODULE_PARM_DESC(cur_hdr_support, "\n cur_hdr_support\n");
 
-#define MAX_KNEE_SETTING	11
+static uint range_control;
+module_param(range_control, uint, 0664);
+MODULE_PARM_DESC(range_control, "\n range_control 0:limit 1:full\n");
+
+/* bit 0: use source primary,
+   bit 1: use display primary,
+   bit 2: adjust contrast according to source lumin,
+   bit 3: adjust saturation according to source lumin */
+uint hdr_flag = (1 << 0) | (1 << 1) | (0 << 2) | (0 << 3);
+module_param(hdr_flag, uint, 0664);
+MODULE_PARM_DESC(hdr_flag, "\n set hdr_flag\n");
+
+static uint rdma_flag =
+	(1 << VPP_MATRIX_XVYCC);
+module_param(rdma_flag, uint, 0664);
+MODULE_PARM_DESC(rdma_flag, "\n set rdma_flag\n");
+
+#define MAX_KNEE_SETTING	35
 /* recommended setting for 100 nits panel: */
 /* 0,16,96,224,320,544,720,864,1000,1016,1023 */
 /* knee factor = 256 */
 static int num_knee_setting = MAX_KNEE_SETTING;
 static int knee_setting[MAX_KNEE_SETTING] = {
 	/* 0, 16, 96, 224, 320, 544, 720, 864, 1000, 1016, 1023 */
-	0, 16, 96, 204, 320, 512, 720, 864, 980, 1016, 1023
+	0, 16, 36, 59, 71, 96,
+	120, 145, 170, 204, 230, 258,
+	288, 320, 355, 390, 428, 470,
+	512, 554, 598, 650, 720, 758,
+	790, 832, 864, 894, 920, 945,
+	968, 980, 1000, 1016, 1023
 };
 
 static int num_knee_linear_setting = MAX_KNEE_SETTING;
 static int knee_linear_setting[MAX_KNEE_SETTING] = {
 	0x000,
 	0x010,
+	0x02f,
+	0x04e,
+	0x06d,
 	0x08c,
+	0x0ab,
+	0x0ca,
+	0x0e9,
 	0x108,
+	0x127,
+	0x146,
+	0x165,
 	0x184,
+	0x1a3,
+	0x1c2,
+	0x1e1,
 	0x200,
+	0x21f,
+	0x23e,
+	0x25d,
 	0x27c,
+	0x29b,
+	0x2ba,
+	0x2d9,
 	0x2f8,
+	0x317,
+	0x336,
+	0x355,
 	0x374,
+	0x393,
+	0x3b2,
+	0x3d1,
 	0x3f0,
 	0x3ff
 };
 
+static bool lut_289_en = 1;
+module_param(lut_289_en, bool, 0664);
+MODULE_PARM_DESC(lut_289_en, "\n if enable 289 lut\n");
+
+/*for gxtvbb(968), only 289 point lut for hdr curve set */
+/*default for 350nit panel*/
+unsigned int lut_289_mapping[LUT_289_SIZE] = {
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0x9, 0xa, 0xb, 0xd, 0xe, 0x10, 0x11, 0x12,
+	  0x14, 0x15, 0x17, 0x18, 0x1a, 0x1c, 0x1d, 0x1f,
+	  0x20, 0x22, 0x24, 0x26, 0x27, 0x29, 0x2b, 0x2d,
+	 0x2f,  0x31,  0x33,  0x35,  0x37,  0x39,  0x3b,  0x3d,
+	 0x40,  0x42,  0x44,  0x46,  0x49,  0x4b,  0x4e,  0x50,
+	 0x53,  0x55,  0x58,  0x5a,  0x5d,  0x60,  0x62,  0x65,
+	 0x68,  0x6b,  0x6e,  0x71,  0x74,  0x77,  0x7a,  0x7e,
+	 0x81,  0x84,  0x87,  0x8b,  0x8e,  0x92,  0x95,  0x99,
+	 0x9d,  0xa1,  0xa4,  0xa8,  0xac,  0xb0,  0xb4,  0xb8,
+	 0xbc,  0xc1,  0xc5,  0xc9,  0xce,  0xd2,  0xd7,  0xdc,
+	 0xe0,  0xe5,  0xea,  0xef,  0xf4,  0xf9,  0xfe,  0x104,
+	 0x109,  0x10e,  0x114,  0x11a,  0x11f,  0x125,  0x12b,  0x131,
+	 0x137,  0x13d,  0x143,  0x14a,  0x150,  0x156,  0x15d,  0x164,
+	 0x16b,  0x172,  0x179,  0x180,  0x187,  0x18e,  0x196,  0x19d,
+	 0x1a5,  0x1ad,  0x1b5,  0x1bd,  0x1c5,  0x1cd,  0x1d6,  0x1de,
+	 0x1e7,  0x1f0,  0x1f9,  0x202,  0x20b,  0x214,  0x21e,  0x227,
+	 0x231,  0x23b,  0x245,  0x24f,  0x25a,  0x264,  0x26f,  0x27a,
+	 0x285,  0x290,  0x29c,  0x2a7,  0x2b3,  0x2bf,  0x2cb,  0x2d7,
+	 0x2e3,  0x2f0,  0x2fd,  0x30a,  0x317,  0x325,  0x332,  0x33e,
+	 0x34a,  0x356,  0x362,  0x36d,  0x377,  0x381,  0x38b,  0x394,
+	 0x39c,  0x3a4,  0x3ac,  0x3b3,  0x3ba,  0x3c1,  0x3c7,  0x3cd,
+	 0x3d2,  0x3d7,  0x3db,  0x3df,  0x3e3,  0x3e6,  0x3e9,  0x3ec,
+	 0x3ef,  0x3f1,  0x3f3,  0x3f5,  0x3f6,  0x3f7,  0x3f8,  0x3f9,
+	 0x3fa,  0x3fa,  0x3fb,  0x3fb,  0x3fb,  0x3fc,  0x3fc,  0x3fc,
+	 0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,
+	 0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,
+	 0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,
+	 0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,
+	 0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,
+	 0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,
+	 0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,  0x3fc,
+	 0x3fc, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff,
+	0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff,
+	0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff, 0x3ff,
+	0x3ff
+};
+
 static int knee_factor; /* 0 ~ 256, 128 = 0.5 */
 static int knee_interpolation_mode = 1; /* 0: linear, 1: cubic */
 
@@ -209,14 +315,14 @@ MODULE_PARM_DESC(knee_interpolation_mode, "\n 0: linear, 1: cubic\n");
 static uint num_customer_matrix_param = NUM_MATRIX_PARAM;
 static uint customer_matrix_param[NUM_MATRIX_PARAM] = {
 	0, 0, 0,
-	0x0b77, 0x1c75, 0x0014,
-	0x1f90, 0x07ed, 0x0083,
-	0x0046, 0x1fb4, 0x0806,
+	0x0d49, 0x1b4d, 0x1f6b,
+	0x1f01, 0x0910, 0x1fef,
+	0x1fdb, 0x1f32, 0x08f3,
 	0, 0, 0,
 	1
 };
 
-static bool customer_matrix_en;
+static bool customer_matrix_en = true;
 
 #define INORM	50000
 #define BL		16
@@ -241,13 +347,69 @@ static u32 bt2020_white_point[2] = {
 	0.3127 * INORM + 0.5, 0.3290 * INORM + 0.5
 };
 
+/* 0: off, 1: on */
+static int customer_master_display_en;
+static uint num_customer_master_display_param = 12;
+static uint customer_master_display_param[12] = {
+	0.17 * INORM + 0.5, 0.797 * INORM + 0.5,      /* G */
+	0.131 * INORM + 0.5, 0.046 * INORM + 0.5,     /* B */
+	0.708 * INORM + 0.5, 0.292 * INORM + 0.5,     /* R */
+	0.3127 * INORM + 0.5, 0.3290 * INORM + 0.5,   /* W */
+	5000 * 10000, 50,
+	/* man/min lumin */
+	5000, 50
+	/* content lumin and frame average */
+};
+
 module_param(customer_matrix_en, bool, 0664);
 MODULE_PARM_DESC(customer_matrix_en, "\n if enable customer matrix\n");
 
 module_param_array(customer_matrix_param, uint,
 	&num_customer_matrix_param, 0664);
 MODULE_PARM_DESC(customer_matrix_param,
-	 "\n matrix from source primary to panel primary\n");
+	"\n matrix from source primary to panel primary\n");
+
+module_param(customer_master_display_en, int, 0664);
+MODULE_PARM_DESC(customer_master_display_en,
+	"\n if enable customer primaries and white point\n");
+
+module_param_array(customer_master_display_param, uint,
+	&num_customer_master_display_param, 0664);
+MODULE_PARM_DESC(customer_master_display_param,
+	"\n matrix from source primary and white point\n");
+
+/* 0: off, 1: on */
+static int customer_hdmi_display_en;
+static uint num_customer_hdmi_display_param = 14;
+static uint customer_hdmi_display_param[14] = {
+	9, /* color priamry = bt2020 */
+	16, /* characteristic = st2084 */
+	0.17 * INORM + 0.5, 0.797 * INORM + 0.5,      /* G */
+	0.131 * INORM + 0.5, 0.046 * INORM + 0.5,     /* B */
+	0.708 * INORM + 0.5, 0.292 * INORM + 0.5,     /* R */
+	0.3127 * INORM + 0.5, 0.3290 * INORM + 0.5,   /* W */
+	9997 * 10000, 0,
+	/* man/min lumin */
+	5000, 50
+	/* content lumin and frame average */
+};
+
+module_param(customer_hdmi_display_en, int, 0664);
+MODULE_PARM_DESC(customer_hdmi_display_en,
+	"\n if enable customer primaries and white point\n");
+
+module_param_array(customer_hdmi_display_param, uint,
+	&num_customer_hdmi_display_param, 0664);
+MODULE_PARM_DESC(customer_hdmi_display_param,
+	"\n matrix from source primary and white point\n");
+
+/* sat offset when > 1200 and <= 1200 */
+static uint num_extra_sat_lut = 2;
+static uint extra_sat_lut[] = {16, 32};
+module_param_array(extra_sat_lut, uint,
+	&num_extra_sat_lut, 0664);
+MODULE_PARM_DESC(extra_sat_lut,
+	 "\n lookup table for saturation match source luminance.\n");
 
 /* norm to 128 as 1, LUT can be changed */
 static uint num_extra_con_lut = 5;
@@ -323,7 +485,7 @@ static void load_knee_lut(int on)
 	int value;
 	int final_knee_setting[MAX_KNEE_SETTING];
 
-	if (cur_knee_factor != knee_factor) {
+	if ((cur_knee_factor != knee_factor) && (!lut_289_en)) {
 		pr_csc("Knee_factor changed from %d to %d\n",
 			cur_knee_factor, knee_factor);
 		for (i = 0; i < MAX_KNEE_SETTING; i++) {
@@ -350,20 +512,20 @@ static void load_knee_lut(int on)
 							j, i, value);
 			}
 			for (i = 16; i < 272; i++) {
-				k = 1 + ((i - 16) >> 5);
+				k = 1 + ((i - 16) >> 3);
 				WRITE_VPP_REG(XVYCC_LUT_R_ADDR_PORT + 2 * j, i);
 				if (knee_interpolation_mode == 0)
 					value = final_knee_setting[k]
 						+ (((final_knee_setting[k+1]
 						- final_knee_setting[k])
-						* ((i - 16) & 0x1f)) >> 5);
+						* ((i - 16) & 0x7)) >> 3);
 				else
 					value = cubic_interpolation(
 						final_knee_setting[k-1],
 						final_knee_setting[k],
 						final_knee_setting[k+1],
 						final_knee_setting[k+2],
-						((i - 16) & 0x1f) << 1);
+						((i - 16) & 0x7) << 3);
 				value = clip(value, 0, 0x3ff);
 				WRITE_VPP_REG(XVYCC_LUT_R_DATA_PORT + 2 * j,
 						value);
@@ -388,16 +550,62 @@ static void load_knee_lut(int on)
 		}
 		cur_knee_factor = knee_factor;
 	}
+
+	if ((cur_knee_factor != knee_factor) && (lut_289_en)) {
+			WRITE_VPP_REG(XVYCC_LUT_CTL, 0x0);
+			WRITE_VPP_REG(XVYCC_LUT_R_ADDR_PORT, 0);
+			for (i = 0; i < LUT_289_SIZE; i++)
+				WRITE_VPP_REG(XVYCC_LUT_R_DATA_PORT,
+					lut_289_mapping[i]);
+			WRITE_VPP_REG(XVYCC_LUT_R_ADDR_PORT + 2, 0);
+			for (i = 0; i < LUT_289_SIZE; i++)
+				WRITE_VPP_REG(XVYCC_LUT_R_DATA_PORT + 2,
+					lut_289_mapping[i]);
+			WRITE_VPP_REG(XVYCC_LUT_R_ADDR_PORT + 4, 0);
+			for (i = 0; i < LUT_289_SIZE; i++)
+				WRITE_VPP_REG(XVYCC_LUT_R_DATA_PORT + 4,
+					lut_289_mapping[i]);
+		cur_knee_factor = knee_factor;
+	}
+
 	if (on) {
 		WRITE_VPP_REG(XVYCC_LUT_CTL, 0x7f);
 		knee_lut_on = 1;
 	} else {
-		WRITE_VPP_REG(XVYCC_LUT_CTL, 0x0);
+		WRITE_VPP_REG(XVYCC_LUT_CTL, 0x0f);
 		knee_lut_on = 0;
 	}
 }
 
 /***************************** gxl hdr ****************************/
+#define EOTF_INV_LUT_NEG2048_SIZE 16 /* 16 for [-2048, 0), 32 for [0, 1024), 17 for [1024, 2048) */
+#define EOTF_INV_LUT_SIZE 32
+#define EOTF_INV_LUT_1024_SIZE 17
+
+static unsigned int num_invlut_neg_mapping = EOTF_INV_LUT_NEG2048_SIZE;
+static int invlut_y_neg[EOTF_INV_LUT_NEG2048_SIZE] = {
+	-2048, -1920, -1792, -1664,
+	-1536, -1408, -1280, -1152,
+	-1024, -896, -768, -640,
+	-512, -384, -256, -128
+};
+
+static unsigned int num_invlut_mapping = EOTF_INV_LUT_SIZE;
+static unsigned int invlut_y[EOTF_INV_LUT_SIZE] = {
+	0, 32, 64, 96, 128, 160, 192, 224,
+	256, 288, 320, 352, 384, 416, 448, 480,
+	512, 544, 576, 608, 640, 672, 704, 736,
+	768, 800, 832, 864, 896, 928, 960, 992
+};
+
+static unsigned int num_invlut_1024_mapping = EOTF_INV_LUT_1024_SIZE;
+static unsigned int invlut_y_1024[EOTF_INV_LUT_1024_SIZE] = {
+	1024, 1088, 1152, 1216,
+	1280, 1344, 1408, 1472,
+	1536, 1600, 1664, 1728,
+	1792, 1856, 1920, 1984,
+	2047
+};
 
 #define EOTF_LUT_SIZE 33
 static unsigned int num_osd_eotf_r_mapping = EOTF_LUT_SIZE;
@@ -502,49 +710,48 @@ static unsigned int reload_lut;
 
 /******************** osd oetf **************/
 
-#define OSD_OETF_LUT_SIZE 41
 static unsigned int num_osd_oetf_r_mapping = OSD_OETF_LUT_SIZE;
 static unsigned int osd_oetf_r_mapping[OSD_OETF_LUT_SIZE] = {
-		0, 150, 250, 330,
-		395, 445, 485, 520,
-		544, 632, 686, 725,
-		756, 782, 803, 822,
-		839, 854, 868, 880,
-		892, 902, 913, 922,
-		931, 939, 947, 954,
-		961, 968, 974, 981,
-		986, 993, 998, 1003,
-		1009, 1014, 1018, 1023,
-		0
+		0, 4, 8, 12,
+		16, 20, 24, 28,
+		31, 62, 93, 124,
+		155, 186, 217, 248,
+		279, 310, 341, 372,
+		403, 434, 465, 496,
+		527, 558, 589, 620,
+		651, 682, 713, 744,
+		775, 806, 837, 868,
+		899, 930, 961, 992,
+		1023
 };
 
 static unsigned int num_osd_oetf_g_mapping = OSD_OETF_LUT_SIZE;
 static unsigned int osd_oetf_g_mapping[OSD_OETF_LUT_SIZE] = {
-		0, 0, 0, 0,
-		0, 32, 64, 96,
-		128, 160, 196, 224,
-		256, 288, 320, 352,
-		384, 416, 448, 480,
-		512, 544, 576, 608,
-		640, 672, 704, 736,
-		768, 800, 832, 864,
-		896, 928, 960, 992,
-		1023, 1023, 1023, 1023,
+		0, 4, 8, 12,
+		16, 20, 24, 28,
+		31, 62, 93, 124,
+		155, 186, 217, 248,
+		279, 310, 341, 372,
+		403, 434, 465, 496,
+		527, 558, 589, 620,
+		651, 682, 713, 744,
+		775, 806, 837, 868,
+		899, 930, 961, 992,
 		1023
 };
 
 static unsigned int num_osd_oetf_b_mapping = OSD_OETF_LUT_SIZE;
 static unsigned int osd_oetf_b_mapping[OSD_OETF_LUT_SIZE] = {
-		0, 0, 0, 0,
-		0, 32, 64, 96,
-		128, 160, 196, 224,
-		256, 288, 320, 352,
-		384, 416, 448, 480,
-		512, 544, 576, 608,
-		640, 672, 704, 736,
-		768, 800, 832, 864,
-		896, 928, 960, 992,
-		1023, 1023, 1023, 1023,
+		0, 4, 8, 12,
+		16, 20, 24, 28,
+		31, 62, 93, 124,
+		155, 186, 217, 248,
+		279, 310, 341, 372,
+		403, 434, 465, 496,
+		527, 558, 589, 620,
+		651, 682, 713, 744,
+		775, 806, 837, 868,
+		899, 930, 961, 992,
 		1023
 };
 
@@ -757,6 +964,18 @@ module_param_array(osd_matrix_coeff, int,
 MODULE_PARM_DESC(osd_matrix_coeff, "\n coef for osd matrix\n");
 
 /****************** video eotf ********************/
+module_param_array(invlut_y_neg, int,
+	&num_invlut_neg_mapping, 0664);
+MODULE_PARM_DESC(invlut_y_neg, "\n lut for inv y -2048..0 eotf\n");
+
+module_param_array(invlut_y, uint,
+	&num_invlut_mapping, 0664);
+MODULE_PARM_DESC(invlut_y, "\n lut for inv y 0..1024 eotf\n");
+
+module_param_array(invlut_y_1024, uint,
+	&num_invlut_1024_mapping, 0664);
+MODULE_PARM_DESC(invlut_y_1024, "\n lut for inv y 1024..2048 eotf\n");
+
 module_param_array(video_eotf_coeff, int,
 	&num_video_eotf_coeff, 0664);
 MODULE_PARM_DESC(video_eotf_coeff, "\n matrix for video eotf\n");
@@ -825,6 +1044,16 @@ MODULE_PARM_DESC(reload_mtx, "\n reload matrix coeff\n");
 module_param(reload_lut, uint, 0664);
 MODULE_PARM_DESC(reload_lut, "\n reload lut settings\n");
 
+static int RGB709_to_YUV709_coeff[MATRIX_5x3_COEF_SIZE] = {
+	0, 0, 0, /* pre offset */
+	COEFF_NORM(0.2126),	COEFF_NORM(0.7152),	COEFF_NORM(0.0722),
+	COEFF_NORM(-0.114572),	COEFF_NORM(-0.385428),	COEFF_NORM(0.5),
+	COEFF_NORM(0.5),	COEFF_NORM(-0.454153),	COEFF_NORM(-0.045847),
+	0, 0, 0, /* 10'/11'/12' */
+	0, 0, 0, /* 20'/21'/22' */
+	0, 512, 512, /* offset */
+	0, 0, 0 /* mode, right_shift, clip_en */
+};
 
 static int RGB709_to_YUV709l_coeff[MATRIX_5x3_COEF_SIZE] = {
 	0, 0, 0, /* pre offset */
@@ -837,6 +1066,17 @@ static int RGB709_to_YUV709l_coeff[MATRIX_5x3_COEF_SIZE] = {
 	0, 0, 0 /* mode, right_shift, clip_en */
 };
 
+static int RGB2020_to_YUV2020l_coeff[MATRIX_5x3_COEF_SIZE] = {
+	0, 0, 0, /* pre offset */
+	COEFF_NORM(0.224732),	COEFF_NORM(0.580008),	COEFF_NORM(0.050729),
+	COEFF_NORM(-0.122176),	COEFF_NORM(-0.315324),	COEFF_NORM(0.437500),
+	COEFF_NORM(0.437500),	COEFF_NORM(-0.402312),	COEFF_NORM(-0.035188),
+	0, 0, 0, /* 30/31/32 */
+	0, 0, 0, /* 40/41/42 */
+	64, 512, 512, /* offset */
+	0, 0, 0 /* mode, right_shift, clip_en */
+};
+
 static int YUV709f_to_YUV709l_coeff[MATRIX_5x3_COEF_SIZE] = {
 	0, -512, -512, /* pre offset */
 	COEFF_NORM(0.859),	COEFF_NORM(0),	COEFF_NORM(0),
@@ -848,6 +1088,16 @@ static int YUV709f_to_YUV709l_coeff[MATRIX_5x3_COEF_SIZE] = {
 	0, 0, 0 /* mode, right_shift, clip_en */
 };
 
+static int YUV709l_to_YUV709f_coeff[MATRIX_5x3_COEF_SIZE] = {
+	64, -512, -512, /* pre offset */
+	COEFF_NORM(1.16895),	COEFF_NORM(0),	COEFF_NORM(0),
+	COEFF_NORM(0),	COEFF_NORM(1.14286),	COEFF_NORM(0),
+	COEFF_NORM(0),	COEFF_NORM(0),	COEFF_NORM(1.14286),
+	0, 0, 0, /* 10'/11'/12' */
+	0, 0, 0, /* 20'/21'/22' */
+	0, 512, 512, /* offset */
+	0, 0, 0 /* mode, right_shift, clip_en */
+};
 
 static int YUV709l_to_RGB709_coeff[MATRIX_5x3_COEF_SIZE] = {
 	-64, -512, -512, /* pre offset */
@@ -892,6 +1142,16 @@ static int eotf_bypass_coeff[EOTF_COEFF_SIZE] = {
 	EOTF_COEFF_RIGHTSHIFT /* right shift */
 };
 
+static int eotf_RGB709_to_RGB2020_coeff[EOTF_COEFF_SIZE] = {
+	EOTF_COEFF_NORM(0.627441),	EOTF_COEFF_NORM(0.329285),
+	EOTF_COEFF_NORM(0.043274),
+	EOTF_COEFF_NORM(0.069092),	EOTF_COEFF_NORM(0.919556),
+	EOTF_COEFF_NORM(0.011322),
+	EOTF_COEFF_NORM(0.016418),	EOTF_COEFF_NORM(0.088058),
+	EOTF_COEFF_NORM(0.895554),
+	EOTF_COEFF_RIGHTSHIFT /* right shift */
+};
+
 /* post matrix: YUV2020 limit to RGB2020 */
 static int YUV2020l_to_RGB2020_coeff[MATRIX_5x3_COEF_SIZE] = {
 	-64, -512, -512, /* pre offset */
@@ -917,70 +1177,149 @@ static unsigned int eotf_33_linear_mapping[EOTF_LUT_SIZE] = {
 	0x4000
 };
 
-/* eotf lut: 2084 src_lum_max = 800 nits, maximum of 10000 nits */
+/* osd oetf lut: linear */
+static unsigned int oetf_41_linear_mapping[OSD_OETF_LUT_SIZE] = {
+		0, 4, 8, 12,
+		16, 20, 24, 28,
+		31, 62, 93, 124,
+		155, 186, 217, 248,
+		279, 310, 341, 372,
+		403, 434, 465, 496,
+		527, 558, 589, 620,
+		651, 682, 713, 744,
+		775, 806, 837, 868,
+		899, 930, 961, 992,
+		1023
+};
+
+/* following array generated from model, do not edit */
+
+/* gamma=2.200000 lumin=500 boost=0.075000 */
+static unsigned int display_scale_factor =
+	(unsigned int)((((1.000000) * 4096.0) + 1) / 2);
+
 static unsigned int eotf_33_2084_mapping[EOTF_LUT_SIZE] = {
-	    0,     0,     2,     6,    12,    23,    40,    67,
-	  106,   161,   240,   351,   503,   712,   994,  1376,
-	 1889,  2575,  3491,  4709,  6328,  8477, 11329, 15114,
-	20140, 21164, 22188, 23212, 24236, 25260, 26284, 27308,
-	28332
+	    0,     3,     6,    11,    18,    27,    40,    58,
+	   84,   119,   169,   237,   329,   455,   636,   881,
+	 1209,  1648,  2234,  3014,  4050,  5425,  7251,  9673,
+	12889, 13773, 14513, 15117, 15594, 15951, 16196, 16338,
+	16383
 };
 
-/* osd oetf lut: linear */
-static unsigned int oetf_41_linear_mapping[OSD_OETF_LUT_SIZE] = {
-	0, 0, 0, 0,
-	0, 32, 64, 96,
-	128, 160, 196, 224,
-	256, 288, 320, 352,
-	384, 416, 448, 480,
-	512, 544, 576, 608,
-	640, 672, 704, 736,
-	768, 800, 832, 864,
-	896, 928, 960, 992,
-	1023, 1023, 1023, 1023,
+static unsigned int oetf_289_gamma22_mapping[VIDEO_OETF_LUT_SIZE] = {
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  125,  171,  206,  235,  259,  281,  302,
+	 321,  339,  356,  371,  386,  401,  414,  427,
+	 440,  453,  465,  476,  488,  498,  509,  519,
+	 529,  539,  549,  558,  568,  577,  586,  595,
+	 603,  612,  620,  628,  637,  645,  652,  660,
+	 668,  675,  683,  690,  697,  705,  712,  719,
+	 726,  733,  740,  748,  755,  763,  771,  778,
+	 786,  793,  801,  808,  814,  821,  827,  832,
+	 837,  842,  846,  849,  852,  854,  856,  858,
+	 860,  862,  864,  866,  867,  869,  871,  873,
+	 875,  877,  879,  880,  882,  884,  886,  887,
+	 889,  891,  893,  894,  896,  898,  899,  901,
+	 902,  904,  906,  907,  909,  910,  912,  914,
+	 915,  917,  918,  920,  921,  923,  924,  925,
+	 927,  928,  930,  931,  933,  934,  935,  937,
+	 938,  939,  941,  942,  943,  945,  946,  947,
+	 948,  950,  951,  952,  953,  954,  956,  957,
+	 958,  959,  960,  961,  962,  963,  965,  966,
+	 967,  968,  969,  970,  971,  972,  973,  974,
+	 975,  976,  977,  978,  979,  980,  981,  981,
+	 982,  983,  984,  985,  986,  987,  987,  988,
+	 989,  990,  991,  991,  992,  993,  994,  995,
+	 995,  996,  997,  997,  998,  999,  999, 1000,
+	1001, 1001, 1002, 1003, 1003, 1004, 1004, 1005,
+	1006, 1006, 1007, 1007, 1008, 1008, 1009, 1009,
+	1010, 1010, 1011, 1011, 1012, 1012, 1012, 1013,
+	1013, 1014, 1014, 1015, 1015, 1015, 1016, 1016,
+	1016, 1017, 1017, 1017, 1018, 1018, 1018, 1019,
+	1019, 1019, 1019, 1020, 1020, 1020, 1020, 1020,
+	1021, 1021, 1021, 1021, 1021, 1022, 1022, 1022,
+	1022, 1022, 1022, 1022, 1022, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
 	1023
 };
 
-static unsigned int oetf_289_hlg_mapping[VIDEO_OETF_LUT_SIZE] = {
-	    0,     7,    14,    21,    28,    36,    43,    50,
-	   57,    64,    71,    78,    85,    92,   100,   107,
-	  114,   121,   128,   157,   181,   202,   222,   239,
-	  256,   272,   286,   300,   314,   326,   339,   351,
-	  362,   373,   384,   395,   405,   415,   425,   434,
-	  443,   453,   462,   470,   479,   487,   496,   504,
-	  512,   520,   527,   535,   541,   548,   555,   561,
-	  567,   573,   578,   584,   589,   594,   599,   604,
-	  609,   614,   618,   623,   627,   631,   635,   639,
-	  643,   647,   651,   655,   658,   662,   665,   669,
-	  672,   675,   679,   682,   685,   688,   691,   694,
-	  697,   700,   703,   706,   708,   711,   714,   716,
-	  719,   722,   724,   727,   729,   731,   734,   736,
-	  739,   741,   743,   745,   748,   750,   752,   754,
-	  756,   758,   760,   762,   765,   767,   769,   770,
-	  772,   774,   776,   778,   780,   782,   784,   785,
-	  787,   789,   791,   792,   794,   796,   798,   799,
-	  801,   803,   804,   806,   807,   809,   811,   812,
-	  814,   815,   817,   818,   820,   821,   823,   824,
-	  826,   827,   828,   830,   831,   833,   834,   835,
-	  837,   838,   840,   841,   842,   843,   845,   846,
-	  847,   849,   850,   851,   852,   854,   855,   856,
-	  857,   859,   860,   861,   862,   863,   864,   866,
-	  867,   868,   869,   870,   871,   872,   874,   875,
-	  876,   877,   878,   879,   880,   881,   882,   883,
-	  884,   885,   886,   887,   889,   890,   891,   892,
-	  893,   894,   895,   896,   897,   898,   898,   899,
-	  900,   901,   902,   903,   904,   905,   906,   907,
-	  908,   909,   910,   911,   912,   912,   913,   914,
-	  915,   916,   917,   918,   919,   920,   920,   921,
-	  922,   923,   924,   925,   925,   926,   927,   928,
-	  929,   930,   930,   931,   932,   933,   934,   934,
-	  935,   936,   937,   938,   938,   939,   940,   941,
-	  941,   942,   943,   944,   945,   945,   946,   947,
-	  948,   952,   957,   961,   966,   970,   975,   979,
-	  984,   988,   993,   997,  1002,  1006,  1011,  1015,
-	 1020
+/* osd eotf lut: 709 */
+static unsigned int osd_eotf_33_709_mapping[EOTF_LUT_SIZE] = {
+	    0,   512,  1024,  1536,  2048,  2560,  3072,  3584,
+	 4096,  4608,  5120,  5632,  6144,  6656,  7168,  7680,
+	 8192,  8704,  9216,  9728, 10240, 10752, 11264, 11776,
+	12288, 12800, 13312, 13824, 14336, 14848, 15360, 15872,
+	16383
 };
 
+/* osd oetf lut: 2084 */
+static unsigned int osd_oetf_41_2084_mapping[OSD_OETF_LUT_SIZE] = {
+	   0,   21,   43,   64,   79,   90,  101,  111,
+	 120,  174,  208,  233,  277,  313,  344,  372,
+	 398,  420,  440,  459,  476,  492,  507,  522,
+	 536,  549,  561,  574,  585,  596,  606,  616,
+	 624,  632,  642,  661,  684,  706,  727,  749,
+	1023
+};
+
+/* sdr eotf lut: 709 */
+static unsigned int eotf_33_sdr_709_mapping[EOTF_LUT_SIZE] = {
+	    0,   512,  1024,  1536,  2048,  2560,  3072,  3584,
+	 4096,  4608,  5120,  5632,  6144,  6656,  7168,  7680,
+	 8192,  8704,  9216,  9728, 10240, 10752, 11264, 11776,
+	12288, 12800, 13312, 13824, 14336, 14848, 15360, 15872,
+	16383
+};
+
+/* sdr oetf lut: 2084 */
+static unsigned int oetf_sdr_2084_mapping[VIDEO_OETF_LUT_SIZE] = {
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,   32,   55,   72,   85,   96,  106,  115,
+	 124,  132,  140,  147,  154,  160,  166,  171,
+	 176,  181,  186,  190,  194,  198,  204,  208,
+	 211,  215,  218,  221,  224,  227,  230,  233,
+	 239,  245,  252,  257,  263,  268,  274,  279,
+	 283,  288,  292,  296,  302,  306,  310,  315,
+	 319,  323,  326,  331,  334,  339,  342,  346,
+	 350,  354,  357,  361,  365,  368,  372,  376,
+	 379,  382,  386,  389,  392,  396,  399,  402,
+	 405,  408,  411,  413,  416,  419,  422,  424,
+	 427,  429,  432,  434,  437,  439,  442,  444,
+	 446,  449,  451,  454,  456,  459,  461,  463,
+	 465,  468,  470,  472,  474,  476,  478,  481,
+	 483,  485,  487,  489,  491,  493,  495,  497,
+	 499,  501,  503,  505,  507,  509,  511,  513,
+	 515,  516,  518,  520,  522,  524,  526,  527,
+	 529,  531,  533,  535,  536,  538,  540,  541,
+	 543,  545,  546,  548,  550,  551,  553,  555,
+	 556,  558,  559,  561,  562,  564,  566,  567,
+	 569,  570,  572,  573,  575,  576,  578,  579,
+	 580,  582,  584,  585,  586,  588,  589,  591,
+	 592,  594,  595,  596,  598,  599,  600,  602,
+	 603,  604,  606,  607,  608,  609,  611,  612,
+	 613,  615,  616,  617,  618,  619,  620,  621,
+	 622,  623,  624,  625,  626,  627,  628,  629,
+	 630,  631,  632,  634,  635,  636,  637,  638,
+	 640,  641,  642,  644,  646,  648,  651,  654,
+	 657,  661,  664,  666,  670,  672,  676,  678,
+	 681,  684,  687,  690,  692,  695,  698,  701,
+	 704,  706,  709,  712,  715,  718,  720,  723,
+	 726,  729,  731,  734,  737,  740,  743,  746,
+	 748,  751,  754,  758,  763,  772,  797,  833,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+};
+
+/* end of array generated from model */
+
+module_param(display_scale_factor, uint, 0664);
+MODULE_PARM_DESC(display_scale_factor, "\n display scale factor\n");
+
 /* video oetf: linear */
 #if 0
 static unsigned int oetf_289_linear_mapping[VIDEO_OETF_LUT_SIZE] = {
@@ -1022,19 +1361,6 @@ static unsigned int oetf_289_linear_mapping[VIDEO_OETF_LUT_SIZE] = {
 	1023
 };
 
-/* eotf lut: 2084 */
-static unsigned int eotf_33_2084_mapping[EOTF_LUT_SIZE] = {
-	0, 0, 0, 0,
-	1, 2, 3, 5,
-	8, 13, 19, 28,
-	40, 57, 80, 110,
-	151, 206, 279, 377,
-	506, 678, 906, 1209,
-	1611, 2146, 2857, 3807,
-	5077, 6781, 9075, 12175,
-	16384,
-};
-
 /* video oetf: 709 */
 static unsigned int oetf_289_709_mapping[VIDEO_OETF_LUT_SIZE] = {
 	   0,   2,   4,   6,   8,  10,  12,  14,
@@ -1116,25 +1442,28 @@ static void print_vpp_matrix(int m_select, int *s, int on)
 	pr_csc("%s matrix %s:\n", matrix_name[m_select],
 		on ? "on" : "off");
 
-if (size == MATRIX_5x3_COEF_SIZE) {
-	pr_csc("\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\n",
-			SIGN(s[0]), DECI(s[0]), FRAC(s[0]),
-			SIGN(s[3]), DECI(s[3]), FRAC(s[3]),
-			SIGN(s[4]), DECI(s[4]), FRAC(s[4]),
-			SIGN(s[5]), DECI(s[5]), FRAC(s[5]),
-			SIGN(s[18]), DECI(s[18]), FRAC(s[18]));
-	pr_csc("\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\n",
-			SIGN(s[1]), DECI(s[1]), FRAC(s[1]),
-			SIGN(s[6]), DECI(s[6]), FRAC(s[6]),
-			SIGN(s[7]), DECI(s[7]), FRAC(s[7]),
-			SIGN(s[8]), DECI(s[8]), FRAC(s[8]),
-			SIGN(s[19]), DECI(s[19]), FRAC(s[19]));
-	pr_csc("\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\n",
-			SIGN(s[2]), DECI(s[2]), FRAC(s[2]),
-			SIGN(s[9]), DECI(s[9]), FRAC(s[9]),
-			SIGN(s[10]), DECI(s[10]), FRAC(s[10]),
-			SIGN(s[11]), DECI(s[11]), FRAC(s[11]),
-			SIGN(s[20]), DECI(s[20]), FRAC(s[20]));
+	if (size == MATRIX_5x3_COEF_SIZE) {
+		pr_csc(
+		"\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\n",
+				SIGN(s[0]), DECI(s[0]), FRAC(s[0]),
+				SIGN(s[3]), DECI(s[3]), FRAC(s[3]),
+				SIGN(s[4]), DECI(s[4]), FRAC(s[4]),
+				SIGN(s[5]), DECI(s[5]), FRAC(s[5]),
+				SIGN(s[18]), DECI(s[18]), FRAC(s[18]));
+		pr_csc(
+		"\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\n",
+				SIGN(s[1]), DECI(s[1]), FRAC(s[1]),
+				SIGN(s[6]), DECI(s[6]), FRAC(s[6]),
+				SIGN(s[7]), DECI(s[7]), FRAC(s[7]),
+				SIGN(s[8]), DECI(s[8]), FRAC(s[8]),
+				SIGN(s[19]), DECI(s[19]), FRAC(s[19]));
+		pr_csc(
+		"\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\n",
+				SIGN(s[2]), DECI(s[2]), FRAC(s[2]),
+				SIGN(s[9]), DECI(s[9]), FRAC(s[9]),
+				SIGN(s[10]), DECI(s[10]), FRAC(s[10]),
+				SIGN(s[11]), DECI(s[11]), FRAC(s[11]),
+				SIGN(s[20]), DECI(s[20]), FRAC(s[20]));
 		if (s[21]) {
 			pr_csc("\t\t%s%1d.%04d\t%s%1d.%04d\t%s%1d.%04d\n",
 				SIGN(s[12]), DECI(s[12]), FRAC(s[12]),
@@ -1171,8 +1500,8 @@ void set_vpp_matrix(int m_select, int *s, int on)
 	int *m = NULL;
 	int size = 0;
 	int i;
-
-	print_vpp_matrix(m_select, s, on);
+	if (debug_csc)
+		print_vpp_matrix(m_select, s, on);
 	if (m_select == VPP_MATRIX_OSD) {
 		m = osd_matrix_coeff;
 		size = MATRIX_5x3_COEF_SIZE;
@@ -1205,6 +1534,7 @@ void set_vpp_matrix(int m_select, int *s, int on)
 
 	if (m_select == VPP_MATRIX_OSD) {
 		/* osd matrix, VPP_MATRIX_0 */
+		/* not enable latched */
 		hdr_osd_reg.viu_osd1_matrix_pre_offset0_1 =
 			((m[0] & 0xfff) << 16) | (m[1] & 0xfff);
 		hdr_osd_reg.viu_osd1_matrix_pre_offset2 =
@@ -1244,16 +1574,16 @@ void set_vpp_matrix(int m_select, int *s, int on)
 		hdr_osd_reg.viu_osd1_matrix_ctrl |= on;
 	} else if (m_select == VPP_MATRIX_EOTF) {
 		/* eotf matrix, VPP_MATRIX_EOTF */
+		/* enable latched */
 		for (i = 0; i < 5; i++)
-			WRITE_VPP_REG(VIU_EOTF_CTL + i + 1,
+			VSYNC_WR_MPEG_REG(VIU_EOTF_CTL + i + 1,
 				((m[i * 2] & 0x1fff) << 16)
 				| (m[i * 2 + 1] & 0x1fff));
-
 		WRITE_VPP_REG_BITS(VIU_EOTF_CTL, on, 30, 1);
 		WRITE_VPP_REG_BITS(VIU_EOTF_CTL, on, 31, 1);
 	} else if (m_select == VPP_MATRIX_OSD_EOTF) {
 		/* osd eotf matrix, VPP_MATRIX_OSD_EOTF */
-
+		/* enable latched */
 		hdr_osd_reg.viu_osd1_eotf_coef00_01 =
 			((m[0 * 2] & 0x1fff) << 16)
 			| (m[0 * 2 + 1] & 0x1fff);
@@ -1283,62 +1613,158 @@ void set_vpp_matrix(int m_select, int *s, int on)
 		if (m_select == VPP_MATRIX_POST) {
 			/* post matrix */
 			m = post_matrix_coeff;
+			/* set bit for enable latched */
+			WRITE_VPP_REG_BITS(VPP_XVYCC_MISC, 1, 14, 1);
 			WRITE_VPP_REG_BITS(VPP_MATRIX_CTRL, on, 0, 1);
-			WRITE_VPP_REG_BITS(VPP_MATRIX_CTRL, 0, 8, 2);
+			if (on) {
+				if (rdma_flag & (1 << m_select))
+					VSYNC_WR_MPEG_REG_BITS(
+						VPP_MATRIX_CTRL, 0, 8, 2);
+				else
+					WRITE_VPP_REG_BITS(
+						VPP_MATRIX_CTRL, 0, 8, 2);
+			}
 		} else if (m_select == VPP_MATRIX_VD1) {
-			/* vd1 matrix */
+			/* vd1 matrix, latched */
 			m = vd1_matrix_coeff;
+			/* set bit for enable latched */
+			WRITE_VPP_REG_BITS(VPP_XVYCC_MISC, 1, 9, 1);
 			WRITE_VPP_REG_BITS(VPP_MATRIX_CTRL, on, 5, 1);
-			WRITE_VPP_REG_BITS(VPP_MATRIX_CTRL, 1, 8, 2);
+			if (on) {
+				if (rdma_flag & (1 << m_select))
+					VSYNC_WR_MPEG_REG_BITS(
+						VPP_MATRIX_CTRL, 1, 8, 2);
+				else
+					WRITE_VPP_REG_BITS(
+						VPP_MATRIX_CTRL, 1, 8, 2);
+			}
 		} else if (m_select == VPP_MATRIX_VD2) {
-			/* vd2 matrix */
+			/* vd2 matrix, not latched */
 			m = vd2_matrix_coeff;
-			WRITE_VPP_REG_BITS(VPP_MATRIX_CTRL, on, 4, 1);
-			WRITE_VPP_REG_BITS(VPP_MATRIX_CTRL, 2, 8, 2);
+			if (rdma_flag & (1 << m_select))
+				VSYNC_WR_MPEG_REG_BITS(
+					VPP_MATRIX_CTRL, on, 4, 1);
+			else
+				WRITE_VPP_REG_BITS(
+					VPP_MATRIX_CTRL, on, 4, 1);
+			if (on) {
+				if (rdma_flag & (1 << m_select))
+					VSYNC_WR_MPEG_REG_BITS(
+						VPP_MATRIX_CTRL, 2, 8, 2);
+				else
+					WRITE_VPP_REG_BITS(
+						VPP_MATRIX_CTRL, 2, 8, 2);
+			}
 		} else if (m_select == VPP_MATRIX_XVYCC) {
-			/* xvycc matrix */
+			/* xvycc matrix, not latched */
 			m = xvycc_matrix_coeff;
-			WRITE_VPP_REG_BITS(VPP_MATRIX_CTRL, on, 6, 1);
-			WRITE_VPP_REG_BITS(VPP_MATRIX_CTRL, 3, 8, 2);
-		}
-		WRITE_VPP_REG(VPP_MATRIX_PRE_OFFSET0_1,
-			((m[0] & 0xfff) << 16) | (m[1] & 0xfff));
-		WRITE_VPP_REG(VPP_MATRIX_PRE_OFFSET2,
-			m[2] & 0xfff);
-		WRITE_VPP_REG(VPP_MATRIX_COEF00_01,
-			((m[3] & 0x1fff) << 16) | (m[4] & 0x1fff));
-		WRITE_VPP_REG(VPP_MATRIX_COEF02_10,
-			((m[5]  & 0x1fff) << 16) | (m[6] & 0x1fff));
-		WRITE_VPP_REG(VPP_MATRIX_COEF11_12,
-			((m[7] & 0x1fff) << 16) | (m[8] & 0x1fff));
-		WRITE_VPP_REG(VPP_MATRIX_COEF20_21,
-			((m[9] & 0x1fff) << 16) | (m[10] & 0x1fff));
-		WRITE_VPP_REG(VPP_MATRIX_COEF22,
-			m[11] & 0x1fff);
-		if (m[21]) {
-			WRITE_VPP_REG(VPP_MATRIX_COEF13_14,
-				((m[12] & 0x1fff) << 16) | (m[13] & 0x1fff));
-			WRITE_VPP_REG(VPP_MATRIX_COEF15_25,
-				((m[14] & 0x1fff) << 16) | (m[17] & 0x1fff));
-			WRITE_VPP_REG(VPP_MATRIX_COEF23_24,
-				((m[15] & 0x1fff) << 16) | (m[16] & 0x1fff));
-		}
-		WRITE_VPP_REG(VPP_MATRIX_OFFSET0_1,
-			((m[18] & 0xfff) << 16) | (m[19] & 0xfff));
-		WRITE_VPP_REG(VPP_MATRIX_OFFSET2,
-			m[20] & 0xfff);
-		WRITE_VPP_REG_BITS(VPP_MATRIX_CLIP,
-			m[21], 3, 2);
-		WRITE_VPP_REG_BITS(VPP_MATRIX_CLIP,
-			m[22], 5, 3);
+			if (rdma_flag & (1 << m_select))
+				VSYNC_WR_MPEG_REG_BITS(
+					VPP_MATRIX_CTRL, on, 6, 1);
+			else
+				WRITE_VPP_REG_BITS(
+					VPP_MATRIX_CTRL, on, 6, 1);
+			if (on) {
+				if (rdma_flag & (1 << m_select))
+					VSYNC_WR_MPEG_REG_BITS(
+						VPP_MATRIX_CTRL, 3, 8, 2);
+				else
+					WRITE_VPP_REG_BITS(
+						VPP_MATRIX_CTRL, 3, 8, 2);
+			}
+		}
+		if (on) {
+			if (rdma_flag & (1 << m_select)) {
+				VSYNC_WR_MPEG_REG(VPP_MATRIX_PRE_OFFSET0_1,
+					((m[0] & 0xfff) << 16)
+					| (m[1] & 0xfff));
+				VSYNC_WR_MPEG_REG(VPP_MATRIX_PRE_OFFSET2,
+					m[2] & 0xfff);
+				VSYNC_WR_MPEG_REG(VPP_MATRIX_COEF00_01,
+					((m[3] & 0x1fff) << 16)
+					| (m[4] & 0x1fff));
+				VSYNC_WR_MPEG_REG(VPP_MATRIX_COEF02_10,
+					((m[5]  & 0x1fff) << 16)
+					| (m[6] & 0x1fff));
+				VSYNC_WR_MPEG_REG(VPP_MATRIX_COEF11_12,
+					((m[7] & 0x1fff) << 16)
+					| (m[8] & 0x1fff));
+				VSYNC_WR_MPEG_REG(VPP_MATRIX_COEF20_21,
+					((m[9] & 0x1fff) << 16)
+					| (m[10] & 0x1fff));
+				VSYNC_WR_MPEG_REG(VPP_MATRIX_COEF22,
+					m[11] & 0x1fff);
+				if (m[21]) {
+					VSYNC_WR_MPEG_REG(VPP_MATRIX_COEF13_14,
+						((m[12] & 0x1fff) << 16)
+						| (m[13] & 0x1fff));
+					VSYNC_WR_MPEG_REG(VPP_MATRIX_COEF15_25,
+						((m[14] & 0x1fff) << 16)
+						| (m[17] & 0x1fff));
+					VSYNC_WR_MPEG_REG(VPP_MATRIX_COEF23_24,
+						((m[15] & 0x1fff) << 16)
+						| (m[16] & 0x1fff));
+				}
+				VSYNC_WR_MPEG_REG(VPP_MATRIX_OFFSET0_1,
+					((m[18] & 0xfff) << 16)
+					| (m[19] & 0xfff));
+				VSYNC_WR_MPEG_REG(VPP_MATRIX_OFFSET2,
+					m[20] & 0xfff);
+				VSYNC_WR_MPEG_REG_BITS(VPP_MATRIX_CLIP,
+					m[21], 3, 2);
+				VSYNC_WR_MPEG_REG_BITS(VPP_MATRIX_CLIP,
+					m[22], 5, 3);
+			} else {
+				WRITE_VPP_REG(VPP_MATRIX_PRE_OFFSET0_1,
+					((m[0] & 0xfff) << 16)
+					| (m[1] & 0xfff));
+				WRITE_VPP_REG(VPP_MATRIX_PRE_OFFSET2,
+					m[2] & 0xfff);
+				WRITE_VPP_REG(VPP_MATRIX_COEF00_01,
+					((m[3] & 0x1fff) << 16)
+					| (m[4] & 0x1fff));
+				WRITE_VPP_REG(VPP_MATRIX_COEF02_10,
+					((m[5]  & 0x1fff) << 16)
+					| (m[6] & 0x1fff));
+				WRITE_VPP_REG(VPP_MATRIX_COEF11_12,
+					((m[7] & 0x1fff) << 16)
+					| (m[8] & 0x1fff));
+				WRITE_VPP_REG(VPP_MATRIX_COEF20_21,
+					((m[9] & 0x1fff) << 16)
+					| (m[10] & 0x1fff));
+				WRITE_VPP_REG(VPP_MATRIX_COEF22,
+					m[11] & 0x1fff);
+				if (m[21]) {
+					WRITE_VPP_REG(VPP_MATRIX_COEF13_14,
+						((m[12] & 0x1fff) << 16)
+						| (m[13] & 0x1fff));
+					WRITE_VPP_REG(VPP_MATRIX_COEF15_25,
+						((m[14] & 0x1fff) << 16)
+						| (m[17] & 0x1fff));
+					WRITE_VPP_REG(VPP_MATRIX_COEF23_24,
+						((m[15] & 0x1fff) << 16)
+						| (m[16] & 0x1fff));
+				}
+				WRITE_VPP_REG(VPP_MATRIX_OFFSET0_1,
+					((m[18] & 0xfff) << 16)
+					| (m[19] & 0xfff));
+				WRITE_VPP_REG(VPP_MATRIX_OFFSET2,
+					m[20] & 0xfff);
+				WRITE_VPP_REG_BITS(VPP_MATRIX_CLIP,
+					m[21], 3, 2);
+				WRITE_VPP_REG_BITS(VPP_MATRIX_CLIP,
+					m[22], 5, 3);
+			}
+		}
 	}
 }
 
-const char lut_name[4][16] = {
+const char lut_name[NUM_LUT][16] = {
 	"OSD_EOTF",
 	"OSD_OETF",
 	"EOTF",
 	"OETF",
+	"INV_EOTF"
 };
 /* VIDEO_OETF_LUT_SIZE 289 >
 	OSD_OETF_LUT_SIZE 41 >
@@ -1360,6 +1786,7 @@ static void print_vpp_lut(
 		addr_port = VIU_OSD1_EOTF_LUT_ADDR_PORT;
 		data_port = VIU_OSD1_EOTF_LUT_DATA_PORT;
 		ctrl_port = VIU_OSD1_EOTF_CTL;
+		return;
 	} else if (lut_sel == VPP_LUT_EOTF) {
 		addr_port = VIU_EOTF_LUT_ADDR_PORT;
 		data_port = VIU_EOTF_LUT_DATA_PORT;
@@ -1368,32 +1795,41 @@ static void print_vpp_lut(
 		addr_port = VIU_OSD1_OETF_LUT_ADDR_PORT;
 		data_port = VIU_OSD1_OETF_LUT_DATA_PORT;
 		ctrl_port = VIU_OSD1_OETF_CTL;
+		return;
 	} else if (lut_sel == VPP_LUT_OETF) {
 		addr_port = XVYCC_LUT_R_ADDR_PORT;
 		data_port = XVYCC_LUT_R_DATA_PORT;
 		ctrl_port = XVYCC_LUT_CTL;
+	} else if (lut_sel == VPP_LUT_INV_EOTF) {
+		addr_port = XVYCC_INV_LUT_Y_ADDR_PORT;
+		data_port = XVYCC_INV_LUT_Y_DATA_PORT;
+		ctrl_port = XVYCC_INV_LUT_CTL;
 	} else
 		return;
 	if (lut_sel == VPP_LUT_OSD_OETF) {
-		WRITE_VPP_REG(addr_port, 0);
 		for (i = 0; i < 20; i++) {
+			WRITE_VPP_REG(addr_port, i);
 			data = READ_VPP_REG(data_port);
 			r_map[i * 2] = data & 0xffff;
 			r_map[i * 2 + 1] = (data >> 16) & 0xffff;
 		}
+		WRITE_VPP_REG(addr_port, 20);
 		data = READ_VPP_REG(data_port);
 		r_map[OSD_OETF_LUT_SIZE - 1] = data & 0xffff;
 		g_map[0] = (data >> 16) & 0xffff;
 		for (i = 0; i < 20; i++) {
+			WRITE_VPP_REG(addr_port, 21 + i);
 			data = READ_VPP_REG(data_port);
 			g_map[i * 2 + 1] = data & 0xffff;
 			g_map[i * 2 + 2] = (data >> 16) & 0xffff;
 		}
 		for (i = 0; i < 20; i++) {
+			WRITE_VPP_REG(addr_port, 41 + i);
 			data = READ_VPP_REG(data_port);
 			b_map[i * 2] = data & 0xffff;
 			b_map[i * 2 + 1] = (data >> 16) & 0xffff;
 		}
+		WRITE_VPP_REG(addr_port, 61);
 		data = READ_VPP_REG(data_port);
 		b_map[OSD_OETF_LUT_SIZE - 1] = data & 0xffff;
 		pr_csc("%s lut %s:\n", lut_name[lut_sel], on ? "on" : "off");
@@ -1477,6 +1913,24 @@ static void print_vpp_lut(
 		pr_csc("\n");
 		if (on)
 			WRITE_VPP_REG(ctrl_port, 0x7f);
+	} else if (lut_sel == VPP_LUT_INV_EOTF) {
+		WRITE_VPP_REG_BITS(ctrl_port, 0, 12, 3);
+		pr_csc("%s lut %s:\n", lut_name[lut_sel], on ? "on" : "off");
+		for (i = 0;
+			i < EOTF_INV_LUT_NEG2048_SIZE +
+			EOTF_INV_LUT_SIZE + EOTF_INV_LUT_1024_SIZE;
+			i++) {
+			WRITE_VPP_REG(addr_port, i);
+			data = READ_VPP_REG(data_port) & 0xfff;
+			if (data & 0x800)
+				pr_csc("\t[%d] = %d\n",
+					i, -(~(data|0xfffff000) + 1));
+			else
+				pr_csc("\t[%d] = %d\n", i, data);
+		}
+		pr_csc("\n");
+		if (on)
+			WRITE_VPP_REG_BITS(ctrl_port, 1<<2, 12, 3);
 	}
 }
 
@@ -1501,8 +1955,8 @@ void set_vpp_lut(
 		r_map = osd_eotf_r_mapping;
 		g_map = osd_eotf_g_mapping;
 		b_map = osd_eotf_b_mapping;
-		/* addr_port = VIU_OSD1_EOTF_LUT_ADDR_PORT; */
-		/* data_port = VIU_OSD1_EOTF_LUT_DATA_PORT; */
+		addr_port = VIU_OSD1_EOTF_LUT_ADDR_PORT;
+		data_port = VIU_OSD1_EOTF_LUT_DATA_PORT;
 		ctrl_port = VIU_OSD1_EOTF_CTL;
 	} else if (lut_sel == VPP_LUT_EOTF) {
 		r_map = video_eotf_r_mapping;
@@ -1515,8 +1969,8 @@ void set_vpp_lut(
 		r_map = osd_oetf_r_mapping;
 		g_map = osd_oetf_g_mapping;
 		b_map = osd_oetf_b_mapping;
-		/* addr_port = VIU_OSD1_OETF_LUT_ADDR_PORT; */
-		/* data_port = VIU_OSD1_OETF_LUT_DATA_PORT; */
+		addr_port = VIU_OSD1_OETF_LUT_ADDR_PORT;
+		data_port = VIU_OSD1_OETF_LUT_DATA_PORT;
 		ctrl_port = VIU_OSD1_OETF_CTL;
 	} else if (lut_sel == VPP_LUT_OETF) {
 #if 0
@@ -1530,10 +1984,15 @@ void set_vpp_lut(
 		data_port = XVYCC_LUT_R_DATA_PORT;
 		ctrl_port = XVYCC_LUT_CTL;
 #endif
+	} else if (lut_sel == VPP_LUT_INV_EOTF) {
+		addr_port = XVYCC_INV_LUT_Y_ADDR_PORT;
+		data_port = XVYCC_INV_LUT_Y_DATA_PORT;
+		ctrl_port = XVYCC_INV_LUT_CTL;
 	} else
 		return;
 
 	if (lut_sel == VPP_LUT_OSD_OETF) {
+		/* enable latched */
 		if (r && r_map)
 			for (i = 0; i < OSD_OETF_LUT_SIZE; i++)
 				r_map[i] = r[i];
@@ -1544,14 +2003,17 @@ void set_vpp_lut(
 			for (i = 0; i < OSD_OETF_LUT_SIZE; i++)
 				b_map[i] = b[i];
 
-		memcpy(hdr_osd_reg.lut_val.r_map,
-			r_map,
-			3 * OSD_OETF_LUT_SIZE * sizeof(uint32_t));
-
+		for (i = 0; i < OSD_OETF_LUT_SIZE; i++) {
+			hdr_osd_reg.lut_val.or_map[i] = r_map[i];
+			hdr_osd_reg.lut_val.og_map[i] = g_map[i];
+			hdr_osd_reg.lut_val.ob_map[i] = b_map[i];
+		}
 		hdr_osd_reg.viu_osd1_oetf_ctl &= 0x1fffffff;
+		hdr_osd_reg.viu_osd1_oetf_ctl |= 7 << 22;
 		if (on)
 			hdr_osd_reg.viu_osd1_oetf_ctl |= 7 << 29;
 	} else if (lut_sel == VPP_LUT_OSD_EOTF) {
+		/* enable latched */
 		if (r && r_map)
 			for (i = 0; i < EOTF_LUT_SIZE; i++)
 				r_map[i] = r[i];
@@ -1562,16 +2024,17 @@ void set_vpp_lut(
 			for (i = 0; i < EOTF_LUT_SIZE; i++)
 				b_map[i] = b[i];
 
-		memcpy(hdr_osd_reg.lut_val.or_map,
-			r_map,
-			3 * EOTF_LUT_SIZE * sizeof(uint32_t));
-
+		for (i = 0; i < EOTF_LUT_SIZE; i++) {
+			hdr_osd_reg.lut_val.r_map[i] = r_map[i];
+			hdr_osd_reg.lut_val.g_map[i] = g_map[i];
+			hdr_osd_reg.lut_val.b_map[i] = b_map[i];
+		}
 		hdr_osd_reg.viu_osd1_eotf_ctl &= 0xc7ffffff;
 		if (on)
 			hdr_osd_reg.viu_osd1_eotf_ctl |= 7 << 27;
-
 		hdr_osd_reg.viu_osd1_eotf_ctl |= 1 << 31;
 	} else if (lut_sel == VPP_LUT_EOTF) {
+		/* enable latched */
 		if (r && r_map)
 			for (i = 0; i < EOTF_LUT_SIZE; i++)
 				r_map[i] = r[i];
@@ -1581,29 +2044,38 @@ void set_vpp_lut(
 		if (r && r_map)
 			for (i = 0; i < EOTF_LUT_SIZE; i++)
 				b_map[i] = b[i];
-		WRITE_VPP_REG(addr_port, 0);
-		for (i = 0; i < 16; i++)
-			WRITE_VPP_REG(data_port,
-				r_map[i * 2]
-				| (r_map[i * 2 + 1] << 16));
-		WRITE_VPP_REG(data_port,
-			r_map[EOTF_LUT_SIZE - 1]
-			| (g_map[0] << 16));
-		for (i = 0; i < 16; i++)
-			WRITE_VPP_REG(data_port,
-				g_map[i * 2 + 1]
-				| (b_map[i * 2 + 2] << 16));
-		for (i = 0; i < 16; i++)
-			WRITE_VPP_REG(data_port,
-				b_map[i * 2]
-				| (b_map[i * 2 + 1] << 16));
-		WRITE_VPP_REG(data_port, b_map[EOTF_LUT_SIZE - 1]);
-		if (on)
+		if (on) {
+			for (i = 0; i < 16; i++) {
+				VSYNC_WR_MPEG_REG(addr_port, i);
+				VSYNC_WR_MPEG_REG(data_port,
+					r_map[i * 2]
+					| (r_map[i * 2 + 1] << 16));
+			}
+			VSYNC_WR_MPEG_REG(addr_port, 16);
+			VSYNC_WR_MPEG_REG(data_port,
+				r_map[EOTF_LUT_SIZE - 1]
+				| (g_map[0] << 16));
+			for (i = 0; i < 16; i++) {
+				VSYNC_WR_MPEG_REG(addr_port, i + 17);
+				VSYNC_WR_MPEG_REG(data_port,
+					g_map[i * 2 + 1]
+					| (g_map[i * 2 + 2] << 16));
+			}
+			for (i = 0; i < 16; i++) {
+				VSYNC_WR_MPEG_REG(addr_port, i + 33);
+				VSYNC_WR_MPEG_REG(data_port,
+					b_map[i * 2]
+					| (b_map[i * 2 + 1] << 16));
+			}
+			VSYNC_WR_MPEG_REG(addr_port, 49);
+			VSYNC_WR_MPEG_REG(data_port, b_map[EOTF_LUT_SIZE - 1]);
 			WRITE_VPP_REG_BITS(ctrl_port, 7, 27, 3);
-		else
+		} else
 			WRITE_VPP_REG_BITS(ctrl_port, 0, 27, 3);
 		WRITE_VPP_REG_BITS(ctrl_port, 1, 31, 1);
 	} else if (lut_sel == VPP_LUT_OETF) {
+		/* set bit to disable latched */
+		WRITE_VPP_REG_BITS(VPP_XVYCC_MISC, 0, 18, 3);
 		if (r && r_map)
 			for (i = 0; i < VIDEO_OETF_LUT_SIZE; i++)
 				r_map[i] = r[i];
@@ -1613,26 +2085,53 @@ void set_vpp_lut(
 		if (r && r_map)
 			for (i = 0; i < VIDEO_OETF_LUT_SIZE; i++)
 				b_map[i] = b[i];
-		WRITE_VPP_REG(ctrl_port, 0x0);
-		WRITE_VPP_REG(addr_port, 0);
-		for (i = 0; i < VIDEO_OETF_LUT_SIZE; i++)
-			WRITE_VPP_REG(data_port, r_map[i]);
-		WRITE_VPP_REG(addr_port + 2, 0);
-		for (i = 0; i < VIDEO_OETF_LUT_SIZE; i++)
-			WRITE_VPP_REG(data_port + 2, g_map[i]);
-		WRITE_VPP_REG(addr_port + 4, 0);
-		for (i = 0; i < VIDEO_OETF_LUT_SIZE; i++)
-			WRITE_VPP_REG(data_port + 4, b_map[i]);
 		if (on) {
-			WRITE_VPP_REG(ctrl_port, 0x7f);
+			VSYNC_WR_MPEG_REG(ctrl_port, 0x0f);
+			for (i = 0; i < VIDEO_OETF_LUT_SIZE; i++) {
+				VSYNC_WR_MPEG_REG(addr_port, i);
+				VSYNC_WR_MPEG_REG(data_port, r_map[i]);
+			}
+			for (i = 0; i < VIDEO_OETF_LUT_SIZE; i++) {
+				VSYNC_WR_MPEG_REG(addr_port + 2, i);
+				VSYNC_WR_MPEG_REG(data_port + 2, g_map[i]);
+			}
+			for (i = 0; i < VIDEO_OETF_LUT_SIZE; i++) {
+				VSYNC_WR_MPEG_REG(addr_port + 4, i);
+				VSYNC_WR_MPEG_REG(data_port + 4, b_map[i]);
+			}
+			VSYNC_WR_MPEG_REG(ctrl_port, 0x7f);
 			knee_lut_on = 1;
 		} else {
-			WRITE_VPP_REG(ctrl_port, 0x0);
+			VSYNC_WR_MPEG_REG(ctrl_port, 0x0f);
 			knee_lut_on = 0;
 		}
 		cur_knee_factor = knee_factor;
+	} else if (lut_sel == VPP_LUT_INV_EOTF) {
+		/* set bit to enable latched */
+		WRITE_VPP_REG_BITS(VPP_XVYCC_MISC, 0x7, 4, 3);
+		if (on) {
+			VSYNC_WR_MPEG_REG(addr_port, 0);
+			for (i = 0; i < EOTF_INV_LUT_NEG2048_SIZE; i++) {
+				VSYNC_WR_MPEG_REG(addr_port, i);
+				VSYNC_WR_MPEG_REG(data_port, invlut_y_neg[i]);
+			}
+			for (i = 0; i < EOTF_INV_LUT_SIZE; i++) {
+				VSYNC_WR_MPEG_REG(addr_port,
+					EOTF_INV_LUT_NEG2048_SIZE + i);
+				VSYNC_WR_MPEG_REG(data_port, invlut_y[i]);
+			}
+			for (i = 0; i < EOTF_INV_LUT_1024_SIZE; i++) {
+				VSYNC_WR_MPEG_REG(addr_port,
+					EOTF_INV_LUT_NEG2048_SIZE +
+					EOTF_INV_LUT_SIZE + i);
+				VSYNC_WR_MPEG_REG(data_port, invlut_y_1024[i]);
+			}
+			WRITE_VPP_REG_BITS(ctrl_port, 1<<2, 12, 3);
+		} else
+			WRITE_VPP_REG_BITS(ctrl_port, 0, 12, 3);
 	}
-	print_vpp_lut(lut_sel, on);
+	if (debug_csc)
+		print_vpp_lut(lut_sel, on);
 }
 
 /***************************** end of gxl hdr **************************/
@@ -1919,6 +2418,7 @@ static struct vframe_master_display_colour_s cur_master_display_colour = {
 #define SIG_HDR_MODE	0x10
 #define SIG_HDR_SUPPORT	0x20
 #define SIG_WB_CHG	0x40
+
 int signal_type_changed(struct vframe_s *vf, struct vinfo_s *vinfo)
 {
 	u32 signal_type = 0;
@@ -1927,20 +2427,32 @@ int signal_type_changed(struct vframe_s *vf, struct vinfo_s *vinfo)
 	int i, j;
 	struct vframe_master_display_colour_s *p_cur;
 	struct vframe_master_display_colour_s *p_new;
+	struct vframe_master_display_colour_s cus;
 
 	if ((vf->source_type == VFRAME_SOURCE_TYPE_TUNER) ||
 		(vf->source_type == VFRAME_SOURCE_TYPE_CVBS) ||
 		(vf->source_type == VFRAME_SOURCE_TYPE_COMP) ||
 		(vf->source_type == VFRAME_SOURCE_TYPE_HDMI)) {
-		default_signal_type =
-			/* default 709 full */
-			  (1 << 29)	/* video available */
-			| (5 << 26)	/* unspecified */
-			| (1 << 25)	/* full */
-			| (1 << 24)	/* color available */
-			| (1 << 16)	/* bt709 */
-			| (1 << 8)	/* bt709 */
-			| (1 << 0);	/* bt709 */
+		if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB)
+			default_signal_type =
+				/* default 709 full */
+				  (1 << 29)	/* video available */
+				| (5 << 26)	/* unspecified */
+				| (1 << 25)	/* limit */
+				| (1 << 24)	/* color available */
+				| (1 << 16)	/* bt709 */
+				| (1 << 8)	/* bt709 */
+				| (1 << 0);	/* bt709 */
+		else
+			default_signal_type =
+				/* default 709 limit */
+				  (1 << 29)	/* video available */
+				| (5 << 26)	/* unspecified */
+				| (0 << 25)	/* limit */
+				| (1 << 24)	/* color available */
+				| (1 << 16)	/* bt709 */
+				| (1 << 8)	/* bt709 */
+				| (1 << 0);	/* bt709 */
 	} else { /* for local play */
 		if (vf->height >= 720)
 			default_signal_type =
@@ -1970,7 +2482,30 @@ int signal_type_changed(struct vframe_s *vf, struct vinfo_s *vinfo)
 
 	p_new = &vf->prop.master_display_colour;
 	p_cur = &cur_master_display_colour;
-	if (p_new->present_flag) {
+	/* customer overwrite */
+	if (customer_master_display_en
+	&& ((p_new->present_flag & 0x80000000) == 0)) {
+		signal_type =	  (1 << 29)	/* video available */
+				| (5 << 26)	/* unspecified */
+				| (0 << 25)	/* limit */
+				| (1 << 24)	/* color available */
+				| (9 << 16)	/* 2020 */
+				| (16 << 8)	/* 2084 */
+				| (9 << 0);	/* 2020 */
+		for (i = 0; i < 3; i++)
+			for (j = 0; j < 2; j++)
+				cus.primaries[i][j] =
+					customer_master_display_param[i*2+j];
+		for (i = 0; i < 2; i++)
+			cus.white_point[i] =
+				customer_master_display_param[6+i];
+		for (i = 0; i < 2; i++)
+			cus.luminance[i] =
+				customer_master_display_param[8+i];
+		cus.present_flag = 1;
+		p_new = &cus;
+	}
+	if (p_new->present_flag & 1) {
 		for (i = 0; i < 3; i++)
 			for (j = 0; j < 2; j++) {
 				if (p_cur->primaries[i][j]
@@ -2025,6 +2560,11 @@ int signal_type_changed(struct vframe_s *vf, struct vinfo_s *vinfo)
 		change_flag |= SIG_HDR_MODE;
 		cur_hdr_process_mode = hdr_process_mode;
 	}
+	if (cur_sdr_process_mode != sdr_process_mode) {
+		pr_csc("SDR mode changed.\n");
+		change_flag |= SIG_HDR_MODE;
+		cur_sdr_process_mode = sdr_process_mode;
+	}
 	if (cur_hdr_support != (vinfo->hdr_info.hdr_support & 0x4)) {
 		pr_csc("Tx HDR support changed.\n");
 		change_flag |= SIG_HDR_SUPPORT;
@@ -2097,6 +2637,26 @@ enum vpp_matrix_csc_e get_csc_type(void)
 	return csc_type;
 }
 
+static void cal_out_curve(uint panel_luma)
+{
+	int index;
+	if (panel_luma == 0)
+		return;
+
+	if (panel_luma <= 500) {
+		if (panel_luma < 250)
+			panel_luma = 250;
+		index = (panel_luma - 250) / 20;
+	} else {
+		if (panel_luma > 1000)
+			panel_luma = 1000;
+		index = ((500 - 240) / 20) + (panel_luma - 500) / 100;
+	}
+	memcpy(eotf_33_2084_mapping,
+		eotf_33_2084_table[index], sizeof(int) * 33);
+	memcpy(oetf_289_gamma22_mapping,
+		oetf_289_gamma22_table[index], sizeof(int) * 289);
+}
 static void mtx_dot_mul(
 	int64_t (*a)[3], int64_t (*b)[3],
 	int64_t (*out)[3], int32_t norm)
@@ -2206,6 +2766,29 @@ static void gamut_mtx(
 	mtx_mul_mtx(out, Tsrc, Tout, 1 << obl);
 }
 
+static void apply_scale_factor(int64_t (*in)[3], int32_t *rs)
+{
+	int i, j;
+	int32_t right_shift;
+
+	if (display_scale_factor > 2 * 2048)
+		right_shift = -2;
+	else if (display_scale_factor > 2048)
+		right_shift = -1;
+	else
+		right_shift = 0;
+	for (i = 0; i < 3; i++)
+		for (j = 0; j < 3; j++) {
+			in[i][j] *= display_scale_factor;
+			in[i][j] >>= 11 - right_shift;
+		}
+	right_shift += 1;
+	if (right_shift < 0)
+		*rs = 8 + right_shift;
+	else
+		*rs = right_shift;
+}
+
 static void N2C(int64_t (*in)[3], int32_t ibl, int32_t obl)
 {
 	int i, j;
@@ -2224,6 +2807,11 @@ static void cal_mtx_seting(
 	struct matrix_s *m)
 {
 	int i, j;
+	int32_t right_shift;
+	if (get_cpu_type() > MESON_CPU_MAJOR_ID_GXTVBB) {
+		apply_scale_factor(in, &right_shift);
+		m->right_shift = right_shift;
+	}
 	N2C(in, ibl, obl);
 	pr_csc("\tHDR color convert matrix:\n");
 	for (i = 0; i < 3; i++) {
@@ -2236,7 +2824,6 @@ static void cal_mtx_seting(
 			(int)(m->matrix[i][1] & 0xffff),
 			(int)(m->matrix[i][2] & 0xffff));
 	}
-	m->right_shift = 1;
 }
 
 static int check_primaries(
@@ -2249,75 +2836,89 @@ static int check_primaries(
 	int32_t (*si)[4][2], int32_t (*di)[4][2])
 {
 	int i, j;
-	int need_calculate_mtx = 0;
+	/* always calculate to apply scale factor */
+	int need_calculate_mtx = 1;
 	const struct master_display_info_s *d;
 
 	/* check and copy primaries */
-	if (((*p)[0][1] > (*p)[1][1])
-		&& ((*p)[0][1] > (*p)[2][1])
-		&& ((*p)[2][0] > (*p)[0][0])
-		&& ((*p)[2][0] > (*p)[1][0])) {
-		/* reasonable g,b,r */
-		for (i = 0; i < 3; i++)
-			for (j = 0; j < 2; j++) {
-				(*si)[i][j] = (*p)[(i + 2) % 3][j];
-			if ((*si)[i][j] != bt2020_primaries[(i + 2) % 3][j])
-				need_calculate_mtx = 1;
-			}
-	} else if (((*p)[0][0] > (*p)[1][0])
-		&& ((*p)[0][0] > (*p)[2][0])
-		&& ((*p)[1][1] > (*p)[0][1])
-		&& ((*p)[1][1] > (*p)[2][1])) {
-		/* reasonable r,g,b */
-		for (i = 0; i < 3; i++)
-			for (j = 0; j < 2; j++) {
-				(*si)[i][j] = (*p)[i][j];
-			if ((*si)[i][j] != bt2020_primaries[(i + 2) % 3][j])
-				need_calculate_mtx = 1;
-			}
-	} else {
-		/* source not usable, use standard bt2020 */
-		for (i = 0; i < 3; i++)
-			for (j = 0; j < 2; j++)
-				(*si)[i][j] = bt2020_primaries[(i + 2) % 3][j];
-	}
-
-	/* check white point */
-	if (need_calculate_mtx == 1) {
-		if (((*w)[0] > (*si)[2][0]) &&
-			((*w)[0] < (*si)[0][0]) &&
-			((*w)[1] > (*si)[2][1]) &&
-			((*w)[1] < (*si)[1][1])) {
-				for (i = 0; i < 2; i++)
-					(*si)[3][i] = (*w)[i];
+	if (hdr_flag & 1) {
+		if (((*p)[0][1] > (*p)[1][1])
+			&& ((*p)[0][1] > (*p)[2][1])
+			&& ((*p)[2][0] > (*p)[0][0])
+			&& ((*p)[2][0] > (*p)[1][0])) {
+			/* reasonable g,b,r */
+			for (i = 0; i < 3; i++)
+				for (j = 0; j < 2; j++) {
+					(*si)[i][j] = (*p)[(i + 2) % 3][j];
+				if ((*si)[i][j] !=
+				bt2020_primaries[(i + 2) % 3][j])
+					need_calculate_mtx = 1;
+				}
+		} else if (((*p)[0][0] > (*p)[1][0])
+			&& ((*p)[0][0] > (*p)[2][0])
+			&& ((*p)[1][1] > (*p)[0][1])
+			&& ((*p)[1][1] > (*p)[2][1])) {
+			/* reasonable r,g,b */
+			for (i = 0; i < 3; i++)
+				for (j = 0; j < 2; j++) {
+					(*si)[i][j] = (*p)[i][j];
+					if ((*si)[i][j] !=
+					bt2020_primaries[(i + 2) % 3][j])
+						need_calculate_mtx = 1;
+				}
 		} else {
+			/* source not usable, use standard bt2020 */
 			for (i = 0; i < 3; i++)
 				for (j = 0; j < 2; j++)
 					(*si)[i][j] =
-				bt2020_primaries[(i + 2) % 3][j];
-
-			for (i = 0; i < 2; i++)
-				(*si)[3][i] = bt2020_white_point[i];
-			need_calculate_mtx = 0;
+						bt2020_primaries
+						[(i + 2) % 3][j];
 		}
-	} else {
-		if (((*w)[0] > (*si)[2][0]) &&
-			((*w)[0] < (*si)[0][0]) &&
-			((*w)[1] > (*si)[2][1]) &&
-			((*w)[1] < (*si)[1][1])) {
-			for (i = 0; i < 2; i++) {
-				(*si)[3][i] = (*w)[i];
-				if ((*si)[3][i] != bt2020_white_point[i])
-					need_calculate_mtx = 1;
+		/* check white point */
+		if (need_calculate_mtx == 1) {
+			if (((*w)[0] > (*si)[2][0]) &&
+				((*w)[0] < (*si)[0][0]) &&
+				((*w)[1] > (*si)[2][1]) &&
+				((*w)[1] < (*si)[1][1])) {
+					for (i = 0; i < 2; i++)
+						(*si)[3][i] = (*w)[i];
+			} else {
+				for (i = 0; i < 3; i++)
+					for (j = 0; j < 2; j++)
+						(*si)[i][j] =
+					bt2020_primaries[(i + 2) % 3][j];
+
+				for (i = 0; i < 2; i++)
+					(*si)[3][i] = bt2020_white_point[i];
+				/* need_calculate_mtx = 0; */
 			}
 		} else {
-			for (i = 0; i < 2; i++)
-				(*si)[3][i] = bt2020_white_point[i];
+			if (((*w)[0] > (*si)[2][0]) &&
+				((*w)[0] < (*si)[0][0]) &&
+				((*w)[1] > (*si)[2][1]) &&
+				((*w)[1] < (*si)[1][1])) {
+				for (i = 0; i < 2; i++) {
+					(*si)[3][i] = (*w)[i];
+					if ((*si)[3][i] !=
+					bt2020_white_point[i])
+						need_calculate_mtx = 1;
+				}
+			} else {
+				for (i = 0; i < 2; i++)
+					(*si)[3][i] = bt2020_white_point[i];
+			}
 		}
+	} else {
+		/* use standard bt2020 */
+		for (i = 0; i < 3; i++)
+			for (j = 0; j < 2; j++)
+				(*si)[i][j] = bt2020_primaries[(i + 2) % 3][j];
+		for (i = 0; i < 2; i++)
+			(*si)[3][i] = bt2020_white_point[i];
 	}
 
 	/* check display */
-	if (v->master_display_info.present_flag) {
+	if ((v->master_display_info.present_flag) && (hdr_flag & 2)) {
 		d = &v->master_display_info;
 		for (i = 0; i < 3; i++) {
 			for (j = 0; j < 2; j++) {
@@ -2332,6 +2933,8 @@ static int check_primaries(
 			if ((*di)[3][i] != bt709_white_point[i])
 				need_calculate_mtx = 1;
 		}
+		if (v->hdr_info.sink_flag)
+			cal_out_curve(v->hdr_info.lumi_max);
 	} else {
 		for (i = 0; i < 3; i++) {
 			for (j = 0; j < 2; j++)
@@ -2347,14 +2950,16 @@ enum vpp_matrix_csc_e prepare_customer_matrix(
 	u32 (*s)[3][2],	/* source primaries */
 	u32 (*w)[2],	/* source white point */
 	const struct vinfo_s *v, /* vinfo carry display primaries */
-	struct matrix_s *m)
+	struct matrix_s *m,
+	bool inverse_flag)
 {
 	int32_t prmy_src[4][2];
 	int32_t prmy_dst[4][2];
 	int64_t out[3][3];
 	int i, j;
 
-	if (customer_matrix_en) {
+	if ((customer_matrix_en &&
+		get_cpu_type() <= MESON_CPU_MAJOR_ID_GXTVBB)) {
 		for (i = 0; i < 3; i++) {
 			m->pre_offset[i] =
 				customer_matrix_param[i];
@@ -2368,11 +2973,18 @@ enum vpp_matrix_csc_e prepare_customer_matrix(
 			customer_matrix_param[15];
 		return VPP_MATRIX_BT2020RGB_CUSRGB;
 	} else {
-		if (check_primaries(s, w, v, &prmy_src, &prmy_dst)) {
-			gamut_mtx(prmy_src, prmy_dst, out, INORM, BL);
-			cal_mtx_seting(out, BL, 13, m);
-			return VPP_MATRIX_BT2020RGB_CUSRGB;
+		if (inverse_flag) {
+			if (check_primaries(s, w, v, &prmy_src, &prmy_dst)) {
+				gamut_mtx(prmy_dst, prmy_src, out, INORM, BL);
+				cal_mtx_seting(out, BL, 13, m);
+			}
+		} else {
+			if (check_primaries(s, w, v, &prmy_src, &prmy_dst)) {
+				gamut_mtx(prmy_src, prmy_dst, out, INORM, BL);
+				cal_mtx_seting(out, BL, 13, m);
+			}
 		}
+		return VPP_MATRIX_BT2020RGB_CUSRGB;
 	}
 	return VPP_MATRIX_BT2020YUV_BT2020RGB;
 }
@@ -2432,23 +3044,53 @@ static void print_primaries_info(struct vframe_master_display_colour_s *p)
 }
 
 static void amvecm_cp_hdr_info(struct master_display_info_s *hdr_data,
-		struct vframe_s *vf)
+		struct vframe_master_display_colour_s *p)
 {
 	int i, j;
-
-	if (((hdr_data->features >> 16) & 0xff) == 9) {
-		if (vf->prop.master_display_colour.present_flag) {
-
+	if (customer_hdmi_display_en) {
+		hdr_data->features =
+			  (1 << 29)	/* video available */
+			| (5 << 26)	/* unspecified */
+			| (0 << 25)	/* limit */
+			| (1 << 24)	/* color available */
+			| (customer_hdmi_display_param[0] << 16) /* bt2020 */
+			| (customer_hdmi_display_param[1] << 8)	/* 2084 */
+			| (10 << 0);	/* bt2020c */
+		memcpy(hdr_data->primaries,
+			&customer_hdmi_display_param[2],
+			sizeof(u32)*6);
+		memcpy(hdr_data->white_point,
+			&customer_hdmi_display_param[8],
+			sizeof(u32)*2);
+		hdr_data->luminance[0] =
+				customer_hdmi_display_param[10];
+		hdr_data->luminance[1] =
+				customer_hdmi_display_param[11];
+		hdr_data->max_content =
+				customer_hdmi_display_param[12];
+		hdr_data->max_frame_average =
+				customer_hdmi_display_param[13];
+	} else if (((hdr_data->features >> 16) & 0xff) == 9) {
+		if (p->present_flag & 1) {
 			memcpy(hdr_data->primaries,
-				vf->prop.master_display_colour.primaries,
+				p->primaries,
 				sizeof(u32)*6);
 			memcpy(hdr_data->white_point,
-				vf->prop.master_display_colour.white_point,
+				p->white_point,
 				sizeof(u32)*2);
 			hdr_data->luminance[0] =
-				vf->prop.master_display_colour.luminance[0];
+				p->luminance[0];
 			hdr_data->luminance[1] =
-				vf->prop.master_display_colour.luminance[1];
+				p->luminance[1];
+			if (p->content_light_level.present_flag == 1) {
+				hdr_data->max_content =
+					p->content_light_level.max_content;
+				hdr_data->max_frame_average =
+					p->content_light_level.max_pic_average;
+			} else {
+				hdr_data->max_content = 0;
+				hdr_data->max_frame_average = 0;
+			}
 		} else {
 			for (i = 0; i < 3; i++)
 				for (j = 0; j < 2; j++)
@@ -2456,10 +3098,13 @@ static void amvecm_cp_hdr_info(struct master_display_info_s *hdr_data,
 							bt2020_primaries[i][j];
 			hdr_data->white_point[0] = bt709_white_point[0];
 			hdr_data->white_point[1] = bt709_white_point[1];
-			/* default luminance
-			 * (got from exodus uhd hdr exodus draft.mp4) */
-			hdr_data->luminance[0] = 0xb71b00;
-			hdr_data->luminance[1] = 0xc8;
+			/* default luminance */
+			hdr_data->luminance[0] = 5000 * 10000;
+			hdr_data->luminance[1] = 50;
+
+			/* content_light_level */
+			hdr_data->max_content = 0;
+			hdr_data->max_frame_average = 0;
 		}
 		hdr_data->luminance[0] = hdr_data->luminance[0] / 10000;
 		hdr_data->present_flag = 1;
@@ -2472,12 +3117,19 @@ static void amvecm_cp_hdr_info(struct master_display_info_s *hdr_data,
 
 }
 
+static void hdr_process_pq_enable(int enable)
+{
+	dnlp_en = enable;
+	/*cm_en = enable;*/
+}
+
 static int hdr_process(
 	enum vpp_matrix_csc_e csc_type,
 	struct vinfo_s *vinfo,
 	struct vframe_master_display_colour_s *master_info)
 {
-	int need_adjust_contrast = 0;
+	int need_adjust_contrast_saturation = 0;
+	int max_lumin = 10000;
 	struct matrix_s m = {
 		{0, 0, 0},
 		{
@@ -2488,6 +3140,16 @@ static int hdr_process(
 		{0, 0, 0},
 		1
 	};
+	struct matrix_s osd_m = {
+		{0, 0, 0},
+		{
+			{0x505, 0x2A2, 0x059},
+			{0x08E, 0x75B, 0x017},
+			{0x022, 0x0B4, 0x72A},
+		},
+		{0, 0, 0},
+		1
+	};
 	int mtx[EOTF_COEFF_SIZE] = {
 		EOTF_COEFF_NORM(1.6607056/2), EOTF_COEFF_NORM(-0.5877533/2),
 		EOTF_COEFF_NORM(-0.0729065/2),
@@ -2497,26 +3159,48 @@ static int hdr_process(
 		EOTF_COEFF_NORM(1.1186371/2),
 		EOTF_COEFF_RIGHTSHIFT,
 	};
+	int osd_mtx[EOTF_COEFF_SIZE] = {
+		EOTF_COEFF_NORM(0.627441),	EOTF_COEFF_NORM(0.329285),
+		EOTF_COEFF_NORM(0.043274),
+		EOTF_COEFF_NORM(0.069092),	EOTF_COEFF_NORM(0.919556),
+		EOTF_COEFF_NORM(0.011322),
+		EOTF_COEFF_NORM(0.016418),	EOTF_COEFF_NORM(0.088058),
+		EOTF_COEFF_NORM(0.895554),
+		EOTF_COEFF_RIGHTSHIFT
+	};
 	int i, j;
 
-	if (master_info->present_flag) {
+	if (master_info->present_flag & 1) {
 		pr_csc("\tMaster_display_colour available.\n");
 		print_primaries_info(master_info);
+		/* for VIDEO */
 		csc_type =
 			prepare_customer_matrix(
 				&master_info->primaries,
 				&master_info->white_point,
-				vinfo, &m);
-		need_adjust_contrast = 1;
+				vinfo, &m, 0);
+		/* for OSD */
+		if (get_cpu_type() > MESON_CPU_MAJOR_ID_GXTVBB)
+			prepare_customer_matrix(
+				&master_info->primaries,
+				&master_info->white_point,
+				vinfo, &osd_m, 1);
+		need_adjust_contrast_saturation |= 1;
 	} else {
 		/* use bt2020 primaries */
 		pr_csc("\tNo master_display_colour.\n");
+		/* for VIDEO */
 		csc_type =
-		prepare_customer_matrix(
+			prepare_customer_matrix(
 			&bt2020_primaries,
 			&bt2020_white_point,
-			vinfo, &m);
-		need_adjust_contrast = 0;
+			vinfo, &m, 0);
+		/* for OSD */
+		if (get_cpu_type() > MESON_CPU_MAJOR_ID_GXTVBB)
+			prepare_customer_matrix(
+				&bt2020_primaries,
+				&bt2020_white_point,
+				vinfo, &osd_m, 1);
 	}
 
 	if (get_cpu_type() > MESON_CPU_MAJOR_ID_GXTVBB) {
@@ -2528,48 +3212,74 @@ static int hdr_process(
 			0, 7, 1);
 		*/
 
-		/* eotf lut bypass */
+		/* eotf lut 709 */
 		set_vpp_lut(VPP_LUT_OSD_EOTF,
-			eotf_33_linear_mapping, /* R */
-			eotf_33_linear_mapping, /* G */
-			eotf_33_linear_mapping, /* B */
+			osd_eotf_33_709_mapping, /* R */
+			osd_eotf_33_709_mapping, /* G */
+			osd_eotf_33_709_mapping, /* B */
 			CSC_ON);
 
-		/* eotf matrix bypass */
+		/* eotf matrix 709->2020 */
+		osd_mtx[EOTF_COEFF_SIZE - 1] = osd_m.right_shift;
+		for (i = 0; i < 3; i++)
+			for (j = 0; j < 3; j++) {
+				if (osd_m.matrix[i][j] & 0x1000)
+					osd_mtx[i * 3 + j] =
+					-(((~osd_m.matrix[i][j]) & 0xfff) + 1);
+				else
+					osd_mtx[i * 3 + j] = osd_m.matrix[i][j];
+			}
 		set_vpp_matrix(VPP_MATRIX_OSD_EOTF,
-			eotf_bypass_coeff,
+			osd_mtx,
 			CSC_ON);
 
-		/* oetf lut bypass */
+		/* oetf lut 2084 */
 		set_vpp_lut(VPP_LUT_OSD_OETF,
-			oetf_41_linear_mapping, /* R */
-			oetf_41_linear_mapping, /* G */
-			oetf_41_linear_mapping, /* B */
+			osd_oetf_41_2084_mapping, /* R */
+			osd_oetf_41_2084_mapping, /* G */
+			osd_oetf_41_2084_mapping, /* B */
 			CSC_ON);
 
-		/* osd matrix RGB709 to YUV709 limit */
+		/* osd matrix RGB2020 to YUV2020 limit */
 		set_vpp_matrix(VPP_MATRIX_OSD,
-			RGB709_to_YUV709l_coeff,
+			RGB2020_to_YUV2020l_coeff,
 			CSC_ON);
 
 		/************** VIDEO **************/
 		/* vd1 matrix bypass */
 		set_vpp_matrix(VPP_MATRIX_VD1,
 			bypass_coeff,
-			CSC_ON);
+			CSC_OFF);
 
 		/* post matrix YUV2020 to RGB2020 */
 		set_vpp_matrix(VPP_MATRIX_POST,
 			YUV2020l_to_RGB2020_coeff,
 			CSC_ON);
 
-		/* eotf lut bypass */
+		/* eotf lut 2048 */
 		set_vpp_lut(VPP_LUT_EOTF,
 			eotf_33_2084_mapping, /* R */
 			eotf_33_2084_mapping, /* G */
 			eotf_33_2084_mapping, /* B */
 			CSC_ON);
 
+		need_adjust_contrast_saturation = 0;
+		saturation_offset =	0;
+		if (hdr_flag & 8) {
+			need_adjust_contrast_saturation |= 2;
+			saturation_offset =	extra_sat_lut[0];
+		}
+		if (master_info->present_flag & 1) {
+			max_lumin = master_info->luminance[0]
+				/ 10000;
+			if ((max_lumin <= 1200) && (max_lumin > 0)) {
+				if (hdr_flag & 4)
+					need_adjust_contrast_saturation |= 1;
+				if (hdr_flag & 8)
+					saturation_offset =
+						extra_sat_lut[1];
+			}
+		}
 		/* eotf matrix RGB2020 to RGB709 */
 		mtx[EOTF_COEFF_SIZE - 1] = m.right_shift;
 		for (i = 0; i < 3; i++)
@@ -2586,9 +3296,9 @@ static int hdr_process(
 
 		/* oetf lut bypass */
 		set_vpp_lut(VPP_LUT_OETF,
-			oetf_289_hlg_mapping,
-			oetf_289_hlg_mapping,
-			oetf_289_hlg_mapping,
+			oetf_289_gamma22_mapping,
+			oetf_289_gamma22_mapping,
+			oetf_289_gamma22_mapping,
 			CSC_ON);
 
 		/* xvyccc matrix3: bypass */
@@ -2599,9 +3309,7 @@ static int hdr_process(
 		else /* xvycc matrix bypass for LCD */
 			set_vpp_matrix(VPP_MATRIX_XVYCC,
 				bypass_coeff,
-				CSC_ON);
-		/* not adjust contrast in gxl for now */
-		need_adjust_contrast = 0;
+				CSC_OFF);
 	} else {
 
 		/* turn vd1 matrix on */
@@ -2612,6 +3320,9 @@ static int hdr_process(
 			csc_type, &m);
 		/* xvycc lut on */
 		load_knee_lut(CSC_ON);
+
+		vecm_latch_flag |= FLAG_VADJ1_BRI;
+		hdr_process_pq_enable(0);
 		/* if GXTVBB HDMI output(YUV) case */
 		/* xvyccc matrix3: RGB to YUV */
 		/* other cases */
@@ -2622,13 +3333,34 @@ static int hdr_process(
 		else
 			vpp_set_matrix3(CSC_OFF, VPP_MATRIX_NULL);
 	}
-	return need_adjust_contrast;
+	return need_adjust_contrast_saturation;
 }
 
 static void bypass_hdr_process(
 	enum vpp_matrix_csc_e csc_type,
-	struct vinfo_s *vinfo)
+	struct vinfo_s *vinfo,
+	struct vframe_master_display_colour_s *master_info)
 {
+	struct matrix_s osd_m = {
+		{0, 0, 0},
+		{
+			{0x505, 0x2A2, 0x059},
+			{0x08E, 0x75B, 0x017},
+			{0x022, 0x0B4, 0x72A},
+		},
+		{0, 0, 0},
+		1
+	};
+	int osd_mtx[EOTF_COEFF_SIZE] = {
+		EOTF_COEFF_NORM(0.627441),	EOTF_COEFF_NORM(0.329285),
+		EOTF_COEFF_NORM(0.043274),
+		EOTF_COEFF_NORM(0.069092),	EOTF_COEFF_NORM(0.919556),
+		EOTF_COEFF_NORM(0.011322),
+		EOTF_COEFF_NORM(0.016418),	EOTF_COEFF_NORM(0.088058),
+		EOTF_COEFF_NORM(0.895554),
+		EOTF_COEFF_RIGHTSHIFT
+	};
+	int i, j;
 	if (get_cpu_type() > MESON_CPU_MAJOR_ID_GXTVBB) {
 		/************** OSD ***************/
 		/* RGB to YUV */
@@ -2637,46 +3369,122 @@ static void bypass_hdr_process(
 		/* WRITE_VPP_REG_BITS(VIU_OSD1_BLK0_CFG_W0,
 			0, 7, 1);
 		*/
+		if ((csc_type == VPP_MATRIX_BT2020YUV_BT2020RGB) &&
+			(((vinfo->hdr_info.hdr_support & 0x4) &&
+			(vinfo->viu_color_fmt != TVIN_RGB444)) ||
+			(vinfo->viu_color_fmt == TVIN_RGB444))) {
+			/* OSD convert to HDR to match HDR video */
+			/* osd eotf lut 709 */
+			set_vpp_lut(VPP_LUT_OSD_EOTF,
+				osd_eotf_33_709_mapping, /* R */
+				osd_eotf_33_709_mapping, /* G */
+				osd_eotf_33_709_mapping, /* B */
+				CSC_ON);
 
-		/* eotf lut bypass */
-		set_vpp_lut(VPP_LUT_OSD_EOTF,
-			eotf_33_linear_mapping, /* R */
-			eotf_33_linear_mapping, /* G */
-			eotf_33_linear_mapping, /* B */
-			CSC_ON);
-
-		/* eotf matrix bypass */
-		set_vpp_matrix(VPP_MATRIX_OSD_EOTF,
-			eotf_bypass_coeff,
-			CSC_ON);
+			/* osd eotf matrix 709->2020 */
+			if (master_info->present_flag & 1) {
+				pr_csc("\tMaster_display_colour available.\n");
+				print_primaries_info(master_info);
+				prepare_customer_matrix(
+					&master_info->primaries,
+					&master_info->white_point,
+					vinfo, &osd_m, 1);
+			} else {
+				pr_csc("\tNo master_display_colour.\n");
+				prepare_customer_matrix(
+					&bt2020_primaries,
+					&bt2020_white_point,
+					vinfo, &osd_m, 1);
+			}
+			osd_mtx[EOTF_COEFF_SIZE - 1] = osd_m.right_shift;
+			for (i = 0; i < 3; i++)
+				for (j = 0; j < 3; j++) {
+					if (osd_m.matrix[i][j] & 0x1000) {
+						osd_mtx[i * 3 + j] =
+						(~osd_m.matrix[i][j]) & 0xfff;
+						osd_mtx[i * 3 + j] =
+						-(1 + osd_mtx[i * 3 + j]);
+					} else
+						osd_mtx[i * 3 + j] =
+							osd_m.matrix[i][j];
+				}
+			set_vpp_matrix(VPP_MATRIX_OSD_EOTF,
+				osd_mtx,
+				CSC_ON);
 
-		/* oetf lut bypass */
-		set_vpp_lut(VPP_LUT_OSD_OETF,
-			oetf_41_linear_mapping, /* R */
-			oetf_41_linear_mapping, /* G */
-			oetf_41_linear_mapping, /* B */
-			CSC_ON);
+			/* osd oetf lut 2084 */
+			set_vpp_lut(VPP_LUT_OSD_OETF,
+				osd_oetf_41_2084_mapping, /* R */
+				osd_oetf_41_2084_mapping, /* G */
+				osd_oetf_41_2084_mapping, /* B */
+				CSC_ON);
 
-		/* osd matrix RGB709 to YUV709 limit/full */
-		set_vpp_matrix(VPP_MATRIX_OSD,
-			RGB709_to_YUV709l_coeff,
-			CSC_ON);	/* use limit range */
+			/* osd matrix RGB2020 to YUV2020 limit */
+			set_vpp_matrix(VPP_MATRIX_OSD,
+				RGB2020_to_YUV2020l_coeff,
+				CSC_ON);
+		} else {
+			/* OSD convert to 709 limited to match SDR video */
+			/* eotf lut bypass */
+			set_vpp_lut(VPP_LUT_OSD_EOTF,
+				eotf_33_linear_mapping, /* R */
+				eotf_33_linear_mapping, /* G */
+				eotf_33_linear_mapping, /* B */
+				CSC_OFF);
+
+			/* eotf matrix bypass */
+			set_vpp_matrix(VPP_MATRIX_OSD_EOTF,
+				eotf_bypass_coeff,
+				CSC_OFF);
+
+			/* oetf lut bypass */
+			set_vpp_lut(VPP_LUT_OSD_OETF,
+				oetf_41_linear_mapping, /* R */
+				oetf_41_linear_mapping, /* G */
+				oetf_41_linear_mapping, /* B */
+				CSC_OFF);
+
+			/* osd matrix RGB709 to YUV709 limit/full */
+			if (range_control)
+				set_vpp_matrix(VPP_MATRIX_OSD,
+					RGB709_to_YUV709_coeff,
+					CSC_ON);	/* use full range */
+			else
+				set_vpp_matrix(VPP_MATRIX_OSD,
+					RGB709_to_YUV709l_coeff,
+					CSC_ON);	/* use limit range */
+		}
 
 		/************** VIDEO **************/
 		/* vd1 matrix: bypass */
 		if (csc_type == VPP_MATRIX_BT2020YUV_BT2020RGB)
 			set_vpp_matrix(VPP_MATRIX_VD1,
 				bypass_coeff,
-				CSC_ON);	/* limit->limit range */
+				CSC_OFF);	/* limit->limit range */
 		else {
-			if (signal_range == 0) /* limit range */
-				set_vpp_matrix(VPP_MATRIX_VD1,
-					bypass_coeff,
-					CSC_ON);	/* limit->limit range */
-			else
-				set_vpp_matrix(VPP_MATRIX_VD1,
-					YUV709f_to_YUV709l_coeff,
-					CSC_ON);	/* full->limit range */
+			if (range_control) {
+				if (signal_range == 0) /* limit range */
+					set_vpp_matrix(VPP_MATRIX_VD1,
+						YUV709l_to_YUV709f_coeff,
+						CSC_ON);
+					/* limit->full range */
+				else
+					set_vpp_matrix(VPP_MATRIX_VD1,
+						bypass_coeff,
+						CSC_OFF);
+					/* full->full range */
+			} else {
+				if (signal_range == 0) /* limit range */
+					set_vpp_matrix(VPP_MATRIX_VD1,
+						bypass_coeff,
+						CSC_OFF);
+					/* limit->limit range */
+				else
+					set_vpp_matrix(VPP_MATRIX_VD1,
+						YUV709f_to_YUV709l_coeff,
+						CSC_ON);
+					/* full->limit range */
+			}
 		}
 
 		/* post matrix bypass */
@@ -2684,22 +3492,39 @@ static void bypass_hdr_process(
 			/* yuv2rgb for eye protect mode */
 			set_vpp_matrix(VPP_MATRIX_POST,
 				bypass_coeff,
-				CSC_ON);
+				CSC_OFF);
 		else /* matrix yuv2rgb for LCD */
 			set_vpp_matrix(VPP_MATRIX_POST,
 				YUV709l_to_RGB709_coeff,
 				CSC_ON);
+		/* xvycc inv lut */
+		if (sdr_process_mode &&
+		(csc_type < VPP_MATRIX_BT2020YUV_BT2020RGB) &&
+		((get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) ||
+		 (get_cpu_type() == MESON_CPU_MAJOR_ID_TXL)))
+			set_vpp_lut(VPP_LUT_INV_EOTF,
+				NULL,
+				NULL,
+				NULL,
+				CSC_ON);
+		else
+			set_vpp_lut(VPP_LUT_INV_EOTF,
+				NULL,
+				NULL,
+				NULL,
+				CSC_OFF);
+
 		/* eotf lut bypass */
 		set_vpp_lut(VPP_LUT_EOTF,
-			eotf_33_linear_mapping, /* R */
-			eotf_33_linear_mapping, /* G */
-			eotf_33_linear_mapping, /* B */
-			CSC_ON);
+			NULL, /* R */
+			NULL, /* G */
+			NULL, /* B */
+			CSC_OFF);
 
 		/* eotf matrix bypass */
 		set_vpp_matrix(VPP_MATRIX_EOTF,
 			eotf_bypass_coeff,
-			CSC_ON);
+			CSC_OFF);
 
 		/* oetf lut bypass */
 		set_vpp_lut(VPP_LUT_OETF,
@@ -2708,10 +3533,21 @@ static void bypass_hdr_process(
 			NULL,
 			CSC_OFF);
 
-		/* xvycc matrix bypass */
-		set_vpp_matrix(VPP_MATRIX_XVYCC,
-			bypass_coeff,
-			CSC_ON);
+		/* xvycc matrix full2limit or bypass */
+		if (csc_type == VPP_MATRIX_BT2020YUV_BT2020RGB) {
+			set_vpp_matrix(VPP_MATRIX_XVYCC,
+				bypass_coeff,
+				CSC_OFF);
+		} else {
+			if (range_control)
+				set_vpp_matrix(VPP_MATRIX_XVYCC,
+					YUV709f_to_YUV709l_coeff,
+					CSC_ON);
+			else
+				set_vpp_matrix(VPP_MATRIX_XVYCC,
+					bypass_coeff,
+					CSC_OFF);
+		}
 	} else {
 		/* OSD */
 		/* keep RGB */
@@ -2729,6 +3565,23 @@ static void bypass_hdr_process(
 			csc_type, NULL);
 		/* xvycc lut off */
 		load_knee_lut(CSC_OFF);
+		/* xvycc inv lut */
+
+		if (sdr_process_mode)
+			set_vpp_lut(VPP_LUT_INV_EOTF,
+				NULL,
+				NULL,
+				NULL,
+				CSC_ON);
+		else
+			set_vpp_lut(VPP_LUT_INV_EOTF,
+				NULL,
+				NULL,
+				NULL,
+				CSC_OFF);
+
+		vecm_latch_flag |= FLAG_VADJ1_BRI;
+		hdr_process_pq_enable(1);
 		/* if GXTVBB HDMI output(YUV) case */
 		/* xvyccc matrix3: RGB to YUV */
 		/* other cases */
@@ -2741,6 +3594,98 @@ static void bypass_hdr_process(
 	}
 }
 
+static void sdr_hdr_process(
+	enum vpp_matrix_csc_e csc_type,
+	struct vinfo_s *vinfo,
+	struct vframe_master_display_colour_s *master_info)
+{
+	if ((get_cpu_type() == MESON_CPU_MAJOR_ID_GXL) ||
+		(get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)) {
+		/* OSD convert to 709 limited to match SDR video */
+		/* eotf lut bypass */
+		set_vpp_lut(VPP_LUT_OSD_EOTF,
+			eotf_33_linear_mapping, /* R */
+			eotf_33_linear_mapping, /* G */
+			eotf_33_linear_mapping, /* B */
+			CSC_OFF);
+
+		/* eotf matrix bypass */
+		set_vpp_matrix(VPP_MATRIX_OSD_EOTF,
+			eotf_bypass_coeff,
+			CSC_OFF);
+
+		/* oetf lut bypass */
+		set_vpp_lut(VPP_LUT_OSD_OETF,
+			oetf_41_linear_mapping, /* R */
+			oetf_41_linear_mapping, /* G */
+			oetf_41_linear_mapping, /* B */
+			CSC_OFF);
+
+		/* osd matrix RGB709 to YUV709 limit/full */
+		if (range_control)
+			set_vpp_matrix(VPP_MATRIX_OSD,
+				RGB709_to_YUV709_coeff,
+				CSC_ON);	/* use full range */
+		else
+			set_vpp_matrix(VPP_MATRIX_OSD,
+				RGB709_to_YUV709l_coeff,
+				CSC_ON);	/* use limit range */
+
+		/************** VIDEO **************/
+		/* convert SDR Video to HDR */
+		if (range_control) {
+			if (signal_range == 0) /* limit range */
+				set_vpp_matrix(VPP_MATRIX_VD1,
+					YUV709l_to_YUV709f_coeff,
+					CSC_ON);	/* limit->full range */
+			else
+				set_vpp_matrix(VPP_MATRIX_VD1,
+					bypass_coeff,
+					CSC_OFF);	/* full->full range */
+		} else {
+			if (signal_range == 0) /* limit range */
+				set_vpp_matrix(VPP_MATRIX_VD1,
+					bypass_coeff,
+					CSC_OFF);	/* limit->limit range */
+			else
+				set_vpp_matrix(VPP_MATRIX_VD1,
+					YUV709f_to_YUV709l_coeff,
+					CSC_ON);	/* full->limit range */
+		}
+
+		set_vpp_matrix(VPP_MATRIX_POST,
+			YUV709l_to_RGB709_coeff,
+			CSC_ON);
+
+		/* eotf lut bypass */
+		set_vpp_lut(VPP_LUT_EOTF,
+			eotf_33_sdr_709_mapping, /* R */
+			eotf_33_sdr_709_mapping, /* G */
+			eotf_33_sdr_709_mapping, /* B */
+			CSC_ON);
+
+		/* eotf matrix bypass */
+		set_vpp_matrix(VPP_MATRIX_EOTF,
+			eotf_RGB709_to_RGB2020_coeff,
+			CSC_ON);
+
+		/* oetf lut bypass */
+		set_vpp_lut(VPP_LUT_OETF,
+			oetf_sdr_2084_mapping,
+			oetf_sdr_2084_mapping,
+			oetf_sdr_2084_mapping,
+			CSC_ON);
+
+		/* xvycc matrix bypass */
+		set_vpp_matrix(VPP_MATRIX_XVYCC,
+			RGB2020_to_YUV2020l_coeff,
+			CSC_ON);
+	} else if ((get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) ||
+				(get_cpu_type() == MESON_CPU_MAJOR_ID_TXL)) {
+		bypass_hdr_process(csc_type, vinfo, master_info);
+	}
+}
+
 static int vpp_eye_protection_process(
 	enum vpp_matrix_csc_e csc_type,
 	struct vinfo_s *vinfo)
@@ -2754,6 +3699,9 @@ static int vpp_eye_protection_process(
 	if ((csc_type == VPP_MATRIX_BT2020YUV_BT2020RGB) &&
 			hdr_process_mode)
 		return 0;
+	if ((csc_type < VPP_MATRIX_BT2020YUV_BT2020RGB) &&
+			sdr_process_mode)
+		return 0;
 
 	/* post matrix bypass */
 	if ((vinfo->viu_color_fmt != TVIN_RGB444) &&
@@ -2782,16 +3730,13 @@ static int vpp_eye_protection_process(
 	return 0;
 }
 
-static void vpp_matrix_update(struct vframe_s *vf)
+static void vpp_matrix_update(struct vframe_s *vf, struct vinfo_s *vinfo)
 {
-	struct vinfo_s *vinfo;
 	enum vpp_matrix_csc_e csc_type = VPP_MATRIX_NULL;
 	int signal_change_flag = 0;
 	struct vframe_master_display_colour_s *p = &cur_master_display_colour;
 	struct master_display_info_s send_info;
-	int need_adjust_contrast = 0;
-
-	vinfo = get_current_vinfo();
+	int need_adjust_contrast_saturation = 0;
 
 	/* Tx hdr information */
 	memcpy(&receiver_hdr_info, &vinfo->hdr_info,
@@ -2806,6 +3751,20 @@ static void vpp_matrix_update(struct vframe_s *vf)
 	} else
 		hdr_process_mode = hdr_mode;
 
+	if (sdr_mode == 2) { /* auto */
+		if ((vinfo->hdr_info.hdr_support & 0x4) &&
+		((get_cpu_type() == MESON_CPU_MAJOR_ID_GXL) ||
+		 (get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)))
+			sdr_process_mode = 1; /*box sdr->hdr*/
+		else if ((vinfo->viu_color_fmt == TVIN_RGB444) &&
+			((get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) ||
+			(get_cpu_type() == MESON_CPU_MAJOR_ID_TXL)))
+			sdr_process_mode = 1; /*tv sdr->hdr*/
+		else
+			sdr_process_mode = 0; /* sdr->sdr*/
+	} else
+		sdr_process_mode = sdr_mode; /* force sdr->hdr */
+
 	signal_change_flag = signal_type_changed(vf, vinfo);
 
 	if ((!signal_change_flag) && (force_csc_type == 0xff))
@@ -2820,8 +3779,20 @@ static void vpp_matrix_update(struct vframe_s *vf)
 
 	if ((vinfo->viu_color_fmt != TVIN_RGB444) &&
 		(vinfo->hdr_info.hdr_support & 0x4)) {
-		/* bypass mode */
-		if ((hdr_process_mode == 0) &&
+		if (sdr_process_mode &&
+			(csc_type < VPP_MATRIX_BT2020YUV_BT2020RGB)) {
+			/* sdr source convert to hdr */
+			/* send hdr info */
+			/* use the features to discribe source info */
+			send_info.features =
+					  (1 << 29)	/* video available */
+					| (5 << 26)	/* unspecified */
+					| (0 << 25)	/* limit */
+					| (1 << 24)	/* color available */
+					| (9 << 16)	/* bt2020 */
+					| (14 << 8)	/* bt2020-10 */
+					| (10 << 0);	/* bt2020c */
+		} else if ((hdr_process_mode == 0) &&
 			(csc_type >= VPP_MATRIX_BT2020YUV_BT2020RGB)) {
 			/* source is hdr, send hdr info */
 			/* use the features to discribe source info */
@@ -2846,7 +3817,7 @@ static void vpp_matrix_update(struct vframe_s *vf)
 					| (1 << 8)	/* bt709 */
 					| (1 << 0);	/* bt709 */
 		}
-		amvecm_cp_hdr_info(&send_info, vf);
+		amvecm_cp_hdr_info(&send_info, p);
 		if (vinfo->fresh_tx_hdr_pkt)
 			vinfo->fresh_tx_hdr_pkt(&send_info);
 	}
@@ -2860,35 +3831,57 @@ static void vpp_matrix_update(struct vframe_s *vf)
 			/* hdr->sdr */
 			if ((signal_change_flag &
 					(SIG_PRI_INFO |
-						SIG_KNEE_FACTOR |
+					SIG_KNEE_FACTOR |
 					SIG_HDR_MODE)
 				) ||
 				(cur_csc_type <
 					VPP_MATRIX_BT2020YUV_BT2020RGB)) {
-				need_adjust_contrast =
+				need_adjust_contrast_saturation =
 					hdr_process(csc_type, vinfo, p);
 			}
 		} else {
-			/* for gxtvbb and gxl HDR bypass process */
-			bypass_hdr_process(csc_type, vinfo);
+			if ((csc_type < VPP_MATRIX_BT2020YUV_BT2020RGB) &&
+				sdr_process_mode)
+				/* for gxl and gxm SDR to HDR process */
+				sdr_hdr_process(csc_type, vinfo, p);
+			else
+				/* for gxtvbb and gxl HDR bypass process */
+				bypass_hdr_process(csc_type, vinfo, p);
 
 			if ((csc_type == VPP_MATRIX_BT2020YUV_BT2020RGB) &&
 				(get_cpu_type() <= MESON_CPU_MAJOR_ID_GXTVBB))
 				csc_type = VPP_MATRIX_YUV709_RGB;
 		}
-		if (need_adjust_contrast) {
-			vd1_contrast_offset =
+		if (need_adjust_contrast_saturation & 1) {
+			if (lut_289_en &&
+				(get_cpu_type() <= MESON_CPU_MAJOR_ID_GXTVBB))
+				vd1_contrast_offset = 0;
+			else
+				vd1_contrast_offset =
 				calculate_contrast_adj(p->luminance[0] / 10000);
 			vecm_latch_flag |= FLAG_VADJ1_CON;
-		} else{
+		} else {
 			vd1_contrast_offset = 0;
 			vecm_latch_flag |= FLAG_VADJ1_CON;
 		}
+		if (need_adjust_contrast_saturation & 2) {
+			vecm_latch_flag |= FLAG_VADJ1_COLOR;
+		} else {
+			if (((get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) ||
+				(get_cpu_type() == MESON_CPU_MAJOR_ID_TXL)) &&
+				(sdr_process_mode == 1))
+				saturation_offset = sdr_saturation_offset;
+			else
+				saturation_offset =	0;
+			vecm_latch_flag |= FLAG_VADJ1_COLOR;
+		}
 		if (cur_csc_type != csc_type) {
 			pr_csc("CSC from 0x%x to 0x%x.\n",
 				cur_csc_type, csc_type);
 			pr_csc("contrast offset = %d.\n",
 				vd1_contrast_offset);
+			pr_csc("saturation offset = %d.\n",
+				saturation_offset);
 			cur_csc_type = csc_type;
 		}
 	}
@@ -2910,6 +3903,7 @@ MODULE_PARM_DESC(null_vf_max, "\n null_vf_max\n");
 void amvecm_matrix_process(struct vframe_s *vf)
 {
 	struct vframe_s fake_vframe;
+	struct vinfo_s *vinfo = get_current_vinfo();
 	int i;
 
 	if ((get_cpu_type() < MESON_CPU_MAJOR_ID_GXTVBB) ||
@@ -2933,12 +3927,24 @@ void amvecm_matrix_process(struct vframe_s *vf)
 					CSC_ON);
 	}
 
-	if ((vf == last_vf) &&
+	/* OSD sdr -> hdr in first vsync when hdr output */
+	if ((vinfo->hdr_info.hdr_support & 0x4) && (vf == NULL) &&
+		((get_cpu_type() == MESON_CPU_MAJOR_ID_GXL) ||
+		 (get_cpu_type() == MESON_CPU_MAJOR_ID_GXM))) {
+		if (((sdr_process_mode != 1) && (sdr_mode > 0))
+		|| ((sdr_process_mode > 0) && (sdr_mode == 0)))
+			null_vf_cnt = null_vf_max + 1;
+	}
+
+	if ((vf == last_vf) && (null_vf_cnt <= null_vf_max) &&
 		(cur_eye_protect_mode == wb_val[0]))
 		return;
 
+	if (is_dolby_vision_on())
+		return;
+
 	if (vf != NULL) {
-		vpp_matrix_update(vf);
+		vpp_matrix_update(vf, vinfo);
 		last_vf = vf;
 		null_vf_cnt = 0;
 		fg_vf_sw_dbg = 1;
@@ -2948,7 +3954,8 @@ void amvecm_matrix_process(struct vframe_s *vf)
 	} else {
 		/* check last signal type */
 		if ((last_vf != NULL) &&
-			((last_vf->signal_type >> 16) & 0xff) == 9)
+			((((last_vf->signal_type >> 16) & 0xff) == 9)
+			|| customer_master_display_en))
 			null_vf_cnt++;
 
 		if ((((READ_VPP_REG(VPP_MISC) & (1<<10)) == 0)
@@ -2960,8 +3967,10 @@ void amvecm_matrix_process(struct vframe_s *vf)
 			fake_vframe.signal_type = 0;
 			fake_vframe.width = 720;
 			fake_vframe.height = 480;
-			fake_vframe.prop.master_display_colour.present_flag = 0;
-			vpp_matrix_update(&fake_vframe);
+			fake_vframe.prop.master_display_colour.present_flag
+				= 0x80000000;
+			vpp_matrix_update(&fake_vframe, vinfo);
+			pr_csc("change CSC when disable video.\n");
 			last_vf = vf;
 			null_vf_cnt = 0;
 			fg_vf_sw_dbg = 2;
@@ -2981,6 +3990,7 @@ int amvecm_hdr_dbg(u32 sel)
 	if (dbg_vf == NULL)
 		goto hdr_dump;
 
+	/*
 	pr_err("----vframe info----\n");
 	pr_err("index:%d, type:0x%x, type_backup:0x%x, blend_mode:%d\n",
 		dbg_vf->index, dbg_vf->type,
@@ -3000,7 +4010,6 @@ int amvecm_hdr_dbg(u32 sel)
 	pr_err("source_type:%d, phase:%d, soruce_mode:%d, sig_fmt:0x%x\n",
 		dbg_vf->source_type, dbg_vf->phase,
 		dbg_vf->source_mode, dbg_vf->sig_fmt);
-	/*
 	pr_err(
 		"trans_fmt 0x%x, lefteye(%d %d %d %d), righteye(%d %d %d %d)\n",
 		vf->trans_fmt, vf->left_eye.start_x, vf->left_eye.start_y,
@@ -3038,41 +4047,64 @@ int amvecm_hdr_dbg(u32 sel)
 	 vs_cycle %d, vs_stamp %d\n",
 		vf->prop.meas.hs_cnt2, vf->prop.meas.hs_cnt3,
 		vf->prop.meas.vs_cycle, vf->prop.meas.vs_stamp);
-	*/
+
 	pr_err("pixel_ratio:%d list:%p ready_jiffies64:%lld, frame_dirty %d\n",
 		dbg_vf->pixel_ratio, &dbg_vf->list,
 		dbg_vf->ready_jiffies64, dbg_vf->frame_dirty);
+	*/
 
-	pr_err("----Source HDR info----\n");
-	pr_err("\tsignal_type:0x%x, present_flag:%d\n",
+	pr_err("----Video frame info----\n");
+	pr_err("bitdepth:0x%x, signal_type:0x%x, present_flag:0x%x\n",
+		dbg_vf->bitdepth,
 		dbg_vf->signal_type,
 		dbg_vf->prop.master_display_colour.present_flag);
-	for (i = 0; i < 3; i++)
-		for (j = 0; j < 2; j++)
-			pr_err(
-				"\tprimaries[%1d][%1d] = %04x\n",
-			i, j,
+
+	if (((dbg_vf->signal_type >> 16) & 0xff) == 9) {
+		pr_err("HDR color primaries:0x%x\n",
+			((dbg_vf->signal_type >> 16) & 0xff));
+		pr_err("HDR transfer_characteristic:0x%x\n",
+			((dbg_vf->signal_type >> 8) & 0xff));
+	} else
+		pr_err("SDR color primaries:0x%x\n", signal_color_primaries);
+
+	if (dbg_vf->prop.master_display_colour.present_flag == 1) {
+		pr_err("----SEI info----\n");
+		for (i = 0; i < 3; i++)
+			for (j = 0; j < 2; j++)
+				pr_err(
+					"\tprimaries[%1d][%1d] = %04x\n",
+				i, j,
 			dbg_vf->prop.master_display_colour.primaries[i][j]);
-	pr_err("\twhite_point = (%04x, %04x)\n",
-		dbg_vf->prop.master_display_colour.white_point[0],
-		dbg_vf->prop.master_display_colour.white_point[1]);
-	pr_err("\tmax,min luminance = %08x, %08x\n",
-		dbg_vf->prop.master_display_colour.luminance[0],
-		dbg_vf->prop.master_display_colour.luminance[1]);
+		pr_err("\twhite_point = (%04x, %04x)\n",
+			dbg_vf->prop.master_display_colour.white_point[0],
+			dbg_vf->prop.master_display_colour.white_point[1]);
+		pr_err("\tmax,min luminance = %08x, %08x\n",
+			dbg_vf->prop.master_display_colour.luminance[0],
+			dbg_vf->prop.master_display_colour.luminance[1]);
+	}
+
 hdr_dump:
 	pr_err("----HDR process info----\n");
+	pr_err("customer_master_display_en:0x%x\n", customer_master_display_en);
+
+	pr_err("hdr_mode:0x%x, hdr_process_mode:0x%x, cur_hdr_process_mode:0x%x\n",
+		hdr_mode, hdr_process_mode, cur_hdr_process_mode);
+
+	pr_err("sdr_mode:0x%x, sdr_process_mode:0x%x, cur_sdr_process_mode:0x%x\n",
+		sdr_mode, sdr_process_mode, cur_sdr_process_mode);
 
-	pr_err("hdr_mode:0x%x, hdr_process_mode:0x%x, force_csc_type:0x%x\n",
-		hdr_mode, hdr_process_mode, force_csc_type);
+	pr_err("hdr_flag:0x%x,     fg_vf_sw_dbg:0x%x\n",
+		hdr_flag, fg_vf_sw_dbg);
 	pr_err("cur_signal_type:0x%x, cur_csc_mode:0x%x, cur_csc_type:0x%x\n",
 		cur_signal_type, cur_csc_mode, cur_csc_type);
 
 	pr_err("knee_lut_on:0x%x,knee_interpolation_mode:0x%x,cur_knee_factor:0x%x\n",
 		knee_lut_on, knee_interpolation_mode, cur_knee_factor);
-	pr_err("fg_vf_sw_dbg: 0x%x\n", fg_vf_sw_dbg);
 
+	if ((receiver_hdr_info.hdr_support & 0x4) == 0)
+		goto dbg_end;
 	pr_err("----TV EDID info----\n");
-	pr_err("hdr_support:0x%x,lumi_max:%d,lumi_avg:%d,lumi_min:%d\n",
+	pr_err("hdr_support:0x%x, lumi_max:%d, lumi_avg:%d, lumi_min:%d\n",
 		receiver_hdr_info.hdr_support,
 		receiver_hdr_info.lumi_max,
 		receiver_hdr_info.lumi_avg,
@@ -3181,25 +4213,32 @@ int amvecm_hdr_dbg(u32 sel)
 		data_port = VIU_OSD1_OETF_LUT_DATA_PORT;
 		ctrl_port = VIU_OSD1_OETF_CTL;
 
-		WRITE_VPP_REG(addr_port, 0);
+		pr_err("\taddr = %08x, val = %08x\n",
+			ctrl_port, READ_VPP_REG(ctrl_port));
+
 		for (i = 0; i < 20; i++) {
+			WRITE_VPP_REG(addr_port, i);
 			data = READ_VPP_REG(data_port);
 			r_map[i * 2] = data & 0xffff;
 			r_map[i * 2 + 1] = (data >> 16) & 0xffff;
 		}
+		WRITE_VPP_REG(addr_port, 20);
 		data = READ_VPP_REG(data_port);
 		r_map[OSD_OETF_LUT_SIZE - 1] = data & 0xffff;
 		g_map[0] = (data >> 16) & 0xffff;
 		for (i = 0; i < 20; i++) {
+			WRITE_VPP_REG(addr_port, 21 + i);
 			data = READ_VPP_REG(data_port);
 			g_map[i * 2 + 1] = data & 0xffff;
 			g_map[i * 2 + 2] = (data >> 16) & 0xffff;
 		}
 		for (i = 0; i < 20; i++) {
+			WRITE_VPP_REG(addr_port, 41 + i);
 			data = READ_VPP_REG(data_port);
 			b_map[i * 2] = data & 0xffff;
 			b_map[i * 2 + 1] = (data >> 16) & 0xffff;
 		}
+		WRITE_VPP_REG(addr_port, 61);
 		data = READ_VPP_REG(data_port);
 		b_map[OSD_OETF_LUT_SIZE - 1] = data & 0xffff;
 
@@ -3239,7 +4278,7 @@ int amvecm_hdr_dbg(u32 sel)
 				i, r_map[i], g_map[i], b_map[i]);
 		}
 
-		pr_err("----dump hdr_osd_reg----\n");
+		pr_err("----dump hdr_osd_reg structure ----\n");
 
 		pr_err("\tviu_osd1_matrix_ctrl = 0x%04x\n",
 				hdr_osd_reg.viu_osd1_matrix_ctrl);
@@ -3298,6 +4337,10 @@ int amvecm_hdr_dbg(u32 sel)
 		}
 		pr_err("\n");
 	}
+	pr_err("----dump regs VPP_LUT_EOTF----\n");
+	print_vpp_lut(VPP_LUT_EOTF, READ_VPP_REG(VIU_EOTF_CTL) & (7 << 27));
+	pr_err("----dump regs VPP_LUT_OETF----\n");
+	print_vpp_lut(VPP_LUT_OETF, READ_VPP_REG(XVYCC_LUT_CTL) & 0x7f);
 	/*********************dump reg end*********************/
 dbg_end:
 
diff --git a/drivers/amlogic/amvecm/amcsc.h b/drivers/amlogic/amvecm/amcsc.h
index 482a855..b456dd6 100644
--- a/drivers/amlogic/amvecm/amcsc.h
+++ b/drivers/amlogic/amvecm/amcsc.h
@@ -83,9 +83,10 @@ enum vpp_lut_sel_e {
 	VPP_LUT_OSD_EOTF = 0,
 	VPP_LUT_OSD_OETF,
 	VPP_LUT_EOTF,
-	VPP_LUT_OETF
+	VPP_LUT_OETF,
+	VPP_LUT_INV_EOTF
 };
-#define NUM_LUT 4
+#define NUM_LUT 5
 
 /* matrix registers */
 struct matrix_s {
@@ -95,16 +96,24 @@ struct matrix_s {
 	u16 right_shift;
 };
 
+#define LUT_289_SIZE	289
+extern unsigned int lut_289_mapping[LUT_289_SIZE];
+extern int dnlp_en;
+/*extern int cm_en;*/
+
 extern unsigned int vecm_latch_flag;
 extern signed int vd1_contrast_offset;
+extern signed int saturation_offset;
+extern uint sdr_mode;
+extern uint hdr_flag;
 
 extern void amvecm_matrix_process(struct vframe_s *vf);
 extern int amvecm_hdr_dbg(u32 sel);
-
-/* use osd rdma w/r */
-u32 VSYNCOSD_RD_MPEG_REG(u32 reg);
-int VSYNCOSD_WR_MPEG_REG(u32 reg, u32 val);
-int VSYNCOSD_WR_MPEG_REG_BITS(u32 reg, u32 val, u32 start, u32 len);
+#ifdef CONFIG_VSYNC_RDMA
+extern int VSYNC_WR_MPEG_REG(u32 adr, u32 val);
+extern u32 VSYNC_RD_MPEG_REG(u32 adr);
+extern int VSYNC_WR_MPEG_REG_BITS(u32 adr, u32 val, u32 start, u32 len);
+#endif
 
 #endif /* AM_CSC_H */
 
diff --git a/drivers/amlogic/amvecm/amdolby_vision.c b/drivers/amlogic/amvecm/amdolby_vision.c
new file mode 100644
index 0000000..c21ba8e
--- /dev/null
+++ b/drivers/amlogic/amvecm/amdolby_vision.c
@@ -0,0 +1,1226 @@
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/video.h>
+#include <linux/amlogic/amvecm/amvecm.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/amlogic/amports/amstream.h>
+#include "arch/vpp_regs.h"
+#include "arch/vpp_hdr_regs.h"
+#include "arch/vpp_dolbyvision_regs.h"
+#include "dolby_vision/dolby_vision.h"
+
+static const struct dolby_vision_func_s *p_funcs;
+
+#define DOLBY_VISION_OUTPUT_MODE_IPT			0
+#define DOLBY_VISION_OUTPUT_MODE_IPT_TUNNEL		1
+#define DOLBY_VISION_OUTPUT_MODE_HDR10			2
+#define DOLBY_VISION_OUTPUT_MODE_SDR10			3
+#define DOLBY_VISION_OUTPUT_MODE_SDR8			4
+#define DOLBY_VISION_OUTPUT_MODE_BYPASS			5
+static unsigned int dolby_vision_mode = DOLBY_VISION_OUTPUT_MODE_SDR10;
+module_param(dolby_vision_mode, uint, 0664);
+MODULE_PARM_DESC(dolby_vision_mode, "\n dolby_vision_mode\n");
+
+/* if sink support DV, always output DV */
+/* else if sink support HDR10, always output HDR10 */
+/* else always output SDR */
+#define DOLBY_VISION_FOLLOW_SINK		0
+/* output DV ooly if source is DV and sink support DV */
+/* else if sink support HDR10, always output HDR10 */
+/* else always output SDR */
+#define DOLBY_VISION_FOLLOW_SOURCE		1
+/* always follow dolby_vision_mode */
+#define DOLBY_VISION_FORCE_OUTPUT_MODE	2
+static unsigned int dolby_vision_policy = DOLBY_VISION_FOLLOW_SINK;
+module_param(dolby_vision_policy, uint, 0664);
+MODULE_PARM_DESC(dolby_vision_policy, "\n dolby_vision_policy\n");
+
+static bool dolby_vision_enable;
+module_param(dolby_vision_enable, bool, 0664);
+MODULE_PARM_DESC(dolby_vision_enable, "\n dolby_vision_enable\n");
+
+#define BYPASS_PROCESS 0
+#define SDR_PROCESS 1
+#define HDR_PROCESS 2
+#define DV_PROCESS 3
+static uint dolby_vision_status;
+module_param(dolby_vision_status, uint, 0664);
+MODULE_PARM_DESC(dolby_vision_status, "\n dolby_vision_status\n");
+
+#define FLAG_RESET_EACH_FRAME		0x01
+#define FLAG_CLKGATE_WHEN_LOAD_LUT	0x02
+#define FLAG_BYPASS_CSC				0x04
+#define FLAG_BYPASS_CVM				0x08
+#define FLAG_USE_SINK_MIN_MAX		0x10
+#define FLAG_DISABLE_COMPOSER		0x20
+#define FLAG_TOGGLE_FRAME			0x80000000
+static unsigned int dolby_vision_flags =
+	FLAG_RESET_EACH_FRAME | FLAG_BYPASS_CVM | FLAG_USE_SINK_MIN_MAX;
+module_param(dolby_vision_flags, uint, 0664);
+MODULE_PARM_DESC(dolby_vision_flags, "\n dolby_vision_flags\n");
+
+static unsigned int htotal_add = 0x140;
+static unsigned int vtotal_add = 0x40;
+static unsigned int vsize_add;
+static unsigned int vwidth = 0x8;
+static unsigned int hwidth = 0x8;
+static unsigned int vpotch = 0x10;
+static unsigned int hpotch = 0x8;
+static unsigned int g_htotal_add = 0x40;
+static unsigned int g_vtotal_add = 0x80;
+static unsigned int g_vsize_add;
+static unsigned int g_vwidth = 0x18;
+static unsigned int g_hwidth = 0x10;
+static unsigned int g_vpotch = 0x8;
+static unsigned int g_hpotch = 0x10;
+
+static unsigned int dolby_vision_target_min = 50; /* 0.0001 */
+static unsigned int dolby_vision_target_max = 1000;
+module_param(dolby_vision_target_min, uint, 0664);
+MODULE_PARM_DESC(dolby_vision_target_min, "\n dolby_vision_target_min\n");
+module_param(dolby_vision_target_max, uint, 0664);
+MODULE_PARM_DESC(dolby_vision_target_max, "\n dolby_vision_target_max\n");
+
+static unsigned int dolby_vision_graphic_min = 50; /* 0.0001 */
+static unsigned int dolby_vision_graphic_max = 300;
+module_param(dolby_vision_graphic_min, uint, 0664);
+MODULE_PARM_DESC(dolby_vision_graphic_min, "\n dolby_vision_graphic_min\n");
+
+static unsigned int debug_dolby;
+module_param(debug_dolby, uint, 0664);
+MODULE_PARM_DESC(debug_dolby, "\n debug_dolby\n");
+
+static unsigned int debug_dolby_frame;
+module_param(debug_dolby_frame, uint, 0664);
+MODULE_PARM_DESC(debug_dolby_frame, "\n debug_dolby_frame\n");
+
+#define pr_dolby_dbg(fmt, args...)\
+	do {\
+		if (debug_dolby)\
+			pr_info("DOLBY: " fmt, ## args);\
+	} while (0)
+#define pr_dolby_error(fmt, args...)\
+	pr_info("DOLBY ERROR: " fmt, ## args)
+#define dump_enable \
+	((debug_dolby_frame >= 0xffff) || (debug_dolby_frame == frame_count))
+
+static bool dolby_vision_on;
+static unsigned int frame_count;
+static struct hdr10_param_s hdr10_param;
+static struct dovi_setting_s dovi_setting;
+
+int dolby_core1_set(
+	uint32_t dm_count,
+	uint32_t comp_count,
+	uint32_t lut_count,
+	uint32_t *p_core1_dm_regs,
+	uint32_t *p_core1_comp_regs,
+	uint32_t *p_core1_lut,
+	int hsize,
+	int vsize,
+	int bl_enable,
+	int el_enable,
+	int el_41_mode,
+	int scramble_en,
+	int lut_endian)
+{
+	uint32_t count;
+	uint32_t bypass_flag = 0;
+	int composer_enable = el_enable;
+	int i;
+
+	if (dolby_vision_flags & FLAG_DISABLE_COMPOSER)
+		composer_enable = 0;
+
+	if ((!dolby_vision_on)
+	|| (dolby_vision_flags & FLAG_RESET_EACH_FRAME)) {
+		VSYNC_WR_MPEG_REG(VIU_SW_RESET, (1 << 10)|(1 << 9));
+		VSYNC_WR_MPEG_REG(VIU_SW_RESET, 0);
+	}
+
+	VSYNC_WR_MPEG_REG(DOLBY_CORE1_SWAP_CTRL0, 0);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE1_SWAP_CTRL1,
+		((hsize + 0x40) << 16) | (vsize + 0x20));
+	VSYNC_WR_MPEG_REG(DOLBY_CORE1_SWAP_CTRL3, (hwidth << 16) | vwidth);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE1_SWAP_CTRL4, (hpotch << 16) | vpotch);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE1_SWAP_CTRL2, (hsize << 16) | vsize);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE1_SWAP_CTRL5, 0xa);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE1_DMA_CTRL, 0x0);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE1_REG_START + 4, 4);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE1_REG_START + 2, 1);
+
+	if (scramble_en) {
+		if (dolby_vision_flags & FLAG_BYPASS_CSC)
+			bypass_flag |= 1 << 1;
+		if (dolby_vision_flags & FLAG_BYPASS_CVM)
+			bypass_flag |= 1 << 2;
+	}
+	VSYNC_WR_MPEG_REG(DOLBY_CORE1_REG_START + 1,
+		0x78 | bypass_flag); /* bypass CVM and/or CSC */
+	VSYNC_WR_MPEG_REG(DOLBY_CORE1_REG_START + 1,
+		0x78 | bypass_flag); /* for delay */
+	if ((dolby_vision_flags & FLAG_RESET_EACH_FRAME) && (dm_count == 0))
+		count = 24;
+	else
+		count = dm_count;
+	for (i = 0; i < count; i++)
+		VSYNC_WR_MPEG_REG(DOLBY_CORE1_REG_START + 6 + i,
+			p_core1_dm_regs[i]);
+
+	if ((dolby_vision_flags & FLAG_RESET_EACH_FRAME) && (comp_count == 0))
+		count = 173;
+	else
+		count = comp_count;
+	for (i = 0; i < count; i++)
+		VSYNC_WR_MPEG_REG(DOLBY_CORE1_REG_START + 6 + 44 + i,
+			p_core1_comp_regs[i]);
+
+	/* metadata program done */
+	VSYNC_WR_MPEG_REG(DOLBY_CORE1_REG_START + 3, 1);
+
+	if ((dolby_vision_flags & FLAG_RESET_EACH_FRAME) && (lut_count == 0))
+		count = 256 * 5;
+	else
+		count = lut_count;
+	if (count) {
+		if (dolby_vision_flags & FLAG_CLKGATE_WHEN_LOAD_LUT)
+			VSYNC_WR_MPEG_REG_BITS(DOLBY_CORE1_CLKGATE_CTRL,
+				2, 2, 2);
+		VSYNC_WR_MPEG_REG(DOLBY_CORE1_DMA_CTRL, 0x1401);
+		if (lut_endian)
+			for (i = 0; i < count; i += 4) {
+				VSYNC_WR_MPEG_REG(DOLBY_CORE1_DMA_PORT,
+					p_core1_lut[i+3]);
+				VSYNC_WR_MPEG_REG(DOLBY_CORE1_DMA_PORT,
+					p_core1_lut[i+2]);
+				VSYNC_WR_MPEG_REG(DOLBY_CORE1_DMA_PORT,
+					p_core1_lut[i+1]);
+				VSYNC_WR_MPEG_REG(DOLBY_CORE1_DMA_PORT,
+					p_core1_lut[i]);
+			}
+		else
+			for (i = 0; i < count; i++)
+				VSYNC_WR_MPEG_REG(DOLBY_CORE1_DMA_PORT,
+					p_core1_lut[i]);
+		if (dolby_vision_flags & FLAG_CLKGATE_WHEN_LOAD_LUT)
+			VSYNC_WR_MPEG_REG_BITS(DOLBY_CORE1_CLKGATE_CTRL,
+				0, 2, 2);
+	}
+
+	/* enable core1 */
+	VSYNC_WR_MPEG_REG(DOLBY_CORE1_SWAP_CTRL0,
+		bl_enable << 0 |
+		composer_enable << 1 |
+		el_41_mode << 2);
+	return 0;
+}
+
+int dolby_core2_set(
+	uint32_t dm_count,
+	uint32_t lut_count,
+	uint32_t *p_core2_dm_regs,
+	uint32_t *p_core2_lut,
+	int hsize,
+	int vsize,
+	int dolby_enable,
+	int lut_endian)
+{
+	uint32_t count;
+	int i;
+
+	VSYNC_WR_MPEG_REG(DOLBY_CORE2A_SWAP_CTRL0, 0);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE2A_SWAP_CTRL1,
+		((hsize + g_htotal_add) << 16)
+		| (vsize + g_vtotal_add + g_vsize_add));
+	VSYNC_WR_MPEG_REG(DOLBY_CORE2A_SWAP_CTRL3,
+		(g_hwidth << 16) | g_vwidth);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE2A_SWAP_CTRL4,
+		(g_hpotch << 16) | g_vpotch);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE2A_SWAP_CTRL2,
+		(hsize << 16) | (vsize + g_vsize_add));
+	VSYNC_WR_MPEG_REG(DOLBY_CORE2A_SWAP_CTRL5, 0x0);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE2A_DMA_CTRL, 0x0);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE2A_REG_START + 2, 1);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE2A_REG_START + 1, 2);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE2A_REG_START + 1, 2);
+
+	if ((dolby_vision_flags & FLAG_RESET_EACH_FRAME)
+	&& (dm_count == 0))
+		count = 24;
+	else
+		count = dm_count;
+	for (i = 0; i < count; i++)
+		VSYNC_WR_MPEG_REG(DOLBY_CORE2A_REG_START + 6 + i,
+			p_core2_dm_regs[i]);
+	/* core2 metadata program done */
+	VSYNC_WR_MPEG_REG(DOLBY_CORE2A_REG_START + 3, 1);
+
+	if (dolby_vision_flags & FLAG_RESET_EACH_FRAME)
+		count = 256 * 5;
+	else
+		count = lut_count;
+	if (count) {
+		if (dolby_vision_flags & FLAG_CLKGATE_WHEN_LOAD_LUT)
+			VSYNC_WR_MPEG_REG_BITS(DOLBY_CORE2A_CLKGATE_CTRL,
+				2, 2, 2);
+		VSYNC_WR_MPEG_REG(DOLBY_CORE2A_DMA_CTRL, 0x1401);
+		if (lut_endian)
+			for (i = 0; i < count; i += 4) {
+				VSYNC_WR_MPEG_REG(DOLBY_CORE2A_DMA_PORT,
+					p_core2_lut[i+3]);
+				VSYNC_WR_MPEG_REG(DOLBY_CORE2A_DMA_PORT,
+					p_core2_lut[i+2]);
+				VSYNC_WR_MPEG_REG(DOLBY_CORE2A_DMA_PORT,
+					p_core2_lut[i+1]);
+				VSYNC_WR_MPEG_REG(DOLBY_CORE2A_DMA_PORT,
+					p_core2_lut[i]);
+			}
+		else
+			for (i = 0; i < count; i++)
+				VSYNC_WR_MPEG_REG(DOLBY_CORE2A_DMA_PORT,
+					p_core2_lut[i]);
+		/* core1 lookup table program done */
+		if (dolby_vision_flags & FLAG_CLKGATE_WHEN_LOAD_LUT)
+			VSYNC_WR_MPEG_REG_BITS(
+				DOLBY_CORE2A_CLKGATE_CTRL, 0, 2, 2);
+	}
+
+	/* enable core2 */
+	VSYNC_WR_MPEG_REG(DOLBY_CORE2A_SWAP_CTRL0, dolby_enable << 0);
+	return 0;
+}
+
+int dolby_core3_set(
+	uint32_t dm_count,
+	uint32_t md_count,
+	uint32_t *p_core3_dm_regs,
+	uint32_t *p_core3_md_regs,
+	int hsize,
+	int vsize,
+	int dolby_enable,
+	int scramble_en)
+{
+	uint32_t count;
+	int i;
+
+	VSYNC_WR_MPEG_REG(DOLBY_CORE3_SWAP_CTRL1,
+		((hsize + htotal_add) << 16)
+		| (vsize + vtotal_add + vsize_add));
+	VSYNC_WR_MPEG_REG(DOLBY_CORE3_SWAP_CTRL3, 0x800020);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE3_SWAP_CTRL4, 0x40008);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE3_SWAP_CTRL2,
+		(hsize << 16) | (vsize + vsize_add));
+	VSYNC_WR_MPEG_REG(DOLBY_CORE3_SWAP_CTRL5, 0x0000);
+	if (dolby_vision_mode !=
+		DOLBY_VISION_OUTPUT_MODE_IPT_TUNNEL)
+		VSYNC_WR_MPEG_REG(DOLBY_CORE3_SWAP_CTRL6, 0);
+	else
+		VSYNC_WR_MPEG_REG(DOLBY_CORE3_SWAP_CTRL6,
+			0x10000000);  /* swap UV */
+	VSYNC_WR_MPEG_REG(DOLBY_CORE3_REG_START + 5, 7);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE3_REG_START + 4, 4);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE3_REG_START + 4, 2);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE3_REG_START + 2, 1);
+	/* Control Register, address 0x04 2:0 RW */
+	/* Output_operating mode
+	   00- IPT 12 bit 444 bypass Dolby Vision output
+	   01- IPT 12 bit tunnelled over RGB 8 bit 444, dolby vision output
+	   02- HDR10 output, RGB 10 bit 444 PQ
+	   03- Deep color SDR, RGB 10 bit 444 Gamma
+	   04- SDR, RGB 8 bit 444 Gamma
+	*/
+	VSYNC_WR_MPEG_REG(DOLBY_CORE3_REG_START + 1, dolby_vision_mode);
+	VSYNC_WR_MPEG_REG(DOLBY_CORE3_REG_START + 1, dolby_vision_mode);
+	/* for delay */
+
+	if ((dolby_vision_flags & FLAG_RESET_EACH_FRAME)
+	&& (dm_count == 0))
+		count = 26;
+	else
+		count = dm_count;
+	for (i = 0; i < count; i++)
+		VSYNC_WR_MPEG_REG(DOLBY_CORE3_REG_START + 0x6 + i,
+			p_core3_dm_regs[i]);
+	/* from addr 0x18 */
+
+	count = md_count;
+	for (i = 0; i < count; i++)
+		VSYNC_WR_MPEG_REG(DOLBY_CORE3_REG_START + 0x24 + i,
+			p_core3_md_regs[i]);
+	/* from addr 0x90 */
+
+	/* core3 metadata program done */
+	VSYNC_WR_MPEG_REG(DOLBY_CORE3_REG_START + 3, 1);
+
+	/* enable core3 */
+	VSYNC_WR_MPEG_REG(DOLBY_CORE3_SWAP_CTRL0, (dolby_enable << 0));
+	return 0;
+}
+
+static uint32_t dolby_ctrl_backup;
+static uint32_t viu_misc_ctrl_backup;
+static uint32_t vpu_hdmi_fmt_backup;
+static uint32_t viu_eotf_ctrl_backup;
+static uint32_t xvycc_lut_ctrl_backup;
+static uint32_t vpp_matrix_backup;
+static uint32_t vpp_vadj_backup;
+static uint32_t vpp_dummy1_backup;
+void enable_dolby_vision(int enable)
+{
+	if (enable) {
+		if (!dolby_vision_on) {
+			dolby_ctrl_backup = READ_VPP_REG(VPP_DOLBY_CTRL);
+			viu_misc_ctrl_backup = READ_VPP_REG(VIU_MISC_CTRL1);
+			vpu_hdmi_fmt_backup = READ_VPP_REG(VPU_HDMI_FMT_CTRL);
+			viu_eotf_ctrl_backup = READ_VPP_REG(VIU_EOTF_CTL);
+			xvycc_lut_ctrl_backup = READ_VPP_REG(XVYCC_LUT_CTL);
+			vpp_matrix_backup = READ_VPP_REG(VPP_MATRIX_CTRL);
+			vpp_vadj_backup = READ_VPP_REG(VPP_VADJ_CTRL);
+			vpp_dummy1_backup = READ_VPP_REG(VPP_DUMMY_DATA1);
+			VSYNC_WR_MPEG_REG(VPP_DOLBY_CTRL,
+					(0x0<<21)  /* cm_datx4_mode */
+				       |(0x0<<20)  /* reg_front_cti_bit_mode */
+				       |(0x0<<17)  /* vpp_clip_ext_mode 19:17 */
+				       |(0x1<<16)  /* vpp_dolby2_en */
+				       |(0x0<<15)  /* mat_xvy_dat_mode */
+				       |(0x1<<14)  /* vpp_ve_din_mode */
+				       |(0x1<<12)  /* mat_vd2_dat_mode 13:12 */
+				       |(0x3<<8)   /* vpp_dpath_sel 10:8 */
+				       |0x1f);   /* vpp_uns2s_mode 7:0 */
+			VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL1,
+				  (0 << 4)	/* 23-20 ext mode */
+				| (0 << 3)	/* 19 osd bypass */
+				| (0 << 2)	/* 18 core2 bypass */
+				| (0 << 1)	/* 17 core1 el bypass */
+				| (0 << 0), /* 16 core1 bl bypass */
+				16, 8);
+			VSYNC_WR_MPEG_REG(VPU_HDMI_FMT_CTRL, 0);
+			VSYNC_WR_MPEG_REG(VIU_EOTF_CTL, 0);
+			VSYNC_WR_MPEG_REG(XVYCC_LUT_CTL, 0);
+			VSYNC_WR_MPEG_REG(VPP_MATRIX_CTRL, 0);
+			VSYNC_WR_MPEG_REG(VPP_VADJ_CTRL, 0);
+			VSYNC_WR_MPEG_REG(VPP_DUMMY_DATA1, 0x20000000);
+			VSYNC_WR_MPEG_REG_BITS(VIU_OSD1_MATRIX_CTRL, 0, 0, 1);
+			dolby_vision_on = 1;
+			pr_dolby_dbg("Dolby Vision turn on\n");
+		}
+	} else {
+		if (dolby_vision_on) {
+			VSYNC_WR_MPEG_REG(VPP_DOLBY_CTRL,  dolby_ctrl_backup);
+			VSYNC_WR_MPEG_REG(VIU_MISC_CTRL1, viu_misc_ctrl_backup);
+			VSYNC_WR_MPEG_REG(VPU_HDMI_FMT_CTRL,
+				vpu_hdmi_fmt_backup);
+			VSYNC_WR_MPEG_REG(VIU_EOTF_CTL, viu_eotf_ctrl_backup);
+			VSYNC_WR_MPEG_REG(XVYCC_LUT_CTL, xvycc_lut_ctrl_backup);
+			VSYNC_WR_MPEG_REG(VPP_MATRIX_CTRL, vpp_matrix_backup);
+			VSYNC_WR_MPEG_REG(VPP_VADJ_CTRL, vpp_vadj_backup);
+			VSYNC_WR_MPEG_REG(VPP_DUMMY_DATA1, vpp_dummy1_backup);
+			VSYNC_WR_MPEG_REG_BITS(VIU_OSD1_MATRIX_CTRL, 1, 0, 1);
+			dolby_vision_on = 0;
+			dolby_vision_status = BYPASS_PROCESS;
+			pr_dolby_dbg("Dolby Vision turn off\n");
+		}
+	}
+}
+EXPORT_SYMBOL(enable_dolby_vision);
+
+static bool video_is_hdr10;
+module_param(video_is_hdr10, bool, 0664);
+MODULE_PARM_DESC(video_is_hdr10, "\n video_is_hdr10\n");
+
+/*
+    dolby vision enhanced layer receiver
+*/
+#define DVEL_RECV_NAME "dvel"
+
+static struct vframe_s *dv_vf[16][2];
+static void *metadata_parser;
+static char meta_buf[1024];
+static char md_buf[1024];
+static char comp_buf[8196];
+static int dvel_receiver_event_fun(int type, void *data, void *arg)
+{
+	char *provider_name = (char *)data;
+	int i;
+
+	if (type == VFRAME_EVENT_PROVIDER_UNREG) {
+		pr_info("%s, provider %s unregistered\n",
+			__func__, provider_name);
+		for (i = 0; i < 16; i++)
+			dv_vf[i][0] = dv_vf[i][1] = NULL;
+		if (metadata_parser && p_funcs) {
+			p_funcs->metadata_parser_release();
+			metadata_parser = NULL;
+		}
+		frame_count = 0;
+		return -1;
+	} else if (type == VFRAME_EVENT_PROVIDER_QUREY_STATE) {
+		return RECEIVER_ACTIVE;
+	} else if (type == VFRAME_EVENT_PROVIDER_REG) {
+		pr_info("%s, provider %s registered\n",
+			__func__, provider_name);
+		for (i = 0; i < 16; i++)
+			dv_vf[i][0] = dv_vf[i][1] = NULL;
+		frame_count = 0;
+	}
+	return 0;
+}
+
+static inline void dvel_vf_put(struct vframe_s *vf)
+{
+	struct vframe_provider_s *vfp = vf_get_provider(DVEL_RECV_NAME);
+	if (vfp)
+		vf_put(vf, DVEL_RECV_NAME);
+}
+
+static inline struct vframe_s *dvel_vf_peek(void)
+{
+	return vf_peek(DVEL_RECV_NAME);
+}
+
+static inline struct vframe_s *dvel_vf_get(void)
+{
+	return vf_get(DVEL_RECV_NAME);
+}
+
+static const struct vframe_receiver_op_s dvel_vf_receiver = {
+	.event_cb = dvel_receiver_event_fun
+};
+
+static struct vframe_receiver_s dvel_vf_recv;
+
+void dolby_vision_init_receiver(void)
+{
+	pr_info("%s(%s)\n", __func__, DVEL_RECV_NAME);
+	vf_receiver_init(&dvel_vf_recv, DVEL_RECV_NAME,
+			&dvel_vf_receiver, &dvel_vf_recv);
+	vf_reg_receiver(&dvel_vf_recv);
+	pr_info("%s: %s\n", __func__, dvel_vf_recv.name);
+}
+EXPORT_SYMBOL(dolby_vision_init_receiver);
+
+void dump_setting(struct dovi_setting_s *setting)
+{
+	int i;
+	uint32_t *p;
+
+	if ((debug_dolby & 0x10) && dump_enable) {
+		pr_info("core1\n");
+		p = (uint32_t *)&setting->dm_reg1;
+		for (i = 0; i < 26; i++)
+			pr_info("%x\n", p[i]);
+
+		pr_info("composer\n");
+		p = (uint32_t *)&setting->comp_reg;
+		for (i = 0; i < 173; i++)
+			pr_info("%x\n", p[i]);
+	}
+
+	if ((debug_dolby & 0x20) && dump_enable) {
+		pr_info("core1lut\n");
+		p = (uint32_t *)&setting->dm_lut1.TmLutI;
+		for (i = 0; i < 64; i++)
+			pr_info("%x, %x, %x, %x\n",
+				p[i*4+3], p[i*4+2], p[i*4+1], p[i*4]);
+		pr_info("\n");
+		p = (uint32_t *)&setting->dm_lut1.TmLutS;
+		for (i = 0; i < 64; i++)
+			pr_info("%x, %x, %x, %x\n",
+				p[i*4+3], p[i*4+2], p[i*4+1], p[i*4]);
+		pr_info("\n");
+		p = (uint32_t *)&setting->dm_lut1.SmLutI;
+		for (i = 0; i < 64; i++)
+			pr_info("%x, %x, %x, %x\n",
+				p[i*4+3], p[i*4+2], p[i*4+1], p[i*4]);
+		pr_info("\n");
+		p = (uint32_t *)&setting->dm_lut1.SmLutS;
+		for (i = 0; i < 64; i++)
+			pr_info("%x, %x, %x, %x\n",
+				p[i*4+3], p[i*4+2], p[i*4+1], p[i*4]);
+		pr_info("\n");
+		p = (uint32_t *)&setting->dm_lut1.G2L;
+		for (i = 0; i < 64; i++)
+			pr_info("%x, %x, %x, %x\n",
+				p[i*4+3], p[i*4+2], p[i*4+1], p[i*4]);
+		pr_info("\n");
+	}
+
+	if ((debug_dolby & 0x10) && dump_enable) {
+		pr_info("core2\n");
+		p = (uint32_t *)&setting->dm_reg2;
+		for (i = 0; i < 24; i++)
+			pr_info("%x\n", p[i]);
+	}
+
+	if ((debug_dolby & 0x20) && dump_enable) {
+		pr_info("core2lut\n");
+		p = (uint32_t *)&setting->dm_lut2.TmLutI;
+		for (i = 0; i < 64; i++)
+			pr_info("%x, %x, %x, %x\n",
+				p[i*4+3], p[i*4+2], p[i*4+1], p[i*4]);
+		pr_info("\n");
+		p = (uint32_t *)&setting->dm_lut2.TmLutS;
+		for (i = 0; i < 64; i++)
+			pr_info("%x, %x, %x, %x\n",
+				p[i*4+3], p[i*4+2], p[i*4+1], p[i*4]);
+		pr_info("\n");
+		p = (uint32_t *)&setting->dm_lut2.SmLutI;
+		for (i = 0; i < 64; i++)
+			pr_info("%x, %x, %x, %x\n",
+				p[i*4+3], p[i*4+2], p[i*4+1], p[i*4]);
+		pr_info("\n");
+		p = (uint32_t *)&setting->dm_lut2.SmLutS;
+		for (i = 0; i < 64; i++)
+			pr_info("%x, %x, %x, %x\n",
+				p[i*4+3], p[i*4+2], p[i*4+1], p[i*4]);
+		pr_info("\n");
+		p = (uint32_t *)&setting->dm_lut2.G2L;
+		for (i = 0; i < 64; i++)
+			pr_info("%x, %x, %x, %x\n",
+				p[i*4+3], p[i*4+2], p[i*4+1], p[i*4]);
+		pr_info("\n");
+	}
+
+	if ((debug_dolby & 0x10) && dump_enable) {
+		pr_info("core3\n");
+		p = (uint32_t *)&setting->dm_reg3;
+		for (i = 0; i < 26; i++)
+			pr_info("%x\n", p[i]);
+	}
+
+	if ((debug_dolby & 0x40) && dump_enable) {
+		pr_info("core3_meta %d\n", setting->md_reg3.size);
+		p = setting->md_reg3.raw_metadata;
+		for (i = 0; i < setting->md_reg3.size; i++)
+			pr_info("%x\n", p[i]);
+	}
+}
+
+int dolby_vision_wait_metadata(struct vframe_s *vf)
+{
+	struct provider_aux_req_s req;
+	struct vframe_s *el_vf;
+
+	req.vf = vf;
+	req.bot_flag = 0;
+	req.aux_buf = NULL;
+	req.aux_size = 0;
+	req.dv_enhance_exist = 0;
+	vf_notify_provider_by_name("dvbldec",
+		VFRAME_EVENT_RECEIVER_GET_AUX_DATA,
+	(void *)&req);
+	if (req.dv_enhance_exist) {
+		el_vf = dvel_vf_peek();
+		while (el_vf) {
+			if (debug_dolby & 2)
+				pr_dolby_dbg("=== peek bl(%p-%lld) with el(%p-%lld) ===\n",
+					vf, vf->pts_us64,
+					el_vf, el_vf->pts_us64);
+			if (el_vf->pts_us64 == vf->pts_us64) {
+				/* found el */
+				return 0;
+			} else if (el_vf->pts_us64 < vf->pts_us64) {
+				if (debug_dolby & 2)
+					pr_dolby_dbg("bl(%p-%lld) => skip el pts(%p-%lld)\n",
+						vf, vf->pts_us64,
+						el_vf, el_vf->pts_us64);
+				el_vf = dvel_vf_get();
+				dvel_vf_put(el_vf);
+				vf_notify_provider(DVEL_RECV_NAME,
+					VFRAME_EVENT_RECEIVER_PUT, NULL);
+				if (debug_dolby & 2) {
+					pr_dolby_dbg("=== get & put el(%p-%lld) ===\n",
+						el_vf, el_vf->pts_us64);
+				}
+				/* skip old el */
+				el_vf = dvel_vf_peek();
+			} else {
+				/* no el found */
+				return 1;
+			}
+		}
+		/* need wait el */
+		if (el_vf == NULL)
+			return 2;
+	}
+	return 0;
+}
+
+void dolby_vision_vf_put(struct vframe_s *vf)
+{
+	int i;
+	if (vf)
+		for (i = 0; i < 16; i++) {
+			if (dv_vf[i][0] == vf) {
+				if (dv_vf[i][1]) {
+					if (debug_dolby & 2)
+						pr_dolby_dbg("--- put bl(%p-%lld) with el(%p-%lld) ---\n",
+							vf, vf->pts_us64,
+							dv_vf[i][1],
+							dv_vf[i][1]->pts_us64);
+					dvel_vf_put(dv_vf[i][1]);
+				} else if (debug_dolby & 2) {
+					pr_dolby_dbg("--- put bl(%p-%lld) ---\n",
+						vf, vf->pts_us64);
+				}
+				dv_vf[i][0] = NULL;
+				dv_vf[i][1] = NULL;
+			}
+		}
+}
+EXPORT_SYMBOL(dolby_vision_vf_put);
+
+struct vframe_s *dolby_vision_vf_peek_el(struct vframe_s *vf)
+{
+	int i;
+
+	if (dolby_vision_flags) {
+		for (i = 0; i < 16; i++) {
+			if (dv_vf[i][0] == vf) {
+				if (dv_vf[i][1]
+				&& (dolby_vision_status == BYPASS_PROCESS))
+					dv_vf[i][1]->type |= VIDTYPE_VD2;
+				return dv_vf[i][1];
+			}
+		}
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(dolby_vision_vf_peek_el);
+
+static void dolby_vision_vf_add(struct vframe_s *vf, struct vframe_s *el_vf)
+{
+	int i;
+	for (i = 0; i < 16; i++) {
+		if (dv_vf[i][0] == NULL) {
+			dv_vf[i][0] = vf;
+			dv_vf[i][1] = el_vf;
+			break;
+		}
+	}
+}
+
+static int dolby_vision_vf_check(struct vframe_s *vf)
+{
+	int i;
+	for (i = 0; i < 16; i++) {
+		if (dv_vf[i][0] == vf) {
+			if (debug_dolby & 2) {
+				if (dv_vf[i][1])
+					pr_dolby_dbg("=== bl(%p-%lld) with el(%p-%lld) toggled ===\n",
+						vf,
+						vf->pts_us64,
+						dv_vf[i][1],
+						dv_vf[i][1]->pts_us64);
+				else
+					pr_dolby_dbg("=== bl(%p-%lld) toggled ===\n",
+						vf,
+						vf->pts_us64);
+			}
+			return 0;
+		}
+	}
+	return 1;
+}
+
+static int parse_sei_and_meta(
+	struct vframe_s *vf,
+	struct provider_aux_req_s *req,
+	int *total_comp_size,
+	int *total_md_size,
+	enum signal_format_e *src_format)
+{
+	int i;
+	char *p;
+	unsigned size = 0;
+	unsigned type = 0;
+	int md_size = 0;
+	int comp_size = 0;
+	int parser_ready = 0;
+	int ret = -1;
+
+	if ((req->aux_buf == NULL)
+	|| (req->aux_size == 0))
+		return 0;
+
+	p = req->aux_buf;
+	while (p < req->aux_buf + req->aux_size - 8) {
+		size = *p++;
+		size = (size << 8) | *p++;
+		size = (size << 8) | *p++;
+		size = (size << 8) | *p++;
+		type = *p++;
+		type = (type << 8) | *p++;
+		type = (type << 8) | *p++;
+		type = (type << 8) | *p++;
+
+		if (type == 0x01000000) {
+			/* source is VS10 */
+			*src_format = FORMAT_DOVI;
+			pr_dolby_dbg("meta(%d), pts(%lld)\n",
+				size, vf->pts_us64);
+			meta_buf[0] = meta_buf[1] = meta_buf[2] = 0;
+			memcpy(&meta_buf[3], p+1, size-1);
+			if ((debug_dolby & 4) && dump_enable) {
+				for (i = 0; i < size+2; i++) {
+					pr_info("%02x ",
+						meta_buf[i]);
+					if (i%16 == 15)
+						pr_info("\n");
+				}
+				if (i%16 != 0)
+					pr_info("\n");
+			}
+
+			/* prepare metadata parser */
+			parser_ready = 0;
+			if (metadata_parser == NULL) {
+				metadata_parser =
+					p_funcs->metadata_parser_init();
+				if (metadata_parser != NULL)
+					parser_ready = 1;
+			} else {
+				if (p_funcs->metadata_parser_reset() == 0)
+					parser_ready = 1;
+			}
+
+			if (parser_ready) {
+				md_size = comp_size = 0;
+				ret = p_funcs->metadata_parser_process(
+					meta_buf, size+2,
+					comp_buf + *total_comp_size,
+					&comp_size,
+					md_buf + *total_md_size,
+					&md_size,
+					true);
+				if (ret) {
+					pr_dolby_error(
+						"metadata parser process fail\n");
+					p_funcs->metadata_parser_release();
+					metadata_parser = NULL;
+					return -1;
+				} else {
+					*total_comp_size += comp_size;
+					*total_md_size += md_size;
+				}
+			} else {
+				pr_dolby_error("metadata parser init fail\n");
+				return -1;
+			}
+			if ((ret == 0)
+			&& (debug_dolby & 8)
+			&& dump_enable) {
+				pr_dolby_dbg("parsed md(%d), comp(%d)\n",
+					md_size, comp_size);
+				for (i = 0; i < md_size; i++) {
+					pr_info("%02x ",
+						md_buf[*total_md_size+i]);
+					if (i%16 == 15)
+						pr_info("\n");
+				}
+				if (i%16 != 0)
+					pr_info("\n");
+			}
+			if ((debug_dolby & 8)  && dump_enable) {
+				for (i = 0; i < comp_size; i++) {
+					pr_info("%02x ",
+						comp_buf[*total_comp_size+i]);
+					if (i%16 == 15)
+						pr_info("\n");
+				}
+				if (i%16 != 0)
+					pr_info("\n");
+			}
+		}
+		p += size;
+	}
+	return 0;
+}
+
+#define signal_color_primaries ((vf->signal_type >> 16) & 0xff)
+#define signal_transfer_characteristic ((vf->signal_type >> 8) & 0xff)
+static int dolby_vision_parse_metadata(struct vframe_s *vf)
+{
+	const struct vinfo_s *vinfo = get_current_vinfo();
+	struct vframe_s *el_vf;
+	struct provider_aux_req_s req;
+	struct provider_aux_req_s el_req;
+
+	int flag;
+	enum signal_format_e src_format = FORMAT_SDR;
+	enum signal_format_e dst_format;
+	int total_md_size = 0;
+	int total_comp_size = 0;
+	bool el_flag = 0;
+	bool el_halfsize_flag = 1;
+
+	if ((!dolby_vision_enable) || (!p_funcs))
+		return 1;
+
+	if (vf) {
+		pr_dolby_dbg("frame %d:\n", frame_count);
+
+		/* check source format */
+		if (signal_transfer_characteristic == 16)
+			video_is_hdr10 = true;
+		else
+			video_is_hdr10 = false;
+		if (video_is_hdr10)
+			src_format = FORMAT_HDR10;
+
+		req.vf = vf;
+		req.bot_flag = 0;
+		req.aux_buf = NULL;
+		req.aux_size = 0;
+		req.dv_enhance_exist = 0;
+		vf_notify_provider_by_name("dvbldec",
+			VFRAME_EVENT_RECEIVER_GET_AUX_DATA,
+	    (void *)&req);
+		/* parse meta in base layer */
+		parse_sei_and_meta(vf, &req,
+			&total_comp_size, &total_md_size, &src_format);
+
+		if (req.dv_enhance_exist) {
+			el_vf = dvel_vf_get();
+			if (el_vf
+			&& (el_vf->pts_us64 == vf->pts_us64)) {
+				if (debug_dolby & 2)
+					pr_dolby_dbg("+++ get bl(%p-%lld) with el(%p-%lld) +++\n",
+						vf, vf->pts_us64,
+						el_vf, el_vf->pts_us64);
+				el_req.vf = el_vf;
+				el_req.bot_flag = 0;
+				el_req.aux_buf = NULL;
+				el_req.aux_size = 0;
+				vf_notify_provider_by_name("dveldec",
+					VFRAME_EVENT_RECEIVER_GET_AUX_DATA,
+					(void *)&el_req);
+				/* parse meta in enhanced layer */
+				parse_sei_and_meta(el_vf, &el_req,
+					&total_comp_size, &total_md_size,
+					&src_format);
+				dolby_vision_vf_add(vf, el_vf);
+				if (dolby_vision_flags) {
+					el_flag = 1;
+					if (vf->width == el_vf->width)
+						el_halfsize_flag = 0;
+				}
+			} else {
+				if (!el_vf)
+					pr_dolby_error(
+						"bl(%p-%lld) not found el\n",
+						vf, vf->pts_us64);
+				else
+					pr_dolby_error(
+						"bl(%p-%lld) not found el(%p-%lld)\n",
+						vf, vf->pts_us64,
+						el_vf, el_vf->pts_us64);
+			}
+		} else {
+			if (debug_dolby & 2)
+				pr_dolby_dbg(
+					"+++ get bl(%p-%lld) +++\n",
+					vf, vf->pts_us64);
+			dolby_vision_vf_add(vf, NULL);
+		}
+	}
+
+	/* if not DOVI, release metadata_parser */
+	if ((src_format != FORMAT_DOVI) && metadata_parser) {
+		p_funcs->metadata_parser_release();
+		metadata_parser = NULL;
+	}
+
+	if (dolby_vision_mode == DOLBY_VISION_OUTPUT_MODE_BYPASS) {
+		frame_count++;
+		return 0;
+	}
+
+	/* check target luminance */
+	if (dolby_vision_flags & FLAG_USE_SINK_MIN_MAX) {
+		if (vinfo->dv_info != NULL) {
+			if (vinfo->dv_info->ver == 0) {
+				/* need lookup PQ table ... */
+				/*
+				dolby_vision_graphic_min =
+				dolby_vision_target_min =
+					vinfo->dv_info.ver0.target_min_pq;
+				dolby_vision_graphic_max =
+				dolby_vision_target_max =
+					vinfo->dv_info.ver0.target_max_pq;
+				*/
+			} else if (vinfo->dv_info->ver == 1) {
+				if (vinfo->dv_info->vers.ver1.target_max_lum) {
+					/* Target max luminance = 100+50*CV */
+					dolby_vision_graphic_max =
+					dolby_vision_target_max =
+						(vinfo->dv_info->
+						vers.ver1.target_max_lum
+						* 50 + 100);
+					/* Target min luminance = (CV/127)^2 */
+					dolby_vision_graphic_min =
+					dolby_vision_target_min =
+						(vinfo->dv_info->
+						vers.ver1.target_min_lum ^ 2)
+						* 10000 / (127 * 127);
+				}
+			}
+		} else if (vinfo->hdr_info.hdr_support) {
+			if (vinfo->hdr_info.lumi_max) {
+				/* Luminance value = 50 * (2 ^ (CV/32)) */
+				dolby_vision_graphic_max =
+				dolby_vision_target_max = 50 *
+					(2 ^ (vinfo->hdr_info.lumi_max >> 5));
+				/* Desired Content Min Luminance =
+					Desired Content Max Luminance
+					* (CV/255) * (CV/255) / 100	*/
+				dolby_vision_graphic_min =
+				dolby_vision_target_min =
+					dolby_vision_target_max * 10000
+					* vinfo->hdr_info.lumi_min
+					* vinfo->hdr_info.lumi_min
+					/ (255 * 255 * 100);
+			}
+		}
+	}
+
+	/* check dst format */
+	if ((dolby_vision_mode == DOLBY_VISION_OUTPUT_MODE_IPT_TUNNEL)
+			|| (dolby_vision_mode == DOLBY_VISION_OUTPUT_MODE_IPT))
+		dst_format = FORMAT_DOVI;
+	else if (dolby_vision_mode == DOLBY_VISION_OUTPUT_MODE_HDR10)
+		dst_format = FORMAT_HDR10;
+	else
+		dst_format = FORMAT_SDR;
+
+	flag = p_funcs->control_path(
+		src_format, dst_format,
+		comp_buf, total_comp_size,
+		md_buf, total_md_size,
+		VIDEO_PRIORITY,
+		12, 0, SIG_RANGE_SMPTE, /* bit/chroma/range */
+		dolby_vision_graphic_min, dolby_vision_graphic_max * 10000,
+		dolby_vision_target_min, dolby_vision_target_max * 10000,
+		(!el_flag) ||
+		(dolby_vision_flags & FLAG_DISABLE_COMPOSER), /* disable el */
+		&hdr10_param,
+		&dovi_setting);
+	if (flag >= 0) {
+		dovi_setting.src_format = src_format;
+		dovi_setting.el_flag = el_flag;
+		dovi_setting.el_halfsize_flag = el_halfsize_flag;
+		if (el_flag)
+			pr_dolby_dbg("setting %d->%d(T:%d-%d): flag=%02x,md=%d,comp=%d\n",
+				src_format, dst_format,
+				dolby_vision_target_min,
+				dolby_vision_target_max,
+				total_md_size, total_comp_size, flag);
+		else
+			pr_dolby_dbg("setting %d->%d(T:%d-%d): flag=%02x,md=%d\n",
+				src_format, dst_format,
+				dolby_vision_target_min,
+				dolby_vision_target_max,
+				total_md_size, flag);
+		dump_setting(&dovi_setting);
+		frame_count++;
+		return 0; /* setting updated */
+	} else {
+		pr_dolby_error("control_path() failed\n");
+	}
+	frame_count++;
+	return 1; /* do nothing for this frame */
+}
+
+int dolby_vision_update_metadata(struct vframe_s *vf)
+{
+	int ret = -1;
+
+	if (!dolby_vision_enable)
+		return -1;
+
+	if (vf && dolby_vision_vf_check(vf))
+		ret = dolby_vision_parse_metadata(vf);
+
+	return ret;
+}
+EXPORT_SYMBOL(dolby_vision_update_metadata);
+
+int dolby_vision_process(struct vframe_s *vf)
+{
+	const struct vinfo_s *vinfo = get_current_vinfo();
+
+	if (get_cpu_type() != MESON_CPU_MAJOR_ID_GXM)
+		return -1;
+
+	if ((!dolby_vision_enable) || (!p_funcs))
+		return -1;
+
+	if (dolby_vision_mode == DOLBY_VISION_OUTPUT_MODE_BYPASS) {
+		if (dolby_vision_status != BYPASS_PROCESS)
+			enable_dolby_vision(0);
+		return 0;
+	}
+
+	if (vf) {
+		if ((dolby_vision_flags & FLAG_TOGGLE_FRAME) == 0)
+			return -1;
+		dolby_core1_set(
+			24,	173, 256 * 5,
+			(uint32_t *)&dovi_setting.dm_reg1,
+			(uint32_t *)&dovi_setting.comp_reg,
+			(uint32_t *)&dovi_setting.dm_lut1,
+			(vf->type & VIDTYPE_COMPRESS) ?
+				vf->compWidth : vf->width,
+			(vf->type & VIDTYPE_COMPRESS) ?
+				vf->compHeight : vf->height,
+			1, /* BL enable */
+			dovi_setting.el_flag, /* EL enable */
+			dovi_setting.el_halfsize_flag, /* if BL and EL is 4:1 */
+			dolby_vision_mode ==
+			DOLBY_VISION_OUTPUT_MODE_IPT_TUNNEL, 1);
+		dolby_core2_set(
+			24, 256 * 5,
+			(uint32_t *)&dovi_setting.dm_reg2,
+			(uint32_t *)&dovi_setting.dm_lut2,
+			1920, 1080, 1, 1);
+		dolby_core3_set(
+			26, dovi_setting.md_reg3.size,
+			(uint32_t *)&dovi_setting.dm_reg3,
+			dovi_setting.md_reg3.raw_metadata,
+			vinfo->width, vinfo->height, 1,
+			dolby_vision_mode ==
+			DOLBY_VISION_OUTPUT_MODE_IPT_TUNNEL);
+		enable_dolby_vision(1);
+		/* update dolby_vision_status */
+		if ((dovi_setting.src_format == FORMAT_DOVI)
+		&& (dolby_vision_status != DV_PROCESS)) {
+			pr_dolby_dbg("Dolby Vision mode changed to DV_PROCESS\n");
+			dolby_vision_status = DV_PROCESS;
+		} else if ((dovi_setting.src_format == FORMAT_HDR10)
+		&& (dolby_vision_status != HDR_PROCESS)) {
+			pr_dolby_dbg("Dolby Vision mode changed to HDR_PROCESS\n");
+			dolby_vision_status = HDR_PROCESS;
+		} else if ((dovi_setting.src_format == FORMAT_SDR)
+		&& (dolby_vision_status != SDR_PROCESS)) {
+			pr_dolby_dbg("Dolby Vision mode changed to SDR_PROCESS\n");
+			dolby_vision_status = SDR_PROCESS;
+		}
+		dolby_vision_flags &= ~FLAG_TOGGLE_FRAME;
+		return 0;
+	}
+
+	if ((dolby_vision_flags & FLAG_TOGGLE_FRAME) == 0)
+		return -1;
+
+	dolby_vision_parse_metadata(NULL);
+	dolby_core1_set(
+		24,	173, 256 * 4,
+		(uint32_t *)&dovi_setting.dm_reg1,
+		(uint32_t *)&dovi_setting.comp_reg,
+		(uint32_t *)&dovi_setting.dm_lut1,
+		vinfo->width, vinfo->height,
+		1, /* BL enable */
+		0, /* EL enable */
+		1, /* if BL and EL is 4:1 */
+		dolby_vision_mode ==
+		DOLBY_VISION_OUTPUT_MODE_IPT_TUNNEL, 1);
+	dolby_core2_set(
+		24, 256 * 5,
+		(uint32_t *)&dovi_setting.dm_reg2,
+		(uint32_t *)&dovi_setting.dm_lut2,
+		1920, 1080, 1, 1);
+	dolby_core3_set(
+		26, dovi_setting.md_reg3.size,
+		(uint32_t *)&dovi_setting.dm_reg3,
+		dovi_setting.md_reg3.raw_metadata,
+		vinfo->width, vinfo->height, 1,
+		dolby_vision_mode ==
+		DOLBY_VISION_OUTPUT_MODE_IPT_TUNNEL);
+	enable_dolby_vision(1);
+	/* update dolby_vision_status */
+	if ((dovi_setting.src_format == FORMAT_DOVI)
+	&& (dolby_vision_status != DV_PROCESS)) {
+		pr_dolby_dbg("Dolby Vision mode changed to DV_PROCESS\n");
+		dolby_vision_status = DV_PROCESS;
+	} else if ((dovi_setting.src_format == FORMAT_HDR10)
+	&& (dolby_vision_status != HDR_PROCESS)) {
+		pr_dolby_dbg("Dolby Vision mode changed to HDR_PROCESS\n");
+		dolby_vision_status = HDR_PROCESS;
+	} else if ((dovi_setting.src_format == FORMAT_SDR)
+	&& (dolby_vision_status != SDR_PROCESS)) {
+		pr_dolby_dbg("Dolby Vision mode changed to SDR_PROCESS\n");
+		dolby_vision_status = SDR_PROCESS;
+	}
+	dolby_vision_flags &= ~FLAG_TOGGLE_FRAME;
+	return 0;
+}
+EXPORT_SYMBOL(dolby_vision_process);
+
+bool is_dolby_vision_on(void)
+{
+	return dolby_vision_on;
+}
+EXPORT_SYMBOL(is_dolby_vision_on);
+
+void dolby_vision_set_toggle_flag(int flag)
+{
+	if (flag)
+		dolby_vision_flags |= FLAG_TOGGLE_FRAME;
+	else
+		dolby_vision_flags &= ~FLAG_TOGGLE_FRAME;
+}
+EXPORT_SYMBOL(dolby_vision_set_toggle_flag);
+
+void set_dolby_vision_mode(int mode)
+{
+	if ((get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)
+	&& dolby_vision_enable) {
+		dolby_vision_mode = mode;
+		video_is_hdr10 = false;
+		dolby_vision_set_toggle_flag(1);
+		dolby_vision_process(NULL);
+	}
+}
+EXPORT_SYMBOL(set_dolby_vision_mode);
+
+int get_dolby_vision_mode(void)
+{
+	return dolby_vision_mode;
+}
+EXPORT_SYMBOL(get_dolby_vision_mode);
+
+bool is_dolby_vision_enable(void)
+{
+	return dolby_vision_enable;
+}
+EXPORT_SYMBOL(is_dolby_vision_enable);
+
+int register_dv_functions(const struct dolby_vision_func_s *func)
+{
+	int ret = -1;
+	if (!p_funcs && func) {
+		pr_info("*** register_dv_functions\n ***");
+		p_funcs = func;
+		ret = 0;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(register_dv_functions);
+
+int unregister_dv_functions(void)
+{
+	int ret = -1;
+	if (p_funcs) {
+		pr_info("*** unregister_dv_functions\n ***");
+		p_funcs = NULL;
+		ret = 0;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(unregister_dv_functions);
diff --git a/drivers/amlogic/amvecm/amve.c b/drivers/amlogic/amvecm/amve.c
index 000b96d..eace6da 100644
--- a/drivers/amlogic/amvecm/amve.c
+++ b/drivers/amlogic/amvecm/amve.c
@@ -33,7 +33,7 @@
 
 #define pr_amve_dbg(fmt, args...)\
 	do {\
-		if (dnlp_debug)\
+		if (dnlp_debug&0x1)\
 			pr_info("AMVE: " fmt, ## args);\
 	} while (0)\
 /* #define pr_amve_error(fmt, args...) */
@@ -41,8 +41,6 @@
 
 #define GAMMA_RETRY        1000
 
-#define SPEED_CTL_VALUE  1
-
 /* 0: Invalid */
 /* 1: Valid */
 /* 2: Updated in 2D mode */
@@ -60,8 +58,6 @@ MODULE_PARM_DESC(dnlp_sel, "dnlp_sel");
 
 struct ve_hist_s video_ve_hist;
 
-bool is_vlock = false;
-
 static unsigned char ve_dnlp_tgt[64];
 bool ve_en;
 unsigned int ve_dnlp_white_factor;
@@ -114,6 +110,16 @@ int amvecm_hiu_reg_write(unsigned int reg, unsigned int val)
 	writel(val, (amvecm_hiu_reg_base+((reg - 0x1000)<<2)));
 	return 0;
 }
+static int amvecm_hiu_reg_write_bits(unsigned int reg, unsigned int value,
+		unsigned int start, unsigned int len)
+{
+	unsigned int rd_val;
+	amvecm_hiu_reg_read(reg, &rd_val);
+	amvecm_hiu_reg_write(reg, ((rd_val &
+	     ~(((1L << (len)) - 1) << (start))) |
+	    (((value) & ((1L << (len)) - 1)) << (start))));
+	return 0;
+}
 
 
 module_param(ve_dnlp_waist_h, int, 0664);
@@ -579,7 +585,7 @@ module_param(ve_dnlp_pavg_btsft, int, 0664);
 MODULE_PARM_DESC(ve_dnlp_pavg_btsft, "ve_dnlp_pavg_btsft");
 
 /* limit range */
-static bool ve_dnlp_limit_rng;
+static bool ve_dnlp_limit_rng = 1;
 module_param(ve_dnlp_limit_rng, bool, 0664);
 MODULE_PARM_DESC(ve_dnlp_limit_rng, "input limit range");
 
@@ -662,31 +668,26 @@ static unsigned int assist_cnt2;/* ASSIST_SPARE8_REG2; */
 /* video lock */
 #define VLOCK_MODE_ENC          0
 #define VLOCK_MODE_PLL		1
+#define VLOCK_MODE_MANUAL_PLL	2
 #define XTAL_VLOCK_CLOCK   24000000/*vlock use xtal clock*/
 
-
-unsigned int vlock_mode = VLOCK_MODE_PLL;/* 0:enc;1:pll */
-module_param(vlock_mode, uint, 0664);
-MODULE_PARM_DESC(vlock_mode, "\n vlock_mode\n");
-
-unsigned int vlock_en = 0;
-module_param(vlock_en, uint, 0664);
-MODULE_PARM_DESC(vlock_en, "\n vlock_en\n");
-
+/* 0:enc;1:pll;2:manual pll */
+static unsigned int vlock_mode = VLOCK_MODE_MANUAL_PLL;
+static unsigned int vlock_en = 1;
 /*
 0:only support 50->50;60->60;24->24;30->30;
 1:support 24/30/50/60/100/120 mix,such as 50->60;
 */
-unsigned int vlock_adapt = 0;
-module_param(vlock_adapt, uint, 0664);
-MODULE_PARM_DESC(vlock_adapt, "\n vlock_adapt\n");
-
-unsigned int vlock_dis_cnt_limit = 2;
-module_param(vlock_dis_cnt_limit, uint, 0664);
-MODULE_PARM_DESC(vlock_dis_cnt_limit, "\n vlock_dis_cnt_limit\n");
+static unsigned int vlock_adapt;
+static unsigned int vlock_dis_cnt_limit = 2;
+static unsigned int vlock_delta_limit = 2;
+/*vlock_debug:bit0:disable info;bit1:format change info;bit2:force reset*/
+static unsigned int vlock_debug;
+static unsigned int vlock_dynamic_adjust = 1;
 
 static unsigned int vlock_sync_limit_flag;
-static enum vmode_e pre_vmode = VMODE_1080P;
+static unsigned int vlock_state = VLOCK_STATE_NULL;/*1/2/3:vlock step*/
+static enum vmode_e pre_vmode = VMODE_INIT_NULL;
 static enum vframe_source_type_e pre_source_type =
 		VFRAME_SOURCE_TYPE_OTHERS;
 static enum vframe_source_mode_e pre_source_mode =
@@ -694,52 +695,30 @@ static enum vframe_source_mode_e pre_source_mode =
 static unsigned int pre_input_freq;
 static unsigned int pre_output_freq;
 static unsigned int vlock_dis_cnt;
+static char pre_vout_mode[64];
+static bool vlock_vmode_changed;
+static unsigned int pre_hiu_reg_m;
+static unsigned int pre_hiu_reg_frac;
+static unsigned int vlock_dis_cnt_no_vf;
+static unsigned int vlock_dis_cnt_no_vf_limit = 5;
+
 
 /* 3d sync parts begin */
 unsigned int sync_3d_h_start = 0;
-module_param(sync_3d_h_start, uint, 0664);
-MODULE_PARM_DESC(sync_3d_h_start, "\n sync_3d_h_start\n");
-
 unsigned int sync_3d_h_end = 0;
-module_param(sync_3d_h_end, uint, 0664);
-MODULE_PARM_DESC(sync_3d_h_end, "\n sync_3d_h_end\n");
-
 unsigned int sync_3d_v_start = 10;
-module_param(sync_3d_v_start, uint, 0664);
-MODULE_PARM_DESC(sync_3d_v_start, "\n sync_3d_v_start\n");
-
 unsigned int sync_3d_v_end = 20;
-module_param(sync_3d_v_end, uint, 0664);
-MODULE_PARM_DESC(sync_3d_v_end, "\n sync_3d_v_end\n");
-
 unsigned int sync_3d_polarity = 0;
-module_param(sync_3d_polarity, uint, 0664);
-MODULE_PARM_DESC(sync_3d_polarity, "\n sync_3d_polarity\n");
-
 unsigned int sync_3d_out_inv = 0;
-module_param(sync_3d_out_inv, uint, 0664);
-MODULE_PARM_DESC(sync_3d_out_inv, "\n sync_3d_out_inv\n");
-
 unsigned int sync_3d_black_color = 0x008080;/* yuv black */
-module_param(sync_3d_black_color, uint, 0664);
-MODULE_PARM_DESC(sync_3d_black_color, "\n sync_3d_black_color\n");
-
 /* 3d sync to v by one enable/disable */
 unsigned int sync_3d_sync_to_vbo = 0;
-module_param(sync_3d_sync_to_vbo, uint, 0664);
-MODULE_PARM_DESC(sync_3d_sync_to_vbo, "\n sync_3d_sync_to_vbo\n");
-/* #endif */
 /* 3d sync parts end */
 
-unsigned int vlock_debug = 0;
-module_param(vlock_debug, uint, 0664);
-MODULE_PARM_DESC(vlock_debug, "\n vlock_debug\n");
-
 unsigned int contrast_adj_sel;/*0:vdj1, 1:vd1 mtx rgb contrast*/
 module_param(contrast_adj_sel, uint, 0664);
 MODULE_PARM_DESC(contrast_adj_sel, "\n contrast_adj_sel\n");
 
-
 /* *********************************************************************** */
 /* *** VPP_FIQ-oriented functions **************************************** */
 /* *********************************************************************** */
@@ -764,7 +743,8 @@ static void ve_hist_gamma_tgt(struct vframe_s *vf)
 	video_ve_hist.ave =
 		video_ve_hist.sum/(video_ve_hist.height*
 				video_ve_hist.width);
-	if (vf->source_type == VFRAME_SOURCE_TYPE_PPMGR) {
+	if ((vf->source_type == VFRAME_SOURCE_TYPE_OTHERS) &&
+		(is_meson_gxtvbb_cpu())) {
 		ave_luma = video_ve_hist.ave;
 		ave_luma = (ave_luma - 16) < 0 ? 0 : (ave_luma - 16);
 		video_ve_hist.ave = ave_luma*255/(235-16);
@@ -1181,6 +1161,11 @@ void GetGmBlkCvs(unsigned int *rGmOt, unsigned int *rGmIn,
 	int i = 0;
 	int nTmp0 = 0;
 
+	if (!ve_dnlp_luma_sum) {
+		for (nT0 = 0; nT0 < 65; nT0++)
+			pgmma0[nT0] = (nT0 << 4); /* 0 ~1024 */
+	}
+
 	GetSubCurve(pLst, rGmIn, pwdth); /*0~1024*/
 
 	for (nT0 = 0; nT0 < 65; nT0++) {
@@ -1867,6 +1852,11 @@ static void clash_blend(void)
 	int nTmp0 = 0;
 	static unsigned int pgmma[65];
 
+	if (!ve_dnlp_luma_sum) {
+		for (i = 0; i < 65; i++)
+			pgmma[i] = (i << 4); /* 0 ~1024 */
+	}
+
 	if (!dnlp_scn_chg && ((ve_dnlp_dbg_i2r >> 3) & 0x1))
 		for (i = 0; i < 65; i++) {
 			nTmp0 = dnlp_bld_lvl * clash_curve[i] + (RBASE >> 1);
@@ -2153,6 +2143,13 @@ static void dnlp_rfrsh_subgmma(void)
 	static unsigned int pgmma0[65]; /* 0~4096*/
 	static unsigned int pgmma1[65];
 
+	if (!ve_dnlp_luma_sum) {
+		for (i = 0; i < 65; i++) {
+			pgmma0[i] = (i << 6); /* 0 ~4096 */
+			pgmma1[i] = (i << 6); /* 0 ~4096 */
+		}
+	}
+
 	if (!dnlp_scn_chg)
 		for (i = 0; i < 65; i++) {
 			gma_scurve0[i] = dnlp_bld_lvl *
@@ -2220,6 +2217,11 @@ static void dnlp_gmma_cuvs(unsigned int gmma_rate,
 	static unsigned int pgmma[65];
 	bool prt_flg = ((dnlp_printk >> 10) & 0x1);
 
+	if (!ve_dnlp_luma_sum) {
+		for (i = 0; i < 65; i++)
+			pgmma[i] = (i << 6); /* 0 ~4096 */
+	}
+
 	/* refresh sub gamma */
 	if ((ve_dnlp_dbg_i2r >> 1) & 0x1)
 		dnlp_rfrsh_subgmma();
@@ -2275,6 +2277,11 @@ static void dnlp_clsh_sbld(unsigned int mtdbld_rate)
 
 	static unsigned int pgmma[65];
 
+	if (!ve_dnlp_luma_sum) {
+		for (i = 0; i < 65; i++)
+			pgmma[i] = (i << 4); /* 0 ~1024 */
+	}
+
 	for (i = 0; i < 65; i++) {
 		nTmp0 = gma_scurvet[i]; /* 0 ~1024 */
 		nTmp0 = nTmp0*mtdbld_rate + clash_curve[i]*(64 - mtdbld_rate);
@@ -2304,6 +2311,11 @@ static void dnlp_blkgma_bld(unsigned int *blk_gma_rat)
 	int i = 0;
 	static unsigned int pgmma[65];
 
+	if (!ve_dnlp_luma_sum) {
+		for (i = 0; i < 65; i++)
+			pgmma[i] = (i << 4); /* 0 ~1024 */
+	}
+
 	for (i = 0; i < 64; i++) {
 		nT1 = blk_gma_rat[i];
 		nTmp0 = clsh_scvbld[i];
@@ -2342,6 +2354,11 @@ static void dnlp_blkwht_bld(int *blk_wht_ext, int bright,
 	int i = 0;
 	static unsigned int pgmma[65];
 
+	if (!ve_dnlp_luma_sum) {
+		for (i = 0; i < 65; i++)
+			pgmma[i] = (i << 4); /* 0 ~1024 */
+	}
+
 	/* black / white extension */
 	for (i = 0; i < 64; i++) {
 		nTmp0 = blk_gma_bld[i];
@@ -3580,10 +3597,6 @@ void ve_on_vs(struct vframe_s *vf)
 	}
 	ve_hist_gamma_tgt(vf);
 
-	/* vlock processs */
-	if (is_meson_g9tv_cpu() || is_meson_gxtvbb_cpu())
-		amve_vlock_process(vf);
-
 	/* sharpness process */
 	sharpness_process(vf);
 
@@ -3627,6 +3640,9 @@ void vpp_set_lcd_gamma_table(u16 *data, u32 rgb_mask)
 {
 	int i;
 	int cnt = 0;
+	unsigned long flags = 0;
+
+	spin_lock_irqsave(&vpp_lcd_gamma_lock, flags);
 
 	while (!(READ_VPP_REG(L_GAMMA_CNTL_PORT) & (0x1 << ADR_RDY))) {
 		udelay(10);
@@ -3654,6 +3670,8 @@ void vpp_set_lcd_gamma_table(u16 *data, u32 rgb_mask)
 	WRITE_VPP_REG(L_GAMMA_ADDR_PORT, (0x1 << H_AUTO_INC) |
 				    (0x1 << rgb_mask)   |
 				    (0x23 << HADR));
+
+	spin_unlock_irqrestore(&vpp_lcd_gamma_lock, flags);
 }
 
 void vpp_set_rgb_ogo(struct tcon_rgb_ogo_s *p)
@@ -4341,22 +4359,18 @@ void ve_ogo_param_update(void)
 	vecm_latch_flag |= FLAG_RGB_OGO;
 }
 
-/*video lock begin*/
-/* #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESONG9TV) */
-static unsigned int amvecm_vlock_check_input_hz(struct vframe_s *vf)
+static unsigned int vlock_check_input_hz(struct vframe_s *vf)
 {
 	unsigned int ret_hz = 0;
 	unsigned int duration = vf->duration;
 
-	if ((vf->source_type != VFRAME_SOURCE_TYPE_TUNER) &&
-		(vf->source_type != VFRAME_SOURCE_TYPE_CVBS) &&
+	if ((vf->source_type != VFRAME_SOURCE_TYPE_CVBS) &&
 		(vf->source_type != VFRAME_SOURCE_TYPE_HDMI))
 		ret_hz = 0;
 	else if (vf->source_type == VFRAME_SOURCE_TYPE_HDMI) {
 		if (duration != 0)
 			ret_hz = (96000 + duration/2)/duration;
-	} else if ((vf->source_type == VFRAME_SOURCE_TYPE_TUNER) ||
-		(vf->source_type == VFRAME_SOURCE_TYPE_CVBS)) {
+	} else if (vf->source_type == VFRAME_SOURCE_TYPE_CVBS) {
 		if (vf->source_mode == VFRAME_SOURCE_MODE_NTSC)
 			ret_hz = 60;
 		else if ((vf->source_mode == VFRAME_SOURCE_MODE_PAL) ||
@@ -4368,8 +4382,7 @@ static unsigned int amvecm_vlock_check_input_hz(struct vframe_s *vf)
 	return ret_hz;
 }
 
-static unsigned int
-amvecm_vlock_check_output_hz(unsigned int sync_duration_num)
+static unsigned int vlock_check_output_hz(unsigned int sync_duration_num)
 {
 	unsigned int ret_hz = 0;
 	switch (sync_duration_num) {
@@ -4397,30 +4410,35 @@ amvecm_vlock_check_output_hz(unsigned int sync_duration_num)
 	}
 	return ret_hz;
 }
-static void amvecm_vlock_setting(struct vframe_s *vf,
-		unsigned int input_hz, unsigned int output_hz)
+static void vlock_enable(bool enable)
 {
-	unsigned int freq_hz = 0;
-	unsigned int reg_value, hiu_reg_value, hiu_reg_value_2;
-	unsigned int m_reg_value, m_reg_value_2, m_reg_value_3;
-	unsigned int tmp_value, abs_value;
-	if (((input_hz != output_hz) && (vlock_adapt == 0)) ||
-			(input_hz == 0) || (output_hz == 0)) {
-		/* VLOCK_CNTL_EN disable */
-		/* WRITE_CBUS_REG_BITS(HHI_HDMI_PLL_CNTL6,0,20,1); */
-		aml_cbus_update_bits(HHI_HDMI_PLL_CNTL6, 0<<20, 0);
-		vlock_dis_cnt = vlock_dis_cnt_limit;
-		pr_info("[%s]auto disable vlock module for no support case!!!\n",
-				__func__);
-		return;
+	if (is_meson_g9tv_cpu() || is_meson_gxtvbb_cpu() ||
+		is_meson_gxbb_cpu()) {
+		if (vlock_mode == VLOCK_MODE_MANUAL_PLL)
+			amvecm_hiu_reg_write_bits(HHI_HDMI_PLL_CNTL6, 0, 20, 1);
+		else
+			amvecm_hiu_reg_write_bits(HHI_HDMI_PLL_CNTL6,
+				enable, 20, 1);
+	} else if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
+		if (vlock_mode == VLOCK_MODE_MANUAL_PLL)
+			amvecm_hiu_reg_write_bits(HHI_HDMI_PLL_CNTL5, 0, 3, 1);
+		else
+			amvecm_hiu_reg_write_bits(HHI_HDMI_PLL_CNTL5,
+				enable, 3, 1);
 	}
+}
+static void vlock_setting(struct vframe_s *vf,
+		unsigned int input_hz, unsigned int output_hz)
+{
+	unsigned int freq_hz = 0, hiu_reg_value_2_addr = HHI_HDMI_PLL_CNTL2;
+	unsigned int reg_value = 0, hiu_reg_value, hiu_reg_value_2;
+	unsigned int hiu_m_val, hiu_frac_val;
+
 	amvecm_hiu_reg_write(HHI_VID_LOCK_CLK_CNTL, 0x80);
 	if (vlock_mode == VLOCK_MODE_ENC) {
 		am_set_regmap(&vlock_enc_lcd720x480);
 		/* VLOCK_CNTL_EN disable */
-		/* WRITE_CBUS_REG_BITS(HHI_HDMI_PLL_CNTL6,0,20,1); */
-		amvecm_hiu_reg_read(HHI_HDMI_PLL_CNTL6, &hiu_reg_value);
-		amvecm_hiu_reg_write(HHI_HDMI_PLL_CNTL6, hiu_reg_value|(0<<20));
+		vlock_enable(0);
 		/* disable to adjust pll */
 		WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 0, 29, 1);
 		/* CFG_VID_LOCK_ADJ_EN enable */
@@ -4432,7 +4450,8 @@ static void amvecm_vlock_setting(struct vframe_s *vf,
 		/*clear accum0 value*/
 		WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 1, 5, 1);
 	}
-	if (vlock_mode == VLOCK_MODE_PLL) {
+	if ((vlock_mode == VLOCK_MODE_PLL) ||
+		(vlock_mode == VLOCK_MODE_MANUAL_PLL)) {
 		/* av pal in,1080p60 hdmi out as default */
 		am_set_regmap(&vlock_pll_in50hz_out60hz);
 		/*
@@ -4447,41 +4466,35 @@ static void amvecm_vlock_setting(struct vframe_s *vf,
 		(output_freq/input_freq)*Ifrm_cnt_mod must be integer
 		*/
 		if (vlock_adapt == 0)
-			WRITE_VPP_REG_BITS(VPU_VLOCK_MISC_CTRL,
-				1, 16, 8);
+			WRITE_VPP_REG_BITS(VPU_VLOCK_MISC_CTRL, 1, 16, 8);
 		else
 			WRITE_VPP_REG_BITS(VPU_VLOCK_MISC_CTRL,
 				input_hz, 16, 8);
 		/*set PLL M_INT;PLL M_frac*/
 		/* WRITE_VPP_REG_BITS(VPU_VLOCK_MX4096, */
 		/* READ_CBUS_REG_BITS(HHI_HDMI_PLL_CNTL,0,9),12,9); */
-	if (is_vlock) {
 		amvecm_hiu_reg_read(HHI_HDMI_PLL_CNTL, &hiu_reg_value);
-		amvecm_hiu_reg_read(HHI_HDMI_PLL_CNTL2, &hiu_reg_value_2);
-		reg_value = ((hiu_reg_value & 0x1FF) << 12)
-					+ ((hiu_reg_value_2 & 0x3FF) << 2);
+		amvecm_hiu_reg_read(hiu_reg_value_2_addr,
+			&hiu_reg_value_2);
+		if (is_meson_g9tv_cpu())
+			reg_value = ((hiu_reg_value & 0x1FF) << 12)
+				+ (hiu_reg_value_2 & 0xFFF);
+		else if (is_meson_gxtvbb_cpu() || is_meson_txl_cpu()) {
+			hiu_m_val = hiu_reg_value & 0x1FF;
+			hiu_frac_val = hiu_reg_value_2 & 0x3FF;
+			if (hiu_reg_value_2 & 0x800) {
+				hiu_m_val -= 1;
+				if (hiu_reg_value_2 & 0x400)
+					hiu_m_val -= 1;
+				hiu_frac_val = 0x400 -
+					((~(hiu_frac_val - 1)) & 0x3ff);
+			} else if (hiu_reg_value_2 & 0x400) {
+				hiu_m_val += 1;
+			}
+			reg_value = (hiu_m_val << 12)
+				+ (hiu_frac_val << 2);
+		}
 		WRITE_VPP_REG_BITS(VPU_VLOCK_MX4096, reg_value, 0, 21);
-		is_vlock = false;
-	}
-
-	m_reg_value = READ_VPP_REG_BITS(VPU_VLOCK_RO_M_INT_FRAC, 16, 9);
-	amvecm_hiu_reg_read(HHI_HDMI_PLL_CNTL, &m_reg_value_2);
-	abs_value = abs(m_reg_value - (m_reg_value_2 & 0x1ff));
-
-	if (abs_value <= SPEED_CTL_VALUE) {
-		m_reg_value_3 = READ_VPP_REG(VPU_VLOCK_RO_M_INT_FRAC);
-
-		amvecm_hiu_reg_read(HHI_HDMI_PLL_CNTL2, &tmp_value);
-		tmp_value = (tmp_value & 0xfffff000) |
-					((m_reg_value_3 >> 2) & 0x3ff);
-		amvecm_hiu_reg_write(HHI_HDMI_PLL_CNTL2, tmp_value);
-
-		amvecm_hiu_reg_read(HHI_HDMI_PLL_CNTL, &tmp_value);
-		tmp_value = (tmp_value & 0xfffffe00) |
-					((m_reg_value_3 >> 16) & 0x1ff);
-		amvecm_hiu_reg_write(HHI_HDMI_PLL_CNTL, tmp_value);
-	}
-
 
 		/* vlock module output goes to which module */
 		switch (READ_VPP_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 0, 2)) {
@@ -4503,8 +4516,7 @@ static void amvecm_vlock_setting(struct vframe_s *vf,
 		/* disable to adjust pll */
 		WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 0, 30, 1);
 		/* VLOCK_CNTL_EN enable */
-		/* WRITE_CBUS_REG_BITS(HHI_HDMI_PLL_CNTL6,1,20,1); */
-		aml_cbus_update_bits(HHI_HDMI_PLL_CNTL6, 0<<20, 1);
+		vlock_enable(1);
 		/* enable to adjust pll */
 		WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 1, 29, 1);
 	}
@@ -4517,110 +4529,313 @@ static void amvecm_vlock_setting(struct vframe_s *vf,
 		WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 1, 16, 3);
 	WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 1, 31, 1);
 }
+void vlock_vmode_check(void)
+{
+	const struct vinfo_s *vinfo;
+	unsigned int tmp_value, hiu_reg_addr;
+	char cur_vout_mode[64];
+	if (vlock_en == 0)
+		return;
+
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)
+		hiu_reg_addr = HHI_HDMI_PLL_CNTL1;
+	else
+		hiu_reg_addr = HHI_HDMI_PLL_CNTL2;
+
+	vinfo = get_current_vinfo();
+	vlock_vmode_changed = 0;
+	memset(cur_vout_mode, 0, sizeof(cur_vout_mode));
+	strcpy(cur_vout_mode, vinfo->name);
+	if (strcmp(cur_vout_mode, pre_vout_mode) != 0) {
+		amvecm_hiu_reg_read(hiu_reg_addr, &tmp_value);
+		pre_hiu_reg_frac = tmp_value & 0xfff;
+		amvecm_hiu_reg_read(HHI_HDMI_PLL_CNTL, &tmp_value);
+		pre_hiu_reg_m = tmp_value & 0x1ff;
+		if (vlock_debug & 0x10)
+			pr_info("[%s]:vout mode changed:%s==>%s\n",
+				__func__, pre_vout_mode, cur_vout_mode);
+		memset(pre_vout_mode, 0, sizeof(pre_vout_mode));
+		strcpy(pre_vout_mode, cur_vout_mode);
+		vlock_vmode_changed = 1;
+	}
+}
+static void vlock_disable_step1(void)
+{
+	unsigned int m_reg_value, tmp_value;
+	unsigned int hiu_reg_addr;
+
+	/* VLOCK_CNTL_EN disable */
+	vlock_enable(0);
+	vlock_vmode_check();
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)
+		hiu_reg_addr = HHI_HDMI_PLL_CNTL1;
+	else
+		hiu_reg_addr = HHI_HDMI_PLL_CNTL2;
+
+	amvecm_hiu_reg_read(hiu_reg_addr, &tmp_value);
+	m_reg_value = tmp_value & 0xfff;
+	if ((m_reg_value != pre_hiu_reg_frac) &&
+		(pre_hiu_reg_frac != 0)) {
+		tmp_value = (tmp_value & 0xfffff000) |
+			(pre_hiu_reg_frac & 0xfff);
+		amvecm_hiu_reg_write(hiu_reg_addr, tmp_value);
+	}
+	amvecm_hiu_reg_read(HHI_HDMI_PLL_CNTL, &tmp_value);
+	m_reg_value = tmp_value & 0x1ff;
+	if ((m_reg_value != pre_hiu_reg_m) &&
+		(pre_hiu_reg_m != 0)) {
+		tmp_value = (tmp_value & 0xfffffe00) |
+			(pre_hiu_reg_m & 0x1ff);
+		amvecm_hiu_reg_write(HHI_HDMI_PLL_CNTL, tmp_value);
+	}
+	vlock_dis_cnt = vlock_dis_cnt_limit;
+	pre_vmode = VMODE_INIT_NULL;
+	pre_source_type = VFRAME_SOURCE_TYPE_OTHERS;
+	pre_source_mode = VFRAME_SOURCE_MODE_OTHERS;
+	pre_input_freq = 0;
+	pre_output_freq = 0;
+	vlock_state = VLOCK_STATE_DISABLE_STEP1_DONE;
+}
+
+static void vlock_disable_step2(void)
+{
+	/* need delay to disable follow regs(vlsi suggest!!!) */
+	if (vlock_dis_cnt > 0)
+		vlock_dis_cnt--;
+	if (vlock_dis_cnt == 0) {
+		/* disable to adjust pll */
+		WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 0, 29, 1);
+		/* CFG_VID_LOCK_ADJ_EN disable */
+		WRITE_VPP_REG_BITS(ENCL_MAX_LINE_SWITCH_POINT,
+				0, 13, 1);
+		/* disable to adjust pll */
+		WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 0, 30, 1);
+		/* disable vid_lock_en */
+		WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 0, 31, 1);
+		vlock_state = VLOCK_STATE_DISABLE_STEP2_DONE;
+	}
+}
+static void vlock_enable_step1(struct vframe_s *vf, struct vinfo_s *vinfo,
+	unsigned int input_hz, unsigned int output_hz)
+{
+	vlock_setting(vf, input_hz, output_hz);
+	if (vlock_debug & 0x10) {
+		pr_info("%s:vmode/source_type/source_mode/input_freq/output_freq:\n",
+			__func__);
+		pr_info("\t%d/%d/%d/%d/%d=>%d/%d/%d/%d/%d\n",
+			pre_vmode, pre_source_type, pre_source_mode,
+			pre_input_freq, pre_output_freq,
+			vinfo->mode, vf->source_type, vf->source_mode,
+			input_hz, output_hz);
+	}
+	pre_vmode = vinfo->mode;
+	pre_source_type = vf->source_type;
+	pre_source_mode = vf->source_mode;
+	pre_input_freq = input_hz;
+	pre_output_freq = output_hz;
+	vlock_sync_limit_flag = 0;
+	vlock_vmode_changed = 0;
+	vlock_dis_cnt = 0;
+	vlock_state = VLOCK_STATE_ENABLE_STEP1_DONE;
+
+}
+static void vlock_enable_step3(void)
+{
+	unsigned int m_reg_value, tmp_value, abs_val;
+	unsigned int hiu_reg_addr;
+
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)
+		hiu_reg_addr = HHI_HDMI_PLL_CNTL1;
+	else
+		hiu_reg_addr = HHI_HDMI_PLL_CNTL2;
+
+	m_reg_value = READ_VPP_REG(VPU_VLOCK_RO_M_INT_FRAC);
+	if (m_reg_value == 0) {
+		vlock_state = VLOCK_STATE_ENABLE_FORCE_RESET;
+		if (vlock_debug & 0x100)
+			pr_info("%s:vlock work abnormal! force reset vlock\n",
+				__func__);
+		return;
+	}
+	amvecm_hiu_reg_read(hiu_reg_addr, &tmp_value);
+	abs_val = abs(((m_reg_value & 0xfff) >> 2) - (tmp_value & 0xfff));
+	if (abs_val > vlock_delta_limit) {
+		tmp_value = (tmp_value & 0xfffff000) |
+			((m_reg_value & 0xfff) >> 2);
+		amvecm_hiu_reg_write(hiu_reg_addr, tmp_value);
+	}
+	amvecm_hiu_reg_read(HHI_HDMI_PLL_CNTL, &tmp_value);
+	if (((m_reg_value >> 16) & 0x1ff) != (tmp_value & 0x1ff)) {
+		tmp_value = (tmp_value & 0xfffffe00) |
+			((m_reg_value >> 16) & 0x1ff);
+		amvecm_hiu_reg_write(HHI_HDMI_PLL_CNTL, tmp_value);
+	}
+}
 /* won't change this function internal seqence,
  * if really need change,please be carefull */
 void amve_vlock_process(struct vframe_s *vf)
 {
-	const struct vinfo_s *vinfo;
+	struct vinfo_s *vinfo;
 	unsigned int input_hz, output_hz, input_vs_cnt;
 
 	if (vecm_latch_flag & FLAG_VLOCK_DIS) {
-		/* VLOCK_CNTL_EN disable */
-		/* WRITE_CBUS_REG_BITS(HHI_HDMI_PLL_CNTL6,0,20,1); */
-		aml_cbus_update_bits(HHI_HDMI_PLL_CNTL6, 0<<20, 0);
-		vlock_dis_cnt = vlock_dis_cnt_limit;
+		vlock_disable_step1();
 		vlock_en = 0;
 		vecm_latch_flag &= ~FLAG_VLOCK_DIS;
+		if (vlock_debug & 0x1)
+			pr_info("[%s]disable vlock module!!!\n", __func__);
+		return;
+	}
+	vinfo = get_current_vinfo();
+	input_hz = vlock_check_input_hz(vf);
+	output_hz = vlock_check_output_hz(vinfo->sync_duration_num);
+	vlock_dis_cnt_no_vf = 0;
+	if (vecm_latch_flag & FLAG_VLOCK_EN) {
+		vlock_enable_step1(vf, vinfo, input_hz, output_hz);
+		vlock_en = 1;
+		vecm_latch_flag &= ~FLAG_VLOCK_EN;
+	}
+	if (vlock_state == VLOCK_STATE_DISABLE_STEP1_DONE) {
+		vlock_disable_step2();
 		return;
 	}
 	if (vlock_en == 1) {
-		vinfo = get_current_vinfo();
-		input_hz = amvecm_vlock_check_input_hz(vf);
-		is_vlock = true;
-		if (input_hz == 0)
+		if (((input_hz != output_hz) && (vlock_adapt == 0)) ||
+			(input_hz == 0) || (output_hz == 0)) {
+			if (vlock_state != VLOCK_STATE_DISABLE_STEP2_DONE)
+				vlock_disable_step1();
+			if (vlock_debug & 0x1)
+				pr_info("[%s]auto disable vlock module for no support case!!!\n",
+					__func__);
 			return;
-		output_hz =
-			amvecm_vlock_check_output_hz(vinfo->sync_duration_num);
-	if ((vinfo->mode != pre_vmode) ||
+		}
+		vlock_vmode_check();
+		if ((vinfo->mode != pre_vmode) ||
 			(vf->source_type != pre_source_type) ||
 			(vf->source_mode != pre_source_mode) ||
 			(input_hz != pre_input_freq) ||
-			(output_hz != pre_output_freq)) {
-		amvecm_vlock_setting(vf, input_hz, output_hz);
-		if (vlock_debug) {
-			pr_amve_dbg("%s:vmode/source_type/source_mode/",
-			__func__);
-			pr_amve_dbg("input_freq/output_freq change:");
-			pr_amve_dbg("%d/%d/%d/%d/%d=>%d/%d/%d/%d/%d\n",
-			pre_vmode, pre_source_type, pre_source_mode,
-			pre_input_freq, pre_output_freq, vinfo->mode,
-			vf->source_type, vf->source_mode,
-			input_hz, output_hz);
-		}
-			pre_vmode = vinfo->mode;
-			pre_source_type = vf->source_type;
-			pre_source_mode = vf->source_mode;
-			pre_input_freq = input_hz;
-			pre_output_freq = output_hz;
-			vlock_sync_limit_flag = 0;
-		}
-		if (vlock_sync_limit_flag < 5) {
+			(output_hz != pre_output_freq) ||
+			vlock_vmode_changed ||
+			(vlock_state == VLOCK_STATE_ENABLE_FORCE_RESET))
+			vlock_enable_step1(vf, vinfo, input_hz, output_hz);
+		if ((vlock_sync_limit_flag < 10) &&
+			(vlock_state >= VLOCK_STATE_ENABLE_STEP1_DONE))
 			vlock_sync_limit_flag++;
-			if (vlock_sync_limit_flag == 5) {
-				/*input_vs_cnt =*/
-				/*READ_VPP_REG_BITS(VPU_VLOCK_RO_VS_I_DIST,*/
-				/*	0, 28);*/
-				input_vs_cnt = XTAL_VLOCK_CLOCK/input_hz;
-				WRITE_VPP_REG(VPU_VLOCK_LOOP1_IMISSYNC_MAX,
-						input_vs_cnt*125/100);
-				WRITE_VPP_REG(VPU_VLOCK_LOOP1_IMISSYNC_MIN,
-						input_vs_cnt*70/100);
-				/*cal accum1 value*/
-				WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 0, 2, 1);
-				/*cal accum0 value*/
-				WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 0, 5, 1);
-			}
+		if ((vlock_sync_limit_flag == 5) &&
+			(vlock_state == VLOCK_STATE_ENABLE_STEP1_DONE)) {
+			/*input_vs_cnt =*/
+			/*READ_VPP_REG_BITS(VPU_VLOCK_RO_VS_I_DIST,*/
+			/*	0, 28);*/
+			input_vs_cnt = XTAL_VLOCK_CLOCK/input_hz;
+			WRITE_VPP_REG(VPU_VLOCK_LOOP1_IMISSYNC_MAX,
+					input_vs_cnt*125/100);
+			WRITE_VPP_REG(VPU_VLOCK_LOOP1_IMISSYNC_MIN,
+					input_vs_cnt*70/100);
+			/*cal accum1 value*/
+			WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 0, 2, 1);
+			/*cal accum0 value*/
+			WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 0, 5, 1);
+			vlock_state = VLOCK_STATE_ENABLE_STEP2_DONE;
+		} else if (vlock_dynamic_adjust &&
+			(vlock_sync_limit_flag > 5) &&
+			(vlock_state == VLOCK_STATE_ENABLE_STEP2_DONE) &&
+			(is_meson_gxtvbb_cpu() || is_meson_txl_cpu()) &&
+			(vlock_mode == VLOCK_MODE_MANUAL_PLL)) {
+			vlock_enable_step3();
 		}
-		return;
 	}
-	if (vlock_dis_cnt > 0) {
-		vlock_dis_cnt--;
-		if (vlock_dis_cnt == 0) {
-			/* disable to adjust pll */
-			WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 0, 29, 1);
-			/* CFG_VID_LOCK_ADJ_EN disable */
-			WRITE_VPP_REG_BITS(ENCL_MAX_LINE_SWITCH_POINT,
-					0, 13, 1);
-			/* disable to adjust pll */
-			WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 0, 30, 1);
-			/* disable vid_lock_en */
-			WRITE_VPP_REG_BITS(VPU_VLOCK_CTRL, 0, 31, 1);
-		}
+}
+
+void amve_vlock_resume(void)
+{
+	if ((vlock_en == 0) || (vlock_state ==
+		VLOCK_STATE_DISABLE_STEP2_DONE))
+		return;
+	if (vlock_state == VLOCK_STATE_DISABLE_STEP1_DONE) {
+		vlock_disable_step2();
+		return;
 	}
-	if (vecm_latch_flag & FLAG_VLOCK_EN) {
-		vinfo = get_current_vinfo();
-		/* pr_info("[%s]vinfo->name:%s\n",__func__,vinfo->name); */
-		input_hz = amvecm_vlock_check_input_hz(vf);
-		output_hz =
-			amvecm_vlock_check_output_hz(vinfo->sync_duration_num);
-		amvecm_vlock_setting(vf, input_hz, output_hz);
-		pr_amve_dbg("%s:current vmode/source_type/source_mode/",
+	vlock_dis_cnt_no_vf++;
+	if ((vlock_state != VLOCK_STATE_DISABLE_STEP2_DONE) &&
+		(vlock_dis_cnt_no_vf > vlock_dis_cnt_no_vf_limit)) {
+		vlock_disable_step1();
+		vlock_dis_cnt_no_vf = 0;
+		if (vlock_debug & 0x1)
+			pr_info("[%s]auto disable vlock module for no vframe & run disable step1.!!!\n",
 				__func__);
-		pr_amve_dbg("input_freq/output_freq/sig_fmt is:");
-		pr_amve_dbg("%d/%d/%d/%d/%d/0x%x\n",
-				vinfo->mode, vf->source_type,
-				vf->source_mode, input_hz,
-				output_hz, vf->sig_fmt);
-		vinfo = get_current_vinfo();
-		pre_vmode = vinfo->mode;
-		pre_source_type = vf->source_type;
-		pre_source_mode = vf->source_mode;
-		pre_input_freq = input_hz;
-		pre_output_freq = output_hz;
-		vlock_en = 1;
-		vlock_sync_limit_flag = 0;
-		vecm_latch_flag &= ~FLAG_VLOCK_EN;
 	}
+	if (vlock_debug & 0x1)
+		pr_info("[%s]auto disable vlock module for no vframe!!!\n",
+			__func__);
+	if (vlock_dynamic_adjust &&
+		(vlock_sync_limit_flag > 5) &&
+		(vlock_state == VLOCK_STATE_ENABLE_STEP2_DONE) &&
+		(is_meson_gxtvbb_cpu() || is_meson_txl_cpu()) &&
+		(vlock_mode == VLOCK_MODE_MANUAL_PLL))
+		vlock_enable_step3();
+}
+void vlock_param_set(unsigned int val, enum vlock_param_e sel)
+{
+	switch (sel) {
+	case VLOCK_EN:
+		vlock_en = val;
+		break;
+	case VLOCK_ADAPT:
+		vlock_adapt = val;
+		break;
+	case VLOCK_MODE:
+		vlock_mode = val;
+		break;
+	case VLOCK_DIS_CNT_LIMIT:
+		vlock_dis_cnt_limit = val;
+		break;
+	case VLOCK_DELTA_LIMIT:
+		vlock_delta_limit = val;
+		break;
+	case VLOCK_DEBUG:
+		vlock_debug = val;
+		break;
+	case VLOCK_DYNAMIC_ADJUST:
+		vlock_dynamic_adjust = val;
+		break;
+	case VLOCK_DIS_CNT_NO_VF_LIMIT:
+		vlock_dis_cnt_no_vf_limit = val;
+		break;
+	default:
+		pr_info("%s:unknow vlock param:%d\n", __func__, sel);
+		break;
+	}
+
+}
+void vlock_status(void)
+{
+	pr_info("\n current vlock parameters status:\n");
+	pr_info("vlock_mode:%d\n", vlock_mode);
+	pr_info("vlock_en:%d\n", vlock_en);
+	pr_info("vlock_adapt:%d\n", vlock_adapt);
+	pr_info("vlock_dis_cnt_limit:%d\n", vlock_dis_cnt_limit);
+	pr_info("vlock_delta_limit:%d\n", vlock_delta_limit);
+	pr_info("vlock_debug:0x%x\n", vlock_debug);
+	pr_info("vlock_dynamic_adjust:%d\n", vlock_dynamic_adjust);
+	pr_info("vlock_state:%d\n", vlock_state);
+	pr_info("vlock_sync_limit_flag:%d\n", vlock_sync_limit_flag);
+	pr_info("pre_vmode:%d\n", pre_vmode);
+	pr_info("pre_hiu_reg_m:0x%x\n", pre_hiu_reg_m);
+	pr_info("pre_hiu_reg_frac:0x%x\n", pre_hiu_reg_frac);
+	pr_info("vlock_dis_cnt:%d\n", vlock_dis_cnt);
+	pr_info("pre_vout_mode:%s\n", pre_vout_mode);
+	pr_info("vlock_dis_cnt_no_vf:%d\n", vlock_dis_cnt_no_vf);
+	pr_info("vlock_dis_cnt_no_vf_limit:%d\n", vlock_dis_cnt_no_vf_limit);
+}
+void vlock_reg_dump(void)
+{
+	unsigned int addr;
+
+	pr_info("----dump vlock reg----\n");
+	for (addr = (0x3000); addr <= (0x3020); addr++)
+		pr_info("[0x%x]vcbus[0x%04x]=0x%08x\n",
+			(0xd0100000+(addr<<2)), addr,
+			READ_VPP_REG(addr));
 }
 /*video lock end*/
 
@@ -4632,18 +4847,30 @@ void sharpness_process(struct vframe_s *vf)
 /* sharpness process end */
 
 /*for gxbbtv rgb contrast adj in vd1 matrix */
-void vpp_vd1_mtx_rgb_contrast(signed int cont_val)
+void vpp_vd1_mtx_rgb_contrast(signed int cont_val, struct vframe_s *vf)
 {
 	unsigned int vd1_contrast;
-	unsigned int vdj1_ctl;
+	unsigned int con_minus_value, rgb_con_en;
 	if ((cont_val > 1023) || (cont_val < -1024))
 		return;
 	cont_val = cont_val + 1024;
+	/*close rgb contrast protect*/
+	WRITE_VPP_REG_BITS(XVYCC_VD1_RGB_CTRST, 0, 0, 1);
 	/*VPP_VADJ_CTRL bit 1 on for rgb contrast adj*/
-	vdj1_ctl = READ_VPP_REG_BITS(XVYCC_VD1_RGB_CTRST, 1, 1);
-	if (!vdj1_ctl)
+	rgb_con_en = READ_VPP_REG_BITS(XVYCC_VD1_RGB_CTRST, 1, 1);
+	if (!rgb_con_en)
 		WRITE_VPP_REG_BITS(XVYCC_VD1_RGB_CTRST, 1, 1, 1);
 
+	/*select full or limit range setting*/
+	con_minus_value = READ_VPP_REG_BITS(XVYCC_VD1_RGB_CTRST, 4, 10);
+	if (vf->source_type == VFRAME_SOURCE_TYPE_OTHERS) {
+		if (con_minus_value != 64)
+			WRITE_VPP_REG_BITS(XVYCC_VD1_RGB_CTRST, 64, 4, 10);
+	} else {
+		if (con_minus_value != 0)
+			WRITE_VPP_REG_BITS(XVYCC_VD1_RGB_CTRST, 0, 4, 10);
+	}
+
 	vd1_contrast = (READ_VPP_REG(XVYCC_VD1_RGB_CTRST) & 0xf000ffff) |
 					(cont_val << 16);
 
@@ -4651,7 +4878,7 @@ void vpp_vd1_mtx_rgb_contrast(signed int cont_val)
 }
 
 /*for gxbbtv contrast adj in vadj1*/
-void vpp_vd_adj1_contrast(signed int cont_val)
+void vpp_vd_adj1_contrast(signed int cont_val, struct vframe_s *vf)
 {
 	unsigned int vd1_contrast;
 	unsigned int vdj1_ctl;
@@ -4660,9 +4887,15 @@ void vpp_vd_adj1_contrast(signed int cont_val)
 	cont_val = ((cont_val + 1024) >> 3);
 	/*VPP_VADJ_CTRL bit 1 off for contrast adj*/
 	vdj1_ctl = READ_VPP_REG_BITS(VPP_VADJ_CTRL, 1, 1);
-	if (vdj1_ctl)
-		WRITE_VPP_REG_BITS(VPP_VADJ_CTRL, 0, 1, 1);
-
+	if (is_meson_gxtvbb_cpu()) {
+		if (vf->source_type == VFRAME_SOURCE_TYPE_OTHERS) {
+			if (!vdj1_ctl)
+				WRITE_VPP_REG_BITS(VPP_VADJ_CTRL, 1, 1, 1);
+		} else {
+			if (vdj1_ctl)
+				WRITE_VPP_REG_BITS(VPP_VADJ_CTRL, 0, 1, 1);
+		}
+	}
 	if (get_cpu_type() > MESON_CPU_MAJOR_ID_GXTVBB) {
 		vd1_contrast = (READ_VPP_REG(VPP_VADJ1_Y) & 0x3ff00) |
 						(cont_val << 0);
@@ -4699,10 +4932,18 @@ void vpp_vd_adj1_brightness(signed int bri_val, struct vframe_s *vf)
 	} else {
 		if ((vf->source_type == VFRAME_SOURCE_TYPE_TUNER) ||
 			(vf->source_type == VFRAME_SOURCE_TYPE_CVBS) ||
-			(vf->source_type == VFRAME_SOURCE_TYPE_COMP) ||
-			(vf->source_type == VFRAME_SOURCE_TYPE_HDMI))
+			(vf->source_type == VFRAME_SOURCE_TYPE_COMP))
 			vd1_brightness = bri_val;
-		else {
+		else if (vf->source_type == VFRAME_SOURCE_TYPE_HDMI) {
+			if ((((vf->signal_type >> 29) & 0x1) == 1) &&
+				(((vf->signal_type >> 16) & 0xff) == 9)) {
+					bri_val += ao0;
+					if (bri_val < -1024)
+						bri_val = -1024;
+					vd1_brightness = bri_val;
+			} else
+				vd1_brightness = bri_val;
+		} else {
 			bri_val += ao0;
 			if (bri_val < -1024)
 				bri_val = -1024;
@@ -4807,22 +5048,28 @@ static void vd1_brightness_contrast(signed int brightness,
 	WRITE_VPP_REG(VPP_MATRIX_CTRL         , ori);
 }
 
-void amvecm_bricon_process(unsigned int bri_val,
-		unsigned int cont_val, struct vframe_s *vf)
+void amvecm_bricon_process(signed int bri_val,
+		signed int cont_val, struct vframe_s *vf)
 {
 	if (vecm_latch_flag & FLAG_VADJ1_BRI) {
 		vecm_latch_flag &= ~FLAG_VADJ1_BRI;
 		vpp_vd_adj1_brightness(bri_val, vf);
 		pr_amve_dbg("\n[amve..] set vd1_brightness OK!!!\n");
+		if (dnlp_debug&0x100)
+			pr_info("\n[amve..]%s :brightness:%d!!!\n",
+				__func__, bri_val);
 	}
 
 	if (vecm_latch_flag & FLAG_VADJ1_CON) {
 		vecm_latch_flag &= ~FLAG_VADJ1_CON;
 		if (contrast_adj_sel)
-			vpp_vd1_mtx_rgb_contrast(cont_val);
+			vpp_vd1_mtx_rgb_contrast(cont_val, vf);
 		else
-			vpp_vd_adj1_contrast(cont_val);
+			vpp_vd_adj1_contrast(cont_val, vf);
 		pr_amve_dbg("\n[amve..] set vd1_contrast OK!!!\n");
+		if (dnlp_debug&0x100)
+			pr_info("\n[amve..]%s :contrast:%d!!!\n",
+				__func__, cont_val);
 	}
 
 	if (0) { /* vecm_latch_flag & FLAG_BRI_CON) { */
@@ -4833,6 +5080,19 @@ void amvecm_bricon_process(unsigned int bri_val,
 }
 /* brightness/contrast adjust process end */
 
+void amvecm_color_process(signed int sat_val,
+		signed int hue_val, struct vframe_s *vf)
+{
+	if (vecm_latch_flag & FLAG_VADJ1_COLOR) {
+		vecm_latch_flag &= ~FLAG_VADJ1_COLOR;
+		vpp_vd_adj1_saturation_hue(sat_val, hue_val, vf);
+		if (dnlp_debug&0x100)
+			pr_info("\n[amve..]%s :saturation:%d,hue:%d!!!\n",
+				__func__, sat_val, hue_val);
+	}
+}
+/* saturation/hue adjust process end */
+
 /* 3d process begin */
 void amvecm_3d_black_process(void)
 {
diff --git a/drivers/amlogic/amvecm/amve.h b/drivers/amlogic/amvecm/amve.h
index 4842a87..b730ddf 100644
--- a/drivers/amlogic/amvecm/amve.h
+++ b/drivers/amlogic/amvecm/amve.h
@@ -52,6 +52,19 @@ struct ve_regs_s {
 	unsigned int mode:1;
 	unsigned int rsv:5;
 };
+enum vlock_param_e {
+	VLOCK_EN = 0x0,
+	VLOCK_ADAPT,
+	VLOCK_MODE,
+	VLOCK_DIS_CNT_LIMIT,
+	VLOCK_DELTA_LIMIT,
+	VLOCK_DEBUG,
+	VLOCK_DYNAMIC_ADJUST,
+	VLOCK_STATE,
+	VLOCK_SYNC_LIMIT_FLAG,
+	VLOCK_DIS_CNT_NO_VF_LIMIT,
+	VLOCK_PARAM_MAX,
+};
 
 extern struct ve_hist_s video_ve_hist;
 extern unsigned int ve_size;
@@ -65,6 +78,8 @@ extern struct tcon_gamma_table_s video_gamma_table_g_adj;
 extern struct tcon_gamma_table_s video_gamma_table_b_adj;
 extern struct tcon_rgb_ogo_s     video_rgb_ogo;
 
+extern spinlock_t vpp_lcd_gamma_lock;
+
 void ve_on_vs(struct vframe_s *vf);
 
 void ve_set_bext(struct ve_bext_s *p);
@@ -101,11 +116,17 @@ extern void ve_new_dnlp_param_update(void);
 extern void ve_ogo_param_update(void);
 extern void am_set_regmap(struct am_regs_s *p);
 extern void sharpness_process(struct vframe_s *vf);
-extern void amvecm_bricon_process(unsigned int bri_val,
-				unsigned int cont_val, struct vframe_s *vf);
+extern void amvecm_bricon_process(signed int bri_val,
+				signed int cont_val, struct vframe_s *vf);
+extern void amvecm_color_process(signed int sat_val,
+	signed int hue_val, struct vframe_s *vf);
 extern void amvecm_3d_black_process(void);
 extern void amvecm_3d_sync_process(void);
 extern void amve_vlock_process(struct vframe_s *vf);
+extern void amve_vlock_resume(void);
+extern void vlock_param_set(unsigned int val, enum vlock_param_e sel);
+extern void vlock_status(void);
+extern void vlock_reg_dump(void);
 
 int amvecm_hiu_reg_read(unsigned int reg, unsigned int *val);
 int amvecm_hiu_reg_write(unsigned int reg, unsigned int val);
@@ -117,6 +138,8 @@ extern unsigned int sync_3d_v_start;
 extern unsigned int sync_3d_v_end;
 extern unsigned int sync_3d_polarity;
 extern unsigned int sync_3d_out_inv;
+extern unsigned int sync_3d_black_color;
+extern unsigned int sync_3d_sync_to_vbo;
 
 extern void __iomem *amvecm_hiu_reg_base;
 
@@ -129,5 +152,12 @@ extern u32 VSYNC_RD_MPEG_REG(u32 adr);
 /* unsigned long long ve_get_vs_cnt(void); */
 /* #endif */
 
+#define VLOCK_STATE_NULL 0
+#define VLOCK_STATE_ENABLE_STEP1_DONE 1
+#define VLOCK_STATE_ENABLE_STEP2_DONE 2
+#define VLOCK_STATE_DISABLE_STEP1_DONE 3
+#define VLOCK_STATE_DISABLE_STEP2_DONE 4
+#define VLOCK_STATE_ENABLE_FORCE_RESET 5
+
 #endif
 
diff --git a/drivers/amlogic/amvecm/amvecm.c b/drivers/amlogic/amvecm/amvecm.c
index cdf3170..445aa45 100644
--- a/drivers/amlogic/amvecm/amvecm.c
+++ b/drivers/amlogic/amvecm/amvecm.c
@@ -26,9 +26,15 @@
 #include <linux/uaccess.h>
 /* #include <linux/amlogic/aml_common.h> */
 #include <linux/ctype.h>/* for parse_para_pq */
+#include <linux/vmalloc.h>
 #include <linux/amlogic/amports/vframe.h>
 #include <linux/amlogic/amvecm/amvecm.h>
 #include <linux/amlogic/vout/vout_notify.h>
+
+#ifdef CONFIG_AML_LCD
+#include <linux/amlogic/vout/lcd_notify.h>
+#endif
+
 #include "arch/vpp_regs.h"
 #include "arch/ve_regs.h"
 #include "arch/cm_regs.h"
@@ -62,6 +68,7 @@ struct amvecm_dev_s {
 
 static struct amvecm_dev_s amvecm_dev;
 
+spinlock_t vpp_lcd_gamma_lock;
 
 signed int vd1_brightness = 0, vd1_contrast;
 
@@ -69,12 +76,19 @@ static int hue_pre;  /*-25~25*/
 static int saturation_pre;  /*-128~127*/
 static int hue_post;  /*-25~25*/
 static int saturation_post;  /*-128~127*/
+
+static s16 saturation_ma;
+static s16 saturation_mb;
+static s16 saturation_ma_shift;
+static s16 saturation_mb_shift;
+
 unsigned int sr1_reg_val[101];
 unsigned int sr1_ret_val[101];
 struct vpp_hist_param_s vpp_hist_param;
 static unsigned int pre_hist_height, pre_hist_width;
 static unsigned int pc_mode = 0xff;
 static unsigned int pc_mode_last = 0xff;
+static struct hdr_metadata_info_s vpp_hdr_metadata_s;
 
 void __iomem *amvecm_hiu_reg_base;/* = *ioremap(0xc883c000, 0x2000); */
 
@@ -86,6 +100,10 @@ unsigned int vecm_latch_flag;
 module_param(vecm_latch_flag, uint, 0664);
 MODULE_PARM_DESC(vecm_latch_flag, "\n vecm_latch_flag\n");
 
+unsigned int vpp_demo_latch_flag;
+module_param(vpp_demo_latch_flag, uint, 0664);
+MODULE_PARM_DESC(vpp_demo_latch_flag, "\n vpp_demo_latch_flag\n");
+
 unsigned int pq_load_en = 1;/* load pq table enable/disable */
 module_param(pq_load_en, uint, 0664);
 MODULE_PARM_DESC(pq_load_en, "\n pq_load_en\n");
@@ -98,26 +116,6 @@ bool wb_en;  /* wb_en enable/disable */
 module_param(wb_en, bool, 0664);
 MODULE_PARM_DESC(wb_en, "\n wb_en\n");
 
-static int pq_on_off = 2; /* 1 :on    0 :off */
-module_param(pq_on_off, uint, 0664);
-MODULE_PARM_DESC(pq_on_off, "\n pq_on_off\n");
-
-static int cm_on_off = 2; /* 1 :on    0 :off */
-module_param(cm_on_off, uint, 0664);
-MODULE_PARM_DESC(cm_on_off, "\n cm_on_off\n");
-
-static int dnlp_on_off = 2; /* 1 :on    0 :off */
-module_param(dnlp_on_off, uint, 0664);
-MODULE_PARM_DESC(dnlp_on_off, "\n dnlp_on_off\n");
-
-static int sharpness_on_off = 2; /* 1 :on    0 :off */
-module_param(sharpness_on_off, uint, 0664);
-MODULE_PARM_DESC(sharpness_on_off, "\n sharpness_on_off\n");
-
-static int wb_on_off = 2; /* 1 :on    0 :off */
-module_param(wb_on_off, uint, 0664);
-MODULE_PARM_DESC(wb_on_off, "\n wb_on_off\n");
-
 unsigned int probe_ok;/* probe ok or not */
 module_param(probe_ok, uint, 0664);
 MODULE_PARM_DESC(probe_ok, "\n probe_ok\n");
@@ -126,22 +124,58 @@ static unsigned int sr1_index;/* for sr1 read */
 module_param(sr1_index, uint, 0664);
 MODULE_PARM_DESC(sr1_index, "\n sr1_index\n");
 
+
+/* vpp brightness/contrast/saturation/hue */
+static int __init amvecm_load_pq_val(char *str)
+{
+	int i = 0, err = 0;
+	char *tk = NULL, *tmp[4];
+	long val;
+
+	if (str == NULL) {
+		pr_err("[amvecm] pq val error !!!\n");
+		return 0;
+	}
+
+	for (tk = strsep(&str, ","); tk != NULL; tk = strsep(&str, ",")) {
+		tmp[i] = tk;
+		err = kstrtol(tmp[i], 10, &val);
+		if (err) {
+			pr_err("[amvecm] pq string error !!!\n");
+			break;
+		}
+		/* pr_err("[amvecm] pq[%d]: %d\n", i, (int)val[i]); */
+
+		/* only need to get sat/hue value,
+		brightness/contrast can be got from registers */
+		if (i == 2)
+			saturation_post = (int)val;
+		else if (i == 3)
+			hue_post = (int)val;
+		i++;
+	}
+
+	return 0;
+}
+__setup("pq=", amvecm_load_pq_val);
+
+
 static void amvecm_size_patch(void)
 {
 	unsigned int hs, he, vs, ve;
 	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB) {
-		hs = READ_VPP_REG_BITS(VPP_HSC_REGION12_STARTP, 16, 12);
-		he = READ_VPP_REG_BITS(VPP_HSC_REGION4_ENDP, 0, 12);
+		hs = READ_VPP_REG_BITS(VPP_HSC_REGION12_STARTP, 16, 13);
+		he = READ_VPP_REG_BITS(VPP_HSC_REGION4_ENDP, 0, 13);
 
-		vs = READ_VPP_REG_BITS(VPP_VSC_REGION12_STARTP, 16, 12);
-		ve = READ_VPP_REG_BITS(VPP_VSC_REGION4_ENDP, 0, 12);
+		vs = READ_VPP_REG_BITS(VPP_VSC_REGION12_STARTP, 16, 13);
+		ve = READ_VPP_REG_BITS(VPP_VSC_REGION4_ENDP, 0, 13);
 		ve_frame_size_patch(he-hs+1, ve-vs+1);
 	}
-	hs = READ_VPP_REG_BITS(VPP_POSTBLEND_VD1_H_START_END, 16, 12);
-	he = READ_VPP_REG_BITS(VPP_POSTBLEND_VD1_H_START_END, 0, 12);
+	hs = READ_VPP_REG_BITS(VPP_POSTBLEND_VD1_H_START_END, 16, 13);
+	he = READ_VPP_REG_BITS(VPP_POSTBLEND_VD1_H_START_END, 0, 13);
 
-	vs = READ_VPP_REG_BITS(VPP_POSTBLEND_VD1_V_START_END, 16, 12);
-	ve = READ_VPP_REG_BITS(VPP_POSTBLEND_VD1_V_START_END, 0, 12);
+	vs = READ_VPP_REG_BITS(VPP_POSTBLEND_VD1_V_START_END, 16, 13);
+	ve = READ_VPP_REG_BITS(VPP_POSTBLEND_VD1_V_START_END, 0, 13);
 	cm2_frame_size_patch(he-hs+1, ve-vs+1);
 }
 
@@ -149,11 +183,19 @@ static void amvecm_size_patch(void)
 static ssize_t video_adj1_brightness_show(struct class *cla,
 			struct class_attribute *attr, char *buf)
 {
-	s32 val = (READ_VPP_REG(VPP_VADJ1_Y) >> 8) & 0x1ff;
+	s32 val = 0;
 
-	val = (val << 23) >> 23;
+	if (get_cpu_type() <= MESON_CPU_MAJOR_ID_GXTVBB) {
+		val = (READ_VPP_REG(VPP_VADJ1_Y) >> 8) & 0x1ff;
+		val = (val << 23) >> 23;
+
+		return sprintf(buf, "%d\n", val);
+	} else {
+		val = (READ_VPP_REG(VPP_VADJ1_Y) >> 8) & 0x3ff;
+		val = (val << 23) >> 23;
 
-	return sprintf(buf, "%d\n", val);
+		return sprintf(buf, "%d\n", val >> 1);
+	}
 }
 
 static ssize_t video_adj1_brightness_store(struct class *cla,
@@ -167,8 +209,12 @@ static ssize_t video_adj1_brightness_store(struct class *cla,
 	if ((r != 1) || (val < -255) || (val > 255))
 		return -EINVAL;
 
-	WRITE_VPP_REG_BITS(VPP_VADJ1_Y, val, 8, 9);
-	WRITE_VPP_REG(VPP_VADJ_CTRL, VPP_VADJ1_EN);
+	if (get_cpu_type() <= MESON_CPU_MAJOR_ID_GXTVBB)
+		WRITE_VPP_REG_BITS(VPP_VADJ1_Y, val, 8, 9);
+	else
+		WRITE_VPP_REG_BITS(VPP_VADJ1_Y, val << 1, 8, 10);
+
+	WRITE_VPP_REG_BITS(VPP_VADJ_CTRL, 1, 0, 1);
 
 	return count;
 }
@@ -194,7 +240,7 @@ static ssize_t video_adj1_contrast_store(struct class *cla,
 	val += 0x80;
 
 	WRITE_VPP_REG_BITS(VPP_VADJ1_Y, val, 0, 8);
-	WRITE_VPP_REG(VPP_VADJ_CTRL, VPP_VADJ1_EN);
+	WRITE_VPP_REG_BITS(VPP_VADJ_CTRL, 1, 0, 1);
 
 	return count;
 }
@@ -203,11 +249,19 @@ static ssize_t video_adj1_contrast_store(struct class *cla,
 static ssize_t video_adj2_brightness_show(struct class *cla,
 			struct class_attribute *attr, char *buf)
 {
-	s32 val = (READ_VPP_REG(VPP_VADJ2_Y) >> 8) & 0x1ff;
+	s32 val = 0;
 
-	val = (val << 23) >> 23;
+	if (get_cpu_type() <= MESON_CPU_MAJOR_ID_GXTVBB) {
+		val = (READ_VPP_REG(VPP_VADJ2_Y) >> 8) & 0x1ff;
+		val = (val << 23) >> 23;
+
+		return sprintf(buf, "%d\n", val);
+	} else {
+		val = (READ_VPP_REG(VPP_VADJ2_Y) >> 8) & 0x3ff;
+		val = (val << 23) >> 23;
 
-	return sprintf(buf, "%d\n", val);
+		return sprintf(buf, "%d\n", val >> 1);
+	}
 }
 
 static ssize_t video_adj2_brightness_store(struct class *cla,
@@ -221,8 +275,12 @@ static ssize_t video_adj2_brightness_store(struct class *cla,
 	if ((r != 1) || (val < -255) || (val > 255))
 		return -EINVAL;
 
-	WRITE_VPP_REG_BITS(VPP_VADJ2_Y, val, 8, 9);
-	WRITE_VPP_REG(VPP_VADJ_CTRL, VPP_VADJ2_EN);
+	if (get_cpu_type() <= MESON_CPU_MAJOR_ID_GXTVBB)
+		WRITE_VPP_REG_BITS(VPP_VADJ2_Y, val, 8, 9);
+	else
+		WRITE_VPP_REG_BITS(VPP_VADJ2_Y, val << 1, 8, 10);
+
+	WRITE_VPP_REG_BITS(VPP_VADJ_CTRL, 1, 2, 1);
 
 	return count;
 }
@@ -248,7 +306,7 @@ static ssize_t video_adj2_contrast_store(struct class *cla,
 	val += 0x80;
 
 	WRITE_VPP_REG_BITS(VPP_VADJ2_Y, val, 0, 8);
-	WRITE_VPP_REG(VPP_VADJ_CTRL, VPP_VADJ2_EN);
+	WRITE_VPP_REG_BITS(VPP_VADJ_CTRL, 1, 2, 1);
 
 	return count;
 }
@@ -276,10 +334,13 @@ static void parse_param_amvecm(char *buf_orig, char **parm)
 {
 	char *ps, *token;
 	unsigned int n = 0;
+	char delim1[3] = " ";
+	char delim2[2] = "\n";
 
 	ps = buf_orig;
+	strcat(delim1, delim2);
 	while (1) {
-		token = strsep(&ps, " \n");
+		token = strsep(&ps, delim1);
 		if (token == NULL)
 			break;
 		if (*token == '\0')
@@ -287,20 +348,15 @@ static void parse_param_amvecm(char *buf_orig, char **parm)
 		parm[n++] = token;
 	}
 }
-static ssize_t amvecm_3d_sync_show(struct class *cla,
-		struct class_attribute *attr, char *buf)
+static void amvecm_3d_sync_status(void)
 {
-	ssize_t len = 0;
 	unsigned int sync_h_start, sync_h_end, sync_v_start,
 		sync_v_end, sync_polarity,
 		sync_out_inv, sync_en;
-
-	if (!is_meson_g9tv_cpu()) {
-		len += sprintf(buf+len,
-				"\n chip does not support 3D sync process!!!\n");
-		return len;
+	if (!is_meson_g9tv_cpu() && !is_meson_gxtvbb_cpu()) {
+		pr_info("\n chip does not support 3D sync process!!!\n");
+		return;
 	}
-
 	sync_h_start = READ_VPP_REG_BITS(VPU_VPU_3D_SYNC2, 0, 13);
 	sync_h_end = READ_VPP_REG_BITS(VPU_VPU_3D_SYNC2, 16, 13);
 	sync_v_start = READ_VPP_REG_BITS(VPU_VPU_3D_SYNC1, 0, 13);
@@ -308,26 +364,44 @@ static ssize_t amvecm_3d_sync_show(struct class *cla,
 	sync_polarity = READ_VPP_REG_BITS(VPU_VPU_3D_SYNC1, 29, 1);
 	sync_out_inv = READ_VPP_REG_BITS(VPU_VPU_3D_SYNC1, 15, 1);
 	sync_en = READ_VPP_REG_BITS(VPU_VPU_3D_SYNC1, 31, 1);
-	len += sprintf(buf+len, "\n current 3d sync state:\n");
-	len += sprintf(buf+len, "sync_h_start:%d\n", sync_h_start);
-	len += sprintf(buf+len, "sync_h_end:%d\n", sync_h_end);
-	len += sprintf(buf+len, "sync_v_start:%d\n", sync_v_start);
-	len += sprintf(buf+len, "sync_v_end:%d\n", sync_v_end);
-	len += sprintf(buf+len, "sync_polarity:%d\n", sync_polarity);
-	len += sprintf(buf+len, "sync_out_inv:%d\n", sync_out_inv);
-	len += sprintf(buf+len, "sync_en:%d\n", sync_en);
+	pr_info("\n current 3d sync state:\n");
+	pr_info("sync_h_start:%d\n", sync_h_start);
+	pr_info("sync_h_end:%d\n", sync_h_end);
+	pr_info("sync_v_start:%d\n", sync_v_start);
+	pr_info("sync_v_end:%d\n", sync_v_end);
+	pr_info("sync_polarity:%d\n", sync_polarity);
+	pr_info("sync_out_inv:%d\n", sync_out_inv);
+	pr_info("sync_en:%d\n", sync_en);
+	pr_info("sync_3d_black_color:%d\n", sync_3d_black_color);
+	pr_info("sync_3d_sync_to_vbo:%d\n", sync_3d_sync_to_vbo);
+}
+static ssize_t amvecm_3d_sync_show(struct class *cla,
+		struct class_attribute *attr, char *buf)
+{
+	ssize_t len = 0;
+
+	len += sprintf(buf+len,
+		"echo hstart val(D) > /sys/class/amvecm/sync_3d\n");
+	len += sprintf(buf+len,
+		"echo hend val(D) > /sys/class/amvecm/sync_3d\n");
 	len += sprintf(buf+len,
-			"echo hstart val(D) > /sys/class/amvecm/sync_3d\n");
+		"echo vstart val(D) > /sys/class/amvecm/sync_3d\n");
 	len += sprintf(buf+len,
-			"echo hend val(D) > /sys/class/amvecm/sync_3d\n");
+		"echo vend val(D) > /sys/class/amvecm/sync_3d\n");
 	len += sprintf(buf+len,
-			"echo vstart val(D) > /sys/class/amvecm/sync_3d\n");
+		"echo pola val(D) > /sys/class/amvecm/sync_3d\n");
 	len += sprintf(buf+len,
-			"echo vend val(D) > /sys/class/amvecm/sync_3d\n");
+		"echo inv val(D) > /sys/class/amvecm/sync_3d\n");
 	len += sprintf(buf+len,
-			"echo pola val(D) > /sys/class/amvecm/sync_3d\n");
+		"echo black_color val(Hex) > /sys/class/amvecm/sync_3d\n");
 	len += sprintf(buf+len,
-			"echo inv val(D) > /sys/class/amvecm/sync_3d\n");
+		"echo sync_to_vx1 val(D) > /sys/class/amvecm/sync_3d\n");
+	len += sprintf(buf+len,
+		"echo enable > /sys/class/amvecm/sync_3d\n");
+	len += sprintf(buf+len,
+		"echo disable > /sys/class/amvecm/sync_3d\n");
+	len += sprintf(buf+len,
+		"echo status > /sys/class/amvecm/sync_3d\n");
 	return len;
 }
 
@@ -341,7 +415,7 @@ static ssize_t amvecm_3d_sync_store(struct class *cla,
 	if (!buf)
 		return count;
 
-	if (!is_meson_g9tv_cpu()) {
+	if (!is_meson_g9tv_cpu() && !is_meson_gxtvbb_cpu()) {
 		pr_info("\n chip does not support 3D sync process!!!\n");
 		return count;
 	}
@@ -378,171 +452,137 @@ static ssize_t amvecm_3d_sync_store(struct class *cla,
 			return -EINVAL;
 		sync_3d_out_inv = val&0x1;
 		WRITE_VPP_REG_BITS(VPU_VPU_3D_SYNC1, sync_3d_out_inv, 15, 1);
+	} else if (!strncmp(parm[0], "black_color", 11)) {
+		if (kstrtol(parm[1], 16, &val) < 0)
+			return -EINVAL;
+		sync_3d_black_color = val&0xffffff;
+		WRITE_VPP_REG_BITS(VPP_BLEND_ONECOLOR_CTRL,
+			sync_3d_black_color, 0, 24);
+	} else if (!strncmp(parm[0], "sync_to_vx1", 11)) {
+		if (kstrtol(parm[1], 10, &val) < 0)
+			return -EINVAL;
+		sync_3d_sync_to_vbo = val&0x1;
+	} else if (!strncmp(parm[0], "enable", 6)) {
+		vecm_latch_flag |= FLAG_3D_SYNC_EN;
+	} else if (!strncmp(parm[0], "disable", 7)) {
+		vecm_latch_flag |= FLAG_3D_SYNC_DIS;
+	} else if (!strncmp(parm[0], "status", 7)) {
+		amvecm_3d_sync_status();
 	}
 	kfree(buf_orig);
 	return count;
 }
 
-/* #endif */
-
-void pq_enable_disable(void)
+static ssize_t amvecm_vlock_show(struct class *cla,
+		struct class_attribute *attr, char *buf)
 {
-	int reg_val;
-	if (pq_on_off == 1) {
-		pq_on_off = 2;
-		/* open dnlp clock gate */
-		WRITE_VPP_REG_BITS(VPP_GCLK_CTRL1, 0, 0, 2);
-		dnlp_en = 1;
-		ve_enable_dnlp();
-		/* open cm clock gate */
-		WRITE_VPP_REG_BITS(VPP_GCLK_CTRL0, 0, 4, 2);
-		cm_en = 1;
-		amcm_enable();
-		if (is_meson_gxtvbb_cpu()) {
-			/* open sharpness clock gate */
-			/*WRITE_VPP_REG_BITS(VPP_GCLK_CTRL0, 0, 30, 2);*/
-			/* sharpness on */
-			WRITE_VPP_REG_BITS(
-				SRSHARP0_SHARP_PK_NR_ENABLE,
-				1, 1, 1);
-			WRITE_VPP_REG_BITS(
-				SRSHARP1_SHARP_PK_NR_ENABLE,
-				1, 1, 1);
-			reg_val = READ_VPP_REG(SRSHARP0_HCTI_FLT_CLP_DC);
-			WRITE_VPP_REG(SRSHARP0_HCTI_FLT_CLP_DC,
-					reg_val | 0x10000000);
-			WRITE_VPP_REG(SRSHARP1_HCTI_FLT_CLP_DC,
-					reg_val | 0x10000000);
-
-			reg_val = READ_VPP_REG(SRSHARP0_HLTI_FLT_CLP_DC);
-			WRITE_VPP_REG(SRSHARP0_HLTI_FLT_CLP_DC,
-					reg_val | 0x10000000);
-			WRITE_VPP_REG(SRSHARP1_HLTI_FLT_CLP_DC,
-					reg_val | 0x10000000);
-
-			reg_val = READ_VPP_REG(SRSHARP0_VLTI_FLT_CON_CLP);
-			WRITE_VPP_REG(SRSHARP0_VLTI_FLT_CON_CLP,
-					reg_val | 0x4000);
-			WRITE_VPP_REG(SRSHARP1_VLTI_FLT_CON_CLP,
-					reg_val | 0x4000);
-
-			reg_val = READ_VPP_REG(SRSHARP0_VCTI_FLT_CON_CLP);
-			WRITE_VPP_REG(SRSHARP0_VCTI_FLT_CON_CLP,
-					reg_val | 0x4000);
-			WRITE_VPP_REG(SRSHARP1_VCTI_FLT_CON_CLP,
-					reg_val | 0x4000);
-			/* wb on */
-			wb_en = 1;
-			WRITE_VPP_REG_BITS(VPP_GAINOFF_CTRL0, 1, 31, 1);
-			/* gamma on */
-			vecm_latch_flag |= FLAG_GAMMA_TABLE_EN;
-		}
-/* #endif */
-	} else if (pq_on_off == 0) {
-		pq_on_off = 2;
-
-		dnlp_en = 0;
-		ve_disable_dnlp();
-		WRITE_VPP_REG_BITS(VPP_GCLK_CTRL1, 1, 0, 2);
-		cm_en = 0;
-		amcm_disable();
-		WRITE_VPP_REG_BITS(VPP_GCLK_CTRL0, 1, 4, 2);
-		if (is_meson_gxtvbb_cpu()) {
-			WRITE_VPP_REG_BITS(
-				SRSHARP0_SHARP_PK_NR_ENABLE,
-				0, 1, 1);
-			WRITE_VPP_REG_BITS(
-				SRSHARP1_SHARP_PK_NR_ENABLE,
-				0, 1, 1);
-			reg_val = READ_VPP_REG(SRSHARP0_HCTI_FLT_CLP_DC);
-			WRITE_VPP_REG(SRSHARP0_HCTI_FLT_CLP_DC,
-					reg_val & 0xefffffff);
-			WRITE_VPP_REG(SRSHARP1_HCTI_FLT_CLP_DC,
-					reg_val & 0xefffffff);
-
-			reg_val = READ_VPP_REG(SRSHARP0_HLTI_FLT_CLP_DC);
-			WRITE_VPP_REG(SRSHARP0_HLTI_FLT_CLP_DC,
-					reg_val & 0xefffffff);
-			WRITE_VPP_REG(SRSHARP1_HLTI_FLT_CLP_DC,
-					reg_val & 0xefffffff);
-
-			reg_val = READ_VPP_REG(SRSHARP0_VLTI_FLT_CON_CLP);
-			WRITE_VPP_REG(SRSHARP0_VLTI_FLT_CON_CLP,
-					reg_val & 0xffffbfff);
-			WRITE_VPP_REG(SRSHARP1_VLTI_FLT_CON_CLP,
-					reg_val & 0xffffbfff);
-
-			reg_val = READ_VPP_REG(SRSHARP0_VCTI_FLT_CON_CLP);
-			WRITE_VPP_REG(SRSHARP0_VCTI_FLT_CON_CLP,
-					reg_val & 0xffffbfff);
-			WRITE_VPP_REG(SRSHARP1_VCTI_FLT_CON_CLP,
-					reg_val & 0xffffbfff);
-			wb_en = 0;
-			WRITE_VPP_REG_BITS(VPP_GAINOFF_CTRL0, 0, 31, 1);
-			vecm_latch_flag |= FLAG_GAMMA_TABLE_DIS;
-		}
-/* #endif */
-	}
+	ssize_t len = 0;
+	len += sprintf(buf+len,
+		"echo vlock_mode val(0/1/2) > /sys/class/amvecm/vlock\n");
+	len += sprintf(buf+len,
+		"echo vlock_en val(0/1) > /sys/class/amvecm/vlock\n");
+	len += sprintf(buf+len,
+		"echo vlock_adapt val(0/1) > /sys/class/amvecm/vlock\n");
+	len += sprintf(buf+len,
+		"echo vlock_dis_cnt_limit val(D) > /sys/class/amvecm/vlock\n");
+	len += sprintf(buf+len,
+		"echo vlock_delta_limit val(D) > /sys/class/amvecm/vlock\n");
+	len += sprintf(buf+len,
+		"echo vlock_debug val(0x111) > /sys/class/amvecm/vlock\n");
+	len += sprintf(buf+len,
+		"echo vlock_dynamic_adjust val(0/1) > /sys/class/amvecm/vlock\n");
+	len += sprintf(buf+len,
+		"echo vlock_dis_cnt_no_vf_limit val(D) > /sys/class/amvecm/vlock\n");
+	len += sprintf(buf+len,
+		"echo enable > /sys/class/amvecm/vlock\n");
+	len += sprintf(buf+len,
+		"echo disable > /sys/class/amvecm/vlock\n");
+	len += sprintf(buf+len,
+		"echo status > /sys/class/amvecm/vlock\n");
+	len += sprintf(buf+len,
+		"echo dump_reg > /sys/class/amvecm/vlock\n");
+	return len;
+}
 
-	if (cm_on_off == 1) {
-		cm_on_off = 2;
-		WRITE_VPP_REG_BITS(VPP_GCLK_CTRL0, 0, 4, 2);
-		cm_en = 1;
-		amcm_enable();
-	} else if (cm_on_off == 0) {
-		cm_on_off = 2;
-		cm_en = 0;
-		amcm_disable();
-		WRITE_VPP_REG_BITS(VPP_GCLK_CTRL0, 1, 4, 2);
-	}
+static ssize_t amvecm_vlock_store(struct class *cla,
+		struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	char *buf_orig, *parm[8] = {NULL};
+	long val;
+	unsigned int temp_val;
+	enum vlock_param_e sel = VLOCK_PARAM_MAX;
 
-	if (dnlp_on_off == 1) {
-		dnlp_on_off = 2;
-		WRITE_VPP_REG_BITS(VPP_GCLK_CTRL1, 0, 0, 2);
-		dnlp_en = 1;
-		ve_enable_dnlp();
-	} else if (dnlp_on_off == 0) {
-		dnlp_on_off = 2;
-		dnlp_en = 0;
-		ve_disable_dnlp();
-		WRITE_VPP_REG_BITS(VPP_GCLK_CTRL1, 1, 0, 2);
+	if (!buf)
+		return count;
+	if (!is_meson_g9tv_cpu() && !is_meson_gxtvbb_cpu() &&
+		!is_meson_gxbb_cpu() &&
+		(get_cpu_type() < MESON_CPU_MAJOR_ID_GXL)) {
+		pr_info("\n chip does not support vlock process!!!\n");
+		return count;
 	}
 
-/* #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESONG9TV) */
-	if (is_meson_gxtvbb_cpu()) {
-		if (sharpness_on_off == 1) {
-			sharpness_on_off = 2;
-			WRITE_VPP_REG_BITS(
-				SRSHARP0_SHARP_PK_NR_ENABLE,
-				1, 1, 1);
-			WRITE_VPP_REG_BITS(
-				SRSHARP1_SHARP_PK_NR_ENABLE,
-				1, 1, 1);
-		} else if (sharpness_on_off == 0) {
-			sharpness_on_off = 2;
-			WRITE_VPP_REG_BITS(
-				SRSHARP0_SHARP_PK_NR_ENABLE,
-				0, 1, 1);
-			WRITE_VPP_REG_BITS(
-				SRSHARP1_SHARP_PK_NR_ENABLE,
-				0, 1, 1);
-		}
-
-		if (wb_on_off == 1) {
-			wb_on_off = 2;
-			wb_en = 1;
-			WRITE_VPP_REG_BITS(VPP_GAINOFF_CTRL0, 1, 31, 1);
-		} else if (wb_on_off == 0) {
-			wb_on_off = 2;
-			wb_en = 0;
-			WRITE_VPP_REG_BITS(VPP_GAINOFF_CTRL0, 0, 31, 1);
-		}
+	buf_orig = kstrdup(buf, GFP_KERNEL);
+	parse_param_amvecm(buf_orig, (char **)&parm);
+	if (!strncmp(parm[0], "vlock_mode", 10)) {
+		if (kstrtol(parm[1], 10, &val) < 0)
+			return -EINVAL;
+		temp_val = val;
+		sel = VLOCK_MODE;
+	} else if (!strncmp(parm[0], "vlock_en", 8)) {
+		if (kstrtol(parm[1], 10, &val) < 0)
+			return -EINVAL;
+		temp_val = val;
+		sel = VLOCK_EN;
+	} else if (!strncmp(parm[0], "vlock_adapt", 11)) {
+		if (kstrtol(parm[1], 10, &val) < 0)
+			return -EINVAL;
+		temp_val = val;
+		sel = VLOCK_ADAPT;
+	} else if (!strncmp(parm[0], "vlock_dis_cnt_limit", 19)) {
+		if (kstrtol(parm[1], 10, &val) < 0)
+			return -EINVAL;
+		temp_val = val;
+		sel = VLOCK_DIS_CNT_LIMIT;
+	} else if (!strncmp(parm[0], "vlock_delta_limit", 17)) {
+		if (kstrtol(parm[1], 10, &val) < 0)
+			return -EINVAL;
+		temp_val = val;
+		sel = VLOCK_DELTA_LIMIT;
+	} else if (!strncmp(parm[0], "vlock_debug", 11)) {
+		if (kstrtol(parm[1], 16, &val) < 0)
+			return -EINVAL;
+		temp_val = val;
+		sel = VLOCK_DEBUG;
+	} else if (!strncmp(parm[0], "vlock_dynamic_adjust", 20)) {
+		if (kstrtol(parm[1], 10, &val) < 0)
+			return -EINVAL;
+		temp_val = val;
+		sel = VLOCK_DYNAMIC_ADJUST;
+	} else if (!strncmp(parm[0], "vlock_dis_cnt_no_vf_limit", 25)) {
+		if (kstrtol(parm[1], 10, &val) < 0)
+			return -EINVAL;
+		temp_val = val;
+		sel = VLOCK_DIS_CNT_NO_VF_LIMIT;
+	} else if (!strncmp(parm[0], "enable", 6)) {
+		vecm_latch_flag |= FLAG_VLOCK_EN;
+	} else if (!strncmp(parm[0], "disable", 7)) {
+		vecm_latch_flag |= FLAG_VLOCK_DIS;
+	} else if (!strncmp(parm[0], "status", 6)) {
+		vlock_status();
+	} else if (!strncmp(parm[0], "dump_reg", 8)) {
+		vlock_reg_dump();
+	} else {
+		pr_info("unsupport cmd!!\n");
 	}
+	if (sel < VLOCK_PARAM_MAX)
+		vlock_param_set(temp_val, sel);
+	kfree(buf_orig);
+	return count;
+}
 
 /* #endif */
 
-}
-
 static void vpp_backup_histgram(struct vframe_s *vf)
 {
 	unsigned int i = 0;
@@ -736,6 +776,65 @@ void vpp_get_vframe_hist_info(struct vframe_s *vf)
 			VI_HIST_ON_BIN_63_BIT, VI_HIST_ON_BIN_63_WID);
 }
 
+static void ioctrl_get_hdr_metadata(struct vframe_s *vf)
+{
+	if (((vf->signal_type >> 16) & 0xff) == 9) {
+		if (vf->prop.master_display_colour.present_flag) {
+
+			memcpy(vpp_hdr_metadata_s.primaries,
+				vf->prop.master_display_colour.primaries,
+				sizeof(u32)*6);
+			memcpy(vpp_hdr_metadata_s.white_point,
+				vf->prop.master_display_colour.white_point,
+				sizeof(u32)*2);
+			vpp_hdr_metadata_s.luminance[0] =
+				vf->prop.master_display_colour.luminance[0];
+			vpp_hdr_metadata_s.luminance[1] =
+				vf->prop.master_display_colour.luminance[1];
+		} else
+			memset(vpp_hdr_metadata_s.primaries, 0,
+					10 * sizeof(unsigned int));
+	} else
+		memset(vpp_hdr_metadata_s.primaries, 0,
+				10 * sizeof(unsigned int));
+}
+
+void vpp_demo_config(struct vframe_s *vf)
+{
+	unsigned int reg_value;
+	/*dnlp demo config*/
+	if (vpp_demo_latch_flag & VPP_DEMO_DNLP_EN) {
+		WRITE_VPP_REG_BITS(VPP_VE_ENABLE_CTRL, 1, 18, 1);
+		/*bit14-15   left: 2   right: 3*/
+		WRITE_VPP_REG_BITS(VPP_VE_ENABLE_CTRL, 2, 14, 2);
+		reg_value = READ_VPP_REG_BITS(VPP_SRSHARP1_CTRL, 0, 1);
+		if (((vf->height > 1080) && (vf->width > 1920)) ||
+			(reg_value == 0))
+			WRITE_VPP_REG_BITS(VPP_VE_DEMO_LEFT_TOP_SCREEN_WIDTH,
+				1920, 0, 12);
+		else
+			WRITE_VPP_REG_BITS(VPP_VE_DEMO_LEFT_TOP_SCREEN_WIDTH,
+				960, 0, 12);
+		vpp_demo_latch_flag &= ~VPP_DEMO_DNLP_EN;
+	} else if (vpp_demo_latch_flag & VPP_DEMO_DNLP_DIS) {
+		WRITE_VPP_REG_BITS(VPP_VE_ENABLE_CTRL, 0, 18, 1);
+		WRITE_VPP_REG_BITS(VPP_VE_ENABLE_CTRL, 0, 14, 2);
+		WRITE_VPP_REG_BITS(VPP_VE_DEMO_LEFT_TOP_SCREEN_WIDTH,
+				0xfff, 0, 12);
+		vpp_demo_latch_flag &= ~VPP_DEMO_DNLP_DIS;
+	}
+	/*cm demo config*/
+	if (vpp_demo_latch_flag & VPP_DEMO_CM_EN) {
+		/*left: 0x1   right: 0x4*/
+		WRITE_VPP_REG(VPP_CHROMA_ADDR_PORT, 0x20f);
+		WRITE_VPP_REG(VPP_CHROMA_DATA_PORT, 0x1);
+		vpp_demo_latch_flag &= ~VPP_DEMO_CM_EN;
+	} else if (vpp_demo_latch_flag & VPP_DEMO_CM_DIS) {
+		WRITE_VPP_REG(VPP_CHROMA_ADDR_PORT, 0x20f);
+		WRITE_VPP_REG(VPP_CHROMA_DATA_PORT, 0x0);
+		vpp_demo_latch_flag &= ~VPP_DEMO_CM_DIS;
+	}
+}
 
 void amvecm_video_latch(void)
 {
@@ -755,7 +854,8 @@ void amvecm_video_latch(void)
 
 void amvecm_on_vs(struct vframe_s *vf)
 {
-	if (probe_ok == 0)
+	if ((probe_ok == 0) ||
+	(is_meson_gxm_cpu() && is_dolby_vision_on()))
 		return;
 
 	if (vf != NULL) {
@@ -765,19 +865,33 @@ void amvecm_on_vs(struct vframe_s *vf)
 		amvecm_bricon_process(
 			vd1_brightness,
 			vd1_contrast + vd1_contrast_offset, vf);
+
+		ioctrl_get_hdr_metadata(vf);
+		amvecm_color_process(
+			saturation_pre + saturation_offset,
+			hue_pre, vf);
+
+		vpp_demo_config(vf);
 	} else
 		amvecm_matrix_process(NULL);
+	/* vlock processs */
+	if ((is_meson_g9tv_cpu() || (get_cpu_type() >=
+		MESON_CPU_MAJOR_ID_GXBB)) && (vf != NULL))
+		amve_vlock_process(vf);
+	else if ((is_meson_g9tv_cpu() || (get_cpu_type() >=
+		MESON_CPU_MAJOR_ID_GXBB)) && (vf == NULL))
+		amve_vlock_resume();
 
 	/* pq latch process */
 	amvecm_video_latch();
-
-	pq_enable_disable();
 }
 EXPORT_SYMBOL(amvecm_on_vs);
 
 
 void refresh_on_vs(struct vframe_s *vf)
 {
+	if (is_meson_gxm_cpu() && is_dolby_vision_on())
+		return;
 	if (vf != NULL) {
 		vpp_get_vframe_hist_info(vf);
 		ve_on_vs(vf);
@@ -878,6 +992,12 @@ static long amvecm_ioctl(struct file *file,
 					sizeof(struct vpp_hist_param_s)))
 			ret = -EFAULT;
 		break;
+	case AMVECM_IOC_G_HDR_METADATA:
+		argp = (void __user *)arg;
+		if (copy_to_user(argp, &vpp_hdr_metadata_s,
+					sizeof(struct hdr_metadata_info_s)))
+			ret = -EFAULT;
+		break;
 	/**********************************************************************
 	gamma ioctl
 	**********************************************************************/
@@ -946,6 +1066,20 @@ static long amvecm_ioctl(struct file *file,
 			ret = -EFAULT;
 
 		break;
+	/*VLOCK*/
+	case AMVECM_IOC_VLOCK_EN:
+		vecm_latch_flag |= FLAG_VLOCK_EN;
+		break;
+	case AMVECM_IOC_VLOCK_DIS:
+		vecm_latch_flag |= FLAG_VLOCK_DIS;
+		break;
+	/*3D-SYNC*/
+	case AMVECM_IOC_3D_SYNC_EN:
+		vecm_latch_flag |= FLAG_3D_SYNC_EN;
+		break;
+	case AMVECM_IOC_3D_SYNC_DIS:
+		vecm_latch_flag |= FLAG_3D_SYNC_DIS;
+		break;
 	default:
 		ret = -EINVAL;
 		break;
@@ -1059,11 +1193,20 @@ static ssize_t amvecm_saturation_hue_store(struct class *cla,
 	size_t r;
 	s32 mab = 0;
 	s16 mc = 0, md = 0;
+	s16 ma, mb;
 
 	r = sscanf(buf, "0x%x", &mab);
 	if ((r != 1) || (mab&0xfc00fc00))
 		return -EINVAL;
+	ma = (s16)((mab << 6) >> 22);
+	mb = (s16)((mab << 22) >> 22);
+
+	saturation_ma = ma - 0x100;
+	saturation_mb = mb;
 
+	ma += saturation_ma_shift;
+	mb += saturation_mb_shift;
+	mab =  ((ma & 0x3ff) << 16) | (mb & 0x3ff);
 	WRITE_VPP_REG(VPP_VADJ1_MA_MB, mab);
 	mc = (s16)((mab<<22)>>22); /* mc = -mb */
 	mc = 0 - mc;
@@ -1086,7 +1229,6 @@ static int parse_para_pq(const char *para, int para_num, int *result)
 	int *out = result;
 	int len = 0, count = 0;
 	int res = 0;
-	int ret = 0;
 
 	if (!para)
 		return 0;
@@ -1104,8 +1246,7 @@ static int parse_para_pq(const char *para, int para_num, int *result)
 		}
 		if (len == 0)
 			break;
-		ret = kstrtoint(token, 0, &res);
-		if (ret < 0)
+		if (!token || kstrtoint(token, 0, &res) < 0)
 			break;
 		len = strlen(token);
 		*out++ = res;
@@ -1116,17 +1257,9 @@ static int parse_para_pq(const char *para, int para_num, int *result)
 	return count;
 }
 
-
-static ssize_t amvecm_saturation_hue_pre_show(struct class *cla,
-		struct class_attribute *attr, char *buf)
+void vpp_vd_adj1_saturation_hue(signed int sat_val,
+	signed int hue_val, struct vframe_s *vf)
 {
-	return snprintf(buf, 20, "%d %d\n", saturation_pre, hue_pre);
-}
-
-static ssize_t amvecm_saturation_hue_pre_store(struct class *cla,
-		struct class_attribute *attr, const char *buf, size_t count)
-{
-	int parsed[2];
 	int i, ma, mb, mab, mc, md;
 	int hue_cos[] = {
 			/*0~12*/
@@ -1145,18 +1278,15 @@ static ssize_t amvecm_saturation_hue_pre_store(struct class *cla,
 		68,  74,   80,   86,   92,	98,  104,  109,  115,  121,
 		126,  132, 137, 142, 147 /*13~25*/
 	};
-	if (likely(parse_para_pq(buf, 2, parsed) != 2))
-		return -EINVAL;
 
-	if ((parsed[0] < -128) || (parsed[0] > 128) ||
-		(parsed[1] < -25) || (parsed[1] > 25)) {
-		return -EINVAL;
-	}
-	saturation_pre = parsed[0];
-	hue_pre = parsed[1];
-	i = (hue_pre > 0) ? hue_pre : -hue_pre;
-	ma = (hue_cos[i]*(saturation_pre + 128)) >> 7;
-	mb = (hue_sin[25+hue_pre]*(saturation_pre + 128)) >> 7;
+	i = (hue_val > 0) ? hue_val : -hue_val;
+	ma = (hue_cos[i]*(sat_val + 128)) >> 7;
+	mb = (hue_sin[25+hue_val]*(sat_val + 128)) >> 7;
+	saturation_ma_shift = ma - 0x100;
+	saturation_mb_shift = mb;
+
+	ma += saturation_ma;
+	mb += saturation_mb;
 	if (ma > 511)
 		ma = 511;
 	if (ma < -512)
@@ -1167,8 +1297,8 @@ static ssize_t amvecm_saturation_hue_pre_store(struct class *cla,
 		mb = -512;
 	mab =  ((ma & 0x3ff) << 16) | (mb & 0x3ff);
 	pr_info("\n[amvideo..] saturation_pre:%d hue_pre:%d mab:%x\n",
-			saturation_pre, hue_pre, mab);
-	WRITE_VPP_REG(VPP_VADJ2_MA_MB, mab);
+			sat_val, hue_val, mab);
+	WRITE_VPP_REG(VPP_VADJ1_MA_MB, mab);
 	mc = (s16)((mab<<22)>>22); /* mc = -mb */
 	mc = 0 - mc;
 	if (mc > 511)
@@ -1179,6 +1309,29 @@ static ssize_t amvecm_saturation_hue_pre_store(struct class *cla,
 	mab = ((mc&0x3ff)<<16)|(md&0x3ff);
 	WRITE_VPP_REG(VPP_VADJ1_MC_MD, mab);
 	WRITE_VPP_REG_BITS(VPP_VADJ_CTRL, 1, 0, 1);
+};
+
+static ssize_t amvecm_saturation_hue_pre_show(struct class *cla,
+		struct class_attribute *attr, char *buf)
+{
+	return snprintf(buf, 20, "%d %d\n", saturation_pre, hue_pre);
+}
+
+static ssize_t amvecm_saturation_hue_pre_store(struct class *cla,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	int parsed[2];
+	if (likely(parse_para_pq(buf, 2, parsed) != 2))
+		return -EINVAL;
+
+	if ((parsed[0] < -128) || (parsed[0] > 128) ||
+		(parsed[1] < -25) || (parsed[1] > 25)) {
+		return -EINVAL;
+	}
+	saturation_pre = parsed[0];
+	hue_pre = parsed[1];
+	vecm_latch_flag |= FLAG_VADJ1_COLOR;
+
 	return count;
 }
 
@@ -1269,11 +1422,14 @@ static ssize_t amvecm_cm2_store(struct class *cls,
 	unsigned int addr_port = VPP_CHROMA_ADDR_PORT;/* 0x1d70; */
 	unsigned int data_port = VPP_CHROMA_DATA_PORT;/* 0x1d71; */
 	long val;
+	char delim1[3] = " ";
+	char delim2[2] = "\n";
 
 	buf_orig = kstrdup(buffer, GFP_KERNEL);
 	ps = buf_orig;
+	strcat(delim1, delim2);
 	while (1) {
-		token = strsep(&ps, " \n");
+		token = strsep(&ps, delim1);
 		if (token == NULL)
 			break;
 		if (*token == '\0')
@@ -1360,187 +1516,6 @@ static ssize_t amvecm_cm2_store(struct class *cls,
 	return count;
 }
 
-static ssize_t amvecm_pq_en_show(struct class *cla,
-			struct class_attribute *attr, char *buf)
-{
-	int len = 0;
-/* #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESONG9TV) */
-	int sharpness_en_val = 0, gamma_en_val = 0;
-	sharpness_en_val = READ_VPP_REG_BITS(VPP_VE_ENABLE_CTRL, 1, 1);
-	gamma_en_val = READ_VPP_REG_BITS(L_GAMMA_CNTL_PORT, GAMMA_EN, 1);
-/* #endif */
-	len += sprintf(buf+len, "dnlp_en = %d\n", dnlp_en);
-	len += sprintf(buf+len, "cm_en = %d\n", cm_en);
-	len += sprintf(buf+len, "wb_en = %d\n", wb_en);
-/* #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESONG9TV) */
-	if (is_meson_gxtvbb_cpu()) {
-		len += sprintf(buf+len,
-				"sharpness_en = %d\n", sharpness_en_val);
-		len += sprintf(buf+len,
-				"gamma_en = %d\n", gamma_en_val);
-	}
-/* #endif */
-	return len;
-}
-
-static ssize_t amvecm_pq_en_store(struct class *cla,
-			struct class_attribute *attr,
-			const char *buf, size_t count)
-{
-	size_t r;
-	int val;
-	r = sscanf(buf, "%d", &val);
-	if ((r != 1) || ((val != 1) && (val != 0)))
-		return -EINVAL;
-
-	if (val == 1) {
-		pq_on_off = 1;
-		pr_amvecm_dbg("dnlp_en = 1 [0x1da1][bit2] = 1\n");
-		pr_amvecm_dbg("cm_en = 1  [0x1d26][bit28] = 1\n");
-		pr_amvecm_dbg("sharpness0_en = 1 [0x3227][bit1] = 1\n");
-		pr_amvecm_dbg("sharpness1_en = 1 [0x32a7][bit1] = 1\n");
-		pr_amvecm_dbg("wb_en = 1 [0x1d6a][bit31] = 1\n");
-		pr_amvecm_dbg("gamma_en = 1 [0x1400][bit0] = 1\n");
-	} else {
-		pq_on_off = 0;
-		pr_amvecm_dbg("dnlp_en = 0 [0x1da1][bit2] = 0\n");
-		pr_amvecm_dbg("cm_en = 0  [0x1d26][bit28] = 0\n");
-		pr_amvecm_dbg("sharpness0_en = 0 [0x3227][bit1] = 0\n");
-		pr_amvecm_dbg("sharpness1_en = 0 [0x32a7][bit1] = 0\n");
-		pr_amvecm_dbg("wb_en = 0 [0x1d6a][bit31] = 0\n");
-		pr_amvecm_dbg("gamma_en = 0 [0x1400][bit0] = 0\n");
-	}
-	return count;
-}
-
-static ssize_t amvecm_cm_en_show(struct class *cla,
-			struct class_attribute *attr, char *buf)
-{
-	return sprintf(buf, "cm_en = %d\n", cm_en);
-}
-
-static ssize_t amvecm_cm_en_store(struct class *cla,
-			struct class_attribute *attr,
-			const char *buf, size_t count)
-{
-	size_t r;
-	int val;
-	r = sscanf(buf, "%d", &val);
-	if ((r != 1) || ((val != 1) && (val != 0)))
-		return -EINVAL;
-
-	if (val == 1)
-		cm_on_off = 1;
-	else
-		cm_on_off = 0;
-	return count;
-
-}
-
-static ssize_t amvecm_dnlp_en_show(struct class *cla,
-			struct class_attribute *attr, char *buf)
-{
-	return sprintf(buf, "dnlp_en = %d\n", dnlp_en);
-}
-
-static ssize_t amvecm_dnlp_en_store(struct class *cla,
-			struct class_attribute *attr,
-			const char *buf, size_t count)
-{
-	size_t r;
-	int val;
-	r = sscanf(buf, "%d", &val);
-	if ((r != 1) || ((val != 1) && (val != 0)))
-		return -EINVAL;
-
-	if (val == 1)
-		dnlp_on_off = 1;
-	else
-		dnlp_on_off = 0;
-	return count;
-
-}
-
-static ssize_t amvecm_sharpness_en_show(struct class *cla,
-			struct class_attribute *attr, char *buf)
-{
-	int val = READ_VPP_REG_BITS(VPP_VE_ENABLE_CTRL, 1, 1);
-
-	return sprintf(buf, "sharpness_en = %d\n", val);
-}
-
-static ssize_t amvecm_sharpness_en_store(struct class *cla,
-			struct class_attribute *attr,
-			const char *buf, size_t count)
-{
-	size_t r;
-	int val;
-	r = sscanf(buf, "%d", &val);
-	if ((r != 1) || ((val != 1) && (val != 0)))
-		return -EINVAL;
-
-	if (val == 1)
-		sharpness_on_off = 1;
-	else
-		sharpness_on_off = 0;
-	return count;
-
-}
-
-static ssize_t amvecm_gamma_en_show(struct class *cla,
-			struct class_attribute *attr, char *buf)
-{
-	int val = READ_VPP_REG_BITS(L_GAMMA_CNTL_PORT, GAMMA_EN, 1);
-
-	return sprintf(buf, "gamma_en = %d\n", val);
-}
-
-static ssize_t amvecm_gamma_en_store(struct class *cla,
-		struct class_attribute *attr,
-		const char *buf,
-		size_t count)
-{
-	size_t r;
-	int val;
-	r = sscanf(buf, "%d", &val);
-	if ((r != 1) || ((val != 1) && (val != 0)))
-		return -EINVAL;
-
-	if (val == 1)
-		vecm_latch_flag |= FLAG_GAMMA_TABLE_EN;	/* gamma off */
-	else
-		vecm_latch_flag |= FLAG_GAMMA_TABLE_DIS;	/* gamma off */
-	return count;
-
-}
-
-static ssize_t amvecm_wb_en_show(struct class *cla,
-			struct class_attribute *attr, char *buf)
-{
-	int val = READ_VPP_REG_BITS(VPP_GAINOFF_CTRL0, 31, 1);
-
-	return sprintf(buf, "sharpness_en = %d\n", val);
-}
-
-static ssize_t amvecm_wb_en_store(struct class *cla,
-			struct class_attribute *attr,
-			const char *buf, size_t count)
-{
-	size_t r;
-	int val;
-	r = sscanf(buf, "%d", &val);
-	if ((r != 1) || ((val != 1) && (val != 0)))
-		return -EINVAL;
-
-	if (val == 1)
-		wb_on_off = 1;
-	else
-		wb_on_off = 0;
-	return count;
-
-}
-
-
 static ssize_t amvecm_gamma_show(struct class *cls,
 			struct class_attribute *attr,
 			char *buf)
@@ -1568,6 +1543,8 @@ static ssize_t amvecm_gamma_store(struct class *cls,
 	char gamma[4];
 	int i = 0;
 	long val;
+	char delim1[3] = " ";
+	char delim2[2] = "\n";
 
 	/* to avoid the bellow warning message while compiling:
 	 * warning: the frame size of 1576 bytes is larger than 1024 bytes
@@ -1578,8 +1555,9 @@ static ssize_t amvecm_gamma_store(struct class *cls,
 
 	buf_orig = kstrdup(buffer, GFP_KERNEL);
 	ps = buf_orig;
+	strcat(delim1, delim2);
 	while (1) {
-		token = strsep(&ps, " \n");
+		token = strsep(&ps, delim1);
 		if (token == NULL)
 			break;
 		if (*token == '\0')
@@ -1649,11 +1627,14 @@ static ssize_t set_gamma_pattern_store(struct class *cls,
 	char *parm[3];
 	unsigned int gamma[3];
 	long val, i;
+	char deliml[3] = " ";
+	char delim2[2] = "\n";
 
 	buf_orig = kstrdup(buffer, GFP_KERNEL);
 	ps = buf_orig;
+	strcat(deliml, delim2);
 	while (1) {
-		token = strsep(&ps, " \n");
+		token = strsep(&ps, deliml);
 		if (token == NULL)
 			break;
 		if (*token == '\0')
@@ -1687,6 +1668,69 @@ static ssize_t set_gamma_pattern_store(struct class *cls,
 
 }
 
+static ssize_t set_hdr_289lut_show(struct class *cla,
+			struct class_attribute *attr, char *buf)
+{
+	int i;
+	for (i = 0; i < 289; i++) {
+		pr_info("0x%-8x\t", lut_289_mapping[i]);
+		if ((i + 1) % 8 == 0)
+			pr_info("\n");
+	}
+	return 0;
+}
+static ssize_t set_hdr_289lut_store(struct class *cls,
+			struct class_attribute *attr,
+			const char *buffer, size_t count)
+{
+	int n = 0;
+	char *buf_orig, *ps, *token;
+	char *parm[4];
+	unsigned short *Hdr289lut;
+	unsigned int gamma_count;
+	char gamma[4];
+	int i = 0;
+	long val;
+	char deliml[3] = " ";
+	char delim2[2] = "\n";
+
+	Hdr289lut = kmalloc(289 * sizeof(unsigned short), GFP_KERNEL);
+
+	buf_orig = kstrdup(buffer, GFP_KERNEL);
+	ps = buf_orig;
+	strcat(deliml, delim2);
+	while (1) {
+		token = strsep(&ps, deliml);
+		if (token == NULL)
+			break;
+		if (*token == '\0')
+			continue;
+		parm[n++] = token;
+	}
+
+	memset(Hdr289lut, 0, 289 * sizeof(unsigned short));
+	gamma_count = (strlen(parm[0]) + 2) / 3;
+	if (gamma_count > 289)
+		gamma_count = 289;
+
+	for (i = 0; i < gamma_count; ++i) {
+		gamma[0] = parm[0][3 * i + 0];
+		gamma[1] = parm[0][3 * i + 1];
+		gamma[2] = parm[0][3 * i + 2];
+		gamma[3] = '\0';
+		if (kstrtol(gamma, 16, &val) < 0)
+			return -EINVAL;
+		Hdr289lut[i] = val;
+	}
+
+	for (i = 0; i < gamma_count; i++)
+		lut_289_mapping[i] = Hdr289lut[i];
+
+	kfree(buf_orig);
+	kfree(Hdr289lut);
+	return count;
+
+}
 
 static ssize_t amvecm_set_post_matrix_show(struct class *cla,
 			struct class_attribute *attr, char *buf)
@@ -1799,6 +1843,7 @@ static ssize_t amvecm_dump_reg_show(struct class *cla,
 			struct class_attribute *attr, char *buf)
 {
 	unsigned int addr;
+	unsigned int value;
 
 	pr_info("----dump sharpness0 reg----\n");
 	for (addr = 0x3200;
@@ -1806,12 +1851,43 @@ static ssize_t amvecm_dump_reg_show(struct class *cla,
 		pr_info("[0x%x]vcbus[0x%04x]=0x%08x\n",
 				(0xd0100000+(addr<<2)), addr,
 				READ_VPP_REG(addr));
+	if (is_meson_txl_cpu()) {
+		for (addr = 0x3265;
+			addr <= 0x3272; addr++)
+			pr_info("[0x%x]vcbus[0x%04x]=0x%08x\n",
+					(0xd0100000+(addr<<2)), addr,
+					READ_VPP_REG(addr));
+	}
 	pr_info("----dump sharpness1 reg----\n");
 	for (addr = (0x3200+0x80);
 		addr <= (0x3264+0x80); addr++)
 		pr_info("[0x%x]vcbus[0x%04x]=0x%08x\n",
 				(0xd0100000+(addr<<2)), addr,
 				READ_VPP_REG(addr));
+	if (is_meson_txl_cpu()) {
+		for (addr = (0x3265+0x80);
+			addr <= (0x3272+0x80); addr++)
+			pr_info("[0x%x]vcbus[0x%04x]=0x%08x\n",
+					(0xd0100000+(addr<<2)), addr,
+					READ_VPP_REG(addr));
+	}
+
+	pr_info("----dump cm reg----\n");
+	for (addr = 0x200; addr <= 0x21e; addr++) {
+		WRITE_VPP_REG(VPP_CHROMA_ADDR_PORT, addr);
+		value = READ_VPP_REG(VPP_CHROMA_DATA_PORT);
+		pr_info("[0x%x]vcbus[0x%04x]=0x%08x\n",
+				addr, addr,
+				value);
+	}
+	for (addr = 0x100; addr <= 0x1fc; addr++) {
+		WRITE_VPP_REG(VPP_CHROMA_ADDR_PORT, addr);
+		value = READ_VPP_REG(VPP_CHROMA_DATA_PORT);
+		pr_info("[0x%x]vcbus[0x%04x]=0x%08x\n",
+				addr, addr,
+				value);
+	}
+
 	pr_info("----dump vd1 IF0 reg----\n");
 	for (addr = (0x1a50);
 		addr <= (0x1a69); addr++)
@@ -1996,6 +2072,15 @@ void pc_mode_process(void)
 		WRITE_VPP_REG(SRSHARP1_VCTI_FLT_CON_CLP,
 				reg_val | 0x4000);
 
+		if (is_meson_txl_cpu()) {
+			WRITE_VPP_REG_BITS(SRSHARP0_DEJ_CTRL, 1, 0, 1);
+			WRITE_VPP_REG_BITS(SRSHARP0_SR3_DRTLPF_EN, 7, 0, 3);
+			WRITE_VPP_REG_BITS(SRSHARP0_SR3_DERING_CTRL, 1, 28, 3);
+
+			WRITE_VPP_REG_BITS(SRSHARP1_DEJ_CTRL, 1, 0, 1);
+			WRITE_VPP_REG_BITS(SRSHARP1_SR3_DRTLPF_EN, 7, 0, 3);
+			WRITE_VPP_REG_BITS(SRSHARP1_SR3_DERING_CTRL, 1, 28, 3);
+		}
 		WRITE_VPP_REG(VPP_VADJ_CTRL, 0xd);
 		pc_mode_last = pc_mode;
 	} else if ((pc_mode == 0) && (pc_mode != pc_mode_last)) {
@@ -2034,11 +2119,397 @@ void pc_mode_process(void)
 		WRITE_VPP_REG(SRSHARP1_VCTI_FLT_CON_CLP,
 				reg_val & 0xffffbfff);
 
+		if (is_meson_txl_cpu()) {
+			WRITE_VPP_REG_BITS(SRSHARP0_DEJ_CTRL, 0, 0, 1);
+			WRITE_VPP_REG_BITS(SRSHARP0_SR3_DRTLPF_EN, 0, 0, 3);
+			WRITE_VPP_REG_BITS(SRSHARP0_SR3_DERING_CTRL, 0, 28, 3);
+
+			WRITE_VPP_REG_BITS(SRSHARP1_DEJ_CTRL, 0, 0, 1);
+			WRITE_VPP_REG_BITS(SRSHARP1_SR3_DRTLPF_EN, 0, 0, 3);
+			WRITE_VPP_REG_BITS(SRSHARP1_SR3_DERING_CTRL, 0, 28, 3);
+		}
 		WRITE_VPP_REG(VPP_VADJ_CTRL, 0x0);
 		pc_mode_last = pc_mode;
 	}
 }
 
+static ssize_t amvecm_vpp_demo_show(struct class *cla,
+			struct class_attribute *attr, char *buf)
+{
+	return 0;
+}
+
+static ssize_t amvecm_vpp_demo_store(struct class *cla,
+			struct class_attribute *attr,
+			const char *buf, size_t count)
+{
+	size_t r;
+	int val;
+	r = sscanf(buf, "%x", &val);
+	if ((r != 1))
+		return -EINVAL;
+
+	if (val & VPP_DEMO_CM_EN)
+		vpp_demo_latch_flag |= VPP_DEMO_CM_EN;
+	else if (val & VPP_DEMO_CM_DIS)
+		vpp_demo_latch_flag |= VPP_DEMO_CM_DIS;
+
+	if (val & VPP_DEMO_DNLP_EN)
+		vpp_demo_latch_flag |= VPP_DEMO_DNLP_EN;
+	else if (val & VPP_DEMO_DNLP_DIS)
+		vpp_demo_latch_flag |= VPP_DEMO_DNLP_DIS;
+
+	return count;
+}
+
+static void dump_vpp_size_info(void)
+{
+	unsigned int vpp_input_h, vpp_input_v,
+		pps_input_lenth, pps_input_height,
+		pps_output_hs, pps_output_he, pps_output_vs, pps_output_ve,
+		vd1_preblend_hs, vd1_preblend_he,
+		vd1_preblend_vs, vd1_preblend_ve,
+		vd2_preblend_hs, vd2_preblend_he,
+		vd2_preblend_vs, vd2_preblend_ve,
+		prelend_input_hsize,
+		vd1_postblend_hs, vd1_postblend_he,
+		vd1_postblend_vs, vd1_postblend_ve,
+		postblend_hsize,
+		ve_hsize, ve_vsize, psr_hsize, psr_vsize,
+		cm_hsize, cm_vsize;
+	vpp_input_h = READ_VPP_REG_BITS(VPP_IN_H_V_SIZE, 16, 13);
+	vpp_input_v = READ_VPP_REG_BITS(VPP_IN_H_V_SIZE, 0, 13);
+	pps_input_lenth = READ_VPP_REG_BITS(VPP_LINE_IN_LENGTH, 0, 13);
+	pps_input_height = READ_VPP_REG_BITS(VPP_PIC_IN_HEIGHT, 0, 13);
+	pps_output_hs = READ_VPP_REG_BITS(VPP_HSC_REGION12_STARTP, 16, 13);
+	pps_output_he = READ_VPP_REG_BITS(VPP_HSC_REGION4_ENDP, 0, 13);
+	pps_output_vs = READ_VPP_REG_BITS(VPP_VSC_REGION12_STARTP, 16, 13);
+	pps_output_ve = READ_VPP_REG_BITS(VPP_VSC_REGION4_ENDP, 0, 13);
+	vd1_preblend_he = READ_VPP_REG_BITS(VPP_PREBLEND_VD1_H_START_END,
+		0, 13);
+	vd1_preblend_hs = READ_VPP_REG_BITS(VPP_PREBLEND_VD1_H_START_END,
+		16, 13);
+	vd1_preblend_ve = READ_VPP_REG_BITS(VPP_PREBLEND_VD1_V_START_END,
+		0, 13);
+	vd1_preblend_vs = READ_VPP_REG_BITS(VPP_PREBLEND_VD1_V_START_END,
+		16, 13);
+	vd2_preblend_he = READ_VPP_REG_BITS(VPP_BLEND_VD2_H_START_END, 0, 13);
+	vd2_preblend_hs = READ_VPP_REG_BITS(VPP_BLEND_VD2_H_START_END, 16, 13);
+	vd2_preblend_ve = READ_VPP_REG_BITS(VPP_BLEND_VD2_V_START_END, 0, 13);
+	vd2_preblend_vs = READ_VPP_REG_BITS(VPP_BLEND_VD2_V_START_END, 16, 13);
+	prelend_input_hsize = READ_VPP_REG_BITS(VPP_PREBLEND_H_SIZE, 0, 13);
+	vd1_postblend_he = READ_VPP_REG_BITS(VPP_POSTBLEND_VD1_H_START_END,
+		0, 13);
+	vd1_postblend_hs = READ_VPP_REG_BITS(VPP_POSTBLEND_VD1_H_START_END,
+		16, 13);
+	vd1_postblend_ve = READ_VPP_REG_BITS(VPP_POSTBLEND_VD1_V_START_END,
+		0, 13);
+	vd1_postblend_vs = READ_VPP_REG_BITS(VPP_POSTBLEND_VD1_V_START_END,
+		16, 13);
+	postblend_hsize = READ_VPP_REG_BITS(VPP_POSTBLEND_H_SIZE, 0, 13);
+	ve_hsize = READ_VPP_REG_BITS(VPP_VE_H_V_SIZE, 16, 13);
+	ve_vsize = READ_VPP_REG_BITS(VPP_VE_H_V_SIZE, 0, 13);
+	psr_hsize = READ_VPP_REG_BITS(VPP_PSR_H_V_SIZE, 16, 13);
+	psr_vsize = READ_VPP_REG_BITS(VPP_PSR_H_V_SIZE, 0, 13);
+	WRITE_VPP_REG(VPP_CHROMA_ADDR_PORT, 0x205);
+	cm_hsize = READ_VPP_REG(VPP_CHROMA_DATA_PORT);
+	cm_vsize = (cm_hsize >> 16) & 0xffff;
+	cm_hsize = cm_hsize & 0xffff;
+	pr_info("\n vpp size info:\n");
+	pr_info("vpp_input_h:%d, vpp_input_v:%d\n"
+		"pps_input_lenth:%d, pps_input_height:%d\n"
+		"pps_output_hs:%d, pps_output_he:%d\n"
+		"pps_output_vs:%d, pps_output_ve:%d\n"
+		"vd1_preblend_hs:%d, vd1_preblend_he:%d\n"
+		"vd1_preblend_vs:%d, vd1_preblend_ve:%d\n"
+		"vd2_preblend_hs:%d, vd2_preblend_he:%d\n"
+		"vd2_preblend_vs:%d, vd2_preblend_ve:%d\n"
+		"prelend_input_hsize:%d\n"
+		"vd1_postblend_hs:%d, vd1_postblend_he:%d\n"
+		"vd1_postblend_vs:%d, vd1_postblend_ve:%d\n"
+		"postblend_hsize:%d\n"
+		"ve_hsize:%d, ve_vsize:%d\n"
+		"psr_hsize:%d, psr_vsize:%d\n"
+		"cm_hsize:%d, cm_vsize:%d\n",
+		vpp_input_h, vpp_input_v,
+		pps_input_lenth, pps_input_height,
+		pps_output_hs, pps_output_he,
+		pps_output_vs, pps_output_ve,
+		vd1_preblend_hs, vd1_preblend_he,
+		vd1_preblend_vs, vd1_preblend_ve,
+		vd2_preblend_hs, vd2_preblend_he,
+		vd2_preblend_vs, vd2_preblend_ve,
+		prelend_input_hsize,
+		vd1_postblend_hs, vd1_postblend_he,
+		vd1_postblend_vs, vd1_postblend_ve,
+		postblend_hsize,
+		ve_hsize, ve_vsize,
+		psr_hsize, psr_vsize,
+		cm_hsize, cm_vsize);
+}
+
+static void vpp_sr3_enhance_enable(unsigned int enable)
+{
+	/*
+	0x00: core 0 disable
+	0x01: core 0 enable
+	0x10: core 1 diable
+	0x11: core 1 enable
+	*/
+	if (enable == 0x00) {
+		WRITE_VPP_REG_BITS(SRSHARP0_DEJ_CTRL, 0, 0, 1);
+		WRITE_VPP_REG_BITS(SRSHARP0_SR3_DRTLPF_EN, 0, 0, 3);
+		WRITE_VPP_REG_BITS(SRSHARP0_SR3_DERING_CTRL, 0, 28, 3);
+	} else if (enable == 0x01) {
+		WRITE_VPP_REG_BITS(SRSHARP0_DEJ_CTRL, 1, 0, 1);
+		WRITE_VPP_REG_BITS(SRSHARP0_SR3_DRTLPF_EN, 7, 0, 3);
+		WRITE_VPP_REG_BITS(SRSHARP0_SR3_DERING_CTRL, 1, 28, 3);
+	} else if (enable == 0x10) {
+		WRITE_VPP_REG_BITS(SRSHARP1_DEJ_CTRL, 0, 0, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_SR3_DRTLPF_EN, 0, 0, 3);
+		WRITE_VPP_REG_BITS(SRSHARP1_SR3_DERING_CTRL, 0, 28, 3);
+	} else if (enable == 0x11) {
+		WRITE_VPP_REG_BITS(SRSHARP1_DEJ_CTRL, 1, 0, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_SR3_DRTLPF_EN, 7, 0, 3);
+		WRITE_VPP_REG_BITS(SRSHARP1_SR3_DERING_CTRL, 1, 28, 3);
+	}
+}
+
+static void amvecm_wb_enable(int enable)
+{
+	if (enable) {
+		wb_en = 1;
+		WRITE_VPP_REG_BITS(VPP_GAINOFF_CTRL0, 1, 31, 1);
+	} else {
+		wb_en = 0;
+		WRITE_VPP_REG_BITS(VPP_GAINOFF_CTRL0, 0, 31, 1);
+	}
+}
+
+static void amvecm_sharpness_debug(int enable)
+{
+	/*0:peaking enable   1:peaking disable
+	  2:lti/cti enable   3:lti/cti disable*/
+	switch (enable) {
+	case 0:
+		WRITE_VPP_REG_BITS(SRSHARP0_SHARP_PK_NR_ENABLE, 1, 1, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_SHARP_PK_NR_ENABLE, 1, 1, 1);
+		break;
+	case 1:
+		WRITE_VPP_REG_BITS(SRSHARP0_SHARP_PK_NR_ENABLE, 0, 1, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_SHARP_PK_NR_ENABLE, 0, 1, 1);
+		break;
+	case 2:
+		WRITE_VPP_REG_BITS(SRSHARP0_HCTI_FLT_CLP_DC, 1, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP0_HLTI_FLT_CLP_DC, 1, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP0_VLTI_FLT_CON_CLP, 1, 14, 1);
+		WRITE_VPP_REG_BITS(SRSHARP0_VCTI_FLT_CON_CLP, 1, 14, 1);
+
+		WRITE_VPP_REG_BITS(SRSHARP1_HCTI_FLT_CLP_DC, 1, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_HLTI_FLT_CLP_DC, 1, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_VLTI_FLT_CON_CLP, 1, 14, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_VCTI_FLT_CON_CLP, 1, 14, 1);
+		break;
+	case 3:
+		WRITE_VPP_REG_BITS(SRSHARP0_HCTI_FLT_CLP_DC, 0, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP0_HLTI_FLT_CLP_DC, 0, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP0_VLTI_FLT_CON_CLP, 0, 14, 1);
+		WRITE_VPP_REG_BITS(SRSHARP0_VCTI_FLT_CON_CLP, 0, 14, 1);
+
+		WRITE_VPP_REG_BITS(SRSHARP1_HCTI_FLT_CLP_DC, 0, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_HLTI_FLT_CLP_DC, 0, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_VLTI_FLT_CON_CLP, 0, 14, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_VCTI_FLT_CON_CLP, 0, 14, 1);
+		break;
+	default:
+		break;
+	}
+}
+
+static void amvecm_pq_enable(int enable)
+{
+	if (enable) {
+		vecm_latch_flag |= FLAG_VE_DNLP_EN;
+
+		amcm_enable();
+
+		WRITE_VPP_REG_BITS(SRSHARP0_SHARP_PK_NR_ENABLE, 1, 1, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_SHARP_PK_NR_ENABLE, 1, 1, 1);
+
+		WRITE_VPP_REG_BITS(SRSHARP0_HCTI_FLT_CLP_DC, 1, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP0_HLTI_FLT_CLP_DC, 1, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP0_VLTI_FLT_CON_CLP, 1, 14, 1);
+		WRITE_VPP_REG_BITS(SRSHARP0_VCTI_FLT_CON_CLP, 1, 14, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_HCTI_FLT_CLP_DC, 1, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_HLTI_FLT_CLP_DC, 1, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_VLTI_FLT_CON_CLP, 1, 14, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_VCTI_FLT_CON_CLP, 1, 14, 1);
+
+		WRITE_VPP_REG_BITS(VPP_GAINOFF_CTRL0, 1, 31, 1);
+
+		vecm_latch_flag |= FLAG_GAMMA_TABLE_EN;
+
+		WRITE_VPP_REG_BITS(VPP_VADJ_CTRL, 1, 0, 1);
+	} else {
+		vecm_latch_flag |= FLAG_VE_DNLP_DIS;
+
+		amcm_disable();
+
+		WRITE_VPP_REG_BITS(SRSHARP0_SHARP_PK_NR_ENABLE, 0, 1, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_SHARP_PK_NR_ENABLE, 0, 1, 1);
+
+		WRITE_VPP_REG_BITS(SRSHARP0_HCTI_FLT_CLP_DC, 0, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP0_HLTI_FLT_CLP_DC, 0, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP0_VLTI_FLT_CON_CLP, 0, 14, 1);
+		WRITE_VPP_REG_BITS(SRSHARP0_VCTI_FLT_CON_CLP, 0, 14, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_HCTI_FLT_CLP_DC, 0, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_HLTI_FLT_CLP_DC, 0, 28, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_VLTI_FLT_CON_CLP, 0, 14, 1);
+		WRITE_VPP_REG_BITS(SRSHARP1_VCTI_FLT_CON_CLP, 0, 14, 1);
+
+		WRITE_VPP_REG_BITS(VPP_GAINOFF_CTRL0, 0, 31, 1);
+
+		vecm_latch_flag |= FLAG_GAMMA_TABLE_DIS;
+
+		WRITE_VPP_REG_BITS(VPP_VADJ_CTRL, 0, 0, 1);
+	}
+}
+
+static const char *amvecm_debug_usage_str = {
+	"Usage:\n"
+	"echo vpp_size > /sys/class/amvecm/debug ; get vpp size config\n"
+};
+static ssize_t amvecm_debug_show(struct class *cla,
+		struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", amvecm_debug_usage_str);
+}
+static ssize_t amvecm_debug_store(struct class *cla,
+		struct class_attribute *attr,
+		const char *buf, size_t count)
+{
+	char *buf_orig, *parm[8] = {NULL};
+	if (!buf)
+		return count;
+	buf_orig = kstrdup(buf, GFP_KERNEL);
+	parse_param_amvecm(buf_orig, (char **)&parm);
+	if (!strncmp(parm[0], "vpp_size", 8))
+		dump_vpp_size_info();
+	else if (!strncmp(parm[0], "4k_enhance", 10)) {
+		if (!strncmp(parm[1], "core0", 5)) {
+			if (!strncmp(parm[2], "00", 2)) {
+				vpp_sr3_enhance_enable(0x0);
+				pr_info("disable core0 sr3 dering/dejaggy/direction\n");
+			} else if (!strncmp(parm[2], "01", 2)) {
+				vpp_sr3_enhance_enable(0x1);
+				pr_info("enable core0 sr3 dering/dejaggy/direction\n");
+			}
+		} else if (!strncmp(parm[1], "core1", 2)) {
+			if (!strncmp(parm[2], "10", 2)) {
+				vpp_sr3_enhance_enable(0x10);
+				pr_info("disable core1 sr3 dering/dejaggy/direction\n");
+			} else if (!strncmp(parm[2], "11", 2)) {
+				vpp_sr3_enhance_enable(0x11);
+				pr_info("enable core1 sr3 dering/dejaggy/direction\n");
+			}
+		}
+	} else if (!strncmp(parm[0], "wb", 2)) {
+		if (!strncmp(parm[1], "enable", 6)) {
+			amvecm_wb_enable(1);
+			pr_info("enable wb\n");
+		} else if (!strncmp(parm[1], "disable", 7)) {
+			amvecm_wb_enable(0);
+			pr_info("disable wb\n");
+		}
+	} else if (!strncmp(parm[0], "gamma", 5)) {
+		if (!strncmp(parm[1], "enable", 6)) {
+			vecm_latch_flag |= FLAG_GAMMA_TABLE_EN;	/* gamma off */
+			pr_info("enable gamma\n");
+		} else if (!strncmp(parm[1], "disable", 7)) {
+			vecm_latch_flag |= FLAG_GAMMA_TABLE_DIS;/* gamma off */
+			pr_info("disable gamma\n");
+		}
+	} else if (!strncmp(parm[0], "sr", 2)) {
+		if (!strncmp(parm[1], "peaking_en", 10)) {
+			amvecm_sharpness_debug(0);
+			pr_info("enable peaking\n");
+		} else if (!strncmp(parm[1], "peaking_dis", 11)) {
+			amvecm_sharpness_debug(1);
+			pr_info("disable peaking\n");
+		} else if (!strncmp(parm[1], "lcti_en", 7)) {
+			amvecm_sharpness_debug(2);
+			pr_info("enable lti cti\n");
+		} else if (!strncmp(parm[1], "lcti_dis", 8)) {
+			amvecm_sharpness_debug(3);
+			pr_info("disable lti cti\n");
+		}
+	} else if (!strncmp(parm[0], "cm", 2)) {
+		if (!strncmp(parm[1], "enable", 6)) {
+			amcm_enable();
+			pr_info("enable cm\n");
+		} else if (!strncmp(parm[1], "disable", 7)) {
+			amcm_disable();
+			pr_info("disable cm\n");
+		}
+	} else if (!strncmp(parm[0], "dnlp", 4)) {
+		if (!strncmp(parm[1], "enable", 6)) {
+			ve_enable_dnlp();
+			pr_info("enable dnlp\n");
+		} else if (!strncmp(parm[1], "disable", 7)) {
+			ve_disable_dnlp();
+			pr_info("disable dnlp\n");
+		}
+	} else if (!strncmp(parm[0], "vpp_pq", 6)) {
+		if (!strncmp(parm[1], "enable", 6)) {
+			amvecm_pq_enable(1);
+			pr_info("enable vpp_pq\n");
+		} else if (!strncmp(parm[1], "disable", 7)) {
+			amvecm_pq_enable(0);
+			pr_info("disable vpp_pq\n");
+		}
+	}
+
+	kfree(buf_orig);
+	return count;
+}
+
+static ssize_t amvecm_dv_mode_show(struct class *cla,
+			struct class_attribute *attr, char *buf)
+{
+	pr_info("usage: echo mode > /sys/class/amvecm/dv_mode\n");
+	pr_info("\tDOLBY_VISION_OUTPUT_MODE_OFF			0\n");
+	pr_info("\tDOLBY_VISION_OUTPUT_MODE_IPT			1\n");
+	pr_info("\tDOLBY_VISION_OUTPUT_MODE_IPT_TUNNEL	2\n");
+	pr_info("\tDOLBY_VISION_OUTPUT_MODE_HDR10		3\n");
+	pr_info("\tDOLBY_VISION_OUTPUT_MODE_SDR10		4\n");
+	pr_info("\tDOLBY_VISION_OUTPUT_MODE_SDR8		5\n");
+	if (is_meson_gxm_cpu() && is_dolby_vision_on())
+		pr_info("current dv_mode = %d\n", get_dolby_vision_mode()+1);
+	else
+		pr_info("current dv_mode = %d\n", 0);
+	return 0;
+}
+
+static ssize_t amvecm_dv_mode_store(struct class *cla,
+			struct class_attribute *attr,
+			const char *buf, size_t count)
+{
+	size_t r;
+	int val;
+
+	if (is_meson_gxm_cpu()) {
+		r = sscanf(buf, "0x%x", &val);
+		if ((r != 1))
+			return -EINVAL;
+
+		if (val == 0)
+			enable_dolby_vision(0);
+		else if (val > 0)
+			set_dolby_vision_mode(val - 1);
+	}
+	return count;
+}
+
 /* #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESONG9TV) */
 void init_sharpness(void)
 {
@@ -2048,41 +2519,16 @@ void init_sharpness(void)
 	WRITE_VPP_REG_BITS(SRSHARP0_SHARP_PK_NR_ENABLE, 0, 1, 1);
 
 	WRITE_VPP_REG_BITS(VPP_SRSHARP1_CTRL, 1, 0, 1);
-/* WRITE_VPP_REG_BITS(SRSHARP1_SHARP_PK_NR_ENABLE, 0,1,1);*/
-
-/* WRITE_VPP_REG_BITS(VPP_VE_ENABLE_CTRL, 1,1,1); */
-/* WRITE_VPP_REG(NR_GAUSSIAN_MODE, 0x0); */
-/* WRITE_VPP_REG(PK_HVCON_LPF_MODE, 0x11111111); */
-/* WRITE_VPP_REG(PK_CON_2CIRHPGAIN_LIMIT, 0x05600500); */
-/* WRITE_VPP_REG(PK_CON_2CIRBPGAIN_LIMIT, 0x05280500); */
-/* WRITE_VPP_REG(PK_CON_2DRTHPGAIN_LIMIT, 0x05600500); */
-/* WRITE_VPP_REG(PK_CON_2DRTBPGAIN_LIMIT, 0x05280500); */
-/*  */
-/* WRITE_VPP_REG(PK_CIRFB_BLEND_GAIN, 0x8f808f80); */
-/* WRITE_VPP_REG(NR_ALP0_MIN_MAX, 0x003f003f); */
-/* WRITE_VPP_REG(PK_ALP2_MIERR_CORING, 0x00010101); */
-/* WRITE_VPP_REG(PK_ALP2_ERR2CURV_TH_RATE, 0x50504010); */
-/* WRITE_VPP_REG(PK_FINALGAIN_HP_BP, 0x00002820); */
-/* WRITE_VPP_REG(PK_OS_STATIC, 0x22014014); */
-/* WRITE_VPP_REG(PK_DRT_SAD_MISC, 0x18180418); */
-/* WRITE_VPP_REG(NR_TI_DNLP_BLEND, 0x00000406); */
-/* WRITE_VPP_REG(LTI_CTI_DF_GAIN, 0x18181818); */
-/* WRITE_VPP_REG(LTI_CTI_DIR_AC_DBG, 0x57ff0000); */
-/* WRITE_VPP_REG(HCTI_FLT_CLP_DC, 0x1a555310); */
-/* WRITE_VPP_REG(HCTI_BST_CORE, 0x05050503); */
-/* WRITE_VPP_REG(HCTI_CON_2_GAIN_0, 0x28193c00); */
-/* WRITE_VPP_REG(HLTI_FLT_CLP_DC, 0x19552104); */
-/* WRITE_VPP_REG(HLTI_BST_GAIN, 0x20201c0c); */
-/* WRITE_VPP_REG(HLTI_CON_2_GAIN_0, 0x24193c5a); */
-/* WRITE_VPP_REG(VLTI_FLT_CON_CLP, 0x00006a90); */
-/* WRITE_VPP_REG(VLTI_CON_2_GAIN_0, 0x193c0560); */
-/* WRITE_VPP_REG(VCTI_FLT_CON_CLP, 0x00006a90); */
-/* WRITE_VPP_REG(VCTI_BST_GAIN, 0x00101010); */
-/* WRITE_VPP_REG(VCTI_BST_CORE, 0x00050503); */
-/* WRITE_VPP_REG(PK_CIRFB_BP_CORING, 0x00043f04); */
-/* WRITE_VPP_REG(PK_DRTFB_HP_CORING, 0x00043f04); */
-/* WRITE_VPP_REG(SHARP_HVBLANK_NUM, 0x00003c3c); */
-/* pr_info("**********sharpness init ok!*********\n"); */
+
+	if (is_meson_txl_cpu()) {
+		WRITE_VPP_REG_BITS(SRSHARP1_PK_FINALGAIN_HP_BP, 2, 16, 2);
+
+		/*sr0 sr1 chroma filter bypass*/
+		WRITE_VPP_REG(SRSHARP0_SHARP_SR2_CBIC_HCOEF0, 0x4000);
+		WRITE_VPP_REG(SRSHARP0_SHARP_SR2_CBIC_VCOEF0, 0x4000);
+		WRITE_VPP_REG(SRSHARP1_SHARP_SR2_CBIC_HCOEF0, 0x4000);
+		WRITE_VPP_REG(SRSHARP1_SHARP_SR2_CBIC_VCOEF0, 0x4000);
+	}
 }
 /* #endif*/
 
@@ -2120,6 +2566,8 @@ static void amvecm_wb_init(bool en)
 }
 
 static struct class_attribute amvecm_class_attrs[] = {
+	__ATTR(debug, S_IRUGO | S_IWUSR,
+		amvecm_debug_show, amvecm_debug_store),
 	__ATTR(dnlp, S_IRUGO | S_IWUSR,
 		amvecm_dnlp_show, amvecm_dnlp_store),
 	__ATTR(brightness, S_IRUGO | S_IWUSR,
@@ -2156,19 +2604,9 @@ static struct class_attribute amvecm_class_attrs[] = {
 	__ATTR(sync_3d, S_IRUGO | S_IWUSR,
 		amvecm_3d_sync_show,
 		amvecm_3d_sync_store),
-	__ATTR(sharpness_on_off, S_IRUGO | S_IWUSR,
-		amvecm_sharpness_en_show, amvecm_sharpness_en_store),
-	__ATTR(gamma_on_off, S_IRUGO | S_IWUSR,
-		amvecm_gamma_en_show, amvecm_gamma_en_store),
-	__ATTR(wb_on_off, S_IRUGO | S_IWUSR,
-		amvecm_wb_en_show, amvecm_wb_en_store),
-/* #endif */
-	__ATTR(pq_on_off, S_IRUGO | S_IWUSR,
-		amvecm_pq_en_show, amvecm_pq_en_store),
-	__ATTR(cm_on_off, S_IRUGO | S_IWUSR,
-		amvecm_cm_en_show, amvecm_cm_en_store),
-	__ATTR(dnlp_on_off, S_IRUGO | S_IWUSR,
-		amvecm_dnlp_en_show, amvecm_dnlp_en_store),
+	__ATTR(vlock, S_IRUGO | S_IWUSR,
+		amvecm_vlock_show,
+		amvecm_vlock_store),
 	__ATTR(matrix_set, S_IRUGO | S_IWUSR,
 		amvecm_set_post_matrix_show, amvecm_set_post_matrix_store),
 	__ATTR(matrix_pos, S_IRUGO | S_IWUSR,
@@ -2191,6 +2629,12 @@ static struct class_attribute amvecm_class_attrs[] = {
 		set_gamma_pattern_show, set_gamma_pattern_store),
 	__ATTR(pc_mode, S_IRUGO | S_IWUSR,
 		amvecm_pc_mode_show, amvecm_pc_mode_store),
+	__ATTR(set_hdr_289lut, S_IRUGO | S_IWUSR,
+		set_hdr_289lut_show, set_hdr_289lut_store),
+	__ATTR(vpp_demo, S_IRUGO | S_IWUSR,
+		amvecm_vpp_demo_show, amvecm_vpp_demo_store),
+	__ATTR(dv_mode, S_IRUGO | S_IWUSR,
+		amvecm_dv_mode_show, amvecm_dv_mode_store),
 	__ATTR_NULL
 };
 
@@ -2230,9 +2674,38 @@ static void aml_vecm_dt_parse(struct platform_device *pdev)
 	/* init module status */
 	amvecm_wb_init(wb_en);
 	amvecm_gamma_init(gamma_en);
-	WRITE_VPP_REG_BITS(VPP_MISC, cm_en, 28, 1);
+	WRITE_VPP_REG_BITS(VPP_MISC, 1, 28, 1);
+	if (cm_en)
+		amcm_enable();
+	else
+		amcm_disable();
+	/* WRITE_VPP_REG_BITS(VPP_MISC, cm_en, 28, 1); */
 }
 
+#ifdef CONFIG_AML_LCD
+static int aml_lcd_gamma_notifier(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+	if ((event & LCD_EVENT_GAMMA_UPDATE) == 0)
+		return NOTIFY_DONE;
+
+#if 0
+	vpp_set_lcd_gamma_table(video_gamma_table_r.data, H_SEL_R);
+	vpp_set_lcd_gamma_table(video_gamma_table_g.data, H_SEL_G);
+	vpp_set_lcd_gamma_table(video_gamma_table_b.data, H_SEL_B);
+#else
+	vecm_latch_flag |= FLAG_GAMMA_TABLE_R;
+	vecm_latch_flag |= FLAG_GAMMA_TABLE_G;
+	vecm_latch_flag |= FLAG_GAMMA_TABLE_B;
+#endif
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block aml_lcd_gamma_nb = {
+	.notifier_call = aml_lcd_gamma_notifier,
+};
+#endif
 static int aml_vecm_probe(struct platform_device *pdev)
 {
 	int ret = 0;
@@ -2266,16 +2739,34 @@ static int aml_vecm_probe(struct platform_device *pdev)
 		ret = PTR_ERR(devp->dev);
 		goto fail_create_device;
 	}
+
+	spin_lock_init(&vpp_lcd_gamma_lock);
+#ifdef CONFIG_AML_LCD
+	ret = aml_lcd_notifier_register(&aml_lcd_gamma_nb);
+	if (ret)
+		pr_info("register aml_lcd_gamma_notifier failed\n");
+#endif
 	/* #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESONG9TV) */
-	if (is_meson_gxtvbb_cpu())
+	if (is_meson_gxtvbb_cpu() || is_meson_txl_cpu())
 		init_sharpness();
 	/* #endif */
 	vpp_get_hist_en();
 
 	memset(&vpp_hist_param.vpp_histgram[0],
 		0, sizeof(unsigned short) * 64);
-
+	/* box sdr_mode:auto, tv sdr_mode:off */
+	/* disable contrast and saturation adjustment for HDR on TV */
+	/* disable SDR to HDR convert on TV */
+	if (is_meson_gxl_cpu() || is_meson_gxm_cpu()) {
+		sdr_mode = 0;
+		hdr_flag = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 3);
+	} else {
+		sdr_mode = 0;
+		hdr_flag = (1 << 0) | (1 << 1) | (0 << 2) | (0 << 3);
+	}
 	aml_vecm_dt_parse(pdev);
+	if (is_meson_gxm_cpu())
+		dolby_vision_init_receiver();
 	probe_ok = 1;
 	pr_info("%s: ok\n", __func__);
 	return 0;
@@ -2310,6 +2801,9 @@ static int __exit aml_vecm_remove(struct platform_device *pdev)
 	class_destroy(devp->clsp);
 	unregister_chrdev_region(devp->devno, 1);
 	kfree(devp);
+#ifdef CONFIG_AML_LCD
+	aml_lcd_notifier_unregister(&aml_lcd_gamma_nb);
+#endif
 	probe_ok = 0;
 	pr_info("[amvecm.] : amvecm_exit.\n");
 	return 0;
diff --git a/drivers/amlogic/amvecm/amvecm_vlock_regmap.h b/drivers/amlogic/amvecm/amvecm_vlock_regmap.h
index 15b5971..0d23d58 100644
--- a/drivers/amlogic/amvecm/amvecm_vlock_regmap.h
+++ b/drivers/amlogic/amvecm/amvecm_vlock_regmap.h
@@ -52,7 +52,7 @@ static struct am_regs_s vlock_pll_in50hz_out60hz = {
 	{REG_TYPE_VCBUS, 0x3000,     0xffffffff, 0x07f13f1b   },
 	{REG_TYPE_VCBUS, 0x3001,     0xffffffff, 0x04053c32   },
 	{REG_TYPE_VCBUS, 0x3002,     0xffffffff, 0x06000000   },
-	{REG_TYPE_VCBUS, 0x3003,     0xffffffff, 0x2065c65c   },
+	{REG_TYPE_VCBUS, 0x3003,     0xffffffff, 0x2055c55c   },
 	{REG_TYPE_VCBUS, 0x3004,     0xffffffff, 0x0065c65c   },
 	{REG_TYPE_VCBUS, 0x3005,     0xffffffff, 0x00080000   },
 	{REG_TYPE_VCBUS, 0x3006,     0xffffffff, 0x00070000   },
diff --git a/drivers/amlogic/amvecm/arch/hdr_curve.h b/drivers/amlogic/amvecm/arch/hdr_curve.h
new file mode 100644
index 0000000..b3eef38
--- /dev/null
+++ b/drivers/amlogic/amvecm/arch/hdr_curve.h
@@ -0,0 +1,884 @@
+/*
+ * drivers/amlogic/amports/arch/regs/hdr_curve.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+#ifndef HDR_CURVE_H
+#define HDR_CURVE_H
+
+/*hdr eotf & oetf curve setting*/
+/*panel from 260nit to 1000nit*/
+/*matlab parameters:
+ *% default setting for TV:
+ *panel_lum_max = 260; % nits, maximum panel luminance (260~1000)
+ *alpha_low = 0.075;    % 0: no dark boost; otherwise add dark boost
+ *panel_gamma = 2.2; % panel gamma 1.8, 2.0, 2.2, ...
+
+ *osd_merge_lut = 1; % whether merge osd
+	eo/oe lut to solve table resolution issue
+
+ *src_lum_max = 10000;  % nits, maximum of 10000 nits
+ *dsp_lum_max = 10000;   % nits, maximum luma of display luminance
+ *panel_lum_max = min(1000, panel_lum_max);
+ *panel_lum_max = max(100, panel_lum_max)
+ *panel_soft_clip_th = 912;
+ *hlg_lum_max = 1200;  % nits, use HLG curve instead of 709 gamma
+ *lum_norm = 10000;    % nits, 2084 maximum lum
+ *eotf_scl = 2^(floor(log2(10000/panel_lum_max))-1)
+	% to increase precision could be 1,2,4,8,16
+ *eo_scale = 1;     % eotf scale
+ *eotf_norm = (2^14)*eo_scale ;  % 14bit(16384)=1.0; 15bit(32768)=1.0
+ *fact_scl = 1 / eo_scale;      % min(max(1,src_lum_max/dsp_lum_max),4);
+	% factors to be applied to linear RGB before going to LUT289
+ *oetf_norm = (2^14); % oetf normalization
+ *oetf_scl = max(1,hlg_lum_max/100); % 1200
+ *blx_soft = 0;        % 0: means not black soft cliping;
+	otherwise soft clipping, e.g. 2*4
+*/
+unsigned int eotf_33_2084_table[][33] = {
+	{/*260*/
+	    0,     4,     9,    16,    27,    43,    66,   101,
+	  149,   219,   315,   449,   644,   911,  1273,  1762,
+	 2418,  3297,  4468,  6028,  8100, 10851, 14501, 14938,
+	15304, 15605, 15847, 16035, 16176, 16276, 16339, 16373,
+	16383
+	},
+	{/*280*/
+	    0,     4,     9,    16,    27,    43,    66,   101,
+	  149,   219,   315,   449,   644,   911,  1273,  1762,
+	 2418,  3297,  4468,  6028,  8100, 10851, 14501, 14938,
+	15304, 15605, 15847, 16035, 16176, 16276, 16339, 16373,
+	16383
+	},
+	{/*300*/
+	    0,     4,     9,    16,    27,    43,    66,   101,
+	  149,   219,   315,   449,   644,   911,  1273,  1762,
+	 2418,  3297,  4468,  6028,  8100, 10851, 14501, 14938,
+	15304, 15605, 15847, 16035, 16176, 16276, 16339, 16373,
+	16383
+	},
+	{/*320*/
+	    0,     3,     6,    11,    18,    27,    40,    58,
+	   84,   119,   169,   237,   329,   455,   636,   881,
+	 1209,  1648,  2234,  3014,  4050,  5425,  7251,  9673,
+	12889, 13773, 14513, 15117, 15594, 15951, 16196, 16338,
+	16383
+	},
+	{/*340*/
+	    0,     3,     6,    11,    18,    27,    40,    58,
+	   84,   119,   169,   237,   329,   455,   636,   881,
+	 1209,  1648,  2234,  3014,  4050,  5425,  7251,  9673,
+	12889, 13773, 14513, 15117, 15594, 15951, 16196, 16338,
+	16383
+	},
+	{/*360*/
+	    0,     3,     6,    11,    18,    27,    40,    58,
+	   84,   119,   169,   237,   329,   455,   636,   881,
+	 1209,  1648,  2234,  3014,  4050,  5425,  7251,  9673,
+	12889, 13773, 14513, 15117, 15594, 15951, 16196, 16338,
+	16383
+	},
+	{/*380*/
+	    0,     3,     6,    11,    18,    27,    40,    58,
+	   84,   119,   169,   237,   329,   455,   636,   881,
+	 1209,  1648,  2234,  3014,  4050,  5425,  7251,  9673,
+	12889, 13773, 14513, 15117, 15594, 15951, 16196, 16338,
+	16383
+	},
+	{/*400*/
+	    0,     3,     6,    11,    18,    27,    40,    58,
+	   84,   119,   169,   237,   329,   455,   636,   881,
+	 1209,  1648,  2234,  3014,  4050,  5425,  7251,  9673,
+	12889, 13773, 14513, 15117, 15594, 15951, 16196, 16338,
+	16383
+	},
+	{/*420*/
+	    0,     3,     6,    11,    18,    27,    40,    58,
+	   84,   119,   169,   237,   329,   455,   636,   881,
+	 1209,  1648,  2234,  3014,  4050,  5425,  7251,  9673,
+	12889, 13773, 14513, 15117, 15594, 15951, 16196, 16338,
+	16383
+	},
+	{/*440*/
+	    0,     3,     6,    11,    18,    27,    40,    58,
+	   84,   119,   169,   237,   329,   455,   636,   881,
+	 1209,  1648,  2234,  3014,  4050,  5425,  7251,  9673,
+	12889, 13773, 14513, 15117, 15594, 15951, 16196, 16338,
+	16383
+	},
+	{/*460*/
+	    0,     3,     6,    11,    18,    27,    40,    58,
+	   84,   119,   169,   237,   329,   455,   636,   881,
+	 1209,  1648,  2234,  3014,  4050,  5425,  7251,  9673,
+	12889, 13773, 14513, 15117, 15594, 15951, 16196, 16338,
+	16383
+	},
+	{/*480*/
+	    0,     3,     6,    11,    18,    27,    40,    58,
+	   84,   119,   169,   237,   329,   455,   636,   881,
+	 1209,  1648,  2234,  3014,  4050,  5425,  7251,  9673,
+	12889, 13773, 14513, 15117, 15594, 15951, 16196, 16338,
+	16383
+	},
+	{/*500*/
+	    0,     3,     6,    11,    18,    27,    40,    58,
+	   84,   119,   169,   237,   329,   455,   636,   881,
+	 1209,  1648,  2234,  3014,  4050,  5425,  7251,  9673,
+	12889, 13773, 14513, 15117, 15594, 15951, 16196, 16338,
+	16383
+	},
+	{/*600*/
+	    0,     3,     6,    11,    18,    27,    40,    58,
+	   84,   119,   169,   237,   329,   455,   636,   881,
+	 1209,  1648,  2234,  3014,  4050,  5425,  7251,  9673,
+	12889, 13773, 14513, 15117, 15594, 15951, 16196, 16338,
+	16383
+	},
+	{/*700*/
+	    0,     2,     5,     8,    12,    18,    25,    35,
+	   49,    68,    93,   128,   175,   239,   325,   440,
+	  605,   824,  1117,  1507,  2025,  2713,  3625,  4836,
+	 6445,  8583, 11430, 15228, 15695, 16025, 16237, 16350,
+	16383
+	},
+	{/*800*/
+	    0,     2,     5,     8,    12,    18,    25,    35,
+	   49,    68,    93,   128,   175,   239,   325,   440,
+	  605,   824,  1117,  1507,  2025,  2713,  3625,  4836,
+	 6445,  8583, 11430, 15228, 15695, 16025, 16237, 16350,
+	16383
+	},
+	{/*900*/
+	    0,     2,     5,     8,    12,    18,    25,    35,
+	   49,    68,    93,   128,   175,   239,   325,   440,
+	  605,   824,  1117,  1507,  2025,  2713,  3625,  4836,
+	 6445,  8583, 11430, 15228, 15695, 16025, 16237, 16350,
+	16383
+	},
+	{/*1000*/
+	    0,     2,     5,     8,    12,    18,    25,    35,
+	   49,    68,    93,   128,   175,   239,   325,   440,
+	  605,   824,  1117,  1507,  2025,  2713,  3625,  4836,
+	 6445,  8583, 11430, 15228, 15695, 16025, 16237, 16350,
+	16383
+	}
+};
+
+unsigned int oetf_289_gamma22_table[][289] = {
+	{/*260*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  125,  169,  202,  230,  255,  278,  297,
+	 316,  333,  349,  364,  379,  393,  407,  420,
+	 433,  445,  457,  468,  479,  489,  500,  510,
+	 520,  530,  539,  549,  558,  567,  576,  585,
+	 593,  602,  610,  618,  626,  634,  642,  649,
+	 657,  664,  671,  678,  686,  693,  701,  708,
+	 716,  724,  732,  739,  747,  755,  762,  769,
+	 776,  782,  789,  794,  800,  805,  809,  813,
+	 816,  819,  821,  823,  826,  828,  830,  832,
+	 834,  836,  839,  841,  843,  845,  847,  849,
+	 851,  853,  855,  857,  859,  861,  863,  865,
+	 867,  869,  871,  873,  875,  877,  879,  880,
+	 882,  884,  886,  888,  890,  891,  893,  895,
+	 897,  898,  900,  902,  903,  905,  907,  908,
+	 910,  912,  913,  915,  916,  918,  920,  921,
+	 923,  924,  926,  927,  929,  930,  932,  933,
+	 935,  936,  937,  939,  940,  942,  943,  944,
+	 946,  947,  948,  950,  951,  952,  953,  955,
+	 956,  957,  958,  960,  961,  962,  963,  964,
+	 965,  967,  968,  969,  970,  971,  972,  973,
+	 974,  975,  976,  977,  978,  979,  980,  981,
+	 982,  983,  984,  985,  986,  987,  988,  989,
+	 989,  990,  991,  992,  993,  994,  994,  995,
+	 996,  997,  997,  998,  999, 1000, 1000, 1001,
+	1002, 1002, 1003, 1004, 1004, 1005, 1006, 1006,
+	1007, 1007, 1008, 1009, 1009, 1010, 1010, 1011,
+	1011, 1012, 1012, 1013, 1013, 1014, 1014, 1014,
+	1015, 1015, 1016, 1016, 1016, 1017, 1017, 1017,
+	1018, 1018, 1018, 1019, 1019, 1019, 1020, 1020,
+	1020, 1020, 1021, 1021, 1021, 1021, 1021, 1022,
+	1022, 1022, 1022, 1022, 1022, 1022, 1022, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*280*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  121,  163,  195,  222,  247,  268,  287,
+	 305,  322,  337,  352,  367,  380,  393,  406,
+	 418,  430,  441,  452,  463,  473,  483,  493,
+	 502,  512,  521,  530,  539,  548,  557,  565,
+	 573,  582,  589,  597,  605,  612,  620,  627,
+	 634,  641,  648,  655,  662,  669,  677,  684,
+	 692,  699,  707,  714,  721,  729,  736,  742,
+	 749,  755,  761,  767,  772,  777,  782,  786,
+	 789,  792,  794,  797,  799,  802,  804,  806,
+	 809,  811,  813,  816,  818,  820,  823,  825,
+	 827,  829,  832,  834,  836,  838,  841,  843,
+	 845,  847,  849,  851,  853,  855,  858,  860,
+	 862,  864,  866,  868,  870,  872,  874,  876,
+	 878,  880,  881,  883,  885,  887,  889,  891,
+	 893,  895,  896,  898,  900,  902,  903,  905,
+	 907,  909,  910,  912,  914,  915,  917,  919,
+	 920,  922,  924,  925,  927,  928,  930,  931,
+	 933,  934,  936,  937,  939,  940,  942,  943,
+	 945,  946,  947,  949,  950,  952,  953,  954,
+	 956,  957,  958,  959,  961,  962,  963,  964,
+	 966,  967,  968,  969,  970,  971,  973,  974,
+	 975,  976,  977,  978,  979,  980,  981,  982,
+	 983,  984,  985,  986,  987,  988,  989,  990,
+	 991,  992,  993,  993,  994,  995,  996,  997,
+	 998,  998,  999, 1000, 1001, 1001, 1002, 1003,
+	1004, 1004, 1005, 1006, 1006, 1007, 1008, 1008,
+	1009, 1009, 1010, 1011, 1011, 1012, 1012, 1013,
+	1013, 1014, 1014, 1015, 1015, 1015, 1016, 1016,
+	1017, 1017, 1017, 1018, 1018, 1019, 1019, 1019,
+	1019, 1020, 1020, 1020, 1021, 1021, 1021, 1021,
+	1021, 1022, 1022, 1022, 1022, 1022, 1022, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*300*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  117,  158,  189,  216,  239,  260,  278,
+	 295,  311,  327,  341,  355,  368,  381,  393,
+	 405,  417,  428,  438,  449,  458,  468,  478,
+	 487,  496,  505,  514,  523,  531,  539,  548,
+	 556,  563,  571,  579,  586,  594,  601,  608,
+	 615,  622,  628,  635,  642,  648,  655,  661,
+	 667,  674,  680,  686,  692,  698,  704,  710,
+	 716,  722,  728,  733,  739,  745,  750,  756,
+	 761,  767,  772,  778,  783,  789,  795,  801,
+	 807,  813,  819,  825,  831,  836,  842,  848,
+	 854,  859,  864,  869,  874,  879,  884,  888,
+	 892,  895,  899,  902,  905,  907,  909,  910,
+	 912,  913,  915,  916,  918,  919,  921,  922,
+	 923,  925,  926,  927,  929,  930,  931,  933,
+	 934,  935,  937,  938,  939,  940,  942,  943,
+	 944,  945,  946,  948,  949,  950,  951,  952,
+	 953,  955,  956,  957,  958,  959,  960,  961,
+	 962,  963,  964,  965,  966,  967,  968,  969,
+	 970,  971,  972,  973,  974,  975,  976,  977,
+	 978,  979,  980,  980,  981,  982,  983,  984,
+	 985,  986,  986,  987,  988,  989,  990,  990,
+	 991,  992,  993,  993,  994,  995,  995,  996,
+	 997,  997,  998,  999,  999, 1000, 1001, 1001,
+	1002, 1002, 1003, 1004, 1004, 1005, 1005, 1006,
+	1006, 1007, 1007, 1008, 1008, 1009, 1009, 1010,
+	1010, 1011, 1011, 1012, 1012, 1013, 1013, 1013,
+	1014, 1014, 1015, 1015, 1015, 1016, 1016, 1016,
+	1017, 1017, 1017, 1018, 1018, 1018, 1018, 1019,
+	1019, 1019, 1019, 1020, 1020, 1020, 1020, 1021,
+	1021, 1021, 1021, 1021, 1021, 1022, 1022, 1022,
+	1022, 1022, 1022, 1022, 1022, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*320*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  153,  209,  252,  287,  317,  345,  370,
+	 394,  416,  436,  455,  474,  491,  508,  524,
+	 540,  555,  569,  584,  597,  611,  623,  636,
+	 648,  661,  672,  684,  696,  707,  718,  729,
+	 739,  750,  761,  772,  784,  796,  808,  820,
+	 831,  841,  851,  860,  868,  874,  879,  882,
+	 884,  886,  887,  889,  891,  892,  894,  895,
+	 897,  899,  900,  902,  903,  905,  906,  908,
+	 909,  911,  912,  913,  915,  916,  918,  919,
+	 920,  922,  923,  924,  926,  927,  928,  930,
+	 931,  932,  934,  935,  936,  937,  938,  940,
+	 941,  942,  943,  944,  946,  947,  948,  949,
+	 950,  951,  952,  953,  954,  955,  956,  958,
+	 959,  960,  961,  962,  963,  964,  965,  965,
+	 966,  967,  968,  969,  970,  971,  972,  973,
+	 974,  975,  975,  976,  977,  978,  979,  979,
+	 980,  981,  982,  983,  983,  984,  985,  986,
+	 986,  987,  988,  988,  989,  990,  990,  991,
+	 992,  992,  993,  994,  994,  995,  996,  996,
+	 997,  997,  998,  998,  999, 1000, 1000, 1001,
+	1001, 1002, 1002, 1003, 1003, 1004, 1004, 1005,
+	1005, 1006, 1006, 1006, 1007, 1007, 1008, 1008,
+	1009, 1009, 1009, 1010, 1010, 1011, 1011, 1011,
+	1012, 1012, 1012, 1013, 1013, 1013, 1014, 1014,
+	1014, 1015, 1015, 1015, 1015, 1016, 1016, 1016,
+	1017, 1017, 1017, 1017, 1017, 1018, 1018, 1018,
+	1018, 1019, 1019, 1019, 1019, 1019, 1020, 1020,
+	1020, 1020, 1020, 1020, 1021, 1021, 1021, 1021,
+	1021, 1021, 1021, 1021, 1022, 1022, 1022, 1022,
+	1022, 1022, 1022, 1022, 1022, 1022, 1022, 1022,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*340*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  149,  204,  245,  279,  309,  335,  360,
+	 383,  404,  424,  442,  460,  477,  494,  510,
+	 525,  539,  554,  567,  581,  594,  606,  619,
+	 631,  642,  654,  666,  677,  688,  699,  709,
+	 719,  730,  740,  751,  763,  774,  786,  797,
+	 808,  818,  827,  836,  844,  850,  855,  858,
+	 860,  862,  864,  866,  868,  870,  871,  873,
+	 875,  877,  879,  880,  882,  884,  886,  887,
+	 889,  891,  892,  894,  896,  897,  899,  900,
+	 902,  904,  905,  907,  908,  910,  911,  913,
+	 914,  916,  917,  919,  920,  921,  923,  924,
+	 926,  927,  928,  930,  931,  932,  934,  935,
+	 936,  938,  939,  940,  941,  943,  944,  945,
+	 946,  947,  949,  950,  951,  952,  953,  954,
+	 955,  956,  957,  959,  960,  961,  962,  963,
+	 964,  965,  966,  967,  968,  969,  970,  971,
+	 972,  972,  973,  974,  975,  976,  977,  978,
+	 979,  980,  980,  981,  982,  983,  984,  984,
+	 985,  986,  987,  987,  988,  989,  990,  990,
+	 991,  992,  992,  993,  994,  994,  995,  996,
+	 996,  997,  998,  998,  999,  999, 1000, 1001,
+	1001, 1002, 1002, 1003, 1003, 1004, 1004, 1005,
+	1005, 1006, 1006, 1007, 1007, 1008, 1008, 1009,
+	1009, 1009, 1010, 1010, 1011, 1011, 1011, 1012,
+	1012, 1013, 1013, 1013, 1014, 1014, 1014, 1015,
+	1015, 1015, 1016, 1016, 1016, 1016, 1017, 1017,
+	1017, 1017, 1018, 1018, 1018, 1018, 1019, 1019,
+	1019, 1019, 1019, 1020, 1020, 1020, 1020, 1020,
+	1021, 1021, 1021, 1021, 1021, 1021, 1021, 1022,
+	1022, 1022, 1022, 1022, 1022, 1022, 1022, 1022,
+	1022, 1022, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*360*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  145,  198,  240,  272,  301,  327,  350,
+	 373,  394,  413,  432,  449,  466,  482,  497,
+	 512,  526,  540,  553,  566,  579,  591,  603,
+	 615,  626,  637,  648,  659,  670,  680,  691,
+	 701,  711,  721,  732,  743,  754,  765,  776,
+	 786,  796,  806,  814,  821,  828,  833,  836,
+	 838,  840,  843,  845,  847,  849,  851,  853,
+	 855,  857,  859,  861,  863,  865,  866,  868,
+	 870,  872,  874,  876,  878,  879,  881,  883,
+	 885,  887,  888,  890,  892,  893,  895,  897,
+	 899,  900,  902,  903,  905,  907,  908,  910,
+	 911,  913,  914,  916,  917,  919,  920,  922,
+	 923,  925,  926,  928,  929,  930,  932,  933,
+	 934,  936,  937,  938,  940,  941,  942,  944,
+	 945,  946,  947,  948,  950,  951,  952,  953,
+	 954,  956,  957,  958,  959,  960,  961,  962,
+	 963,  964,  965,  966,  967,  968,  969,  970,
+	 971,  972,  973,  974,  975,  976,  977,  978,
+	 979,  980,  981,  981,  982,  983,  984,  985,
+	 986,  986,  987,  988,  989,  989,  990,  991,
+	 992,  992,  993,  994,  994,  995,  996,  997,
+	 997,  998,  998,  999, 1000, 1000, 1001, 1001,
+	1002, 1003, 1003, 1004, 1004, 1005, 1005, 1006,
+	1006, 1007, 1007, 1008, 1008, 1009, 1009, 1010,
+	1010, 1011, 1011, 1011, 1012, 1012, 1013, 1013,
+	1013, 1014, 1014, 1014, 1015, 1015, 1015, 1016,
+	1016, 1016, 1017, 1017, 1017, 1017, 1018, 1018,
+	1018, 1019, 1019, 1019, 1019, 1019, 1020, 1020,
+	1020, 1020, 1020, 1021, 1021, 1021, 1021, 1021,
+	1021, 1022, 1022, 1022, 1022, 1022, 1022, 1022,
+	1022, 1022, 1022, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*380*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  142,  194,  233,  265,  293,  319,  343,
+	 365,  385,  403,  421,  438,  454,  469,  484,
+	 499,  513,  527,  540,  553,  565,  577,  588,
+	 600,  611,  622,  633,  643,  654,  664,  674,
+	 684,  693,  704,  714,  725,  736,  746,  757,
+	 767,  777,  786,  794,  801,  808,  813,  816,
+	 818,  821,  823,  825,  828,  830,  832,  834,
+	 836,  838,  841,  843,  845,  847,  849,  851,
+	 853,  855,  857,  859,  861,  863,  865,  867,
+	 869,  871,  873,  875,  877,  879,  880,  882,
+	 884,  886,  888,  889,  891,  893,  895,  896,
+	 898,  900,  901,  903,  905,  906,  908,  910,
+	 911,  913,  914,  916,  917,  919,  921,  922,
+	 923,  925,  926,  928,  929,  931,  932,  934,
+	 935,  936,  938,  939,  940,  942,  943,  944,
+	 946,  947,  948,  949,  951,  952,  953,  954,
+	 955,  957,  958,  959,  960,  961,  962,  963,
+	 964,  966,  967,  968,  969,  970,  971,  972,
+	 973,  974,  975,  976,  977,  978,  978,  979,
+	 980,  981,  982,  983,  984,  985,  986,  986,
+	 987,  988,  989,  990,  990,  991,  992,  993,
+	 993,  994,  995,  996,  996,  997,  998,  998,
+	 999, 1000, 1000, 1001, 1001, 1002, 1003, 1003,
+	1004, 1004, 1005, 1005, 1006, 1007, 1007, 1008,
+	1008, 1009, 1009, 1010, 1010, 1010, 1011, 1011,
+	1012, 1012, 1013, 1013, 1013, 1014, 1014, 1015,
+	1015, 1015, 1016, 1016, 1016, 1017, 1017, 1017,
+	1017, 1018, 1018, 1018, 1019, 1019, 1019, 1019,
+	1020, 1020, 1020, 1020, 1020, 1021, 1021, 1021,
+	1021, 1021, 1021, 1022, 1022, 1022, 1022, 1022,
+	1022, 1022, 1022, 1022, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*400*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  139,  189,  228,  259,  287,  312,  334,
+	 356,  375,  394,  411,  427,  443,  458,  473,
+	 487,  501,  514,  527,  540,  552,  564,  575,
+	 586,  597,  608,  618,  629,  639,  649,  658,
+	 668,  677,  687,  697,  708,  718,  729,  739,
+	 749,  758,  767,  775,  782,  788,  793,  797,
+	 800,  802,  804,  807,  809,  812,  814,  816,
+	 819,  821,  823,  826,  828,  830,  832,  835,
+	 837,  839,  841,  843,  845,  848,  850,  852,
+	 854,  856,  858,  860,  862,  864,  866,  868,
+	 870,  872,  874,  876,  878,  880,  882,  883,
+	 885,  887,  889,  891,  892,  894,  896,  898,
+	 899,  901,  903,  905,  906,  908,  910,  911,
+	 913,  914,  916,  918,  919,  921,  922,  924,
+	 925,  927,  928,  930,  931,  933,  934,  935,
+	 937,  938,  940,  941,  942,  944,  945,  946,
+	 948,  949,  950,  951,  953,  954,  955,  956,
+	 958,  959,  960,  961,  962,  963,  964,  966,
+	 967,  968,  969,  970,  971,  972,  973,  974,
+	 975,  976,  977,  978,  979,  980,  981,  982,
+	 983,  984,  984,  985,  986,  987,  988,  989,
+	 990,  990,  991,  992,  993,  993,  994,  995,
+	 996,  996,  997,  998,  999,  999, 1000, 1001,
+	1001, 1002, 1002, 1003, 1004, 1004, 1005, 1005,
+	1006, 1007, 1007, 1008, 1008, 1009, 1009, 1010,
+	1010, 1011, 1011, 1012, 1012, 1012, 1013, 1013,
+	1014, 1014, 1014, 1015, 1015, 1016, 1016, 1016,
+	1017, 1017, 1017, 1018, 1018, 1018, 1018, 1019,
+	1019, 1019, 1019, 1020, 1020, 1020, 1020, 1021,
+	1021, 1021, 1021, 1021, 1021, 1022, 1022, 1022,
+	1022, 1022, 1022, 1022, 1022, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*420*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  135,  185,  222,  253,  280,  305,  327,
+	 348,  368,  385,  402,  418,  434,  449,  463,
+	 477,  490,  503,  516,  528,  539,  550,  562,
+	 572,  583,  594,  604,  614,  624,  634,  644,
+	 653,  662,  672,  682,  692,  702,  713,  723,
+	 732,  741,  750,  758,  765,  771,  776,  780,
+	 783,  785,  788,  790,  793,  795,  798,  800,
+	 803,  805,  808,  810,  813,  815,  817,  820,
+	 822,  824,  827,  829,  831,  834,  836,  838,
+	 840,  842,  845,  847,  849,  851,  853,  855,
+	 857,  859,  862,  864,  866,  868,  870,  872,
+	 874,  876,  877,  879,  881,  883,  885,  887,
+	 889,  891,  892,  894,  896,  898,  900,  901,
+	 903,  905,  907,  908,  910,  912,  913,  915,
+	 916,  918,  920,  921,  923,  924,  926,  927,
+	 929,  930,  932,  933,  935,  936,  938,  939,
+	 941,  942,  943,  945,  946,  947,  949,  950,
+	 951,  953,  954,  955,  956,  958,  959,  960,
+	 961,  962,  964,  965,  966,  967,  968,  969,
+	 970,  971,  972,  973,  975,  976,  977,  978,
+	 979,  980,  980,  981,  982,  983,  984,  985,
+	 986,  987,  988,  989,  990,  990,  991,  992,
+	 993,  994,  994,  995,  996,  997,  997,  998,
+	 999, 1000, 1000, 1001, 1002, 1002, 1003, 1003,
+	1004, 1005, 1005, 1006, 1006, 1007, 1008, 1008,
+	1009, 1009, 1010, 1010, 1011, 1011, 1012, 1012,
+	1013, 1013, 1013, 1014, 1014, 1015, 1015, 1015,
+	1016, 1016, 1017, 1017, 1017, 1018, 1018, 1018,
+	1018, 1019, 1019, 1019, 1020, 1020, 1020, 1020,
+	1020, 1021, 1021, 1021, 1021, 1021, 1022, 1022,
+	1022, 1022, 1022, 1022, 1022, 1022, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*440*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  133,  182,  219,  249,  275,  298,  320,
+	 340,  360,  377,  394,  410,  425,  440,  454,
+	 467,  480,  493,  505,  517,  528,  539,  550,
+	 561,  572,  582,  592,  602,  612,  621,  631,
+	 640,  649,  658,  667,  675,  684,  692,  700,
+	 708,  716,  724,  731,  739,  747,  754,  761,
+	 769,  776,  784,  793,  801,  809,  818,  826,
+	 834,  842,  850,  858,  865,  872,  878,  884,
+	 889,  894,  898,  901,  903,  905,  906,  908,
+	 909,  911,  912,  913,  915,  916,  918,  919,
+	 920,  922,  923,  924,  926,  927,  928,  930,
+	 931,  932,  933,  935,  936,  937,  938,  939,
+	 941,  942,  943,  944,  945,  946,  948,  949,
+	 950,  951,  952,  953,  954,  955,  956,  957,
+	 958,  959,  960,  961,  962,  963,  964,  965,
+	 966,  967,  968,  969,  970,  971,  972,  973,
+	 973,  974,  975,  976,  977,  978,  979,  979,
+	 980,  981,  982,  983,  983,  984,  985,  986,
+	 986,  987,  988,  988,  989,  990,  991,  991,
+	 992,  993,  993,  994,  994,  995,  996,  996,
+	 997,  998,  998,  999,  999, 1000, 1000, 1001,
+	1001, 1002, 1003, 1003, 1004, 1004, 1005, 1005,
+	1006, 1006, 1006, 1007, 1007, 1008, 1008, 1009,
+	1009, 1010, 1010, 1010, 1011, 1011, 1011, 1012,
+	1012, 1013, 1013, 1013, 1014, 1014, 1014, 1015,
+	1015, 1015, 1016, 1016, 1016, 1016, 1017, 1017,
+	1017, 1017, 1018, 1018, 1018, 1018, 1019, 1019,
+	1019, 1019, 1019, 1020, 1020, 1020, 1020, 1020,
+	1021, 1021, 1021, 1021, 1021, 1021, 1021, 1022,
+	1022, 1022, 1022, 1022, 1022, 1022, 1022, 1022,
+	1022, 1022, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*460*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  130,  177,  214,  243,  269,  293,  314,
+	 334,  353,  370,  386,  402,  416,  430,  444,
+	 457,  470,  482,  494,  506,  517,  528,  539,
+	 549,  560,  570,  580,  590,  599,  609,  618,
+	 627,  636,  645,  653,  662,  670,  678,  686,
+	 694,  702,  709,  717,  725,  732,  739,  746,
+	 754,  761,  769,  777,  785,  793,  801,  809,
+	 817,  825,  833,  840,  847,  854,  860,  866,
+	 871,  875,  879,  883,  885,  887,  889,  890,
+	 892,  893,  895,  897,  898,  900,  901,  903,
+	 904,  906,  907,  909,  910,  912,  913,  915,
+	 916,  918,  919,  921,  922,  923,  925,  926,
+	 927,  929,  930,  931,  933,  934,  935,  937,
+	 938,  939,  940,  941,  943,  944,  945,  946,
+	 947,  949,  950,  951,  952,  953,  954,  955,
+	 956,  958,  959,  960,  961,  962,  963,  964,
+	 965,  966,  967,  968,  969,  970,  971,  972,
+	 973,  973,  974,  975,  976,  977,  978,  979,
+	 980,  980,  981,  982,  983,  984,  985,  985,
+	 986,  987,  988,  988,  989,  990,  991,  991,
+	 992,  993,  993,  994,  995,  995,  996,  997,
+	 997,  998,  999,  999, 1000, 1000, 1001, 1002,
+	1002, 1003, 1003, 1004, 1004, 1005, 1005, 1006,
+	1006, 1007, 1007, 1008, 1008, 1009, 1009, 1010,
+	1010, 1010, 1011, 1011, 1012, 1012, 1012, 1013,
+	1013, 1014, 1014, 1014, 1015, 1015, 1015, 1016,
+	1016, 1016, 1017, 1017, 1017, 1017, 1018, 1018,
+	1018, 1018, 1019, 1019, 1019, 1019, 1020, 1020,
+	1020, 1020, 1020, 1021, 1021, 1021, 1021, 1021,
+	1021, 1021, 1022, 1022, 1022, 1022, 1022, 1022,
+	1022, 1022, 1022, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*480*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  128,  174,  210,  239,  264,  287,  308,
+	 327,  345,  362,  378,  393,  408,  422,  435,
+	 448,  461,  473,  485,  496,  507,  518,  529,
+	 539,  549,  559,  569,  579,  588,  597,  606,
+	 615,  624,  632,  641,  649,  657,  665,  673,
+	 681,  689,  696,  704,  711,  718,  725,  733,
+	 740,  747,  754,  762,  770,  778,  786,  794,
+	 801,  809,  816,  823,  830,  837,  843,  849,
+	 854,  858,  862,  865,  868,  870,  872,  874,
+	 875,  877,  879,  881,  882,  884,  886,  888,
+	 889,  891,  893,  894,  896,  897,  899,  901,
+	 902,  904,  905,  907,  909,  910,  912,  913,
+	 915,  916,  918,  919,  920,  922,  923,  925,
+	 926,  928,  929,  930,  932,  933,  934,  936,
+	 937,  938,  940,  941,  942,  943,  945,  946,
+	 947,  948,  949,  951,  952,  953,  954,  955,
+	 956,  958,  959,  960,  961,  962,  963,  964,
+	 965,  966,  967,  968,  969,  970,  971,  972,
+	 973,  974,  975,  976,  977,  978,  979,  980,
+	 980,  981,  982,  983,  984,  985,  985,  986,
+	 987,  988,  989,  989,  990,  991,  992,  992,
+	 993,  994,  995,  995,  996,  997,  997,  998,
+	 999,  999, 1000, 1001, 1001, 1002, 1002, 1003,
+	1003, 1004, 1005, 1005, 1006, 1006, 1007, 1007,
+	1008, 1008, 1009, 1009, 1010, 1010, 1011, 1011,
+	1011, 1012, 1012, 1013, 1013, 1013, 1014, 1014,
+	1015, 1015, 1015, 1016, 1016, 1016, 1017, 1017,
+	1017, 1018, 1018, 1018, 1018, 1019, 1019, 1019,
+	1019, 1020, 1020, 1020, 1020, 1020, 1021, 1021,
+	1021, 1021, 1021, 1021, 1022, 1022, 1022, 1022,
+	1022, 1022, 1022, 1022, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*500*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  125,  171,  206,  235,  259,  281,  302,
+	 321,  339,  356,  371,  386,  401,  414,  427,
+	 440,  453,  465,  476,  488,  498,  509,  519,
+	 529,  539,  549,  558,  568,  577,  586,  595,
+	 603,  612,  620,  628,  637,  645,  652,  660,
+	 668,  675,  683,  690,  697,  705,  712,  719,
+	 726,  733,  740,  748,  755,  763,  771,  778,
+	 786,  793,  801,  808,  814,  821,  827,  832,
+	 837,  842,  846,  849,  852,  854,  856,  858,
+	 860,  862,  864,  866,  867,  869,  871,  873,
+	 875,  877,  879,  880,  882,  884,  886,  887,
+	 889,  891,  893,  894,  896,  898,  899,  901,
+	 902,  904,  906,  907,  909,  910,  912,  914,
+	 915,  917,  918,  920,  921,  923,  924,  925,
+	 927,  928,  930,  931,  933,  934,  935,  937,
+	 938,  939,  941,  942,  943,  945,  946,  947,
+	 948,  950,  951,  952,  953,  954,  956,  957,
+	 958,  959,  960,  961,  962,  963,  965,  966,
+	 967,  968,  969,  970,  971,  972,  973,  974,
+	 975,  976,  977,  978,  979,  980,  981,  981,
+	 982,  983,  984,  985,  986,  987,  987,  988,
+	 989,  990,  991,  991,  992,  993,  994,  995,
+	 995,  996,  997,  997,  998,  999,  999, 1000,
+	1001, 1001, 1002, 1003, 1003, 1004, 1004, 1005,
+	1006, 1006, 1007, 1007, 1008, 1008, 1009, 1009,
+	1010, 1010, 1011, 1011, 1012, 1012, 1012, 1013,
+	1013, 1014, 1014, 1015, 1015, 1015, 1016, 1016,
+	1016, 1017, 1017, 1017, 1018, 1018, 1018, 1019,
+	1019, 1019, 1019, 1020, 1020, 1020, 1020, 1020,
+	1021, 1021, 1021, 1021, 1021, 1022, 1022, 1022,
+	1022, 1022, 1022, 1022, 1022, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*600*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  115,  157,  189,  215,  238,  259,  278,
+	 296,  312,  327,  342,  356,  369,  381,  394,
+	 405,  417,  428,  438,  449,  459,  468,  478,
+	 487,  496,  505,  514,  523,  531,  540,  548,
+	 556,  564,  571,  579,  586,  594,  601,  608,
+	 615,  622,  629,  636,  642,  649,  655,  662,
+	 668,  675,  681,  688,  695,  702,  709,  715,
+	 722,  729,  735,  741,  747,  753,  759,  764,
+	 769,  773,  777,  781,  784,  786,  789,  791,
+	 794,  796,  799,  801,  803,  806,  808,  811,
+	 813,  815,  818,  820,  822,  825,  827,  829,
+	 831,  834,  836,  838,  840,  842,  845,  847,
+	 849,  851,  853,  855,  857,  860,  862,  864,
+	 866,  868,  870,  872,  874,  876,  878,  880,
+	 882,  884,  886,  887,  889,  891,  893,  895,
+	 897,  899,  900,  902,  904,  906,  908,  909,
+	 911,  913,  915,  916,  918,  920,  921,  923,
+	 925,  926,  928,  929,  931,  932,  934,  936,
+	 937,  939,  940,  942,  943,  945,  946,  947,
+	 949,  950,  952,  953,  954,  956,  957,  958,
+	 960,  961,  962,  964,  965,  966,  967,  969,
+	 970,  971,  972,  973,  974,  976,  977,  978,
+	 979,  980,  981,  982,  983,  984,  985,  986,
+	 987,  988,  989,  990,  991,  992,  993,  994,
+	 995,  996,  996,  997,  998,  999, 1000, 1001,
+	1001, 1002, 1003, 1004, 1004, 1005, 1006, 1006,
+	1007, 1008, 1008, 1009, 1010, 1010, 1011, 1011,
+	1012, 1012, 1013, 1014, 1014, 1015, 1015, 1015,
+	1016, 1016, 1017, 1017, 1018, 1018, 1018, 1019,
+	1019, 1019, 1020, 1020, 1020, 1020, 1021, 1021,
+	1021, 1021, 1022, 1022, 1022, 1022, 1022, 1022,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*700*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  146,  201,  241,  276,  306,  332,  356,
+	 378,  399,  419,  437,  454,  471,  487,  503,
+	 518,  533,  547,  560,  573,  586,  599,  611,
+	 623,  634,  646,  657,  668,  679,  689,  700,
+	 710,  720,  730,  739,  749,  758,  767,  776,
+	 785,  794,  803,  811,  820,  828,  837,  845,
+	 853,  861,  870,  880,  889,  898,  905,  908,
+	 909,  911,  912,  914,  915,  917,  918,  919,
+	 921,  922,  923,  925,  926,  927,  929,  930,
+	 931,  932,  934,  935,  936,  937,  939,  940,
+	 941,  942,  943,  944,  946,  947,  948,  949,
+	 950,  951,  952,  953,  954,  955,  956,  957,
+	 958,  959,  960,  961,  962,  963,  964,  965,
+	 966,  967,  968,  969,  970,  971,  972,  972,
+	 973,  974,  975,  976,  977,  977,  978,  979,
+	 980,  981,  981,  982,  983,  984,  984,  985,
+	 986,  987,  987,  988,  989,  989,  990,  991,
+	 991,  992,  993,  993,  994,  994,  995,  996,
+	 996,  997,  997,  998,  998,  999,  999, 1000,
+	1001, 1001, 1002, 1002, 1003, 1003, 1003, 1004,
+	1004, 1005, 1005, 1006, 1006, 1007, 1007, 1007,
+	1008, 1008, 1009, 1009, 1009, 1010, 1010, 1011,
+	1011, 1011, 1012, 1012, 1012, 1013, 1013, 1013,
+	1014, 1014, 1014, 1014, 1015, 1015, 1015, 1016,
+	1016, 1016, 1016, 1017, 1017, 1017, 1017, 1017,
+	1018, 1018, 1018, 1018, 1018, 1019, 1019, 1019,
+	1019, 1019, 1020, 1020, 1020, 1020, 1020, 1020,
+	1020, 1021, 1021, 1021, 1021, 1021, 1021, 1021,
+	1021, 1022, 1022, 1022, 1022, 1022, 1022, 1022,
+	1022, 1022, 1022, 1022, 1022, 1022, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*800*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  139,  189,  227,  259,  288,  312,  335,
+	 356,  375,  393,  411,  427,  443,  458,  473,
+	 487,  501,  514,  527,  539,  551,  563,  574,
+	 586,  597,  607,  618,  628,  639,  649,  658,
+	 668,  678,  687,  696,  705,  714,  722,  731,
+	 739,  747,  756,  764,  772,  780,  787,  795,
+	 803,  811,  819,  827,  836,  844,  850,  854,
+	 856,  858,  860,  862,  864,  866,  868,  870,
+	 872,  873,  875,  877,  879,  881,  883,  884,
+	 886,  888,  890,  891,  893,  895,  896,  898,
+	 900,  901,  903,  905,  906,  908,  909,  911,
+	 912,  914,  916,  917,  919,  920,  922,  923,
+	 924,  926,  927,  929,  930,  931,  933,  934,
+	 936,  937,  938,  939,  941,  942,  943,  945,
+	 946,  947,  948,  949,  951,  952,  953,  954,
+	 955,  956,  958,  959,  960,  961,  962,  963,
+	 964,  965,  966,  967,  968,  969,  970,  971,
+	 972,  973,  974,  975,  976,  977,  978,  979,
+	 980,  980,  981,  982,  983,  984,  985,  985,
+	 986,  987,  988,  989,  989,  990,  991,  992,
+	 992,  993,  994,  994,  995,  996,  996,  997,
+	 998,  998,  999, 1000, 1000, 1001, 1001, 1002,
+	1002, 1003, 1004, 1004, 1005, 1005, 1006, 1006,
+	1007, 1007, 1008, 1008, 1009, 1009, 1010, 1010,
+	1010, 1011, 1011, 1012, 1012, 1012, 1013, 1013,
+	1014, 1014, 1014, 1015, 1015, 1015, 1016, 1016,
+	1016, 1017, 1017, 1017, 1017, 1018, 1018, 1018,
+	1018, 1019, 1019, 1019, 1019, 1020, 1020, 1020,
+	1020, 1020, 1020, 1021, 1021, 1021, 1021, 1021,
+	1021, 1022, 1022, 1022, 1022, 1022, 1022, 1022,
+	1022, 1022, 1022, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*900*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  131,  179,  216,  246,  273,  296,  317,
+	 337,  355,  373,  389,  405,  420,  435,  449,
+	 462,  475,  488,  500,  512,  523,  534,  545,
+	 555,  566,  576,  586,  596,  605,  615,  624,
+	 633,  642,  651,  660,  668,  676,  685,  693,
+	 701,  709,  716,  724,  732,  739,  747,  754,
+	 761,  769,  776,  783,  790,  797,  804,  810,
+	 817,  824,  832,  839,  847,  855,  863,  870,
+	 877,  884,  890,  895,  900,  904,  907,  908,
+	 910,  911,  913,  914,  915,  917,  918,  920,
+	 921,  922,  924,  925,  926,  928,  929,  930,
+	 932,  933,  934,  935,  937,  938,  939,  940,
+	 941,  943,  944,  945,  946,  947,  948,  949,
+	 951,  952,  953,  954,  955,  956,  957,  958,
+	 959,  960,  961,  962,  963,  964,  965,  966,
+	 967,  968,  969,  970,  971,  972,  972,  973,
+	 974,  975,  976,  977,  978,  978,  979,  980,
+	 981,  982,  982,  983,  984,  985,  985,  986,
+	 987,  988,  988,  989,  990,  990,  991,  992,
+	 992,  993,  994,  994,  995,  996,  996,  997,
+	 997,  998,  999,  999, 1000, 1000, 1001, 1001,
+	1002, 1002, 1003, 1004, 1004, 1005, 1005, 1005,
+	1006, 1006, 1007, 1007, 1008, 1008, 1009, 1009,
+	1009, 1010, 1010, 1011, 1011, 1011, 1012, 1012,
+	1013, 1013, 1013, 1014, 1014, 1014, 1015, 1015,
+	1015, 1015, 1016, 1016, 1016, 1017, 1017, 1017,
+	1017, 1018, 1018, 1018, 1018, 1019, 1019, 1019,
+	1019, 1019, 1020, 1020, 1020, 1020, 1020, 1020,
+	1021, 1021, 1021, 1021, 1021, 1021, 1021, 1022,
+	1022, 1022, 1022, 1022, 1022, 1022, 1022, 1022,
+	1022, 1022, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	},
+	{/*1000*/
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,    0,    0,    0,    0,    0,    0,    0,
+	   0,  124,  171,  206,  235,  260,  281,  302,
+	 321,  339,  355,  371,  386,  400,  414,  428,
+	 441,  453,  465,  476,  487,  498,  509,  519,
+	 529,  539,  549,  558,  568,  577,  586,  594,
+	 603,  612,  620,  628,  636,  644,  652,  660,
+	 668,  675,  683,  690,  697,  705,  712,  719,
+	 726,  733,  740,  746,  753,  759,  766,  772,
+	 778,  785,  791,  797,  803,  809,  815,  821,
+	 827,  833,  839,  845,  850,  856,  862,  867,
+	 873,  880,  886,  893,  898,  903,  907,  909,
+	 911,  912,  914,  915,  917,  918,  919,  921,
+	 922,  924,  925,  926,  928,  929,  930,  932,
+	 933,  934,  936,  937,  938,  939,  941,  942,
+	 943,  944,  946,  947,  948,  949,  950,  951,
+	 952,  954,  955,  956,  957,  958,  959,  960,
+	 961,  962,  963,  964,  965,  966,  967,  968,
+	 969,  970,  971,  972,  973,  974,  975,  976,
+	 976,  977,  978,  979,  980,  981,  982,  982,
+	 983,  984,  985,  986,  986,  987,  988,  989,
+	 989,  990,  991,  991,  992,  993,  993,  994,
+	 995,  995,  996,  997,  997,  998,  999,  999,
+	1000, 1000, 1001, 1001, 1002, 1003, 1003, 1004,
+	1004, 1005, 1005, 1006, 1006, 1007, 1007, 1008,
+	1008, 1008, 1009, 1009, 1010, 1010, 1011, 1011,
+	1011, 1012, 1012, 1013, 1013, 1013, 1014, 1014,
+	1014, 1015, 1015, 1015, 1016, 1016, 1016, 1016,
+	1017, 1017, 1017, 1018, 1018, 1018, 1018, 1019,
+	1019, 1019, 1019, 1019, 1020, 1020, 1020, 1020,
+	1020, 1020, 1021, 1021, 1021, 1021, 1021, 1021,
+	1022, 1022, 1022, 1022, 1022, 1022, 1022, 1022,
+	1022, 1022, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023, 1023, 1023, 1023, 1023, 1023, 1023, 1023,
+	1023
+	}
+};
+
+#endif
+
diff --git a/drivers/amlogic/amvecm/arch/vpp_dolbyvision_regs.h b/drivers/amlogic/amvecm/arch/vpp_dolbyvision_regs.h
new file mode 100644
index 0000000..91e997e
--- /dev/null
+++ b/drivers/amlogic/amvecm/arch/vpp_dolbyvision_regs.h
@@ -0,0 +1,201 @@
+/*
+ * drivers/amlogic/amports/arch/regs/vpp_dolbyvision_regs.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+#ifndef VPP_DOLBYVISION_REGS_H
+#define VPP_DOLBYVISION_REGS_H
+
+#define DOLBY_CORE1_REG_START		0x3300
+#define DOLBY_CORE1_CLKGATE_CTRL	0x33f2
+#define DOLBY_CORE1_SWAP_CTRL0		0x33f3
+#define DOLBY_CORE1_SWAP_CTRL1		0x33f4
+#define DOLBY_CORE1_SWAP_CTRL2		0x33f5
+#define DOLBY_CORE1_SWAP_CTRL3		0x33f6
+#define DOLBY_CORE1_SWAP_CTRL4		0x33f7
+#define DOLBY_CORE1_SWAP_CTRL5		0x33f8
+#define DOLBY_CORE1_DMA_CTRL		0x33f9
+#define DOLBY_CORE1_DMA_STATUS		0x33fa
+#define DOLBY_CORE1_STATUS0		0x33fb
+#define DOLBY_CORE1_STATUS1		0x33fc
+#define DOLBY_CORE1_STATUS2		0x33fd
+#define DOLBY_CORE1_STATUS3		0x33fe
+#define DOLBY_CORE1_DMA_PORT		0x33ff
+
+#define DOLBY_CORE2A_REG_START		0x3400
+#define DOLBY_CORE2A_CLKGATE_CTRL	0x3432
+#define DOLBY_CORE2A_SWAP_CTRL0		0x3433
+#define DOLBY_CORE2A_SWAP_CTRL1		0x3434
+#define DOLBY_CORE2A_SWAP_CTRL2		0x3435
+#define DOLBY_CORE2A_SWAP_CTRL3		0x3436
+#define DOLBY_CORE2A_SWAP_CTRL4		0x3437
+#define DOLBY_CORE2A_SWAP_CTRL5		0x3438
+#define DOLBY_CORE2A_DMA_CTRL		0x3439
+#define DOLBY_CORE2A_DMA_STATUS		0x343a
+#define DOLBY_CORE2A_STATUS0		0x343b
+#define DOLBY_CORE2A_STATUS1		0x343c
+#define DOLBY_CORE2A_STATUS2		0x343d
+#define DOLBY_CORE2A_STATUS3		0x343e
+#define DOLBY_CORE2A_DMA_PORT		0x343f
+
+#define DOLBY_CORE3_REG_START		0x3600
+#define DOLBY_CORE3_CLKGATE_CTRL	0x36f0
+#define DOLBY_CORE3_SWAP_CTRL0		0x36f1
+#define DOLBY_CORE3_SWAP_CTRL1		0x36f2
+#define DOLBY_CORE3_SWAP_CTRL2		0x36f3
+#define DOLBY_CORE3_SWAP_CTRL3		0x36f4
+#define DOLBY_CORE3_SWAP_CTRL4		0x36f5
+#define DOLBY_CORE3_SWAP_CTRL5		0x36f6
+#define DOLBY_CORE3_SWAP_CTRL6		0x36f7
+
+#define VIU_MISC_CTRL1			0x1a07
+#define VPP_DOLBY_CTRL			0x1d93
+#define VIU_SW_RESET			0x1a01
+#define VPU_HDMI_FMT_CTRL		0x2743
+
+#if 0
+/* core 1 display manager 24 registers */
+struct dm_register_ipcore_1_s {
+	uint32_t SRange;
+	uint32_t Srange_Inverse;
+	uint32_t Frame_Format_1;
+	uint32_t Frame_Format_2;
+	uint32_t Frame_Pixel_Def;
+	uint32_t Y2RGB_Coefficient_1;
+	uint32_t Y2RGB_Coefficient_2;
+	uint32_t Y2RGB_Coefficient_3;
+	uint32_t Y2RGB_Coefficient_4;
+	uint32_t Y2RGB_Coefficient_5;
+	uint32_t Y2RGB_Offset_1;
+	uint32_t Y2RGB_Offset_2;
+	uint32_t Y2RGB_Offset_3;
+	uint32_t EOTF;
+	uint32_t A2B_Coefficient_1;
+	uint32_t A2B_Coefficient_2;
+	uint32_t A2B_Coefficient_3;
+	uint32_t A2B_Coefficient_4;
+	uint32_t A2B_Coefficient_5;
+	uint32_t C2D_Coefficient_1;
+	uint32_t C2D_Coefficient_2;
+	uint32_t C2D_Coefficient_3;
+	uint32_t C2D_Coefficient_4;
+	uint32_t C2D_Coefficient_5;
+};
+
+/* core 1 composer 173 registers */
+struct composer_register_ipcore_s {
+	uint32_t Composer_Mode;
+	uint32_t VDR_Resolution;
+	uint32_t Bit_Depth;
+	uint32_t Coefficient_Log2_Denominator;
+	uint32_t BL_Num_Pivots_Y;
+	uint32_t BL_Pivot[5];
+	uint32_t BL_Order;
+	uint32_t BL_Coefficient_Y[8][3];
+	uint32_t EL_NLQ_Offset_Y;
+	uint32_t EL_Coefficient_Y[3];
+	uint32_t Mapping_IDC_U;
+	uint32_t BL_Num_Pivots_U;
+	uint32_t BL_Pivot_U[3];
+	uint32_t BL_Order_U;
+	uint32_t BL_Coefficient_U[4][3];
+	uint32_t MMR_Coefficient_U[22][2];
+	uint32_t MMR_Order_U;
+	uint32_t EL_NLQ_Offset_U;
+	uint32_t EL_Coefficient_U[3];
+	uint32_t Mapping_IDC_V;
+	uint32_t BL_Num_Pivots_V;
+	uint32_t BL_Pivot_V[3];
+	uint32_t BL_Order_V;
+	uint32_t BL_Coefficient_V[4][3];
+	uint32_t MMR_Coefficient_V[22][2];
+	uint32_t MMR_Order_V;
+	uint32_t EL_NLQ_Offset_V;
+	uint32_t EL_Coefficient_V[3];
+};
+
+/* core 2 display manager 24 registers */
+struct dm_register_ipcore_2_s {
+	uint32_t SRange;
+	uint32_t Srange_Inverse;
+	uint32_t Y2RGB_Coefficient_1;
+	uint32_t Y2RGB_Coefficient_2;
+	uint32_t Y2RGB_Coefficient_3;
+	uint32_t Y2RGB_Coefficient_4;
+	uint32_t Y2RGB_Coefficient_5;
+	uint32_t Y2RGB_Offset_1;
+	uint32_t Y2RGB_Offset_2;
+	uint32_t Y2RGB_Offset_3;
+	uint32_t Frame_Format;
+	uint32_t EOTF;
+	uint32_t A2B_Coefficient_1;
+	uint32_t A2B_Coefficient_2;
+	uint32_t A2B_Coefficient_3;
+	uint32_t A2B_Coefficient_4;
+	uint32_t A2B_Coefficient_5;
+	uint32_t C2D_Coefficient_1;
+	uint32_t C2D_Coefficient_2;
+	uint32_t C2D_Coefficient_3;
+	uint32_t C2D_Coefficient_4;
+	uint32_t C2D_Coefficient_5;
+	uint32_t C2D_Offset;
+	uint32_t VDR_Resolution;
+};
+
+/* core 3 display manager 26 registers */
+struct dm_register_ipcore_3_s {
+	uint32_t D2C_coefficient_1;
+	uint32_t D2C_coefficient_2;
+	uint32_t D2C_coefficient_3;
+	uint32_t D2C_coefficient_4;
+	uint32_t D2C_coefficient_5;
+	uint32_t B2A_Coefficient_1;
+	uint32_t B2A_Coefficient_2;
+	uint32_t B2A_Coefficient_3;
+	uint32_t B2A_Coefficient_4;
+	uint32_t B2A_Coefficient_5;
+	uint32_t Eotf_param_1;
+	uint32_t Eotf_param_2;
+	uint32_t IPT_Scale;
+	uint32_t IPT_Offset_1;
+	uint32_t IPT_Offset_2;
+	uint32_t IPT_Offset_3;
+	uint32_t Output_range_1;
+	uint32_t Output_range_2;
+	uint32_t RGB2YUV_coefficient_register1;
+	uint32_t RGB2YUV_coefficient_register2;
+	uint32_t RGB2YUV_coefficient_register3;
+	uint32_t RGB2YUV_coefficient_register4;
+	uint32_t RGB2YUV_coefficient_register5;
+	uint32_t RGB2YUV_offset_0;
+	uint32_t RGB2YUV_offset_1;
+	uint32_t RGB2YUV_offset_2;
+};
+
+/* lut 5 * 256 for core 1 and core 2 */
+struct dm_lut_ipcore_s {
+	uint32_t TmLutI[64*4];
+	uint32_t TmLutS[64*4];
+	uint32_t SmLutI[64*4];
+	uint32_t SmLutS[64*4];
+	uint32_t G2L[256];
+};
+
+/* core 3 metadata 128 registers */
+struct md_reister_ipcore_3_s {
+	uint32_t raw_metadata[128];
+};
+#endif
+
+#endif
diff --git a/drivers/amlogic/amvecm/arch/vpp_hdr_regs.h b/drivers/amlogic/amvecm/arch/vpp_hdr_regs.h
index a711d3d..24fd860 100644
--- a/drivers/amlogic/amvecm/arch/vpp_hdr_regs.h
+++ b/drivers/amlogic/amvecm/arch/vpp_hdr_regs.h
@@ -26,6 +26,9 @@
 #define XVYCC_INV_LUT_CTL		0x3164
 #define XVYCC_LUT_CTL			0x3165
 
+#define XVYCC_INV_LUT_Y_ADDR_PORT     0x3158
+#define XVYCC_INV_LUT_Y_DATA_PORT     0x3159
+
 extern struct am_regs_s r_lut_hdr_hdr;
 extern struct am_regs_s r_lut_sdr_sdr;
 extern struct am_regs_s r_lut_hdr_sdr_level1;
diff --git a/drivers/amlogic/amvecm/arch/vpp_regs.h b/drivers/amlogic/amvecm/arch/vpp_regs.h
index ed62a70..0005114 100644
--- a/drivers/amlogic/amvecm/arch/vpp_regs.h
+++ b/drivers/amlogic/amvecm/arch/vpp_regs.h
@@ -148,6 +148,7 @@
 #define VPP_VE_DEMO_LEFT_TOP_SCREEN_WIDTH 0x1da2
 #define VPP_VE_DEMO_CENTER_BAR 0x1da3
 #define VPP_VE_H_V_SIZE 0x1da4
+#define VPP_PSR_H_V_SIZE 0x1da5
 #define VPP_VDO_MEAS_CTRL 0x1da8
 #define VPP_VDO_MEAS_VS_COUNT_HI 0x1da9
 #define VPP_VDO_MEAS_VS_COUNT_LO 0x1daa
@@ -185,6 +186,7 @@
 #define VPP_OSD_SCALE_COEF_IDX 0x1dcc
 #define VPP_OSD_SCALE_COEF 0x1dcd
 #define VPP_INT_LINE_NUM 0x1dce
+#define VPP_XVYCC_MISC 0x1dcf
 
 #define VPP_CLIP_MISC0 0x1dd9
 
@@ -447,6 +449,7 @@
 #define SRSHARP0_PK_FINALGAIN_HP_BP 0x3222
 #define SRSHARP0_SHARP_PK_NR_ENABLE 0x3227
 #define SRSHARP0_SHARP_DNLP_EN 0x3245
+#define SRSHARP1_PK_FINALGAIN_HP_BP 0x32a2
 #define SRSHARP1_SHARP_PK_NR_ENABLE 0x32a7
 #define SRSHARP1_SHARP_DNLP_EN 0x32c5
 
@@ -472,6 +475,15 @@
 #define SRSHARP1_VLTI_FLT_CON_CLP     0x32ba/*bit14*/
 #define SRSHARP1_VCTI_FLT_CON_CLP     0x32bf
 
+/*sr0 sr1 dejaggy/direction/dering*/
+#define SRSHARP0_DEJ_CTRL				0x3264/*bit 0*/
+#define SRSHARP0_SR3_DRTLPF_EN			0x3266/*bit 0-2*/
+#define SRSHARP0_SR3_DERING_CTRL		0x326b/*bit 28-30*/
+
+#define SRSHARP1_DEJ_CTRL				0x32e4/*bit 0*/
+#define SRSHARP1_SR3_DRTLPF_EN			0x32e6/*bit 0-2*/
+#define SRSHARP1_SR3_DERING_CTRL		0x32eb/*bit 28-30*/
+
 /* for pll bug */
 #define HHI_HDMI_PLL_CNTL			    0x10c8
 #define HHI_HDMI_PLL_CNTL2			    0x10c9
@@ -484,7 +496,10 @@
 
 #define ENCL_VIDEO_MAX_LNCNT            0x1cbb
 #define VDIN_MEAS_VS_COUNT_LO 0x125c
-
+/*after GXL new add CNTL1,same with CNTL2 on G9TV/GXTVBB*/
+#define HHI_HDMI_PLL_CNTL1			    0x10c9
+/*after GXL CNTL5[bit3] is same with CNTL6[bit20] on G9TV/GXTVBB*/
+#define HHI_HDMI_PLL_CNTL5			    0x10cd
 
 
 /* #define VI_HIST_CTRL                             0x2e00 */
diff --git a/drivers/amlogic/amvecm/dolby_vision/dolby_vision.h b/drivers/amlogic/amvecm/dolby_vision/dolby_vision.h
new file mode 100644
index 0000000..13b0d3e
--- /dev/null
+++ b/drivers/amlogic/amvecm/dolby_vision/dolby_vision.h
@@ -0,0 +1,274 @@
+#ifndef _DV_H_
+#define _DV_H_
+
+#include <linux/types.h>
+
+#define DEF_G2L_LUT_SIZE_2P        8
+#define DEF_G2L_LUT_SIZE           (1 << DEF_G2L_LUT_SIZE_2P)
+
+enum signal_format_e {
+	FORMAT_DOVI  = 0,
+	FORMAT_HDR10 = 1,
+	FORMAT_SDR   = 2
+};
+
+enum priority_mode_e {
+	VIDEO_PRIORITY = 0,
+	GRAPHIC_PRIORITY = 1
+};
+
+enum cp_signal_range_e {
+	SIG_RANGE_SMPTE = 0,  /* head range */
+	SIG_RANGE_FULL  = 1,  /* full range */
+	SIG_RANGE_SDI   = 2           /* PQ */
+};
+
+struct composer_register_ipcore_s {
+	uint32_t Composer_Mode;
+	uint32_t VDR_Resolution;
+	uint32_t Bit_Depth;
+	uint32_t Coefficient_Log2_Denominator;
+	uint32_t BL_Num_Pivots_Y;
+	uint32_t BL_Pivot[5];
+	uint32_t BL_Order;
+	uint32_t BL_Coefficient_Y[8][3];
+	uint32_t EL_NLQ_Offset_Y;
+	uint32_t EL_Coefficient_Y[3];
+	uint32_t Mapping_IDC_U;
+	uint32_t BL_Num_Pivots_U;
+	uint32_t BL_Pivot_U[3];
+	uint32_t BL_Order_U;
+	uint32_t BL_Coefficient_U[4][3];
+	uint32_t MMR_Coefficient_U[22][2];
+	uint32_t MMR_Order_U;
+	uint32_t EL_NLQ_Offset_U;
+	uint32_t EL_Coefficient_U[3];
+	uint32_t Mapping_IDC_V;
+	uint32_t BL_Num_Pivots_V;
+	uint32_t BL_Pivot_V[3];
+	uint32_t BL_Order_V;
+	uint32_t BL_Coefficient_V[4][3];
+	uint32_t MMR_Coefficient_V[22][2];
+	uint32_t MMR_Order_V;
+	uint32_t EL_NLQ_Offset_V;
+	uint32_t EL_Coefficient_V[3];
+};
+
+/** @brief DM registers for IPCORE 1 */
+struct dm_register_ipcore_1_s {
+	uint32_t SRange;
+	uint32_t Srange_Inverse;
+	uint32_t Frame_Format_1;
+	uint32_t Frame_Format_2;
+	uint32_t Frame_Pixel_Def;
+	uint32_t Y2RGB_Coefficient_1;
+	uint32_t Y2RGB_Coefficient_2;
+	uint32_t Y2RGB_Coefficient_3;
+	uint32_t Y2RGB_Coefficient_4;
+	uint32_t Y2RGB_Coefficient_5;
+	uint32_t Y2RGB_Offset_1;
+	uint32_t Y2RGB_Offset_2;
+	uint32_t Y2RGB_Offset_3;
+	uint32_t EOTF;
+	uint32_t A2B_Coefficient_1;
+	uint32_t A2B_Coefficient_2;
+	uint32_t A2B_Coefficient_3;
+	uint32_t A2B_Coefficient_4;
+	uint32_t A2B_Coefficient_5;
+	uint32_t C2D_Coefficient_1;
+	uint32_t C2D_Coefficient_2;
+	uint32_t C2D_Coefficient_3;
+	uint32_t C2D_Coefficient_4;
+	uint32_t C2D_Coefficient_5;
+	uint32_t C2D_Offset;
+	uint32_t Active_area_left_top;
+	uint32_t Active_area_bottom_right;
+};
+
+/** @brief DM registers for IPCORE 2 */
+struct dm_register_ipcore_2_s {
+	uint32_t SRange;
+	uint32_t Srange_Inverse;
+	uint32_t Y2RGB_Coefficient_1;
+	uint32_t Y2RGB_Coefficient_2;
+	uint32_t Y2RGB_Coefficient_3;
+	uint32_t Y2RGB_Coefficient_4;
+	uint32_t Y2RGB_Coefficient_5;
+	uint32_t Y2RGB_Offset_1;
+	uint32_t Y2RGB_Offset_2;
+	uint32_t Y2RGB_Offset_3;
+	uint32_t Frame_Format;
+	uint32_t EOTF;
+	uint32_t A2B_Coefficient_1;
+	uint32_t A2B_Coefficient_2;
+	uint32_t A2B_Coefficient_3;
+	uint32_t A2B_Coefficient_4;
+	uint32_t A2B_Coefficient_5;
+	uint32_t C2D_Coefficient_1;
+	uint32_t C2D_Coefficient_2;
+	uint32_t C2D_Coefficient_3;
+	uint32_t C2D_Coefficient_4;
+	uint32_t C2D_Coefficient_5;
+	uint32_t C2D_Offset;
+	uint32_t VDR_Resolution;
+};
+
+/** @brief DM registers for IPCORE 3 */
+struct dm_register_ipcore_3_s {
+	uint32_t D2C_coefficient_1;
+	uint32_t D2C_coefficient_2;
+	uint32_t D2C_coefficient_3;
+	uint32_t D2C_coefficient_4;
+	uint32_t D2C_coefficient_5;
+	uint32_t B2A_Coefficient_1;
+	uint32_t B2A_Coefficient_2;
+	uint32_t B2A_Coefficient_3;
+	uint32_t B2A_Coefficient_4;
+	uint32_t B2A_Coefficient_5;
+	uint32_t Eotf_param_1;
+	uint32_t Eotf_param_2;
+	uint32_t IPT_Scale;
+	uint32_t IPT_Offset_1;
+	uint32_t IPT_Offset_2;
+	uint32_t IPT_Offset_3;
+	uint32_t Output_range_1;
+	uint32_t Output_range_2;
+	uint32_t RGB2YUV_coefficient_register1;
+	uint32_t RGB2YUV_coefficient_register2;
+	uint32_t RGB2YUV_coefficient_register3;
+	uint32_t RGB2YUV_coefficient_register4;
+	uint32_t RGB2YUV_coefficient_register5;
+	uint32_t RGB2YUV_offset_0;
+	uint32_t RGB2YUV_offset_1;
+	uint32_t RGB2YUV_offset_2;
+};
+
+/** @brief DM luts for IPCORE 1 and 2 */
+struct dm_lut_ipcore_s {
+	uint32_t TmLutI[64*4];
+	uint32_t TmLutS[64*4];
+	uint32_t SmLutI[64*4];
+	uint32_t SmLutS[64*4];
+	uint32_t G2L[DEF_G2L_LUT_SIZE];
+};
+
+/** @brief hdmi metadata for IPCORE 3 */
+struct md_reister_ipcore_3_s {
+	uint32_t raw_metadata[128];
+	uint32_t size;
+};
+
+struct hdr_10_infoframe_s {
+	uint8_t infoframe_type_code;
+	uint8_t infoframe_version_number;
+	uint8_t length_of_info_frame;
+	uint8_t data_byte_1;
+	uint8_t data_byte_2;
+	uint8_t display_primaries_x_0_LSB;
+	uint8_t display_primaries_x_0_MSB;
+	uint8_t display_primaries_y_0_LSB;
+	uint8_t display_primaries_y_0_MSB;
+	uint8_t display_primaries_x_1_LSB;
+	uint8_t display_primaries_x_1_MSB;
+	uint8_t display_primaries_y_1_LSB;
+	uint8_t display_primaries_y_1_MSB;
+	uint8_t display_primaries_x_2_LSB;
+	uint8_t display_primaries_x_2_MSB;
+	uint8_t display_primaries_y_2_LSB;
+	uint8_t display_primaries_y_2_MSB;
+	uint8_t white_point_x_LSB;
+	uint8_t white_point_x_MSB;
+	uint8_t white_point_y_LSB;
+	uint8_t white_point_y_MSB;
+	uint8_t max_display_mastering_luminance_LSB;
+	uint8_t max_display_mastering_luminance_MSB;
+	uint8_t min_display_mastering_luminance_LSB;
+	uint8_t min_display_mastering_luminance_MSB;
+	uint8_t max_content_light_level_LSB;
+	uint8_t max_content_light_level_MSB;
+	uint8_t max_frame_average_light_level_LSB;
+	uint8_t max_frame_average_light_level_MSB;
+};
+
+struct hdr10_param_s {
+	uint32_t min_display_mastering_luminance;
+	uint32_t max_display_mastering_luminance;
+	uint16_t Rx;
+	uint16_t Ry;
+	uint16_t Gx;
+	uint16_t Gy;
+	uint16_t Bx;
+	uint16_t By;
+	uint16_t Wx;
+	uint16_t Wy;
+	uint16_t max_content_light_level;
+	uint16_t max_pic_average_light_level;
+};
+
+struct dovi_setting_s {
+	struct composer_register_ipcore_s comp_reg;
+	struct dm_register_ipcore_1_s dm_reg1;
+	struct dm_register_ipcore_2_s dm_reg2;
+	struct dm_register_ipcore_3_s dm_reg3;
+	struct dm_lut_ipcore_s dm_lut1;
+	struct dm_lut_ipcore_s dm_lut2;
+	/* for dovi output */
+	struct md_reister_ipcore_3_s md_reg3;
+	/* for hdr10 output */
+	struct hdr_10_infoframe_s hdr_info;
+	/* current process */
+	enum signal_format_e src_format;
+	enum signal_format_e dst_format;
+	/* uint32_t video_width; */
+	/* uint32_t video_height; */
+	/* el not available */
+	bool el_flag;
+	bool el_halfsize_flag;
+};
+
+extern int control_path(
+	enum signal_format_e in_format,
+	enum signal_format_e out_format,
+	char *in_comp, int in_comp_size,
+	char *in_md, int in_md_size,
+	enum priority_mode_e set_priority,
+	int set_bit_depth, int set_chroma_format, int set_yuv_range,
+	int set_graphic_min_lum, int set_graphic_max_lum,
+	int set_target_min_lum, int set_target_max_lum,
+	int set_no_el,
+	struct hdr10_param_s *hdr10_param,
+	struct dovi_setting_s *output);
+extern void *metadata_parser_init(void);
+extern int metadata_parser_reset(void);
+extern int metadata_parser_process(
+	char  *src_rpu, int rpu_len,
+	char  *dst_comp, int *comp_len,
+	char  *dst_md, int *md_len, bool src_eos);
+extern void metadata_parser_release(void);
+
+struct dolby_vision_func_s {
+	void * (*metadata_parser_init)(void);
+	int (*metadata_parser_reset)(void);
+	int (*metadata_parser_process)(
+	char  *src_rpu, int rpu_len,
+	char  *dst_comp, int *comp_len,
+	char  *dst_md, int *md_len, bool src_eos);
+	void (*metadata_parser_release)(void);
+	int (*control_path)(
+	enum signal_format_e in_format,
+	enum signal_format_e out_format,
+	char *in_comp, int in_comp_size,
+	char *in_md, int in_md_size,
+	enum priority_mode_e set_priority,
+	int set_bit_depth, int set_chroma_format, int set_yuv_range,
+	int set_graphic_min_lum, int set_graphic_max_lum,
+	int set_target_min_lum, int set_target_max_lum,
+	int set_no_el,
+	struct hdr10_param_s *hdr10_param,
+	struct dovi_setting_s *output);
+};
+
+extern int register_dv_functions(const struct dolby_vision_func_s *func);
+extern int unregister_dv_functions(void);
+
+#endif
diff --git a/drivers/amlogic/canvas/canvas.c b/drivers/amlogic/canvas/canvas.c
index 0be8693..fb2458c 100644
--- a/drivers/amlogic/canvas/canvas.c
+++ b/drivers/amlogic/canvas/canvas.c
@@ -207,26 +207,25 @@ int canvas_read_hw(u32 index, struct canvas_s *canvas)
 }
 EXPORT_SYMBOL(canvas_read_hw);
 
-static inline void canvas_lock(void)
-{
-	struct canvas_device_info *info = &canvas_info;
-	raw_local_save_flags(info->fiq_flag);
-	local_fiq_disable();
-	spin_lock_irqsave(&info->lock, info->flags);
-}
+#define canvas_lock(info, f, f2) do {\
+		spin_lock_irqsave(&info->lock, f);\
+		raw_local_save_flags(f2);\
+		local_fiq_disable();\
+	} while (0)
+
+#define canvas_unlock(info, f, f2) do {\
+		raw_local_irq_restore(f2);\
+		spin_unlock_irqrestore(&info->lock, f);\
+	} while (0)
+
 
-static inline void canvas_unlock(void)
-{
-	struct canvas_device_info *info = &canvas_info;
-	spin_unlock_irqrestore(&info->lock, info->flags);
-	raw_local_irq_restore(info->fiq_flag);
-}
 
 void canvas_config_ex(u32 index, ulong addr, u32 width, u32 height, u32 wrap,
 					  u32 blkmode, u32 endian)
 {
 	struct canvas_device_info *info = &canvas_info;
 	struct canvas_s *canvas;
+	unsigned long flags, fiqflags;
 	if (!CANVAS_VALID(index))
 		return;
 
@@ -236,7 +235,7 @@ void canvas_config_ex(u32 index, ulong addr, u32 width, u32 height, u32 wrap,
 		dump_stack();
 		return;
 	}
-	canvas_lock();
+	canvas_lock(info, flags, fiqflags);
 	canvas = &info->canvasPool[index];
 	canvas->addr = addr;
 	canvas->width = width;
@@ -245,11 +244,19 @@ void canvas_config_ex(u32 index, ulong addr, u32 width, u32 height, u32 wrap,
 	canvas->blkmode = blkmode;
 	canvas->endian = endian;
 	canvas_config_locked(index, canvas);
-	canvas_unlock();
+	canvas_unlock(info, flags, fiqflags);
 	return;
 }
 EXPORT_SYMBOL(canvas_config_ex);
 
+void canvas_config_config(u32 index, struct canvas_config_s *cfg)
+{
+	canvas_config_ex(index, cfg->phy_addr,
+		cfg->width, cfg->height, CANVAS_ADDR_NOWRAP,
+		cfg->block_mode, cfg->endian);
+}
+EXPORT_SYMBOL(canvas_config_config);
+
 void canvas_config(u32 index, ulong addr, u32 width, u32 height, u32 wrap,
 				   u32 blkmode)
 {
@@ -270,6 +277,7 @@ void canvas_copy(u32 src, u32 dst)
 	struct canvas_device_info *info = &canvas_info;
 	struct canvas_s *canvas_src = &info->canvasPool[src];
 	struct canvas_s *canvas_dst = &info->canvasPool[dst];
+	unsigned long flags, fiqflags;
 
 	if (!CANVAS_VALID(src) || !CANVAS_VALID(dst))
 		return;
@@ -282,7 +290,7 @@ void canvas_copy(u32 src, u32 dst)
 		return;
 	}
 
-	canvas_lock();
+	canvas_lock(info, flags, fiqflags);
 	canvas_dst->addr = canvas_src->addr;
 	canvas_dst->width = canvas_src->width;
 	canvas_dst->height = canvas_src->height;
@@ -292,7 +300,7 @@ void canvas_copy(u32 src, u32 dst)
 	canvas_dst->dataH = canvas_src->dataH;
 	canvas_dst->dataL = canvas_src->dataL;
 	canvas_config_locked(dst, canvas_dst);
-	canvas_unlock();
+	canvas_unlock(info, flags, fiqflags);
 	return;
 }
 EXPORT_SYMBOL(canvas_copy);
@@ -301,6 +309,7 @@ void canvas_update_addr(u32 index, u32 addr)
 {
 	struct canvas_device_info *info = &canvas_info;
 	struct canvas_s *canvas;
+	unsigned long flags, fiqflags;
 
 	if (!CANVAS_VALID(index))
 		return;
@@ -311,10 +320,10 @@ void canvas_update_addr(u32 index, u32 addr)
 		dump_stack();
 		return;
 	}
-	canvas_lock();
+	canvas_lock(info, flags, fiqflags);
 	canvas->addr = addr;
 	canvas_config_locked(index, canvas);
-	canvas_unlock();
+	canvas_unlock(info, flags, fiqflags);
 
 	return;
 }
diff --git a/drivers/amlogic/codec_mm/Makefile b/drivers/amlogic/codec_mm/Makefile
index de05c0c..d49013c 100644
--- a/drivers/amlogic/codec_mm/Makefile
+++ b/drivers/amlogic/codec_mm/Makefile
@@ -8,5 +8,6 @@
 ##########################################
 
 
-obj-$(CONFIG_AML_CODEC_MM)	+= codec_mm.o
+obj-$(CONFIG_AML_CODEC_MM)	+= codec_mm.o codec_mm_scatter.o
+obj-$(CONFIG_AML_CODEC_MM)	+= codec_mm_keeper.o
 
diff --git a/drivers/amlogic/codec_mm/codec_mm.c b/drivers/amlogic/codec_mm/codec_mm.c
index 372cad1..9898742 100644
--- a/drivers/amlogic/codec_mm/codec_mm.c
+++ b/drivers/amlogic/codec_mm/codec_mm.c
@@ -35,10 +35,16 @@
 #include <linux/dma-contiguous.h>
 
 #include <linux/amlogic/codec_mm/codec_mm.h>
+#include <linux/amlogic/codec_mm/codec_mm_scatter.h>
 
 #include "codec_mm_priv.h"
+#include "codec_mm_scatter_priv.h"
+#include "codec_mm_keeper_priv.h"
 
 #define TVP_POOL_NAME "TVP_POOL"
+#define CMA_RES_POOL_NAME "CMA_RES"
+
+
 
 #define RES_IS_MAPED
 
@@ -74,13 +80,27 @@ trace memory alloc/free info:0x20,
 */
 static u32 debug_mode;
 
+static u32 debug_sc_mode;
+u32 codec_mm_get_sc_debug_mode(void)
+{
+	return debug_sc_mode;
+}
+static u32 debug_keep_mode;
+u32 codec_mm_get_keep_debug_mode(void)
+{
+	return debug_keep_mode;
+}
+
+
 #define TVP_MAX_SLOT 8
-struct tvp_pool_mgt_s {
+struct extpool_mgt_s {
 	struct gen_pool *gen_pool[TVP_MAX_SLOT];
 	struct codec_mm_s *mm[TVP_MAX_SLOT];
 	int slot_num;
 	int default_size;
 	int default_4k_size;
+	int alloced_size;
+	int total_size;
 	spinlock_t lock;
 };
 
@@ -89,26 +109,29 @@ struct codec_mm_mgt_s {
 	struct device *dev;
 	struct list_head mem_list;
 	struct gen_pool *res_pool;
-	struct tvp_pool_mgt_s tvp_pool;
+	struct extpool_mgt_s tvp_pool;
+	struct extpool_mgt_s cma_res_pool;
 	struct reserved_mem rmem;
 	int total_codec_mem_size;
 	int total_alloced_size;
 	int total_cma_size;
 	int total_reserved_size;
-	int total_tvp_size;
 	int max_used_mem_size;
 
 	int alloced_res_size;
 	int alloced_cma_size;
 	int alloced_sys_size;
-	int alloced_tvp_size;
+	int alloced_for_sc_size;
+	int alloced_for_sc_cnt;
 
 	int alloc_from_sys_pages_max;
 	int enable_kmalloc_on_nomem;
 	int res_mem_flags;
-
+	int global_memid;
 	/*1:for 1080p,2:for 4k*/
 	int tvp_enable;
+	/*1:for 1080p,2:for 4k*/
+	int fastplay_enable;
 	spinlock_t lock;
 };
 
@@ -130,8 +153,8 @@ static struct codec_mm_mgt_s *get_mem_mgt(void)
 };
 
 
-static void *codec_mm_tvp_alloc(
-	struct tvp_pool_mgt_s *tvp_pool,
+static void *codec_mm_extpool_alloc(
+	struct extpool_mgt_s *tvp_pool,
 	void **from_pool, int size)
 {
 	int i = 0;
@@ -150,7 +173,7 @@ static void *codec_mm_tvp_alloc(
 	return NULL;
 }
 
-static void *codec_mm_tvp_free(struct gen_pool *from_pool,
+static void *codec_mm_extpool_free(struct gen_pool *from_pool,
 	void *handle, int size)
 {
 	gen_pool_free(from_pool,
@@ -159,6 +182,24 @@ static void *codec_mm_tvp_free(struct gen_pool *from_pool,
 }
 
 
+static int codec_mm_valid_mm_locked(struct codec_mm_s *mmhandle)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	struct codec_mm_s *mem;
+	int have_found = 0;
+
+	if (!list_empty(&mgt->mem_list)) {
+		list_for_each_entry(mem, &mgt->mem_list, list) {
+			if (mem == mmhandle) {
+				have_found =  1;
+				break;
+			}
+		}
+	}
+	return have_found;
+}
+
+
 /*
 have_space:
 1:	can alloced from reserved
@@ -177,18 +218,23 @@ static int codec_mm_alloc_pre_check_in(
 	int aligned_size = PAGE_ALIGN(need_size);
 	if (aligned_size <= mgt->total_reserved_size - mgt->alloced_res_size)
 		have_space |= 1;
+	if (aligned_size <= mgt->cma_res_pool.total_size -
+			mgt->cma_res_pool.alloced_size)
+		have_space |= 1;
+
 	if (aligned_size <= mgt->total_cma_size - mgt->alloced_cma_size)
 		have_space |= 2;
+
 	if (aligned_size/PAGE_SIZE <= mgt->alloc_from_sys_pages_max)
 		have_space |= 4;
-	if (aligned_size <= mgt->total_tvp_size - mgt->alloced_tvp_size)
+	if (aligned_size <= mgt->tvp_pool.total_size -
+			mgt->tvp_pool.alloced_size)
 		have_space |= 8;
 
 	if (flags & 1) {
 		have_space = have_space & 8;
 	}
 	if (debug_mode & 0xf) {
-		pr_info("codec mm is enabled debug_mode:%d\n", debug_mode);
 		have_space = have_space & (~(debug_mode & 1));
 		have_space = have_space & (~(debug_mode & 2));
 		have_space = have_space & (~(debug_mode & 4));
@@ -270,9 +316,31 @@ static int codec_mm_alloc_in(
 			}
 			try_alloced_from_sys = 1;
 		}
-		/*reserved first..*/
-		if (!try_cma_first && /*if cma first, ignore this alloc.*/
-			can_from_res &&
+		/*cma first.*/
+		if (try_cma_first && can_from_cma) {
+			/*
+				normal cma.
+			*/
+			mem->mem_handle = dma_alloc_from_contiguous(mgt->dev,
+					mem->page_count,
+					align_2n - PAGE_SHIFT);
+			mem->from_flags = AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA;
+			if (mem->mem_handle) {
+				mem->vbuffer = mem->mem_handle;
+				mem->phy_addr =
+				 page_to_phys((struct page *)mem->mem_handle);
+#ifdef CONFIG_ARM64
+				if (mem->flags & CODEC_MM_FLAGS_CMA_CLEAR) {
+					dma_clear_buffer(
+						(struct page *)mem->vbuffer,
+						mem->buffer_size);
+				}
+#endif
+				break;
+			}
+		}
+		/*reserved alloc..*/
+		if (can_from_res &&
 			(align_2n <= RESERVE_MM_ALIGNED_2N)) {
 			int aligned_buffer_size = ALIGN(mem->buffer_size,
 					(1 << RESERVE_MM_ALIGNED_2N));
@@ -289,8 +357,40 @@ static int codec_mm_alloc_in(
 			}
 			try_alloced_from_reserved = 1;
 		}
-		/*cma first..*/
+		/*can_from_res is reserved..*/
+		if (can_from_res) {
+			if (mgt->cma_res_pool.total_size > 0 &&
+				(mgt->cma_res_pool.alloced_size +
+					mem->buffer_size) <
+				mgt->cma_res_pool.total_size) {
+				/*
+				from cma res first.
+				*/
+				int aligned_buffer_size =
+					ALIGN(mem->buffer_size,
+						(1 << RESERVE_MM_ALIGNED_2N));
+				mem->mem_handle =
+					(void *)codec_mm_extpool_alloc(
+						&mgt->cma_res_pool,
+						&mem->from_ext,
+						aligned_buffer_size);
+				mem->from_flags =
+					AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA_RES;
+				if (mem->mem_handle) {
+					/*no vaddr for TVP MEMORY */
+					mem->vbuffer = NULL;
+					mem->phy_addr =
+						(unsigned long)mem->mem_handle;
+					mem->buffer_size = aligned_buffer_size;
+					break;
+				}
+			}
+
+		}
 		if (can_from_cma) {
+			/*
+				normal cma.
+			*/
 			mem->mem_handle = dma_alloc_from_contiguous(mgt->dev,
 					mem->page_count,
 					align_2n - PAGE_SHIFT);
@@ -309,31 +409,12 @@ static int codec_mm_alloc_in(
 				break;
 			}
 		}
-		/*reserved later.*/
-		if (!try_alloced_from_reserved &&
-			can_from_res &&
-			(align_2n <= RESERVE_MM_ALIGNED_2N)) {
-			int aligned_buffer_size = ALIGN(mem->buffer_size,
-					(1 << RESERVE_MM_ALIGNED_2N));
-			mem->mem_handle = (void *)gen_pool_alloc(mgt->res_pool,
-							aligned_buffer_size);
-			mem->from_flags =
-				AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED;
-			if (mem->mem_handle) {
-				/*default is no maped */
-				mem->vbuffer = NULL;
-				mem->phy_addr = (unsigned long)mem->mem_handle;
-				mem->buffer_size = aligned_buffer_size;
-				break;
-			}
-		}
-
 		if (can_from_tvp &&
 				align_2n <= RESERVE_MM_ALIGNED_2N) {
 			/* 64k,aligend */
 			int aligned_buffer_size = ALIGN(mem->buffer_size,
 					(1 << RESERVE_MM_ALIGNED_2N));
-			mem->mem_handle = (void *)codec_mm_tvp_alloc(
+			mem->mem_handle = (void *)codec_mm_extpool_alloc(
 					&mgt->tvp_pool,
 					&mem->from_ext,
 					aligned_buffer_size);
@@ -372,8 +453,12 @@ static int codec_mm_alloc_in(
 static void codec_mm_free_in(struct codec_mm_mgt_s *mgt,
 		struct codec_mm_s *mem)
 {
-	if (!(mem->flags & CODEC_MM_FLAGS_FOR_TVP_POOL))
+	if (!(mem->flags & CODEC_MM_FLAGS_FOR_LOCAL_MGR))
 		mgt->total_alloced_size -= mem->buffer_size;
+	if (mem->flags & CODEC_MM_FLAGS_FOR_SCATTER) {
+		mgt->alloced_for_sc_size -= mem->buffer_size;
+		mgt->alloced_for_sc_cnt--;
+	}
 
 	if (mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA) {
 		dma_release_from_contiguous(mgt->dev,
@@ -385,21 +470,27 @@ static void codec_mm_free_in(struct codec_mm_mgt_s *mgt,
 			(unsigned long)mem->mem_handle, mem->buffer_size);
 		mgt->alloced_res_size -= mem->buffer_size;
 	} else if (mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_TVP) {
-		codec_mm_tvp_free(
+		codec_mm_extpool_free(
 			(struct gen_pool *)mem->from_ext,
 			mem->mem_handle,
 			mem->buffer_size);
-		mgt->alloced_tvp_size -= mem->buffer_size;
+		mgt->tvp_pool.alloced_size -= mem->buffer_size;
 	} else if (mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_PAGES) {
-		__free_pages((struct page *)mem->mem_handle,
+		free_pages((unsigned long)mem->mem_handle,
 			get_order(mem->buffer_size));
 		mgt->alloced_sys_size -= mem->buffer_size;
+	} else if (mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA_RES) {
+		codec_mm_extpool_free(
+			(struct gen_pool *)mem->from_ext,
+			mem->mem_handle,
+			mem->buffer_size);
+		mgt->cma_res_pool.alloced_size -= mem->buffer_size;
 	}
 
 	return;
 }
 
-static struct codec_mm_s *codec_mm_alloc(const char *owner, int size,
+struct codec_mm_s *codec_mm_alloc(const char *owner, int size,
 		int align2n, int memflags)
 {
 	struct codec_mm_mgt_s *mgt = get_mem_mgt();
@@ -432,6 +523,14 @@ static struct codec_mm_s *codec_mm_alloc(const char *owner, int size,
 	mem->align2n = align2n;
 	mem->flags = memflags;
 	ret = codec_mm_alloc_in(mgt, mem);
+	if (ret == -10003 &&
+		mgt->alloced_for_sc_cnt > 0 && /*have used for scatter.*/
+		!(memflags & CODEC_MM_FLAGS_FOR_SCATTER)) {
+		/*if not scatter, free scatter caches.*/
+		pr_err(" No mem ret=%d, clear scatter cache!!\n", ret);
+		codec_mm_scatter_free_all_ignorecache();
+		ret = codec_mm_alloc_in(mgt, mem);
+	}
 	if (ret < 0) {
 		pr_err("not enough mem for %s size %d, ret=%d\n",
 				owner, size, ret);
@@ -445,6 +544,7 @@ static struct codec_mm_s *codec_mm_alloc(const char *owner, int size,
 	mem->owner[0] = owner;
 	spin_lock_init(&mem->lock);
 	spin_lock_irqsave(&mgt->lock, flags);
+	mem->mem_id = mgt->global_memid++;
 	list_add_tail(&mem->list, &mgt->mem_list);
 	switch (mem->from_flags) {
 	case AMPORTS_MEM_FLAGS_FROM_GET_FROM_PAGES:
@@ -454,19 +554,26 @@ static struct codec_mm_s *codec_mm_alloc(const char *owner, int size,
 		mgt->alloced_cma_size += mem->buffer_size;
 		break;
 	case AMPORTS_MEM_FLAGS_FROM_GET_FROM_TVP:
-		mgt->alloced_tvp_size += mem->buffer_size;
+		mgt->tvp_pool.alloced_size += mem->buffer_size;
 		break;
 	case AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED:
 		mgt->alloced_res_size += mem->buffer_size;
 		break;
+	case AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA_RES:
+		mgt->cma_res_pool.alloced_size += mem->buffer_size;
+		break;
 	default:
 		pr_err("error alloc flags %d\n", mem->from_flags);
 	}
-	if (!(mem->flags & CODEC_MM_FLAGS_FOR_TVP_POOL)) {
+	if (!(mem->flags & CODEC_MM_FLAGS_FOR_LOCAL_MGR)) {
 		mgt->total_alloced_size += mem->buffer_size;
 		if (mgt->total_alloced_size > mgt->max_used_mem_size)
 			mgt->max_used_mem_size = mgt->total_alloced_size;
 	}
+	if ((mem->flags & CODEC_MM_FLAGS_FOR_SCATTER)) {
+		mgt->alloced_for_sc_size += mem->buffer_size;
+		mgt->alloced_for_sc_cnt++;
+	}
 	spin_unlock_irqrestore(&mgt->lock, flags);
 	if (debug_mode & 0x20)
 		pr_err("%s alloc mem size %d at %lx from %d\n",
@@ -475,7 +582,7 @@ static struct codec_mm_s *codec_mm_alloc(const char *owner, int size,
 	return mem;
 }
 
-static void codec_mm_release(struct codec_mm_s *mem, const char *owner)
+void codec_mm_release(struct codec_mm_s *mem, const char *owner)
 {
 
 	int index;
@@ -509,6 +616,20 @@ static void codec_mm_release(struct codec_mm_s *mem, const char *owner)
 	return;
 }
 
+void codec_mm_release_with_check(struct codec_mm_s *mem, const char *owner)
+{
+	unsigned long flags;
+	int ret;
+	spin_lock_irqsave(&mem->lock, flags);
+	ret = codec_mm_valid_mm_locked(mem);
+	spin_unlock_irqrestore(&mem->lock, flags);
+	if (ret) {
+		/*for check,*/
+		return codec_mm_release(mem, owner);
+	}
+	return;
+}
+
 void codec_mm_dma_flush(void *vaddr,
 	int size,
 	enum dma_data_direction dir)
@@ -521,11 +642,27 @@ void codec_mm_dma_flush(void *vaddr,
 	return;
 }
 
+
 int codec_mm_request_shared_mem(struct codec_mm_s *mem, const char *owner)
 {
-	if (!mem || atomic_read(&mem->use_cnt) > 7)
-		return -1;
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	unsigned long flags;
+	int ret = -1;
+	spin_lock_irqsave(&mgt->lock, flags);
+	if (!codec_mm_valid_mm_locked(mem)) {
+		ret = -2;
+		goto out;
+	}
+	if (atomic_read(&mem->use_cnt) > 7) {
+		ret = -3;
+		goto out;
+	}
+	ret = 0;
 	mem->owner[atomic_inc_return(&mem->use_cnt) - 1] = owner;
+
+out:
+	spin_unlock_irqrestore(&mgt->lock, flags);
+
 	return 0;
 }
 
@@ -547,6 +684,8 @@ static struct codec_mm_s *codec_mm_get_by_val_off(unsigned long val, int off)
 	return want_mem;
 }
 
+
+
 unsigned long codec_mm_alloc_for_dma(const char *owner, int page_cnt,
 		int align2n, int memflags)
 {
@@ -570,7 +709,7 @@ int codec_mm_free_for_dma(const char *owner, unsigned long phy_addr)
 }
 
 static int codec_mm_init_tvp_pool(
-			struct tvp_pool_mgt_s *tvp_pool,
+			struct extpool_mgt_s *tvp_pool,
 			struct codec_mm_s *mm)
 {
 	struct gen_pool *pool;
@@ -590,24 +729,25 @@ static int codec_mm_init_tvp_pool(
 
 
 
-int codec_mm_tvp_before_alloc(int size, int memflags)
+int codec_mm_extpool_pool_alloc(
+	struct extpool_mgt_s *tvp_pool,
+	int size, int memflags, int for_tvp)
 {
 	struct codec_mm_mgt_s *mgt = get_mem_mgt();
-	struct tvp_pool_mgt_s *tvp_pool =  &mgt->tvp_pool;
 	struct codec_mm_s *mem;
-	int alloced_size = mgt->total_tvp_size;
+	int alloced_size = tvp_pool->alloced_size;
 	int try_alloced_size = size;
 	int ret;
 
 /*alloced from reserved*/
 	try_alloced_size = mgt->total_reserved_size - mgt->alloced_res_size;
-	if (try_alloced_size > 0) {
+	if (try_alloced_size > 0 && for_tvp) {
 		try_alloced_size = min_t(int,
 			size - alloced_size, try_alloced_size);
 		mem = codec_mm_alloc(TVP_POOL_NAME,
 					try_alloced_size,
 					0,
-					CODEC_MM_FLAGS_FOR_TVP_POOL |
+					CODEC_MM_FLAGS_FOR_LOCAL_MGR |
 					CODEC_MM_FLAGS_RESERVED);
 
 		if (mem) {
@@ -632,10 +772,13 @@ int codec_mm_tvp_before_alloc(int size, int memflags)
 	if (try_alloced_size > 0) {
 		try_alloced_size = min_t(int, size -
 				alloced_size, try_alloced_size);
-		mem = codec_mm_alloc(TVP_POOL_NAME,
+		mem = codec_mm_alloc(
+					for_tvp ?
+						TVP_POOL_NAME :
+						CMA_RES_POOL_NAME,
 					try_alloced_size,
 					0,
-					CODEC_MM_FLAGS_FOR_TVP_POOL |
+					CODEC_MM_FLAGS_FOR_LOCAL_MGR |
 					CODEC_MM_FLAGS_CMA);
 
 		if (mem) {
@@ -653,7 +796,7 @@ int codec_mm_tvp_before_alloc(int size, int memflags)
 
 alloced_finished:
 	if (alloced_size > 0) {
-		mgt->total_tvp_size = alloced_size;
+		tvp_pool->total_size = alloced_size;
 		return alloced_size;
 	}
 	return -1;
@@ -666,10 +809,9 @@ alloced TVP memory;
 it not free,some memory may free ignore.
 return :
 */
-static int codec_mm_tvp_after_release(void)
+static int codec_mm_extpool_pool_release(struct extpool_mgt_s *tvp_pool)
 {
 	struct codec_mm_mgt_s *mgt = get_mem_mgt();
-	struct tvp_pool_mgt_s *tvp_pool =  &mgt->tvp_pool;
 	int i;
 	int ignored = 0;
 
@@ -689,7 +831,7 @@ static int codec_mm_tvp_after_release(void)
 						TVP_POOL_NAME);
 			}
 		}
-		mgt->total_tvp_size -= slot_mem_size;
+		mgt->tvp_pool.total_size -= slot_mem_size;
 		tvp_pool->gen_pool[i] = NULL;
 		tvp_pool->mm[i] = NULL;
 	}
@@ -732,7 +874,7 @@ return n;
 static int codec_mm_tvp_get_mem_resource(ulong *res, int victor_size)
 {
 	struct codec_mm_mgt_s *mgt = get_mem_mgt();
-	struct tvp_pool_mgt_s *tvp_pool =  &mgt->tvp_pool;
+	struct extpool_mgt_s *tvp_pool =  &mgt->tvp_pool;
 	int i;
 
 	for (i = 0; i < tvp_pool->slot_num && i < victor_size/2; i++) {
@@ -748,7 +890,7 @@ static int codec_mm_tvp_get_mem_resource(ulong *res, int victor_size)
 static int codec_mm_is_in_tvp_region(ulong phy_addr)
 {
 	struct codec_mm_mgt_s *mgt = get_mem_mgt();
-	struct tvp_pool_mgt_s *tvp_pool =  &mgt->tvp_pool;
+	struct extpool_mgt_s *tvp_pool =  &mgt->tvp_pool;
 	int i;
 	int in = 0, in2 = 0;
 
@@ -771,6 +913,8 @@ static int codec_mm_is_in_tvp_region(ulong phy_addr)
 void *codec_mm_phys_to_virt(unsigned long phy_addr)
 {
 	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	if (codec_mm_is_in_tvp_region(phy_addr))
+		return NULL;	/* no virt for tvp memory; */
 
 	if (phy_addr >= mgt->rmem.base &&
 			phy_addr < mgt->rmem.base + mgt->rmem.size) {
@@ -778,8 +922,7 @@ void *codec_mm_phys_to_virt(unsigned long phy_addr)
 			return phys_to_virt(phy_addr);
 		return NULL;	/* no virt for reserved memory; */
 	}
-	if (codec_mm_is_in_tvp_region(phy_addr))
-		return NULL;	/* no virt for tvp memory; */
+
 	return phys_to_virt(phy_addr);
 }
 
@@ -815,7 +958,7 @@ static int dump_mem_infos(void *buf, int size)
 	s = sprintf(pbuf, "\tCMA:%d,RES:%d,TVP:%d,SYS:%d MB\n",
 		mgt->alloced_cma_size / SZ_1M,
 		mgt->alloced_res_size / SZ_1M,
-		mgt->alloced_tvp_size / SZ_1M,
+		mgt->tvp_pool.alloced_size / SZ_1M,
 		mgt->alloced_sys_size / SZ_1M);
 	tsize += s;
 	pbuf += s;
@@ -844,10 +987,21 @@ static int dump_mem_infos(void *buf, int size)
 		s = sprintf(pbuf,
 			"\t[%d]TVP size:%d MB,alloced:%d MB free:%d MB\n",
 				AMPORTS_MEM_FLAGS_FROM_GET_FROM_TVP,
-				(int)(mgt->total_tvp_size / SZ_1M),
-				(int)(mgt->alloced_tvp_size / SZ_1M),
-				(int)((mgt->total_tvp_size -
-				mgt->alloced_tvp_size) / SZ_1M));
+				(int)(mgt->tvp_pool.total_size / SZ_1M),
+				(int)(mgt->tvp_pool.alloced_size / SZ_1M),
+				(int)((mgt->tvp_pool.total_size -
+				mgt->tvp_pool.alloced_size) / SZ_1M));
+		tsize += s;
+		pbuf += s;
+	}
+	if (mgt->cma_res_pool.slot_num > 0) {
+		s = sprintf(pbuf,
+			"\t[%d]CMA_RES size:%d MB,alloced:%d MB free:%d MB\n",
+				AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA_RES,
+				(int)(mgt->cma_res_pool.total_size / SZ_1M),
+				(int)(mgt->cma_res_pool.alloced_size / SZ_1M),
+				(int)((mgt->cma_res_pool.total_size -
+				mgt->cma_res_pool.alloced_size) / SZ_1M));
 		tsize += s;
 		pbuf += s;
 	}
@@ -865,17 +1019,21 @@ static int dump_mem_infos(void *buf, int size)
 	}
 	list_for_each_entry(mem, &mgt->mem_list, list) {
 		s = sprintf(pbuf,
-		"\towner: %s:%s,addr=%p,s=%d,from=%d,cnt=%d\n",
+		"\towner:[%d] %s:%s,addr=%p,s=%d,from=%d,cnt=%d\n",
+		mem->mem_id,
 		mem->owner[0] ? mem->owner[0] : "no",
 		mem->owner[1] ? mem->owner[1] : "no",
 		(void *)mem->phy_addr,
 		mem->buffer_size, mem->from_flags,
 		atomic_read(&mem->use_cnt));
 
-		if (buf)
+		if (buf) {
 			pbuf += s;
-		else
+			if (tsize + s > size - 128)
+				break;/*no memory for dump now.*/
+		} else {
 			pr_info("%s", sbuf);
+		}
 		tsize += s;
 	}
 	spin_unlock_irqrestore(&mgt->lock, flags);
@@ -892,14 +1050,34 @@ int codec_mm_video_tvp_enabled(void)
 int codec_mm_get_total_size(void)
 {
 	struct codec_mm_mgt_s *mgt = get_mem_mgt();
-	return mgt->total_codec_mem_size;
+	int total_size = mgt->total_codec_mem_size;
+	if ((debug_mode & 0xf) == 0) {/*no debug memory mode.*/
+		return total_size;
+	}
+	/*
+	disable reserved:1
+	disable cma:2
+	disable sys memory:4
+	disable half memory:8,
+	*/
+	if (debug_mode & 0x8)
+		total_size -=  mgt->total_codec_mem_size/2;
+	if (debug_mode & 0x1) {
+		total_size -= mgt->total_reserved_size;
+		total_size -= mgt->cma_res_pool.total_size;
+	}
+	if (debug_mode & 0x2)
+		total_size -=  mgt->total_cma_size;
+	if (total_size < 0)
+		total_size = 0;
+	return total_size;
 }
 
 int codec_mm_get_free_size(void)
 {
 	struct codec_mm_mgt_s *mgt = get_mem_mgt();
-	return mgt->total_codec_mem_size -
-	mgt->total_alloced_size;
+	return codec_mm_get_total_size() -
+		mgt->total_alloced_size;
 }
 
 int codec_mm_get_reserved_size(void)
@@ -907,12 +1085,22 @@ int codec_mm_get_reserved_size(void)
 	struct codec_mm_mgt_s *mgt = get_mem_mgt();
 	return mgt->total_reserved_size;
 }
-
-int codec_mm_enough_for_size(int size)
+/*
+with_wait:
+1: if no mem, do wait and free some cache.
+0: do not wait.
+*/
+int codec_mm_enough_for_size(int size, int with_wait)
 {
 	struct codec_mm_mgt_s *mgt = get_mem_mgt();
 	int have_mem = codec_mm_alloc_pre_check_in(mgt, size, 0);
-	if (!have_mem) {
+	if (!have_mem && with_wait && mgt->alloced_for_sc_cnt > 0) {
+		pr_err(" No mem, clear scatter cache!!\n");
+		codec_mm_scatter_free_all_ignorecache();
+		have_mem = codec_mm_alloc_pre_check_in(mgt, size, 0);
+		if (have_mem)
+			return 1;
+
 		if (debug_mode & 0x20)
 			dump_mem_infos(NULL, 0);
 		return 0;
@@ -922,7 +1110,6 @@ int codec_mm_enough_for_size(int size)
 
 
 
-
 int codec_mm_mgt_init(struct device *dev)
 {
 
@@ -955,9 +1142,15 @@ int codec_mm_mgt_init(struct device *dev)
 	}
 	mgt->total_cma_size = dma_get_cma_size_int_byte(mgt->dev);
 	mgt->total_codec_mem_size += mgt->total_cma_size;
-	mgt->tvp_pool.default_size = mgt->total_reserved_size + SZ_1M*32;
 	/*2M for audio not protect.*/
 	mgt->tvp_pool.default_4k_size = mgt->total_codec_mem_size - SZ_1M * 2;
+	/*97MB -> 160MB, may not enough for h265*/
+	mgt->tvp_pool.default_size = mgt->total_codec_mem_size > SZ_1M * 160 ?
+			SZ_1M * 160 : mgt->tvp_pool.default_4k_size;
+
+	mgt->cma_res_pool.default_size = mgt->total_cma_size;
+	mgt->cma_res_pool.default_4k_size = mgt->total_cma_size;
+	mgt->global_memid = 0;
 	spin_lock_init(&mgt->lock);
 	return 0;
 }
@@ -1025,7 +1218,21 @@ static ssize_t codec_mm_dump_show(struct class *class,
 	ret = dump_mem_infos(buf, PAGE_SIZE);
 	return ret;
 }
+static ssize_t codec_mm_scatter_dump_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	size_t ret;
+	ret = codec_mm_scatter_info_dump(buf, PAGE_SIZE);
+	return ret;
+}
 
+static ssize_t codec_mm_keeper_dump_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	size_t ret;
+	ret = codec_mm_keeper_dump_info(buf, PAGE_SIZE);
+	return ret;
+}
 
 static ssize_t tvp_enable_help_show(struct class *class,
 		struct class_attribute *attr,
@@ -1055,21 +1262,74 @@ static ssize_t tvp_enable_store(struct class *class,
 	ret = sscanf(buf, "%d", &val);
 	if (ret != 1)
 		return -EINVAL;
+	/*
+	always free all scatter cache for
+	tvp changes.
+	*/
+	codec_mm_keeper_free_all_keep(2);
+	codec_mm_scatter_free_all_ignorecache();
 	switch (val) {
 	case 0:
-		ret = codec_mm_tvp_after_release();
+		ret = codec_mm_extpool_pool_release(&mgt->tvp_pool);
 		mgt->tvp_enable = 0;
-		pr_err("disalbe tvp\n");
+		pr_info("disalbe tvp\n");
 		break;
 	case 1:
-		codec_mm_tvp_before_alloc(mgt->tvp_pool.default_size, 0);
+		codec_mm_extpool_pool_alloc(
+			&mgt->tvp_pool,
+			mgt->tvp_pool.default_size, 0, 1);
 		mgt->tvp_enable = 1;
-		pr_err("enable tvp for 1080p\n");
+		pr_info("enable tvp for 1080p\n");
 		break;
 	case 2:
-		codec_mm_tvp_before_alloc(mgt->tvp_pool.default_4k_size, 0);
+		codec_mm_extpool_pool_alloc(
+			&mgt->tvp_pool,
+			mgt->tvp_pool.default_4k_size, 0, 1);
 		mgt->tvp_enable = 2;
-		pr_err("enable tvp for 4k\n");
+		pr_info("enable tvp for 4k\n");
+		break;
+	default:
+		pr_err("unknow cmd! %d\n", val);
+	}
+	return size;
+}
+
+static ssize_t fastplay_enable_help_show(struct class *class,
+		struct class_attribute *attr,
+		char *buf)
+{
+	ssize_t size = 0;
+	size += sprintf(buf, "fastplay enable help:\n");
+	size += sprintf(buf + size, "echo n > tvp_enable\n");
+	size += sprintf(buf + size, "0: disable fastplay\n");
+	size += sprintf(buf + size,
+	"1: enable fastplay for 1080p playing(use default size)\n");
+	return size;
+}
+
+static ssize_t fastplay_enable_store(struct class *class,
+		struct class_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	unsigned val;
+	ssize_t ret;
+	val = -1;
+	ret = sscanf(buf, "%d", &val);
+	if (ret != 1)
+		return -EINVAL;
+	switch (val) {
+	case 0:
+		ret = codec_mm_extpool_pool_release(&mgt->cma_res_pool);
+		mgt->fastplay_enable = 0;
+		pr_err("disalbe fastplay\n");
+		break;
+	case 1:
+		codec_mm_extpool_pool_alloc(
+			&mgt->cma_res_pool,
+			mgt->cma_res_pool.default_4k_size, 0, 0);
+		mgt->fastplay_enable = 1;
+		pr_err("enable fastplay\n");
 		break;
 	default:
 		pr_err("unknow cmd! %d\n", val);
@@ -1082,6 +1342,7 @@ static ssize_t tvp_enable_store(struct class *class,
 
 
 
+
 static ssize_t codec_mm_config_show(struct class *class,
 	struct class_attribute *attr, char *buf)
 {
@@ -1095,6 +1356,7 @@ static ssize_t codec_mm_config_show(struct class *class,
 		"default_tvp_4k_size:0x%x(%d MB)\n",
 		mgt->tvp_pool.default_4k_size,
 		mgt->tvp_pool.default_4k_size / SZ_1M);
+	ret += codec_mm_scatter_mgt_get_config(buf + ret);
 	return ret;
 }
 
@@ -1115,7 +1377,7 @@ static ssize_t codec_mm_config_store(struct class *class,
 		mgt->tvp_pool.default_4k_size = val;
 		return size;
 	}
-	return -1;
+	return codec_mm_scatter_mgt_set_config(buf, size);
 }
 
 static ssize_t tvp_region_show(struct class *class,
@@ -1138,16 +1400,152 @@ static ssize_t tvp_region_show(struct class *class,
 	return off;
 }
 
+static ssize_t codec_mm_debug_show(struct class *class,
+		struct class_attribute *attr,
+		char *buf)
+{
+	ssize_t size = 0;
+	size += sprintf(buf, "mm_scatter help:\n");
+	size += sprintf(buf + size, "echo n > mm_scatter_debug\n");
+	size += sprintf(buf + size, "n==0: clear all debugs)\n");
+	size += sprintf(buf + size,
+	"n=1: dump all alloced scatters\n");
+	size += sprintf(buf + size,
+	"n=2: dump all slots\n");
+
+	size += sprintf(buf + size,
+	"n=3: dump all free slots\n");
+
+	size += sprintf(buf + size,
+	"n=4: dump all sid hash table\n");
+
+	size += sprintf(buf + size,
+	"n=5: free all free slot now!\n");
+
+	size += sprintf(buf + size,
+	"n=6: clear all time infos!\n");
+
+	size += sprintf(buf + size,
+	"n=10: force free all keeper\n");
+
+	size += sprintf(buf + size,
+	"n=20: dump memory,# 20 #addr(hex) #len\n");
+
+	size += sprintf(buf + size,
+	"n==100: cmd mode p1 p ##mode:0,dump, 1,alloc 2,more,3,free some,4,free all\n");
+	return size;
+}
+
+static int codec_mm_mem_dump(unsigned long addr, int isphy, int len)
+{
+	void *vaddr;
+	int is_map = 0;
+	pr_info("start dump addr: %p %d\n", (void *)addr, len);
+	if (!isphy) {
+		vaddr = (void *)addr;
+	} else {
+		vaddr = ioremap_nocache(
+					addr, len);
+		if (!vaddr) {
+			pr_info("map addr: %p len: %d, failed\n",
+				(void *)addr, len);
+			vaddr = codec_mm_phys_to_virt(addr);
+		} else {
+			is_map = 1;
+		}
+	}
+	if (vaddr) {
+		unsigned int *p, *vint;
+		int i;
+		vint = (unsigned int *)vaddr;
+		for (i = 0; i <= len - 32; i += sizeof(int) * 8) {
+			p = (int *)&vint[i];
+			pr_info("%p: %08x %08x %08x %08x %08x %08x %08x %08x\n",
+			p,
+			p[0], p[1], p[2], p[3],
+			p[4], p[5], p[6], p[7]);
+		}
+	}
+	if (vaddr && is_map) {
+		/*maped free...*/
+		iounmap(vaddr);
+	}
+	return 0;
+}
 
+static ssize_t codec_mm_debug_store(struct class *class,
+		struct class_attribute *attr,
+		const char *buf, size_t size)
+{
+	unsigned val;
+	ssize_t ret;
+	val = -1;
+	ret = sscanf(buf, "%d", &val);
+	if (ret != 1)
+		return -EINVAL;
+	switch (val) {
+	case 0:
+		pr_info("clear debug!\n");
+		break;
+	case 1:
+		codec_mm_dump_all_scatters();
+		break;
+	case 2:
+		codec_mm_dump_all_slots();
+		break;
+	case 3:
+		codec_mm_dump_free_slots();
+		break;
+	case 4:
+		codec_mm_dump_all_hash_table();
+		break;
+	case 5:
+		codec_mm_free_all_free_slots();
+		break;
+	case 6:
+		codec_mm_clear_alloc_infos();
+		break;
+	case 10:
+		codec_mm_keeper_free_all_keep(1);
+		break;
+	case 20: {
+		int cmd, len;
+		unsigned int addr;
+		cmd = len = 0;
+		addr = 0;
+		ret = sscanf(buf, "%d %x %d", &cmd, &addr, &len);
+		if (addr > 0 && len > 0)
+			codec_mm_mem_dump(addr, 1, len);
+		}
+		break;
+	case 100: {
+		int cmd, mode, p1, p2;
+		mode = p1 = p2 = 0;
+		ret = sscanf(buf, "%d %d %d %d", &cmd, &mode, &p1, &p2);
+		codec_mm_scatter_test(mode, p1, p2);
+		}
+		break;
+	default:
+		pr_err("unknow cmd! %d\n", val);
+	}
+	return size;
+
+}
 
 
 static struct class_attribute codec_mm_class_attrs[] = {
 	__ATTR_RO(codec_mm_dump),
+	__ATTR_RO(codec_mm_scatter_dump),
+	__ATTR_RO(codec_mm_keeper_dump),
 	__ATTR_RO(tvp_region),
 	__ATTR(tvp_enable, S_IRUGO | S_IWUSR | S_IWGRP,
 		tvp_enable_help_show, tvp_enable_store),
+	__ATTR(fastplay_enable, S_IRUGO | S_IWUSR | S_IWGRP,
+		fastplay_enable_help_show, fastplay_enable_store),
 	__ATTR(config, S_IRUGO | S_IWUSR | S_IWGRP,
 		codec_mm_config_show, codec_mm_config_store),
+	__ATTR(debug, S_IRUGO | S_IWUSR | S_IWGRP,
+		codec_mm_debug_show, codec_mm_debug_store),
 	__ATTR_NULL
 };
 
@@ -1176,8 +1574,11 @@ static int codec_mm_probe(struct platform_device *pdev)
 		pr_debug("codec_mm reserved memory probed done\n");
 
 	pr_debug("codec_mm_probe ok\n");
-	amstream_test_init();
 
+	codec_mm_scatter_mgt_init();
+	codec_mm_keeper_mgr_init();
+	amstream_test_init();
+	codec_mm_scatter_mgt_test();
 	return 0;
 }
 
@@ -1274,4 +1675,9 @@ RESERVEDMEM_OF_DECLARE(codec_mm_reserved, "amlogic, codec-mm-reserved",
 
 module_param(debug_mode, uint, 0664);
 MODULE_PARM_DESC(debug_mode, "\n debug module\n");
+module_param(debug_sc_mode, uint, 0664);
+MODULE_PARM_DESC(debug_sc_mode, "\n debug scatter module\n");
+module_param(debug_keep_mode, uint, 0664);
+MODULE_PARM_DESC(debug_keep_mode, "\n debug keep module\n");
+
 
diff --git a/drivers/amlogic/codec_mm/codec_mm_keeper.c b/drivers/amlogic/codec_mm/codec_mm_keeper.c
new file mode 100644
index 0000000..248581e
--- /dev/null
+++ b/drivers/amlogic/codec_mm/codec_mm_keeper.c
@@ -0,0 +1,276 @@
+/*
+ * drivers/amlogic/codec_mm/codec_mm_keeper.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/genalloc.h>
+#include <linux/amlogic/codec_mm/codec_mm.h>
+#include <linux/amlogic/codec_mm/codec_mm_scatter.h>
+#include <linux/amlogic/codec_mm/codec_mm_keeper.h>
+
+#include <linux/workqueue.h>
+#include "codec_mm_priv.h"
+#include "codec_mm_scatter_priv.h"
+#define KEEP_NAME "keeper"
+#define MAX_KEEP_FRAME 4
+#define START_KEEP_ID 0x9
+#define MAX_KEEP_ID    (INT_MAX - 1)
+
+struct keep_mem_info {
+	void *handle;
+	int keep_id;
+	int type;
+	int user;
+	u64 delay_on_jiffies64;
+};
+
+struct codec_mm_keeper_mgr {
+	int num;
+	spinlock_t lock;
+	struct delayed_work dealy_work;
+	int work_runs;
+	struct keep_mem_info keep_list[MAX_KEEP_FRAME];
+	int next_id;		/*id for keep & free. */
+};
+
+static struct codec_mm_keeper_mgr codec_keeper_mgr_private;
+static struct codec_mm_keeper_mgr *get_codec_mm_keeper_mgr(void)
+{
+	return &codec_keeper_mgr_private;
+}
+
+/*
+not call in interrupt;
+*/
+int codec_mm_keeper_mask_keep_mem(void *mem_handle, int type)
+{
+	struct codec_mm_keeper_mgr *mgr = get_codec_mm_keeper_mgr();
+	int keep_id = -1;
+	int i;
+	unsigned long flags;
+	int ret;
+	int slot_i = -1;
+	int have_samed = 0;
+	if (codec_mm_get_keep_debug_mode() & 1)
+		pr_err("codec_mm_keeper_mask_keep_mem %p\n", mem_handle);
+	if (!mem_handle) {
+		pr_err("NULL mem_handle for keeper!!\n");
+		return -2;
+	}
+	if (type != MEM_TYPE_CODEC_MM_SCATTER &&
+		type != MEM_TYPE_CODEC_MM) {
+		pr_err("not valid type for keeper!!,%d\n", type);
+		return -3;
+	}
+	if (type == MEM_TYPE_CODEC_MM_SCATTER) {
+		ret = codec_mm_scatter_inc_for_keeper(mem_handle);
+		if (ret < 0) {
+			pr_err("keeper scatter failed,%d,handle:%p\n",
+				ret, mem_handle);
+			if (codec_mm_get_keep_debug_mode() & 1)
+				codec_mm_dump_all_scatters();
+			return -4;
+		}
+	} else if (type == MEM_TYPE_CODEC_MM) {
+		ret = codec_mm_request_shared_mem(mem_handle, KEEP_NAME);
+		if (ret < 0) {
+			pr_err("keeper codec mm failed,%d,handle:%p\n",
+				ret, mem_handle);
+			return -4;
+		}
+	}
+	spin_lock_irqsave(&mgr->lock, flags);
+	keep_id = mgr->next_id++;
+	if (mgr->next_id >= MAX_KEEP_ID)
+		mgr->next_id = START_KEEP_ID;
+	for (i = 0; i < MAX_KEEP_FRAME; i++) {
+		if (!mgr->keep_list[i].handle && slot_i < 0)
+			slot_i = i;
+		else if (mgr->keep_list[i].handle == mem_handle) {
+			have_samed = 1;
+			keep_id = mgr->keep_list[i].keep_id;
+			break;
+		}
+	}
+	if (slot_i >= 0 && !have_samed) {
+		mgr->keep_list[slot_i].handle = mem_handle;
+		mgr->keep_list[slot_i].keep_id = keep_id;
+		mgr->keep_list[slot_i].type = type;
+		mgr->keep_list[slot_i].user = 1;
+		mgr->num++;
+	} else {
+		if (!have_samed)
+			keep_id = -1;
+	}
+	if (keep_id < 0 || have_samed) {
+		if (type == MEM_TYPE_CODEC_MM_SCATTER)
+			ret = codec_mm_scatter_dec_keeper_user(mem_handle, 0);
+		else if (type == MEM_TYPE_CODEC_MM)
+			codec_mm_release_with_check(mem_handle, KEEP_NAME);
+		if (keep_id < 0)
+			pr_err("keep mem failed because keep buffer fulled!!!\n");
+	}
+	spin_unlock_irqrestore(&mgr->lock, flags);
+	if (codec_mm_get_keep_debug_mode() & 1) {
+		/*keeped info*/
+		pr_err("codec_mm_keeper_mask_keep_mem %p id=%d\n",
+			mem_handle, keep_id);
+	}
+	return keep_id;
+}
+
+/*
+can call in irq
+*/
+int codec_mm_keeper_unmask_keeper(int keep_id, int delayms)
+{
+	struct codec_mm_keeper_mgr *mgr = get_codec_mm_keeper_mgr();
+	int i;
+	unsigned long flags;
+	if (codec_mm_get_keep_debug_mode() & 1)
+		pr_err("codec_mm_keeper_unmask_keeper %d\n", keep_id);
+	if (keep_id < START_KEEP_ID || keep_id >= MAX_KEEP_ID) {
+		pr_err("invalid keepid %d\n", keep_id);
+		return -1;
+	}
+	spin_lock_irqsave(&mgr->lock, flags);
+	for (i = 0; i < MAX_KEEP_FRAME; i++) {
+		if (keep_id == mgr->keep_list[i].keep_id) {
+			mgr->keep_list[i].user--;/*mask can free. */
+			mgr->keep_list[i].delay_on_jiffies64 =
+				get_jiffies_64() + delayms * HZ/1000;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&mgr->lock, flags);
+	schedule_delayed_work(&mgr->dealy_work, delayms);/*do free later, */
+	return 0;
+}
+
+static int codec_mm_keeper_free_keep(int index)
+{
+	struct codec_mm_keeper_mgr *mgr = get_codec_mm_keeper_mgr();
+	void *mem_handle = NULL;
+	int type;
+	unsigned long flags;
+	spin_lock_irqsave(&mgr->lock, flags);
+	mem_handle = mgr->keep_list[index].handle;
+	type = mgr->keep_list[index].type;
+	mgr->keep_list[index].handle = NULL;
+	mgr->keep_list[index].delay_on_jiffies64 = 0;
+	mgr->num--;
+	spin_unlock_irqrestore(&mgr->lock, flags);
+	if (!mem_handle)
+		return -1;
+	if (type == MEM_TYPE_CODEC_MM)
+		codec_mm_release_with_check(mem_handle, KEEP_NAME);
+	else if (type == MEM_TYPE_CODEC_MM_SCATTER) {
+		struct codec_mm_scatter *sc = mem_handle;
+		codec_mm_scatter_dec_keeper_user(sc, 0);
+	}
+
+	return 0;
+}
+
+/*
+can't call it
+in irq/timer.tasklet
+*/
+int codec_mm_keeper_free_all_keep(int force)
+{
+	struct codec_mm_keeper_mgr *mgr = get_codec_mm_keeper_mgr();
+	int i;
+	int time_after, want_free;
+	for (i = 0; i < MAX_KEEP_FRAME; i++) {
+		struct keep_mem_info *info = &mgr->keep_list[i];
+		if (!info->handle || info->keep_id < 0)
+			continue;
+		want_free = 0;
+		time_after = time_after64(get_jiffies_64(),
+				info->delay_on_jiffies64);
+		if (force == 1)
+			want_free = 1;
+		else if (force == 2 && info->user <= 0)
+			want_free = 1;
+		else if (info->user <= 0 && time_after)
+			want_free = 1;
+
+		if (want_free)
+			codec_mm_keeper_free_keep(i);
+	}
+
+	return 0;
+}
+
+int codec_mm_keeper_dump_info(void *buf, int size)
+{
+	struct codec_mm_keeper_mgr *mgr = get_codec_mm_keeper_mgr();
+	char *pbuf = buf;
+	char sbuf[512];
+	int tsize = 0;
+	int s;
+	int i;
+	if (!pbuf)
+		pbuf = sbuf;
+#define BUFPRINT(args...) \
+		do {\
+			s = sprintf(pbuf, args);\
+			tsize += s;\
+			pbuf += s;\
+		} while (0)\
+
+	BUFPRINT("dump keep list:next_id=%d,work_run:%d,num=%d\n",
+			mgr->next_id,
+			mgr->work_runs,
+			mgr->num);
+	for (i = 0; i < MAX_KEEP_FRAME; i++) {
+		BUFPRINT("keeper:[%d]:\t\tid:%d\thandle:%p,type:%d,user:%d\n",
+			i,
+			mgr->keep_list[i].keep_id,
+			mgr->keep_list[i].handle,
+			mgr->keep_list[i].type,
+			mgr->keep_list[i].user);
+	}
+#undef BUFPRINT
+	if (!buf)
+		pr_info("%s", sbuf);
+	return tsize;
+}
+
+static void codec_mm_keeper_monitor(struct work_struct *work)
+{
+	struct codec_mm_keeper_mgr *mgr = container_of(work,
+					struct codec_mm_keeper_mgr,
+					dealy_work.work);
+	mgr->work_runs++;
+	codec_mm_keeper_free_all_keep(0);
+	if (mgr->num > 0) /*have some not free, run later.*/
+		schedule_delayed_work(&mgr->dealy_work, 10);
+}
+
+int codec_mm_keeper_mgr_init(void)
+{
+	struct codec_mm_keeper_mgr *mgr = get_codec_mm_keeper_mgr();
+	memset(mgr, 0, sizeof(struct codec_mm_keeper_mgr));
+	mgr->next_id = START_KEEP_ID;
+	spin_lock_init(&mgr->lock);
+	INIT_DELAYED_WORK(&mgr->dealy_work, codec_mm_keeper_monitor);
+	return 0;
+}
diff --git a/drivers/amlogic/codec_mm/codec_mm_keeper_priv.h b/drivers/amlogic/codec_mm/codec_mm_keeper_priv.h
new file mode 100644
index 0000000..5e33b8a
--- /dev/null
+++ b/drivers/amlogic/codec_mm/codec_mm_keeper_priv.h
@@ -0,0 +1,25 @@
+/*
+ * drivers/amlogic/codec_mm/codec_mm_keeper_priv.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef CODEC_MM_KEEP_PRIV_HEADER
+#define CODEC_MM_KEEP_PRIV_HEADER
+int codec_mm_keeper_mgr_init(void);
+int codec_mm_keeper_dump_info(void *buf, int size);
+int codec_mm_keeper_free_all_keep(int force);
+
+#endif
+
diff --git a/drivers/amlogic/codec_mm/codec_mm_priv.h b/drivers/amlogic/codec_mm/codec_mm_priv.h
index dbaa12d..00081ad 100644
--- a/drivers/amlogic/codec_mm/codec_mm_priv.h
+++ b/drivers/amlogic/codec_mm/codec_mm_priv.h
@@ -51,51 +51,12 @@
 
 
 
+extern void dma_clear_buffer(struct page *page, size_t size);
 
-struct codec_mm_s {
-
-	/*can be shared by many user */
-	const char *owner[8];
-
-	/*virtual buffer of this memory */
-	char *vbuffer;
-
-	void *mem_handle;	/*used for top level.alloc/free */
-	void *from_ext;		/*alloced from pool*/
-	ulong phy_addr;		/*if phy continue or one page only */
-
-	int buffer_size;
-
-	int page_count;
-
-	int align2n;
-
-	/*if vbuffer is no cache set
-	   AMPORTS_MEM_FLAGS_NOCACHED  to flags */
-#define AMPORTS_MEM_FLAGS_NOCACHED (1<<0)
-	/*phy continue,need dma
-	 */
-#define AMPORTS_MEM_FLAGS_DMA (1<<1)
-	int flags;
-
-#define AMPORTS_MEM_FLAGS_FROM_SYS 1
-#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_PAGES 2
-#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED 3
-#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA 4
-#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_TVP 5
-
-	int from_flags;
+u32 codec_mm_get_sc_debug_mode(void);
+u32 codec_mm_get_keep_debug_mode(void);
 
-	/*may can be shared on many user..
-	   decoder/di/ppmgr,
-	 */
-	atomic_t use_cnt;
 
-	spinlock_t lock;
 
-	struct list_head list;
+#endif/**/
 
-};
-extern void dma_clear_buffer(struct page *page, size_t size);
-#endif				/*
-				 */
diff --git a/drivers/amlogic/codec_mm/codec_mm_scatter.c b/drivers/amlogic/codec_mm/codec_mm_scatter.c
new file mode 100644
index 0000000..ac21efc
--- /dev/null
+++ b/drivers/amlogic/codec_mm/codec_mm_scatter.c
@@ -0,0 +1,2461 @@
+/*
+ * drivers/amlogic/codec_mm/codec_mm_scatter.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/dma-contiguous.h>
+#include <linux/cma.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/libfdt_env.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <linux/genalloc.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-contiguous.h>
+#include <linux/amlogic/codec_mm/codec_mm.h>
+#include <linux/amlogic/codec_mm/codec_mm_scatter.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+
+#include "codec_mm_priv.h"
+#include "codec_mm_scatter_priv.h"
+
+#define SCATTER_MEM "SCATTER_MEM"
+
+/*#define PHY_ADDR_NEED_64BITS*/
+#if PAGE_SHIFT >= 12
+#define SID_MASK 0xfff
+#elif PAGE_SHIFT >= 8
+#define SID_MASK 0xff
+#else
+#error "unsupport PAGE_SHIFT PAGE_SHIFT must >= 8" ## PAGE_SHIFT
+#endif
+
+#define MAX_ADDR_SHIFT PAGE_SHIFT
+#define MAX_SID (SID_MASK - 1)
+#define MAX_HASH_SID (MAX_SID - 1)
+
+#define ADDR_SEED(paddr) (((paddr) >> (MAX_ADDR_SHIFT << 1)) +\
+					((paddr) >> MAX_ADDR_SHIFT) +\
+					(paddr))
+/*
+hash ID: 0-MAX_HASH_SID
+ONE_PAGE_SID: MAX_SID
+*/
+#define HASH_PAGE_ADDR(paddr) (ADDR_SEED(paddr) % MAX_SID)
+#define SLOT_TO_SID(slot)	HASH_PAGE_ADDR(((slot->phy_addr)>>PAGE_SHIFT))
+
+#define ONE_PAGE_SID (SID_MASK)
+#define PAGE_SID(mm_page)  (page_sid_type)((mm_page) & SID_MASK)
+#define PAGE_ADDR(mm_page) (ulong)(((mm_page) >> MAX_ADDR_SHIFT)\
+			<< MAX_ADDR_SHIFT)
+
+#define ADDR2PAGE(addr, sid)	(((addr) & (~SID_MASK)) | (sid))
+
+#define PAGE_SID_OF_MMS(mms, id) PAGE_SID((mms)->pages_list[id])
+#define PAGE_ADDR_OF_MMS(mms, id) PAGE_ADDR((mms)->pages_list[id])
+
+#define INVALID_ID(mms, id) (!(mms) ||\
+					!(mms)->pages_list ||\
+					(mms)->page_cnt <= (id) ||\
+					(id) < 0)
+
+#define SID_OF_ONEPAGE(sid)	   ((sid) == ONE_PAGE_SID)
+#define ADDR2BIT(base, addr)  (((addr) - (base)) >> PAGE_SHIFT)
+#define BIT2ADDR(base, bit)   ((base) + (1<<PAGE_SHIFT) * (bit))
+#define VALID_SID(sid) (((sid) < MAX_SID) || SID_OF_ONEPAGE(sid))
+#define VALID_BIT(slot, bit) (bit >= 0 && ((slot->pagemap_size << 3) > bit))
+#define CODEC_MM_S_ERR(x) ((-1000) - (x))
+
+/*#define SCATTER_DEBUG*/
+#define ERR_LOG(args...) pr_err(args)
+#define WAR_LOG(args...) pr_warn(args)
+#define INFO_LOG(args...) pr_info(args)
+
+#ifdef SCATTER_DEBUG
+#define DBG_LOG(args...) pr_info(args)
+#else
+#define DBG_LOG(args...)
+#endif
+#define MAX_SYS_BLOCK_PAGE 128
+#define MIN_SYS_BLOCK_PAGE 8
+
+/*#define USE_KMALLOC_FOR_SCATTER
+*/
+#ifdef USE_KMALLOC_FOR_SCATTER
+#define SC_ALLOC(s, f) kmalloc(s, f)
+#define SC_FREE(p) kfree(p)
+#else
+#define SC_ALLOC(s, f) vmalloc(s)
+#define SC_FREE(p) vfree(p)
+
+#endif
+#define MAX_SC_LIST 64
+struct codec_mm_scatter_mgt {
+	struct codec_mm_slot *slot_list_map[MAX_SID];
+	int codec_mm_num;
+	int total_page_num;
+	int alloced_page_num;
+	int max_alloced;
+	int try_alloc_in_cma_page_cnt;
+	int try_alloc_in_sys_page_cnt;
+	int try_alloc_in_sys_page_cnt_max;
+	int try_alloc_in_sys_page_cnt_min;
+	int alloc_from_cma_first;
+	int enable_slot_from_sys;
+	int no_cache_size_M;
+	int support_from_slot_sys;
+	int one_page_cnt;
+	int scatters_cnt;
+	int slot_cnt;
+	int reserved_block_mm_M;
+	int keep_size_PAGE;
+
+	int alloc_from_sys_sc_cnt;
+	int alloc_from_sys_page_cnt;
+	int alloc_from_sys_max_page_cnt;
+
+	int delay_free_on;
+	int force_cache_on;
+	int force_cache_page_cnt;
+	u64 delay_free_timeout_jiffies64;
+
+/*time states*/
+	int alloc_max_us;
+	u64 alloc_total_us;
+	int alloc_cnt;
+	int alloc_10us_less_cnt;
+	int alloc_10_50us_cnt;
+	int alloc_50_100us_cnt;
+	int alloc_100_1000us_cnt;
+	int alloc_1_10ms_cnt;
+	int alloc_10_100ms_cnt;
+	int alloc_100ms_up_cnt;
+
+	struct delayed_work dealy_work;
+	int scatter_task_run_num;
+	struct codec_mm_scatter *cache_sc;
+	int cached_pages;
+	spinlock_t list_lock;
+	struct mutex monitor_lock;
+	struct list_head free_list;	/*slot */
+	struct list_head scatter_list;	/*scatter list */
+	struct codec_mm_scatter *scmap[MAX_SC_LIST];/*used for valid check.*/
+};
+
+
+
+static struct codec_mm_scatter_mgt *scatter_mgt;
+
+static struct codec_mm_scatter_mgt *codec_mm_get_scatter_mgt(void)
+{
+	return scatter_mgt;
+}
+/*#define MY_MUTEX_DEBUG*/
+#ifdef MY_MUTEX_DEBUG
+#define codec_mm_scatter_lock(s) \
+	codec_mm_scatter_lock_debug(s, __LINE__)
+
+#define codec_mm_list_lock(s) \
+	codec_mm_list_lock_debug(s, __LINE__)
+
+static inline int mutex_trylock_time(
+	struct mutex *lock, int wait)
+{
+	unsigned long timeout = jiffies + wait;
+	int locked = mutex_trylock(lock);
+	while (!locked && time_before(jiffies, timeout)) {
+		msleep(20);
+		locked = mutex_trylock(lock);
+	}
+	return locked;
+}
+
+#define TRY_MLOCK_INFO(lock, line, time, info)\
+		static int last_lock_line;\
+		while (!mutex_trylock_time((lock), time)) {\
+			pr_err(info " mutex has lock on %d,new lock on %d\n",\
+			last_lock_line, line);\
+		} \
+		last_lock_line = line;\
+
+
+static inline int spin_trylock_time(
+			spinlock_t *lock, int wait)
+{
+	unsigned long timeout = jiffies + wait;
+	int locked = spin_trylock(lock);
+	while (!locked && time_before(jiffies, timeout)) {
+		msleep(20);
+		locked = spin_trylock(lock);
+	}
+	return locked;
+}
+
+#define TRY_SLOCK_INFO(lock, line, time, info)\
+		static int last_lock_line;\
+		while (!spin_trylock_time((lock), time)) {\
+			pr_err(info " spin has lock on %d,new lock on %d\n",\
+			last_lock_line, line);\
+		} \
+		last_lock_line = line;\
+
+
+static inline void codec_mm_scatter_lock_debug(
+	struct codec_mm_scatter *mms,
+	int line)
+{
+	TRY_MLOCK_INFO(&mms->mutex, line, 10 * HZ , "mms");
+}
+
+static inline void codec_mm_list_lock_debug(
+	struct codec_mm_scatter_mgt *smgt, int line)
+{
+	TRY_SLOCK_INFO(&smgt->list_lock, line, 10 * HZ , "list");
+}
+#else
+static inline void codec_mm_scatter_lock(
+	struct codec_mm_scatter *mms)
+{
+	mutex_lock(&mms->mutex);
+}
+static inline void codec_mm_list_lock(
+	struct codec_mm_scatter_mgt *smgt)
+{
+	spin_lock(&smgt->list_lock);
+}
+#endif
+static inline void codec_mm_scatter_unlock(
+	struct codec_mm_scatter *mms)
+{
+	mutex_unlock(&mms->mutex);
+}
+
+static inline void codec_mm_list_unlock(
+	struct codec_mm_scatter_mgt *smgt)
+{
+	spin_unlock(&smgt->list_lock);
+}
+
+static int codec_mm_scatter_alloc_want_pages_in(
+		struct codec_mm_scatter *mms,
+		int want_pages);
+
+static struct workqueue_struct *codec_mm_scatter_wq_get(void)
+{
+	static struct workqueue_struct *codec_mm_scatter;
+	if (!codec_mm_scatter)
+		codec_mm_scatter = create_singlethread_workqueue("codec_mm_sc");
+	return codec_mm_scatter;
+}
+
+
+static int codec_mm_schedule_delay_work(int delay_ms, int for_update)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	bool ret;
+	if (!for_update && delayed_work_pending(&smgt->dealy_work))
+		return 0;
+	if (delayed_work_pending(&smgt->dealy_work))
+		cancel_delayed_work(&smgt->dealy_work);
+	if (codec_mm_scatter_wq_get()) {
+		ret = queue_delayed_work(codec_mm_scatter_wq_get(),
+			&smgt->dealy_work, delay_ms * HZ / 1000);
+	} else
+		ret = schedule_delayed_work(&smgt->dealy_work,
+			delay_ms * HZ / 1000);
+	return ret;
+}
+
+static inline u64 codec_mm_get_current_us(void)
+{
+	struct timeval  tv;
+	do_gettimeofday(&tv);
+	return div64_u64(timeval_to_ns(&tv), 1000);
+}
+
+static void codec_mm_update_alloc_time(u64 startus)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	int spend_time_us;
+
+	spend_time_us = (int)(codec_mm_get_current_us() - startus);
+	if (spend_time_us > 0 && spend_time_us < 100000000) {
+		/*	>0 && less than 100s
+			else think time base changed.
+		*/
+		smgt->alloc_cnt++;
+		if (spend_time_us < 10)
+			smgt->alloc_10us_less_cnt++;
+		else if (spend_time_us < 50)
+			smgt->alloc_10_50us_cnt++;
+		else if (spend_time_us < 100)
+			smgt->alloc_50_100us_cnt++;
+		else if (spend_time_us < 1000)
+			smgt->alloc_100_1000us_cnt++;
+		else if (spend_time_us < 10000)
+			smgt->alloc_1_10ms_cnt++;
+		else if (spend_time_us < 100000)
+			smgt->alloc_10_100ms_cnt++;
+		else
+			smgt->alloc_100ms_up_cnt++;
+
+		smgt->alloc_total_us += spend_time_us;
+		if (spend_time_us > smgt->alloc_max_us) {
+			/*..*/
+			smgt->alloc_max_us  = spend_time_us;
+		}
+	}
+}
+
+void codec_mm_clear_alloc_infos(void)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	smgt->alloc_cnt = 0;
+	smgt->alloc_10us_less_cnt = 0;
+	smgt->alloc_10_50us_cnt = 0;
+	smgt->alloc_50_100us_cnt = 0;
+	smgt->alloc_100_1000us_cnt = 0;
+	smgt->alloc_1_10ms_cnt = 0;
+	smgt->alloc_10_100ms_cnt = 0;
+	smgt->alloc_100ms_up_cnt = 0;
+	smgt->alloc_total_us = 0;
+	smgt->alloc_max_us = 0;
+	return;
+}
+
+
+static int codec_mm_set_slot_in_hash(struct codec_mm_slot *slot)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+
+	page_sid_type sid = SLOT_TO_SID(slot);
+	if (sid < 0 || sid > MAX_SID) {
+		ERR_LOG("ERROR sid %d", sid);
+		return -1;
+	}
+	slot->sid = sid;
+	INIT_LIST_HEAD(&slot->sid_list);
+	INIT_LIST_HEAD(&slot->free_list);
+	codec_mm_list_lock(smgt);
+	if (!smgt->slot_list_map[sid]) {
+		smgt->slot_list_map[sid] = slot;
+		slot->isroot = 1;
+	} else {
+		struct codec_mm_slot *f_slot = smgt->slot_list_map[sid];
+		list_add_tail(&slot->sid_list, &f_slot->sid_list);
+		slot->isroot = 0;
+	}
+	smgt->total_page_num += slot->page_num;
+	smgt->slot_cnt++;
+	if (slot->from_type == SLOT_FROM_GET_FREE_PAGES) {
+		smgt->alloc_from_sys_sc_cnt++;
+		smgt->alloc_from_sys_page_cnt += slot->page_num;
+		if (smgt->alloc_from_sys_page_cnt >
+				smgt->alloc_from_sys_max_page_cnt)
+			smgt->alloc_from_sys_max_page_cnt =
+				smgt->alloc_from_sys_page_cnt;
+	}
+	list_add_tail(&slot->free_list, &smgt->free_list);
+	codec_mm_list_unlock(smgt);
+	return 0;
+}
+
+static struct codec_mm_slot *codec_mm_find_slot_in_hash(
+	page_sid_type sid, ulong addr)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	struct codec_mm_slot *fslot, *slot;
+
+	if (!VALID_SID(sid))
+		return NULL;
+	codec_mm_list_lock(smgt);
+	fslot = smgt->slot_list_map[sid];
+	if (!fslot) {
+		ERR_LOG("not valid sid %d\n",
+			(int)sid);
+		goto err;
+	}
+	slot = fslot;
+	while (!(addr >= slot->phy_addr &&	/*optimization with hash? */
+			 addr <
+			 (slot->phy_addr +
+			(slot->page_num << PAGE_SHIFT)))) {
+		/*not in range. */
+
+		slot = list_entry(slot->sid_list.prev,
+					struct codec_mm_slot, sid_list);
+		/*
+		   pr_err("Slot range from =%p->%p\n",
+		   (void *)slot->phy_addr,
+		   (void *)slot->phy_addr +
+		   (slot->page_num << PAGE_SHIFT));
+		 */
+		if (slot == fslot) {
+			ERR_LOG("can't find valid slot, for addr =%p\n",
+					(void *)addr);
+			goto err;
+		}
+	}
+	codec_mm_list_unlock(smgt);
+	return slot;
+err:
+	codec_mm_list_unlock(smgt);
+	return NULL;
+}
+
+static int codec_mm_slot_free(struct codec_mm_slot *slot)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	int ret = 0;
+	codec_mm_list_lock(smgt);
+	if (slot->alloced_page_num > 0 || slot->on_alloc_free) {
+		codec_mm_list_unlock(smgt);
+		return -1;
+	}
+	if (!list_empty(&slot->free_list))
+			list_del(&slot->free_list);
+	if (!list_empty(&slot->sid_list)) {
+		if (slot->isroot) {
+			struct codec_mm_slot *next_slot;
+			next_slot = list_entry(slot->sid_list.next,
+					struct codec_mm_slot, sid_list);
+			next_slot->isroot = 1;
+			smgt->slot_list_map[slot->sid] = next_slot;
+		}
+		list_del(&slot->sid_list);
+	} else {/*no sid list,clear map*/
+		smgt->slot_list_map[slot->sid] = NULL;
+	}
+	smgt->slot_cnt--;
+	smgt->total_page_num -= slot->page_num;
+	if (slot->from_type == SLOT_FROM_GET_FREE_PAGES) {
+		smgt->alloc_from_sys_sc_cnt--;
+		smgt->alloc_from_sys_page_cnt -= slot->page_num;
+	}
+	codec_mm_list_unlock(smgt);
+	switch (slot->from_type) {
+	case SLOT_FROM_CODEC_MM:
+		if (slot->mm)
+			codec_mm_release(slot->mm, SCATTER_MEM);
+		else
+			ERR_LOG("ERR:slot->mm is ERROR:%p\n", slot->mm);
+		break;
+	case SLOT_FROM_GET_FREE_PAGES:
+		if (slot->page_header != 0)
+			free_pages(slot->page_header,
+				get_order(PAGE_SIZE * slot->page_num));
+		else
+			ERR_LOG("ERR:slot->page_header is ERROR:%p\n",
+			(void *)slot->page_header);
+		break;
+	/*other */
+	default:
+		ERR_LOG("unknow from type:%d\n", slot->from_type);
+		ret = -1;
+	}
+
+	kfree(slot->pagemap);
+	kfree(slot);
+	return 0;
+}
+static int codec_mm_slot_try_free(struct codec_mm_slot *slot)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+
+	if (smgt->keep_size_PAGE > 0) {
+		/*delay free, when size < delay_free_M MB*/
+		int free_pages  = smgt->total_page_num - smgt->alloced_page_num;
+		if (free_pages < smgt->keep_size_PAGE)
+			return -1;
+	}
+	return codec_mm_slot_free(slot);
+}
+
+static inline int  codec_mm_slot_init_bitmap(struct codec_mm_slot *slot)
+{
+	slot->alloced_page_num = 0;
+	/*bytes = 8bits for 8 pages.
+	   1 more for less than 8 page.
+	   another for reserved.
+	*/
+	slot->pagemap_size = (slot->page_num >> 3) + 2;
+	slot->pagemap = kmalloc(slot->pagemap_size, GFP_KERNEL);
+	if (!slot->pagemap) {
+		ERR_LOG("ERROR.init pagemap failed\n");
+		return -1;
+	}
+	memset(slot->pagemap, 0, slot->pagemap_size);
+	slot->next_bit = 0;
+	return 0;
+}
+/*
+flags : 1. don't used codecmm.
+*/
+static struct codec_mm_slot *codec_mm_slot_alloc(int size, int flags)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	struct codec_mm_slot *slot;
+	struct codec_mm_s *mm;
+	int try_alloc_size = size;
+	int have_alloced = 0;
+	if (try_alloc_size > 0 && try_alloc_size <= PAGE_SIZE)
+		return NULL;	/*don't alloc less than one PAGE. */
+	slot = kmalloc(sizeof(struct codec_mm_slot), GFP_KERNEL);
+	if (!slot)
+		return NULL;
+	memset(slot, 0, sizeof(struct codec_mm_slot));
+	do {
+		if (flags & 1)
+			break;/*ignore codec_mm*/
+		if ((try_alloc_size <= 0 ||
+			try_alloc_size > 64 * 1024) &&	/*must > 512K. */
+			codec_mm_get_free_size() >
+			smgt->reserved_block_mm_M * SZ_1M) {
+			/*try from codec_mm */
+			if (try_alloc_size <= 0) {
+				try_alloc_size =
+					smgt->try_alloc_in_cma_page_cnt *
+					PAGE_SIZE;
+			}
+			if (codec_mm_get_free_size() < try_alloc_size)
+				try_alloc_size = codec_mm_get_free_size();
+			mm = codec_mm_alloc(SCATTER_MEM, try_alloc_size, 0,
+					CODEC_MM_FLAGS_CMA_FIRST |
+					CODEC_MM_FLAGS_FOR_VDECODER |
+					CODEC_MM_FLAGS_FOR_SCATTER);
+			if (mm != NULL) {
+				slot->from_type = SLOT_FROM_CODEC_MM;
+				slot->mm = mm;
+				slot->page_num = mm->page_count;
+				slot->phy_addr = mm->phy_addr;
+				codec_mm_slot_init_bitmap(slot);
+				if (slot->pagemap == NULL) {
+					codec_mm_release(mm, SCATTER_MEM);
+					break;	/*try next. */
+				}
+				have_alloced = 1;
+				DBG_LOG("alloced from codec mm %d!!!\n",
+					slot->page_num);
+			}
+		}
+	} while (0);
+	if (!have_alloced && !smgt->support_from_slot_sys) {
+		/*not enabled from sys*/
+		goto error;
+	}
+	if (!have_alloced) {	/*init for sys alloc */
+		if (size <= 0)
+			try_alloc_size =
+				smgt->try_alloc_in_sys_page_cnt << PAGE_SHIFT;
+		else
+			try_alloc_size = PAGE_ALIGN(size);
+		if (try_alloc_size <= PAGE_SIZE << 1) {
+			DBG_LOG("try too small %d, try one page now,\n",
+				try_alloc_size);
+			goto error;	/*don't alloc 1 page with slot. */
+		}
+	}
+	if (!have_alloced && codec_mm_video_tvp_enabled()) {
+		/*tvp not support alloc from sys.*/
+		goto error;
+	}
+	while (!have_alloced) {
+		/*don't alloc 1 page with slot. */
+		/*try alloc from sys. */
+		int page_order = get_order(try_alloc_size);
+		slot->page_header = __get_free_pages(
+			__GFP_IO | __GFP_NOWARN | __GFP_NORETRY,
+			page_order);
+		if (!slot->page_header) {
+			if ((try_alloc_size >> (PAGE_SHIFT + 1)) >=
+				smgt->try_alloc_in_sys_page_cnt_min) {
+				try_alloc_size = try_alloc_size >> 1;
+				smgt->try_alloc_in_sys_page_cnt =
+					try_alloc_size >> PAGE_SHIFT;
+				continue;	/*try less block memory. */
+			} else {
+				/*disabled from sys
+				may auto enabled when free more.
+				*/
+				smgt->support_from_slot_sys = 0;
+				ERR_LOG("alloc sys failed size =%d!!!\n",
+					try_alloc_size);
+				goto error;
+			}
+		}
+		slot->from_type = SLOT_FROM_GET_FREE_PAGES;
+		slot->mm = NULL;
+		slot->page_num = 1 << page_order;
+		slot->phy_addr =
+			virt_to_phys((unsigned long *)slot->page_header);
+		codec_mm_slot_init_bitmap(slot);
+		if (slot->pagemap == NULL) {
+			free_pages(slot->page_header, page_order);
+			goto error;
+		}
+		have_alloced = 1;
+		break;
+	}
+	codec_mm_set_slot_in_hash(slot);
+
+	return slot;
+error:
+	kfree(slot);
+	return NULL;
+}
+
+static int codec_mm_slot_free_page(struct codec_mm_slot *slot, ulong phy_addr)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	int bit;
+
+	if (!slot || !slot->pagemap || slot->page_num <= 0)
+		return CODEC_MM_S_ERR(4);
+
+	bit = ADDR2BIT(slot->phy_addr, phy_addr);
+	if (!VALID_BIT(slot, bit))
+		return CODEC_MM_S_ERR(5);	/*!!!out of page map.!! */
+	codec_mm_list_lock(smgt);
+	slot->on_alloc_free++;
+	if (!test_and_clear_bit(bit, slot->pagemap)) {
+		ERR_LOG("ERROR,page is ready free before!!! page=%p\n",
+			(void *)phy_addr);
+		slot->on_alloc_free--;
+		codec_mm_list_unlock(smgt);
+		return CODEC_MM_S_ERR(6);
+	}
+	slot->alloced_page_num--;
+	slot->on_alloc_free--;
+	codec_mm_list_unlock(smgt);
+	return 0;
+}
+
+static int codec_mm_slot_alloc_pages(struct codec_mm_slot *slot,
+		phy_addr_type  *pages, int num)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	int alloced = 0;
+	int need = num;
+	int can_alloced;
+	phy_addr_type page;
+	int tryn = slot->page_num;
+	int i;
+
+	if (!slot || !slot->pagemap)
+		return -1;
+	if (slot->alloced_page_num >= slot->page_num)
+		return -2;
+	can_alloced = slot->page_num - slot->alloced_page_num;
+	need = need > can_alloced ? can_alloced : need;
+	i = slot->next_bit;
+	/*if not one alloc free. quit this one*/
+	while (need > 0 && (slot->on_alloc_free == 1)) {
+		if (!VALID_BIT(slot, i)) {
+			ERR_LOG("ERROR alloc in slot %p\n",
+					slot);
+			ERR_LOG("\ti=%d,slot->pagemap=%p\n",
+					i,
+					slot->pagemap);
+			break;
+		}
+		codec_mm_list_lock(smgt);
+		if (!test_and_set_bit(i, slot->pagemap)) {
+			page = ADDR2PAGE(BIT2ADDR(slot->phy_addr, i),
+						slot->sid);
+			slot->alloced_page_num++;
+			pages[alloced] = page;
+			alloced++;
+			need--;
+		}
+		codec_mm_list_unlock(smgt);
+		i++;
+		if (i >= slot->page_num)
+			i = 0;
+		if (--tryn <= 0)
+			break;
+	}
+	slot->next_bit = i;
+	if (i >= slot->page_num)
+		slot->next_bit = 0;
+	DBG_LOG("alloced from %p, %d,%d,%d\n",
+			slot, slot->page_num,
+			slot->alloced_page_num, alloced);
+	return alloced;
+}
+
+static inline phy_addr_type codec_mm_get_page_addr(
+		struct codec_mm_scatter *mms,
+		int id)
+{
+	phy_addr_type page;
+	if (INVALID_ID(mms, id))
+		return 0;
+	page = mms->pages_list[id];
+	return PAGE_ADDR(page);
+}
+
+static inline page_sid_type codec_mm_get_page_sid(
+		struct codec_mm_scatter *mms,
+		int id)
+{
+	phy_addr_type page;
+	if (INVALID_ID(mms, id))
+		return 0;
+	page = mms->pages_list[id];
+	return PAGE_SID(page);
+}
+
+static int codec_mm_page_free_to_slot(page_sid_type sid, ulong addr)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	struct codec_mm_slot *slot;
+	int ret;
+	int slot_free = 0;
+
+	slot = codec_mm_find_slot_in_hash(sid, addr);
+	if (!slot)
+		return -1;
+	ret = codec_mm_slot_free_page(slot, addr);
+	if (ret != 0)
+		ERR_LOG("free slot addr error =%p ret=%d\n",
+			(void *)addr, ret);
+
+	if (slot->alloced_page_num == 0)
+		slot_free = (codec_mm_slot_try_free(slot) == 0);
+
+	if (!slot_free) {/*move to have free list. */
+		codec_mm_list_lock(smgt);
+		if (list_empty(&slot->free_list) &&
+			(slot->alloced_page_num < slot->page_num)) {
+			DBG_LOG("add to  free %p, %d,%d,%d\n",
+					slot, slot->page_num,
+					slot->alloced_page_num, ret);
+			list_add_tail(&slot->free_list, &smgt->free_list);
+		}
+		codec_mm_list_unlock(smgt);
+	}
+
+	return 0;
+}
+
+static int codec_mm_page_alloc_from_one_pages(phy_addr_type *pages, int num)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	int neednum = num;
+	int alloced = 0;
+
+	while (neednum > 0) {	/*one page  alloc */
+		void *vpage = (void *)__get_free_page(GFP_KERNEL);
+		ulong page;
+		page_sid_type sid;
+		if (vpage != NULL) {
+			page = virt_to_phys(vpage);
+			sid = ONE_PAGE_SID;
+			page |= sid;
+			pages[alloced++] = page;
+			neednum--;
+		} else {
+			/*can't alloced memofy from ONEPAGE alloc */
+			WAR_LOG("Out of memory OnePage alloc =%d,%d\n",
+					alloced, num);
+			break;
+		}
+	}
+	codec_mm_list_lock(smgt);
+	smgt->total_page_num += alloced;
+	smgt->one_page_cnt += alloced;
+	smgt->alloced_page_num += alloced;
+	codec_mm_list_unlock(smgt);
+	return alloced;
+}
+
+
+
+static int codec_mm_page_alloc_from_slot(phy_addr_type *pages, int num)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	struct codec_mm_slot *slot = NULL;
+	int alloced = 0;
+	int neednum = num;
+	int n;
+
+	codec_mm_list_lock(smgt);
+	if (list_empty(&smgt->free_list) &&
+		(codec_mm_get_free_size() </*no codec mm*/
+		smgt->reserved_block_mm_M * SZ_1M) &&
+		!smgt->support_from_slot_sys) {/*no sys*/
+		codec_mm_list_unlock(smgt);
+		return 0;
+	}
+	codec_mm_list_unlock(smgt);
+
+	do {
+		slot = NULL;
+		if (smgt->total_page_num <= 0 ||	/*no codec mm. */
+			smgt->alloced_page_num == smgt->total_page_num ||
+			list_empty(&smgt->free_list)) {
+			/*codec_mm_scatter_info_dump(NULL, 0);*/
+			slot = codec_mm_slot_alloc(0, 0);
+			if (!slot) {
+				/*
+				ERR_LOG("can't alloc slot from system\n");
+				*/
+				break;
+			}
+		}
+		codec_mm_list_lock(smgt);
+		if (slot && slot->on_alloc_free != 0) {
+			ERR_LOG("the slot on alloc/free1: %d\n",
+					slot->on_alloc_free);
+			slot = NULL;/*slot used on another alloc.*/
+		}
+		if (!slot && !list_empty(&smgt->free_list)) {
+			slot = list_entry(smgt->free_list.next,
+					struct codec_mm_slot, free_list);
+			if (!slot)
+				ERR_LOG("ERROR!!!!.slot is NULL!!!!\n");
+			else if (slot->on_alloc_free != 0) {
+				ERR_LOG("the slot on alloc/free: %d\n",
+					slot->on_alloc_free);
+				slot = NULL;
+			}
+		}
+		if (slot && slot->on_alloc_free == 0) { /*del from free list.*/
+			slot->on_alloc_free++;
+			list_del_init(&slot->free_list);
+		} else {
+			slot = NULL;
+		}
+		codec_mm_list_unlock(smgt);
+		if (slot) {
+			n = codec_mm_slot_alloc_pages(slot,
+				&pages[alloced], neednum);
+			codec_mm_list_lock(smgt);
+			slot->on_alloc_free--;/*alloc use end*/
+			if (slot->alloced_page_num < slot->page_num &&
+				list_empty(&smgt->free_list)) {
+				DBG_LOG("slot have free: %p, t:%d,a:%d,%d\n",
+					slot, slot->page_num,
+					slot->alloced_page_num, alloced);
+				list_add_tail(&slot->free_list,
+					&smgt->free_list);
+				/*no free now, del from free list.,
+				and init to empty */
+			}
+			codec_mm_list_unlock(smgt);
+			if (n > 0) {
+				alloced += n;
+				neednum -= n;
+			} else {
+				DBG_LOG("alloced fail neednum:%d n=%d\n",
+						neednum, n);
+				DBG_LOG("smgt->free_list.next:%p\n",
+						smgt->free_list.next);
+				DBG_LOG("smgt->free_list.prev:%p\n",
+						smgt->free_list.prev);
+				DBG_LOG("slot->free_list:%p\n",
+						&slot->free_list);
+				DBG_LOG("slot->free_list.next:%p\n",
+						slot->free_list.next);
+				/*codec_mm_dump_slot(slot, NULL, 0);*/
+				continue;	/*try next. */
+			}
+		} else {
+			/*not alloced enough in block mode, try one page next */
+			/*ERR_LOG("get free slot failed neednum: %d\n",
+				neednum);
+			*/
+			break;
+		}
+	} while (neednum > 0);
+	if (neednum > 0 && 0) {
+		WAR_LOG("1can't alloc enough pages!!alloced=%d,need=%d\n",
+			alloced, num);
+		WAR_LOG("2can't alloc enough pages!!alloced=%d,need=%d\n",
+			alloced, num);
+	}
+	codec_mm_list_lock(smgt);
+	smgt->alloced_page_num += alloced;
+	if (smgt->max_alloced < smgt->alloced_page_num)
+		smgt->max_alloced = smgt->alloced_page_num;
+	codec_mm_list_unlock(smgt);
+	return alloced;
+}
+
+
+static int codec_mm_page_alloc_from_free_scatter(
+	phy_addr_type *pages, int num)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	struct codec_mm_scatter *mms;
+	int need = num;
+	int alloced = 0;
+
+	mms = smgt->cache_sc;
+	if (!mms)
+		return 0;
+	codec_mm_scatter_lock(mms);
+	alloced = min(mms->page_cnt, need);
+	if (alloced > 0) {
+		mms->page_cnt -= alloced;
+		mms->page_tail -= alloced;
+#if 1
+		memcpy(pages, &mms->pages_list[mms->page_tail + 1],
+			alloced * sizeof(phy_addr_type));
+#else
+	/*alloc from first*/
+		memcpy(pages, &mms->pages_list[0],
+			alloced * sizeof(phy_addr_type));
+		memmove(&mms->pages_list[0],
+			&mms->pages_list[alloced],
+			mms->page_cnt * sizeof(phy_addr_type));
+#endif
+		memset(&mms->pages_list[mms->page_tail + 1], 0,
+			alloced * sizeof(phy_addr_type));
+	}
+	codec_mm_list_lock(smgt);
+	smgt->cached_pages = mms->page_cnt;
+	codec_mm_list_unlock(smgt);
+	codec_mm_scatter_unlock(mms);
+	return alloced;
+}
+
+static int codec_mm_page_alloc_all_locked(
+		phy_addr_type * pages, int num, int iscache)
+{
+	int alloced = 0;
+	int can_from_scatter = iscache ? 0 : 1;
+	int can_from_slot = 1;
+	int new_alloc;
+
+	while (alloced < num) {
+		new_alloc = 0;
+		if (can_from_scatter) {
+			new_alloc = codec_mm_page_alloc_from_free_scatter(
+				pages + alloced,
+				num - alloced);
+			if (new_alloc <= 0)
+				can_from_scatter = 0;
+		} else if (can_from_slot) {
+			new_alloc = codec_mm_page_alloc_from_slot(
+				pages + alloced,
+				num - alloced);
+			if (new_alloc <= 0)
+				can_from_slot = 0;
+		} else if (!codec_mm_video_tvp_enabled()) {
+			new_alloc = codec_mm_page_alloc_from_one_pages(
+				pages + alloced,
+				num - alloced);
+			if (new_alloc <= 0)
+				break;
+		} else {
+			break;
+		}
+		alloced += new_alloc;
+	}
+	return alloced;
+}
+
+static int codec_mm_pages_free_to_scatter(
+	struct codec_mm_scatter *src_mms)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	struct codec_mm_scatter *dst_mms;
+	int moved = 0;
+	int left;
+
+	if (src_mms->page_used >= src_mms->page_cnt)
+		return -1;/*no need free.*/
+	dst_mms = smgt->cache_sc;
+	if (!dst_mms)
+		return 0;
+	codec_mm_scatter_lock(dst_mms);
+	moved = min(src_mms->page_cnt - src_mms->page_used,
+		dst_mms->page_max_cnt - dst_mms->page_cnt);
+	left = src_mms->page_cnt - moved;
+	if (moved > 0) {
+		memcpy(&dst_mms->pages_list[dst_mms->page_tail + 1],
+			&src_mms->pages_list[left],
+			moved * sizeof(phy_addr_type));
+		memset(&src_mms->pages_list[left], 0,
+			sizeof(phy_addr_type) * moved);
+	}
+	dst_mms->page_cnt += moved;
+	dst_mms->page_tail += moved;
+	src_mms->page_cnt -= moved;
+	src_mms->page_tail -= moved;
+	codec_mm_list_lock(smgt);
+	smgt->cached_pages = dst_mms->page_cnt;
+	codec_mm_list_unlock(smgt);
+	codec_mm_scatter_unlock(dst_mms);
+	return moved;
+}
+
+#if 0
+/*
+return:
+1:for valid;
+0:no valid mms.
+must check in
+codec_mm_list_lock
+*/
+static int codec_mm_scatter_valid_check_inlock(struct codec_mm_scatter *mms)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	struct list_head *pos, *to_check_list;
+	if (!mms)
+		return 0;
+	to_check_list = &mms->list;
+	if (list_empty(&smgt->scatter_list))
+		return 0;
+	list_for_each(pos, &smgt->scatter_list) {
+		if (pos == to_check_list)
+			return 1;
+	}
+	return 0;
+}
+#endif
+
+/*
+free one page in mms;
+*/
+static int codec_mm_scatter_free_page_id_locked(
+	struct codec_mm_scatter *mms, int id)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	page_sid_type sid;
+	int ret;
+
+	if (INVALID_ID(mms, id))
+		return CODEC_MM_S_ERR(1);
+	sid = PAGE_SID_OF_MMS(mms, id);
+	if (!VALID_SID(sid))
+		return CODEC_MM_S_ERR(2);
+	if (SID_OF_ONEPAGE(sid)) {
+		ulong phy_addr = PAGE_ADDR_OF_MMS(mms, id);
+		free_page((unsigned long)phys_to_virt(phy_addr));
+		smgt->one_page_cnt--;
+		smgt->total_page_num--;
+		if (id == mms->page_tail)
+			mms->page_tail--;
+		mms->page_cnt--;
+		return 0;
+	}
+	ret = codec_mm_page_free_to_slot(sid, PAGE_ADDR_OF_MMS(mms, id));
+	if (!ret) {
+		mms->page_cnt--;
+		mms->page_tail--;
+	}
+	return ret;
+}
+/*
+free one page in mms;
+*/
+static int codec_mm_scatter_free_pages_in_locked(struct codec_mm_scatter *mms,
+	int start_id)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	int i;
+	int ret;
+	int id = start_id;
+	int freeNum = 0;
+	int not_continue_print = 1;
+
+	for (i = mms->page_tail; i >= id; i--) {
+		ret = codec_mm_scatter_free_page_id_locked(mms, i);
+		if (ret < 0) {
+			if (not_continue_print) {
+				ERR_LOG("page free error.%d,id=%d, addr:%d\n",
+					ret, i,
+					(int)mms->pages_list[i]);
+				codec_mm_dump_scatter(mms, NULL, 0);
+			}
+			not_continue_print = 0;
+		} else {
+			not_continue_print = 1;
+		}
+		freeNum++;
+		mms->pages_list[i] = (phy_addr_type) 0;
+	}
+	codec_mm_list_lock(smgt);
+	smgt->alloced_page_num -= freeNum;
+	codec_mm_list_unlock(smgt);
+	return 0;
+}
+/*
+free pages from id(include id);
+*/
+static int codec_mm_scatter_free_tail_pages_in(
+	struct codec_mm_scatter *mms,
+	int start_free_id,
+	int fast)
+{
+	int id = start_free_id;
+
+	if (!mms || id < 0 || id >= mms->page_cnt || mms->page_tail < 0) {
+		if (mms)
+			ERR_LOG("free mm scatters error id %d,page_cnt=%d\n",
+				id, mms->page_cnt);
+		return -1;
+	}
+	codec_mm_scatter_lock(mms);
+	mms->page_used = start_free_id;
+
+	if (fast == 1) {
+		codec_mm_scatter_unlock(mms);
+		return 0;
+	}
+	if (fast == 2 || fast == 3) {
+		codec_mm_pages_free_to_scatter(mms);
+		if (fast == 2 || mms->page_used == mms->page_cnt) {
+			codec_mm_scatter_unlock(mms);
+			return 0;
+		}
+	}
+	codec_mm_scatter_free_pages_in_locked(mms, start_free_id);
+	codec_mm_scatter_unlock(mms);
+	return 0;
+}
+
+int codec_mm_scatter_free_tail_pages(struct codec_mm_scatter *mms,
+				int start_free_id)
+{
+	int ret = 0;
+	if (start_free_id < mms->page_cnt)
+		ret = codec_mm_scatter_free_tail_pages_in(mms,
+			start_free_id, 0);
+	return ret;
+}
+
+int codec_mm_scatter_free_tail_pages_fast(struct codec_mm_scatter *mms,
+				int start_free_id)
+{
+	int ret = 0;
+	if (start_free_id < mms->page_cnt)
+		ret = codec_mm_scatter_free_tail_pages_in(mms,
+			start_free_id, 2);
+	codec_mm_schedule_delay_work(100, 0);
+	return ret;
+}
+
+int codec_mm_scatter_free_unused_pages(struct codec_mm_scatter *mms)
+{
+	int ret = 0;
+	if (mms->page_used < mms->page_cnt)
+		ret = codec_mm_scatter_free_tail_pages_in(mms,
+			mms->page_used, 3);
+	return ret;
+}
+
+/*free all pages only
+don't free scatter
+*/
+int codec_mm_scatter_free_all_pages(struct codec_mm_scatter *mms)
+{
+	int ret;
+	ret = codec_mm_scatter_free_tail_pages(mms, 0);
+	return ret;
+}
+
+static inline int codec_mm_scatter_map_add_locked(
+	struct codec_mm_scatter *mms)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	int i;
+	for (i = 0; i < MAX_SC_LIST; i++) {
+		if (smgt->scmap[i] == NULL) {
+			smgt->scmap[i] = mms;
+			return i;
+		}
+	}
+	return -1;
+}
+
+static inline int codec_mm_scatter_map_del_locked(
+	struct codec_mm_scatter *mms)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	int i;
+	for (i = 0; i < MAX_SC_LIST; i++) {
+		if (smgt->scmap[i] == mms) {
+			smgt->scmap[i] = NULL;
+			return i;
+		}
+	}
+	return 0;
+}
+
+int codec_mm_scatter_valid_locked(struct codec_mm_scatter *mms)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	int i;
+	int valid = 0;
+	for (i = 0; i < MAX_SC_LIST; i++) {
+		if (smgt->scmap[i] == mms) {
+			valid = 1;
+			break;
+		}
+	}
+	return valid;
+}
+
+/*free scatter's all */
+static int codec_mm_scatter_free_on_nouser(struct codec_mm_scatter *mms)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	int ret = 0;
+	int free;
+	codec_mm_scatter_lock(mms);
+	codec_mm_list_lock(smgt);
+	ret = atomic_read(&mms->user_cnt);
+	if (ret > 0) {
+		codec_mm_list_unlock(smgt);
+		codec_mm_scatter_unlock(mms);
+		/*>0 have another user.*/
+		/*pr_err("ERROR, scatter is not free.cnt:%d\n", ret);*/
+		return 0;
+	}
+	/*to free now*/
+	free = mms->page_cnt;
+	if (!list_empty(&mms->list))
+		list_del(&mms->list);
+	smgt->scatters_cnt--;
+	codec_mm_scatter_map_del_locked(mms);
+	codec_mm_list_unlock(smgt);
+	codec_mm_scatter_unlock(mms);
+	if (mms->page_cnt > 0)
+		ret = codec_mm_scatter_free_tail_pages_in(mms, 0, 0);
+	if (free >= 256 &&
+		(smgt->try_alloc_in_sys_page_cnt <
+			smgt->try_alloc_in_sys_page_cnt_max) &&
+		(smgt->total_page_num < (1024 * 1024 * 32 >> PAGE_SHIFT))) {
+		smgt->try_alloc_in_sys_page_cnt *= 2;
+		if (!smgt->support_from_slot_sys) {
+			smgt->support_from_slot_sys =
+				smgt->enable_slot_from_sys;
+		}
+	}
+
+	SC_FREE(mms);
+	return ret;
+}
+
+/*
+mask for other use it.
+*/
+static int codec_mm_scatter_inc_user_in(struct codec_mm_scatter *mms,
+	int cnt)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	int ret = -1;
+	int old_user;
+	if (!mms)
+		return -1;
+	codec_mm_list_lock(smgt);
+	if (!codec_mm_scatter_valid_locked(mms)) {
+		codec_mm_list_unlock(smgt);
+		return -1;
+	}
+	old_user = atomic_read(&mms->user_cnt);
+	if (old_user >= 0) {
+		ret = atomic_add_return(cnt, &mms->user_cnt);
+		if (old_user == 1)
+			mms->tofree_jiffies = 0;
+	}
+	codec_mm_list_unlock(smgt);
+	return ret <= 0 ? ret : 0;/*must add before user cnt >= 0*/
+}
+
+/*mask scatter's to free.*/
+static int codec_mm_scatter_dec_user_in(struct codec_mm_scatter *mms,
+	int delay_free_ms, int cnt)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	int after_users = 1;
+	if (!mms)
+		return -1;
+	codec_mm_list_lock(smgt);
+	if (!codec_mm_scatter_valid_locked(mms)) {
+		codec_mm_list_unlock(smgt);
+		return -1;
+	}
+	if (atomic_read(&mms->user_cnt) >= 1) {
+		after_users = atomic_sub_return(cnt, &mms->user_cnt);
+		if (after_users == 0) {
+			/*is free time*/
+			if (delay_free_ms > 0)
+				mms->tofree_jiffies  = jiffies +
+					delay_free_ms * HZ/1000;
+			else {
+				mms->page_used = 0;
+				mms->tofree_jiffies = 0;
+			}
+		}
+	}
+	codec_mm_list_unlock(smgt);
+	if (after_users == 0)
+		codec_mm_schedule_delay_work(0, 1);
+	return 0;
+}
+
+
+/*
+maybe a render/sink.video/osd/
+*/
+int codec_mm_scatter_inc_for_keeper(void *sc_mm)
+{
+	struct codec_mm_scatter *mms = sc_mm;
+	return codec_mm_scatter_inc_user_in(mms, 100);
+}
+
+/*
+maybe a render/sink.video/osd/
+*/
+int codec_mm_scatter_dec_keeper_user(void *sc_mm, int delay_ms)
+{
+	struct codec_mm_scatter *mms = sc_mm;
+	return codec_mm_scatter_dec_user_in(mms, delay_ms, 100);
+}
+
+int codec_mm_scatter_dec_owner_user(void *sc_mm, int delay_ms)
+{
+	struct codec_mm_scatter *mms = sc_mm;
+	int ret = codec_mm_scatter_dec_user_in(mms, delay_ms, 1000);
+	if (ret)
+		ERR_LOG("dec_owner_user error %p\n", mms);
+	return ret;
+}
+/*
+max pages:
+want pages now,
+maybe:
+	max pages == support 4k,need pages;
+	page num = current size need pages;
+*/
+struct codec_mm_scatter *codec_mm_scatter_alloc_new(int max_page, int page_num)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	struct codec_mm_scatter *mms;
+	int ret;
+
+	if (max_page < page_num)
+		return NULL;
+
+	mms = SC_ALLOC(sizeof(struct codec_mm_scatter) + sizeof(phy_addr_type) *
+				  max_page, GFP_KERNEL);
+	if (!mms) {
+		ERR_LOG("no enough for mm scatter!!!!\n");
+		return NULL;
+	}
+	memset(mms, 0, sizeof(struct codec_mm_scatter));
+	mms->pages_list = (phy_addr_type *)(mms + 1);
+	mms->page_max_cnt = max_page;
+	INIT_LIST_HEAD(&mms->list);
+	memset(mms->pages_list, 0, sizeof(phy_addr_type) * max_page);
+	mms->page_cnt = 0;
+	mms->page_tail = -1;
+	atomic_set(&mms->user_cnt, 0);
+	mutex_init(&mms->mutex);
+	if (page_num > 0) {
+		ret = codec_mm_page_alloc_all_locked(mms->pages_list, page_num,
+			mms == smgt->cache_sc);
+		if (ret <= 0)
+			goto error;
+		mms->page_cnt = ret;
+		mms->page_tail = mms->page_cnt - 1;
+	}
+	atomic_set(&mms->user_cnt, 1000);
+	codec_mm_list_lock(smgt);
+	mms->page_used = mms->page_cnt;
+	list_add_tail(&mms->list, &smgt->scatter_list);
+	smgt->scatters_cnt++;
+	codec_mm_scatter_map_add_locked(mms);
+	codec_mm_list_unlock(smgt);
+	return mms;
+error:
+	codec_mm_scatter_free_on_nouser(mms);
+	return NULL;
+}
+/*
+max pages:
+want pages now,
+maybe:
+	max pages == support 4k,need pages;
+	page num = current size need pages;
+*/
+struct codec_mm_scatter *codec_mm_scatter_alloc(int max_page, int page_num)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	struct codec_mm_scatter *mms, *alloced_mms;
+	struct list_head *pos, *next;
+	int ret;
+	u64 startus;
+
+	startus = codec_mm_get_current_us();
+	alloced_mms = NULL;
+	codec_mm_list_lock(smgt);
+	if (!list_empty(&smgt->scatter_list)) {/*try find a free scatter.*/
+		pos = smgt->scatter_list.prev;/*free on prev.*/
+		while (pos != &smgt->scatter_list) {
+			next = pos->prev;
+			mms = list_entry(pos, struct codec_mm_scatter, list);
+			if (mms->page_max_cnt >= max_page &&
+				atomic_read(&mms->user_cnt) == 0) {
+				if (atomic_add_return(1000,
+						&mms->user_cnt) == 1000) {
+					mms->page_used = mms->page_cnt;
+					alloced_mms = mms;
+					break;
+				} else
+					atomic_sub(1000, &mms->user_cnt);
+			}
+			pos = next;
+		}
+	}
+	codec_mm_list_unlock(smgt);
+	if (!alloced_mms) {
+		/*just alloc mms first,
+		alloc pages later.
+		*/
+		alloced_mms = codec_mm_scatter_alloc_new(max_page, 0);
+	}
+	if (alloced_mms) {
+		ret = codec_mm_scatter_alloc_want_pages_in(alloced_mms,
+			page_num);
+		if (ret < 0) {
+			atomic_sub(1000, &alloced_mms->user_cnt);
+			return NULL;
+		}
+		/*pr_info("reused old mms! %p\n", alloced_mms);*/
+		codec_mm_update_alloc_time(startus);
+		return alloced_mms;
+	}
+	return NULL;
+}
+
+static int codec_mm_scatter_alloc_want_pages_in(
+		struct codec_mm_scatter *mms,
+		int want_pages)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	int ret;
+
+	if (want_pages > mms->page_max_cnt)
+		return CODEC_MM_S_ERR(100);
+	codec_mm_scatter_lock(mms);
+	mms->page_used = want_pages;
+	if (want_pages > mms->page_cnt) {
+		ret = codec_mm_page_alloc_all_locked(
+				&mms->pages_list[mms->page_tail + 1],
+					want_pages - mms->page_cnt,
+				mms == smgt->cache_sc);
+		if (ret <= 0) {
+			codec_mm_scatter_unlock(mms);
+			ERR_LOG("can't alloc want pages %d\n", want_pages);
+			return ret;
+		}
+		mms->page_cnt += ret;
+		mms->page_tail += ret;
+	}
+	if (mms == smgt->cache_sc) {
+		codec_mm_list_lock(smgt);
+		if (smgt->cache_sc)/*update cache pages*/
+			smgt->cached_pages = smgt->cache_sc->page_cnt;
+		codec_mm_list_unlock(smgt);
+	}
+	codec_mm_scatter_unlock(mms);
+	if (smgt->cached_pages < smgt->keep_size_PAGE / 2) {
+		/*try alloc more cache.*/
+		codec_mm_schedule_delay_work(0, 1);
+	}
+	return 0;
+}
+
+int codec_mm_scatter_alloc_want_pages(
+		struct codec_mm_scatter *mms,
+		int want_pages)
+{
+	int ret;
+	u64 startus;
+	startus = codec_mm_get_current_us();
+	ret = codec_mm_scatter_alloc_want_pages_in(mms, want_pages);
+	codec_mm_update_alloc_time(startus);
+	return ret;
+}
+
+int codec_mm_free_all_free_slots(void)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	struct codec_mm_slot *slot, *to_free;
+
+	do {
+		to_free = NULL;
+		codec_mm_list_lock(smgt);
+		{
+			struct list_head *header, *list;
+			header = &smgt->free_list;
+			list = header->prev;
+			while (list != header) {
+				slot = list_entry(list, struct codec_mm_slot,
+								free_list);
+				if (slot->alloced_page_num == 0) {
+					list_del_init(&slot->free_list);
+					to_free = slot;
+					break;
+				}
+				list = list->prev;
+			};
+		}
+		codec_mm_list_unlock(smgt);
+		if (!to_free)
+			break;
+		codec_mm_slot_free(to_free);
+	} while (1);
+	return 0;
+}
+
+
+int codec_mm_scatter_info_dump(void *buf, int size)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	char *pbuf = buf;
+	char sbuf[512];
+	int tsize = 0;
+	int s;
+	int n;
+
+	if (!pbuf)
+		pbuf = sbuf;
+
+#define BUFPRINT(args...) \
+	do {\
+			s = sprintf(pbuf, args);\
+			tsize += s;\
+			pbuf += s; \
+		} while (0)
+
+	BUFPRINT("codec scattered memory info:\n");
+	BUFPRINT("\ttotal size:%dM, %d Bytes,pages:%d\n",
+			 (smgt->total_page_num << PAGE_SHIFT) / SZ_1M,
+			 smgt->total_page_num << PAGE_SHIFT,
+			 smgt->total_page_num);
+	n = smgt->alloced_page_num;
+	BUFPRINT("\talloced size:%dM, %d Bypes,pages:%d\n",
+			 (n << PAGE_SHIFT) / SZ_1M,
+			 n << PAGE_SHIFT,
+			 n);
+	BUFPRINT("\tmax alloced:%d M | %d pages\n",
+		(smgt->max_alloced << PAGE_SHIFT) / SZ_1M,
+		smgt->max_alloced);
+	BUFPRINT("\tscatter cached:%d M |%d pages\n",
+		(smgt->cached_pages << PAGE_SHIFT) / SZ_1M,
+		smgt->cached_pages);
+
+	BUFPRINT("\talloc from sys size:%d\n",
+		(smgt->alloc_from_sys_sc_cnt +
+		smgt->one_page_cnt) << PAGE_SHIFT);
+
+	BUFPRINT("\talloc from sys sc cnt:%d\n",
+		smgt->alloc_from_sys_sc_cnt);
+	BUFPRINT("\talloc from sys pages cnt:%d pages\n",
+		smgt->alloc_from_sys_page_cnt);
+	BUFPRINT("\talloc from sys max pages cnt:%d pages\n",
+		smgt->alloc_from_sys_max_page_cnt);
+	BUFPRINT("\tscatter_task_run:%d\n",
+		smgt->scatter_task_run_num);
+	BUFPRINT("\tone_page_cnt:%d\n",
+		smgt->one_page_cnt);
+	BUFPRINT("\tcatters cnt:%d\n", smgt->scatters_cnt);
+	BUFPRINT("\tslot cnt:%d\n", smgt->slot_cnt);
+	BUFPRINT("\tcma alloc block size:%d\n",
+			smgt->try_alloc_in_cma_page_cnt);
+	BUFPRINT("\tsys alloc block size:%d\n",
+			smgt->try_alloc_in_sys_page_cnt);
+	BUFPRINT("\tdelay_free_on:%d\n",
+			smgt->delay_free_on);
+	BUFPRINT("\tdelay_free_on time:%lld jiffies\n",
+			smgt->delay_free_timeout_jiffies64);
+	BUFPRINT("\tcurrent time:%lld\n",
+			get_jiffies_64());
+	BUFPRINT("\talloc time max us:%d\n",
+			smgt->alloc_max_us);
+	BUFPRINT("\talloc cnt:%d step:%d:%d:%d:%d:%d:%d:%d\n",
+			smgt->alloc_cnt,
+			smgt->alloc_10us_less_cnt,
+			smgt->alloc_10_50us_cnt,
+			smgt->alloc_50_100us_cnt,
+			smgt->alloc_100_1000us_cnt,
+			smgt->alloc_1_10ms_cnt,
+			smgt->alloc_10_100ms_cnt,
+			smgt->alloc_100ms_up_cnt
+			);
+	{
+		int average_timeus = smgt->alloc_cnt == 0 ?
+			0 : (int)(smgt->alloc_total_us/smgt->alloc_cnt);
+		BUFPRINT("\talloc time average us:%d\n",
+			average_timeus);
+	}
+
+
+#undef BUFPRINT
+	if (!buf)
+		INFO_LOG("%s", sbuf);
+	return tsize;
+}
+
+int codec_mm_dump_slot(struct codec_mm_slot *slot, void *buf, int size)
+{
+	char *pbuf = buf;
+	char sbuf[512];
+	int tsize = 0;
+	int s;
+	int i;
+	int sum;
+	char bits_incharNhalf[] = { 0, 1, 1, 2, 1, 2, 2, 3,
+		1, 2, 2, 3, 2, 2, 3, 4, 1, 2};
+
+	if (!pbuf)
+		pbuf = sbuf;
+
+#define BUFPRINT(args...) \
+	do {\
+			s = sprintf(pbuf, args);\
+			tsize += s;\
+			pbuf += s; \
+		} while (0)
+
+	BUFPRINT("slot info:%p\n", slot);
+	BUFPRINT("\tfrom:%s\n",
+		(slot->from_type == SLOT_FROM_CODEC_MM ? "codec_mm" :
+			"sys"));
+	BUFPRINT("\tbase addr range:%p<-->%p\n",
+			 (void *)slot->phy_addr,
+			 (void *)(slot->phy_addr +
+			 (slot->page_num << PAGE_SHIFT)
+					 - 1));
+	BUFPRINT("\tpage_num:%d\n", slot->page_num);
+	BUFPRINT("\talloced:%d,free:%d\n", slot->alloced_page_num,
+			 slot->page_num - slot->alloced_page_num);
+	BUFPRINT("\tnext bit:%d\n", slot->next_bit);
+	BUFPRINT("\tsid:%x\n", slot->sid);
+	BUFPRINT("\troot:%d\n", slot->isroot);
+	sum = 0;
+	for (i = 0; i < slot->pagemap_size; i++) {
+		int c = ((unsigned char *)slot->pagemap)[i];
+		sum += bits_incharNhalf[c & 0xf] + bits_incharNhalf[c >> 4];
+	}
+	BUFPRINT("\tbitmap.setbits.sum:%d\n", sum);
+	BUFPRINT("\tbitmap");
+	i = 0;
+	while (i < slot->pagemap_size && i < 16)
+		BUFPRINT(":%02x", ((char *)slot->pagemap)[i++]);
+	BUFPRINT("\n");
+#undef BUFPRINT
+	if (!buf)
+		INFO_LOG("%s", sbuf);
+	return 0;
+
+}
+
+int codec_mm_dump_all_slots(void)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	struct codec_mm_slot *slot, *fslot;
+	int total_pages = 0;
+	int alloced_pages = 0;
+	int slot_cnt = 0;
+	int i;
+	codec_mm_list_lock(smgt);
+	INFO_LOG("start dump all slots!\n");
+	for (i = 0; i < MAX_SID; i++) {
+		fslot = smgt->slot_list_map[i];
+		if (fslot) {
+			codec_mm_dump_slot(fslot, NULL, 0);
+			slot_cnt++;
+			total_pages += fslot->page_num;
+			alloced_pages += fslot->alloced_page_num;
+			if (!list_empty(&fslot->sid_list)) {
+				slot = list_entry(fslot->sid_list.next,
+					struct codec_mm_slot, sid_list);
+				while (slot != fslot) {
+					codec_mm_dump_slot(slot, NULL, 0);
+					slot_cnt++;
+					total_pages += slot->page_num;
+					alloced_pages += slot->alloced_page_num;
+					slot = list_entry(slot->sid_list.next,
+						struct codec_mm_slot, sid_list);
+				}
+			}
+		}
+
+	}
+	codec_mm_list_unlock(smgt);
+	INFO_LOG("end dump, slot cnt:%d total pages:%d, free:%d\n",
+		slot_cnt,
+		total_pages,
+		total_pages - alloced_pages);
+	return 0;
+}
+
+int codec_mm_dump_all_hash_table(void)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	struct codec_mm_slot *slot, *fslot;
+	int i;
+	int total_pages = 0;
+	int alloced_pages = 0;
+
+	INFO_LOG("start dump sid hash table!\n");
+	codec_mm_list_lock(smgt);
+	for (i = 0; i < MAX_SID; i++) {
+		int cnt = 0;
+		int pages = 0;
+		int alloced = 0;
+		fslot = smgt->slot_list_map[i];
+		if (fslot) {
+			cnt++;
+			pages += fslot->page_num;
+			alloced += fslot->alloced_page_num;
+			if (!list_empty(&fslot->sid_list)) {
+				slot = list_entry(fslot->sid_list.next,
+					struct codec_mm_slot, sid_list);
+				while (slot != fslot) {
+					cnt++;
+					pages += slot->page_num;
+					alloced += slot->alloced_page_num;
+					slot = list_entry(slot->sid_list.next,
+						struct codec_mm_slot, sid_list);
+				}
+			}
+		}
+		if (cnt > 0) {
+			total_pages += pages;
+			alloced_pages += alloced;
+			INFO_LOG(
+			"\tSID(%d):\tslots:%d,\tpages:%d:\tfree pages:%d\n",
+			i, cnt, pages, pages - alloced);
+		}
+	}
+	codec_mm_list_unlock(smgt);
+	INFO_LOG("end dump sid hash table, total pages:%d, free:%d\n",
+		total_pages, total_pages - alloced_pages);
+	return 0;
+}
+
+
+int codec_mm_dump_free_slots(void)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	struct codec_mm_slot *slot;
+	int total_pages = 0;
+	int alloced_pages = 0;
+
+	INFO_LOG("dump all free slots:\n");
+	codec_mm_list_lock(smgt);
+	if (!list_empty(&smgt->free_list)) {
+		struct list_head *header, *list;
+		header = &smgt->free_list;
+		list = header->prev;
+		while (list != header) {
+			slot = list_entry(list, struct codec_mm_slot,
+							free_list);
+			codec_mm_dump_slot(slot, NULL, 0);
+			total_pages += slot->page_num;
+			alloced_pages += slot->alloced_page_num;
+			list = list->prev;
+		};
+	}
+	codec_mm_list_unlock(smgt);
+	INFO_LOG("end all free slots: total pages:%d, freed:%d\n",
+		total_pages,
+		total_pages - alloced_pages);
+	return 0;
+}
+
+int codec_mm_dump_scatter(struct codec_mm_scatter *mms, void *buf, int size)
+{
+	char *pbuf = buf;
+	char sbuf[512];
+	int tsize = 0;
+	int s;
+	int i;
+
+	if (!pbuf)
+		pbuf = sbuf;
+
+#define BUFPRINT(args...) \
+	do {\
+			s = sprintf(pbuf, args);\
+			tsize += s;\
+			pbuf += s; \
+		} while (0)
+
+	BUFPRINT("scatter info:%p\n", mms);
+	BUFPRINT("\tsize:%d\n", (int)(mms->page_cnt * PAGE_SIZE));
+	BUFPRINT("\tmax:%d\n", mms->page_max_cnt);
+	BUFPRINT("\tpage_cnt:%d\n", mms->page_cnt);
+	BUFPRINT("\tpage_used:%d\n", mms->page_used);
+	BUFPRINT("\tpage_tail:%d\n", mms->page_tail);
+	BUFPRINT("\tuser_cnt:%d\n", atomic_read(&mms->user_cnt));
+	BUFPRINT("\ttofree_jiffies:%ld\n", mms->tofree_jiffies);
+
+	i = 0;
+	while (i < mms->page_cnt && i < 16)
+		BUFPRINT(":%x", (u32) mms->pages_list[i++]);
+	BUFPRINT("\n");
+#undef BUFPRINT
+	if (!buf)
+		INFO_LOG("%s", sbuf);
+
+	return 0;
+
+}
+
+int codec_mm_dump_all_scatters(void)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	struct codec_mm_scatter *mms;
+	struct list_head *pos, *tmp;
+	INFO_LOG("start dump all scatters!\n");
+	codec_mm_list_lock(smgt);
+	do {
+		if (list_empty(&smgt->scatter_list))
+			break;
+		list_for_each_safe(pos, tmp, &smgt->scatter_list) {
+			mms = list_entry(pos, struct codec_mm_scatter, list);
+			codec_mm_dump_scatter(mms, 0, 0);
+		}
+	} while (0);
+	INFO_LOG("start dump free scatters!\n");
+	if (smgt->cache_sc)
+		codec_mm_dump_scatter(smgt->cache_sc, 0, 0);
+	codec_mm_list_unlock(smgt);
+	INFO_LOG("finished dump all scatters!\n");
+	return 0;
+}
+
+
+struct sc_configs {
+	int id;
+	const char *name;
+};
+
+enum config_id {
+	ID0_KEEP_SIZE,
+	ID1_RES_BLK_SIZEM,
+	ID2_ONCE_CMA_SIZEM,
+	ID3_MAX_SYS_PAGES,
+	ID4_MIN_SYS_PAGES,
+	ID5_SLOT_FROM_SYS,
+	ID6_NO_CACHE_SIZE,
+	IDX_MAX,
+};
+struct sc_configs sc_global_config[] = {
+	{ID0_KEEP_SIZE, "keep_size"},
+	{ID1_RES_BLK_SIZEM, "res_blk_size"},
+	{ID2_ONCE_CMA_SIZEM, "once_cma_size"},
+	{ID3_MAX_SYS_PAGES, "max_sys_pages"},
+	{ID4_MIN_SYS_PAGES, "min_sys_pages"},
+	{ID5_SLOT_FROM_SYS, "enable_slot_from_sys"},
+	{ID6_NO_CACHE_SIZE, "no_cache_size_M"},
+};
+
+static int codec_mm_scatter_mgt_get_config_in(int id)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+
+	switch (id) {
+	case ID0_KEEP_SIZE:
+		return (smgt->keep_size_PAGE << PAGE_SHIFT) / SZ_1M;
+	case ID1_RES_BLK_SIZEM:
+		return smgt->reserved_block_mm_M;
+	case ID2_ONCE_CMA_SIZEM:
+		return smgt->try_alloc_in_cma_page_cnt;
+	case ID3_MAX_SYS_PAGES:
+		return smgt->try_alloc_in_sys_page_cnt_max;
+	case ID4_MIN_SYS_PAGES:
+		return smgt->try_alloc_in_sys_page_cnt_min;
+	case ID5_SLOT_FROM_SYS:
+		return smgt->enable_slot_from_sys;
+	case ID6_NO_CACHE_SIZE:
+		return smgt->no_cache_size_M;
+	default:
+		return 0;
+	}
+	return -1;
+}
+static int codec_mm_scatter_mgt_set_config_in(int id, int newset)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	int val;
+	switch (id) {
+	case ID0_KEEP_SIZE:
+		val = newset * (SZ_1M >> PAGE_SHIFT);
+		smgt->keep_size_PAGE = val;
+		break;
+	case ID1_RES_BLK_SIZEM:
+		smgt->reserved_block_mm_M = newset;
+		break;
+	case ID2_ONCE_CMA_SIZEM:
+		smgt->try_alloc_in_cma_page_cnt = newset;
+		break;
+	case ID3_MAX_SYS_PAGES:
+		smgt->try_alloc_in_sys_page_cnt_max = newset;
+		break;
+	case ID4_MIN_SYS_PAGES:
+		smgt->try_alloc_in_sys_page_cnt_min = newset;
+		break;
+	case ID5_SLOT_FROM_SYS:
+		smgt->enable_slot_from_sys = newset;
+		smgt->support_from_slot_sys = newset;
+		break;
+	case ID6_NO_CACHE_SIZE:
+		smgt->no_cache_size_M = newset;
+		break;
+	default:
+		return -1;
+	}
+	return 0;
+}
+int codec_mm_scatter_mgt_get_config(char *buf)
+{
+	size_t ret = 0;
+	int i;
+	for (i = 0; i < IDX_MAX; i++) {
+		ret += sprintf(buf + ret,
+			"scatter:%s:%d\n",
+			sc_global_config[i].name,
+			codec_mm_scatter_mgt_get_config_in(i));
+	}
+	return ret;
+}
+int codec_mm_scatter_mgt_set_config(const char *buf, size_t size)
+{
+	size_t ret = 0;
+	char *str;
+	int i;
+	int val;
+
+	for (i = 0; i < IDX_MAX; i++) {
+		str = strstr(buf, sc_global_config[i].name);
+		if (!str)
+			continue;/*to next.*/
+		str += strlen(sc_global_config[i].name);
+		if (str[0] != ':' || str[1] == '\0')
+			continue;/*to next.*/
+		ret = sscanf(str, ":%d", &val);
+		if (ret == 1) {
+			codec_mm_scatter_mgt_set_config_in(i, val);
+			return size;
+		}
+	}
+	pr_info("unknow cmd %s\n", buf);
+	return -1;
+}
+
+int codec_mm_scatter_mgt_delay_free_swith(int on,
+	int delay_ms,
+	int wait_size_M)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	codec_mm_list_lock(smgt);
+	if (on) {
+		smgt->delay_free_on++;
+		smgt->delay_free_timeout_jiffies64 =
+			get_jiffies_64() + delay_ms * HZ/1000;
+	} else {
+		smgt->delay_free_on--;
+		if (smgt->delay_free_on <= 0) {
+			smgt->delay_free_on = 0;
+			smgt->delay_free_timeout_jiffies64 =
+				get_jiffies_64() + delay_ms * HZ/1000;
+		}
+	}
+	codec_mm_list_unlock(smgt);
+	if (on && wait_size_M > 0) {
+		u64 start_time = get_jiffies_64();
+		int try_max = 1000;
+		smgt->force_cache_on = 1;
+		smgt->force_cache_page_cnt = wait_size_M >> PAGE_SHIFT;
+		smgt->delay_free_timeout_jiffies64 =
+			get_jiffies_64() + 10000 * HZ/1000;
+		codec_mm_schedule_delay_work(0, 1);/*start cache*/
+		while (smgt->cached_pages < smgt->force_cache_page_cnt) {
+			if (smgt->cache_sc &&
+				(smgt->cached_pages >=
+					smgt->cache_sc->page_max_cnt - 100)) {
+				/*cache sc fulled.*/
+				break;
+			}
+			if (try_max-- <= 0 || time_after64(get_jiffies_64(),
+					start_time + HZ)) {
+				break;
+			}
+			msleep(20);
+		}
+		pr_info("end: cached pages: %d, speed %d ms\n",
+			smgt->cached_pages,
+			(int)(get_jiffies_64() - start_time) * 1000/HZ);
+		smgt->force_cache_on = 0;
+		smgt->delay_free_timeout_jiffies64 =
+			get_jiffies_64() + delay_ms * HZ/1000;
+	} else if (on) {
+		codec_mm_schedule_delay_work(0, 1);
+	} else {
+		codec_mm_schedule_delay_work(delay_ms, 0);
+	}
+	return 0;
+}
+static void codec_mm_scatter_cache_manage(struct codec_mm_scatter_mgt *smgt)
+{
+	struct codec_mm_scatter *mms;
+	int alloced = 0;
+	int total_free_page = smgt->total_page_num -
+		smgt->alloced_page_num + smgt->cached_pages;
+	if (smgt->delay_free_on > 0 && smgt->keep_size_PAGE > 0) {
+		/*if alloc too much ,don't cache any more.*/
+		if (smgt->no_cache_size_M > 0 &&
+			(smgt->cached_pages <= smgt->keep_size_PAGE) &&
+			(smgt->total_page_num >=
+			 (smgt->no_cache_size_M * (SZ_1M >> PAGE_SHIFT)))) {
+			/*have enough pages for most movies.
+			  don't cache more.
+			*/
+		} else if ((smgt->cached_pages < smgt->keep_size_PAGE) ||
+			(smgt->force_cache_on &&/*on star cache*/
+			(smgt->cached_pages < smgt->force_cache_page_cnt))
+		) {/*first 500ms ,alloc double.*/
+			mms = smgt->cache_sc;
+			if (mms) {
+				int need;
+				int once_alloc = 1000;/*once 4M*/
+				if (smgt->force_cache_on) {
+					once_alloc = 4000;
+					if ((smgt->total_page_num -
+						smgt->alloced_page_num) >
+							once_alloc) {
+						once_alloc =
+							smgt->total_page_num -
+							smgt->alloced_page_num;
+					}
+				}
+				need = mms->page_cnt + once_alloc;
+				if ((need - mms->page_cnt) > once_alloc)
+					need = mms->page_cnt + once_alloc;
+				if (need > smgt->force_cache_page_cnt)
+					need = smgt->force_cache_page_cnt;
+				if (need > mms->page_max_cnt)
+					need = mms->page_max_cnt - 4;
+				if (need > mms->page_cnt) {
+					alloced =
+					!codec_mm_scatter_alloc_want_pages_in(
+						mms,
+						need);
+				} else {
+					alloced = 0;
+				}
+			} else {
+				alloced = 0;
+			}
+			/*int from_sys = codec_mm_get_free_size() < 16 * SZ_1M;
+			alloced = !!codec_mm_slot_alloc(0, (from_sys ? 1 : 0));
+			*/
+		} else if ((smgt->cached_pages >
+			(smgt->keep_size_PAGE + 1000)) &&
+			time_after64(get_jiffies_64(),
+			smgt->delay_free_timeout_jiffies64)) {
+			/*wait time out can free.*/
+			mms = smgt->cache_sc;
+			if (mms) {/*only free some 1M cache*/
+				int free_start = smgt->cached_pages - 256;
+				if (free_start < smgt->keep_size_PAGE)
+					free_start = smgt->keep_size_PAGE;
+				codec_mm_scatter_free_tail_pages(mms,
+					free_start);
+			}
+			codec_mm_free_all_free_slots();
+			/*free some slots.*/
+		}
+	} else if (smgt->delay_free_on <= 0 &&
+			time_after64(get_jiffies_64(),
+			smgt->delay_free_timeout_jiffies64)) {
+		/*free all free pages, no delay needed.*/
+		codec_mm_free_all_free_slots();
+	}
+	if (smgt->keep_size_PAGE > 0 && smgt->delay_free_on) {
+		if (((smgt->force_cache_on ||
+			  (total_free_page < smgt->keep_size_PAGE)) &&
+			!codec_mm_video_tvp_enabled()) &&
+			alloced) {/*if failed may deadlock...*/
+			/*ignore keep on tvp mode.*/
+			if (smgt->force_cache_on)
+				codec_mm_schedule_delay_work(0, 1);
+			else
+				codec_mm_schedule_delay_work(10, 0);
+		} else
+			codec_mm_schedule_delay_work(100, 0);
+	} else if (!smgt->delay_free_on && smgt->total_page_num > 0) {
+		codec_mm_schedule_delay_work(100, 0);
+	}
+}
+
+
+static int codec_mm_scatter_scatter_arrange(struct codec_mm_scatter_mgt *smgt)
+{
+	struct codec_mm_scatter *mms;
+	struct codec_mm_scatter *first_free_mms = NULL;
+	struct list_head *pos, *tmp;
+	int n = 0;
+
+	if (smgt->delay_free_on > 0 && !smgt->cache_sc) {
+		/*no free scatter.*/
+		mms = codec_mm_scatter_alloc_new(16384, 0);
+		if (mms) {
+			codec_mm_list_lock(smgt);
+			list_del_init(&mms->list);
+			smgt->cache_sc = mms;
+			codec_mm_list_unlock(smgt);
+		}
+	}
+	if (smgt->delay_free_on <= 0 && smgt->cache_sc &&
+		time_after64(get_jiffies_64(),
+			smgt->delay_free_timeout_jiffies64)) {
+		codec_mm_list_lock(smgt);
+		mms = smgt->cache_sc;
+		smgt->cache_sc = NULL;
+		smgt->cached_pages = 0;
+		codec_mm_list_unlock(smgt);
+		codec_mm_scatter_dec_owner_user(mms, 0);
+		codec_mm_scatter_free_on_nouser(mms);
+	}
+
+	codec_mm_list_lock(smgt);
+	if (list_empty(&smgt->scatter_list)) {
+		codec_mm_list_unlock(smgt);
+		return 0;
+	}
+	list_for_each_safe(pos, tmp, &smgt->scatter_list) {
+		mms = list_entry(pos, struct codec_mm_scatter, list);
+		if (atomic_read(&mms->user_cnt) == 0 &&
+			time_after(jiffies, mms->tofree_jiffies)) {
+			if (!first_free_mms ||
+				mms->tofree_jiffies <
+						first_free_mms->tofree_jiffies)
+				first_free_mms = mms;
+		} else
+			n++;
+	}
+	if (first_free_mms)
+		list_move_tail(&mms->list, &smgt->scatter_list);
+	codec_mm_list_unlock(smgt);
+
+	return 0;
+}
+
+static int codec_mm_scatter_scatter_clear(
+	struct codec_mm_scatter_mgt *smgt,
+	int force)/*not check jiffies & cache*/
+{
+	struct codec_mm_scatter *mms, *to_free_mms, *less_page_mms;
+	struct list_head *pos, *tmp;
+	int to_free_mms_cnt = 0;
+
+	codec_mm_list_lock(smgt);
+	to_free_mms = NULL;
+	less_page_mms = NULL;
+	list_for_each_safe(pos, tmp, &smgt->scatter_list) {
+		mms = list_entry(pos, struct codec_mm_scatter, list);
+		if (atomic_read(&mms->user_cnt) == 0) {
+			if (!to_free_mms ||
+				(mms->tofree_jiffies <
+					to_free_mms->tofree_jiffies))
+				to_free_mms = mms;
+			to_free_mms_cnt++;
+		}
+		if (!less_page_mms && mms->page_used < mms->page_cnt) {
+			less_page_mms = mms;
+			break;
+		}
+	}
+	if ((to_free_mms != NULL) &&
+		(((to_free_mms_cnt > 1 || !smgt->delay_free_on) &&
+		time_after(jiffies, to_free_mms->tofree_jiffies)) ||
+		force)) {/*force== no checktimeer.*/
+		/*set to nagative for free now. */
+		int cnt = atomic_sub_return(100000, &to_free_mms->user_cnt);
+		if (cnt != -100000) {
+			atomic_add(100000, &to_free_mms->user_cnt);
+			to_free_mms = NULL;
+		} else {
+			list_del_init(&to_free_mms->list);
+		}
+	} else {
+		to_free_mms = NULL;
+	}
+	codec_mm_list_unlock(smgt);
+	if (to_free_mms != NULL)
+		codec_mm_scatter_free_on_nouser(to_free_mms);
+	if (less_page_mms && (less_page_mms != to_free_mms))
+		codec_mm_scatter_free_unused_pages(less_page_mms);
+	return (to_free_mms != NULL)  || (less_page_mms != NULL);
+}
+/*
+clear all ignore any cache.
+
+return the total num alloced.
+0 is all freeed.
+N is have some pages not alloced.
+*/
+int codec_mm_scatter_free_all_ignorecache(void)
+{
+	struct codec_mm_scatter_mgt *smgt = codec_mm_get_scatter_mgt();
+	int need_retry = 1;
+	int retry_num = 0;
+	mutex_lock(&smgt->monitor_lock);
+	pr_info("force free all scatter ignorecache!\n");
+	do {
+		struct codec_mm_scatter *mms;
+		/*clear cache first.*/
+		/*disabled free on first.*/
+		smgt->delay_free_on = 0;
+		codec_mm_list_lock(smgt);
+		mms = smgt->cache_sc;
+		smgt->cache_sc = NULL;
+		smgt->cached_pages = 0;
+		codec_mm_list_unlock(smgt);
+		if (mms) {
+			codec_mm_scatter_dec_owner_user(mms, 0);
+			codec_mm_scatter_free_on_nouser(mms);
+		}
+		/*alloced again on timer?
+		check again.*/
+	} while (smgt->cache_sc != NULL);
+	do {
+		need_retry = codec_mm_scatter_scatter_clear(smgt, 1);
+	} while ((smgt->scatters_cnt > 0) && (retry_num++ < 1000));
+	if (need_retry || smgt->scatters_cnt > 0) {
+		pr_info("can't free all scatter, because some have used!!\n");
+		codec_mm_dump_all_scatters();
+	}
+	codec_mm_free_all_free_slots();
+	if (smgt->total_page_num > 0) {
+		/*have some not free,dump tables for debug*/
+		pr_info("Some slots have not free!!\n\n");
+		codec_mm_dump_all_hash_table();
+	}
+	mutex_unlock(&smgt->monitor_lock);
+	return smgt->total_page_num;
+}
+
+
+static void codec_mm_scatter_monitor(struct work_struct *work)
+{
+	struct codec_mm_scatter_mgt *smgt = container_of(work,
+					struct codec_mm_scatter_mgt,
+					dealy_work.work);
+	int needretry = 0;
+	mutex_lock(&smgt->monitor_lock);
+	smgt->scatter_task_run_num++;
+
+	codec_mm_scatter_scatter_arrange(smgt);
+	needretry = codec_mm_scatter_scatter_clear(smgt, 0);
+
+	if (needretry)
+		codec_mm_schedule_delay_work(10, 0);
+	else if (smgt->scatters_cnt > 0)
+		codec_mm_schedule_delay_work(100, 0);
+	codec_mm_scatter_cache_manage(smgt);
+	mutex_unlock(&smgt->monitor_lock);
+}
+
+int codec_mm_scatter_mgt_init(void)
+{
+	scatter_mgt = kmalloc(sizeof(struct codec_mm_scatter_mgt), GFP_KERNEL);
+	if (!scatter_mgt) {
+		ERR_LOG("ERR:codec mm mpt init ERROR\n");
+		return -1;
+	}
+	memset(scatter_mgt, 0, sizeof(struct codec_mm_scatter_mgt));
+	spin_lock_init(&scatter_mgt->list_lock);
+	scatter_mgt->alloced_page_num = 0;
+	scatter_mgt->try_alloc_in_cma_page_cnt = (4 * 1024 * 1024) / PAGE_SIZE;
+	scatter_mgt->try_alloc_in_sys_page_cnt_max = MAX_SYS_BLOCK_PAGE;
+	scatter_mgt->try_alloc_in_sys_page_cnt = MAX_SYS_BLOCK_PAGE;
+	scatter_mgt->try_alloc_in_sys_page_cnt_min = MIN_SYS_BLOCK_PAGE;
+	scatter_mgt->reserved_block_mm_M = 64;
+	scatter_mgt->keep_size_PAGE = 20 * SZ_1M >> PAGE_SHIFT;
+	scatter_mgt->alloc_from_cma_first = 1;
+	scatter_mgt->enable_slot_from_sys = 1;
+	scatter_mgt->support_from_slot_sys =
+		scatter_mgt->enable_slot_from_sys;
+	if ((totalram_pages << PAGE_SHIFT) < 800 * SZ_1M) {
+		/*less memory boards don't cache more,
+		after alloced many pages.*/
+		scatter_mgt->no_cache_size_M = 100;
+	} else
+		scatter_mgt->no_cache_size_M = 0;
+	INIT_LIST_HEAD(&scatter_mgt->free_list);
+	INIT_LIST_HEAD(&scatter_mgt->scatter_list);
+	mutex_init(&scatter_mgt->monitor_lock);
+
+	INIT_DELAYED_WORK(&scatter_mgt->dealy_work,
+				codec_mm_scatter_monitor);
+
+	return 0;
+}
+
+int codec_mm_scatter_mgt_test(void)
+{
+#if 0
+	struct codec_mm_scatter *sc[64];
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.11..\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	sc[0] = codec_mm_scatter_alloc(10240, 10000);
+	sc[1] = codec_mm_scatter_alloc(10240, 10000);
+	sc[2] = codec_mm_scatter_alloc(10240, 10000);
+	codec_mm_dump_all_scatters();
+	/*codec_mm_dump_all_slots();*/
+	codec_mm_scatter_free(sc[0]);
+	codec_mm_scatter_free(sc[1]);
+	codec_mm_scatter_free(sc[2]);
+	codec_mm_dump_all_scatters();
+	/*codec_mm_dump_all_slots();*/
+	#endif
+#if 0
+	struct codec_mm_scatter *sc[64];
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.11..\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	sc[0] = codec_mm_scatter_alloc(1024, 512);
+
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.22..\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	codec_mm_dump_all_scatters();
+	codec_mm_dump_all_slots();
+	sc[1] = codec_mm_scatter_alloc(128, 32);
+	sc[2] = codec_mm_scatter_alloc(128, 64);
+	sc[3] = codec_mm_scatter_alloc(128, 128);
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.33..\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	codec_mm_dump_all_scatters();
+	codec_mm_dump_all_slots();
+	codec_mm_scatter_free_tail_pages(sc[0], 128);	/* 128 */
+	codec_mm_scatter_free_tail_pages(sc[1], 16);	/* 16 */
+	codec_mm_scatter_free_tail_pages(sc[2], 4);	/* 4/4 */
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.44..\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	codec_mm_dump_all_scatters();
+	codec_mm_dump_all_slots();
+	codec_mm_scatter_info_dump(NULL, 0);
+	codec_mm_scatter_free(sc[1]);	/* 0 */
+	sc[4] = codec_mm_scatter_alloc(128, 32);	/* 32 */
+	sc[5] = codec_mm_scatter_alloc(512, 256);	/* 256 */
+	codec_mm_scatter_alloc_want_pages(sc[2], 44);	/* 44-->//48 */
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.55.\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	codec_mm_dump_all_scatters();
+	codec_mm_dump_all_slots();
+	codec_mm_scatter_free(sc[0]);
+	codec_mm_scatter_free(sc[2]);
+	codec_mm_scatter_free(sc[3]);
+
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.66..\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	codec_mm_dump_all_scatters();
+	codec_mm_scatter_free(sc[4]);
+	codec_mm_scatter_free(sc[5]);
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.77..\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	codec_mm_dump_all_scatters();
+	codec_mm_dump_all_slots();
+#endif
+
+	return 0;
+}
+
+/*
+mode:0,dump, 1,alloc 2,more,3,free some,4,free all
+0:dump ALL
+1: alloc id,num
+2: alloc more  id,num
+3: free tail  id,start
+4: free all  id
+5:dump id
+6:dump all free slots
+
+*/
+int codec_mm_scatter_test(int mode, int p1, int p2)
+{
+	static int init;
+	static struct codec_mm_scatter *sc[64];
+	if (!init) {
+		init++;
+		memset(sc, 0, sizeof(sc));
+	}
+	switch (mode) {
+	case 1:/*alloc*/
+		INFO_LOG(" alloc sc[%d] num %d:\n", p1, p2);
+		if (p1 > 0 && p1 < 64) {
+			if (sc[p1])
+				codec_mm_scatter_free_on_nouser(sc[p1]);
+			sc[p1] = codec_mm_scatter_alloc(p2 * 2, p2);
+		}
+		break;
+	case 2:/*alloc more*/
+		INFO_LOG(" alloc more sc[%d] num %d\n", p1, p2);
+		if (p1 > 0 && p1 < 64 && sc[p1])
+			codec_mm_scatter_alloc_want_pages(sc[p1], p2);
+		break;
+	case 3:/*alloc tails*/
+		INFO_LOG(" free some sc[%d] start free id %d\n", p1, p2);
+		if (p1 > 0 && p1 < 64 && sc[p1])
+			codec_mm_scatter_free_tail_pages(sc[p1], p2);
+		break;
+	case 4:
+		INFO_LOG(" free sc[%d] all\n", p1);
+		if (p1 > 0 && p1 < 64 && sc[p1]) {
+			codec_mm_scatter_free_on_nouser(sc[p1]);
+			sc[p1] = NULL;
+		}
+		break;
+	case 5:
+		INFO_LOG(" sc %d info:\n", p1);
+		if (p1 > 0 && p1 < 64 && sc[p1])
+			codec_mm_dump_scatter(sc[p1], NULL, 0);
+		break;
+	case 0:
+	default: {
+		int i;
+		INFO_LOG(" dump all test sc info:\n");
+		for (i = 0; i < 64; i++) {
+			if (sc[i] != NULL) {
+				INFO_LOG(" alloc sc[%d] has data\n", i);
+				codec_mm_dump_scatter(sc[i], NULL, 0);
+			}
+		}
+	}
+	break;
+	}
+	return 0;
+}
diff --git a/drivers/amlogic/codec_mm/codec_mm_scatter_priv.h b/drivers/amlogic/codec_mm/codec_mm_scatter_priv.h
new file mode 100644
index 0000000..eef1b66
--- /dev/null
+++ b/drivers/amlogic/codec_mm/codec_mm_scatter_priv.h
@@ -0,0 +1,74 @@
+/*
+ * drivers/amlogic/codec_mm/codec_mm_scatter_priv.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef CODEC_MM_SCATTER_PRIV_HEADER
+#define CODEC_MM_SCATTER_PRIV_HEADER
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/amlogic/codec_mm/codec_mm.h>
+#include <linux/amlogic/codec_mm/codec_mm_scatter.h>
+
+struct codec_mm_slot {
+	struct codec_mm_s *mm;
+	unsigned long page_header;
+#define SLOT_FROM_CODEC_MM 1
+#define SLOT_FROM_GET_FREE_PAGES 2
+	int from_type;
+	void *pagemap;
+	ulong phy_addr;
+	int pagemap_size;
+	int page_num;
+	int alloced_page_num;
+	int next_bit;
+	int sid;
+	int isroot;
+	int on_alloc_free;
+	spinlock_t lock;
+	struct list_head sid_list;
+	struct list_head free_list;
+};
+
+
+int codec_mm_dump_slot(struct codec_mm_slot *slot, void *buf, int size);
+
+int codec_mm_scatter_mgt_init(void);
+int codec_mm_scatter_mgt_test(void);
+
+int codec_mm_scatter_info_dump(void *buf, int size);
+int codec_mm_dump_all_slots(void);
+int codec_mm_dump_free_slots(void);
+int codec_mm_dump_all_scatters(void);
+
+int codec_mm_scatter_mgt_test(void);
+int codec_mm_scatter_test(int mode, int p1, int p2);
+int codec_mm_dump_all_hash_table(void);
+
+int codec_mm_scatter_mask_for_keep(void *sc_mm);
+int codec_mm_free_all_free_slots(void);
+int codec_mm_scatter_inc_for_keeper(void *sc_mm);
+int codec_mm_scatter_dec_keeper_user(void *sc_mm, int delay_ms);
+
+
+int codec_mm_scatter_mgt_get_config(char *buf);
+int codec_mm_scatter_mgt_set_config(const char *buf, size_t size);
+
+int codec_mm_scatter_free_all_ignorecache(void);
+int codec_mm_scatter_valid_locked(struct codec_mm_scatter *mms);
+
+void codec_mm_clear_alloc_infos(void);
+
+#endif
diff --git a/drivers/amlogic/deinterlace/deinterlace.c b/drivers/amlogic/deinterlace/deinterlace.c
index 2d2ee87..d29c884 100644
--- a/drivers/amlogic/deinterlace/deinterlace.c
+++ b/drivers/amlogic/deinterlace/deinterlace.c
@@ -41,9 +41,11 @@
 #include <linux/uaccess.h>
 #include <linux/of_fdt.h>
 #include <linux/cma.h>
+#include <linux/dma-contiguous.h>
 #include <linux/ctype.h>
 #include <linux/string.h>
 #include <linux/amlogic/iomap.h>
+#include <linux/amlogic/codec_mm/codec_mm.h>
 #include <linux/amlogic/cpu_version.h>
 #include <linux/amlogic/amports/vframe.h>
 #include <linux/amlogic/amports/vframe_provider.h>
@@ -53,6 +55,7 @@
 #include <linux/amlogic/tvin/tvin_v4l2.h>
 #include <linux/amlogic/vout/vinfo.h>
 #include <linux/amlogic/vout/vout_notify.h>
+#include <linux/amlogic/vpu.h>
 #ifdef CONFIG_AML_RDMA
 #include <linux/amlogic/rdma/rdma_mgr.h>
 #endif
@@ -116,6 +119,9 @@ static int rdma_en;
 module_param(rdma_en, int, 0664);
 MODULE_PARM_DESC(rdma_en, "rdma_en");
 
+static int di_reg_unreg_cnt = 10;
+module_param(di_reg_unreg_cnt, int, 0664);
+MODULE_PARM_DESC(di_reg_unreg_cnt, "di_reg_unreg_cnt");
 
 static bool overturn;
 module_param(overturn, bool, 0664);
@@ -129,20 +135,6 @@ bool mcpre_en = true;
 module_param(mcpre_en, bool, 0664);
 MODULE_PARM_DESC(mcpre_en, "enable/disable me in pre");
 
-static unsigned int dump_vf_start_flag;
-module_param(dump_vf_start_flag, uint, 0664);
-MODULE_PARM_DESC(dump_vf_start_flag, "dump_vf_start_flag");
-static unsigned int dump_vf_num = 5;
-module_param(dump_vf_num, uint, 0664);
-MODULE_PARM_DESC(dump_vf_num, "dump_vf_num");
-static unsigned int dump_vf_num_inner;
-static unsigned int dump_one_frame_size;
-static unsigned int dump_vf_in_width = 768;
-module_param(dump_vf_in_width, uint, 0664);
-MODULE_PARM_DESC(dump_vf_in_width, "dump_vf_in_width");
-static unsigned int dump_vf_in_height = 576;
-module_param(dump_vf_in_height, uint, 0664);
-MODULE_PARM_DESC(dump_vf_in_height, "dump_vf_in_height");
 #ifdef NEW_DI_V4
 static bool dnr_en = 1;
 module_param(dnr_en, bool, 0664);
@@ -169,14 +161,15 @@ static dev_t di_devno;
 static struct class *di_clsp;
 
 #define INIT_FLAG_NOT_LOAD 0x80
-static const char version_s[] = "2016-09-13a";
+static const char version_s[] = "2016-12-18a";
 static unsigned char boot_init_flag;
 static int receiver_is_amvideo = 1;
 
 static unsigned char new_keep_last_frame_enable;
 static int bypass_state = 1;
-static int bypass_prog;
+static int bypass_prog = 1;
 static int bypass_hd_prog;
+static int bypass_4K;
 static int bypass_interlace_output;
 #ifdef CONFIG_AM_DEINTERLACE_SD_ONLY
 static int bypass_hd = 1;
@@ -196,6 +189,7 @@ static int invert_top_bot;
 static int skip_top_bot;/*1or2: may affect atv when bypass di*/
 static char interlace_output_flag;
 static int bypass_get_buf_threshold = 4;
+static int bypass_hdmi_get_buf_threshold = 3;
 
 static int post_hold_line = 17;/* for m8 1080i/50 output */
 static int force_update_post_reg = 0x10;
@@ -343,6 +337,7 @@ static int force_duration_0;
 static int use_reg_cfg = 1;
 
 static uint init_flag;/*flag for di buferr*/
+static uint mem_flag;/*flag for mem alloc*/
 static unsigned int reg_flag;/*flag for vframe reg/unreg*/
 static unsigned int unreg_cnt;/*cnt for vframe unreg*/
 static unsigned int reg_cnt;/*cnt for vframe reg*/
@@ -354,10 +349,6 @@ static unsigned int recovery_log_reason;
 static unsigned int recovery_log_queue_idx;
 static struct di_buf_s *recovery_log_di_buf;
 
-static void *vf_input_buff;
-static unsigned int vf_input_size;
-static unsigned int dump_buff_offset;
-
 #define VFM_NAME "deinterlace"
 
 static long same_field_top_count;
@@ -385,11 +376,6 @@ static int pre_process_time_force;
 static int used_local_buf_index[USED_LOCAL_BUF_MAX];
 static int used_post_buf_index = -1;
 
-#define DisableVideoLayer() \
-	CLEAR_MPEG_REG_MASK(VPP_MISC, \
-	VPP_VD1_PREBLEND | VPP_VD2_PREBLEND | \
-	VPP_VD2_POSTBLEND | VPP_VD1_POSTBLEND); \
-
 static int di_receiver_event_fun(int type, void *data, void *arg);
 static void di_uninit_buf(void);
 static unsigned char is_bypass(vframe_t *vf_in);
@@ -630,9 +616,6 @@ store_dbg(struct device *dev,
 			init_flag = 1;
 		else
 			init_flag = 0;
-	}	else if (strncmp(buf, "show_osd", 8) == 0) {
-		DI_Wr(VIU_OSD1_CTRL_STAT,
-			Rd(VIU_OSD1_CTRL_STAT) | (0xff << 12));
 	} else if (strncmp(buf, "run", 3) == 0) {
 		/* timestamp_pcrscr_enable(1); */
 		run_flag = DI_RUN_FLAG_RUN;
@@ -690,11 +673,28 @@ store_dbg(struct device *dev,
 		pr_info("[0x%x][0x%x]=0x%x\n",
 			0xd0100000 + (0x1aa7 << 2),
 			0x1aa7, Rd(0x1aa7));
+		pr_info("----dump dnr reg----\n");
+		for (i = 0; i < 29; i++)
+			pr_info("[0x%x][0x%x]=0x%x\n",
+				0xd0100000 + ((0x2d00 + i) << 2),
+				0x2d00 + i, Rd(0x2d00 + i));
+		pr_info("----dump if0 reg----\n");
+		for (i = 0; i < 26; i++)
+			pr_info("[0x%x][0x%x]=0x%x\n",
+				0xd0100000 + ((0x1a60 + i) << 2),
+				0x1a50 + i, Rd(0x1a50 + i));
+		pr_info("----dump if2 reg----\n");
+		for (i = 0; i < 29; i++)
+			pr_info("[0x%x][0x%x]=0x%x\n",
+				0xd0100000 + ((0x2010 + i) << 2),
+				0x2010 + i, Rd(0x2010 + i));
 		pr_info("----dump reg done----\n");
 	} else if (strncmp(buf, "robust_test", 11) == 0) {
 		recovery_flag = 1;
 	} else if (strncmp(buf, "recycle_buf", 11) == 0) {
 		recycle_keep_buffer();
+	} else {
+		pr_info("DI no support cmd!!!\n");
 	}
 
 	return count;
@@ -726,6 +726,7 @@ static unsigned int di_printk_flag;
 unsigned int di_log_flag = 0;
 unsigned int buf_state_log_threshold = 16;
 unsigned int buf_state_log_start = 0;
+static unsigned int timerc_cnt;
 /*  set to 1 by condition of "post_ready count < buf_state_log_threshold",
  * reset to 0 by set buf_state_log_threshold as 0 */
 
@@ -786,10 +787,10 @@ int di_print(const char *fmt, ...)
 /* len += snprintf(buf+len, avail-len, "%d:",log_seq++); */
 	if (di_log_flag & DI_LOG_TIMESTAMP)
 		len += snprintf(buf + len, avail - len, "%u:",
-			(unsigned int)jiffies);
+			jiffies_to_msecs(jiffies_64));
 	else if (di_log_flag & DI_LOG_PRECISE_TIMESTAMP)
 		len += snprintf(buf + len, avail - len, "%u:",
-			(unsigned int)aml_read_cbus(ISA_TIMERE));
+			aml_read_cbus(ISA_TIMERE));
 
 	va_start(args, fmt);
 	len += vsnprintf(buf + len, avail - len, fmt, args);
@@ -1052,11 +1053,14 @@ show_vframe_status(struct device *dev,
 static void parse_cmd_params(char *buf_orig, char **parm)
 {
 	char *ps, *token;
+	char delim1[2] = " ";
+	char delim2[2] = "\n";
 	unsigned int n = 0;
 
+	strcat(delim1, delim2);
 	ps = buf_orig;
 	while (1) {
-		token = strsep(&ps, "\n");
+		token = strsep(&ps, delim1);
 		if (token == NULL)
 			break;
 		if (*token == '\0')
@@ -1204,7 +1208,7 @@ static DEVICE_ATTR(tvp_region, 0444, show_tvp_region, NULL);
 /***************************
 * di buffer management
 ***************************/
-#define MAX_IN_BUF_NUM            16
+#define MAX_IN_BUF_NUM            20
 #define MAX_LOCAL_BUF_NUM         12
 #define MAX_POST_BUF_NUM          16
 
@@ -1784,8 +1788,10 @@ struct di_pre_stru_s {
 	/* flag is set when VFRAME_EVENT_PROVIDER_UNREG*/
 	int	unreg_req_flag;
 	int	unreg_req_flag_irq;
+	int	unreg_req_flag_cnt;
 	int	reg_req_flag;
 	int	reg_req_flag_irq;
+	int	reg_req_flag_cnt;
 	int	force_unreg_req_flag;
 	int	disable_req_flag;
 	/* current source info */
@@ -1803,6 +1809,9 @@ struct di_pre_stru_s {
 	unsigned char prog_proc_type;
 /* set by prog_proc_config when source is vdin,0:use 2 i
  * serial buffer,1:use 1 p buffer,3:use 2 i paralleling buffer*/
+	unsigned char buf_alloc_mode;
+/* alloc di buf as p or i;0: alloc buf as i;
+ * 1: alloc buf as p;*/
 	unsigned char enable_mtnwr;
 	unsigned char enable_pulldown_check;
 
@@ -1829,6 +1838,15 @@ struct di_pre_stru_s {
 	int	static_frame_count;
 	bool force_interlace;
 	bool bypass_pre;
+	bool invert_flag;
+	int nr_size;
+	int count_size;
+	int mcinfo_size;
+	int mv_size;
+	int mtn_size;
+	int cma_alloc_req;
+	int cma_alloc_done;
+	int cma_release_req;
 };
 static struct di_pre_stru_s di_pre_stru;
 
@@ -1893,6 +1911,8 @@ static void dump_di_pre_stru(void)
 		di_pre_stru.vdin2nr);
 	pr_info("bypass_pre		   = %s\n",
 		di_pre_stru.bypass_pre ? "true" : "false");
+	pr_info("invert_flag	   = %s\n",
+		di_pre_stru.invert_flag ? "true" : "false");
 }
 
 struct di_post_stru_s {
@@ -1917,6 +1937,8 @@ struct di_post_stru_s {
 	int de_post_process_done;
 	int post_de_busy;
 	int di_post_num;
+	unsigned int di_post_process_cnt;
+	unsigned int check_recycle_buf_cnt;
 };
 static struct di_post_stru_s di_post_stru;
 static void dump_di_post_stru(void)
@@ -1939,7 +1961,9 @@ static ssize_t
 store_dump_mem(struct device *dev, struct device_attribute *attr,
 	       const char *buf, size_t len)
 {
-	unsigned int n = 0, canvas_w = 0, canvas_h = 0, canvas_real_size = 0;
+	unsigned int n = 0, canvas_w = 0, canvas_h = 0;
+	unsigned long nr_size = 0;
+	struct di_buf_s *di_buf;
 	char *buf_orig, *ps, *token;
 	char *parm[3] = { NULL };
 	struct file *filp = NULL;
@@ -1959,20 +1983,23 @@ store_dump_mem(struct device *dev, struct device_attribute *attr,
 			continue;
 		parm[n++] = token;
 	}
-	if (0 == strcmp(parm[0], "capture")) {
-		if (parm[1] != NULL)
-			if (unlikely(di_pre_stru.di_mem_buf_dup_p == NULL))
-				return len;
-
-		canvas_w =
-			(di_pre_stru.di_mem_buf_dup_p->canvas_config_size >> 16)
-			& 0xffff;
-		canvas_h =
-			(di_pre_stru.di_mem_buf_dup_p->canvas_config_size)
-			& 0xffff;
-		canvas_real_size = canvas_w * canvas_h * 2;
-		old_fs = get_fs();
-		set_fs(KERNEL_DS);
+	if (0 == strcmp(parm[0], "capture"))
+		di_buf = di_pre_stru.di_mem_buf_dup_p;
+	else if (0 == strcmp(parm[0], "capture_post"))
+		di_buf = di_post_stru.cur_post_buf;
+	else {
+		pr_err("wrong dump cmd\n");
+		return len;
+	}
+	if (parm[1] != NULL) {
+		if (unlikely(di_buf == NULL))
+			return len;
+	}
+	canvas_w = di_buf->canvas_width[NR_CANVAS];
+	canvas_h = di_buf->canvas_height;
+	nr_size = canvas_w * canvas_h * 2;
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
 /* pr_dbg("dump path =%s\n",dump_path); */
 		filp = filp_open(parm[1], O_RDWR | O_CREAT, 0666);
 		if (IS_ERR(filp)) {
@@ -1980,9 +2007,13 @@ store_dump_mem(struct device *dev, struct device_attribute *attr,
 			return len;
 		}
 		dump_state_flag = 1;
-
-		buff = phys_to_virt(di_pre_stru.di_mem_buf_dup_p->nr_adr);
-		vfs_write(filp, buff, canvas_real_size, &pos);
+		if (de_devp->flags && DI_MAP_FLAG)
+			buff = phys_to_virt(di_buf->nr_adr);
+		else
+			buff = ioremap(di_buf->nr_adr, nr_size);
+		if (buff == NULL)
+			pr_err("%s: ioremap error.\n", __func__);
+		vfs_write(filp, buff, nr_size, &pos);
 /*	pr_dbg("di_chan2_buf_dup_p:\n	nr:%u,mtn:%u,cnt:%u\n",
  * di_pre_stru.di_chan2_buf_dup_p->nr_adr,
  * di_pre_stru.di_chan2_buf_dup_p->mtn_adr,
@@ -2002,69 +2033,12 @@ store_dump_mem(struct device *dev, struct device_attribute *attr,
  * pr_dbg("di_mem_start=%u\n",di_mem_start);
  */
 		vfs_fsync(filp, 0);
+		if (!(de_devp->flags & DI_MAP_FLAG))
+			iounmap(buff);
 		dump_state_flag = 0;
 		filp_close(filp, NULL);
 		set_fs(old_fs);
-		pr_dbg("write buffer %d  to %s.\n",
-			di_pre_stru.di_mem_buf_dup_p->seq, parm[1]);
-	} else if (0 == strcmp(parm[0], "cap_input")) {
-		if (parm[1] != NULL)
-			if (vf_input_buff == NULL) {
-				pr_dbg("vf_input_buff is NULL\n");
-				return len;
-			}
-		canvas_real_size = vf_input_size;
-		old_fs = get_fs();
-		set_fs(KERNEL_DS);
-		pr_dbg("dump path =%s\n", parm[1]);
-		filp = filp_open(parm[1], O_RDWR | O_CREAT, 0666);
-		if (IS_ERR(filp)) {
-			pr_err("create %s error.\n", parm[1]);
-			return len;
-		}
-		dump_state_flag = 1;
-		pos = 0;
-		vfs_write(filp, vf_input_buff,
-			dump_one_frame_size * dump_vf_num, &pos);
-		vfs_fsync(filp, 0);
-		dump_state_flag = 0;
-		filp_close(filp, NULL);
-		set_fs(old_fs);
-		if (NULL != vf_input_buff) {
-			kfree(vf_input_buff);
-			vf_input_buff = NULL;
-		}
-	} else if (0 == strcmp(parm[0], "capture_post_wr_mem")) {
-		if (parm[1] != NULL)
-			if (unlikely(di_pre_stru.di_post_wr_buf == NULL))
-				return len;
-
-		canvas_w =
-(di_pre_stru.di_post_wr_buf->canvas_config_size>>16)&0xffff;
-		canvas_h =
-(di_pre_stru.di_post_wr_buf->canvas_config_size)&0xffff;
-		canvas_real_size = canvas_w*canvas_h*2;
-		old_fs = get_fs();
-		set_fs(KERNEL_DS);
-		/* pr_info("dump path =%s\n",dump_path); */
-		filp = filp_open(parm[1], O_RDWR|O_CREAT, 0666);
-		if (IS_ERR(filp)) {
-			pr_err("create %s error.\n", parm[1]);
-			return len;
-		}
-		dump_state_flag = 1;
-
-		buff = phys_to_virt(di_pre_stru.di_post_wr_buf->nr_adr);
-		vfs_write(filp, buff, canvas_real_size, &pos);
-		vfs_fsync(filp, 0);
-		dump_state_flag = 0;
-		filp_close(filp, NULL);
-		set_fs(old_fs);
-		di_pr_info("write buffer %d  to %s.\n",
-di_pre_stru.di_mem_buf_dup_p->seq, parm[1]);
-	} else
-		pr_dbg("wrong dump di canvas\n");
-
+		pr_info("write buffer %d  to %s.\n", di_buf->seq, parm[1]);
 	return len;
 }
 #endif
@@ -2072,7 +2046,7 @@ di_pre_stru.di_mem_buf_dup_p->seq, parm[1]);
 #define is_from_vdin(vframe) (vframe->type & VIDTYPE_VIU_422)
 static void recycle_vframe_type_pre(struct di_buf_s *di_buf);
 static void recycle_vframe_type_post(struct di_buf_s *di_buf);
-#ifdef DI_DEBUG
+#ifdef DI_BUFFER_DEBUG
 static void
 recycle_vframe_type_post_print(struct di_buf_s *di_buf,
 				const char *func,
@@ -2140,7 +2114,7 @@ reg_cfg_t di_default_post = {
 		{DI_MTN_1_CTRL2, 0x141a2062, 0, 31},
 		{DI_MTN_1_CTRL3, 0x1520050a, 0, 31},
 		{DI_MTN_1_CTRL4, 0x08800840, 0, 31},
-		{DI_MTN_1_CTRL5, 0x74000d0d, 0, 31},
+		{DI_MTN_1_CTRL5, 0x74200d0d, 0, 31},
 /* #define DI_MTN_1_CTRL6 */
 		{DI_MTN_1_CTRL6, 0x0d5a1520, 0, 31},
 /* #define DI_MTN_1_CTRL7 */
@@ -2286,7 +2260,7 @@ store_config(struct device *dev,
 
 		di_print("%s: disable\n", __func__);
 
-		if (init_flag) {
+		if (init_flag && mem_flag) {
 			di_pre_stru.disable_req_flag = 1;
 			provider_vframe_level = 0;
 			bypass_dynamic_flag = 0;
@@ -2306,8 +2280,7 @@ static unsigned char is_progressive(vframe_t *vframe)
 {
 	unsigned char ret = 0;
 
-	ret =
-		((vframe->type & VIDTYPE_TYPEMASK) == VIDTYPE_PROGRESSIVE);
+	ret = ((vframe->type & VIDTYPE_TYPEMASK) == VIDTYPE_PROGRESSIVE);
 	return ret;
 }
 
@@ -2391,7 +2364,7 @@ static unsigned char is_bypass(vframe_t *vf_in)
 	    )
 		return 1;
 	if (bypass_superd &&
-	    ((di_pre_stru.cur_width > 1920) || (di_pre_stru.cur_height > 1080))
+	    ((di_pre_stru.cur_width > 1920) && (di_pre_stru.cur_height > 1080))
 	    )
 		return 1;
 	if ((di_pre_stru.cur_width < 16) || (di_pre_stru.cur_height < 16))
@@ -2405,8 +2378,13 @@ static unsigned char is_bypass(vframe_t *vf_in)
 
 	if (((bypass_trick_mode) &&
 	     (new_keep_last_frame_enable == 0)) || (bypass_trick_mode & 0x2)) {
-		int trick_mode;
-		query_video_status(0, &trick_mode);
+		int trick_mode_fffb = 0;
+		int trick_mode_i = 0;
+		if (bypass_trick_mode&0x1)
+			query_video_status(0, &trick_mode_fffb);
+		if (bypass_trick_mode&0x2)
+			query_video_status(1, &trick_mode_i);
+		trick_mode = trick_mode_fffb | (trick_mode_i << 1);
 		if (trick_mode)
 			return 1;
 	}
@@ -2530,31 +2508,32 @@ static int di_get_canvas(void)
 static void config_canvas_idx(struct di_buf_s *di_buf, int nr_canvas_idx,
 	int mtn_canvas_idx)
 {
-	unsigned int width, canvas_height;
-
+	unsigned int height = 0;
 	if (!di_buf)
 		return;
-	width = (di_buf->canvas_config_size >> 16) & 0xffff;
-	canvas_height = (di_buf->canvas_config_size) & 0xffff;
 	if (di_buf->canvas_config_flag == 1) {
 		if (nr_canvas_idx >= 0) {
+			/* linked two interlace buffer should double height*/
+			if (di_buf->di_wr_linked_buf)
+				height = (di_buf->canvas_height << 1);
+			else
+				height =  di_buf->canvas_height;
 			di_buf->nr_canvas_idx = nr_canvas_idx;
-			canvas_config(
-				nr_canvas_idx, di_buf->nr_adr, width * 2,
-				canvas_height, 0, 0);
+			canvas_config(nr_canvas_idx, di_buf->nr_adr,
+				di_buf->canvas_width[NR_CANVAS], height, 0, 0);
 		}
 	} else if (di_buf->canvas_config_flag == 2) {
 		if (nr_canvas_idx >= 0) {
 			di_buf->nr_canvas_idx = nr_canvas_idx;
-			canvas_config(
-				nr_canvas_idx, di_buf->nr_adr, width * 2,
-				canvas_height / 2, 0, 0);
+			canvas_config(nr_canvas_idx, di_buf->nr_adr,
+				di_buf->canvas_width[NR_CANVAS],
+				di_buf->canvas_height, 0, 0);
 		}
 		if (mtn_canvas_idx >= 0) {
 			di_buf->mtn_canvas_idx = mtn_canvas_idx;
-			canvas_config(
-				mtn_canvas_idx, di_buf->mtn_adr, width / 2,
-				canvas_height / 2, 0, 0);
+			canvas_config(mtn_canvas_idx, di_buf->mtn_adr,
+				di_buf->canvas_width[MTN_CANVAS],
+				di_buf->canvas_height, 0, 0);
 		}
 	}
 	if (nr_canvas_idx >= 0) {
@@ -2567,45 +2546,42 @@ static void config_canvas_idx(struct di_buf_s *di_buf, int nr_canvas_idx,
 static void config_cnt_canvas_idx(struct di_buf_s *di_buf,
 	unsigned int cnt_canvas_idx)
 {
-	unsigned int width, canvas_height;
 
 	if (!di_buf)
 		return;
-	width = (di_buf->canvas_config_size >> 16) & 0xffff;
-	canvas_height = (di_buf->canvas_config_size) & 0xffff;
+
 	di_buf->cnt_canvas_idx = cnt_canvas_idx;
 	canvas_config(
-		cnt_canvas_idx, di_buf->cnt_adr, width / 2, canvas_height / 2,
-		0, 0);
+		cnt_canvas_idx, di_buf->cnt_adr,
+		di_buf->canvas_width[MTN_CANVAS],
+		di_buf->canvas_height, 0, 0);
 }
 #endif
 
 static void config_mcinfo_canvas_idx(struct di_buf_s *di_buf,
 	int mcinfo_canvas_idx)
 {
-	unsigned int canvas_height;
 
 	if (!di_buf)
 		return;
-	canvas_height = (di_buf->canvas_config_size) & 0xffff;
+
 	di_buf->mcinfo_canvas_idx = mcinfo_canvas_idx;
 	canvas_config(
-		mcinfo_canvas_idx, di_buf->mcinfo_adr, canvas_height / 2, 2, 0,
-		0);
+		mcinfo_canvas_idx, di_buf->mcinfo_adr,
+		di_buf->canvas_height, 2, 0, 0);
 }
 static void config_mcvec_canvas_idx(struct di_buf_s *di_buf,
 	int mcvec_canvas_idx)
 {
-	unsigned int width, canvas_height;
 
 	if (!di_buf)
 		return;
-	width = (di_buf->canvas_config_size >> 16) & 0xffff;
-	canvas_height = (di_buf->canvas_config_size) & 0xffff;
+
 	di_buf->mcvec_canvas_idx = mcvec_canvas_idx;
 	canvas_config(
-		mcvec_canvas_idx, di_buf->mcvec_adr, width * 2 / 5,
-		canvas_height / 2, 0, 0);
+		mcvec_canvas_idx, di_buf->mcvec_adr,
+		di_buf->canvas_width[MV_CANVAS],
+		di_buf->canvas_height, 0, 0);
 }
 
 
@@ -2613,37 +2589,145 @@ static void config_mcvec_canvas_idx(struct di_buf_s *di_buf,
 
 static void config_canvas(struct di_buf_s *di_buf)
 {
-	unsigned int width, canvas_height;
-
+	unsigned int height = 0;
 	if (!di_buf)
 		return;
-	width = (di_buf->canvas_config_size >> 16) & 0xffff;
-	canvas_height = (di_buf->canvas_config_size) & 0xffff;
+
 	if (di_buf->canvas_config_flag == 1) {
-		canvas_config(
-			di_buf->nr_canvas_idx, di_buf->nr_adr, width * 2,
-			canvas_height, 0, 0);
+			/* linked two interlace buffer should double height*/
+			if (di_buf->di_wr_linked_buf)
+				height = (di_buf->canvas_height << 1);
+			else
+				height =  di_buf->canvas_height;
+		canvas_config(di_buf->nr_canvas_idx, di_buf->nr_adr,
+			di_buf->canvas_width[NR_CANVAS], height, 0, 0);
 		di_buf->canvas_config_flag = 0;
 	} else if (di_buf->canvas_config_flag == 2) {
-		canvas_config(
-			di_buf->nr_canvas_idx, di_buf->nr_adr, width * 2,
-			canvas_height / 2, 0, 0);
-		canvas_config(
-			di_buf->mtn_canvas_idx, di_buf->mtn_adr, width / 2,
-			canvas_height / 2, 0, 0);
+		canvas_config(di_buf->nr_canvas_idx, di_buf->nr_adr,
+			di_buf->canvas_width[MV_CANVAS],
+			di_buf->canvas_height, 0, 0);
+		canvas_config(di_buf->mtn_canvas_idx, di_buf->mtn_adr,
+			di_buf->canvas_width[MTN_CANVAS],
+			di_buf->canvas_height, 0, 0);
 		di_buf->canvas_config_flag = 0;
 	}
 }
 
 #endif
-
+#ifdef CONFIG_CMA
+void di_cma_alloc(void)
+{
+	unsigned int i, start_time, end_time, delta_time;
+	if (bypass_4K == 1) {
+		pr_dbg("%s:di don't need alloc mem for 4k input\n", __func__);
+		return;
+	}
+	start_time = jiffies_to_msecs(jiffies);
+	for (i = 0; (i < local_buf_num); i++) {
+		struct di_buf_s *di_buf = &(di_buf_local[i]);
+		int ii = USED_LOCAL_BUF_MAX;
+		if ((used_post_buf_index != -1) &&
+		    (new_keep_last_frame_enable)) {
+			for (ii = 0; ii < USED_LOCAL_BUF_MAX; ii++) {
+				if (i == used_local_buf_index[ii]) {
+					pr_dbg("%s skip %d,cma_alloc=%d\n",
+						__func__, i,
+						de_devp->cma_alloc[i]);
+					break;
+				}
+			}
+		}
+		if ((ii >= USED_LOCAL_BUF_MAX) &&
+			(de_devp->cma_alloc[i] == 0)) {
+			de_devp->pages[i] =
+				dma_alloc_from_contiguous(&(de_devp->pdev->dev),
+				de_devp->buffer_size >> PAGE_SHIFT, 0);
+			if (de_devp->pages[i]) {
+				de_devp->mem_start =
+					page_to_phys(de_devp->pages[i]);
+				de_devp->cma_alloc[i] = 1;
+				pr_dbg("DI CMA  allocate addr:0x%x[%d] ok.\n",
+					(unsigned int)de_devp->mem_start, i);
+			} else {
+				pr_dbg("DI CMA  allocate %d fail.\n", i);
+			}
+			if (di_pre_stru.buf_alloc_mode) {
+				di_buf->nr_adr = de_devp->mem_start;
+			} else {
+				di_buf->nr_adr = de_devp->mem_start;
+				di_buf->mtn_adr = de_devp->mem_start +
+					di_pre_stru.nr_size;
+#ifdef NEW_DI_V1
+				di_buf->cnt_adr = de_devp->mem_start +
+					di_pre_stru.nr_size +
+					di_pre_stru.mtn_size;
+#endif
+				if (mcpre_en) {
+					di_buf->mcvec_adr = de_devp->mem_start +
+						di_pre_stru.nr_size +
+						di_pre_stru.mtn_size +
+						di_pre_stru.count_size;
+					di_buf->mcinfo_adr =
+						de_devp->mem_start +
+						di_pre_stru.nr_size +
+						di_pre_stru.mtn_size +
+						di_pre_stru.count_size +
+						di_pre_stru.mv_size;
+				}
+			}
+		}
+	}
+	end_time = jiffies_to_msecs(jiffies);
+	delta_time = end_time - start_time;
+	pr_dbg("%s:alloc use %d ms(%d~%d)\n", __func__, delta_time,
+		start_time, end_time);
+}
+void di_cma_release(void)
+{
+	unsigned int i, start_time, end_time, delta_time;
+	start_time = jiffies_to_msecs(jiffies);
+	for (i = 0; (i < local_buf_num); i++) {
+		int ii = USED_LOCAL_BUF_MAX;
+		if ((used_post_buf_index != -1) &&
+		    (new_keep_last_frame_enable)) {
+			for (ii = 0; ii < USED_LOCAL_BUF_MAX; ii++) {
+				if (i == used_local_buf_index[ii]) {
+					pr_dbg("%s skip %d,cma_alloc=%d\n",
+						__func__, i,
+						de_devp->cma_alloc[i]);
+					break;
+				}
+			}
+		}
+		if ((ii >= USED_LOCAL_BUF_MAX) &&
+			(de_devp->cma_alloc[i] == 1)) {
+			if (dma_release_from_contiguous(&(de_devp->pdev->dev),
+				de_devp->pages[i],
+				de_devp->buffer_size >> PAGE_SHIFT)) {
+				de_devp->cma_alloc[i] = 0;
+				pr_dbg("DI CMA  release %d ok.\n", i);
+			} else {
+				pr_dbg("DI CMA  release %d fail.\n", i);
+			}
+		}
+	}
+	end_time = jiffies_to_msecs(jiffies);
+	delta_time = end_time - start_time;
+	pr_dbg("%s:release use %d ms(%d~%d)\n", __func__, delta_time,
+		start_time, end_time);
+}
+#endif
 static int di_init_buf(int width, int height, unsigned char prog_flag)
 {
-	int i, local_buf_num_available, local_buf_num_valid;
+	int i;
 	int canvas_height = height + 8;
 
-	unsigned int di_buf_size;
-	unsigned int di_post_mem = 0, di_post_buf_size = 0;
+	unsigned int di_buf_size = 0, di_post_buf_size = 0, mtn_size = 0;
+	unsigned int nr_size = 0, count_size = 0, mv_size = 0, mc_size = 0;
+	unsigned int nr_width = width, mtn_width = width, mv_width = width;
+	unsigned int nr_canvas_width = width, mtn_canvas_width = width;
+	unsigned int mv_canvas_width = width;
+	unsigned long di_post_mem = 0;
 	frame_count = 0;
 	disp_frame_count = 0;
 	cur_post_ready_di_buf = NULL;
@@ -2655,13 +2739,32 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
 			vframe_in[i] = NULL;
 		}
 	}
-
 	memset(&di_pre_stru, 0, sizeof(di_pre_stru));
+	if (nr10bit_surpport) {
+		if (full_422_pack)
+			nr_width = (width * 5) / 4;
+		else
+			nr_width = (width * 3) / 2;
+	} else {
+		nr_width = width;
+	}
+	/* make sure canvas width must be divided by 256bit|32byte align */
+	nr_canvas_width = nr_width << 1;
+	mtn_canvas_width = mtn_width >> 1;
+	mv_canvas_width = (mv_width << 1) / 5;
+	nr_canvas_width = roundup(nr_canvas_width, 32);
+	mtn_canvas_width = roundup(mtn_canvas_width, 32);
+	mv_canvas_width = roundup(mv_canvas_width, 32);
+	nr_width = nr_canvas_width >> 1;
+	mtn_width = mtn_canvas_width << 1;
+	mv_width = (mv_canvas_width * 5) >> 1;
+
 	if (prog_flag) {
 		di_pre_stru.prog_proc_type = 1;
-		di_buf_size = width * canvas_height * 2;
+		di_pre_stru.buf_alloc_mode = 1;
+		di_buf_size = nr_width * canvas_height * 2;
+		di_buf_size = roundup(di_buf_size, PAGE_SIZE);
 		local_buf_num = de_devp->mem_size / di_buf_size;
-		local_buf_num_available = local_buf_num;
 		if (local_buf_num > (2 * MAX_LOCAL_BUF_NUM))
 			local_buf_num = 2 * MAX_LOCAL_BUF_NUM;
 
@@ -2671,35 +2774,35 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
 			new_keep_last_frame_enable = 0;
 	} else {
 		di_pre_stru.prog_proc_type = 0;
-
+		di_pre_stru.buf_alloc_mode = 0;
+		/*nr_size(bits)=w*active_h*8*2(yuv422)
+		* mtn(bits)=w*active_h*4
+		* cont(bits)=w*active_h*4 mv(bits)=w*active_h/5*16
+		* mcinfo(bits)=active_h*16*/
+		nr_size = (nr_width * canvas_height)*8*2/16;
+		mtn_size = (mtn_width * canvas_height)*4/16;
+		count_size = (mtn_width * canvas_height)*4/16;
+		mv_size = (mv_width * canvas_height)/5;
+		mc_size = canvas_height;
 		if (mcpre_en) {
-			/*nr_size(bits)=w*active_h*8*2(yuv422)
-			 * mtn(bits)=w*active_h*4
-			 * cont(bits)=w*active_h*4 mv(bits)=w*active_h/5*16
-			 * mcinfo(bits)=active_h*16*/
-			di_buf_size =
-				(width * canvas_height) * 6 / 4 + width *
-				canvas_height / 5 + canvas_height;
-			/* 3552320 bytes */
+			di_buf_size = nr_size + mtn_size + count_size +
+				mv_size + mc_size;
 		} else {
 #ifdef NEW_DI_V1
-			/* 3133440 bytes */
-			di_buf_size = width * canvas_height * 6 / 4;
+			di_buf_size = nr_size + mtn_size + count_size;
 #else
-			/* 2611200 bytes */
-			di_buf_size = width * canvas_height * 5 / 4;
+			di_buf_size = nr_size + mtn_size;
 #endif
 		}
-
+		di_buf_size = roundup(di_buf_size, PAGE_SIZE);
 		local_buf_num = de_devp->mem_size / di_buf_size;
 
 		if (post_wr_en && post_wr_surpport) {
 			local_buf_num = (de_devp->mem_size +
-				(width*canvas_height<<2)) /
-				(di_buf_size + (width*canvas_height<<1));
+				(nr_width*canvas_height<<2)) /
+				(di_buf_size + (nr_width*canvas_height<<1));
 		}
 
-		local_buf_num_available = local_buf_num;
 		if (local_buf_num > MAX_LOCAL_BUF_NUM)
 			local_buf_num = MAX_LOCAL_BUF_NUM;
 
@@ -2708,13 +2811,17 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
 		else
 			new_keep_last_frame_enable = 0;
 	}
-
+	de_devp->buffer_size = di_buf_size;
+	di_pre_stru.nr_size = nr_size;
+	di_pre_stru.count_size = count_size;
+	di_pre_stru.mtn_size = mtn_size;
+	di_pre_stru.mv_size = mv_size;
+	di_pre_stru.mcinfo_size = mc_size;
 	same_w_r_canvas_count = 0;
 	same_field_top_count = 0;
 	same_field_bot_count = 0;
 
 	queue_init(local_buf_num);
-	local_buf_num_valid = local_buf_num;
 	for (i = 0; i < local_buf_num; i++) {
 		struct di_buf_s *di_buf = &(di_buf_local[i]);
 		int ii = USED_LOCAL_BUF_MAX;
@@ -2726,8 +2833,6 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
 					break;
 				}
 			}
-			if (ii < USED_LOCAL_BUF_MAX)
-				local_buf_num_valid--;
 		}
 
 		if (ii >= USED_LOCAL_BUF_MAX) {
@@ -2735,39 +2840,37 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
 			di_buf->type = VFRAME_TYPE_LOCAL;
 			di_buf->pre_ref_count = 0;
 			di_buf->post_ref_count = 0;
+			di_buf->canvas_width[NR_CANVAS] = nr_canvas_width;
+			di_buf->canvas_width[MTN_CANVAS] = mtn_canvas_width;
+			di_buf->canvas_width[MV_CANVAS] = mv_canvas_width;
 			if (prog_flag) {
-				di_buf->nr_adr
-					= de_devp->mem_start + di_buf_size * i;
+				di_buf->canvas_height = canvas_height;
+				di_buf->nr_adr = de_devp->mem_start +
+					di_buf_size * i;
 				di_buf->canvas_config_flag = 1;
-				di_buf->canvas_config_size
-					= (width << 16) | canvas_height;
 			} else {
-				di_buf->nr_adr
-					= de_devp->mem_start + di_buf_size * i;
-				di_buf->mtn_adr
-					= de_devp->mem_start + di_buf_size * i +
-					  width * canvas_height;
+				di_buf->canvas_height = (canvas_height>>1);
+				di_buf->nr_adr = de_devp->mem_start +
+					di_buf_size * i;
+				di_buf->mtn_adr = de_devp->mem_start +
+					di_buf_size * i +
+					nr_size;
 #ifdef NEW_DI_V1
-				di_buf->cnt_adr =
-					de_devp->mem_start + di_buf_size * i +
-					(width * canvas_height) * 5 / 4;
+				di_buf->cnt_adr = de_devp->mem_start +
+					di_buf_size * i +
+					nr_size + mtn_size;
 #endif
 
 				if (mcpre_en) {
-					di_buf->mcvec_adr =
-						de_devp->mem_start +
+					di_buf->mcvec_adr = de_devp->mem_start +
 						di_buf_size * i +
-						(width * canvas_height) * 6 / 4;
+						nr_size + mtn_size + count_size;
 					di_buf->mcinfo_adr =
 						de_devp->mem_start +
-						di_buf_size * i +
-						(width * canvas_height) * 6 /
-						4 +
-						width * canvas_height / 5;
+						di_buf_size * i + nr_size +
+						mtn_size + count_size + mv_size;
 				}
 				di_buf->canvas_config_flag = 2;
-				di_buf->canvas_config_size
-					= (width << 16) | canvas_height;
 			}
 			di_buf->index = i;
 			di_buf->vframe = &(vframe_local[i]);
@@ -2779,17 +2882,25 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
 			queue_in(di_buf, QUEUE_LOCAL_FREE);
 		}
 	}
-
+#ifdef CONFIG_CMA
+	if (de_devp->flag_cma == 1) {
+		pr_dbg("%s:cma alloc req time: %d ms\n",
+			__func__, jiffies_to_msecs(jiffies));
+		di_pre_stru.cma_alloc_req = 1;
+		up(&di_sema);
+	}
+#endif
 	if (post_wr_en && post_wr_surpport) {
 		di_post_mem = de_devp->mem_start + di_buf_size*local_buf_num;
 		di_post_buf_size = width * canvas_height*2;
 		/* pre buffer must 2 more than post buffer */
 		di_post_stru.di_post_num = local_buf_num - 2;
+		pr_info("DI: di post buffer size %u byte.\n", di_post_buf_size);
 	} else {
 		di_post_stru.di_post_num = MAX_POST_BUF_NUM;
 		di_post_buf_size = 0;
 	}
-	for (i = 0; i < di_post_stru.di_post_num; i++) {
+	for (i = 0; i < MAX_IN_BUF_NUM; i++) {
 		struct di_buf_s *di_buf = &(di_buf_in[i]);
 		if (di_buf) {
 			memset(di_buf, 0, sizeof(struct di_buf_s));
@@ -2805,7 +2916,7 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
 		}
 	}
 
-	for (i = 0; i < MAX_POST_BUF_NUM; i++) {
+	for (i = 0; i < di_post_stru.di_post_num; i++) {
 		struct di_buf_s *di_buf = &(di_buf_post[i]);
 		if (di_buf) {
 			if (i != used_post_buf_index) {
@@ -2816,6 +2927,14 @@ static int di_init_buf(int width, int height, unsigned char prog_flag)
 				di_buf->vframe->private_data = di_buf;
 				di_buf->queue_index = -1;
 				di_buf->invert_top_bot_flag = 0;
+				if (post_wr_en && post_wr_surpport) {
+					di_buf->canvas_width[NR_CANVAS] =
+						(nr_width << 1);
+					di_buf->canvas_height = canvas_height;
+					di_buf->canvas_config_flag = 1;
+					di_buf->nr_adr = di_post_mem +
+						di_post_buf_size*i;
+				}
 				queue_in(di_buf, QUEUE_POST_FREE);
 			}
 		}
@@ -2905,7 +3024,14 @@ static void di_uninit_buf(void)
 			vframe_in[i] = NULL;
 		}
 	}
-
+#ifdef CONFIG_CMA
+	if (de_devp->flag_cma == 1) {
+		pr_dbg("%s:cma release req time: %d ms\n",
+			__func__, jiffies_to_msecs(jiffies));
+		di_pre_stru.cma_release_req = 1;
+		up(&di_sema);
+	}
+#endif
 	di_pre_stru.pre_de_process_done = 0;
 	di_pre_stru.pre_de_busy = 0;
 	if (post_wr_en && post_wr_surpport) {
@@ -3110,6 +3236,7 @@ static void dump_state(void)
 		recovery_flag, recovery_log_reason, di_blocking);
 	pr_info("recovery_log_queue_idx=%d, recovery_log_di_buf=0x%p\n",
 		recovery_log_queue_idx, recovery_log_di_buf);
+	pr_info("buffer_size=%d,mem_flag=%d\n", de_devp->buffer_size, mem_flag);
 	pr_info("new_keep_last_frame_enable %d,", new_keep_last_frame_enable);
 	pr_info("used_post_buf_index %d(0x%p),", used_post_buf_index,
 		(used_post_buf_index ==
@@ -3139,7 +3266,7 @@ static void dump_state(void)
 	queue_for_each_entry(p, ptmp, QUEUE_PRE_READY, list) {
 		print_di_buf(p, 2);
 	}
-	pr_info("post_free_list (max %d):\n", MAX_POST_BUF_NUM);
+	pr_info("post_free_list (max %d):\n", di_post_stru.di_post_num);
 	queue_for_each_entry(p, ptmp, QUEUE_POST_FREE, list) {
 		pr_info("index %2d, 0x%p, type %d, vframetype 0x%x\n",
 			p->index, p, p->type, p->vframe->type);
@@ -3311,7 +3438,8 @@ config_di_wr_mif(struct DI_SIM_MIF_s *di_nrwr_mif,
 		di_mtnwr_mif->canvas_num = di_buf->mtn_canvas_idx;
 	}
 }
-
+static bool force_prog;
+module_param_named(force_prog, force_prog, bool, 0664);
 static void config_di_mif(struct DI_MIF_s *di_mif, struct di_buf_s *di_buf)
 {
 	if (di_buf == NULL)
@@ -3391,7 +3519,7 @@ static void config_di_mif(struct DI_MIF_s *di_mif, struct di_buf_s *di_buf)
 			di_mif->chroma_y_end0 =
 				di_buf->vframe->height / 2 - 1;
 		} else {
-			di_mif->src_prog = di_pre_stru.cur_prog_flag;
+			di_mif->src_prog = force_prog?1:0;
 			di_mif->src_field_mode = 1;
 			if (
 				(di_buf->vframe->type & VIDTYPE_TYPEMASK) ==
@@ -3668,7 +3796,7 @@ static void pre_de_process(void)
 
 	/* enable pre mif*/
 	enable_di_pre_mif(1);
-
+	di_print("DI:buf[%d] irq start.\n", di_pre_stru.di_inp_buf->seq);
 #ifdef CONFIG_AML_RDMA
 	if (di_pre_rdma_enable & 0x2)
 		rdma_config(de_devp->rdma_handle, RDMA_TRIGGER_MANUAL);
@@ -3793,7 +3921,7 @@ static unsigned int combing_pure_still_setting[MAX_NUM_DI_REG] = {
 	0x1A1A3A62,
 	0x15200A0A,
 	0x01800880,
-	0x74000D0D,
+	0x74200D0D,
 	0x0D5A1520,
 	0x0A800480,
 	0x1A1A2662,
@@ -3812,7 +3940,7 @@ static unsigned int combing_bias_static_setting[MAX_NUM_DI_REG] = {
 	0x1A1A3A62,
 	0x15200A0A,
 	0x01800880,
-	0x74000D0D,
+	0x74200D0D,
 	0x0D5A1520,
 	0x0A800480,
 	0x1A1A2662,
@@ -3832,7 +3960,7 @@ static unsigned int combing_normal_setting[MAX_NUM_DI_REG] = {
 	0x1A1A3A62,
 	0x15200a0a,
 	0x01000880,
-	0x74000D0D,
+	0x74200D0D,
 	0x0D5A1520,
 	0x0A0A0201,
 	0x1A1A2662,
@@ -3851,7 +3979,7 @@ static unsigned int combing_bias_motion_setting[MAX_NUM_DI_REG] = {
 	0x1A1A3A62,
 	0x15200101,
 	0x01200440,
-	0x74000D0D,
+	0x74200D0D,
 	0x0D5A1520,
 	0x0A0A0201,
 	0x1A1A2662,
@@ -3870,7 +3998,7 @@ static unsigned int combing_very_motion_setting[MAX_NUM_DI_REG] = {
 	0x1A1A3A62,
 	0x15200101,
 	0x01200440,
-	0x74000D0D,
+	0x74200D0D,
 	0x0D5A1520,
 	0x0A0A0201,
 	0x1A1A2662,
@@ -3889,7 +4017,7 @@ static unsigned int combing_resolution_setting[MAX_NUM_DI_REG] = {
 	0x141a3a62,
 	0x15200a0a,
 	0x01800880,
-	0x74000d0d,
+	0x74200d0d,
 	0x0d5a1520,
 	0x0a800480,
 	0x1a1a2662,
@@ -3918,6 +4046,12 @@ static unsigned int (*combing_setting_values[6])[MAX_NUM_DI_REG] = {
  * from low motion to high motion level
  * take 720x480 as example */
 static unsigned int combing_glb_mot_thr_LH[4] = {1440, 2880, 4760, 9520};
+
+/* >> 4 */
+static unsigned int combing_glbmot_radprat[4] = {32, 48, 64, 80};
+static unsigned int num_glbmot_radprat = 4;
+module_param_array(combing_glbmot_radprat, uint, &num_glbmot_radprat, 0664);
+
 /* level:    0<-1  1<-2   2<-3   3<-4
  * from high motion to low motion level */
 static unsigned int combing_glb_mot_thr_HL[4] = {720, 1440, 2880, 5760};
@@ -3985,14 +4119,23 @@ static void combing_threshold_config(unsigned int  width)
 {
 	int i = 0;
 	/* init combing threshold */
+	/*
 	for (i = 0; i < 4; i++) {
 		combing_glb_mot_thr_LH[i] = (width<<1)*(i+1);
 		combing_glb_mot_thr_HL[i] = width<<i;
 	}
 	combing_glb_mot_thr_LH[3] = width*13;
+	*/
+
+	for (i = 0; i < 4; i++) {
+		combing_glb_mot_thr_LH[i] =
+			((width * combing_glbmot_radprat[i] + 8) >> 4);
+		combing_glb_mot_thr_HL[i] =
+			combing_glb_mot_thr_LH[i] - width;
+	}
 }
 
-unsigned int adp_set_level(unsigned int diff)
+unsigned int adp_set_level(unsigned int diff, unsigned int field_diff_num)
 {
 	unsigned int rst = 0;
 	char tlog[] = "LHM";
@@ -4004,7 +4147,8 @@ unsigned int adp_set_level(unsigned int diff)
 		rst = 2;
 
 	if (cmb_adpset_cnt > 0) {
-		pr_info("\ndiff=%d lvl=%c\n", diff, tlog[rst]);
+		pr_info("\field-num=%04d frame-num=%04d lvl=%c\n",
+			field_diff_num, diff, tlog[rst]);
 		cmb_adpset_cnt--;
 	}
 
@@ -4174,12 +4318,18 @@ unsigned int adp_set_mtn_ctrl7(unsigned int diff, unsigned int dlvel)
 	}*/
 	return rst;
 }
+static unsigned int small_local_mtn = 70;
+module_param(small_local_mtn, uint, 0644);
+MODULE_PARM_DESC(small_local_mtn, "small_local_mtn");
 
 unsigned int adp_set_mtn_ctrl10(unsigned int diff, unsigned int dlvel)
 {
 	int istp = 0, idats = 0, idatm = 0, idatr = 0;
 	unsigned int rst = 0;
-	if (dlvel == 0)
+
+	if (frame_diff_avg < small_local_mtn)
+		rst = combing_very_motion_setting[9];
+	else if (dlvel == 0)
 		rst = combing_pure_still_setting[9];
 	else if (dlvel == 1)
 		rst = combing_very_motion_setting[9];
@@ -4212,10 +4362,11 @@ unsigned int adp_set_mtn_ctrl10(unsigned int diff, unsigned int dlvel)
 			idatr = ((idats - idatm) * istp >> 6) + idatm;
 			rst = (rst<<8) | (idatr & 0xff);
 	}
-	/*
+
 	if (cmb_adpset_cnt > 0) {
-		pr_info("mtn_ctr10=%8x\n", rst);
-	}*/
+		pr_info("mtn_ctr10=0x%08x (frame_dif_avg=%03d)\n",
+			rst, frame_diff_avg);
+	}
 	return rst;
 }
 
@@ -4285,7 +4436,7 @@ void set_combing_regs(int lvl)
 			register only in GCTVBB */
 			ndat = (*combing_setting_values[lvl])[i];
 			DI_Wr(combing_setting_registers[i], ndat);
-		} else if (is_meson_gxtvbb_cpu())
+		} else if (cpu_after_eq(MESON_CPU_MAJOR_ID_GXTVBB))
 			DI_Wr(combing_setting_registers[i],
 				((*combing_setting_values[lvl])[i] &
 				combing_setting_masks[i]) |
@@ -4391,7 +4542,7 @@ static void adaptive_combing_fixing(
 
 	if ((force_lev > 5) && (di_debug_new_en == 1) &&
 		(glb_mot[1] != glb_mot[0])) {
-		dlvl = adp_set_level(glb_mot[0]);
+		dlvl = adp_set_level(glb_mot[0], field_pd_info->field_diff_num);
 		diff = glb_mot[0];
 		pre_dat[0] = Rd(DI_MTN_1_CTRL3);
 		wt_dat = adp_set_mtn_ctrl3(diff, dlvl);
@@ -4407,9 +4558,8 @@ static void adaptive_combing_fixing(
 		if (pre_dat[1] != wt_dat) {
 			DI_Wr(DI_MTN_1_CTRL4, wt_dat);
 			if (prt_flg)
-				pr_info("set mtn04 %08x -> %08x (%d).\n",
-				pre_dat[1], wt_dat,
-				field_pd_info->field_diff_num);
+				pr_info("set mtn04 %08x -> %08x.\n",
+				pre_dat[1], wt_dat);
 			pre_dat[1] = wt_dat;
 		}
 
@@ -4514,6 +4664,10 @@ module_param(flmxx_sure_num, uint, 0644);
 MODULE_PARM_DESC(flmxx_sure_num, "ture film-xx/n");
 */
 
+static unsigned int flm22_sure_smnum = 70;
+static unsigned int flm22_ratio = 100;
+/* 79 for iptv test pd22 ts */
+module_param_named(flm22_ratio, flm22_ratio, uint, 0644);
 /* static unsigned int flmxx_sure_num[7]
  = {50, 50, 50, 50, 50, 50, 50}; */
 static unsigned int flmxx_sure_num[7] = {20, 20, 20, 20, 20, 20, 20};
@@ -4549,10 +4703,13 @@ static void pre_de_done_buf_config(void)
 	bool flm22 = false;
 	bool flmxx = false;
 	int tb_chk_ret = 0;
-	unsigned int glb_mot = 0;
+
+	unsigned int glb_frame_mot_num = 0;
+	unsigned int glb_field_mot_num = 0;
 	unsigned int mot_row = 0;
 	unsigned int mot_max = 0;
-
+	unsigned int flm22_surenum = flm22_sure_num;
+	unsigned int ntmp = 0;
 	if (di_pre_stru.di_wr_buf) {
 		if (di_pre_stru.pre_throw_flag > 0) {
 			di_pre_stru.di_wr_buf->throw_flag = 1;
@@ -4606,9 +4763,12 @@ static void pre_de_done_buf_config(void)
 		if (!di_pre_stru.cur_prog_flag) {
 			/* always read and print data */
 			read_new_pulldown_info(&flmreg);
-
 			/* read_new_pulldown_info(&flmreg); */
 			if ((pldn_calc_en == 1) && pulldown_enable) {
+				glb_frame_mot_num = di_pre_stru.di_post_wr_buf->
+						field_pd_info.frame_diff_num;
+				glb_field_mot_num = di_pre_stru.di_post_wr_buf->
+						field_pd_info.field_diff_num;
 				dectres.rF22Flag = FlmVOFSftTop(
 					&(dectres.rCmb32Spcl),
 					dectres.rPstCYWnd0,
@@ -4622,10 +4782,13 @@ static void pre_de_done_buf_config(void)
 					flmreg.rROFldDif01,
 					flmreg.rROFrmDif02,
 					flmreg.rROCmbInf,
+					glb_frame_mot_num,
+					glb_field_mot_num,
 					&tTCNm,
 					&pd_param,
 					hHeight + 1,
-					wWidth  + 1);
+					wWidth + 1,
+					overturn);
 
 				if (hHeight >= 289) /*full hd */
 					tTCNm = tTCNm << 1;
@@ -4701,11 +4864,19 @@ static void pre_de_done_buf_config(void)
 				flm32 = (dectres.rFlmPstMod == 2 &&
 					dectres.rFlmPstGCm == 0);
 
+				ntmp = (glb_frame_mot_num + glb_field_mot_num) /
+					(wWidth + 1);
+				if (flm22_sure_num > ntmp + flm22_sure_smnum)
+					flm22_surenum = flm22_sure_num - ntmp;
+				else
+					flm22_surenum = flm22_sure_smnum;
+
+				if (cmb_adpset_cnt > 0)
+					pr_info("flm22_surenum = %2d\n",
+						flm22_surenum);
 				if (di_debug_new_en &&
 					(dectres.rFlmPstMod == 1)) {
-					glb_mot = di_pre_stru.di_post_wr_buf->
-						field_pd_info.frame_diff_num;
-					mot_row = glb_mot *
+					mot_row = glb_frame_mot_num *
 					flm22_glbpxlnum_rat / (wWidth + 1);
 					mot_max = (flm22_glbpxl_maxrow *
 						hHeight + 128) >> 8;
@@ -4729,7 +4900,7 @@ static void pre_de_done_buf_config(void)
 				}
 
 				flm22 = (dectres.rFlmPstMod == 1  &&
-					dectres.rF22Flag >= flm22_sure_num);
+					dectres.rF22Flag >= flm22_surenum);
 				if (dectres.rFlmPstMod >= 4)
 					flmxx = (dectres.rF22Flag >=
 					flmxx_sure_num[dectres.rFlmPstMod - 4]);
@@ -4948,9 +5119,12 @@ static void pre_de_done_buf_config(void)
 					= di_pre_stru.di_chan2_buf_dup_p;
 				di_pre_stru.di_chan2_buf_dup_p
 					= di_pre_stru.di_wr_buf;
+#ifdef DI_BUFFER_DEBUG
 				di_print("%s:set di_mem to di_chan2,",
 					__func__);
-				di_print("set di_chan2 to di_wr_buf\n");
+				di_print("%s:set di_chan2 to di_wr_buf\n",
+					__func__);
+#endif
 			} else {
 				di_pre_stru.di_mem_buf_dup_p->pre_ref_count = 0;
 				/*recycle the progress throw buffer*/
@@ -4958,18 +5132,22 @@ static void pre_de_done_buf_config(void)
 					di_pre_stru.di_wr_buf->
 						pre_ref_count = 0;
 					di_pre_stru.di_mem_buf_dup_p = NULL;
+#ifdef DI_BUFFER_DEBUG
 				di_print(
 				"%s set throw %s[%d] pre_ref_count to 0.\n",
 				__func__,
 				vframe_type_name[di_pre_stru.di_wr_buf->type],
 				di_pre_stru.di_wr_buf->index);
+#endif
 				} else {
 					di_pre_stru.di_mem_buf_dup_p
 						= di_pre_stru.di_wr_buf;
 				}
+#ifdef DI_BUFFER_DEBUG
 				di_print(
 					"%s: set di_mem_buf_dup_p to di_wr_buf\n",
 					__func__);
+#endif
 			}
 
 			di_pre_stru.di_wr_buf->seq
@@ -4986,20 +5164,24 @@ static void pre_de_done_buf_config(void)
 			if (bypass_state == 1) {
 				di_pre_stru.di_wr_buf->new_format_flag = 1;
 				bypass_state = 0;
+#ifdef DI_BUFFER_DEBUG
 				di_print(
 					"%s:bypass_state->0, is_bypass() %d\n",
 					__func__, is_bypass(NULL));
 				di_print(
 					"trick_mode %d bypass_all %d\n",
 					trick_mode, bypass_all);
+#endif
 			}
 			if (di_pre_stru.di_post_wr_buf)
 				queue_in(di_pre_stru.di_post_wr_buf,
 					QUEUE_PRE_READY);
+#ifdef DI_BUFFER_DEBUG
 			di_print(
 				"%s: %s[%d] => pre_ready_list\n", __func__,
 				vframe_type_name[di_pre_stru.di_wr_buf->type],
 				di_pre_stru.di_wr_buf->index);
+#endif
 			if (di_pre_stru.di_wr_buf) {
 				if (di_pre_rdma_enable)
 					di_pre_stru.di_post_wr_buf =
@@ -5014,9 +5196,11 @@ static void pre_de_done_buf_config(void)
 			if (di_pre_stru.di_chan2_buf_dup_p) {
 				di_pre_stru.di_mem_buf_dup_p =
 					di_pre_stru.di_chan2_buf_dup_p;
+#ifdef DI_BUFFER_DEBUG
 				di_print(
 				"%s: di_mem_buf_dup_p = di_chan2_buf_dup_p\n",
 				__func__);
+#endif
 			}
 			di_pre_stru.di_chan2_buf_dup_p = di_pre_stru.di_wr_buf;
 
@@ -5036,11 +5220,13 @@ static void pre_de_done_buf_config(void)
 							di_buf_tmp,
 							QUEUE_PRE_READY);
 					}
+#ifdef DI_BUFFER_DEBUG
 					di_print(
 					"%s: dummy %s[%d] => pre_ready_list\n",
 					__func__,
 					vframe_type_name[di_buf_tmp->type],
 					di_buf_tmp->index);
+#endif
 				}
 			}
 			di_pre_stru.di_wr_buf->seq =
@@ -5058,13 +5244,14 @@ static void pre_de_done_buf_config(void)
 				di_pre_stru.di_wr_buf->new_format_flag = 1;
 				bypass_state = 0;
 
+#ifdef DI_BUFFER_DEBUG
 				di_print(
 					"%s:bypass_state->0, is_bypass() %d\n",
 					__func__, is_bypass(NULL));
 				di_print(
 					"trick_mode %d bypass_all %d\n",
 					trick_mode, bypass_all);
-
+#endif
 			}
 
 			if (di_pre_stru.di_post_wr_buf)
@@ -5087,9 +5274,11 @@ static void pre_de_done_buf_config(void)
 	}
 
 	if (di_pre_stru.di_post_inp_buf && di_pre_rdma_enable) {
+#ifdef DI_BUFFER_DEBUG
 		di_print("%s: %s[%d] => recycle_list\n", __func__,
 			vframe_type_name[di_pre_stru.di_post_inp_buf->type],
 			di_pre_stru.di_post_inp_buf->index);
+#endif
 		di_lock_irqfiq_save(irq_flag2, fiq_flag);
 		queue_in(di_pre_stru.di_post_inp_buf, QUEUE_RECYCLE);
 		di_pre_stru.di_post_inp_buf = NULL;
@@ -5097,9 +5286,11 @@ static void pre_de_done_buf_config(void)
 	}
 	if (di_pre_stru.di_inp_buf) {
 		if (!di_pre_rdma_enable) {
+#ifdef DI_BUFFER_DEBUG
 			di_print("%s: %s[%d] => recycle_list\n", __func__,
 			vframe_type_name[di_pre_stru.di_inp_buf->type],
 			di_pre_stru.di_inp_buf->index);
+#endif
 			di_lock_irqfiq_save(irq_flag2, fiq_flag);
 			queue_in(di_pre_stru.di_inp_buf, QUEUE_RECYCLE);
 			di_pre_stru.di_inp_buf = NULL;
@@ -5208,67 +5399,6 @@ static struct di_buf_s *get_free_linked_buf(int idx)
 	return di_buf;
 }
 
-
-static void dump_vframe_input(vframe_t *vframe)
-{
-	unsigned int canvas_w = 0, canvas_h = 0, canvas_real_size = 0;
-	unsigned int y_size = 0;
-	unsigned int uv_size = 0;
-	void *buff = NULL;
-	struct canvas_s vf_canvas;
-	if (NULL == vframe)
-		return;
-	canvas_read(vframe->canvas0Addr & 0xff, &vf_canvas);
-	canvas_w = vf_canvas.width;
-	canvas_h = vf_canvas.height;
-	y_size = canvas_w * canvas_h;
-	uv_size = canvas_w * canvas_h / 2;
-	canvas_real_size = y_size + uv_size;
-	dump_one_frame_size = canvas_real_size;
-	pr_dbg("canvas_w: %d, canvas_h: %d, canvas_real_size: %d\n",
-		canvas_w, canvas_h, canvas_real_size);
-	pr_dbg("canvas0Addr: %x\n", vframe->canvas0Addr);
-	pr_dbg("canvas1Addr: %x\n", vframe->canvas1Addr);
-	if (dump_vf_start_flag) {
-		pr_dbg("vf_input_buff size: %d\n",
-			canvas_real_size * dump_vf_num);
-		vf_input_buff =
-			kmalloc(canvas_real_size * dump_vf_num, GFP_KERNEL);
-		pr_dbg("malloc vframe buff\n");
-	}
-	if (NULL == vf_input_buff) {
-		dump_vf_num_inner = 0;
-		pr_dbg("kmalloc vf_input_buff failed\n");
-		return;
-	}
-	if ((!is_progressive(vframe))
-		&& ((vframe->height == 576) || (vframe->height == 480))
-		&& ((vframe->type & VIDTYPE_TYPEMASK)
-			== VIDTYPE_INTERLACE_TOP)) {
-		return;
-	}
-	buff = phys_to_virt(canvas_get_addr(vframe->canvas0Addr & 0xff));
-	if (NULL == buff) {
-		dump_vf_num_inner = 0;
-		pr_dbg("buff is NULL\n");
-		return;
-	}
-	vf_input_size = canvas_real_size;
-	memcpy(vf_input_buff + (dump_buff_offset * canvas_real_size),
-		buff, y_size);
-	buff = phys_to_virt(canvas_get_addr((vframe->canvas0Addr >> 8) & 0xff));
-	if (NULL == buff) {
-		dump_vf_num_inner = 0;
-		return;
-	}
-	memcpy(vf_input_buff + y_size + (dump_buff_offset * vf_input_size),
-		buff, uv_size);
-	++dump_buff_offset;
-	--dump_vf_num_inner;
-	pr_dbg("dup vf_input_buff OK\n");
-	return;
-}
-
 static unsigned char pre_de_buf_config(void)
 {
 	struct di_buf_s *di_buf = NULL;
@@ -5278,7 +5408,7 @@ static unsigned char pre_de_buf_config(void)
 
 	if (di_blocking)
 		return 0;
-	if ((queue_empty(QUEUE_IN_FREE) && (!di_pre_stru.di_inp_buf_next)) ||
+	if ((list_count(QUEUE_IN_FREE) < 2 && (!di_pre_stru.di_inp_buf_next)) ||
 	    (queue_empty(QUEUE_LOCAL_FREE)))
 		return 0;
 
@@ -5286,10 +5416,16 @@ static unsigned char pre_de_buf_config(void)
 		/* some provider has problem if receiver
 		 * get all buffers of provider */
 		int in_buf_num = 0;
+		int bypass_buf_threshold = bypass_get_buf_threshold;
+		if ((di_pre_stru.cur_inp_type & VIDTYPE_VIU_444) &&
+			(di_pre_stru.cur_source_type ==
+			VFRAME_SOURCE_TYPE_HDMI))
+			bypass_buf_threshold = bypass_hdmi_get_buf_threshold;
+		cur_lev = 0;
 		for (i = 0; i < MAX_IN_BUF_NUM; i++)
 			if (vframe_in[i] != NULL)
 				in_buf_num++;
-		if (in_buf_num > bypass_get_buf_threshold
+		if (in_buf_num > bypass_buf_threshold
 #ifdef DET3D
 		    && (di_pre_stru.vframe_interleave_flag == 0)
 #endif
@@ -5307,15 +5443,19 @@ static unsigned char pre_de_buf_config(void)
 	if (di_pre_stru.di_inp_buf_next) {
 		di_pre_stru.di_inp_buf = di_pre_stru.di_inp_buf_next;
 		di_pre_stru.di_inp_buf_next = NULL;
+#ifdef DI_BUFFER_DEBUG
 		di_print("%s: di_inp_buf_next %s[%d] => di_inp_buf\n",
 			__func__,
 			vframe_type_name[di_pre_stru.di_inp_buf->type],
 			di_pre_stru.di_inp_buf->index);
+#endif
 		if (di_pre_stru.di_mem_buf_dup_p == NULL) {/* use n */
 			di_pre_stru.di_mem_buf_dup_p = di_pre_stru.di_inp_buf;
+#ifdef DI_BUFFER_DEBUG
 			di_print(
 				"%s: set di_mem_buf_dup_p to be di_inp_buf\n",
 				__func__);
+#endif
 		}
 	} else {
 		/* check if source change */
@@ -5340,18 +5480,12 @@ static unsigned char pre_de_buf_config(void)
 
 		if (vframe == NULL)
 			return 0;
-
-		vframe->prog_proc_config = (prog_proc_config&0x20) >> 5;
-
-		if (dump_vf_start_flag)
-			dump_vf_num_inner = dump_vf_num;
-
-		if (dump_vf_num_inner) {
-			dump_vframe_input(vframe);
-			dump_vf_start_flag = 0;
+		else {
+			di_print("DI: get vframe[0x%p] from frontend %u ms.\n",
+			vframe,
+jiffies_to_msecs(jiffies_64 - vframe->ready_jiffies64));
 		}
-		if (0 == dump_vf_num_inner)
-			dump_buff_offset = 0;
+		vframe->prog_proc_config = (prog_proc_config&0x20) >> 5;
 
 		if (vframe->width > 10000 || vframe->height > 10000 ||
 		    di_pre_stru.bad_frame_throw_count > 0) {
@@ -5383,7 +5517,12 @@ static unsigned char pre_de_buf_config(void)
 		di_pre_stru.source_trans_fmt = vframe->trans_fmt;
 		di_pre_stru.left_right = di_pre_stru.left_right ? 0 : 1;
 
-		if (((invert_top_bot & 0x2) != 0) &&
+		di_pre_stru.invert_flag =
+			(vframe->type & TB_DETECT_MASK) ? true : false;
+		vframe->type &= ~TB_DETECT_MASK;
+
+		if ((((invert_top_bot & 0x2) != 0) ||
+				di_pre_stru.invert_flag) &&
 		    (!is_progressive(vframe))) {
 			if (
 				(vframe->type & VIDTYPE_TYPEMASK) ==
@@ -5402,6 +5541,9 @@ static unsigned char pre_de_buf_config(void)
 		if (force_height)
 			vframe->height = force_height;
 
+		/* backup frame motion info */
+		vframe->combing_cur_lev = cur_lev;
+
 		di_print("%s: vf_get => 0x%p\n", __func__, vframe);
 
 		provider_vframe_level--;
@@ -5562,6 +5704,7 @@ static unsigned char pre_de_buf_config(void)
 			/* bypass progressive */
 			di_buf->seq = di_pre_stru.pre_ready_seq++;
 			di_buf->post_ref_count = 0;
+			cur_lev = 0;
 			if (di_pre_stru.source_change_flag) {
 				di_buf->new_format_flag = 1;
 				di_pre_stru.source_change_flag = 0;
@@ -5588,24 +5731,27 @@ static unsigned char pre_de_buf_config(void)
 						0;
 					recycle_vframe_type_pre(
 						di_pre_stru.di_wr_buf);
-
+#ifdef DI_BUFFER_DEBUG
 					di_print(
 						"%s: %s[%d] => recycle_list\n",
 						__func__,
 						vframe_type_name[di_pre_stru.
 							di_wr_buf->type],
 						di_pre_stru.di_wr_buf->index);
+#endif
 					di_pre_stru.di_wr_buf = NULL;
 				}
 
 				di_buf->new_format_flag = 1;
 				bypass_state = 1;
+#ifdef DI_BUFFER_DEBUG
 				di_print(
 					"%s:bypass_state = 1, is_bypass() %d\n",
 					__func__, is_bypass(NULL));
 				di_print(
 					"trick_mode %d bypass_all %d\n",
 					trick_mode, bypass_all);
+#endif
 			}
 
 			top_bot_config(di_buf);
@@ -5624,9 +5770,11 @@ static unsigned char pre_de_buf_config(void)
 				di_buf->post_proc_flag = -2;
 			else
 				di_buf->post_proc_flag = 0;
+#ifdef DI_BUFFER_DEBUG
 			di_print(
 				"%s: %s[%d] => pre_ready_list\n", __func__,
 				vframe_type_name[di_buf->type], di_buf->index);
+#endif
 			return 0;
 		} else if (is_progressive(di_buf->vframe)) {
 			if (
@@ -5642,6 +5790,11 @@ static unsigned char pre_de_buf_config(void)
 
 				di_buf_tmp =
 					get_di_buf_head(QUEUE_IN_FREE);
+				if (check_di_buf(di_buf_tmp, 10)) {
+					recycle_vframe_type_pre(di_buf);
+					pr_err("DI:no free in_buffer for progressive skip.\n");
+					return 0;
+				}
 				di_buf_tmp->vframe->private_data
 					= di_buf_tmp;
 				di_buf_tmp->seq = di_pre_stru.in_seq;
@@ -5660,6 +5813,7 @@ static unsigned char pre_de_buf_config(void)
 				di_buf_tmp->post_proc_flag = 0;
 
 				di_pre_stru.di_inp_buf = di_buf;
+#ifdef DI_BUFFER_DEBUG
 				di_print(
 			"%s: %s[%d] => di_inp_buf; %s[%d] => di_inp_buf_next\n",
 					__func__,
@@ -5667,12 +5821,14 @@ static unsigned char pre_de_buf_config(void)
 					di_buf->index,
 					vframe_type_name[di_buf_tmp->type],
 					di_buf_tmp->index);
-
+#endif
 				if (di_pre_stru.di_mem_buf_dup_p == NULL) {
 					di_pre_stru.di_mem_buf_dup_p = di_buf;
+#ifdef DI_BUFFER_DEBUG
 					di_print(
 				"%s: set di_mem_buf_dup_p to be di_inp_buf\n",
 						__func__);
+#endif
 				}
 			} else {
 				di_buf->post_proc_flag = 0;
@@ -5680,19 +5836,23 @@ static unsigned char pre_de_buf_config(void)
 				    di_pre_stru.force_interlace)
 					di_buf->post_proc_flag = 1;
 				di_pre_stru.di_inp_buf = di_buf;
+#ifdef DI_BUFFER_DEBUG
 				di_print(
 					"%s: %s[%d] => di_inp_buf\n",
 					__func__,
 					vframe_type_name[di_buf->type],
 					di_buf->index);
+#endif
 				if (
 					di_pre_stru.di_mem_buf_dup_p == NULL) {
 					/* use n */
 					di_pre_stru.di_mem_buf_dup_p
 						= di_buf;
+#ifdef DI_BUFFER_DEBUG
 					di_print(
 				"%s: set di_mem_buf_dup_p to be di_inp_buf\n",
 						__func__);
+#endif
 				}
 			}
 		} else {
@@ -5711,9 +5871,11 @@ static unsigned char pre_de_buf_config(void)
 
 			if (di_pre_stru.di_mem_buf_dup_p == NULL) {/* use n */
 				di_pre_stru.di_mem_buf_dup_p = di_buf;
+#ifdef DI_BUFFER_DEBUG
 				di_print(
 				"%s: set di_mem_buf_dup_p to be di_inp_buf\n",
 					__func__);
+#endif
 			}
 		}
 	}
@@ -5755,12 +5917,14 @@ static unsigned char pre_de_buf_config(void)
 	di_pre_stru.di_wr_buf = di_buf;
 	di_pre_stru.di_wr_buf->pre_ref_count = 1;
 
+#ifdef DI_BUFFER_DEBUG
 	di_print("%s: %s[%d] => di_wr_buf\n", __func__,
 		vframe_type_name[di_buf->type], di_buf->index);
 	if (di_buf->di_wr_linked_buf)
 		di_print("%s: linked %s[%d] => di_wr_buf\n", __func__,
 			vframe_type_name[di_buf->di_wr_linked_buf->type],
 			di_buf->di_wr_linked_buf->index);
+#endif
 
 	memcpy(di_buf->vframe,
 		di_pre_stru.di_inp_buf->vframe, sizeof(vframe_t));
@@ -5869,10 +6033,12 @@ static int check_recycle_buf(void)
 					vf_notify_provider(VFM_NAME,
 						VFRAME_EVENT_RECEIVER_PUT,
 						NULL);
+#ifdef DI_BUFFER_DEBUG
 					di_print(
 						"%s: vf_put(%d) %x\n", __func__,
 						di_pre_stru.recycle_seq,
 						vframe_in[di_buf->index]);
+#endif
 					vframe_in[di_buf->index] = NULL;
 				}
 				di_buf->invert_top_bot_flag = 0;
@@ -5887,6 +6053,7 @@ static int check_recycle_buf(void)
 					queue_in(
 						di_buf->di_wr_linked_buf,
 						QUEUE_LOCAL_FREE);
+#ifdef DI_BUFFER_DEBUG
 					di_print(
 					"%s: linked %s[%d]=>recycle_list\n",
 						__func__,
@@ -5894,12 +6061,15 @@ static int check_recycle_buf(void)
 						di_buf->di_wr_linked_buf->type],
 						di_buf->di_wr_linked_buf->index
 					);
+#endif
 					di_buf->di_wr_linked_buf = NULL;
 				}
 				ret |= 2;
 			}
+#ifdef DI_BUFFER_DEBUG
 			di_print("%s: recycle %s[%d]\n", __func__,
 				vframe_type_name[di_buf->type], di_buf->index);
+#endif
 		}
 	}
 	return ret;
@@ -6075,16 +6245,32 @@ static void get_mcinfo_from_reg_in_irq(void)
 		}
 	}
 }
+
+static unsigned int bit_reverse(unsigned int val)
+{
+	unsigned int i = 0, res = 0;
+	for (i = 0; i < 16; i++) {
+		res |= (((val&(1<<i))>>i)<<(31-i));
+		res |= (((val&(1<<(31-i)))<<i)>>(31-i));
+	}
+	return res;
+}
+
 static void set_post_mcinfo(struct mcinfo_pre_s *curr_field_mcinfo)
 {
-	unsigned int i = 0;
+	unsigned int i = 0, value = 0;
 
 	DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_REL_GAIN_OFFST_0,
 		curr_field_mcinfo->highvertfrqflg, 24, 1);
 	DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_REL_GAIN_OFFST_0,
 		curr_field_mcinfo->motionparadoxflg, 25, 1);
-	for (i = 0; i < 26; i++)
-		DI_VSYNC_WR_MPEG_REG(0x2f78 + i, curr_field_mcinfo->regs[i]);
+	for (i = 0; i < 26; i++) {
+		if (overturn)
+			value = bit_reverse(curr_field_mcinfo->regs[i]);
+		else
+			value = curr_field_mcinfo->regs[i];
+		DI_VSYNC_WR_MPEG_REG(0x2f78 + i, value);
+	}
 }
 
 static irqreturn_t de_irq(int irq, void *dev_instance)
@@ -6096,10 +6282,7 @@ static irqreturn_t de_irq(int irq, void *dev_instance)
 
 	if (di_pre_stru.pre_de_busy) {
 		/* only one inetrrupr mask should be enable */
-		if ((data32 & 4) && !(mask32 & 4)) {
-			di_print("== DIWR ==\n");
-			flag = 1;
-		} else if ((data32 & 2) && !(mask32 & 2)) {
+		if ((data32 & 2) && !(mask32 & 2)) {
 			di_print("== MTNWR ==\n");
 			flag = 1;
 		} else if ((data32 & 1) && !(mask32 & 1)) {
@@ -6112,6 +6295,7 @@ static irqreturn_t de_irq(int irq, void *dev_instance)
 	}
 
 #endif
+
 #ifdef DET3D
 	if (det3d_en) {
 		if ((data32 & 0x100) && !(mask32 & 0x100) && flag) {
@@ -6129,8 +6313,10 @@ static irqreturn_t de_irq(int irq, void *dev_instance)
 	if ((post_wr_en && post_wr_surpport) && (data32&0x4)) {
 		di_post_stru.de_post_process_done = 1;
 		di_post_stru.post_de_busy = 0;
-		if (!(data32 & 0x2))
+		if (!(data32 & 0x2)) {
+			DI_Wr(DI_INTR_CTRL, data32);
 			goto end;
+		}
 	}
 	if (pre_process_time_force)
 		return IRQ_HANDLED;
@@ -6140,12 +6326,9 @@ static irqreturn_t de_irq(int irq, void *dev_instance)
 		return IRQ_HANDLED;
 	}
 
-	di_print("%s: start\n", __func__);
-
 	if (flag) {
 		if (mcpre_en)
 			get_mcinfo_from_reg_in_irq();
-
 #ifdef NEW_DI_V4
 		if (dnr_en)
 			run_dnr_in_irq(
@@ -6161,12 +6344,12 @@ static irqreturn_t de_irq(int irq, void *dev_instance)
 		di_pre_stru.pre_de_busy = 0;
 
 end:
-		if (init_flag)
+		if (init_flag && mem_flag)
 			/* pr_dbg("%s:up di sema\n", __func__); */
 			trigger_pre_di_process(TRIGGER_PRE_BY_DE_IRQ);
 	}
 
-	di_print("%s: end\n", __func__);
+	di_print("DI:buf[%d] irq end.\n", di_pre_stru.di_inp_buf->seq);
 
 	return IRQ_HANDLED;
 }
@@ -6221,8 +6404,7 @@ static void dec_post_ref_count(struct di_buf_s *di_buf)
 static void vscale_skip_disable_post(struct di_buf_s *di_buf, vframe_t *disp_vf)
 {
 	struct di_buf_s *di_buf_i = NULL;
-	int width = (di_buf->di_buf[0]->canvas_config_size >> 16) & 0xffff;
-	int canvas_height = (di_buf->di_buf[0]->canvas_config_size) & 0xffff;
+	int canvas_height = di_buf->di_buf[0]->canvas_height;
 
 	if (di_vscale_skip_enable & 0x2) {/* drop the bottom field */
 		if ((di_buf->di_buf_dup_p[0]) && (di_buf->di_buf_dup_p[1]))
@@ -6254,7 +6436,8 @@ static void vscale_skip_disable_post(struct di_buf_s *di_buf, vframe_t *disp_vf)
 	disp_vf->canvas1Addr = di_post_idx[di_post_stru.canvas_id][0];
 	canvas_config(
 		di_post_idx[di_post_stru.canvas_id][0],
-		di_buf_i->nr_adr, width * 2, canvas_height, 0, 0);
+		di_buf_i->nr_adr, di_buf_i->canvas_width[NR_CANVAS],
+		canvas_height, 0, 0);
 	disable_post_deinterlace_2();
 	di_post_stru.vscale_skip_flag = true;
 }
@@ -6330,9 +6513,14 @@ static int do_pre_only_fun(void *arg, vframe_t *disp_vf)
 			di_print("error:%s,NULL point!!\n", __func__);
 			return 0;
 		}
-		width = (di_buf->di_buf[0]->canvas_config_size >> 16) & 0xffff;
-		canvas_height =
-			(di_buf->di_buf[0]->canvas_config_size) & 0xffff;
+		width = di_buf->di_buf[0]->canvas_width[NR_CANVAS];
+		/* linked two interlace buffer should double height*/
+		if (di_buf->di_buf[0]->di_wr_linked_buf)
+			canvas_height =
+			(di_buf->di_buf[0]->canvas_height << 1);
+		else
+			canvas_height =
+			di_buf->di_buf[0]->canvas_height;
 #ifdef CONFIG_VSYNC_RDMA
 		if ((is_vsync_rdma_enable() &&
 		     ((force_update_post_reg & 0x40) == 0)) ||
@@ -6346,8 +6534,9 @@ static int do_pre_only_fun(void *arg, vframe_t *disp_vf)
 
 		canvas_config(
 			di_post_idx[di_post_stru.canvas_id][0],
-			di_buf->di_buf[0]->nr_adr, width * 2, canvas_height, 0,
-			0);
+			di_buf->di_buf[0]->nr_adr,
+			di_buf->di_buf[0]->canvas_width[NR_CANVAS],
+			canvas_height, 0, 0);
 
 		vf->canvas0Addr =
 			di_post_idx[di_post_stru.canvas_id][0];
@@ -6357,7 +6546,8 @@ static int do_pre_only_fun(void *arg, vframe_t *disp_vf)
 		if (di_pre_stru.vframe_interleave_flag && di_buf->di_buf[1]) {
 			canvas_config(
 				di_post_idx[di_post_stru.canvas_id][1],
-				di_buf->di_buf[1]->nr_adr, width * 2,
+				di_buf->di_buf[1]->nr_adr,
+				di_buf->di_buf[1]->canvas_width[NR_CANVAS],
 				canvas_height, 0, 0);
 			vf->canvas1Addr =
 				di_post_idx[di_post_stru.canvas_id][1];
@@ -6380,6 +6570,7 @@ static int do_pre_only_fun(void *arg, vframe_t *disp_vf)
 static void config_fftffb_mode(struct di_buf_s *di_buf,
 	unsigned int *post_field_type, char fftffb_mode)
 {
+	unsigned char tmp_idx = 0;
 	switch (fftffb_mode) {
 	case 1:
 		*post_field_type =
@@ -6425,6 +6616,14 @@ static void config_fftffb_mode(struct di_buf_s *di_buf,
 		break;
 	}
 
+	if (is_meson_txl_cpu() && overturn) {
+		/* swap if1&if2 mean negation of mv for normal di*/
+		tmp_idx = di_post_stru.di_buf1_mif.canvas0_addr0;
+		di_post_stru.di_buf1_mif.canvas0_addr0 =
+		di_post_stru.di_buf2_mif.canvas0_addr0;
+		di_post_stru.di_buf2_mif.canvas0_addr0 = tmp_idx;
+	}
+
 }
 
 static void get_vscale_skip_count(unsigned par)
@@ -6432,6 +6631,44 @@ static void get_vscale_skip_count(unsigned par)
 	di_vscale_skip_count_real = (par >> 24) & 0xff;
 }
 
+static void recalc_pd_wnd(struct di_buf_s *di_buf, unsigned short offset)
+{
+	if (di_buf->reg0_s > offset)
+		di_buf->reg0_s -= offset;
+	else
+		di_buf->reg0_s = 0;
+	if (di_buf->reg0_e > offset)
+		di_buf->reg0_e -= offset;
+	else
+		di_buf->reg0_e = 0;
+
+	if (di_buf->reg1_s > offset)
+		di_buf->reg1_s -= offset;
+	else
+		di_buf->reg1_s = 0;
+	if (di_buf->reg1_e > offset)
+		di_buf->reg1_e -= offset;
+	else
+		di_buf->reg1_e = 0;
+
+	if (di_buf->reg2_s > offset)
+		di_buf->reg2_s -= offset;
+	else
+		di_buf->reg2_s = 0;
+	if (di_buf->reg2_e > offset)
+		di_buf->reg2_e -= offset;
+	else
+		di_buf->reg2_e = 0;
+
+	if (di_buf->reg3_s > offset)
+		di_buf->reg3_s -= offset;
+	else
+		di_buf->reg3_s = 0;
+	if (di_buf->reg3_e > offset)
+		di_buf->reg3_e -= offset;
+	else
+		di_buf->reg3_e = 0;
+}
 #define get_vpp_reg_update_flag(par) ((par >> 16) & 0x1)
 
 static unsigned int pldn_dly = 1;
@@ -6463,6 +6700,7 @@ de_post_process(void *arg, unsigned zoom_start_x_lines,
 	unsigned int post_blend_en = 0, post_blend_mode = 0,
 		     blend_mtn_en = 0, ei_en = 0, post_field_num = 0;
 	int di_vpp_en, di_ddr_en;
+	unsigned char mc_pre_flag = 0;
 
 	if ((di_get_power_control(1) == 0) || di_post_stru.vscale_skip_flag)
 		return 0;
@@ -6504,7 +6742,8 @@ de_post_process(void *arg, unsigned zoom_start_x_lines,
 	zoom_start_y_lines = zoom_start_y_lines & 0xffff;
 	zoom_end_y_lines = zoom_end_y_lines & 0xffff;
 
-	if ((init_flag == 0) && (new_keep_last_frame_enable == 0))
+	if (((init_flag == 0) || (mem_flag == 0)) &&
+		(new_keep_last_frame_enable == 0))
 		return 0;
 
 	di_start_x = zoom_start_x_lines;
@@ -6618,7 +6857,7 @@ de_post_process(void *arg, unsigned zoom_start_x_lines,
 			di_post_stru.di_mcvecrd_mif.size_x =
 				(di_end_x + 1 + 4) / 5 - 1 - di_start_x / 5;
 			di_post_stru.di_mcvecrd_mif.size_y =
-				(di_height >> 1) - 1;
+				(di_height >> 1);
 		}
 		di_post_stru.update_post_reg_flag = update_post_reg_count;
 		/* if height decrease, mtn will not enough */
@@ -6659,9 +6898,9 @@ de_post_process(void *arg, unsigned zoom_start_x_lines,
 				di_post_idx[di_post_stru.canvas_id][4]);
 
 		/* for post_wr_en */
-		if ((post_wr_en && post_wr_surpport))
+		if ((post_wr_en && post_wr_surpport) && !mcpre_en)
 			config_canvas_idx(
-			di_buf, di_post_idx[di_post_stru.canvas_id][5], -1);
+			di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 		break;
 	case PULL_DOWN_BLEND_2:
 		config_canvas_idx(
@@ -6680,9 +6919,9 @@ de_post_process(void *arg, unsigned zoom_start_x_lines,
 			config_mcvec_canvas_idx(
 				di_buf->di_buf_dup_p[2],
 				di_post_idx[di_post_stru.canvas_id][4]);
-		if ((post_wr_en && post_wr_surpport))
+		if ((post_wr_en && post_wr_surpport) && !mcpre_en)
 			config_canvas_idx(
-			di_buf, di_post_idx[di_post_stru.canvas_id][5], -1);
+			di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 		break;
 	case PULL_DOWN_MTN:
 		config_canvas_idx(
@@ -6731,18 +6970,30 @@ di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 	if ((di_buf->di_buf_dup_p[1]->vframe == NULL) ||
 		di_buf->di_buf_dup_p[0]->vframe == NULL)
 		return 0;
-	switch (di_buf->pulldown_mode) {
+
+	if (is_meson_txl_cpu() && overturn && di_buf->di_buf_dup_p[2]) {
+		if (post_blend == PULL_DOWN_BLEND_2)
+			post_blend = PULL_DOWN_BLEND_0;
+		else if (post_blend == PULL_DOWN_BLEND_0)
+			post_blend = PULL_DOWN_BLEND_2;
+	}
+
+	switch (post_blend) {
 	case PULL_DOWN_BLEND_0:
 	case PULL_DOWN_NORMAL:
 		config_fftffb_mode(di_buf, &post_field_num,
 			(di_buf->di_buf_dup_p[tbbtff_dly]->privated&0x3));
-		if (mcpre_en)
-			di_post_stru.di_mcvecrd_mif.canvas_num =
-				di_buf->di_buf_dup_p[2]->mcvec_canvas_idx;
-		if (di_buf->pulldown_mode == PULL_DOWN_NORMAL)
+		if (di_buf->pulldown_mode == PULL_DOWN_NORMAL) {
 			post_blend_mode = 3;
-		else
+			mc_pre_flag = is_meson_txl_cpu()?2:(overturn?0:1);
+		} else {
 			post_blend_mode = 1;
+			mc_pre_flag = is_meson_txl_cpu()?0:(overturn?0:1);
+		}
+		if (mcpre_en) {
+			di_post_stru.di_mcvecrd_mif.canvas_num =
+				di_buf->di_buf_dup_p[2]->mcvec_canvas_idx;
+		}
 		blend_mtn_en = 1;
 		post_ei = ei_en = 1;
 		post_blend_en = 1;
@@ -6760,15 +7011,23 @@ di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 			di_buf->di_buf_dup_p[0]->nr_canvas_idx;
 		di_post_stru.di_mtnprd_mif.canvas_num =
 			di_buf->di_buf_dup_p[2]->mtn_canvas_idx;
-		if (mcpre_en)
+		if (is_meson_txl_cpu() && overturn) {
+			di_post_stru.di_buf1_mif.canvas0_addr0 =
+			di_post_stru.di_buf2_mif.canvas0_addr0;
+		}
+		if (mcpre_en) {
 			di_post_stru.di_mcvecrd_mif.canvas_num =
 				di_buf->di_buf_dup_p[2]->mcvec_canvas_idx;
-
+			mc_pre_flag = is_meson_txl_cpu()?0:(overturn?1:0);
+			if (!overturn)
+				di_post_stru.di_buf2_mif.canvas0_addr0 =
+			di_buf->di_buf_dup_p[2]->nr_canvas_idx;
+		}
 		if ((post_wr_en && post_wr_surpport))
 			di_post_stru.di_diwr_mif.canvas_num =
 				di_post_idx[di_post_stru.canvas_id][4];
 
-				post_blend_mode = 1;
+		post_blend_mode = 1;
 		blend_mtn_en = 1;
 		post_ei = ei_en = 1;
 		post_blend_en = 1;
@@ -6860,7 +7119,7 @@ di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 	}
 
 	if (mcpre_en)
-		di_post_stru.di_mcvecrd_mif.blend_mode = post_blend_mode;
+		di_post_stru.di_mcvecrd_mif.blend_en = post_blend_en;
 
 	if ((di_post_stru.update_post_reg_flag) &&
 	    ((force_update_post_reg & 0x80) == 0)) {
@@ -6868,7 +7127,7 @@ di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 			&di_post_stru.di_buf0_mif,
 			&di_post_stru.di_buf1_mif,
 			&di_post_stru.di_buf2_mif,
-			((post_wr_en && post_wr_surpport) ?
+			(di_ddr_en ?
 				(&di_post_stru.di_diwr_mif):NULL),
 			&di_post_stru.di_mtnprd_mif,
 			ei_en,                  /* ei enable */
@@ -6892,7 +7151,7 @@ di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 			&di_post_stru.di_buf0_mif,
 			&di_post_stru.di_buf1_mif,
 			&di_post_stru.di_buf2_mif,
-((post_wr_en && post_wr_surpport) ? (&di_post_stru.di_diwr_mif):NULL),
+(di_ddr_en ? (&di_post_stru.di_diwr_mif):NULL),
 			&di_post_stru.di_mtnprd_mif,
 			&di_post_stru.di_mcvecrd_mif,
 			ei_en,                  /* ei enable */
@@ -6908,12 +7167,14 @@ di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 	}
 
 #ifdef NEW_DI_V1
-	if (di_post_stru.update_post_reg_flag)
+	if (di_post_stru.update_post_reg_flag && (!combing_fix_en)) {
 		di_apply_reg_cfg(1);
+		last_lev = -1;
+	}
 
 #endif
 	if (is_meson_gxtvbb_cpu() || is_meson_txl_cpu())
-		di_post_read_reverse_irq(overturn);
+		di_post_read_reverse_irq(overturn, mc_pre_flag);
 	if (mcpre_en) {
 		if (di_buf->di_buf_dup_p[2])
 			set_post_mcinfo(&di_buf->di_buf_dup_p[2]
@@ -6926,6 +7187,10 @@ di_buf, di_post_idx[di_post_stru.canvas_id][4], -1);
 
 	if (di_pldn_buf && pulldown_enable &&
 		!di_pre_stru.cur_prog_flag) {
+		unsigned short offset = (di_start_y>>1);
+		if (overturn)
+			offset = ((di_buf->vframe->height - di_end_y)>>1);
+		recalc_pd_wnd(di_pldn_buf, offset);
 		if (pldn_wnd_flsh == 1) {
 			DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_REG0_Y,
 				di_pldn_buf->reg0_s, 17, 12);
@@ -7073,7 +7338,7 @@ static void recycle_vframe_type_post(struct di_buf_s *di_buf)
 	queue_in(di_buf, QUEUE_POST_FREE);
 }
 
-#ifdef DI_DEBUG
+#ifdef DI_BUFFER_DEBUG
 static void
 recycle_vframe_type_post_print(struct di_buf_s *di_buf,
 			       const char *func,
@@ -7372,7 +7637,7 @@ void drop_frame(int check_drop, int throw_flag, struct di_buf_s *di_buf)
 	if (drop_flag) {
 		queue_in(di_buf, QUEUE_TMP);
 		recycle_vframe_type_post(di_buf);
-#ifdef DI_DEBUG
+#ifdef DI_BUFFER_DEBUG
 		recycle_vframe_type_post_print(
 				di_buf, __func__,
 				__LINE__);
@@ -7382,6 +7647,11 @@ void drop_frame(int check_drop, int throw_flag, struct di_buf_s *di_buf)
 			queue_in(di_buf, QUEUE_POST_DOING);
 		else
 			queue_in(di_buf, QUEUE_POST_READY);
+		di_print("DI:%s[%d] => post ready %u ms.\n",
+		vframe_type_name[di_buf->type], di_buf->index,
+		jiffies_to_msecs(jiffies_64 - di_buf->vframe->ready_jiffies64));
+
+
 	}
 	di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
 }
@@ -7481,9 +7751,9 @@ static int process_post_vframe(void)
 				recycle_vframe_type_post(di_buf);
 
 				di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
-
+#ifdef DI_BUFFER_DEBUG
 				di_print("%s <dummy>: ", __func__);
-
+#endif
 			} else {
 				if (di_buf->di_buf_dup_p[1]->
 				post_proc_flag == 2){
@@ -7558,8 +7828,9 @@ static int process_post_vframe(void)
 					di_buf);
 
 				frame_count++;
+#ifdef DI_BUFFER_DEBUG
 				di_print("%s <interlace>: ", __func__);
-
+#endif
 				if (!(post_wr_en && post_wr_surpport))
 					vf_notify_receiver(VFM_NAME,
 VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
@@ -7643,6 +7914,8 @@ VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
 
 				if (ready_di_buf->new_format_flag &&
 				(ready_di_buf->type == VFRAME_TYPE_IN)) {
+					pr_info("DI:%d disable post.\n",
+						__LINE__);
 					di_buf->vframe->early_process_fun
 						= de_post_disable_fun;
 				} else {
@@ -7695,11 +7968,11 @@ VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
 					di_buf->di_buf[0]->throw_flag, di_buf);
 
 				frame_count++;
-
+#ifdef DI_BUFFER_DEBUG
 				di_print(
 					"%s <prog by frame>: ",
 					__func__);
-
+#endif
 				ret = 1;
 				vf_notify_receiver(VFM_NAME,
 					VFRAME_EVENT_PROVIDER_VFRAME_READY,
@@ -7861,9 +8134,9 @@ VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
 					di_buf);
 			}
 			frame_count++;
-
+#ifdef DI_BUFFER_DEBUG
 			di_print("%s <prog by field>: ", __func__);
-
+#endif
 			ret = 1;
 			vf_notify_receiver(VFM_NAME,
 				VFRAME_EVENT_PROVIDER_VFRAME_READY,
@@ -7871,6 +8144,7 @@ VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
 		}
 	}
 
+#ifdef DI_BUFFER_DEBUG
 	if (di_buf) {
 		di_print("%s[%d](",
 			vframe_type_name[di_buf->type], di_buf->index);
@@ -7888,6 +8162,7 @@ VFRAME_EVENT_PROVIDER_VFRAME_READY, NULL);
 		else
 			di_print("=> post_ready_list\n");
 	}
+#endif
 	return ret;
 }
 
@@ -7898,12 +8173,14 @@ static void di_unreg_process(void)
 {
 	if (reg_flag) {
 		field_count = 0;
+		pr_dbg("%s unreg start %d.\n", __func__, reg_flag);
 		vf_unreg_provider(&di_vf_prov);
 		reg_flag = 0;
 		unreg_cnt++;
 		if (unreg_cnt > 0x3fffffff)
 			unreg_cnt = 0;
-		di_print("########%s\n", __func__);
+		pr_dbg("%s unreg stop %d.\n", __func__, reg_flag);
+		di_pre_stru.pre_de_busy = 0;
 		di_pre_stru.unreg_req_flag_irq = 1;
 		trigger_pre_di_process(TRIGGER_PRE_BY_UNREG);
 	} else {
@@ -7917,7 +8194,7 @@ static void di_unreg_process(void)
 static void di_unreg_process_irq(void)
 {
 	ulong flags = 0, fiq_flag = 0, irq_flag2 = 0;
-
+	pr_dbg("%s unreg irq start.\n", __func__);
 #if (defined ENABLE_SPIN_LOCK_ALWAYS)
 	spin_lock_irqsave(&plist_lock, flags);
 #endif
@@ -7934,7 +8211,6 @@ static void di_unreg_process_irq(void)
 			dejaggy_flag = -1;
 			DI_Wr_reg_bits(SRSHARP0_SHARP_DEJ1_MISC, 0, 3, 1);
 		}
-
 	di_set_power_control(0, 0);
 #ifndef NEW_DI_V3
 	DI_Wr(DI_CLKG_CTRL, 0xff0000);
@@ -7948,7 +8224,12 @@ static void di_unreg_process_irq(void)
 #endif
 	if (get_blackout_policy()) {
 		di_set_power_control(1, 0);
+		di_hw_disable();
 		DI_Wr(DI_CLKG_CTRL, 0x80000000);
+		if (!is_meson_gxl_cpu() && !is_meson_gxm_cpu() &&
+			!is_meson_gxbb_cpu())
+			switch_vpu_clk_gate_vmod(VPU_VPU_CLKB,
+				VPU_CLK_GATE_OFF);
 	}
 	if ((post_wr_en && post_wr_surpport)) {
 		diwr_set_power_control(0);
@@ -7970,6 +8251,7 @@ static void di_unreg_process_irq(void)
 #endif
 	di_pre_stru.unreg_req_flag = 0;
 	di_pre_stru.unreg_req_flag_irq = 0;
+	pr_info("%s unreg irq stop.\n", __func__);
 }
 
 static void di_reg_process(void)
@@ -8009,6 +8291,8 @@ static struct rdma_op_s di_rdma_op = {
 	NULL
 };
 #endif
+static int nr_level;
+
 static void di_reg_process_irq(void)
 {
 	ulong flags = 0, fiq_flag = 0, irq_flag2 = 0;
@@ -8026,6 +8310,13 @@ static void di_reg_process_irq(void)
 	vframe = vf_peek(VFM_NAME);
 
 	if (vframe) {
+		#ifdef CONFIG_CMA
+		if ((vframe->width > default_width) ||
+			(vframe->height > (default_height + 8)))
+			bypass_4K = 1;
+		else
+			bypass_4K = 0;
+		#endif
 		/* patch for vdin progressive input */
 		if (((vframe->type & VIDTYPE_VIU_422) &&
 		    ((vframe->type & VIDTYPE_PROGRESSIVE) == 0))
@@ -8037,7 +8328,7 @@ static void di_reg_process_irq(void)
 			use_2_interlace_buff = 1;
 		else
 			use_2_interlace_buff = 0;
-
+		switch_vpu_clk_gate_vmod(VPU_VPU_CLKB, VPU_CLK_GATE_ON);
 		di_set_power_control(0, 1);
 		di_set_power_control(1, 1);
 		if ((post_wr_en && post_wr_surpport)) {
@@ -8051,7 +8342,7 @@ static void di_reg_process_irq(void)
 		/* di enable nr clock gate */
 #else
 		/* if mcdi enable DI_CLKG_CTRL should be 0xfef60000 */
-		DI_Wr(DI_CLKG_CTRL, 0xfef60000);
+		DI_Wr(DI_CLKG_CTRL, 0xfef60001);
 		/* nr/blend0/ei0/mtn0 clock gate */
 #endif
 		/* add for di Reg re-init */
@@ -8063,29 +8354,18 @@ static void di_reg_process_irq(void)
 
 		di_print("%s: vframe come => di_init_buf\n", __func__);
 
-		if (is_progressive(vframe) && (prog_proc_config & 0x10)
-		    ) {
+		if (is_progressive(vframe) && (prog_proc_config & 0x10)) {
 #if (!(defined RUN_DI_PROCESS_IN_IRQ)) || (defined ENABLE_SPIN_LOCK_ALWAYS)
 			spin_lock_irqsave(&plist_lock, flags);
 #endif
 			di_lock_irqfiq_save(irq_flag2, fiq_flag);
-			/* di_init_buf(vframe->width,
-			 * vframe->height, 1); */
 			 /*
 			 * 10 bit mode need 1.5 times buffer size of
 			 * 8 bit mode, init the buffer size as 10 bit
 			 * mode size, to make sure can switch bit mode
 			 * smoothly.
 			 */
-			if (nr10bit_surpport) {
-				if (full_422_pack)
-					di_init_buf(default_width * 5 / 4,
-						default_height, 1);
-				else
-					di_init_buf(default_width * 3 / 2,
-						default_height, 1);
-			} else
-				di_init_buf(default_width, default_height, 1);
+			di_init_buf(default_width, default_height, 1);
 
 			di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
 
@@ -8103,16 +8383,7 @@ static void di_reg_process_irq(void)
 			 * mode size, to make sure can switch bit mode
 			 * smoothly.
 			 */
-			if (nr10bit_surpport) {
-				if (cpu_after_eq(MESON_CPU_MAJOR_ID_TXL) &&
-					full_422_pack)
-					di_init_buf(
-				default_width * 3 / 2, default_height, 0);
-				else
-					di_init_buf(
-				default_width * 3 / 2, default_height, 0);
-			} else
-				di_init_buf(default_width, default_height, 0);
+			di_init_buf(default_width, default_height, 0);
 
 			di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
 
@@ -8120,8 +8391,13 @@ static void di_reg_process_irq(void)
 			spin_unlock_irqrestore(&plist_lock, flags);
 #endif
 		}
-
+		di_nr_level_config(nr_level);
 		reset_pulldown_state();
+		if (pulldown_enable) {
+			FlmVOFSftInt(&pd_param);
+			flm22_sure_num = (vframe->height * 100)/480;
+			flm22_sure_smnum = (flm22_sure_num * flm22_ratio)/100;
+		}
 		combing_threshold_config(vframe->width);
 		if (is_meson_txl_cpu()) {
 			combing_pd22_window_config(vframe->width,
@@ -8130,6 +8406,7 @@ static void di_reg_process_irq(void)
 		}
 		init_flag = 1;
 		di_pre_stru.reg_req_flag_irq = 1;
+		last_lev = -1;
 	}
 }
 
@@ -8168,7 +8445,8 @@ static void di_process(void)
 
 	di_process_cnt++;
 
-	if ((init_flag) && (recovery_flag == 0) && (dump_state_flag == 0)) {
+	if (init_flag && mem_flag && (recovery_flag == 0) &&
+		(dump_state_flag == 0)) {
 		if (bypass_dynamic != 0)
 			dynamic_bypass_process();
 #if (!(defined RUN_DI_PROCESS_IN_IRQ)) || (defined ENABLE_SPIN_LOCK_ALWAYS)
@@ -8219,8 +8497,15 @@ static void di_process(void)
 		}
 
 		di_lock_irqfiq_save(irq_flag2, fiq_flag);
-		while (check_recycle_buf() & 1)
-			;
+		di_post_stru.check_recycle_buf_cnt = 0;
+		while (check_recycle_buf() & 1) {
+			if (di_post_stru.check_recycle_buf_cnt++ >
+				MAX_IN_BUF_NUM) {
+				di_pr_info("%s: check_recycle_buf time out!!\n",
+					__func__);
+				break;
+			}
+		}
 		di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
 		if ((di_pre_stru.pre_de_busy == 0) &&
 		    (di_pre_stru.pre_de_process_done == 0)) {
@@ -8232,9 +8517,15 @@ static void di_process(void)
 					pre_de_process();
 			}
 		}
-
-		while (process_post_vframe())
-			;
+		di_post_stru.di_post_process_cnt = 0;
+		while (process_post_vframe()) {
+			if (di_post_stru.di_post_process_cnt++ >
+				MAX_POST_BUF_NUM) {
+				di_pr_info("%s: process_post_vframe time out!!\n",
+					__func__);
+				break;
+			}
+		}
 		if ((post_wr_en && post_wr_surpport)) {
 			if (di_post_stru.post_de_busy == 0 &&
 			di_post_stru.de_post_process_done) {
@@ -8284,7 +8575,7 @@ void di_timer_handle(struct work_struct *work)
 	if (force_recovery) {
 		if (recovery_flag || (force_recovery & 0x2)) {
 			force_recovery_count++;
-			if (init_flag) {
+			if (init_flag && mem_flag) {
 				pr_dbg("====== DI force recovery =========\n");
 				force_recovery &= (~0x2);
 				dis2_di();
@@ -8304,14 +8595,32 @@ static int di_task_handle(void *data)
 			if ((di_pre_stru.unreg_req_flag ||
 				di_pre_stru.force_unreg_req_flag ||
 				di_pre_stru.disable_req_flag) &&
-				(di_pre_stru.pre_de_busy == 0))
+				(di_pre_stru.pre_de_busy == 0)) {
+				pr_dbg("%s,up enter unreg process.\n",
+					__func__);
 				di_unreg_process();
+			}
 			if (di_pre_stru.reg_req_flag_irq ||
 				di_pre_stru.reg_req_flag) {
+				pr_dbg("%s,up enter reg process.\n", __func__);
 				di_reg_process();
 				di_pre_stru.reg_req_flag = 0;
 				di_pre_stru.reg_req_flag_irq = 0;
 			}
+			#ifdef CONFIG_CMA
+			if (di_pre_stru.cma_alloc_req) {
+				di_cma_alloc();
+				di_pre_stru.cma_alloc_req = 0;
+				di_pre_stru.cma_alloc_done = 1;
+				mem_flag = 1;
+			}
+			if (di_pre_stru.cma_release_req) {
+				di_cma_release();
+				di_pre_stru.cma_release_req = 0;
+				di_pre_stru.cma_alloc_done = 0;
+				mem_flag = 0;
+			}
+			#endif
 		}
 	}
 
@@ -8322,7 +8631,7 @@ static irqreturn_t timer_irq(int irq, void *dev_instance)
 {
 /* unsigned int data32; */
 	int i;
-
+	timerc_cnt++;
 	if (active_flag) {
 		if (di_pre_stru.unreg_req_flag_irq)
 			di_unreg_process_irq();
@@ -8351,13 +8660,7 @@ static int di_receiver_event_fun(int type, void *data, void *arg)
 	} else if (type == VFRAME_EVENT_PROVIDER_UNREG) {
 		pr_dbg("%s , is_bypass() %d trick_mode %d bypass_all %d\n",
 			__func__, is_bypass(NULL), trick_mode, bypass_all);
-
-		if ((Rd(DI_IF1_GEN_REG) & 0x1) && get_blackout_policy())
-			/* disable post di, so can call vf_keep_current()
-			 * to keep displayed vframe */
-				pr_info("DI: disabled, not keep buffer.\n");
-
-		pr_dbg("%s: vf_notify_receiver unreg\n", __func__);
+		pr_info("%s: vf_notify_receiver unreg\n", __func__);
 
 		di_pre_stru.unreg_req_flag = 1;
 		provider_vframe_level = 0;
@@ -8365,8 +8668,19 @@ static int di_receiver_event_fun(int type, void *data, void *arg)
 		post_ready_empty_count = 0;
 		vdin_source_flag = 0;
 		trigger_pre_di_process(TRIGGER_PRE_BY_PROVERDER_UNREG);
-		while (di_pre_stru.unreg_req_flag)
+		di_pre_stru.unreg_req_flag_cnt = 0;
+		while (di_pre_stru.unreg_req_flag) {
 			usleep_range(10000, 10001);
+			di_pr_info("%s:unreg_req_flag_cnt:%d timerc_cnt %u!!!\n",
+			__func__, di_pre_stru.unreg_req_flag_cnt, timerc_cnt);
+			if (di_pre_stru.unreg_req_flag_cnt++ >
+				di_reg_unreg_cnt) {
+				di_pr_info("%s:unreg_reg_flag timeout!!!\n",
+					__func__);
+				dump_di_pre_stru();
+				break;
+			}
+		}
 #ifdef SUPPORT_MPEG_TO_VDIN
 		if (mpeg2vdin_flag) {
 			struct vdin_arg_s vdin_arg;
@@ -8547,8 +8861,17 @@ static int di_receiver_event_fun(int type, void *data, void *arg)
 		di_pre_stru.reg_req_flag = 1;
 		pr_dbg("%s: vframe provider reg\n", __func__);
 		trigger_pre_di_process(TRIGGER_PRE_BY_PROVERDER_REG);
-		while (di_pre_stru.reg_req_flag)
+		di_pre_stru.reg_req_flag_cnt = 0;
+		while (di_pre_stru.reg_req_flag) {
 			usleep_range(10000, 10001);
+			di_pr_info("%s:reg_req_flag_cnt:%d!!!\n",
+				__func__, di_pre_stru.reg_req_flag_cnt);
+			if (di_pre_stru.reg_req_flag_cnt++ > di_reg_unreg_cnt) {
+				di_pr_info("%s:reg_req_flag timeout!!!\n",
+					__func__);
+				break;
+			}
+		}
 
 		aml_cbus_update_bits(ISA_TIMER_MUX, 1 << 14, 0 << 14);
 		aml_cbus_update_bits(ISA_TIMER_MUX, 3 << 4, 0 << 4);
@@ -8563,14 +8886,14 @@ static int di_receiver_event_fun(int type, void *data, void *arg)
 		}
 		receiver_name = vf_get_receiver_name(VFM_NAME);
 		if (receiver_name) {
-			if (strcmp(receiver_name, "amvideo") == 0) {
+			if (!strcmp(receiver_name, "amvideo")) {
 				di_post_stru.run_early_proc_fun_flag = 0;
 				receiver_is_amvideo = 1;
 		/* pr_info("set run_early_proc_fun_flag to 1\n"); */
 			} else {
 				di_post_stru.run_early_proc_fun_flag = 1;
 				receiver_is_amvideo = 0;
-		/* pr_dbg("set run_early_proc_fun_flag to 1\n"); */
+		 pr_info("set run_early_proc_fun_flag to 1\n");
 			}
 		} else {
 			pr_info("%s error receiver is null.\n", __func__);
@@ -8597,9 +8920,14 @@ static void fast_process(void)
 {
 	int i;
 	ulong flags = 0, fiq_flag = 0, irq_flag2 = 0;
-
-	if (active_flag && is_bypass(NULL) && (bypass_get_buf_threshold <= 1) &&
-	    (init_flag) && (recovery_flag == 0) && (dump_state_flag == 0)) {
+	unsigned int bypass_buf_threshold = bypass_get_buf_threshold;
+
+	if ((di_pre_stru.cur_inp_type & VIDTYPE_VIU_444) &&
+		(di_pre_stru.cur_source_type == VFRAME_SOURCE_TYPE_HDMI))
+		bypass_buf_threshold = bypass_hdmi_get_buf_threshold;
+	if (active_flag && is_bypass(NULL) && (bypass_buf_threshold <= 1) &&
+		init_flag && mem_flag && (recovery_flag == 0) &&
+		(dump_state_flag == 0)) {
 		if (vf_peek(VFM_NAME) == NULL)
 			return;
 
@@ -8611,8 +8939,15 @@ static void fast_process(void)
 			}
 
 			di_lock_irqfiq_save(irq_flag2, fiq_flag);
-			while (check_recycle_buf() & 1)
-				;
+			di_post_stru.check_recycle_buf_cnt = 0;
+			while (check_recycle_buf() & 1) {
+				if (di_post_stru.check_recycle_buf_cnt++ >
+					MAX_IN_BUF_NUM) {
+					di_pr_info("%s: check_recycle_buf time out!!\n",
+						__func__);
+					break;
+				}
+			}
 			di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
 
 			if ((di_pre_stru.pre_de_busy == 0) &&
@@ -8626,8 +8961,15 @@ static void fast_process(void)
 						pre_de_process();
 				}
 			}
-
-			while (process_post_vframe());
+			di_post_stru.di_post_process_cnt = 0;
+			while (process_post_vframe()) {
+				if (di_post_stru.di_post_process_cnt++ >
+					MAX_POST_BUF_NUM) {
+					di_pr_info("%s: process_post_vframe time out!!\n",
+						__func__);
+					break;
+				}
+			}
 
 			spin_unlock_irqrestore(&plist_lock, flags);
 		}
@@ -8640,8 +8982,8 @@ static vframe_t *di_vf_peek(void *arg)
 	struct di_buf_s *di_buf = NULL;
 
 	video_peek_cnt++;
-	if ((init_flag == 0) || recovery_flag || di_blocking ||
-	    di_pre_stru.unreg_req_flag || dump_state_flag)
+	if ((init_flag == 0) || (mem_flag == 0) || recovery_flag ||
+		di_blocking || di_pre_stru.unreg_req_flag || dump_state_flag)
 		return NULL;
 	if ((run_flag == DI_RUN_FLAG_PAUSE) ||
 	    (run_flag == DI_RUN_FLAG_STEP_DONE))
@@ -8667,12 +9009,12 @@ static vframe_t *di_vf_peek(void *arg)
 				vframe_ret = di_buf->vframe;
 		}
 	}
-
+#ifdef DI_BUFFER_DEBUG
 	if (vframe_ret)
 		di_print("%s: %s[%d]:%x\n", __func__,
 			vframe_type_name[di_buf->type],
 			di_buf->index, vframe_ret);
-
+#endif
 	if (force_duration_0) {
 		if (vframe_ret)
 			vframe_ret->duration = 0;
@@ -8717,8 +9059,8 @@ static vframe_t *di_vf_get(void *arg)
 	struct di_buf_s *di_buf = NULL;
 	ulong flags = 0, fiq_flag = 0, irq_flag2 = 0;
 
-	if ((init_flag == 0) || recovery_flag || di_blocking ||
-	    di_pre_stru.unreg_req_flag || dump_state_flag)
+	if ((init_flag == 0) || (mem_flag == 0) || recovery_flag ||
+		di_blocking || di_pre_stru.unreg_req_flag || dump_state_flag)
 		return NULL;
 
 	if ((run_flag == DI_RUN_FLAG_PAUSE) ||
@@ -8764,17 +9106,18 @@ static vframe_t *di_vf_get(void *arg)
 
 		log_buffer_state("get");
 	}
-	if (vframe_ret)
-		di_print("%s: %s[%d]:%x\n", __func__,
-			vframe_type_name[di_buf->type], di_buf->index,
-			vframe_ret);
+	if (vframe_ret) {
+		di_print("%s: %s[%d]:%x %u ms\n", __func__,
+		vframe_type_name[di_buf->type], di_buf->index, vframe_ret,
+		jiffies_to_msecs(jiffies_64 - vframe_ret->ready_jiffies64));
+	}
 
 	if (force_duration_0) {
 		if (vframe_ret)
 			vframe_ret->duration = 0;
 	}
 
-	if (di_post_stru.run_early_proc_fun_flag && vframe_ret) {
+	if (!post_wr_en && di_post_stru.run_early_proc_fun_flag && vframe_ret) {
 		if (vframe_ret->early_process_fun == do_pre_only_fun)
 			vframe_ret->early_process_fun(
 				vframe_ret->private_data, vframe_ret);
@@ -8792,7 +9135,7 @@ static void di_vf_put(vframe_t *vf, void *arg)
 
 /* struct di_buf_s *p = NULL; */
 /* int itmp = 0; */
-	if ((init_flag == 0) || recovery_flag) {
+	if ((init_flag == 0) || (mem_flag == 0) || recovery_flag) {
 		di_print("%s: 0x%p\n", __func__, vf);
 		return;
 	}
@@ -8814,7 +9157,7 @@ static void di_vf_put(vframe_t *vf, void *arg)
 			vframe_type_name[di_buf->type], di_buf->index);
 	}
 		di_unlock_irqfiq_restore(irq_flag2, fiq_flag);
-#ifdef DI_DEBUG
+#ifdef DI_BUFFER_DEBUG
 		recycle_vframe_type_post_print(di_buf, __func__, __LINE__);
 #endif
 	} else {
@@ -8832,15 +9175,28 @@ static void di_vf_put(vframe_t *vf, void *arg)
 static int di_event_cb(int type, void *data, void *private_data)
 {
 	if (type == VFRAME_EVENT_RECEIVER_FORCE_UNREG) {
-		di_print("%s: VFRAME_EVENT_RECEIVER_FORCE_UNREG\n", __func__);
+		pr_info("%s: RECEIVER_FORCE_UNREG return\n",
+			__func__);
+		return 0;
 		di_pre_stru.force_unreg_req_flag = 1;
 		provider_vframe_level = 0;
 		bypass_dynamic_flag = 0;
 		post_ready_empty_count = 0;
 
 		trigger_pre_di_process(TRIGGER_PRE_BY_FORCE_UNREG);
-		while (di_pre_stru.force_unreg_req_flag)
+		di_pre_stru.unreg_req_flag_cnt = 0;
+		while (di_pre_stru.force_unreg_req_flag) {
 			usleep_range(1000, 1001);
+			di_pr_info("%s:unreg_req_flag_cnt:%d!!!\n",
+				__func__, di_pre_stru.unreg_req_flag_cnt);
+			if (di_pre_stru.unreg_req_flag_cnt++ >
+				di_reg_unreg_cnt) {
+				di_pre_stru.unreg_req_flag_cnt = 0;
+				di_pr_info("%s:unreg_reg_flag timeout!!!\n",
+					__func__);
+				break;
+			}
+		}
 	}
 	return 0;
 }
@@ -8896,7 +9252,7 @@ show_frame_format(struct device *dev,
 {
 	int ret = 0;
 
-	if (init_flag)
+	if (init_flag && mem_flag)
 		ret += sprintf(buf + ret, "%s\n",
 			di_pre_stru.cur_prog_flag
 			? "progressive" : "interlace");
@@ -8915,7 +9271,9 @@ static int rmem_di_device_init(struct reserved_mem *rmem, struct device *dev)
 	if (di_devp) {
 		di_devp->mem_start = rmem->base;
 		di_devp->mem_size = rmem->size;
-		pr_dbg("di reveser memory 0x%lx, size %uMB.\n",
+		if (!of_get_flat_dt_prop(rmem->fdt_node, "no-map", NULL))
+			di_devp->flags |= DI_MAP_FLAG;
+	pr_dbg("di reveser memory 0x%lx, size %uMB.\n",
 			di_devp->mem_start, (di_devp->mem_size >> 20));
 		return 0;
 	}
@@ -9029,7 +9387,7 @@ static void set_di_flag(void)
 			di_force_bit_mode = 8;
 		if (is_meson_txl_cpu()) {
 			full_422_pack = true;
-			tff_bff_enable = true;
+			tff_bff_enable = false;
 			dejaggy_enable = 0;
 		}
 	} else {
@@ -9052,6 +9410,9 @@ static void set_di_flag(void)
 		tbbtff_dly = 0;
 	}
 
+	if (cpu_after_eq(MESON_CPU_MAJOR_ID_GXBB))
+		dnr_dm_en = true;
+
 	return;
 }
 
@@ -9113,6 +9474,22 @@ static int di_probe(struct platform_device *pdev)
 	dev_set_drvdata(di_devp->dev, di_devp);
 	platform_set_drvdata(pdev, di_devp);
 	of_reserved_mem_device_init(&pdev->dev);
+	ret = of_property_read_u32(pdev->dev.of_node,
+		"flag_cma", &(di_devp->flag_cma));
+	if (ret)
+		pr_err("DI-%s: get flag_cma error.\n", __func__);
+	else
+		pr_info("DI-%s: flag_cma: %d\n", __func__, di_devp->flag_cma);
+	if (di_devp->flag_cma == 1) {
+#ifdef CONFIG_CMA
+		di_devp->pdev = pdev;
+		di_devp->mem_size = dma_get_cma_size_int_byte(&pdev->dev);
+		pr_info("DI: CMA size 0x%x.\n", di_devp->mem_size);
+#endif
+		mem_flag = 0;
+	} else {
+		mem_flag = 1;
+	}
 	di_devp->di_irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
 	di_devp->timerc_irq = irq_of_parse_and_map(pdev->dev.of_node, 1);
 	pr_info("di_irq:%d,timerc_irq:%d\n",
@@ -9136,6 +9513,7 @@ static int di_probe(struct platform_device *pdev)
 	if (ret)
 		pr_err("DI-%s: get hw version error.\n", __func__);
 	di_pr_info("DI hw version %u.\n", di_devp->hw_version);
+
 	vout_register_client(&display_mode_notifier_nb_v);
 
 	/* set flag to indicate that post_wr is surpportted */
@@ -9223,7 +9601,6 @@ static int di_probe(struct platform_device *pdev)
 /* Disable MCDI when code does not surpport MCDI */
 	if (!mcpre_en)
 		DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, 0, 0, 1);
-
 /* timer */
 	INIT_WORK(&di_pre_work, di_timer_handle);
 	init_timer(&di_pre_timer);
@@ -9290,6 +9667,7 @@ static int di_remove(struct platform_device *pdev)
 
 #ifdef CONFIG_PM
 static int save_init_flag;
+static int save_mem_flag;
 static int di_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	aml_cbus_update_bits(ISA_TIMER_MUX, 1 << 18, 0 << 18);
@@ -9297,7 +9675,9 @@ static int di_suspend(struct platform_device *pdev, pm_message_t state)
 
 /* fix suspend/resume crash problem */
 	save_init_flag = init_flag;
+	save_mem_flag = mem_flag;
 	init_flag = 0;
+	mem_flag = 0;
 	field_count = 0;
 	if (di_pre_stru.di_inp_buf) {
 		if (vframe_in[di_pre_stru.di_inp_buf->index]) {
@@ -9319,7 +9699,8 @@ static int di_suspend(struct platform_device *pdev, pm_message_t state)
 static int di_resume(struct platform_device *pdev)
 {
 	init_flag = save_init_flag;
-	if (init_flag) {
+	mem_flag = save_mem_flag;
+	if (init_flag && mem_flag) {
 		di_set_power_control(0, 1);
 		di_set_power_control(1, 1);
 	}
@@ -9449,6 +9830,9 @@ module_param(force_height, int, 0664);
 MODULE_PARM_DESC(bypass_get_buf_threshold, "\n bypass_get_buf_threshold\n");
 module_param(bypass_get_buf_threshold, uint, 0664);
 
+MODULE_PARM_DESC(bypass_hdmi_get_buf_threshold, "\n bypass_hdmi_get_buf_threshold\n");
+module_param(bypass_hdmi_get_buf_threshold, uint, 0664);
+
 MODULE_PARM_DESC(pulldown_detect, "\n pulldown_detect\n");
 module_param(pulldown_detect, int, 0664);
 
diff --git a/drivers/amlogic/deinterlace/deinterlace.h b/drivers/amlogic/deinterlace/deinterlace.h
index 554cf27..dd019c2 100644
--- a/drivers/amlogic/deinterlace/deinterlace.h
+++ b/drivers/amlogic/deinterlace/deinterlace.h
@@ -127,6 +127,12 @@ enum pulldown_mode_e {
 	PULL_DOWN_EI	  = 4,/* ei only */
 	PULL_DOWN_NORMAL  = 5,/* normal di */
 };
+
+enum canvas_idx_e {
+	NR_CANVAS,
+	MTN_CANVAS,
+	MV_CANVAS,
+};
 #define pulldown_mode_t enum pulldown_mode_e
 struct di_buf_s {
 #ifdef USE_LIST
@@ -184,7 +190,8 @@ struct di_buf_s {
 	unsigned int canvas_config_flag;
 	/* 0,configed; 1,config type 1 (prog);
 	2, config type 2 (interlace) */
-	unsigned int canvas_config_size;
+	unsigned int canvas_height;
+	unsigned int canvas_width[3];/* nr/mtn/mv */
 	/*bit [31~16] width; bit [15~0] height*/
 	pulldown_detect_info_t field_pd_info;
 	pulldown_detect_info_t win_pd_info[MAX_WIN_NUM];
@@ -252,10 +259,10 @@ struct DI_MIF_s {
 	unsigned short	chroma_y_end0;
 	unsigned		set_separate_en:2;
 	unsigned		src_field_mode:1;
-	unsigned		src_prog:1;
 	unsigned		video_mode:1;
 	unsigned		output_field_num:1;
 	unsigned		bit_mode:2;
+	unsigned		src_prog:1;
 	/*
 	unsigned		burst_size_y:2; set 3 as default
 	unsigned		burst_size_cb:2;set 1 as default
@@ -279,7 +286,7 @@ struct DI_MC_MIF_s {
 	unsigned short size_x;
 	unsigned short size_y;
 	unsigned short canvas_num;
-	unsigned short blend_mode;
+	unsigned short blend_en;
 	unsigned short vecrd_offset;
 };
 void disable_deinterlace(void);
@@ -341,7 +348,7 @@ void deinterlace_init(void);
 void initial_di_pre_aml(int hsize_pre, int vsize_pre, int hold_line);
 
 void initial_di_post_2(int hsize_post, int vsize_post, int hold_line);
-
+void di_nr_level_config(int level);
 void enable_di_post_2(
 	struct DI_MIF_s		*di_buf0_mif,
 	struct DI_MIF_s		*di_buf1_mif,
@@ -385,10 +392,10 @@ void read_mtn_info(unsigned long *mtn_info, unsigned long*);
 
 /* for video reverse */
 void di_post_read_reverse(bool reverse);
-void di_post_read_reverse_irq(bool reverse);
+void di_post_read_reverse_irq(bool reverse, unsigned char mc_pre_flag);
 extern void recycle_keep_buffer(void);
 
-#undef DI_DEBUG
+/* #define DI_BUFFER_DEBUG */
 
 #define DI_LOG_MTNINFO		0x02
 #define DI_LOG_PULLDOWN		0x10
@@ -402,6 +409,7 @@ extern unsigned int di_log_flag;
 extern unsigned int di_debug_flag;
 extern bool mcpre_en;
 extern bool dnr_reg_update;
+extern bool dnr_dm_en;
 extern int mpeg2vdin_flag;
 extern int di_vscale_skip_count_real;
 extern unsigned int pulldown_enable;
@@ -444,6 +452,7 @@ void config_di_bit_mode(vframe_t *vframe, unsigned int bypass_flag);
 void combing_pd22_window_config(unsigned int width, unsigned int height);
 int tff_bff_check(int height, int width);
 void tbff_init(void);
+void di_hw_disable(void);
 #ifdef CONFIG_AM_ATVDEMOD
 extern int aml_atvdemod_get_snr_ex(void);
 #endif
@@ -456,25 +465,31 @@ void DI_VSYNC_WR_MPEG_REG_BITS(unsigned int addr, unsigned int val,
 	unsigned int start, unsigned int len);
 
 #define DI_COUNT   1
-
+#define DI_MAP_FLAG	0x1
 struct di_dev_s {
 	dev_t			   devt;
 	struct cdev		   cdev; /* The cdev structure */
 	struct device	   *dev;
+	struct platform_device	*pdev;
 	struct task_struct *task;
 	unsigned char	   di_event;
 	unsigned int	   di_irq;
+	unsigned int	   flags;
 	unsigned int	   timerc_irq;
 	unsigned long	   mem_start;
 	unsigned int	   mem_size;
 	unsigned int	   buffer_size;
 	unsigned int	   buf_num_avail;
 	unsigned int	   hw_version;
-	int							rdma_handle;
+	int		rdma_handle;
 	/* is surpport nr10bit */
 	unsigned int	   nr10bit_surpport;
 	/* is DI surpport post wr to mem for OMX */
 	unsigned int       post_wr_surpport;
+	unsigned int	   flag_cma;
+	unsigned int	   cma_alloc[10];
+	unsigned int	   buffer_addr[10];
+	struct page	*pages[10];
 };
 #define di_dev_t struct di_dev_s
 
diff --git a/drivers/amlogic/deinterlace/deinterlace_hw.c b/drivers/amlogic/deinterlace/deinterlace_hw.c
index 0957aa6..67b8ebe 100644
--- a/drivers/amlogic/deinterlace/deinterlace_hw.c
+++ b/drivers/amlogic/deinterlace/deinterlace_hw.c
@@ -76,10 +76,6 @@ unsigned int di_force_bit_mode = 10;
 module_param(di_force_bit_mode, uint, 0664);
 MODULE_PARM_DESC(di_force_bit_mode, "force DI bit mode to 8 or 10 bit");
 
-static unsigned short mc_pre_flag = 2;
-MODULE_PARM_DESC(mc_pre_flag, "\n mc per/forward flag\n");
-module_param(mc_pre_flag, ushort, 0664);
-
 #ifdef DET3D
 static unsigned int det3d_cfg;
 module_param(det3d_cfg, uint, 0664);
@@ -194,8 +190,8 @@ void di_hw_init(void)
 	unsigned short fifo_size_vpp = 0xc0;
 	unsigned short fifo_size_di = 0xc0;
 #endif
-
 #ifdef NEW_DI_V1
+	switch_vpu_clk_gate_vmod(VPU_VPU_CLKB, VPU_CLK_GATE_ON);
 	/* enable old DI mode for m6tv */
 	if (is_meson_gxtvbb_cpu() || is_meson_gxl_cpu() || is_meson_gxm_cpu())
 		DI_Wr(DI_CLKG_CTRL, 0xffff0001);
@@ -239,8 +235,15 @@ void di_hw_init(void)
 
 	if (mcpre_en)
 		mc_di_param_init();
-
-	DI_Wr(DI_CLKG_CTRL, 0x2); /* di clock gate all */
+	if (is_meson_txl_cpu()) {
+		DI_Wr(DI_CLKG_CTRL, 0x80000000); /* di clock div enable for pq load */
+	} else {
+		DI_Wr(DI_CLKG_CTRL, 0x2); /* di clock gate all */
+		if (!is_meson_gxl_cpu() && !is_meson_gxm_cpu() &&
+			!is_meson_gxbb_cpu())
+			switch_vpu_clk_gate_vmod(VPU_VPU_CLKB,
+				VPU_CLK_GATE_OFF);
+	}
 }
 
 void di_hw_uninit(void)
@@ -534,8 +537,7 @@ void enable_mc_di_post(struct DI_MC_MIF_s *di_mcvecrd_mif,
 						(0x31<<16));
 	DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, di_mcvecrd_mif->vecrd_offset,
 		12, 3);
-
-	if (di_mcvecrd_mif->blend_mode == 3)
+	if (di_mcvecrd_mif->blend_en)
 		DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, mcen_mode, 0, 2);
 	else
 		DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, 0, 0, 2);
@@ -605,15 +607,15 @@ static void set_di_inp_mif(struct DI_MIF_s *mif, int urgent, int hold_line)
 
 		vfmt_rpt_first = 1;
 		if (mif->output_field_num == 0)
-			vt_ini_phase = 0xa;
-		else
 			vt_ini_phase = 0xe;
+		else
+			vt_ini_phase = 0xa;
 
 		if (mif->src_prog) {
 			if (mif->output_field_num == 0) {
-				vt_ini_phase = 0x4;
-			} else {
 				vt_ini_phase = 0xc;
+			} else {
+				vt_ini_phase = 0x4;
 				vfmt_rpt_first = 0;
 			}
 		 }
@@ -1532,10 +1534,12 @@ void initial_di_post_2(int hsize_post, int vsize_post, int hold_line)
 		);
 	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
 		/* enable ma,disable if0 to vpp */
-		if (Rd_reg_bits(VIU_MISC_CTRL0, 16, 3) != 5)
+		if ((VSYNC_RD_MPEG_REG(VIU_MISC_CTRL0) & 0x50000) != 0x50000) {
 			DI_VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL0, 5, 16, 3);
-		if (post_wr_en)
-			DI_VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL0, 1, 28, 1);
+			if (post_wr_en)
+				DI_VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL0,
+					1, 28, 1);
+		}
 	}
 }
 
@@ -1560,6 +1564,11 @@ void di_post_switch_buffer(
 	ei_only = ei_en && !blend_en && (di_vpp_en || di_ddr_en);
 	buf1_en =  (!ei_only && (di_ddr_en || di_vpp_en));
 
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
+		if ((VSYNC_RD_MPEG_REG(VIU_MISC_CTRL0) & 0x50000) != 0x50000)
+			DI_VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL0, 5, 16, 3);
+	}
+
 	if (ei_en || di_vpp_en || di_ddr_en)
 		set_di_if0_mif(di_buf0_mif, urgent, hold_line);
 
@@ -1573,16 +1582,6 @@ void di_post_switch_buffer(
 				(di_buf2_mif->canvas0_addr2 << 16) |
 				(di_buf2_mif->canvas0_addr1 << 8) |
 				(di_buf2_mif->canvas0_addr0 << 0));
-	#if 0
-	/* post bit mode config, if0 config in video.c */
-		if (is_meson_gxtvbb_cpu() || is_meson_gxl_cpu() ||
-			is_meson_gxm_cpu())
-			DI_VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG3,
-						di_buf1_mif->bit_mode, 8, 2);
-		if (is_meson_txl_cpu())
-			DI_VSYNC_WR_MPEG_REG_BITS(DI_IF2_GEN_REG3,
-				di_buf2_mif->bit_mode, 8, 2);
-	#endif
 	}
 
 	/* motion for current display field. */
@@ -1594,16 +1593,11 @@ void di_post_switch_buffer(
 	}
 
 	if (di_ddr_en) {
-		if ((post_wr_en && post_wr_surpport)) {
-			DI_VSYNC_WR_MPEG_REG(DI_DIWR_CTRL,
-				di_diwr_mif->canvas_num);
-			DI_VSYNC_WR_MPEG_REG_BITS(DI_DIWR_CTRL, urgent, 16, 1);
-			DI_VSYNC_WR_MPEG_REG_BITS(DI_DIWR_CTRL,
-				di_ddr_en, 30, 1);
-		} else {
-			DI_VSYNC_WR_MPEG_REG(DI_DIWR_CTRL,
-			di_diwr_mif->canvas_num | (urgent << 16)); /* urgent. */
-		}
+		DI_VSYNC_WR_MPEG_REG(DI_DIWR_CTRL,
+			di_diwr_mif->canvas_num |
+				(urgent << 16)	|
+				(2 << 26)		|
+				(di_ddr_en << 30));
 	}
 	if ((pldn_ctrl_rflsh == 1) && pulldown_enable) {
 		DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_CTRL, blend_en, 31, 1);
@@ -1622,13 +1616,13 @@ void di_post_switch_buffer(
 	(1<<9) |	  /* canvas enable */
 	di_mcvecrd_mif->canvas_num |  /* canvas index. */
 	(urgent << 8));
+		DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,
+			di_mcvecrd_mif->vecrd_offset, 12, 3);
+		if (di_mcvecrd_mif->blend_en)
+			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,
+				mcen_mode, 0, 2);
+		else
 			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,
-				di_mcvecrd_mif->vecrd_offset, 12, 3);
-			if (di_mcvecrd_mif->blend_mode == 3)
-				DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,
-					mcen_mode, 0, 2);
-			else
-				DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,
 					0, 0, 2);
 	}
 	DI_VSYNC_WR_MPEG_REG(DI_POST_CTRL,
@@ -1692,24 +1686,16 @@ blend_mtn_en,blend_mode); */
 	}
 
 	if (di_ddr_en) {
-		if ((post_wr_en && post_wr_surpport)) {
-			DI_VSYNC_WR_MPEG_REG(DI_DIWR_X,
-(di_diwr_mif->start_x << 16) | (di_diwr_mif->end_x));
-			DI_VSYNC_WR_MPEG_REG(DI_DIWR_Y,
-(di_diwr_mif->start_y << 16) | (di_diwr_mif->end_y));
-			DI_VSYNC_WR_MPEG_REG(DI_DIWR_CTRL,
-			di_diwr_mif->canvas_num|
-			(urgent << 16) |
-			(di_ddr_en << 30));
-		} else {
 		DI_VSYNC_WR_MPEG_REG(DI_DIWR_X,
 (di_diwr_mif->start_x << 16) | (di_diwr_mif->end_x));
-	   DI_VSYNC_WR_MPEG_REG(DI_DIWR_Y,
-(di_diwr_mif->start_y << 16) | (di_diwr_mif->end_y * 2 + 1));
-	   DI_VSYNC_WR_MPEG_REG(DI_DIWR_CTRL, di_diwr_mif->canvas_num|
-(urgent << 16));
-		}
-}
+		DI_VSYNC_WR_MPEG_REG(DI_DIWR_Y, (3 << 30) |
+(di_diwr_mif->start_y << 16) | (di_diwr_mif->end_y));
+		DI_VSYNC_WR_MPEG_REG(DI_DIWR_CTRL,
+		di_diwr_mif->canvas_num|
+		(urgent << 16) |
+		(2 << 26) |
+		(di_ddr_en << 30));
+	}
 
 	DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_CTRL, 7, 22, 3);
 	DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_CTRL,
@@ -1736,7 +1722,7 @@ blend_mtn_en,blend_mode); */
 (di_vpp_en << 12) |	/* post viu link */
 (hold_line << 16) |	/* post hold line number */
 (post_field_num << 29) |	/* post field number. */
-(((post_wr_en && post_wr_surpport)?0x3:0x1) << 30)
+(0x3 << 30)
 /* post soft rst  post frame rst. */
 		);
 }
@@ -1750,7 +1736,7 @@ void disable_post_deinterlace_2(void)
 		DI_VSYNC_WR_MPEG_REG(DI_IF2_GEN_REG, 0x3 << 30);
 	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
 		/* disable ma,enable if0 to vpp,enable afbc to vpp */
-		if (Rd_reg_bits(VIU_MISC_CTRL0, 16, 4) != 0)
+		if ((VSYNC_RD_MPEG_REG(VIU_MISC_CTRL0) & 0x50000) != 0)
 			DI_VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL0, 0, 16, 4);
 		/* DI inp(current data) switch to memory */
 		DI_VSYNC_WR_MPEG_REG_BITS(VIUB_MISC_CTRL0, 0, 16, 1);
@@ -1759,6 +1745,29 @@ void disable_post_deinterlace_2(void)
 Rd(DI_IF1_GEN_REG) & 0xfffffffe); */
 }
 
+static void enable_di_post_mif(bool enable)
+{
+	DI_Wr(DI_POST_SIZE, (32-1) | ((128-1) << 16));
+	DI_Wr(DI_IF1_GEN_REG, 0x3 << 30);
+	if (is_meson_txl_cpu())
+		DI_Wr(DI_IF2_GEN_REG, 0x3 << 30);
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
+		/* disable ma,enable if0 to vpp,enable afbc to vpp */
+		if (Rd_reg_bits(VIU_MISC_CTRL0, 16, 4) != 0)
+			DI_Wr_reg_bits(VIU_MISC_CTRL0, 0, 16, 4);
+		/* DI inp(current data) switch to memory */
+		DI_Wr_reg_bits(VIUB_MISC_CTRL0, 0, 16, 1);
+	}
+}
+
+void di_hw_disable(void)
+{
+	DI_Wr(DI_PRE_CTRL, 0x3 << 30);
+	enable_di_pre_mif(false);
+	DI_Wr(DI_POST_CTRL, 0x3 << 30);
+	enable_di_post_mif(false);
+}
+
 void enable_film_mode_check(unsigned int width, unsigned int height,
 		enum vframe_source_type_e source_type)
 {
@@ -1911,24 +1920,33 @@ void di_post_read_reverse(bool reverse)
 	}
 #endif
 }
-void di_post_read_reverse_irq(bool reverse)
+void di_post_read_reverse_irq(bool reverse, unsigned char mc_pre_flag)
 {
 	if (reverse) {
 		DI_VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG2,    3, 2, 2);
 		DI_VSYNC_WR_MPEG_REG_BITS(VD1_IF0_GEN_REG2, 0xf, 2, 4);
 		DI_VSYNC_WR_MPEG_REG_BITS(VD2_IF0_GEN_REG2, 0xf, 2, 4);
 		DI_VSYNC_WR_MPEG_REG_BITS(DI_MTNRD_CTRL, 0xf, 17, 4);
+		if (cpu_after_eq(MESON_CPU_MAJOR_ID_TXL))
+			DI_VSYNC_WR_MPEG_REG_BITS(DI_IF2_GEN_REG2,  3, 2, 2);
 		if (mcpre_en) {
 			/* motion vector read reverse*/
 			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MCVECRD_X, 1, 30, 1);
 			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MCVECRD_Y, 1, 30, 1);
-			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, 0, 8, 1);
+			if (is_meson_txl_cpu())
+				DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,
+				mc_pre_flag, 8, 2);
+			else
+				DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,
+				mc_pre_flag, 8, 1);
 		}
 	} else {
 		DI_VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG2,  0, 2, 2);
 		DI_VSYNC_WR_MPEG_REG_BITS(VD1_IF0_GEN_REG2, 0, 2, 4);
 		DI_VSYNC_WR_MPEG_REG_BITS(VD2_IF0_GEN_REG2, 0, 2, 4);
 		DI_VSYNC_WR_MPEG_REG_BITS(DI_MTNRD_CTRL, 0, 17, 4);
+		if (cpu_after_eq(MESON_CPU_MAJOR_ID_TXL))
+			DI_VSYNC_WR_MPEG_REG_BITS(DI_IF2_GEN_REG2, 0, 2, 2);
 		if (mcpre_en) {
 			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MCVECRD_X, 0, 30, 1);
 			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MCVECRD_Y, 0, 30, 1);
@@ -1937,7 +1955,7 @@ void di_post_read_reverse_irq(bool reverse)
 					mc_pre_flag, 8, 2);
 			else
 				DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,
-					1, 8, 1);
+					mc_pre_flag, 8, 1);
 		}
 	}
 }
@@ -2012,7 +2030,60 @@ static void di_nr_init(void)
 	DI_Wr(NR3_CMOT_PARA, 0x08140f);
 	DI_Wr(NR3_SUREMOT_YGAIN, 0x100c4014);
 	DI_Wr(NR3_SUREMOT_CGAIN, 0x22264014);
+}
+static void nr_level_strong(void)
+{
+	DI_Wr(0x1751, 0x132f);
+	DI_Wr(0x1752, 0x8d);
+	DI_Wr(0x1753, 0x40ff00);
+	DI_Wr(0x1754, 0x4);
+	DI_Wr(0x1755, 0xc2b64);
+	DI_Wr(0x1756, 0x0);
+	DI_Wr(0x1757, 0x3608);
+	DI_Wr(0x1758, 0x420);
+	DI_Wr(0x1759, 0xa06664);
+	DI_Wr(0x175a, 0xe0000);
+	DI_Wr(0x175b, 0x991c00);
+	DI_Wr(0x175c, 0x991000);
+	DI_Wr(0x175d, 0xf9f3e);
+	DI_Wr(0x175e, 0x7292abcd);
+	DI_Wr(0x175f, 0x1c23314f);
+	DI_Wr(0x1760, 0xf111317);
+	DI_Wr(0x1761, 0x8090a0c);
+	DI_Wr(0x1762, 0x80a0e0ff);
+	DI_Wr(0x1763, 0x4102050);
+	DI_Wr(0x1764, 0x2);
+	DI_Wr(0x1765, 0x0);
+	DI_Wr(0x1766, 0x20100400);
+	DI_Wr(0x1767, 0xc4804030);
+	DI_Wr(0x1768, 0xfffff0e0);
+	DI_Wr(0x1769, 0xffffffff);
+	DI_Wr(0x176a, 0x1133);
+	DI_Wr(0x176b, 0x32020);
+	DI_Wr(0x176c, 0x3030);
+	DI_Wr(0x176d, 0x3f3f3e3f);
+	DI_Wr(0x176e, 0x153);
+	DI_Wr(0x176f, 0x50505050);
+	DI_Wr(0x1770, 0x5c4d3232);
+	DI_Wr(0x1771, 0x7b716a66);
+	DI_Wr(0x1772, 0xffffffa9);
+	DI_Wr(0x1773, 0x28282828);
+	DI_Wr(0x1774, 0x493f2828);
+	DI_Wr(0x1775, 0x7e625854);
+	DI_Wr(0x1776, 0xfffff99c);
+	DI_Wr(0x1777, 0xa06663);
+	DI_Wr(0x1778, 0x372);
+	DI_Wr(0x1779, 0x14141414);
+	DI_Wr(0x177a, 0x1400);
+	DI_Wr(0x177b, 0x80064);
+	DI_Wr(0x177c, 0x80064);
+	DI_Wr(0x177d, 0x80a0a);
+	DI_Wr(0x177e, 0x4281e);
+	DI_Wr(0x177f, 0x0);
+}
 
+static void nr_level_normal(void)
+{
 	DI_Wr(0x1745, 0x5056410);
 	DI_Wr(0x1746, 0x45056410);
 	DI_Wr(0x1747, 0x45056410);
@@ -2075,7 +2146,13 @@ static void di_nr_init(void)
 	DI_Wr(0x179c, 0x11b);
 	DI_Wr(0x179d, 0x202220);
 }
-
+void di_nr_level_config(int level)
+{
+	if (level == 1)
+		nr_level_strong();
+	else
+		nr_level_normal();
+}
 void enable_di_pre_mif(int en)
 {
 	if (en) {
diff --git a/drivers/amlogic/deinterlace/dnr.c b/drivers/amlogic/deinterlace/dnr.c
index e0baa63..59fe902 100644
--- a/drivers/amlogic/deinterlace/dnr.c
+++ b/drivers/amlogic/deinterlace/dnr.c
@@ -89,21 +89,21 @@ int global_bs_calc_sw(int *pGbsVldCnt,
 	nMax = max(max(nGbsStatLR, nGbsStatLL), nGbsStatRR);
 	nMin = min(min(nGbsStatLR, nGbsStatLL), nGbsStatRR);
 
-	nDif0 = nMax == 0 ? 0 : 512*(nMax - nMin)/nMax;
+	nDif0 = nMax == 0 ? 0 : ((nMax - nMin) << 9)/nMax;
 	nDif0 = min(511, nDif0);
 
 	nDif1 = nGbsStatLR == 0 ? 0 :
-512*abs(nGbsStatLR - (nGbsStatLL + nGbsStatRR)/2)/nGbsStatLR;
+	(abs(nGbsStatLR - (nGbsStatLL + nGbsStatRR)/2) << 9)/nGbsStatLR;
 	nDif1 = min(511, nDif1);
 
 	nDif2 = nGbsStatLR == 0 ? 0 :
-512*abs(nGbsStatLR - max(nGbsStatLL, nGbsStatRR))/nGbsStatLR;
+	(abs(nGbsStatLR - max(nGbsStatLL, nGbsStatRR)) << 9)/nGbsStatLR;
 	nDif2 = min(511, nDif2);
 
 	if (0 == prm_gbs_ratcalcmod)
-		nRat = 16 * nGbsStatLR / max(prm_gbs_cnt_min, nGbsStatCnt);
+		nRat = (nGbsStatLR << 4) / max(prm_gbs_cnt_min, nGbsStatCnt);
 	else
-		nRat = 16 * nGbsStatDif / max(prm_gbs_cnt_min, nGbsStatCnt);
+		nRat = (nGbsStatDif << 4) / max(prm_gbs_cnt_min, nGbsStatCnt);
 
 	nDif = 0 == prm_gbs_calcmod ? nDif0 :
 (1 == prm_gbs_calcmod ? nDif1 : nDif2);
@@ -284,9 +284,9 @@ int ver_blk_ofst_calc_sw(int *pVbOfVldCnt,
 }
 #endif
 
-void run_dnr_in_irq(int nCol, int nRow)
+void run_dnr_in_irq(unsigned short nCol, unsigned short nRow)
 {
-	int ro_gbs_stat_lr = 0, ro_gbs_stat_ll = 0, ro_gbs_stat_rr = 0,
+	static int ro_gbs_stat_lr = 0, ro_gbs_stat_ll = 0, ro_gbs_stat_rr = 0,
 	ro_gbs_stat_dif = 0, ro_gbs_stat_cnt = 0;
 	/* int reg_dnr_stat_xst=0,reg_dnr_stat_xed=0,
 reg_dnr_stat_yst=0,reg_dnr_stat_yed=0; */
@@ -295,19 +295,33 @@ reg_dnr_stat_yst=0,reg_dnr_stat_yed=0; */
 #endif
 	if (dnr_reg_update == 0)
 		return;
+
 	DI_Wr(DNR_CTRL, 0x1df00);
 	DI_Wr(DNR_DM_CTRL, Rd(DNR_DM_CTRL)|(1 << 11));
-	DI_Wr_reg_bits(DNR_DM_CTRL, dnr_dm_en, 9, 1);
+	/* dm for sd, hd will slower */
+	if (nCol >= 1920)
+		DI_Wr_reg_bits(DNR_DM_CTRL, 0, 9, 1);
+	else
+		DI_Wr_reg_bits(DNR_DM_CTRL, dnr_dm_en, 9, 1);
 	DI_Wr(DNR_HVSIZE, nCol<<16|nRow);
-	DI_Wr(DNR_STAT_X_START_END, (((8*dnr_stat_coef)&0x3fff) << 16)
-		|((nCol-(8*dnr_stat_coef+1))&0x3fff));
-	DI_Wr(DNR_STAT_Y_START_END, (((8*dnr_stat_coef)&0x3fff) << 16)
-		|((nRow-(8*dnr_stat_coef+1))&0x3fff));
-	ro_gbs_stat_lr = Rd(DNR_RO_GBS_STAT_LR);
-	ro_gbs_stat_ll = Rd(DNR_RO_GBS_STAT_LL);
-	ro_gbs_stat_rr = Rd(DNR_RO_GBS_STAT_RR);
-	ro_gbs_stat_dif = Rd(DNR_RO_GBS_STAT_DIF);
-	ro_gbs_stat_cnt = Rd(DNR_RO_GBS_STAT_CNT);
+	DI_Wr(DNR_STAT_X_START_END, (((dnr_stat_coef<<3)&0x3fff) << 16)
+		|((nCol-((dnr_stat_coef<<3)+1))&0x3fff));
+	DI_Wr(DNR_STAT_Y_START_END, (((dnr_stat_coef<<3)&0x3fff) << 16)
+		|((nRow-((dnr_stat_coef<<3)+1))&0x3fff));
+	if (ro_gbs_stat_lr != Rd(DNR_RO_GBS_STAT_LR) ||
+		ro_gbs_stat_ll != Rd(DNR_RO_GBS_STAT_LL) ||
+		ro_gbs_stat_rr != Rd(DNR_RO_GBS_STAT_RR) ||
+		ro_gbs_stat_dif != Rd(DNR_RO_GBS_STAT_DIF) ||
+		ro_gbs_stat_cnt != Rd(DNR_RO_GBS_STAT_CNT)) {
+
+		ro_gbs_stat_lr = Rd(DNR_RO_GBS_STAT_LR);
+		ro_gbs_stat_ll = Rd(DNR_RO_GBS_STAT_LL);
+		ro_gbs_stat_rr = Rd(DNR_RO_GBS_STAT_RR);
+		ro_gbs_stat_dif = Rd(DNR_RO_GBS_STAT_DIF);
+		ro_gbs_stat_cnt = Rd(DNR_RO_GBS_STAT_CNT);
+	} else {
+		return;
+	}
 
 	global_bs_calc_sw(&pDnrPrm->sw_gbs_vld_cnt,
 			  &pDnrPrm->sw_gbs_vld_flg,
diff --git a/drivers/amlogic/deinterlace/dnr.h b/drivers/amlogic/deinterlace/dnr.h
index 40f652c..2e4c0c7 100644
--- a/drivers/amlogic/deinterlace/dnr.h
+++ b/drivers/amlogic/deinterlace/dnr.h
@@ -93,6 +93,6 @@ int ver_blk_ofst_calc_sw(int *pVbOfVldCnt,
 			 int prm_vbof_vldcntthd,
 			 int nRow,
 			 int nCol);
-void run_dnr_in_irq(int nCol, int nRow);
+void run_dnr_in_irq(unsigned short nCol, unsigned short nRow);
 #endif
 
diff --git a/drivers/amlogic/deinterlace/film_fw1.c b/drivers/amlogic/deinterlace/film_fw1.c
index 1265911..87fb48f 100644
--- a/drivers/amlogic/deinterlace/film_fw1.c
+++ b/drivers/amlogic/deinterlace/film_fw1.c
@@ -1,6 +1,8 @@
 /* Film Detection and VOF detection Software implementation
 * Designer: Xin.Hu@amlogic.com
-* Date: 12/06/13 */
+*/
+
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include "film_vof_soft.h"
@@ -24,7 +26,7 @@ UINT8 FlmVOFSftInt(struct sFlmSftPar *pPar)
 
 	pPar->sF32Dif01A1 = 65;
 	pPar->sF32Dif01T1 = 128;
-	pPar->sF32Dif01A2 = 65;
+	pPar->sF32Dif01A2 = 60;
 	pPar->sF32Dif01T2 = 128;
 
 	pPar->rCmbRwMinCt0 = 8;	/* for film 3-2 */
@@ -87,10 +89,18 @@ int flm32_mim_frms = 6;
 module_param(flm32_mim_frms, int, 0644);
 MODULE_PARM_DESC(flm32_mim_frms, "flm32_mim_frms");
 
+int flm32_dif01a_flag = 1;
+module_param(flm32_dif01a_flag, int, 0644);
+MODULE_PARM_DESC(flm32_dif01a_flag, "flm32_dif01a_flag");
+
 int flm22_mim_frms = 60;
 module_param(flm22_mim_frms, int, 0644);
 MODULE_PARM_DESC(flm22_mim_frms, "flm22_mim_frms");
 
+int flm22_mim_smfrms = 40;
+module_param(flm22_mim_smfrms, int, 0644);
+MODULE_PARM_DESC(flm22_mim_smfrms, "flm22_mim_smfrms");
+
 int flm32_f2fdif_min0 = 11;
 module_param(flm32_f2fdif_min0, int, 0644);
 MODULE_PARM_DESC(flm32_f2fdif_min0, "flm32_f2fdif_min0");
@@ -168,14 +178,36 @@ int flm22_anti_ck141 = 80;
 module_param(flm22_anti_ck141, int, 0644);
 MODULE_PARM_DESC(flm22_anti_ck141, "flm22_anti_ck141");
 
+int flm22_frmdif_max = 50;
+module_param(flm22_frmdif_max, int, 0644);
+MODULE_PARM_DESC(flm22_frmdif_max, "flm22_frmdif_max");
+
+int flm22_flddif_max = 100;
+module_param(flm22_flddif_max, int, 0644);
+MODULE_PARM_DESC(flm22_flddif_max, "flm22_flddif_max");
+
+int flm22_minus_cntmax = 2;
+module_param(flm22_minus_cntmax, int, 0644);
+MODULE_PARM_DESC(flm22_minus_cntmax, "flm22_minus_cntmax");
+
+static int flagdif01chk = 1;
+module_param(flagdif01chk,  int, 0644);
+MODULE_PARM_DESC(flagdif01chk, "flagdif01chk");
+
+static int dif01_ratio = 10;
+module_param(dif01_ratio,  int, 0644);
+MODULE_PARM_DESC(dif01_ratio, "dif01_ratio");
+
+
+unsigned int frame_diff_avg = 0;
 
 int FlmVOFSftTop(UINT8 *rCmb32Spcl, unsigned short *rPstCYWnd0,
 		 unsigned short *rPstCYWnd1, unsigned short *rPstCYWnd2,
 		 unsigned short *rPstCYWnd3, unsigned short *rPstCYWnd4,
 		 UINT8 *rFlmPstGCm, UINT8 *rFlmSltPre, UINT8 *rFlmPstMod,
 		 UINT32 *rROFldDif01, UINT32 *rROFrmDif02, UINT32 *rROCmbInf,
-		 int *tTCNm,
-		 struct sFlmSftPar *pPar, int nROW, int nCOL)
+		 UINT32 glb_frame_mot_num, UINT32 glb_field_mot_num, int *tTCNm,
+		 struct sFlmSftPar *pPar, int nROW, int nCOL, bool reverse)
 {
 	static UINT32 DIF01[HISDIFNUM]; /* Last one is global */
 	static UINT32 DIF02[HISDIFNUM]; /* Last one is global */
@@ -184,10 +216,18 @@ int FlmVOFSftTop(UINT8 *rCmb32Spcl, unsigned short *rPstCYWnd0,
 
 	static struct sFlmDatSt pRDat;
 	static int pre22lvl;
+	static UINT32 pre_fld_motnum;
+	static int modpre;
+	static int num;
+	static int num32;
+	static int flag_pre;
+	int dif01th = 0;
 
 	int nDIF01[HISDIFNUM];
 	int nDIF02[HISDIFNUM];
 	/* UINT32 nCb32=0; */
+	unsigned int ntmp = 0;
+	unsigned int flm22_mim_numb = 0;
 
 	/* int nRCMB[ROWCMBNUM]; */
 	int mDly = pPar->mPstDlyPre;
@@ -198,6 +238,7 @@ int FlmVOFSftTop(UINT8 *rCmb32Spcl, unsigned short *rPstCYWnd0,
 	int nS0 = 0;
 	int nS1 = 0;
 	int nMod = 0;
+	int difflag = 0;
 
 	/* difference */
 	pRDat.rROFrmDif02 = rROFrmDif02;
@@ -258,9 +299,13 @@ int FlmVOFSftTop(UINT8 *rCmb32Spcl, unsigned short *rPstCYWnd0,
 	DIF01[HISDIFNUM - 1] = rROFldDif01[0];	/* 5windows+global */
 	DIF02[HISDIFNUM - 1] = rROFrmDif02[0];	/* 5windows+global */
 
-	if (pr_pd)
+	if (pr_pd) {
 		sprintf(debug_str, "\nField#%5d: [%4dx%4d]\n",
 			field_count, nROW, nCOL);
+		sprintf(debug_str + strlen(debug_str),
+		"diff counter: %4d %4d\n",
+			glb_field_mot_num, glb_frame_mot_num);
+	}
 
 	prt_flg = (pr_pd & 0x1);
 	if (prt_flg) {
@@ -339,6 +384,7 @@ int FlmVOFSftTop(UINT8 *rCmb32Spcl, unsigned short *rPstCYWnd0,
 	/* Only frame (t-1) */
 	/* pFMReg->rFlmPstGCm = 0; */
 	*rFlmPstGCm = 0;
+	frame_diff_avg = DIF02[HISDIFNUM-1] / (glb_frame_mot_num + 1);
 	/* rFlmPstGCm = 1; */
 	if (pRDat.pMod32[HISDETNUM - 1 - mDly] == 3) {
 		nT0 = pRDat.pFlg32[HISDETNUM - 1 - mDly] % 2;
@@ -359,10 +405,54 @@ int FlmVOFSftTop(UINT8 *rCmb32Spcl, unsigned short *rPstCYWnd0,
 		00: global combing, 01: 2-2 film, 10: 2-3 film, 11:-others */
 		*rFlmPstMod = 1;
 
+		ntmp = (glb_frame_mot_num + glb_field_mot_num) /
+				(nCOL + 1);
+		if (flm22_mim_frms > ntmp +  flm22_mim_smfrms)
+			flm22_mim_numb = flm22_mim_frms - ntmp;
+		else
+			flm22_mim_numb = flm22_mim_smfrms;
+
+		if (pr_pd)
+			pr_info("diff02-avg=%4d\n", frame_diff_avg);
+		if (frame_diff_avg > flm22_frmdif_max) {
+			ntmp = frame_diff_avg - flm22_frmdif_max;
+			if (ntmp > flm22_minus_cntmax)
+				ntmp = flm22_minus_cntmax;
+			if (pRDat.mNum22[HISDETNUM - 1] > ntmp)
+				pRDat.mNum22[HISDETNUM - 1] =
+					pRDat.mNum22[HISDETNUM - 1] - ntmp;
+			else
+				pRDat.mNum22[HISDETNUM - 1] = 0;
+		}
+
+		if (DIF01[HISDIFNUM-1] < DIF01[HISDIFNUM-2]) {
+			/*ntmp = DIF01[HISDIFNUM-1] / (glb_field_mot_num + 1);*/
+			/* min / max */
+			ntmp = DIF01[HISDIFNUM-1] / (pre_fld_motnum + 1);
+
+			if (pr_pd)
+				pr_info("diff01-avg=%4d\n", ntmp);
+			if (ntmp > flm22_flddif_max) {
+				ntmp = ntmp - flm22_flddif_max;
+
+				if (ntmp > flm22_minus_cntmax)
+					ntmp = flm22_minus_cntmax;
+
+				if (pRDat.mNum22[HISDETNUM - 1] > ntmp)
+					pRDat.mNum22[HISDETNUM - 1] =
+					pRDat.mNum22[HISDETNUM - 1] - ntmp;
+				else
+					pRDat.mNum22[HISDETNUM - 1] = 0;
+			}
+		}
+
 		/* param: at least 60 field+4 */
-		if (pRDat.mNum22[HISDETNUM - 1] < flm22_mim_frms) {
+		if (pRDat.mNum22[HISDETNUM - 1] < flm22_mim_numb) {
 			*rFlmSltPre = 0;
 			*rFlmPstMod = 0;
+			if (pr_pd)
+				pr_info("mNum22(%3d) < %03d => set to mod=0\n",
+				pRDat.mNum22[HISDETNUM - 1], flm22_mim_frms);
 		}
 	} else {
 		*rFlmSltPre = 0;
@@ -371,10 +461,11 @@ int FlmVOFSftTop(UINT8 *rCmb32Spcl, unsigned short *rPstCYWnd0,
 		*rFlmPstMod = 0;
 		nS1 = 0;
 	}
+	pre_fld_motnum = glb_field_mot_num;
 
 	VOFSftTop(rFlmPstGCm, rFlmSltPre, rFlmPstMod,
 		rPstCYWnd0, rPstCYWnd1, rPstCYWnd2, rPstCYWnd3,
-		nMod, rROCmbInf, &pRDat, pPar, nROW, nCOL);
+		nMod, rROCmbInf, &pRDat, pPar, nROW, nCOL, reverse);
 
 	nT1 = pRDat.pLvlXx[HISDETNUM - 1 - mDly];
 	if ((*rFlmPstMod == 0) && (nT1 > flmxx_maybe_num)
@@ -383,6 +474,39 @@ int FlmVOFSftTop(UINT8 *rCmb32Spcl, unsigned short *rPstCYWnd0,
 		*rFlmPstMod = 4 + pRDat.pModXx[HISDETNUM - 1 - mDly];
 		nS1 = pRDat.pLvlXx[HISDETNUM - 1 - mDly];
 	}
+	if (num32 > 0 && *rFlmPstMod != 2)
+		num32 = num32-1;
+	if (pRDat.pFlg32[HISDETNUM - 1 - mDly] == 3) {
+		if (DIF01[HISDIFNUM - 2] > DIF01[HISDIFNUM - 1])
+			num32 = num32 + 1;
+		else if (num32 > 0)
+			num32 = num32-1;
+	}
+	if (modpre != *rFlmPstMod && modpre != 0 && *rFlmPstMod != 0 &&
+		num32 == 0) {
+		flag_pre = 1;
+		num = 0;
+	} else {
+		if (modpre == 0 || *rFlmPstMod == 0)
+			num = 0;
+		else if (num <= 255)
+			num = num + 1;
+	}
+
+	if (num > 5 || num32 > 0)
+		flag_pre = 0;
+
+	if (DIF01[HISDIFNUM - 2] < DIF01[HISDIFNUM - 1])
+		difflag = 1;
+	else
+		difflag = 0;
+
+	dif01th = (DIF01[HISDIFNUM - 2] + DIF01[HISDIFNUM - 1]) / dif01_ratio;
+
+	if (abs(DIF01[HISDIFNUM - 2] - DIF01[HISDIFNUM - 1]) > dif01th &&
+		flag_pre && flagdif01chk)
+		*rFlmSltPre = difflag;
+	modpre = *rFlmPstMod;
 
 	*tTCNm = pRDat.TCNm[HISCMBNUM - 1];
 	return nS1;
diff --git a/drivers/amlogic/deinterlace/film_vof_soft.h b/drivers/amlogic/deinterlace/film_vof_soft.h
index 7c6d4a3..7664a42 100644
--- a/drivers/amlogic/deinterlace/film_vof_soft.h
+++ b/drivers/amlogic/deinterlace/film_vof_soft.h
@@ -134,8 +134,8 @@ int FlmVOFSftTop(UINT8 *rCmb32Spcl, UShort *rPstCYWnd0, UShort *rPstCYWnd1,
 		 UShort *rPstCYWnd2, UShort *rPstCYWnd3, UShort *rPstCYWnd4,
 		 UINT8 *rFlmPstGCm, UINT8 *rFlmSltPre, UINT8 *rFlmPstMod,
 		 UINT32 *rROFldDif01, UINT32 *rROFrmDif02, UINT32 *rROCmbInf,
-		 int *tTCNm,
-		 struct sFlmSftPar *pPar, int nROW, int nCOL);
+		 UINT32 glb_frame_mot_num, UINT32 glb_field_mot_num, int *tTCNm,
+		 struct sFlmSftPar *pPar, int nROW, int nCOL, bool reverse);
 
 /* length of pFlm01/nDif01: [0:5]; */
 /* iDx: index of minimum dif02 ([0:5] */
@@ -173,8 +173,9 @@ int VOFSftTop(UINT8 *rFlmPstGCm, UINT8 *rFlmSltPre, UINT8 *rFlmPstMod,
 	      UShort *rPstCYWnd0, UShort *rPstCYWnd1, UShort *rPstCYWnd2,
 	      UShort *rPstCYWnd3, int nMod, UINT32 *rROCmbInf,
 	      struct sFlmDatSt *pRDat, struct sFlmSftPar *pPar,
-	      int nROW, int nCOL);
+	      int nROW, int nCOL, bool reverse);
 
 extern UINT32 field_count;
+extern unsigned int frame_diff_avg;
 
 #endif
diff --git a/drivers/amlogic/deinterlace/vof_soft_top.c b/drivers/amlogic/deinterlace/vof_soft_top.c
index 6a1b65c..79341db 100644
--- a/drivers/amlogic/deinterlace/vof_soft_top.c
+++ b/drivers/amlogic/deinterlace/vof_soft_top.c
@@ -9,7 +9,7 @@ int cmb32_blw_wnd = 180; /*192 */
 module_param(cmb32_blw_wnd, int, 0644);
 MODULE_PARM_DESC(cmb32_blw_wnd, "cmb32_blw_wnd");
 
-int cmb32_wnd_ext = 4;
+static int cmb32_wnd_ext = 11;
 module_param(cmb32_wnd_ext, int, 0644);
 MODULE_PARM_DESC(cmb32_wnd_ext, "cmb32_wnd_ext");
 
@@ -65,7 +65,7 @@ int VOFSftTop(UINT8 *rFlmPstGCm, UINT8 *rFlmSltPre, UINT8 *rFlmPstMod,
 		UShort *rPstCYWnd0, UShort *rPstCYWnd1,
 		UShort *rPstCYWnd2, UShort *rPstCYWnd3, int nMod,
 		UINT32 *rROCmbInf, struct sFlmDatSt *pRDat,
-		struct sFlmSftPar *pPar, int nROW, int nCOL)
+		struct sFlmSftPar *pPar, int nROW, int nCOL, bool reverse)
 {
 	/* HSCMB[hist10][9(32bit)] */
 	static UINT32 HSCMB[HISCMBNUM][ROWCMBLEN];
@@ -210,11 +210,21 @@ int VOFSftTop(UINT8 *rFlmPstGCm, UINT8 *rFlmSltPre, UINT8 *rFlmPstMod,
 		nWCmb = 0;
 		nBCmb = 0;
 		for (nT0 = 0; nT0 < nT1; nT0++) {
-			if (VOFWnd[2 * nT0] > (cmb32_blw_wnd * nROW >> 8)) {
-				CWND[HISDETNUM - 1][2 * nT0] =
-					VOFWnd[2 * nT0] - cmb32_wnd_ext;
-				CWND[HISDETNUM - 1][2 * nT0 + 1] =
-					VOFWnd[2 * nT0 + 1] + cmb32_wnd_ext;
+			if (VOFWnd[2*nT0] > (cmb32_blw_wnd * nROW >> 8)) {
+				CWND[HISDETNUM-1][2*nT0] =
+					VOFWnd[2*nT0] - cmb32_wnd_ext;
+				CWND[HISDETNUM-1][2*nT0+1] =
+					VOFWnd[2*nT0+1] + cmb32_wnd_ext;
+				if (reverse) {
+					if (CWND[HISDETNUM-1][2*nT0+1] >=
+						nROW - 1)
+						CWND[HISDETNUM-1][2*nT0+1]
+							= nROW - 1;
+					CWND[HISDETNUM-1][2*nT0] = nROW - 1
+					- CWND[HISDETNUM-1][2*nT0+1];
+					CWND[HISDETNUM-1][2*nT0+1] = nROW
+					- 1 - (VOFWnd[2*nT0] - cmb32_wnd_ext);
+				}
 
 				nBCmb = VOFWnd[2*nT0+1]-VOFWnd[2*nT0]+1;
 
@@ -362,7 +372,12 @@ int VOFSftTop(UINT8 *rFlmPstGCm, UINT8 *rFlmSltPre, UINT8 *rFlmPstMod,
 		for (nT0 = 0; nT0 < nT1; nT0++) {
 			CWND[HISDETNUM-1][2*nT0]   = VOFWnd[2*nT0];
 			CWND[HISDETNUM-1][2*nT0+1] = VOFWnd[2*nT0+1];
-
+			if (reverse) {
+				CWND[HISDETNUM-1][2*nT0] =
+					nROW - 1 - VOFWnd[2*nT0+1];
+				CWND[HISDETNUM-1][2*nT0+1] =
+					nROW - 1 - VOFWnd[2*nT0];
+			}
 			if (prt_flg)
 				sprintf(debug_str + strlen(debug_str),
 					"Wnd22[%d]=[%3d~%3d]\n",
@@ -413,13 +428,18 @@ int VOFSftTop(UINT8 *rFlmPstGCm, UINT8 *rFlmSltPre, UINT8 *rFlmPstMod,
 		for (nT0 = 0; nT0 < nT1; nT0++) {
 			CWND[HISDETNUM-1][2*nT0]   = VOFWnd[2*nT0];
 			CWND[HISDETNUM-1][2*nT0+1] = VOFWnd[2*nT0+1];
-
+			if (reverse) {
+				CWND[HISDETNUM-1][2*nT0] =
+					nROW - 1 - VOFWnd[2*nT0+1];
+				CWND[HISDETNUM-1][2*nT0+1] =
+					nROW - 1 - VOFWnd[2*nT0];
+			}
 			if (prt_flg)
 				sprintf(debug_str + strlen(debug_str),
-				"WndXx[%d]=[%3d~%3d]\n",
-				nT0, VOFWnd[2*nT0], VOFWnd[2*nT0+1]);
+					"WndXx[%d]=[%3d~%3d]\n",
+					nT0, VOFWnd[2*nT0], VOFWnd[2*nT0+1]);
 
-				nWCmb += VOFWnd[2*nT0+1]-VOFWnd[2*nT0]+1;
+			nWCmb += VOFWnd[2*nT0+1]-VOFWnd[2*nT0]+1;
 		}
 
 		nT1 = pRDat->pModXx[HISDETNUM - 1];
diff --git a/drivers/amlogic/display/backlight/aml_bl.c b/drivers/amlogic/display/backlight/aml_bl.c
index 0524242..6205d06 100644
--- a/drivers/amlogic/display/backlight/aml_bl.c
+++ b/drivers/amlogic/display/backlight/aml_bl.c
@@ -47,8 +47,6 @@
 
 /* #define AML_BACKLIGHT_DEBUG */
 static unsigned int bl_debug_print_flag;
-module_param(bl_debug_print_flag, uint, 0664);
-MODULE_PARM_DESC(bl_debug_print_flag, "bl_debug_print_flag");
 
 static enum bl_chip_type_e bl_chip_type = BL_CHIP_MAX;
 static struct aml_bl_drv_s *bl_drv;
@@ -67,16 +65,16 @@ static unsigned int bl_level_uboot;
 static unsigned int brightness_bypass;
 module_param(brightness_bypass, uint, 0664);
 MODULE_PARM_DESC(brightness_bypass, "bl_brightness_bypass");
-static unsigned int pwm_bypass;
-module_param(pwm_bypass, uint, 0664);
-MODULE_PARM_DESC(pwm_bypass, "bl_pwm_bypass");
 
-static unsigned int bl_pwm_duty_free;
-module_param(bl_pwm_duty_free, uint, 0664);
-MODULE_PARM_DESC(bl_pwm_duty_free, "bl_pwm_duty_free");
+static unsigned char bl_pwm_bypass; /* debug flag */
+static unsigned char bl_pwm_duty_free; /* debug flag */
+static unsigned char bl_on_request; /* for lcd power sequence */
+static unsigned char bl_step_on_flag;
+static unsigned int bl_on_level;
 
 static DEFINE_MUTEX(bl_power_mutex);
 static DEFINE_MUTEX(bl_level_mutex);
+static spinlock_t bl_pinmux_lock;
 
 static void bl_set_pwm_gpio_check(struct bl_pwm_config_s *bl_pwm);
 
@@ -416,11 +414,15 @@ static void bl_gpio_multiplex_set(int index, int value)
 }
 /* ****************************************************** */
 static char *bl_pinmux_str[] = {
-	"pwm_on",           /* 0 */
-	"pwm_vs_on",        /* 1 */
-	"pwm_combo_on",     /* 2 */
-	"pwm_combo_0_on",   /* 3 */
-	"pwm_combo_1_on",   /* 4 */
+	"pwm_on",               /* 0 */
+	"pwm_vs_on",            /* 1 */
+	"pwm_combo_0_1_on",     /* 2 */
+	"pwm_combo_0_vs_1_on",  /* 3 */
+	"pwm_combo_0_1_vs_on",  /* 4 */
+	"pwm_combo_0_on",       /* 5 */
+	"pwm_combo_0_vs_on",    /* 6 */
+	"pwm_combo_1_on",       /* 7 */
+	"pwm_combo_1_vs_on",    /* 8 */
 };
 
 static void bl_pwm_pinmux_gpio_set(int pwm_index, int gpio_level)
@@ -428,6 +430,11 @@ static void bl_pwm_pinmux_gpio_set(int pwm_index, int gpio_level)
 	struct bl_config_s *bconf = bl_drv->bconf;
 	struct bl_pwm_config_s *bl_pwm = NULL;
 	int index = 0xff;
+	unsigned long flags = 0;
+
+	if (bl_debug_print_flag)
+		BLPR("%s\n", __func__);
+	spin_lock_irqsave(&bl_pinmux_lock, flags);
 
 	switch (bconf->method) {
 	case BL_CTRL_PWM:
@@ -436,15 +443,21 @@ static void bl_pwm_pinmux_gpio_set(int pwm_index, int gpio_level)
 	case BL_CTRL_PWM_COMBO:
 		if (pwm_index == 0) {
 			bl_pwm = bconf->bl_pwm_combo0;
-			if (bconf->bl_pwm_combo1->pinmux_flag > 0)
-				index = 4;
-			else
+			if (bconf->bl_pwm_combo1->pinmux_flag > 0) {
+				if (bconf->bl_pwm_combo1->pwm_port == BL_PWM_VS)
+					index = 8;
+				else
+					index = 7;
+			} else
 				index = 0xff;
 		} else {
 			bl_pwm = bconf->bl_pwm_combo1;
-			if (bconf->bl_pwm_combo0->pinmux_flag > 0)
-				index = 3;
-			else
+			if (bconf->bl_pwm_combo0->pinmux_flag > 0) {
+				if (bconf->bl_pwm_combo0->pwm_port == BL_PWM_VS)
+					index = 6;
+				else
+					index = 5;
+			} else
 				index = 0xff;
 		}
 		break;
@@ -453,8 +466,10 @@ static void bl_pwm_pinmux_gpio_set(int pwm_index, int gpio_level)
 		break;
 	}
 
-	if (bl_pwm == NULL)
+	if (bl_pwm == NULL) {
+		spin_unlock_irqrestore(&bl_pinmux_lock, flags);
 		return;
+	}
 
 	if (bl_debug_print_flag) {
 		BLPR("%s: pwm_port=%d, pinmux_flag=%d(%d)\n",
@@ -465,7 +480,8 @@ static void bl_pwm_pinmux_gpio_set(int pwm_index, int gpio_level)
 		/* release pwm pinmux */
 		if (bl_debug_print_flag)
 			BLPR("release pinmux: %p\n", bconf->pin);
-		devm_pinctrl_put(bconf->pin); /* release pinmux */
+		if (!IS_ERR(bconf->pin))
+			devm_pinctrl_put(bconf->pin); /* release pinmux */
 		bl_pwm->pinmux_flag = 0;
 
 		/* request combo pinmux */
@@ -491,6 +507,8 @@ static void bl_pwm_pinmux_gpio_set(int pwm_index, int gpio_level)
 	/* set gpio */
 	if (bl_pwm->pwm_gpio < BL_GPIO_NUM_MAX)
 		bl_gpio_multiplex_set(bl_pwm->pwm_gpio, gpio_level);
+
+	spin_unlock_irqrestore(&bl_pinmux_lock, flags);
 }
 
 static void bl_pwm_pinmux_gpio_clr(unsigned int pwm_index)
@@ -498,6 +516,11 @@ static void bl_pwm_pinmux_gpio_clr(unsigned int pwm_index)
 	struct bl_config_s *bconf = bl_drv->bconf;
 	struct bl_pwm_config_s *bl_pwm = NULL;
 	int index = 0xff, release_flag = 0;
+	unsigned long flags = 0;
+
+	if (bl_debug_print_flag)
+		BLPR("%s\n", __func__);
+	spin_lock_irqsave(&bl_pinmux_lock, flags);
 
 	switch (bconf->method) {
 	case BL_CTRL_PWM:
@@ -511,21 +534,49 @@ static void bl_pwm_pinmux_gpio_clr(unsigned int pwm_index)
 	case BL_CTRL_PWM_COMBO:
 		if (pwm_index == 0) {
 			bl_pwm = bconf->bl_pwm_combo0;
-			if (bconf->bl_pwm_combo1->pinmux_flag > 0) {
-				index = 2;
-				release_flag = 1;
+			if (bconf->bl_pwm_combo0->pwm_port == BL_PWM_VS) {
+				if (bconf->bl_pwm_combo1->pinmux_flag > 0) {
+					index = 3;
+					release_flag = 1;
+				} else {
+					index = 6;
+					release_flag = 0;
+				}
 			} else {
-				index = 3;
-				release_flag = 0;
+				if (bconf->bl_pwm_combo1->pinmux_flag > 0) {
+					if (bconf->bl_pwm_combo1->pwm_port ==
+						BL_PWM_VS)
+						index = 4;
+					else
+						index = 2;
+					release_flag = 1;
+				} else {
+					index = 5;
+					release_flag = 0;
+				}
 			}
 		} else {
 			bl_pwm = bconf->bl_pwm_combo1;
-			if (bconf->bl_pwm_combo0->pinmux_flag > 0) {
-				index = 2;
-				release_flag = 1;
+			if (bconf->bl_pwm_combo1->pwm_port == BL_PWM_VS) {
+				if (bconf->bl_pwm_combo0->pinmux_flag > 0) {
+					index = 4;
+					release_flag = 1;
+				} else {
+					index = 8;
+					release_flag = 0;
+				}
 			} else {
-				index = 4;
-				release_flag = 0;
+				if (bconf->bl_pwm_combo0->pinmux_flag > 0) {
+					if (bconf->bl_pwm_combo0->pwm_port ==
+						BL_PWM_VS)
+						index = 3;
+					else
+						index = 2;
+					release_flag = 1;
+				} else {
+					index = 7;
+					release_flag = 0;
+				}
 			}
 		}
 		break;
@@ -534,16 +585,20 @@ static void bl_pwm_pinmux_gpio_clr(unsigned int pwm_index)
 		break;
 	}
 
-	if (bl_pwm == NULL)
+	if (bl_pwm == NULL) {
+		spin_unlock_irqrestore(&bl_pinmux_lock, flags);
 		return;
+	}
 
 	if (bl_debug_print_flag) {
 		BLPR("%s: pwm_port=%d, pinmux_flag=%d(%d)\n",
 			__func__, bl_pwm->pwm_port,
 			bl_pwm->pinmux_flag, bconf->pinmux_flag);
 	}
-	if (bl_pwm->pinmux_flag > 0)
+	if (bl_pwm->pinmux_flag > 0) {
+		spin_unlock_irqrestore(&bl_pinmux_lock, flags);
 		return;
+	}
 
 	/* release gpio */
 	if (bl_pwm->pwm_gpio < BL_GPIO_NUM_MAX)
@@ -553,7 +608,8 @@ static void bl_pwm_pinmux_gpio_clr(unsigned int pwm_index)
 		/* release pwm pinmux */
 		if (bl_debug_print_flag)
 			BLPR("release pinmux: %p\n", bconf->pin);
-		devm_pinctrl_put(bconf->pin); /* release pinmux */
+		if (!IS_ERR(bconf->pin))
+			devm_pinctrl_put(bconf->pin); /* release pinmux */
 	}
 
 	/* request pwm pinmux */
@@ -569,10 +625,16 @@ static void bl_pwm_pinmux_gpio_clr(unsigned int pwm_index)
 	}
 	bconf->pinmux_flag = 1;
 	bl_pwm->pinmux_flag = 1;
+
+	spin_unlock_irqrestore(&bl_pinmux_lock, flags);
 }
 
 static void bl_pwm_pinmux_ctrl(struct bl_config_s *bconf, int status)
 {
+	unsigned long flags = 0;
+
+	if (bl_debug_print_flag)
+		BLPR("%s\n", __func__);
 	if (status) {
 		/* release gpio */
 		switch (bconf->method) {
@@ -587,11 +649,13 @@ static void bl_pwm_pinmux_ctrl(struct bl_config_s *bconf, int status)
 			break;
 		}
 	} else {
+		spin_lock_irqsave(&bl_pinmux_lock, flags);
 		/* release pwm pinmux */
 		if (bconf->pinmux_flag > 0) {
 			if (bl_debug_print_flag)
 				BLPR("release pinmux: %p\n", bconf->pin);
-			devm_pinctrl_put(bconf->pin);
+			if (!IS_ERR(bconf->pin))
+				devm_pinctrl_put(bconf->pin);
 			bconf->pinmux_flag = 0;
 		}
 		switch (bconf->method) {
@@ -621,6 +685,7 @@ static void bl_pwm_pinmux_ctrl(struct bl_config_s *bconf, int status)
 		default:
 			break;
 		}
+		spin_unlock_irqrestore(&bl_pinmux_lock, flags);
 	}
 }
 
@@ -677,15 +742,11 @@ void bl_pwm_ctrl(struct bl_pwm_config_s *bl_pwm, int status)
 static void bl_power_en_ctrl(struct bl_config_s *bconf, int status)
 {
 	if (status) {
-		if (bconf->power_on_delay > 0)
-			mdelay(bconf->power_on_delay);
 		if (bconf->en_gpio < BL_GPIO_NUM_MAX)
 			bl_gpio_set(bconf->en_gpio, bconf->en_gpio_on);
 	} else {
 		if (bconf->en_gpio < BL_GPIO_NUM_MAX)
 			bl_gpio_set(bconf->en_gpio, bconf->en_gpio_off);
-		if (bconf->power_off_delay > 0)
-			mdelay(bconf->power_off_delay);
 	}
 }
 
@@ -725,20 +786,20 @@ static void bl_power_on(void)
 		break;
 	case BL_CTRL_PWM:
 		/* step 1: power on pwm */
-		if (bconf->pwm_on_delay > 0)
-			mdelay(bconf->pwm_on_delay);
 		bl_pwm_ctrl(bconf->bl_pwm, 1);
 		bl_pwm_pinmux_ctrl(bconf, 1);
+		if (bconf->pwm_on_delay > 0)
+			mdelay(bconf->pwm_on_delay);
 		/* step 2: power on enable */
 		bl_power_en_ctrl(bconf, 1);
 		break;
 	case BL_CTRL_PWM_COMBO:
 		/* step 1: power on pwm_combo */
-		if (bconf->pwm_on_delay > 0)
-			mdelay(bconf->pwm_on_delay);
 		bl_pwm_ctrl(bconf->bl_pwm_combo0, 1);
 		bl_pwm_ctrl(bconf->bl_pwm_combo1, 1);
 		bl_pwm_pinmux_ctrl(bconf, 1);
+		if (bconf->pwm_on_delay > 0)
+			mdelay(bconf->pwm_on_delay);
 		/* step 2: power on enable */
 		bl_power_en_ctrl(bconf, 1);
 		break;
@@ -825,20 +886,20 @@ static void bl_power_off(void)
 		/* step 1: power off enable */
 		bl_power_en_ctrl(bconf, 0);
 		/* step 2: power off pwm */
-		bl_pwm_ctrl(bconf->bl_pwm, 0);
-		bl_pwm_pinmux_ctrl(bconf, 0);
 		if (bconf->pwm_off_delay > 0)
 			mdelay(bconf->pwm_off_delay);
+		bl_pwm_ctrl(bconf->bl_pwm, 0);
+		bl_pwm_pinmux_ctrl(bconf, 0);
 		break;
 	case BL_CTRL_PWM_COMBO:
 		/* step 1: power off enable */
 		bl_power_en_ctrl(bconf, 0);
 		/* step 2: power off pwm_combo */
+		if (bconf->pwm_off_delay > 0)
+			mdelay(bconf->pwm_off_delay);
 		bl_pwm_ctrl(bconf->bl_pwm_combo0, 0);
 		bl_pwm_ctrl(bconf->bl_pwm_combo1, 0);
 		bl_pwm_pinmux_ctrl(bconf, 0);
-		if (bconf->pwm_off_delay > 0)
-			mdelay(bconf->pwm_off_delay);
 		break;
 #ifdef CONFIG_AML_LOCAL_DIMMING
 	case BL_CTRL_LOCAL_DIMING:
@@ -882,6 +943,9 @@ static void bl_power_off(void)
 		BLPR("invalid backlight control method\n");
 		break;
 	}
+	if (bconf->power_off_delay > 0)
+		mdelay(bconf->power_off_delay);
+
 	bl_drv->state &= ~BL_STATE_BL_ON;
 	BLPR("backlight power off\n");
 	mutex_unlock(&bl_power_mutex);
@@ -950,7 +1014,7 @@ static void bl_set_pwm(struct bl_pwm_config_s *bl_pwm)
 {
 	unsigned int pwm_hi = 0, pwm_lo = 0;
 	unsigned int port = bl_pwm->pwm_port;
-	unsigned int vs[4], ve[4], sw, n, i;
+	unsigned int vs[4], ve[4], sw, n, i, pol = 0;
 
 	if (bl_drv->state & BL_STATE_BL_ON)
 		bl_set_pwm_gpio_check(bl_pwm);
@@ -959,10 +1023,12 @@ static void bl_set_pwm(struct bl_pwm_config_s *bl_pwm)
 	case BL_PWM_POSITIVE:
 		pwm_hi = bl_pwm->pwm_level;
 		pwm_lo = bl_pwm->pwm_cnt - bl_pwm->pwm_level;
+		pol = 0;
 		break;
 	case BL_PWM_NEGATIVE:
 		pwm_lo = bl_pwm->pwm_level;
 		pwm_hi = bl_pwm->pwm_cnt - bl_pwm->pwm_level;
+		pol = 1;
 		break;
 	default:
 		BLERR("port %d: invalid pwm_method %d\n",
@@ -984,6 +1050,7 @@ static void bl_set_pwm(struct bl_pwm_config_s *bl_pwm)
 		bl_cbus_write(pwm_reg[port], (pwm_hi << 16) | pwm_lo);
 		break;
 	case BL_PWM_VS:
+		pwm_hi = bl_pwm->pwm_level;
 		memset(vs, 0xffff, sizeof(unsigned int) * 4);
 		memset(ve, 0xffff, sizeof(unsigned int) * 4);
 		n = bl_pwm->pwm_freq;
@@ -1000,7 +1067,9 @@ static void bl_set_pwm(struct bl_pwm_config_s *bl_pwm)
 					i, vs[i], i, ve[i]);
 			}
 		}
-		bl_vcbus_write(VPU_VPU_PWM_V0, (ve[0] << 16) | (vs[0]));
+		bl_vcbus_write(VPU_VPU_PWM_V0, (pol << 31) |
+				(2 << 14) | /* vsync latch */
+				(ve[0] << 16) | (vs[0]));
 		bl_vcbus_write(VPU_VPU_PWM_V1, (ve[1] << 16) | (vs[1]));
 		bl_vcbus_write(VPU_VPU_PWM_V2, (ve[2] << 16) | (vs[2]));
 		bl_vcbus_write(VPU_VPU_PWM_V3, (ve[3] << 16) | (vs[3]));
@@ -1012,12 +1081,12 @@ static void bl_set_pwm(struct bl_pwm_config_s *bl_pwm)
 
 static void bl_set_duty_pwm(struct bl_pwm_config_s *bl_pwm)
 {
-	if (pwm_bypass)
+	if (bl_pwm_bypass)
 		return;
 
 	if (bl_pwm_duty_free) {
 		if (bl_pwm->pwm_duty > 100) {
-			BLERR("pwm_duty %d%% is bigger 100%%\n",
+			BLERR("pwm_duty %d%% is bigger than 100%%\n",
 				bl_pwm->pwm_duty);
 			bl_pwm->pwm_duty = 100;
 			BLPR("reset to 100%%\n");
@@ -1036,7 +1105,8 @@ static void bl_set_duty_pwm(struct bl_pwm_config_s *bl_pwm)
 		}
 	}
 
-	bl_pwm->pwm_level = bl_pwm->pwm_cnt * bl_pwm->pwm_duty / 100;
+	bl_pwm->pwm_level =
+		(((bl_pwm->pwm_cnt * bl_pwm->pwm_duty / 10) + 5) / 10);
 	if (bl_debug_print_flag) {
 		BLPR("pwm port %d: duty=%d%%, duty_max=%d, duty_min=%d\n",
 			bl_pwm->pwm_port, bl_pwm->pwm_duty,
@@ -1052,7 +1122,7 @@ static void bl_set_level_pwm(struct bl_pwm_config_s *bl_pwm, unsigned int level)
 	unsigned int pwm_max = bl_pwm->pwm_max;
 	unsigned int pwm_min = bl_pwm->pwm_min;
 
-	if (pwm_bypass)
+	if (bl_pwm_bypass)
 		return;
 
 	level = bl_level_mapping(level);
@@ -1064,15 +1134,18 @@ static void bl_set_level_pwm(struct bl_pwm_config_s *bl_pwm, unsigned int level)
 		bl_pwm->pwm_level = ((pwm_max - pwm_min) * (level - min) /
 			(max - min)) + pwm_min;
 	}
+
+	bl_pwm->pwm_duty =
+		(((bl_pwm->pwm_level * 1000 / bl_pwm->pwm_cnt) + 5) / 10);
 	if (bl_debug_print_flag) {
 		BLPR("port %d mapping: level=%d, level_max=%d, level_min=%d\n",
 			bl_pwm->pwm_port, level, max, min);
 		BLPR("port %d: pwm_max=%d, pwm_min=%d, pwm_level=%d\n",
 			bl_pwm->pwm_port, pwm_max, pwm_min, bl_pwm->pwm_level);
+		BLPR("port %d: duty=%d%%\n",
+			bl_pwm->pwm_port, bl_pwm->pwm_duty);
 	}
 
-	bl_pwm->pwm_duty = bl_pwm->pwm_level * 100 / bl_pwm->pwm_cnt;
-
 	bl_set_pwm(bl_pwm);
 }
 
@@ -2115,11 +2188,8 @@ static int aml_bl_config_load(struct bl_config_s *bconf,
 /* ****************************************
  * lcd notify
  * **************************************** */
-static void aml_bl_delayd_on(struct work_struct *work)
+static void aml_bl_on_function(void)
 {
-	if (aml_bl_check_driver())
-		return;
-
 	/* lcd power on backlight flag */
 	bl_drv->state |= (BL_STATE_LCD_ON | BL_STATE_BL_POWER_ON);
 	BLPR("%s: bl_level=%u, state=0x%x\n",
@@ -2128,10 +2198,34 @@ static void aml_bl_delayd_on(struct work_struct *work)
 		if ((bl_drv->state & BL_STATE_BL_ON) == 0)
 			bl_power_on();
 	} else {
+		if (bl_step_on_flag) {
+			bl_on_level = bl_drv->bldev->props.brightness;
+			bl_drv->bldev->props.brightness = bl_level_uboot;
+			BLPR("bl_step_on: %d\n",
+				bl_drv->bldev->props.brightness);
+		}
 		aml_bl_update_status(bl_drv->bldev);
+		if (bl_step_on_flag) {
+			mdelay(100);
+			bl_drv->bldev->props.brightness = bl_on_level;
+			BLPR("bl_step_on: %d\n",
+				bl_drv->bldev->props.brightness);
+			aml_bl_update_status(bl_drv->bldev);
+		}
 	}
 }
 
+static void aml_bl_delayd_on(struct work_struct *work)
+{
+	if (aml_bl_check_driver())
+		return;
+
+	if (bl_on_request == 0)
+		return;
+
+	aml_bl_on_function();
+}
+
 static int aml_bl_on_notifier(struct notifier_block *nb,
 		unsigned long event, void *data)
 {
@@ -2146,6 +2240,7 @@ static int aml_bl_on_notifier(struct notifier_block *nb,
 		return NOTIFY_DONE;
 
 	bconf = bl_drv->bconf;
+	bl_on_request = 1;
 	/* lcd power on sequence control */
 	if (bconf->method < BL_CTRL_MAX) {
 		if (bl_drv->workqueue) {
@@ -2154,16 +2249,9 @@ static int aml_bl_on_notifier(struct notifier_block *nb,
 				msecs_to_jiffies(bconf->power_on_delay));
 		} else {
 			BLPR("Warning: no bl workqueue\n");
-			msleep(bconf->power_on_delay);
-			/* lcd power on backlight flag */
-			bl_drv->state |=
-				(BL_STATE_LCD_ON | BL_STATE_BL_POWER_ON);
-			if (brightness_bypass) {
-				if ((bl_drv->state & BL_STATE_BL_ON) == 0)
-					bl_power_on();
-			} else {
-				aml_bl_update_status(bl_drv->bldev);
-			}
+			if (bconf->power_on_delay)
+				msleep(bconf->power_on_delay);
+			aml_bl_on_function();
 		}
 	} else {
 		BLERR("wrong backlight control method\n");
@@ -2183,6 +2271,7 @@ static int aml_bl_off_notifier(struct notifier_block *nb,
 	if (aml_bl_check_driver())
 		return NOTIFY_DONE;
 
+	bl_on_request = 0;
 	bl_drv->state &= ~(BL_STATE_LCD_ON | BL_STATE_BL_POWER_ON);
 	if (brightness_bypass) {
 		if (bl_drv->state & BL_STATE_BL_ON)
@@ -2314,6 +2403,7 @@ static const char *bl_debug_usage_str = {
 "    echo duty <index> <pwm_duty> > pwm ; set pwm duty cycle(unit: %)\n"
 "    echo pol <index> <pwm_pol> > pwm ; set pwm polarity(unit: %)\n"
 "    cat pwm ; dump pwm state\n"
+"	 echo free <0|1> > pwm ; set bl_pwm_duty_free enable or disable\n"
 "\n"
 "    echo <0|1> > power ; backlight power ctrl\n"
 "    cat power ; print backlight power state\n"
@@ -2453,17 +2543,21 @@ static ssize_t bl_debug_pwm_show(struct class *class,
 	len = sprintf(buf, "read backlight pwm state:\n");
 	switch (bconf->method) {
 	case BL_CTRL_PWM:
+		len += sprintf(buf+len,
+			"bl_pwm_bypass:      %d\n"
+			"bl_pwm_duty_free:   %d\n",
+			bl_pwm_bypass, bl_pwm_duty_free);
 		if (bconf->bl_pwm) {
 			bl_pwm = bconf->bl_pwm;
 			len += sprintf(buf+len,
-				"pwm_index:      %d\n"
-				"pwm_method:     %d\n"
-				"pwm_port:       %d\n"
-				"pwm_freq:       %d\n"
-				"pwm_duty_max:   %d\n"
-				"pwm_duty_min:   %d\n"
-				"pwm_cnt:        %d\n"
-				"pwm_duty:       %d%%\n",
+				"pwm_index:          %d\n"
+				"pwm_method:         %d\n"
+				"pwm_port:           %d\n"
+				"pwm_freq:           %d\n"
+				"pwm_duty_max:       %d\n"
+				"pwm_duty_min:       %d\n"
+				"pwm_cnt:            %d\n"
+				"pwm_duty:           %d%%\n",
 				bl_pwm->index, bl_pwm->pwm_method,
 				bl_pwm->pwm_port, bl_pwm->pwm_freq,
 				bl_pwm->pwm_duty_max, bl_pwm->pwm_duty_min,
@@ -2477,15 +2571,15 @@ static ssize_t bl_debug_pwm_show(struct class *class,
 			case BL_PWM_F:
 				value = bl_cbus_read(pwm_reg[bl_pwm->pwm_port]);
 				len += sprintf(buf+len,
-					"pwm_reg:        0x%08x\n",
+					"pwm_reg:            0x%08x\n",
 					value);
 				break;
 			case BL_PWM_VS:
 				len += sprintf(buf+len,
-					"pwm_reg0:        0x%08x\n"
-					"pwm_reg1:        0x%08x\n"
-					"pwm_reg2:        0x%08x\n"
-					"pwm_reg3:        0x%08x\n",
+					"pwm_reg0:            0x%08x\n"
+					"pwm_reg1:            0x%08x\n"
+					"pwm_reg2:            0x%08x\n"
+					"pwm_reg3:            0x%08x\n",
 					bl_vcbus_read(VPU_VPU_PWM_V0),
 					bl_vcbus_read(VPU_VPU_PWM_V1),
 					bl_vcbus_read(VPU_VPU_PWM_V2),
@@ -2497,6 +2591,10 @@ static ssize_t bl_debug_pwm_show(struct class *class,
 		}
 		break;
 	case BL_CTRL_PWM_COMBO:
+		len += sprintf(buf+len,
+			"bl_pwm_bypass:      %d\n"
+			"bl_pwm_duty_free:   %d\n",
+			bl_pwm_bypass, bl_pwm_duty_free);
 		if (bconf->bl_pwm_combo0) {
 			bl_pwm = bconf->bl_pwm_combo0;
 			len += sprintf(buf+len,
@@ -2656,9 +2754,15 @@ static ssize_t bl_debug_pwm_store(struct class *class,
 	unsigned int index = 0, val = 0;
 
 	switch (buf[0]) {
-	case 'f': /* frequency */
-		ret = sscanf(buf, "freq %d %d", &index, &val);
-		bl_debug_pwm_set(index, val, BL_DEBUG_PWM_FREQ);
+	case 'f':
+		if (buf[3] == 'q') { /* frequency */
+			ret = sscanf(buf, "freq %d %d", &index, &val);
+			bl_debug_pwm_set(index, val, BL_DEBUG_PWM_FREQ);
+		} else if (buf[3] == 'e') { /* duty free */
+			ret = sscanf(buf, "free %d", &val);
+			bl_pwm_duty_free = (unsigned char)val;
+			BLPR("set bl_pwm_duty_free: %d\n", bl_pwm_duty_free);
+		}
 		break;
 	case 'd': /* duty */
 		ret = sscanf(buf, "duty %d %d", &index, &val);
@@ -2668,6 +2772,11 @@ static ssize_t bl_debug_pwm_store(struct class *class,
 		ret = sscanf(buf, "pol %d %d", &index, &val);
 		bl_debug_pwm_set(index, val, BL_DEBUG_PWM_POL);
 		break;
+	case 'b': /* bypass */
+		ret = sscanf(buf, "bypass %d", &val);
+		bl_pwm_bypass = (unsigned char)val;
+		BLPR("set bl_pwm_bypass: %d\n", bl_pwm_bypass);
+		break;
 	default:
 		BLERR("wrong command\n");
 		break;
@@ -2679,6 +2788,30 @@ static ssize_t bl_debug_pwm_store(struct class *class,
 	return count;
 }
 
+static ssize_t bl_debug_step_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "bl_step_on_flag: %d\n", bl_step_on_flag);
+}
+
+static ssize_t bl_debug_step_store(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret;
+	unsigned int temp = 0;
+
+	ret = sscanf(buf, "%d", &temp);
+	if (ret == 1) {
+		bl_step_on_flag = (unsigned char)temp;
+		pr_info("set bl_step_on_flag: %d\n", bl_step_on_flag);
+	} else {
+		pr_info("invalid data\n");
+		return -EINVAL;
+	}
+
+	return count;
+}
+
 static ssize_t bl_debug_power_show(struct class *class,
 		struct class_attribute *attr, char *buf)
 {
@@ -2723,6 +2856,36 @@ static ssize_t bl_debug_power_store(struct class *class,
 	return count;
 }
 
+static ssize_t bl_debug_delay_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	struct bl_config_s *bconf = bl_drv->bconf;
+
+	return sprintf(buf, "bl power delay: on=%dms, off=%dms\n",
+		bconf->power_on_delay, bconf->power_off_delay);
+}
+
+static ssize_t bl_debug_delay_store(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret;
+	unsigned int val[2];
+	struct bl_config_s *bconf = bl_drv->bconf;
+
+	ret = sscanf(buf, "%d %d", &val[0], &val[1]);
+	if (ret == 2) {
+		bconf->power_on_delay = val[0];
+		bconf->power_off_delay = val[1];
+		pr_info("set bl power_delay: on=%dms, off=%dms\n",
+			val[0], val[1]);
+	} else {
+		pr_info("invalid data\n");
+		return -EINVAL;
+	}
+
+	return count;
+}
+
 static ssize_t bl_debug_key_valid_show(struct class *class,
 		struct class_attribute *attr, char *buf)
 {
@@ -2735,16 +2898,47 @@ static ssize_t bl_debug_config_load_show(struct class *class,
 	return sprintf(buf, "%d\n", bl_config_load);
 }
 
+static ssize_t bl_debug_print_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "show bl_debug_print_flag: %d\n",
+		bl_debug_print_flag);
+}
+
+static ssize_t bl_debug_print_store(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret;
+	unsigned int temp = 0;
+
+	ret = sscanf(buf, "%d", &temp);
+	if (ret == 1) {
+		bl_debug_print_flag = temp;
+		BLPR("set bl_debug_print_flag: %u\n", bl_debug_print_flag);
+	} else {
+		pr_info("invalid data\n");
+		return -EINVAL;
+	}
+
+	return count;
+}
+
 static struct class_attribute bl_debug_class_attrs[] = {
 	__ATTR(help, S_IRUGO | S_IWUSR, bl_debug_help, NULL),
 	__ATTR(status, S_IRUGO | S_IWUSR, bl_status_read, NULL),
 	__ATTR(pwm, S_IRUGO | S_IWUSR, bl_debug_pwm_show,
 			bl_debug_pwm_store),
+	__ATTR(step_on, S_IRUGO | S_IWUSR, bl_debug_step_show,
+			bl_debug_step_store),
 	__ATTR(power, S_IRUGO | S_IWUSR, bl_debug_power_show,
 			bl_debug_power_store),
+	__ATTR(delay, S_IRUGO | S_IWUSR, bl_debug_delay_show,
+			bl_debug_delay_store),
 	__ATTR(key_valid,   S_IRUGO | S_IWUSR, bl_debug_key_valid_show, NULL),
 	__ATTR(config_load, S_IRUGO | S_IWUSR,
 		bl_debug_config_load_show, NULL),
+	__ATTR(print, S_IRUGO | S_IWUSR, bl_debug_print_show,
+			bl_debug_print_store),
 };
 
 static int aml_bl_creat_class(void)
@@ -2816,6 +3010,7 @@ static int aml_bl_probe(struct platform_device *pdev)
 	struct bl_config_s *bconf;
 	int ret;
 
+	spin_lock_init(&bl_pinmux_lock);
 #ifdef AML_BACKLIGHT_DEBUG
 	bl_debug_print_flag = 1;
 #else
@@ -2826,8 +3021,9 @@ static int aml_bl_probe(struct platform_device *pdev)
 
 	/* init backlight parameters */
 	brightness_bypass = 0;
-	pwm_bypass = 0;
+	bl_pwm_bypass = 0;
 	bl_pwm_duty_free = 0;
+	bl_step_on_flag = 1;
 
 	bl_chip_type = aml_bl_check_chip();
 	bl_drv = kzalloc(sizeof(struct aml_bl_drv_s), GFP_KERNEL);
@@ -2886,11 +3082,15 @@ static int aml_bl_probe(struct platform_device *pdev)
 	/* update bl status */
 	bl_drv->state = (BL_STATE_LCD_ON |
 			BL_STATE_BL_POWER_ON | BL_STATE_BL_ON);
+	bl_on_request = 1;
 
-	if (brightness_bypass)
+	if (brightness_bypass) {
 		aml_bl_set_level(bl_level_uboot);
-	else
+		bl_on_level = bl_level_uboot;
+	} else {
 		aml_bl_update_status(bl_drv->bldev);
+		bl_on_level = bconf->level_default;
+	}
 
 	BLPR("probe OK\n");
 	return 0;
diff --git a/drivers/amlogic/display/backlight/aml_ldim/Makefile b/drivers/amlogic/display/backlight/aml_ldim/Makefile
index fb8ca40..8793149 100644
--- a/drivers/amlogic/display/backlight/aml_ldim/Makefile
+++ b/drivers/amlogic/display/backlight/aml_ldim/Makefile
@@ -1,6 +1,6 @@
 #
 # Makefile for LDIM.
 #
-obj-$(CONFIG_AML_LOCAL_DIMMING) = aml_ldim.o ldim_dev_drv.o iw7019_bl.o iw7019_lpf.o ob3350_bl.o
+obj-$(CONFIG_AML_LOCAL_DIMMING) = aml_ldim.o ldim_dev_drv.o iw7019_bl.o iw7019_lpf.o ob3350_bl.o iw7027_bl.o
 aml_ldim-objs := ldim_drv.o ldim_func.o
 
diff --git a/drivers/amlogic/display/backlight/aml_ldim/iw7027_bl.c b/drivers/amlogic/display/backlight/aml_ldim/iw7027_bl.c
new file mode 100644
index 0000000..0e8c330
--- /dev/null
+++ b/drivers/amlogic/display/backlight/aml_ldim/iw7027_bl.c
@@ -0,0 +1,686 @@
+/*
+ * drivers/amlogic/display/backlight/aml_ldim/iw7027_bl.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/spinlock.h>
+#include <linux/irq.h>
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/amlogic/vout/aml_ldim.h>
+#include <linux/amlogic/vout/aml_bl.h>
+#include "iw7027_bl.h"
+#include "ldim_drv.h"
+#include "ldim_dev_drv.h"
+
+#define INT_VIU_VSYNC   35
+
+#define NORMAL_MSG      (0<<7)
+#define BROADCAST_MSG   (1<<7)
+#define BLOCK_DATA      (0<<6)
+#define SINGLE_DATA     (1<<6)
+#define IW7027_DEV_ADDR 1
+
+#define IW7027_REG_BRIGHTNESS_CHK  0x00
+#define IW7027_REG_BRIGHTNESS      0x01
+#define IW7027_REG_CHIPID          0x7f
+#define IW7027_CHIPID              0x28
+
+#define IW7027_POWER_ON       0
+#define IW7027_POWER_RESET    1
+static int iw7027_on_flag;
+static int iw7027_spi_op_flag;
+
+static spinlock_t iw7027_spi_lock;
+
+struct iw7027 {
+	int test_mode;
+	struct spi_device *spi;
+	int cs_hold_delay;
+	int cs_clk_delay;
+	unsigned char cmd_size;
+	unsigned char *init_data;
+	struct class cls;
+};
+struct iw7027 *bl_iw7027;
+
+static int test_brightness[] = {0xfff, 0xfff, 0xfff, 0xfff,
+				0xfff, 0xfff, 0xfff, 0xfff, 0xfff, 0xfff
+};
+
+static int iw7027_wreg(struct spi_device *spi, u8 addr, u8 val)
+{
+	u8 tbuf[3];
+	int ret;
+
+	spin_lock(&iw7027_spi_lock);
+	if (bl_iw7027->cs_hold_delay)
+		udelay(bl_iw7027->cs_hold_delay);
+	dirspi_start(spi);
+	if (bl_iw7027->cs_clk_delay)
+		udelay(bl_iw7027->cs_clk_delay);
+	tbuf[0] = NORMAL_MSG | SINGLE_DATA | IW7027_DEV_ADDR;
+	tbuf[1] = addr & 0x7f;
+	tbuf[2] = val;
+	ret = dirspi_write(spi, tbuf, 3);
+	if (bl_iw7027->cs_clk_delay)
+		udelay(bl_iw7027->cs_clk_delay);
+	dirspi_stop(spi);
+	spin_unlock(&iw7027_spi_lock);
+
+	return ret;
+}
+
+static int iw7027_rreg(struct spi_device *spi, u8 addr, u8 *val)
+{
+	u8 tbuf[3];
+	int ret;
+
+	if (addr >= 0x80)
+		iw7027_wreg(bl_iw7027->spi, 0x78, 0x80);
+	else
+		iw7027_wreg(bl_iw7027->spi, 0x78, 0x0);
+
+	spin_lock(&iw7027_spi_lock);
+	if (bl_iw7027->cs_hold_delay)
+		udelay(bl_iw7027->cs_hold_delay);
+	dirspi_start(spi);
+	if (bl_iw7027->cs_clk_delay)
+		udelay(bl_iw7027->cs_clk_delay);
+	tbuf[0] = NORMAL_MSG | SINGLE_DATA | IW7027_DEV_ADDR;
+	tbuf[1] = addr | 0x80;
+	tbuf[2] = 0;
+	ret = dirspi_write(spi, tbuf, 3);
+	ret = dirspi_read(spi, val, 1);
+	if (bl_iw7027->cs_clk_delay)
+		udelay(bl_iw7027->cs_clk_delay);
+	dirspi_stop(spi);
+
+	spin_unlock(&iw7027_spi_lock);
+
+	return ret;
+}
+
+static int iw7027_wregs(struct spi_device *spi, u8 addr, u8 *val, int len)
+{
+	u8 tbuf[30];
+	int ret;
+
+	spin_lock(&iw7027_spi_lock);
+	if (bl_iw7027->cs_hold_delay)
+		udelay(bl_iw7027->cs_hold_delay);
+	dirspi_start(spi);
+	if (bl_iw7027->cs_clk_delay)
+		udelay(bl_iw7027->cs_clk_delay);
+	tbuf[0] = NORMAL_MSG | BLOCK_DATA | IW7027_DEV_ADDR;
+	tbuf[1] = len;
+	tbuf[2] = addr & 0x7f;
+	memcpy(&tbuf[3], val, len);
+	ret = dirspi_write(spi, tbuf, len+3);
+	if (bl_iw7027->cs_clk_delay)
+		udelay(bl_iw7027->cs_clk_delay);
+	dirspi_stop(spi);
+	spin_unlock(&iw7027_spi_lock);
+
+	return ret;
+}
+
+static int iw7027_power_on_init(int flag)
+{
+	unsigned char addr, val;
+	int i, ret = 0;
+
+	LDIMPR("%s: spi_op_flag=%d\n", __func__, iw7027_spi_op_flag);
+
+	if (flag == IW7027_POWER_RESET)
+		goto iw7027_power_reset_p;
+	i = 1000;
+	while ((iw7027_spi_op_flag) && (i > 0)) {
+		i--;
+		udelay(10);
+	}
+	if (iw7027_spi_op_flag == 1) {
+		LDIMERR("%s: wait spi idle state failed\n", __func__);
+		return 0;
+	}
+
+	iw7027_spi_op_flag = 1;
+iw7027_power_reset_p:
+
+	for (i = 0; i < LDIM_SPI_INIT_ON_SIZE; i += bl_iw7027->cmd_size) {
+		if (bl_iw7027->init_data[i] == 0xff) {
+			if (bl_iw7027->init_data[i+3] > 0)
+				mdelay(bl_iw7027->init_data[i+3]);
+			break;
+		} else if (bl_iw7027->init_data[i] == 0x0) {
+			addr = bl_iw7027->init_data[i+1];
+			val = bl_iw7027->init_data[i+2];
+			ret = iw7027_wreg(bl_iw7027->spi, addr, val);
+			udelay(1);
+		}
+		if (bl_iw7027->init_data[i+3] > 0)
+			mdelay(bl_iw7027->init_data[i+3]);
+	}
+
+	if (flag == IW7027_POWER_RESET)
+		return ret;
+
+	iw7027_spi_op_flag = 0;
+	return ret;
+}
+
+static int iw7027_hw_init_on(void)
+{
+	int i, j;
+	unsigned char temp, reg_chk, reg_duty_chk;
+
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+
+	ldim_gpio_set(ldim_drv->ldev_conf->en_gpio,
+		ldim_drv->ldev_conf->en_gpio_on);
+	mdelay(2);
+
+	iw7027_wreg(bl_iw7027->spi, 0x00, 0x06);
+
+	ldim_set_duty_pwm(&(ldim_drv->ldev_conf->pwm_config));
+	ldim_drv->pinmux_ctrl(ldim_drv->ldev_conf->pinmux_name, 1);
+	mdelay(100);
+
+	iw7027_rreg(bl_iw7027->spi, 0x00, &reg_chk);
+	for (i = 1; i < 10; i++) {
+		iw7027_rreg(bl_iw7027->spi, 0x00, &temp);
+		if (temp != reg_chk)
+			goto iw7027_smr_end;
+		}
+
+	iw7027_power_on_init(IW7027_POWER_ON);
+	mdelay(500);
+	iw7027_wreg(bl_iw7027->spi, 0x00, 0x07);
+	iw7027_rreg(bl_iw7027->spi, 0xb3, &reg_duty_chk);
+	if (reg_duty_chk == 0x05) {
+		for (j = 0; j < 20; j++)
+			iw7027_wreg(bl_iw7027->spi, (0x40 + j), 0x1f);
+		}
+
+iw7027_smr_end:
+	iw7027_spi_op_flag = 0;
+
+	return 0;
+}
+
+static int iw7027_hw_init_off(void)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+	int i = 1000;
+
+	while ((iw7027_spi_op_flag) && (i > 0)) {
+		i--;
+		udelay(10);
+	}
+	if (iw7027_spi_op_flag == 1)
+		LDIMERR("%s: wait spi idle state failed\n", __func__);
+
+	ldim_drv->pinmux_ctrl(ldim_drv->ldev_conf->pinmux_name, 0);
+	ldim_gpio_set(ldim_drv->ldev_conf->en_gpio,
+		ldim_drv->ldev_conf->en_gpio_off);
+
+	return 0;
+}
+
+static int iw7027_spi_dump_low(char *buf)
+{
+	int ret = 0;
+	unsigned int i;
+	unsigned char val;
+
+	for (i = 0; i <= 0x7f; i++) {
+		iw7027_rreg(bl_iw7027->spi, i, &val);
+		if (buf) {
+			int n = sprintf(buf+ret,
+					"iw7027 reg 0x%02x=0x%02x\n", i, val);
+			ret += n;
+		}
+		pr_info("iw7027 reg 0x%02x=0x%02x\n", i, val);
+	}
+	if (buf)
+		ret += sprintf(buf, "\n");
+	pr_info("\n");
+
+	return ret;
+}
+
+static int iw7027_spi_dump_high(char *buf)
+{
+	int ret = 0;
+	unsigned int i;
+	unsigned char val;
+
+	for (i = 0x80; i <= 0xff; i++) {
+		iw7027_rreg(bl_iw7027->spi, i, &val);
+		if (buf) {
+			int n = sprintf(buf+ret,
+					"iw7027 reg 0x%02x=0x%02x\n", i, val);
+			ret += n;
+		}
+		pr_info("iw7027 reg 0x%02x=0x%02x\n", i, val);
+	}
+	if (buf)
+		ret += sprintf(buf, "\n");
+	pr_info("\n");
+
+	return ret;
+}
+
+static unsigned int iw7027_get_value(unsigned int level)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+	unsigned int val;
+	unsigned int dim_max, dim_min;
+
+	dim_max = ldim_drv->ldev_conf->dim_max;
+	dim_min = ldim_drv->ldev_conf->dim_min;
+
+	val = dim_min + ((level * (dim_max - dim_min)) / LD_DATA_MAX);
+
+	return val;
+}
+
+static int iw7027_smr(unsigned short *buf, unsigned char len)
+{
+	int i, j;
+	unsigned int value_flag = 0;
+	unsigned char val_0[20];
+
+	if (iw7027_on_flag == 0) {
+		if (ldim_debug_print)
+			LDIMPR("%s: on_flag=%d\n", __func__, iw7027_on_flag);
+		return 0;
+	}
+	if (len != 10) {
+		LDIMERR("%s: data len %d invalid\n", __func__, len);
+		return -1;
+	}
+	if (iw7027_spi_op_flag) {
+		if (ldim_debug_print) {
+			LDIMPR("%s: spi_op_flag=%d\n",
+				__func__, iw7027_spi_op_flag);
+		}
+		return 0;
+	}
+
+	iw7027_spi_op_flag = 1;
+
+	for (i = 0; i < 10; i++)
+		value_flag = value_flag || buf[i];
+
+	if (value_flag) {
+		if (bl_iw7027->test_mode) {
+			val_0[0] = (test_brightness[0] & 0xf00) >> 8;
+			val_0[1] = test_brightness[0] & 0xff;
+			val_0[2] = (test_brightness[1] & 0xf00) >> 8;
+			val_0[3] = test_brightness[1] & 0xff;
+			val_0[4] = (test_brightness[2] & 0xf00) >> 8;
+			val_0[5] = test_brightness[2] & 0xff;
+			val_0[6] = (test_brightness[3] & 0xf00) >> 8;
+			val_0[7] = test_brightness[3] & 0xff;
+			val_0[8] = (test_brightness[4] & 0xf00) >> 8;
+			val_0[9] = test_brightness[4] & 0xff;
+			val_0[10] = (test_brightness[5] & 0xf00) >> 8;
+			val_0[11] = test_brightness[5] & 0xff;
+			val_0[12] = (test_brightness[6] & 0xf00) >> 8;
+			val_0[13] = test_brightness[6] & 0xff;
+			val_0[14] = (test_brightness[7] & 0xf00) >> 8;
+			val_0[15] = test_brightness[7] & 0xff;
+			val_0[16] = (test_brightness[8] & 0xf00) >> 8;
+			val_0[17] = test_brightness[8] & 0xff;
+			val_0[18] = (test_brightness[9] & 0xf00) >> 8;
+			val_0[19] = test_brightness[9] & 0xff;
+
+			iw7027_wregs(bl_iw7027->spi, 0x40, val_0, 20);
+		} else {
+			val_0[0] = ((iw7027_get_value(buf[0])
+				) & 0xf00) >> 8;
+			val_0[1] = (iw7027_get_value(buf[0])
+				) & 0xff;
+			val_0[2] = ((iw7027_get_value(buf[1])
+				) & 0xf00) >> 8;
+			val_0[3] = (iw7027_get_value(buf[1])
+				) & 0xff;
+			val_0[4] = ((iw7027_get_value(buf[2])
+				) & 0xf00) >> 8;
+			val_0[5] = (iw7027_get_value(buf[2])
+				) & 0xff;
+			val_0[6] = ((iw7027_get_value(buf[3])
+				) & 0xf00) >> 8;
+			val_0[7] = (iw7027_get_value(buf[3])
+				) & 0xff;
+			val_0[8] = ((iw7027_get_value(buf[4])
+				) & 0xf00) >> 8;
+			val_0[9] = (iw7027_get_value(buf[4])
+				) & 0xff;
+			val_0[10] = ((iw7027_get_value(buf[5])
+				) & 0xf00) >> 8;
+			val_0[11] = (iw7027_get_value(buf[5])
+				) & 0xff;
+			val_0[12] = ((iw7027_get_value(buf[6])
+				) & 0xf00) >> 8;
+			val_0[13] = (iw7027_get_value(buf[6])
+				) & 0xff;
+			val_0[14] = ((iw7027_get_value(buf[7])
+				) & 0xf00) >> 8;
+			val_0[15] = (iw7027_get_value(buf[7])
+				) & 0xff;
+			val_0[16] = ((iw7027_get_value(buf[8])
+				) & 0xf00) >> 8;
+			val_0[17] = (iw7027_get_value(buf[8])
+				) & 0xff;
+			val_0[18] = ((iw7027_get_value(buf[9])
+				) & 0xf00) >> 8;
+			val_0[19] = (iw7027_get_value(buf[9])
+				) & 0xff;
+
+			iw7027_wregs(bl_iw7027->spi, 0x40, val_0, 20);
+		}
+	} else {
+		for (j = 0; j < 20; j++)
+			val_0[j] = 0;
+			iw7027_wregs(bl_iw7027->spi, 0x40, val_0, 20);
+	}
+
+	iw7027_spi_op_flag = 0;
+	return 0;
+}
+
+static int iw7027_power_on(void)
+{
+	if (iw7027_on_flag) {
+		LDIMPR("%s: iw7027 is already on, exit\n", __func__);
+		return 0;
+	}
+	iw7027_hw_init_on();
+	iw7027_on_flag = 1;
+
+	LDIMPR("%s: ok\n", __func__);
+	return 0;
+}
+
+static int iw7027_power_off(void)
+{
+	iw7027_on_flag = 0;
+	iw7027_hw_init_off();
+
+	LDIMPR("%s: ok\n", __func__);
+	return 0;
+}
+
+static ssize_t iw7027_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+	struct iw7027 *bl = container_of(class, struct iw7027, cls);
+	int ret = 0;
+	int i;
+
+	if (!strcmp(attr->attr.name, "mode")) {
+		ret = sprintf(buf, "0x%02x\n", bl->spi->mode);
+	} else if (!strcmp(attr->attr.name, "speed")) {
+		ret = sprintf(buf, "%d\n", bl->spi->max_speed_hz);
+	} else if (!strcmp(attr->attr.name, "test")) {
+		ret = sprintf(buf, "test mode=%d\n", bl->test_mode);
+	} else if (!strcmp(attr->attr.name, "brightness")) {
+		ret = sprintf(buf, "0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x,0x%x\n",
+				test_brightness[0],
+				test_brightness[1],
+				test_brightness[2],
+				test_brightness[3],
+				test_brightness[4],
+				test_brightness[5],
+				test_brightness[6],
+				test_brightness[7]);
+	} else if (!strcmp(attr->attr.name, "status")) {
+		ret = sprintf(buf, "iw7027 status:\n"
+				"dev_index      = %d\n"
+				"on_flag        = %d\n"
+				"en_on          = %d\n"
+				"en_off         = %d\n"
+				"cs_hold_delay  = %d\n"
+				"cs_clk_delay   = %d\n"
+				"spi_op_flag    = %d\n"
+				"dim_max        = 0x%03x\n"
+				"dim_min        = 0x%03x\n",
+				ldim_drv->dev_index, iw7027_on_flag,
+				ldim_drv->ldev_conf->en_gpio_on,
+				ldim_drv->ldev_conf->en_gpio_off,
+				ldim_drv->ldev_conf->cs_hold_delay,
+				ldim_drv->ldev_conf->cs_clk_delay,
+				iw7027_spi_op_flag,
+				ldim_drv->ldev_conf->dim_max,
+				ldim_drv->ldev_conf->dim_min);
+	} else if (!strcmp(attr->attr.name, "dump_low")) {
+		i = 1000;
+		while ((iw7027_spi_op_flag) && (i > 0)) {
+			i--;
+			udelay(10);
+		}
+		if (iw7027_spi_op_flag == 0) {
+			iw7027_spi_op_flag = 1;
+			ret = iw7027_spi_dump_low(buf);
+			iw7027_spi_op_flag = 0;
+		} else {
+			LDIMERR("%s: wait spi idle state failed\n", __func__);
+		}
+		ret += sprintf(buf, "\n");
+	} else if (!strcmp(attr->attr.name, "dump_high")) {
+		i = 1000;
+		while ((iw7027_spi_op_flag) && (i > 0)) {
+			i--;
+			udelay(10);
+		}
+		if (iw7027_spi_op_flag == 0) {
+			iw7027_spi_op_flag = 1;
+			ret = iw7027_spi_dump_high(buf);
+			iw7027_spi_op_flag = 0;
+		} else {
+			LDIMERR("%s: wait spi idle state failed\n", __func__);
+		}
+		ret += sprintf(buf, "\n");
+	}
+
+	return ret;
+}
+
+#define MAX_ARG_NUM 3
+static ssize_t iw7027_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t count)
+{
+	struct iw7027 *bl = container_of(class, struct iw7027, cls);
+	unsigned int val, val2;
+	unsigned char reg_addr, reg_val;
+	int i;
+
+	if (!strcmp(attr->attr.name, "init")) {
+		iw7027_hw_init_on();
+	} else if (!strcmp(attr->attr.name, "mode")) {
+		i = sscanf(buf, "%d", &val);
+		if (i == 1)
+			bl->spi->mode = val;
+		else
+			LDIMERR("%s: invalid args\n", __func__);
+	} else if (!strcmp(attr->attr.name, "speed")) {
+		i = sscanf(buf, "%d", &val);
+		if (i == 1)
+			bl->spi->max_speed_hz = val*1000;
+		else
+			LDIMERR("%s: invalid args\n", __func__);
+	} else if (!strcmp(attr->attr.name, "reg")) {
+		if (buf[0] == 'w') {
+			i = sscanf(buf, "w %x %x", &val, &val2);
+			if (i == 2) {
+				reg_addr = (unsigned char)val;
+				reg_val = (unsigned char)val2;
+				iw7027_wreg(bl->spi, reg_addr, reg_val);
+			} else {
+				LDIMERR("%s: invalid args\n", __func__);
+			}
+		} else if (buf[0] == 'r') {
+			i = sscanf(buf, "r %x", &val);
+			if (i == 1) {
+				reg_addr = (unsigned char)val;
+				iw7027_rreg(bl->spi, reg_addr, &reg_val);
+				pr_info("reg 0x%02x = 0x%02x\n",
+					reg_addr, reg_val);
+			} else {
+				LDIMERR("%s: invalid args\n", __func__);
+			}
+		}
+	} else if (!strcmp(attr->attr.name, "test")) {
+		i = sscanf(buf, "%d", &val);
+		LDIMPR("set test mode to %d\n", val);
+		bl->test_mode = val;
+	} else if (!strcmp(attr->attr.name, "brightness")) {
+		i = sscanf(buf, "%d %d", &val, &val2);
+		val &= 0xfff;
+		LDIMPR("brightness=%d, index=%d\n", val, val2);
+		if ((i == 2) && (val2 < ARRAY_SIZE(test_brightness)))
+			test_brightness[val2] = val;
+	} else
+		LDIMERR("LDIM argment error!\n");
+	return count;
+}
+
+static struct class_attribute iw7027_class_attrs[] = {
+	__ATTR(init, S_IRUGO | S_IWUSR, iw7027_show, iw7027_store),
+	__ATTR(mode, S_IRUGO | S_IWUSR, iw7027_show, iw7027_store),
+	__ATTR(speed, S_IRUGO | S_IWUSR, iw7027_show, iw7027_store),
+	__ATTR(reg, S_IRUGO | S_IWUSR, iw7027_show, iw7027_store),
+	__ATTR(test, S_IRUGO | S_IWUSR, iw7027_show, iw7027_store),
+	__ATTR(brightness, S_IRUGO | S_IWUSR, iw7027_show, iw7027_store),
+	__ATTR(status, S_IRUGO | S_IWUSR, iw7027_show, NULL),
+	__ATTR(dump_low, S_IRUGO | S_IWUSR, iw7027_show, NULL),
+	__ATTR(dump_high, S_IRUGO | S_IWUSR, iw7027_show, NULL),
+	__ATTR_NULL
+};
+
+static int iw7027_ldim_driver_update(void)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+
+	ldim_drv->device_power_on = iw7027_power_on;
+	ldim_drv->device_power_off = iw7027_power_off;
+	ldim_drv->device_bri_update = iw7027_smr;
+	return 0;
+}
+
+static int ldim_spi_dev_probe(struct spi_device *spi)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+	int ret;
+
+	ldim_drv->spi = spi;
+
+	dev_set_drvdata(&spi->dev, ldim_drv->ldev_conf);
+	spi->bits_per_word = 8;
+	ret = spi_setup(spi);
+	if (ret)
+		LDIMERR("spi setup failed\n");
+
+	/* LDIMPR("%s ok\n", __func__); */
+	return ret;
+}
+
+static int ldim_spi_dev_remove(struct spi_device *spi)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+
+	ldim_drv->spi = NULL;
+	return 0;
+}
+
+static struct spi_driver ldim_spi_dev_driver = {
+	.probe = ldim_spi_dev_probe,
+	.remove = ldim_spi_dev_remove,
+	.driver = {
+		.name = "ldim_dev",
+		.owner = THIS_MODULE,
+	},
+};
+
+int ldim_dev_iw7027_probe(void)
+{
+	struct aml_ldim_driver_s *ldim_drv = aml_ldim_get_driver();
+	int ret;
+
+	iw7027_on_flag = 0;
+	iw7027_spi_op_flag = 0;
+	spin_lock_init(&iw7027_spi_lock);
+
+	bl_iw7027 = kzalloc(sizeof(struct iw7027), GFP_KERNEL);
+	if (bl_iw7027 == NULL) {
+		pr_err("malloc bl_iw7027 failed\n");
+		return -1;
+	}
+
+	spi_register_board_info(ldim_drv->spi_dev, 1);
+	ret = spi_register_driver(&ldim_spi_dev_driver);
+	if (ret) {
+		LDIMERR("register ldim_dev spi driver failed\n");
+		return -1;
+	}
+
+	bl_iw7027->test_mode = 0;
+	bl_iw7027->spi = ldim_drv->spi;
+	bl_iw7027->cs_hold_delay = ldim_drv->ldev_conf->cs_hold_delay;
+	bl_iw7027->cs_clk_delay = ldim_drv->ldev_conf->cs_clk_delay;
+	bl_iw7027->cmd_size = ldim_drv->ldev_conf->cmd_size;
+	bl_iw7027->init_data = ldim_drv->ldev_conf->init_on;
+
+	iw7027_ldim_driver_update();
+
+	bl_iw7027->cls.name = kzalloc(10, GFP_KERNEL);
+	sprintf((char *)bl_iw7027->cls.name, "iw7027");
+	bl_iw7027->cls.class_attrs = iw7027_class_attrs;
+	ret = class_register(&bl_iw7027->cls);
+	if (ret < 0)
+		pr_err("register iw7027 class failed\n");
+
+
+	iw7027_on_flag = 1; /* default enable in uboot */
+
+	/* LDIMPR("%s ok\n", __func__); */
+	return ret;
+}
+
+int ldim_dev_iw7027_remove(void)
+{
+	spi_unregister_driver(&ldim_spi_dev_driver);
+	kfree(bl_iw7027);
+	bl_iw7027 = NULL;
+
+	return 0;
+}
+
diff --git a/drivers/amlogic/display/backlight/aml_ldim/iw7027_bl.h b/drivers/amlogic/display/backlight/aml_ldim/iw7027_bl.h
new file mode 100644
index 0000000..8bc5582
--- /dev/null
+++ b/drivers/amlogic/display/backlight/aml_ldim/iw7027_bl.h
@@ -0,0 +1,115 @@
+/*
+ * drivers/amlogic/display/backlight/aml_ldim/iw7027_bl.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef __IW7027_HW_H
+#define __IW7027_HW_H
+
+#define CHECK_INIT_DONE_MAX_COUNT	10
+
+#define BRIGHTNESS_2D			0x7FF
+#define BRIGHTNESS_3D			0x333
+
+#define BRIGHTNESS_2D_MAX		0xFFF
+#define BRIGHTNESS_3D_MAX		0x500
+
+/* skyworht 39" */
+#define ISET_VALUE_2D_SKY39		0xB43C
+#define ISET_VALUE_3D_SKY39		0xB4B4
+#define VDAC_VALUE_2D_SKY39		0xE5
+#define VDAC_VALUE_3D_SKY39		0x85
+
+#define VDAC_MIN_2D_SKY39		0xB0
+#define VDAC_MAX_2D_SKY39		0xF1
+#define VDAC_MIN_3D_SKY39		0x00
+#define VDAC_MAX_3D_SKY39		0x96
+
+/* skyworht 42" */
+#define ISET_VALUE_2D_SKY42		0xA537
+#define ISET_VALUE_3D_SKY42		0xA5A5
+#define VDAC_VALUE_2D_SKY42		0xE6
+#define VDAC_VALUE_3D_SKY42		0x84
+
+#define VDAC_MIN_2D_SKY42		0xB3
+#define VDAC_MAX_2D_SKY42		0xF4
+#define VDAC_MIN_3D_SKY42		0x3A
+#define VDAC_MAX_3D_SKY42		0x97
+
+/* skyworht 50" */
+#define ISET_VALUE_2D_SKY50		0xB43C
+#define ISET_VALUE_3D_SKY50		0xB4B4
+#define VDAC_VALUE_2D_SKY50		0xE1
+#define VDAC_VALUE_3D_SKY50		0x77
+
+#define VDAC_MIN_2D_SKY50		0xC0
+#define VDAC_MAX_2D_SKY50		0xF5
+#define VDAC_MIN_3D_SKY50		0x47
+#define VDAC_MAX_3D_SKY50		0xA3
+
+#define EEPROM_ADDR_VDAC_2D		3504	/* 0xDB0 */
+#define EEPROM_ADDR_VDAC_3D		3506	/* 0xDB2 */
+
+#define VSYNC_CNT_2D_3D			64
+#define VSYNC_CNT_3D_2D			64
+#define VSYNC_CNT_SET_BRI_ZERO		49
+#define VSYNC_CNT_RAMP			45
+#define VSYNC_CNT_SET_BRI_2D		15
+#define VSYNC_CNT_SET_BRI_3D		15
+#define VSYNC_CNT_WAIT_EN_PROT		0
+
+/* scan timing parameters for 42"*/
+#define DEFAULT_TD0_2D		333 /* 0.333ms */
+#define DEFAULT_DG1_2D		720 /* 0.720ms */
+#define DEFAULT_DELTAT_2D	790 /* 0.790ms */
+
+#define DEFAULT_TD0_3D		333 /* 0.333ms */
+#define DEFAULT_DG1_3D		720 /* 0.720ms */
+#define DEFAULT_DELTAT_3D	790 /* 0.790ms */
+
+/* scan timing parameters for 39"*/
+#define DEFAULT_TD0_2D_SKY39		333  /* 0.333ms */
+#define DEFAULT_DG1_2D_SKY39		700  /* 0.700ms */
+#define DEFAULT_DELTAT_2D_SKY39		1104 /* 1.104ms */
+
+#define DEFAULT_TD0_3D_SKY39		333  /* 0.333ms */
+#define DEFAULT_DG1_3D_SKY39		700  /* 0.700ms */
+#define DEFAULT_DELTAT_3D_SKY39		1104 /* 1.104ms */
+
+/* scan timing parameters for 50"*/
+#define DEFAULT_TD0_2D_SKY50		333  /* 0.333ms */
+#define DEFAULT_DG1_2D_SKY50		720  /* 0.720ms */
+#define DEFAULT_DELTAT_2D_SKY50		790  /* 1.120ms */
+
+#define DEFAULT_TD0_3D_SKY50		333  /* 0.333ms */
+#define DEFAULT_DG1_3D_SKY50		720  /* 0.720ms */
+#define DEFAULT_DELTAT_3D_SKY50		790  /* 1.120ms */
+
+#define EEPROM_ADDR_PANEL	3463
+
+struct iwatt_reg_map {
+	u16 addr;
+	u16 val_2d;
+	u16 val_3d;
+};
+
+extern int  dirspi_write(struct spi_device *spi, u8 *buf, int len);
+extern int  dirspi_read(struct spi_device *spi, u8 *buf, int len);
+extern void dirspi_start(struct spi_device *spi);
+extern void dirspi_stop(struct spi_device *spi);
+#endif /* __IW7027_HW_H */
+
+
+
diff --git a/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.c b/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.c
index 939bf19e..ac5560a 100644
--- a/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.c
+++ b/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.c
@@ -686,6 +686,9 @@ static int ldim_dev_add_driver(struct ldim_dev_config_s *ldev_conf, int index)
 	if (strcmp(ldev_conf->name, "iw7019") == 0) {
 		ret = ldim_dev_iw7019_probe();
 		goto ldim_dev_add_driver_next;
+	} else if (strcmp(ldev_conf->name, "iw7027") == 0) {
+		ret = ldim_dev_iw7027_probe();
+		goto ldim_dev_add_driver_next;
 	} else if (strcmp(ldev_conf->name, "ob3350") == 0) {
 		ret = ldim_dev_ob3350_probe();
 		goto ldim_dev_add_driver_next;
@@ -713,6 +716,9 @@ static int ldim_dev_remove_driver(struct ldim_dev_config_s *ldev_conf,
 	if (strcmp(ldev_conf->name, "iw7019") == 0) {
 		ret = ldim_dev_iw7019_remove();
 		goto ldim_dev_remove_driver_next;
+	} else if (strcmp(ldev_conf->name, "iw7027") == 0) {
+		ret = ldim_dev_iw7027_remove();
+		goto ldim_dev_remove_driver_next;
 	} else if (strcmp(ldev_conf->name, "ob3350") == 0) {
 		ret = ldim_dev_ob3350_remove();
 		goto ldim_dev_remove_driver_next;
diff --git a/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.h b/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.h
index e556d0f..55c0225 100644
--- a/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.h
+++ b/drivers/amlogic/display/backlight/aml_ldim/ldim_dev_drv.h
@@ -25,6 +25,8 @@ extern int ldim_dev_iw7019_probe(void);
 extern int ldim_dev_iw7019_remove(void);
 extern int ldim_dev_ob3350_probe(void);
 extern int ldim_dev_ob3350_remove(void);
+extern int ldim_dev_iw7027_probe(void);
+extern int ldim_dev_iw7027_remove(void);
 extern void ldim_set_duty_pwm(struct bl_pwm_config_s *ld_pwm);
 
 
diff --git a/drivers/amlogic/display/ge2d/Kconfig b/drivers/amlogic/display/ge2d/Kconfig
index 4869c92..8abf1a1 100644
--- a/drivers/amlogic/display/ge2d/Kconfig
+++ b/drivers/amlogic/display/ge2d/Kconfig
@@ -1,8 +1,16 @@
 #
 # GE2D Module
 #
+menu "Amlogic GE2D Module"
 config  AM_GE2D
 	boolean "Amlogic GE2D Module"
 	default n
 	help
 		Select to enable GE2D graphic 2D engine.
+config	AM_GE2D_MORE_SECURITY
+	boolean "Amlogic GE2D not use physical addr"
+	default n
+	depends on AM_GE2D
+	help
+		Select to enable GE2D not use physical addr.
+endmenu
diff --git a/drivers/amlogic/display/ge2d/Makefile b/drivers/amlogic/display/ge2d/Makefile
index 44a8758..3cb04fa 100644
--- a/drivers/amlogic/display/ge2d/Makefile
+++ b/drivers/amlogic/display/ge2d/Makefile
@@ -9,3 +9,6 @@ ge2d-objs = bitblt.o \
 
 obj-$(CONFIG_AM_GE2D) += ge2d.o
 ccflags-y += -Iinclude/linux/ge2d/
+ccflags-y += -Idrivers/amlogic/display/osd/
+ccflags-y += -I$(srctree)/drivers/staging/android
+ccflags-y += -Idrivers/amlogic/ion_dev/
diff --git a/drivers/amlogic/display/ge2d/blend.c b/drivers/amlogic/display/ge2d/blend.c
index 93a8516..d21d4a7 100644
--- a/drivers/amlogic/display/ge2d/blend.c
+++ b/drivers/amlogic/display/ge2d/blend.c
@@ -144,3 +144,121 @@ void blend_noblk(struct ge2d_context_s *wq,
 	ge2d_wq_add_work(wq);
 }
 EXPORT_SYMBOL(blend_noblk);
+
+
+void blend_noalpha(struct ge2d_context_s *wq,
+	   int src_x, int src_y, int src_w, int src_h,
+	   int src2_x, int src2_y, int src2_w, int src2_h,
+	   int dst_x, int dst_y, int dst_w, int dst_h,
+	   int op)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+	ge2d_cmd_cfg->src1_x_start = src_x;
+	ge2d_cmd_cfg->src1_x_end   = src_x + src_w - 1;
+	ge2d_cmd_cfg->src1_y_start = src_y;
+	ge2d_cmd_cfg->src1_y_end   = src_y + src_h - 1;
+
+	ge2d_cmd_cfg->src2_x_start = src2_x;
+	ge2d_cmd_cfg->src2_x_end   = src2_x + src2_w - 1;
+	ge2d_cmd_cfg->src2_y_start = src2_y;
+	ge2d_cmd_cfg->src2_y_end   = src2_y + src2_h - 1;
+
+	ge2d_cmd_cfg->dst_x_start  = dst_x;
+	ge2d_cmd_cfg->dst_x_end    = dst_x + dst_w - 1;
+	ge2d_cmd_cfg->dst_y_start  = dst_y;
+	ge2d_cmd_cfg->dst_y_end    = dst_y + dst_h - 1;
+
+	/* if ((dst_w != src_w) || (dst_h != src_h)) { */
+	if (1) {
+		ge2d_cmd_cfg->sc_hsc_en = 1;
+		ge2d_cmd_cfg->sc_vsc_en = 1;
+		ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
+		ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
+		ge2d_cmd_cfg->hsc_div_en = 1;
+	} else {
+		ge2d_cmd_cfg->sc_hsc_en = 0;
+		ge2d_cmd_cfg->sc_vsc_en = 0;
+		ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
+		ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
+		ge2d_cmd_cfg->hsc_div_en = 0;
+	}
+
+	ge2d_cmd_cfg->color_blend_mode = (op >> 24) & 0xff;
+	ge2d_cmd_cfg->color_src_blend_factor = (op >> 20) & 0xf;
+	ge2d_cmd_cfg->color_dst_blend_factor = (op >> 16) & 0xf;
+	ge2d_cmd_cfg->alpha_src_blend_factor = (op >>  4) & 0xf;
+	ge2d_cmd_cfg->alpha_dst_blend_factor = (op >>  0) & 0xf;
+
+	if (ge2d_cmd_cfg->color_blend_mode >= BLENDOP_LOGIC) {
+		ge2d_cmd_cfg->color_logic_op =
+			ge2d_cmd_cfg->color_blend_mode - BLENDOP_LOGIC;
+		ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+	}
+	ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_SET;
+
+	ge2d_cmd_cfg->wait_done_flag   = 1;
+
+	ge2d_wq_add_work(wq);
+}
+EXPORT_SYMBOL(blend_noalpha);
+
+
+void blend_noalpha_noblk(struct ge2d_context_s *wq,
+	   int src_x, int src_y, int src_w, int src_h,
+	   int src2_x, int src2_y, int src2_w, int src2_h,
+	   int dst_x, int dst_y, int dst_w, int dst_h,
+	   int op)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+	ge2d_cmd_cfg->src1_x_start = src_x;
+	ge2d_cmd_cfg->src1_x_end   = src_x + src_w - 1;
+	ge2d_cmd_cfg->src1_y_start = src_y;
+	ge2d_cmd_cfg->src1_y_end   = src_y + src_h - 1;
+
+	ge2d_cmd_cfg->src2_x_start = src2_x;
+	ge2d_cmd_cfg->src2_x_end   = src2_x + src2_w - 1;
+	ge2d_cmd_cfg->src2_y_start = src2_y;
+	ge2d_cmd_cfg->src2_y_end   = src2_y + src2_h - 1;
+
+	ge2d_cmd_cfg->dst_x_start  = dst_x;
+	ge2d_cmd_cfg->dst_x_end    = dst_x + dst_w - 1;
+	ge2d_cmd_cfg->dst_y_start  = dst_y;
+	ge2d_cmd_cfg->dst_y_end    = dst_y + dst_h - 1;
+
+	/* if ((dst_w != src_w) || (dst_h != src_h)) { */
+	if (1) {
+		ge2d_cmd_cfg->sc_hsc_en = 1;
+		ge2d_cmd_cfg->sc_vsc_en = 1;
+		ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
+		ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
+		ge2d_cmd_cfg->hsc_div_en = 1;
+	} else {
+		ge2d_cmd_cfg->sc_hsc_en = 0;
+		ge2d_cmd_cfg->sc_vsc_en = 0;
+		ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
+		ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
+		ge2d_cmd_cfg->hsc_div_en = 0;
+	}
+
+	ge2d_cmd_cfg->color_blend_mode = (op >> 24) & 0xff;
+	ge2d_cmd_cfg->color_src_blend_factor = (op >> 20) & 0xf;
+	ge2d_cmd_cfg->color_dst_blend_factor = (op >> 16) & 0xf;
+	ge2d_cmd_cfg->alpha_src_blend_factor = (op >>  4) & 0xf;
+	ge2d_cmd_cfg->alpha_dst_blend_factor = (op >>  0) & 0xf;
+
+	if (ge2d_cmd_cfg->color_blend_mode >= BLENDOP_LOGIC) {
+		ge2d_cmd_cfg->color_logic_op =
+			ge2d_cmd_cfg->color_blend_mode - BLENDOP_LOGIC;
+		ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+	}
+	ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_SET;
+
+	ge2d_cmd_cfg->wait_done_flag   = 0;
+
+	ge2d_wq_add_work(wq);
+}
+EXPORT_SYMBOL(blend_noalpha_noblk);
diff --git a/drivers/amlogic/display/ge2d/ge2d_hw.c b/drivers/amlogic/display/ge2d/ge2d_hw.c
index fbfe0af..a81f45d 100644
--- a/drivers/amlogic/display/ge2d/ge2d_hw.c
+++ b/drivers/amlogic/display/ge2d/ge2d_hw.c
@@ -28,6 +28,116 @@
 #include "ge2d_io.h"
 #include "ge2d_reg.h"
 
+static const  unsigned int filt_coef_gau1[] = { /* gau1+phase */
+	0x20402000,
+	0x203f2001,
+	0x203e2002,
+	0x203d2003,
+	0x203c2004,
+	0x203b2005,
+	0x203a2006,
+	0x20392007,
+	0x20382008,
+	0x20372009,
+	0x2036200a,
+	0x2035200b,
+	0x2034200c,
+	0x2033200d,
+	0x2032200e,
+	0x2031200f,
+	0x20302010,
+	0x202f2011,
+	0x202e2012,
+	0x202d2013,
+	0x202c2014,
+	0x202b2015,
+	0x202a2016,
+	0x20292017,
+	0x20282018,
+	0x20272019,
+	0x2026201a,
+	0x2025201b,
+	0x2024201c,
+	0x2023201d,
+	0x2022201e,
+	0x2021201f,
+	0x20202020
+};
+
+/* average, no phase, horizontal filter and vertical filter for top field */
+static const  unsigned int filt_coef_gau0[] = {
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020
+};
+
+/* average, no phase, only for vertical filter of bot filed*/
+static const  unsigned int filt_coef_gau0_bot[] = {
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00
+};
+
 static const  unsigned int filt_coef0[] = { /* bicubic */
 	0x00800000,
 	0x007f0100,
@@ -191,6 +301,8 @@ void ge2d_set_src1_data(struct ge2d_src1_data_s *cfg)
 	ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->endian, 7, 1);
 	ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->color_map, 3, 4);
 	ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->format, 0, 2);
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_TXL)
+		ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->deep_color, 2, 1);
 	ge2d_reg_set_bits(GE2D_GEN_CTRL0, cfg->mode_8b_sel, 5, 2);
 	ge2d_reg_set_bits(GE2D_GEN_CTRL0, cfg->lut_en, 3, 1);
 
@@ -220,8 +332,14 @@ void ge2d_set_src1_scale_coef(unsigned v_filt_type, unsigned h_filt_type)
 			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef0[i]);
 		else if (v_filt_type == FILTER_TYPE_BILINEAR)
 			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef1[i]);
-		else if ((v_filt_type & 0xf) == FILTER_TYPE_TRIANGLE)
+		else if (v_filt_type == FILTER_TYPE_TRIANGLE)
 			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef2[i]);
+		else if (v_filt_type == FILTER_TYPE_GAU0)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef_gau0[i]);
+		else if (v_filt_type == FILTER_TYPE_GAU0_BOT)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef_gau0_bot[i]);
+		else if (v_filt_type == FILTER_TYPE_GAU1)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef_gau1[i]);
 		else {
 			/* TODO */
 			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef3[i]);
@@ -237,6 +355,12 @@ void ge2d_set_src1_scale_coef(unsigned v_filt_type, unsigned h_filt_type)
 			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef1[i]);
 		else if (h_filt_type == FILTER_TYPE_TRIANGLE)
 			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef2[i]);
+		else if (h_filt_type == FILTER_TYPE_GAU0)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef_gau0[i]);
+		else if (h_filt_type == FILTER_TYPE_GAU0_BOT)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef_gau0_bot[i]);
+		else if (h_filt_type == FILTER_TYPE_GAU1)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef_gau1[i]);
 		else {
 			/* TODO */
 			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef3[i]);
@@ -490,6 +614,7 @@ void ge2d_set_dp_gen(struct ge2d_dp_gen_s *cfg)
 		cfg->matrix_sat_in_en = 0;
 		cfg->matrix_minus_16_ctrl = 0;
 		cfg->matrix_sign_ctrl = 0;
+
 	} else if (cfg->use_matrix_default == MATRIX_FULL_RANGE_YCC_TO_RGB) {
 		/* ycbcr (0-255) to rgb(0-255) */
 		/* 1,     0,      1.402 */
@@ -510,6 +635,22 @@ void ge2d_set_dp_gen(struct ge2d_dp_gen_s *cfg)
 		cfg->matrix_sat_in_en = 0;
 		cfg->matrix_minus_16_ctrl = 0;
 		cfg->matrix_sign_ctrl = 0x3;
+	} else if (cfg->use_matrix_default == MATRIX_RGB_TO_FULL_RANGE_YCC) {
+		cfg->matrix_coef[0] = 0x132;
+		cfg->matrix_coef[1] = 0x259;
+		cfg->matrix_coef[2] = 0x75;
+		cfg->matrix_coef[3] = 0x1f53;
+		cfg->matrix_coef[4] = 0x1ead;
+		cfg->matrix_coef[5] = 0x200;
+		cfg->matrix_coef[6] = 0x200;
+		cfg->matrix_coef[7] = 0x1e53;
+		cfg->matrix_coef[8] = 0x1fad;
+		cfg->matrix_offset[0] = 0;
+		cfg->matrix_offset[1] = 128;
+		cfg->matrix_offset[2] = 128;
+		cfg->matrix_sat_in_en = 0;
+		cfg->matrix_minus_16_ctrl = 0;
+		cfg->matrix_sign_ctrl = 0;
 	}
 
 	if (cfg->matrix_minus_16_ctrl)
diff --git a/drivers/amlogic/display/ge2d/ge2d_io.h b/drivers/amlogic/display/ge2d/ge2d_io.h
index 1388290..6100c9c 100644
--- a/drivers/amlogic/display/ge2d/ge2d_io.h
+++ b/drivers/amlogic/display/ge2d/ge2d_io.h
@@ -26,6 +26,8 @@
 #include "ge2d_log.h"
 
 #define GE2DBUS_REG_ADDR(reg) (((reg - 0x1800) << 2))
+extern unsigned int ge2d_dump_reg_cnt;
+extern unsigned int ge2d_dump_reg_enable;
 
 struct reg_map_s {
 	unsigned int phy_addr;
@@ -75,7 +77,6 @@ static uint32_t ge2d_reg_read(unsigned int reg)
 
 static void ge2d_reg_write(unsigned int reg, unsigned int val)
 {
-	unsigned int ret = 0;
 	unsigned int addr = 0;
 
 	if (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR)
@@ -89,8 +90,11 @@ static void ge2d_reg_write(unsigned int reg, unsigned int val)
 		writel(val, reg_map.vir_addr + addr);
 		/* ret = readl(reg_map.vir_addr + addr); */
 	}
-	ge2d_log_dbg2("write(0x%x, 0x%x)=0x%x\n",
-			reg_map.phy_addr + addr, val, ret);
+	if (ge2d_dump_reg_enable && (ge2d_dump_reg_cnt > 0)) {
+		ge2d_log_info("write(0x%x) = 0x%x\n",
+				reg, val);
+		ge2d_dump_reg_cnt--;
+	}
 }
 
 static inline uint32_t ge2d_vcbus_read(uint32_t reg)
diff --git a/drivers/amlogic/display/ge2d/ge2d_main.c b/drivers/amlogic/display/ge2d/ge2d_main.c
index 9094cc7..4674fe4 100644
--- a/drivers/amlogic/display/ge2d/ge2d_main.c
+++ b/drivers/amlogic/display/ge2d/ge2d_main.c
@@ -38,7 +38,9 @@
 #include <linux/amlogic/ge2d/ge2d.h>
 #include <linux/amlogic/ge2d/ge2d_cmd.h>
 #include <linux/amlogic/cpu_version.h>
-
+#ifdef CONFIG_AMLOGIC_ION
+#include <meson_ion.h>
+#endif
 /* Local Headers */
 #include "ge2dgen.h"
 #include "ge2d_log.h"
@@ -58,7 +60,11 @@ struct ge2d_device_s {
 static struct ge2d_device_s ge2d_device;
 static DEFINE_MUTEX(ge2d_mutex);
 unsigned int ge2d_log_level;
-
+unsigned int ge2d_dump_reg_enable;
+unsigned int ge2d_dump_reg_cnt;
+#ifdef CONFIG_AMLOGIC_ION
+struct ion_client *ge2d_ion_client = NULL;
+#endif
 static int ge2d_open(struct inode *inode, struct file *file);
 static long ge2d_ioctl(struct file *filp, unsigned int cmd,
 		       unsigned long args);
@@ -73,6 +79,19 @@ static ssize_t log_level_show(struct class *cla,
 static ssize_t log_level_store(struct class *cla,
 			       struct class_attribute *attr,
 			       const char *buf, size_t count);
+static ssize_t dump_reg_enable_show(struct class *cla,
+			      struct class_attribute *attr,
+			      char *buf);
+static ssize_t dump_reg_enable_store(struct class *cla,
+				 struct class_attribute *attr,
+				 const char *buf, size_t count);
+static ssize_t dump_reg_cnt_show(struct class *cla,
+			      struct class_attribute *attr,
+			      char *buf);
+static ssize_t dump_reg_cnt_store(struct class *cla,
+			       struct class_attribute *attr,
+			       const char *buf, size_t count);
+
 
 static const struct file_operations ge2d_fops = {
 	.owner		= THIS_MODULE,
@@ -91,6 +110,10 @@ static struct class_attribute ge2d_class_attrs[] = {
 			free_queue_status_show, NULL),
 	__ATTR(log_level, S_IRUGO | S_IWUSR,
 			log_level_show, log_level_store),
+	__ATTR(dump_reg_enable, S_IRUGO | S_IWUSR,
+			dump_reg_enable_show, dump_reg_enable_store),
+	__ATTR(dump_reg_cnt, S_IRUGO | S_IWUSR,
+			dump_reg_cnt_show, dump_reg_cnt_store),
 	__ATTR_NULL
 };
 
@@ -99,6 +122,47 @@ static struct class ge2d_class = {
 	.class_attrs = ge2d_class_attrs,
 };
 
+static ssize_t dump_reg_enable_show(struct class *cla,
+			      struct class_attribute *attr,
+			      char *buf)
+{
+	return snprintf(buf, 40, "%d\n", ge2d_dump_reg_enable);
+}
+
+static ssize_t dump_reg_enable_store(struct class *cla,
+			       struct class_attribute *attr,
+			       const char *buf, size_t count)
+{
+	int res = 0;
+	int ret = 0;
+
+	ret = kstrtoint(buf, 0, &res);
+	ge2d_log_info("ge2d dump_reg_enbale: %d->%d\n",
+		ge2d_dump_reg_enable, res);
+	ge2d_dump_reg_enable = res;
+
+	return count;
+}
+
+static ssize_t dump_reg_cnt_show(struct class *cla,
+			      struct class_attribute *attr,
+			      char *buf)
+{
+	return snprintf(buf, 40, "%d\n", ge2d_dump_reg_cnt);
+}
+
+static ssize_t dump_reg_cnt_store(struct class *cla,
+			       struct class_attribute *attr,
+			       const char *buf, size_t count)
+{
+	int res = 0;
+	int ret = 0;
+
+	ret = kstrtoint(buf, 0, &res);
+	ge2d_log_info("ge2d dump_reg: %d->%d\n", ge2d_dump_reg_cnt, res);
+	ge2d_dump_reg_cnt = res;
+	return count;
+}
 
 static ssize_t log_level_show(struct class *cla,
 			      struct class_attribute *attr,
@@ -121,19 +185,6 @@ static ssize_t log_level_store(struct class *cla,
 	return count;
 }
 
-static bool command_valid(unsigned int cmd)
-{
-	bool ret = false;
-#ifdef CONFIG_COMPAT
-	ret = (cmd <= GE2D_CONFIG_EX32 &&
-		cmd >= GE2D_ANTIFLICKER_ENABLE);
-#else
-	ret = (cmd <= GE2D_CONFIG_EX &&
-		cmd >= GE2D_ANTIFLICKER_ENABLE);
-#endif
-	return ret;
-}
-
 static int ge2d_open(struct inode *inode, struct file *file)
 {
 	struct ge2d_context_s *context = NULL;
@@ -156,19 +207,31 @@ static long ge2d_ioctl(struct file *filp, unsigned int cmd, unsigned long args)
 	struct config_para_s ge2d_config;
 	struct ge2d_para_s para;
 	struct config_para_ex_s ge2d_config_ex;
+	struct config_para_ex_ion_s ge2d_config_ex_ion;
 	int ret = 0;
 #ifdef CONFIG_COMPAT
 	struct compat_config_para_s __user *uf;
+	struct compat_config_para_ex_s __user *uf_ex;
+	struct compat_config_para_ex_ion_s __user *uf_ex_ion;
 	int r = 0;
 	int i, j;
 #endif
 	void __user *argp = (void __user *)args;
 
-	if (!command_valid(cmd))
-		return -1;
-
 	context = (struct ge2d_context_s *)filp->private_data;
 	memset(&ge2d_config, 0, sizeof(struct config_para_s));
+	memset(&ge2d_config_ex, 0, sizeof(struct config_para_ex_s));
+	memset(&ge2d_config_ex_ion, 0, sizeof(struct config_para_ex_ion_s));
+#ifdef CONFIG_AM_GE2D_MORE_SECURITY
+	switch (cmd) {
+	case GE2D_CONFIG:
+	case GE2D_CONFIG32:
+	case GE2D_CONFIG_EX:
+	case GE2D_CONFIG_EX32:
+		pr_err("ioctl not support.\n");
+		return -EINVAL;
+	}
+#endif
 	switch (cmd) {
 	case GE2D_CONFIG:
 	case GE2D_SRCCOLORKEY:
@@ -176,6 +239,38 @@ static long ge2d_ioctl(struct file *filp, unsigned int cmd, unsigned long args)
 				argp, sizeof(struct config_para_s));
 		break;
 #ifdef CONFIG_COMPAT
+	case GE2D_SRCCOLORKEY32:
+		uf = (struct compat_config_para_s *)argp;
+		r = get_user(ge2d_config.src_dst_type, &uf->src_dst_type);
+		r |= get_user(ge2d_config.alu_const_color,
+			&uf->alu_const_color);
+		r |= get_user(ge2d_config.src_format, &uf->src_format);
+		r |= get_user(ge2d_config.dst_format, &uf->dst_format);
+		for (i = 0; i < 4; i++) {
+			r |= get_user(ge2d_config.src_planes[i].addr,
+				&uf->src_planes[i].addr);
+			r |= get_user(ge2d_config.src_planes[i].w,
+				&uf->src_planes[i].w);
+			r |= get_user(ge2d_config.src_planes[i].h,
+				&uf->src_planes[i].h);
+		}
+		for (j = 0; j < 4; j++) {
+			r |= get_user(ge2d_config.dst_planes[j].addr,
+				&uf->dst_planes[j].addr);
+			r |= get_user(ge2d_config.dst_planes[j].w,
+				&uf->dst_planes[j].w);
+			r |= get_user(ge2d_config.dst_planes[j].h,
+				&uf->dst_planes[j].h);
+		}
+		r |= copy_from_user(&ge2d_config.src_key, &uf->src_key,
+			sizeof(struct src_key_ctrl_s));
+		if (r) {
+			pr_err("GE2D_SRCCOLORKEY32 get parameter failed .\n");
+			return -EFAULT;
+			}
+		break;
+#endif
+#ifdef CONFIG_COMPAT
 	case GE2D_CONFIG32:
 		uf = (struct compat_config_para_s *)argp;
 		r = get_user(ge2d_config.src_dst_type, &uf->src_dst_type);
@@ -212,9 +307,214 @@ static long ge2d_ioctl(struct file *filp, unsigned int cmd, unsigned long args)
 		ret = copy_from_user(&ge2d_config_ex, argp,
 				sizeof(struct config_para_ex_s));
 		break;
+#ifdef CONFIG_COMPAT
+	case GE2D_CONFIG_EX32:
+		uf_ex = (struct compat_config_para_ex_s *)argp;
+		r = copy_from_user(&ge2d_config_ex.src_para, &uf_ex->src_para,
+			sizeof(struct src_dst_para_ex_s));
+		r |= copy_from_user(&ge2d_config_ex.src2_para,
+			&uf_ex->src2_para,
+			sizeof(struct src_dst_para_ex_s));
+		r |= copy_from_user(&ge2d_config_ex.dst_para, &uf_ex->dst_para,
+			sizeof(struct src_dst_para_ex_s));
+
+		r |= copy_from_user(&ge2d_config_ex.src_key, &uf_ex->src_key,
+			sizeof(struct src_key_ctrl_s));
+		r |= copy_from_user(&ge2d_config_ex.src2_key, &uf_ex->src2_key,
+			sizeof(struct src_key_ctrl_s));
+
+		r |= get_user(ge2d_config_ex.alu_const_color,
+			&uf_ex->alu_const_color);
+		r |= get_user(ge2d_config_ex.src1_gb_alpha,
+			&uf_ex->src1_gb_alpha);
+		r |= get_user(ge2d_config_ex.op_mode, &uf_ex->op_mode);
+		r |= get_user(ge2d_config_ex.bitmask_en, &uf_ex->bitmask_en);
+		r |= get_user(ge2d_config_ex.bytemask_only,
+			&uf_ex->bytemask_only);
+		r |= get_user(ge2d_config_ex.bitmask, &uf_ex->bitmask);
+		r |= get_user(ge2d_config_ex.dst_xy_swap, &uf_ex->dst_xy_swap);
+		r |= get_user(ge2d_config_ex.hf_init_phase,
+			&uf_ex->hf_init_phase);
+		r |= get_user(ge2d_config_ex.hf_rpt_num, &uf_ex->hf_rpt_num);
+		r |= get_user(ge2d_config_ex.hsc_start_phase_step,
+			&uf_ex->hsc_start_phase_step);
+		r |= get_user(ge2d_config_ex.hsc_phase_slope,
+			&uf_ex->hsc_phase_slope);
+		r |= get_user(ge2d_config_ex.vf_init_phase,
+			&uf_ex->vf_init_phase);
+		r |= get_user(ge2d_config_ex.vf_rpt_num, &uf_ex->vf_rpt_num);
+		r |= get_user(ge2d_config_ex.vsc_start_phase_step,
+			&uf_ex->vsc_start_phase_step);
+		r |= get_user(ge2d_config_ex.vsc_phase_slope,
+			&uf_ex->vsc_phase_slope);
+		r |= get_user(ge2d_config_ex.src1_vsc_phase0_always_en,
+			&uf_ex->src1_vsc_phase0_always_en);
+		r |= get_user(ge2d_config_ex.src1_hsc_phase0_always_en,
+			&uf_ex->src1_hsc_phase0_always_en);
+		r |= get_user(ge2d_config_ex.src1_hsc_rpt_ctrl,
+			&uf_ex->src1_hsc_rpt_ctrl);
+		r |= get_user(ge2d_config_ex.src1_vsc_rpt_ctrl,
+			&uf_ex->src1_vsc_rpt_ctrl);
+
+		for (i = 0; i < 4; i++) {
+			r |= get_user(ge2d_config_ex.src_planes[i].addr,
+				&uf_ex->src_planes[i].addr);
+			r |= get_user(ge2d_config_ex.src_planes[i].w,
+				&uf_ex->src_planes[i].w);
+			r |= get_user(ge2d_config_ex.src_planes[i].h,
+				&uf_ex->src_planes[i].h);
+		}
+
+		for (i = 0; i < 4; i++) {
+			r |= get_user(ge2d_config_ex.src2_planes[i].addr,
+				&uf_ex->src2_planes[i].addr);
+			r |= get_user(ge2d_config_ex.src2_planes[i].w,
+				&uf_ex->src2_planes[i].w);
+			r |= get_user(ge2d_config_ex.src2_planes[i].h,
+				&uf_ex->src2_planes[i].h);
+		}
+
+		for (j = 0; j < 4; j++) {
+			r |= get_user(ge2d_config_ex.dst_planes[j].addr,
+				&uf_ex->dst_planes[j].addr);
+			r |= get_user(ge2d_config_ex.dst_planes[j].w,
+				&uf_ex->dst_planes[j].w);
+			r |= get_user(ge2d_config_ex.dst_planes[j].h,
+				&uf_ex->dst_planes[j].h);
+		}
+
+		if (r) {
+			pr_err("GE2D_CONFIG_EX32 get parameter failed .\n");
+			return -EFAULT;
+			}
+		break;
+#endif
+		case GE2D_CONFIG_EX_ION:
+			ret = copy_from_user(&ge2d_config_ex_ion, argp,
+					sizeof(struct config_para_ex_ion_s));
+			break;
+#ifdef CONFIG_COMPAT
+		case GE2D_CONFIG_EX32_ION:
+			uf_ex_ion = (struct compat_config_para_ex_ion_s *)argp;
+			r = copy_from_user(
+				&ge2d_config_ex_ion.src_para,
+				&uf_ex_ion->src_para,
+				sizeof(struct src_dst_para_ex_s));
+			r |= copy_from_user(
+				&ge2d_config_ex_ion.src2_para,
+				&uf_ex_ion->src2_para,
+				sizeof(struct src_dst_para_ex_s));
+			r |= copy_from_user(
+				&ge2d_config_ex_ion.dst_para,
+				&uf_ex_ion->dst_para,
+				sizeof(struct src_dst_para_ex_s));
+
+			r |= copy_from_user(&ge2d_config_ex_ion.src_key,
+				&uf_ex_ion->src_key,
+				sizeof(struct src_key_ctrl_s));
+			r |= copy_from_user(&ge2d_config_ex_ion.src2_key,
+				&uf_ex_ion->src2_key,
+				sizeof(struct src_key_ctrl_s));
+
+			r |= get_user(ge2d_config_ex_ion.alu_const_color,
+				&uf_ex_ion->alu_const_color);
+			r |= get_user(ge2d_config_ex_ion.src1_gb_alpha,
+				&uf_ex_ion->src1_gb_alpha);
+			r |= get_user(ge2d_config_ex_ion.op_mode,
+				&uf_ex_ion->op_mode);
+			r |= get_user(ge2d_config_ex_ion.bitmask_en,
+				&uf_ex_ion->bitmask_en);
+			r |= get_user(ge2d_config_ex_ion.bytemask_only,
+				&uf_ex_ion->bytemask_only);
+			r |= get_user(ge2d_config_ex_ion.bitmask,
+				&uf_ex_ion->bitmask);
+			r |= get_user(ge2d_config_ex_ion.dst_xy_swap,
+				&uf_ex_ion->dst_xy_swap);
+			r |= get_user(ge2d_config_ex_ion.hf_init_phase,
+				&uf_ex_ion->hf_init_phase);
+			r |= get_user(ge2d_config_ex_ion.hf_rpt_num,
+				&uf_ex_ion->hf_rpt_num);
+			r |= get_user(ge2d_config_ex_ion.hsc_start_phase_step,
+				&uf_ex_ion->hsc_start_phase_step);
+			r |= get_user(ge2d_config_ex_ion.hsc_phase_slope,
+				&uf_ex_ion->hsc_phase_slope);
+			r |= get_user(ge2d_config_ex_ion.vf_init_phase,
+				&uf_ex_ion->vf_init_phase);
+			r |= get_user(ge2d_config_ex_ion.vf_rpt_num,
+				&uf_ex_ion->vf_rpt_num);
+			r |= get_user(ge2d_config_ex_ion.vsc_start_phase_step,
+				&uf_ex_ion->vsc_start_phase_step);
+			r |= get_user(ge2d_config_ex_ion.vsc_phase_slope,
+				&uf_ex_ion->vsc_phase_slope);
+			r |= get_user(
+				ge2d_config_ex_ion.src1_vsc_phase0_always_en,
+				&uf_ex_ion->src1_vsc_phase0_always_en);
+			r |= get_user(
+				ge2d_config_ex_ion.src1_hsc_phase0_always_en,
+				&uf_ex_ion->src1_hsc_phase0_always_en);
+			r |= get_user(
+				ge2d_config_ex_ion.src1_hsc_rpt_ctrl,
+				&uf_ex_ion->src1_hsc_rpt_ctrl);
+			r |= get_user(
+				ge2d_config_ex_ion.src1_vsc_rpt_ctrl,
+				&uf_ex_ion->src1_vsc_rpt_ctrl);
+
+			for (i = 0; i < 4; i++) {
+				struct config_planes_ion_s *psrc_planes;
+				psrc_planes =
+					&ge2d_config_ex_ion.src_planes[i];
+				r |= get_user(psrc_planes->addr,
+					&uf_ex_ion->src_planes[i].addr);
+				r |= get_user(psrc_planes->w,
+					&uf_ex_ion->src_planes[i].w);
+				r |= get_user(psrc_planes->h,
+					&uf_ex_ion->src_planes[i].h);
+				r |= get_user(psrc_planes->shared_fd,
+					&uf_ex_ion->src_planes[i].shared_fd);
+			}
+
+			for (i = 0; i < 4; i++) {
+				struct config_planes_ion_s *psrc2_planes;
+				psrc2_planes =
+					&ge2d_config_ex_ion.src2_planes[i];
+				r |= get_user(psrc2_planes->addr,
+					&uf_ex_ion->src2_planes[i].addr);
+				r |= get_user(psrc2_planes->w,
+					&uf_ex_ion->src2_planes[i].w);
+				r |= get_user(psrc2_planes->h,
+					&uf_ex_ion->src2_planes[i].h);
+				r |= get_user(psrc2_planes->shared_fd,
+					&uf_ex_ion->src2_planes[i].shared_fd);
+			}
+
+			for (j = 0; j < 4; j++) {
+				struct config_planes_ion_s *pdst_planes;
+				pdst_planes =
+					&ge2d_config_ex_ion.dst_planes[j];
+				r |= get_user(pdst_planes->addr,
+					&uf_ex_ion->dst_planes[j].addr);
+				r |= get_user(pdst_planes->w,
+					&uf_ex_ion->dst_planes[j].w);
+				r |= get_user(pdst_planes->h,
+					&uf_ex_ion->dst_planes[j].h);
+				r |= get_user(pdst_planes->shared_fd,
+					&uf_ex_ion->dst_planes[j].shared_fd);
+			}
+			if (r) {
+				pr_err("GE2D_CONFIG_EX32 get parameter failed .\n");
+				return -EFAULT;
+				}
+			break;
+#endif
+
 	case GE2D_SET_COEF:
 	case GE2D_ANTIFLICKER_ENABLE:
 		break;
+	case GE2D_CONFIG_OLD:
+	case GE2D_CONFIG_EX_OLD:
+	case GE2D_SRCCOLORKEY_OLD:
+		pr_err("ioctl not support yed.\n");
+		return -EINVAL;
 	default:
 		ret = copy_from_user(&para, argp, sizeof(struct ge2d_para_s));
 		break;
@@ -229,8 +529,17 @@ static long ge2d_ioctl(struct file *filp, unsigned int cmd, unsigned long args)
 		ret = ge2d_context_config(context, &ge2d_config);
 		break;
 	case GE2D_CONFIG_EX:
+#ifdef CONFIG_COMPAT
+	case GE2D_CONFIG_EX32:
+#endif
 		ret = ge2d_context_config_ex(context, &ge2d_config_ex);
 		break;
+	case GE2D_CONFIG_EX_ION:
+#ifdef CONFIG_COMPAT
+	case GE2D_CONFIG_EX32_ION:
+#endif
+		ret = ge2d_context_config_ex_ion(context, &ge2d_config_ex_ion);
+		break;
 	case GE2D_SET_COEF:
 		ge2d_wq_set_scale_coef(context, args & 0xff, args >> 16);
 		break;
@@ -238,6 +547,15 @@ static long ge2d_ioctl(struct file *filp, unsigned int cmd, unsigned long args)
 		ge2d_antiflicker_enable(context, args);
 		break;
 	case GE2D_SRCCOLORKEY:
+#ifdef CONFIG_COMPAT
+	case GE2D_SRCCOLORKEY32:
+#endif
+		ge2d_log_dbg("src colorkey...,key_enable=0x%x,key_color=0x%x,key_mask=0x%x,key_mode=0x%x\n",
+			     ge2d_config.src_key.key_enable,
+			     ge2d_config.src_key.key_color,
+			     ge2d_config.src_key.key_mask,
+			     ge2d_config.src_key.key_mode);
+
 		ge2dgen_src_key(context , ge2d_config.src_key.key_enable,
 				ge2d_config.src_key.key_color,
 				ge2d_config.src_key.key_mask,
@@ -332,6 +650,28 @@ static long ge2d_ioctl(struct file *filp, unsigned int cmd, unsigned long args)
 			    para.dst_rect.w, para.dst_rect.h,
 			    para.op);
 		break;
+	case GE2D_BLEND_NOALPHA:
+		ge2d_log_dbg("blend_noalpha ...\n");
+		blend_noalpha(context,
+			  para.src1_rect.x, para.src1_rect.y,
+			  para.src1_rect.w, para.src1_rect.h,
+			  para.src2_rect.x, para.src2_rect.y,
+			  para.src2_rect.w, para.src2_rect.h,
+			  para.dst_rect.x, para.dst_rect.y,
+			  para.dst_rect.w, para.dst_rect.h,
+			  para.op);
+			break;
+	case GE2D_BLEND_NOALPHA_NOBLOCK:
+		ge2d_log_dbg("blend_noalpha ...,noblk\n");
+		blend_noalpha_noblk(context,
+				para.src1_rect.x, para.src1_rect.y,
+				para.src1_rect.w, para.src1_rect.h,
+				para.src2_rect.x, para.src2_rect.y,
+				para.src2_rect.w, para.src2_rect.h,
+				para.dst_rect.x, para.dst_rect.y,
+				para.dst_rect.w, para.dst_rect.h,
+				para.op);
+		break;
 	case GE2D_BLIT_NOALPHA:
 		/* bitblt_noalpha */
 		ge2d_log_dbg("blit_noalpha...\n");
@@ -448,6 +788,10 @@ static int ge2d_probe(struct platform_device *pdev)
 		}
 	}
 	ret = ge2d_wq_init(pdev, irq, rstc, clk);
+#ifdef CONFIG_AMLOGIC_ION
+	if (!ge2d_ion_client)
+		ge2d_ion_client = meson_ion_client_create(-1, "meson-ge2d");
+#endif
 failed1:
 	return ret;
 }
diff --git a/drivers/amlogic/display/ge2d/ge2d_wq.c b/drivers/amlogic/display/ge2d/ge2d_wq.c
index f29d5d1..2717757 100644
--- a/drivers/amlogic/display/ge2d/ge2d_wq.c
+++ b/drivers/amlogic/display/ge2d/ge2d_wq.c
@@ -34,6 +34,7 @@
 #include <linux/amlogic/canvas/canvas_mgr.h>
 #include <linux/amlogic/ge2d/ge2d.h>
 #include <linux/platform_device.h>
+#include <meson_ion.h>
 
 /* Local Headers */
 #include "ge2dgen.h"
@@ -42,6 +43,8 @@
 #include "ge2d_reg.h"
 #include "ge2d_wq.h"
 
+#include "osd_io.h"
+
 #define OSD1_CANVAS_INDEX 0x40
 #define OSD2_CANVAS_INDEX 0x43
 #define OSD3_CANVAS_INDEX 0x41
@@ -171,6 +174,76 @@ static inline  int  work_queue_no_space(struct ge2d_context_s *queue)
 	return  list_empty(&queue->free_queue);
 }
 
+static void ge2d_dump_cmd(struct ge2d_cmd_s *cfg)
+{
+	ge2d_log_dbg("src1_x_start=%d,src1_y_start=%d\n",
+		cfg->src1_x_start, cfg->src1_y_start);
+	ge2d_log_dbg("src1_x_end=%d,src1_y_end=%d\n",
+		cfg->src1_x_end, cfg->src1_y_end);
+	ge2d_log_dbg("src1_x_rev=%d,src1_y_rev=%d\n",
+		cfg->src1_x_rev, cfg->src1_y_rev);
+	ge2d_log_dbg("src1_fill_color_en=%d\n",
+		cfg->src1_fill_color_en);
+
+	ge2d_log_dbg("src2_x_start=%d,src2_y_start=%d\n",
+		cfg->src2_x_start, cfg->src2_y_start);
+	ge2d_log_dbg("src2_x_end=%d,src2_y_end=%d\n",
+		cfg->src2_x_end, cfg->src2_y_end);
+	ge2d_log_dbg("src2_x_rev=%d,src2_y_rev=%d\n",
+		cfg->src2_x_rev, cfg->src2_y_rev);
+	ge2d_log_dbg("src2_fill_color_en=%d\n",
+		cfg->src2_fill_color_en);
+
+	ge2d_log_dbg("dst_x_start=%d,dst_y_start=%d\n",
+		cfg->dst_x_start, cfg->dst_y_start);
+	ge2d_log_dbg("dst_x_end=%d,dst_y_end=%d\n",
+		cfg->dst_x_end, cfg->dst_y_end);
+	ge2d_log_dbg("dst_x_rev=%d,dst_y_rev=%d\n",
+		cfg->dst_x_rev, cfg->dst_y_rev);
+	ge2d_log_dbg("dst_xy_swap=%d\n",
+		cfg->dst_xy_swap);
+
+	ge2d_log_dbg("color_blend_mode=0x%x\n",
+		cfg->color_blend_mode);
+	ge2d_log_dbg("color_src_blend_factor=0x%x\n",
+		cfg->color_src_blend_factor);
+	ge2d_log_dbg("color_dst_blend_factor=0x%x\n",
+		cfg->color_dst_blend_factor);
+	ge2d_log_dbg("color_logic_op=0x%x\n",
+		cfg->color_logic_op);
+	ge2d_log_dbg("alpha_blend_mode=0x%x\n",
+		cfg->alpha_blend_mode);
+	ge2d_log_dbg("alpha_src_blend_factor=0x%x\n",
+		cfg->alpha_src_blend_factor);
+	ge2d_log_dbg("alpha_src_blend_factor=0x%x\n",
+		cfg->alpha_dst_blend_factor);
+	ge2d_log_dbg("alpha_logic_op=0x%x\n",
+		cfg->alpha_logic_op);
+
+	ge2d_log_dbg("sc_prehsc_en=%d\n", cfg->sc_prehsc_en);
+	ge2d_log_dbg("sc_prevsc_en=%d\n", cfg->sc_prevsc_en);
+	ge2d_log_dbg("sc_hsc_en=%d\n", cfg->sc_hsc_en);
+	ge2d_log_dbg("sc_vsc_en=%d\n", cfg->sc_vsc_en);
+	ge2d_log_dbg("vsc_phase_step=%d\n", cfg->vsc_phase_step);
+	ge2d_log_dbg("vsc_phase_slope=%d\n", cfg->vsc_phase_slope);
+	ge2d_log_dbg("vsc_rpt_l0_num=%d\n", cfg->vsc_rpt_l0_num);
+	ge2d_log_dbg("vsc_ini_phase=%d\n", cfg->vsc_ini_phase);
+	ge2d_log_dbg("hsc_phase_step=%d\n", cfg->hsc_phase_step);
+	ge2d_log_dbg("hsc_phase_slope=%d\n", cfg->hsc_phase_slope);
+	ge2d_log_dbg("hsc_rpt_p0_num=%d\n", cfg->hsc_rpt_p0_num);
+	ge2d_log_dbg("hsc_ini_phase=%d\n", cfg->hsc_ini_phase);
+	ge2d_log_dbg("hsc_div_en=%d\n", cfg->hsc_div_en);
+	ge2d_log_dbg("hsc_div_length=%d\n", cfg->hsc_div_length);
+	ge2d_log_dbg("hsc_adv_num=%d\n", cfg->hsc_adv_num);
+	ge2d_log_dbg("hsc_adv_phase=%d\n", cfg->hsc_adv_phase);
+	ge2d_log_dbg("src1_cmult_asel=%d\n", cfg->src1_cmult_asel);
+	ge2d_log_dbg("src2_cmult_asel=%d\n", cfg->src2_cmult_asel);
+
+	ge2d_log_dbg("GE2D_STATUS0=0x%x\n", ge2d_reg_read(GE2D_STATUS0));
+	ge2d_log_dbg("GE2D_STATUS1=0x%x\n", ge2d_reg_read(GE2D_STATUS1));
+}
+
+
 static int ge2d_process_work_queue(struct ge2d_context_s *wq)
 {
 	struct ge2d_config_s *cfg;
@@ -179,7 +252,9 @@ static int ge2d_process_work_queue(struct ge2d_context_s *wq)
 	struct list_head  *head = &wq->work_queue, *pos;
 	int ret = 0;
 	unsigned int block_mode;
-
+	int timeout = 0;
+	if (wq->ge2d_request_exit)
+		goto exit;
 	ge2d_manager.ge2d_state = GE2D_STATE_RUNNING;
 	pos = head->next;
 	if (pos != head) { /* current work queue not empty. */
@@ -241,9 +316,18 @@ static int ge2d_process_work_queue(struct ge2d_context_s *wq)
 		/* list_move_tail(&pitem->list,&wq->free_queue); */
 		/* spin_unlock(&wq->lock); */
 
-		while (ge2d_is_busy())
-			interruptible_sleep_on_timeout(
-					&ge2d_manager.event.cmd_complete, 1);
+		while (ge2d_is_busy()) {
+			timeout = wait_event_interruptible_timeout(
+					ge2d_manager.event.cmd_complete,
+					!ge2d_is_busy(),
+					100);
+			if (timeout == 0) {
+				ge2d_log_err("ge2d timeout!!!\n");
+				ge2d_dump_cmd(&pitem->cmd);
+				ge2d_soft_rst();
+				break;
+			}
+		}
 		/* if block mode (cmd) */
 		if (block_mode) {
 			pitem->cmd.wait_done_flag = 0;
@@ -258,7 +342,7 @@ static int ge2d_process_work_queue(struct ge2d_context_s *wq)
 	} while (pos != head);
 	ge2d_manager.last_wq = wq;
 exit:
-	if (ge2d_manager.ge2d_state == GE2D_STATE_REMOVING_WQ)
+	if (wq->ge2d_request_exit)
 		complete(&ge2d_manager.event.process_complete);
 	ge2d_manager.ge2d_state = GE2D_STATE_IDLE;
 	return ret;
@@ -321,10 +405,12 @@ int ge2d_wq_add_work(struct ge2d_context_s *wq)
 	if (work_queue_no_space(wq)) {
 		ge2d_log_dbg("work queue no space\n");
 		/* we should wait for queue empty at this point. */
+		#if 0
 		while (work_queue_no_space(wq))
 			interruptible_sleep_on_timeout(
 					&ge2d_manager.event.cmd_complete, 3);
-		ge2d_log_dbg("got free space\n");
+		#endif
+		return -1;
 	}
 
 	pitem = list_entry(wq->free_queue.next, struct ge2d_queue_item_s, list);
@@ -384,7 +470,8 @@ static int ge2d_monitor_thread(void *data)
 		while ((manager->current_wq =
 				get_next_work_queue(manager)) != NULL)
 			ge2d_process_work_queue(manager->current_wq);
-		ge2d_clk_config(false);
+		if (!ge2d_dump_reg_enable)
+			ge2d_clk_config(false);
 	}
 	ge2d_log_info("exit ge2d_monitor_thread\n");
 	return 0;
@@ -426,6 +513,9 @@ static inline int bpp(unsigned format)
 	case GE2D_BPP_16BIT:
 		return 16;
 	case GE2D_BPP_24BIT:
+		if ((GE2D_COLOR_MAP_NV21 == (format & GE2D_COLOR_MAP_NV21)) ||
+			(GE2D_COLOR_MAP_NV12 == (format & GE2D_COLOR_MAP_NV12)))
+			return 8;
 		return 24;
 	case GE2D_BPP_32BIT:
 	default:
@@ -543,8 +633,14 @@ static int setup_display_property(struct src_dst_para_s *src_dst, int index)
 
 	index = (index == OSD1_CANVAS_INDEX ? 0 : 1);
 	ge2d_log_dbg("osd%d ", index);
-	data32 = ge2d_vcbus_read(VIU_OSD1_BLK0_CFG_W0 + REG_OFFSET * index);
-
+#ifdef CONFIG_AM_FB
+	data32 = VSYNCOSD_RD_MPEG_REG(
+		VIU_OSD1_BLK0_CFG_W0 + REG_OFFSET * index);
+	src_dst->canvas_index = (data32 >> 16) & 0xff;
+	canvas_read(src_dst->canvas_index, &canvas);
+#else
+	data32 = 0;
+#endif
 	index = (data32 >> 8) & 0xf;
 	bpp = block_mode[index]; /* OSD_BLK_MODE[8..11] */
 	ge2d_log_dbg("%d bpp\n", bpp);
@@ -556,7 +652,7 @@ static int setup_display_property(struct src_dst_para_s *src_dst, int index)
 	src_dst->xres = canvas.width / (bpp >> 3);
 	src_dst->yres = canvas.height;
 	if (index == 3) /* yuv422 32bit for two pixel. */
-		src_dst->ge2d_color_index =	GE2D_FORMAT_S16_YUV422;
+		src_dst->ge2d_color_index = GE2D_FORMAT_S16_YUV422;
 	else { /* for block mode=4,5,7 */
 		/* color mode [2..5] */
 		index = bpp - 16 + ((data32 >> 2) & 0xf);
@@ -727,6 +823,74 @@ static int build_ge2d_config_ex(struct config_planes_s *plane,
 }
 
 
+static int build_ge2d_config_ex_ion(struct config_planes_ion_s *plane,
+				unsigned format,
+				unsigned *canvas_index,
+				int index,
+				unsigned *r_offset)
+{
+	int bpp_value = bpp(format);
+	int ret = -1;
+	unsigned long addr;
+	size_t len;
+
+	bpp_value /= 8;
+	index &= 0xff;
+	if (plane) {
+		if (plane[0].shared_fd) {
+#ifdef CONFIG_AMLOGIC_ION
+			ret = meson_ion_share_fd_to_phys(ge2d_ion_client,
+				plane[0].shared_fd, &addr, &len);
+			if (ret != 0)
+				return ret;
+#else
+			return ret;
+#endif
+			plane[0].addr += addr;
+			*canvas_index = index;
+			*r_offset += 1;
+			canvas_config(index++, plane[0].addr,
+				      plane[0].w * bpp_value,
+				      plane[0].h,
+				      CANVAS_ADDR_NOWRAP,
+				      CANVAS_BLKMODE_LINEAR);
+			ret = 0;
+		}
+		/* multi-src_planes */
+		if (plane[1].addr) {
+			plane[1].addr += plane[0].addr;
+			*canvas_index |= index << 8;
+			*r_offset += 1;
+			canvas_config(index++, plane[1].addr,
+				      plane[1].w * bpp_value,
+				      plane[1].h,
+				      CANVAS_ADDR_NOWRAP,
+				      CANVAS_BLKMODE_LINEAR);
+		}
+		if (plane[2].addr) {
+			plane[2].addr += plane[1].addr;
+			*canvas_index |= index << 16;
+			*r_offset += 1;
+			canvas_config(index++, plane[2].addr,
+				      plane[2].w * bpp_value,
+				      plane[2].h,
+				      CANVAS_ADDR_NOWRAP,
+				      CANVAS_BLKMODE_LINEAR);
+		}
+		if (plane[3].addr) {
+			plane[3].addr += plane[2].addr;
+			*canvas_index |= index << 24;
+			*r_offset += 1;
+			canvas_config(index++, plane[3].addr,
+				      plane[3].w * bpp_value,
+				      plane[3].h,
+				      CANVAS_ADDR_NOWRAP,
+				      CANVAS_BLKMODE_LINEAR);
+		}
+	}
+	return ret;
+}
+
 int ge2d_context_config_ex(struct ge2d_context_s *context,
 			   struct config_para_ex_s *ge2d_config)
 {
@@ -764,6 +928,8 @@ int ge2d_context_config_ex(struct ge2d_context_s *context,
 			ge2d_log_dbg("ge2d src error: out of range\n");
 			return -1;
 		}
+		ge2d_config->src_para.width = tmp.xres;
+		ge2d_config->src_para.height = tmp.yres;
 		break;
 	case CANVAS_ALLOC:
 		top = ge2d_config->src_para.top;
@@ -812,6 +978,8 @@ int ge2d_context_config_ex(struct ge2d_context_s *context,
 				ge2d_config->src2_para.mem_type - CANVAS_OSD0);
 			return -1;
 		}
+		ge2d_config->src2_para.width = tmp.xres;
+		ge2d_config->src2_para.height = tmp.yres;
 		break;
 	case  CANVAS_ALLOC:
 		top = ge2d_config->src2_para.top;
@@ -863,6 +1031,8 @@ int ge2d_context_config_ex(struct ge2d_context_s *context,
 				ge2d_config->dst_para.mem_type - CANVAS_OSD0);
 			return -1;
 		}
+		ge2d_config->dst_para.width = tmp.xres;
+		ge2d_config->dst_para.height = tmp.yres;
 		break;
 	case  CANVAS_ALLOC:
 		top = ge2d_config->dst_para.top;
@@ -996,6 +1166,285 @@ int ge2d_context_config_ex(struct ge2d_context_s *context,
 	return  0;
 }
 
+int ge2d_context_config_ex_ion(struct ge2d_context_s *context,
+			   struct config_para_ex_ion_s *ge2d_config)
+{
+	struct src_dst_para_s  tmp;
+	unsigned index = 0;
+	unsigned alloc_canvas_offset = 0;
+	struct ge2d_src1_gen_s *src1_gen_cfg;
+	struct ge2d_src2_dst_data_s *src2_dst_data_cfg;
+	struct ge2d_src2_dst_gen_s *src2_dst_gen_cfg;
+	struct ge2d_dp_gen_s *dp_gen_cfg;
+	struct ge2d_cmd_s *ge2d_cmd_cfg;
+	int top, left, width, height;
+
+	/* setup src and dst */
+	switch (ge2d_config->src_para.mem_type) {
+	case CANVAS_OSD0:
+	case CANVAS_OSD1:
+		if (setup_display_property(&tmp,
+			(ge2d_config->src_para.mem_type == CANVAS_OSD0) ?
+			OSD1_CANVAS_INDEX : OSD2_CANVAS_INDEX) < 0)
+			return -1;
+		ge2d_config->src_para.canvas_index = tmp.canvas_index;
+		ge2d_config->src_para.format = tmp.ge2d_color_index;
+
+		ge2d_log_dbg("ge2d: src1-->type: osd%d, format: 0x%x !!\n",
+			     ge2d_config->src_para.mem_type - CANVAS_OSD0,
+			     ge2d_config->src_para.format);
+
+		top = ge2d_config->src_para.top;
+		left = ge2d_config->src_para.left;
+		width = ge2d_config->src_para.width;
+		height = ge2d_config->src_para.height;
+		if ((left + width > tmp.xres) ||
+		    (top + height > tmp.yres)) {
+			ge2d_log_dbg("ge2d src error: out of range\n");
+			return -1;
+		}
+		ge2d_config->src_para.width = tmp.xres;
+		ge2d_config->src_para.height = tmp.yres;
+		break;
+	case CANVAS_ALLOC:
+		top = ge2d_config->src_para.top;
+		left = ge2d_config->src_para.left;
+		width = ge2d_config->src_para.width;
+		height = ge2d_config->src_para.height;
+		if ((left + width > ge2d_config->src_planes[0].w)
+		    || (top + height > ge2d_config->src_planes[0].h)) {
+			ge2d_log_dbg("ge2d error: src alloc, out of range\n");
+			return -1;
+		}
+		if (build_ge2d_config_ex_ion(&ge2d_config->src_planes[0],
+				 ge2d_config->src_para.format,
+				 &index,
+				 ALLOC_CANVAS_INDEX + alloc_canvas_offset,
+				 &alloc_canvas_offset) < 0)
+			return -1;
+		ge2d_config->src_para.canvas_index = index;
+		ge2d_log_dbg("ge2d alloc canvas index:0x%x, format:0x%x\n",
+			     index, ge2d_config->src_para.format);
+		break;
+	default:
+		break;
+	}
+
+	switch (ge2d_config->src2_para.mem_type) {
+	case  CANVAS_OSD0:
+	case  CANVAS_OSD1:
+		if (setup_display_property(&tmp,
+			(ge2d_config->src2_para.mem_type == CANVAS_OSD0) ?
+			OSD1_CANVAS_INDEX : OSD2_CANVAS_INDEX) < 0)
+			return -1;
+		ge2d_config->src2_para.canvas_index = tmp.canvas_index;
+		ge2d_config->src2_para.format = tmp.ge2d_color_index;
+
+		ge2d_log_dbg("ge2d: src2-->type: osd%d, format: 0x%x !!\n",
+			     ge2d_config->src2_para.mem_type - CANVAS_OSD0,
+			     ge2d_config->src2_para.format);
+
+		top = ge2d_config->src2_para.top;
+		left = ge2d_config->src2_para.left;
+		width = ge2d_config->src2_para.width;
+		height = ge2d_config->src2_para.height;
+		if ((left + width > tmp.xres) || (top + height > tmp.yres)) {
+			ge2d_log_dbg("ge2d error: src2: osd%d, out of range\n",
+				ge2d_config->src2_para.mem_type - CANVAS_OSD0);
+			return -1;
+		}
+		ge2d_config->src2_para.width = tmp.xres;
+		ge2d_config->src2_para.height = tmp.yres;
+		break;
+	case  CANVAS_ALLOC:
+		top = ge2d_config->src2_para.top;
+		left = ge2d_config->src2_para.left;
+		width = ge2d_config->src2_para.width;
+		height = ge2d_config->src2_para.height;
+		if ((left + width > ge2d_config->src2_planes[0].w)
+		    || (top + height > ge2d_config->src2_planes[0].h)) {
+			ge2d_log_dbg("ge2d error: src2: alloc, out of range\n");
+			return -1;
+		}
+		/*if (ge2d_config->src2_planes[0].addr ==
+		 *		ge2d_config->src_planes[0].addr)
+		 *	index = ge2d_config->src_para.canvas_index;
+		 * else
+		*/
+		if (build_ge2d_config_ex_ion(&ge2d_config->src2_planes[0],
+				      ge2d_config->src2_para.format,
+				      &index,
+				      ALLOC_CANVAS_INDEX + alloc_canvas_offset,
+				      &alloc_canvas_offset) < 0)
+			return -1;
+		ge2d_config->src2_para.canvas_index = index;
+		ge2d_log_dbg("ge2d src2 alloc, canvas index:0x%x,format:0x%x\n",
+			     index, ge2d_config->src2_para.format);
+		break;
+	default:
+		break;
+	}
+
+	switch (ge2d_config->dst_para.mem_type) {
+	case  CANVAS_OSD0:
+	case  CANVAS_OSD1:
+		if (setup_display_property(&tmp,
+			(ge2d_config->dst_para.mem_type == CANVAS_OSD0) ?
+			OSD1_CANVAS_INDEX : OSD2_CANVAS_INDEX) < 0)
+			return -1;
+		ge2d_config->dst_para.canvas_index = tmp.canvas_index;
+		ge2d_config->dst_para.format = tmp.ge2d_color_index;
+
+		ge2d_log_dbg("ge2d: dst-->type: osd%d, format: 0x%x !!\n",
+			     ge2d_config->dst_para.mem_type - CANVAS_OSD0,
+			     ge2d_config->dst_para.format);
+
+		top = ge2d_config->dst_para.top;
+		left = ge2d_config->dst_para.left;
+		width = ge2d_config->dst_para.width;
+		height = ge2d_config->dst_para.height;
+		if ((left + width > tmp.xres) || (top + height > tmp.yres)) {
+			ge2d_log_dbg("ge2d error: dst: osd%d, out of range\n",
+				ge2d_config->dst_para.mem_type - CANVAS_OSD0);
+			return -1;
+		}
+		ge2d_config->dst_para.width = tmp.xres;
+		ge2d_config->dst_para.height = tmp.yres;
+		break;
+	case  CANVAS_ALLOC:
+		top = ge2d_config->dst_para.top;
+		left = ge2d_config->dst_para.left;
+		width = ge2d_config->dst_para.width;
+		height = ge2d_config->dst_para.height;
+		if ((left + width > ge2d_config->dst_planes[0].w)
+		    || (top + height > ge2d_config->dst_planes[0].h)) {
+			ge2d_log_dbg("ge2d error: dst: alloc, out of range\n");
+			return -1;
+		}
+		/*if (ge2d_config->dst_planes[0].addr ==
+		 *		ge2d_config->src_planes[0].addr)
+		 *	index = ge2d_config->src_para.canvas_index;
+		 * else if (ge2d_config->dst_planes[0].addr ==
+		 *		ge2d_config->src2_planes[0].addr)
+		 *	index = ge2d_config->src2_para.canvas_index;
+		 * else
+		*/
+		if (build_ge2d_config_ex_ion(&ge2d_config->dst_planes[0],
+				      ge2d_config->dst_para.format,
+				      &index,
+				      ALLOC_CANVAS_INDEX + alloc_canvas_offset,
+				      &alloc_canvas_offset) < 0)
+			return -1;
+		ge2d_config->dst_para.canvas_index = index;
+		ge2d_log_dbg("ge2d: dst alloc, index:0x%x, format:0x%x\n",
+			     index, ge2d_config->dst_para.format);
+		break;
+	default:
+		break;
+	}
+
+	ge2dgen_rendering_dir(context, ge2d_config->src_para.x_rev,
+			      ge2d_config->src_para.y_rev,
+			      ge2d_config->dst_para.x_rev,
+			      ge2d_config->dst_para.y_rev,
+			      ge2d_config->dst_xy_swap);
+	ge2dgen_const_color(context, ge2d_config->alu_const_color);
+
+	ge2dgen_src(context, ge2d_config->src_para.canvas_index,
+		    ge2d_config->src_para.format);
+	ge2dgen_src_clip(context, ge2d_config->src_para.left,
+			ge2d_config->src_para.top,
+			ge2d_config->src_para.width,
+			ge2d_config->src_para.height);
+	ge2dgen_src_key(context, ge2d_config->src_key.key_enable,
+			ge2d_config->src_key.key_color,
+			ge2d_config->src_key.key_mask,
+			ge2d_config->src_key.key_mode);
+
+	ge2dgent_src_gbalpha(context, ge2d_config->src1_gb_alpha);
+	ge2dgen_src_color(context, ge2d_config->src_para.color);
+
+	ge2dgen_src2(context, ge2d_config->src2_para.canvas_index,
+		     ge2d_config->src2_para.format);
+	ge2dgen_src2_clip(context, ge2d_config->src2_para.left,
+			  ge2d_config->src2_para.top,
+			  ge2d_config->src2_para.width,
+			  ge2d_config->src2_para.height);
+
+	ge2dgen_dst(context, ge2d_config->dst_para.canvas_index,
+		    ge2d_config->dst_para.format);
+	ge2dgen_dst_clip(context, ge2d_config->dst_para.left,
+			 ge2d_config->dst_para.top,
+			 ge2d_config->dst_para.width,
+			 ge2d_config->dst_para.height,
+			 DST_CLIP_MODE_INSIDE);
+
+	src1_gen_cfg = ge2d_wq_get_src_gen(context);
+	src1_gen_cfg->fill_mode = ge2d_config->src_para.fill_mode;
+	src1_gen_cfg->chfmt_rpt_pix = 0;
+	src1_gen_cfg->cvfmt_rpt_pix = 0;
+	/* src1_gen_cfg->clipx_start_ex = 0; */
+	/* src1_gen_cfg->clipx_end_ex = 1; */
+	/* src1_gen_cfg->clipy_start_ex = 1; */
+	/* src1_gen_cfg->clipy_end_ex = 1; */
+
+	src2_dst_data_cfg = ge2d_wq_get_dst_data(context);
+	src2_dst_data_cfg->src2_def_color = ge2d_config->src2_para.color;
+
+	src2_dst_gen_cfg = ge2d_wq_get_dst_gen(context);
+	src2_dst_gen_cfg->src2_fill_mode = ge2d_config->src2_para.fill_mode;
+
+	dp_gen_cfg = ge2d_wq_get_dp_gen(context);
+
+	dp_gen_cfg->src1_vsc_phase0_always_en =
+		ge2d_config->src1_hsc_phase0_always_en;
+	dp_gen_cfg->src1_hsc_phase0_always_en =
+		ge2d_config->src1_vsc_phase0_always_en;
+	/* 1bit, 0: using minus, 1: using repeat data */
+	dp_gen_cfg->src1_hsc_rpt_ctrl = ge2d_config->src1_hsc_rpt_ctrl;
+	/* 1bit, 0: using minus  1: using repeat data */
+	dp_gen_cfg->src1_vsc_rpt_ctrl = ge2d_config->src1_vsc_rpt_ctrl;
+
+	dp_gen_cfg->src2_key_en = ge2d_config->src2_key.key_enable;
+	dp_gen_cfg->src2_key_mode = ge2d_config->src2_key.key_mode;
+	dp_gen_cfg->src2_key =   ge2d_config->src2_key.key_color;
+	dp_gen_cfg->src2_key_mask = ge2d_config->src2_key.key_mask;
+
+	dp_gen_cfg->bitmask_en = ge2d_config->bitmask_en;
+	dp_gen_cfg->bitmask = ge2d_config->bitmask;
+	dp_gen_cfg->bytemask_only = ge2d_config->bytemask_only;
+
+	ge2d_cmd_cfg = ge2d_wq_get_cmd(context);
+
+	ge2d_cmd_cfg->src1_fill_color_en = ge2d_config->src_para.fill_color_en;
+
+	ge2d_cmd_cfg->src2_x_rev = ge2d_config->src2_para.x_rev;
+	ge2d_cmd_cfg->src2_y_rev = ge2d_config->src2_para.y_rev;
+	ge2d_cmd_cfg->src2_fill_color_en =
+		ge2d_config->src2_para.fill_color_en;
+
+	ge2d_cmd_cfg->vsc_phase_slope = ge2d_config->vsc_phase_slope;
+	ge2d_cmd_cfg->vsc_ini_phase = ge2d_config->vf_init_phase;
+	ge2d_cmd_cfg->vsc_phase_step = ge2d_config->vsc_start_phase_step;
+	ge2d_cmd_cfg->vsc_rpt_l0_num = ge2d_config->vf_rpt_num;
+
+	/* let internal decide */
+	ge2d_cmd_cfg->hsc_phase_slope = ge2d_config->hsc_phase_slope;
+	ge2d_cmd_cfg->hsc_ini_phase = ge2d_config->hf_init_phase;
+	ge2d_cmd_cfg->hsc_phase_step = ge2d_config->hsc_start_phase_step;
+	ge2d_cmd_cfg->hsc_rpt_p0_num = ge2d_config->hf_rpt_num;
+
+	ge2d_cmd_cfg->src1_cmult_asel = 0;
+	ge2d_cmd_cfg->src2_cmult_asel = 0;
+	context->config.update_flag = UPDATE_ALL;
+	/* context->config.src1_data.ddr_burst_size_y = 3; */
+	/* context->config.src1_data.ddr_burst_size_cb = 3; */
+	/* context->config.src1_data.ddr_burst_size_cr = 3; */
+	/* context->config.src2_dst_data.ddr_burst_size= 3; */
+
+	return  0;
+}
+
 struct ge2d_context_s *create_ge2d_work_queue(void)
 {
 	int  i;
@@ -1006,6 +1455,7 @@ struct ge2d_context_s *create_ge2d_work_queue(void)
 	ge2d_work_queue = kzalloc(sizeof(struct ge2d_context_s), GFP_KERNEL);
 	ge2d_work_queue->config.h_scale_coef_type = FILTER_TYPE_BILINEAR;
 	ge2d_work_queue->config.v_scale_coef_type = FILTER_TYPE_BILINEAR;
+	ge2d_work_queue->ge2d_request_exit = 0;
 	if (IS_ERR(ge2d_work_queue)) {
 		ge2d_log_err("can't create work queue\n");
 		return NULL;
@@ -1048,9 +1498,10 @@ int  destroy_ge2d_work_queue(struct ge2d_context_s *ge2d_work_queue)
 		spin_unlock(&ge2d_manager.event.sem_lock);
 		if ((ge2d_manager.current_wq == ge2d_work_queue) &&
 		    (ge2d_manager.ge2d_state == GE2D_STATE_RUNNING)) {
-			ge2d_manager.ge2d_state = GE2D_STATE_REMOVING_WQ;
-			wait_for_completion(
-				&ge2d_manager.event.process_complete);
+			ge2d_work_queue->ge2d_request_exit = 1;
+			wait_for_completion_timeout(
+				&ge2d_manager.event.process_complete,
+				msecs_to_jiffies(500));
 			/* condition so complex ,simplify it . */
 			ge2d_manager.last_wq = NULL;
 		} /* else we can delete it safely. */
diff --git a/drivers/amlogic/display/ge2d/ge2d_wq.h b/drivers/amlogic/display/ge2d/ge2d_wq.h
index 13a2513..b84a067 100644
--- a/drivers/amlogic/display/ge2d/ge2d_wq.h
+++ b/drivers/amlogic/display/ge2d/ge2d_wq.h
@@ -17,7 +17,11 @@
 
 #ifndef _GE2D_WQ_H_
 #define _GE2D_WQ_H_
+#ifdef CONFIG_AMLOGIC_ION
+#include <ion/ion.h>
 
+extern struct ion_client *ge2d_ion_client;
+#endif
 extern ssize_t work_queue_status_show(struct class *cla,
 		struct class_attribute *attr, char *buf);
 
diff --git a/drivers/amlogic/display/ge2d/ge2dgen.c b/drivers/amlogic/display/ge2d/ge2dgen.c
index ce84f05..3440ce5 100644
--- a/drivers/amlogic/display/ge2d/ge2dgen.c
+++ b/drivers/amlogic/display/ge2d/ge2dgen.c
@@ -42,6 +42,11 @@ static inline void _set_src1_format(struct ge2d_src1_data_s *src1_data_cfg,
 	src1_data_cfg->x_yc_ratio  = (format_src >> 1) & 1;
 	src1_data_cfg->y_yc_ratio  = (format_src >> 0) & 1;
 
+	if (format_src & GE2D_FORMAT_DEEP_COLOR)
+		src1_data_cfg->deep_color = 1;
+	else
+		src1_data_cfg->deep_color = 0;
+
 	if ((format_src & GE2D_FORMAT_YUV) &&
 	    ((format_dst & GE2D_FORMAT_YUV) == 0)) {
 		dp_gen_cfg->use_matrix_default =
@@ -50,7 +55,9 @@ static inline void _set_src1_format(struct ge2d_src1_data_s *src1_data_cfg,
 		dp_gen_cfg->conv_matrix_en = 1;
 	} else if (((format_src & GE2D_FORMAT_YUV) == 0) &&
 		   (format_dst & GE2D_FORMAT_YUV)) {
-		dp_gen_cfg->use_matrix_default = MATRIX_RGB_TO_YCC;
+		dp_gen_cfg->use_matrix_default =
+			(format_dst & GE2D_FORMAT_COMP_RANGE) ?
+			MATRIX_RGB_TO_YCC : MATRIX_RGB_TO_FULL_RANGE_YCC;
 		dp_gen_cfg->conv_matrix_en = 1;
 	} else
 		dp_gen_cfg->conv_matrix_en = 0;
@@ -99,7 +106,9 @@ static inline void _set_dst_format(
 		dp_gen_cfg->conv_matrix_en = 1;
 	} else if (((format_src & GE2D_FORMAT_YUV) == 0) &&
 		   (format_dst & GE2D_FORMAT_YUV)) {
-		dp_gen_cfg->use_matrix_default = MATRIX_RGB_TO_YCC;
+		dp_gen_cfg->use_matrix_default =
+			(format_dst & GE2D_FORMAT_COMP_RANGE) ?
+			MATRIX_RGB_TO_YCC : MATRIX_RGB_TO_FULL_RANGE_YCC;
 		dp_gen_cfg->conv_matrix_en = 1;
 	} else
 		dp_gen_cfg->conv_matrix_en = 0;
diff --git a/drivers/amlogic/display/lcd/lcd_clk_config.c b/drivers/amlogic/display/lcd/lcd_clk_config.c
index 27a0350..bf7fb5d 100644
--- a/drivers/amlogic/display/lcd/lcd_clk_config.c
+++ b/drivers/amlogic/display/lcd/lcd_clk_config.c
@@ -104,7 +104,7 @@ static char *lcd_pll_ss_table_gxtvbb[] = {
 static char *lcd_pll_ss_table_txl[] = {
 	"0, disable",
 	"1, +/-0.3%",
-	"2, +/-0.5%",
+	"2, +/-0.4%",
 	"3, +/-0.9%",
 	"4, +/-1.2%",
 };
@@ -434,6 +434,11 @@ static void lcd_set_pll_ss_m8(struct lcd_clk_config_s *cConf)
 		lcd_pll_ss_table_m8[cConf->ss_level]);
 }
 
+static void lcd_pll_reset_m8(void)
+{
+	LCDPR("%s: to do\n", __func__);
+}
+
 static void lcd_set_pll_m8(struct lcd_clk_config_s *cConf)
 {
 	unsigned int pll_reg;
@@ -543,6 +548,11 @@ static void lcd_set_pll_ss_m8b(struct lcd_clk_config_s *cConf)
 		lcd_pll_ss_table_m8b[cConf->ss_level]);
 }
 
+static void lcd_pll_reset_m8b(void)
+{
+	LCDPR("%s: to do\n", __func__);
+}
+
 static void lcd_set_pll_m8b(struct lcd_clk_config_s *cConf)
 {
 	unsigned int pll_reg;
@@ -703,6 +713,11 @@ static void lcd_set_pll_ss_g9tv(struct lcd_clk_config_s *cConf)
 		lcd_pll_ss_table_g9tv[cConf->ss_level]);
 }
 
+static void lcd_pll_reset_g9tv(void)
+{
+	LCDPR("%s: to do\n", __func__);
+}
+
 static void lcd_set_pll_g9tv(struct lcd_clk_config_s *cConf)
 {
 	unsigned int pll_ctrl, pll_ctrl2;
@@ -758,6 +773,11 @@ static void lcd_set_pll_ss_g9bb(struct lcd_clk_config_s *cConf)
 		lcd_pll_ss_table_g9bb[cConf->ss_level]);
 }
 
+static void lcd_pll_reset_g9bb(void)
+{
+	LCDPR("%s: to do\n", __func__);
+}
+
 static void lcd_set_pll_g9bb(struct lcd_clk_config_s *cConf)
 {
 	unsigned int pll_ctrl, pll_ctrl2;
@@ -877,6 +897,13 @@ static void lcd_set_pll_ss_gxtvbb(struct lcd_clk_config_s *cConf)
 		lcd_pll_ss_table_gxtvbb[cConf->ss_level]);
 }
 
+static void lcd_pll_reset_gxtvbb(void)
+{
+	lcd_hiu_setb(HHI_HDMI_PLL_CNTL, 1, LCD_PLL_RST_GXTVBB, 1);
+	udelay(10);
+	lcd_hiu_setb(HHI_HDMI_PLL_CNTL, 0, LCD_PLL_RST_GXTVBB, 1);
+}
+
 static void lcd_set_pll_gxtvbb(struct lcd_clk_config_s *cConf)
 {
 	unsigned int pll_ctrl, pll_ctrl2;
@@ -927,7 +954,52 @@ static void lcd_update_pll_frac_gxtvbb(struct lcd_clk_config_s *cConf)
 
 static void lcd_set_pll_ss_txl(struct lcd_clk_config_s *cConf)
 {
-	/* to do */
+	unsigned int pll_ctrl3, pll_ctrl4;
+
+	pll_ctrl3 = lcd_hiu_read(HHI_HDMI_PLL_CNTL3);
+	pll_ctrl4 = lcd_hiu_read(HHI_HDMI_PLL_CNTL4);
+
+	switch (cConf->ss_level) {
+	case 1: /* +/- 0.3% */
+		pll_ctrl3 &= ~(0xf << 10);
+		pll_ctrl3 |= ((1 << 14) | (0xc << 10));
+		pll_ctrl4 &= ~(0x3 << 2);
+		break;
+	case 2: /* +/- 0.4% */
+		pll_ctrl3 &= ~(0xf << 10);
+		pll_ctrl3 |= ((1 << 14) | (0x8 << 10));
+		pll_ctrl4 &= ~(0x3 << 2);
+		pll_ctrl4 |= (0x1 << 2);
+		break;
+	case 3: /* +/- 0.9% */
+		pll_ctrl3 &= ~(0xf << 10);
+		pll_ctrl3 |= ((1 << 14) | (0xc << 10));
+		pll_ctrl4 &= ~(0x3 << 2);
+		pll_ctrl4 |= (0x2 << 2);
+		break;
+	case 4: /* +/- 1.2% */
+		pll_ctrl3 &= ~(0xf << 10);
+		pll_ctrl3 |= ((1 << 14) | (0xc << 10));
+		pll_ctrl4 &= ~(0x3 << 2);
+		pll_ctrl4 |= (0x3 << 2);
+		break;
+	default: /* disable */
+		pll_ctrl3 &= ~((0xf << 10) | (1 << 14));
+		pll_ctrl4 &= ~(0x3 << 2);
+		break;
+	}
+	lcd_hiu_write(HHI_HDMI_PLL_CNTL3, pll_ctrl3);
+	lcd_hiu_write(HHI_HDMI_PLL_CNTL4, pll_ctrl4);
+
+	LCDPR("set pll spread spectrum: %s\n",
+		lcd_pll_ss_table_txl[cConf->ss_level]);
+}
+
+static void lcd_pll_reset_txl(void)
+{
+	lcd_hiu_setb(HHI_HDMI_PLL_CNTL, 1, LCD_PLL_RST_TXL, 1);
+	udelay(10);
+	lcd_hiu_setb(HHI_HDMI_PLL_CNTL, 0, LCD_PLL_RST_TXL, 1);
 }
 
 static void lcd_set_pll_txl(struct lcd_clk_config_s *cConf)
@@ -942,7 +1014,7 @@ static void lcd_set_pll_txl(struct lcd_clk_config_s *cConf)
 		(cConf->pll_m << LCD_PLL_M_TXL));
 	pll_ctrl2 = 0x800ca000;
 	pll_ctrl2 |= ((1 << 12) | (cConf->pll_frac << 0));
-	pll_ctrl3 = 0x860730c4;
+	pll_ctrl3 = 0xc60330c4; /* bit[30]: od_fb */
 	pll_ctrl3 |= ((cConf->pll_od3_sel << LCD_PLL_OD3_TXL) |
 		(cConf->pll_od2_sel << LCD_PLL_OD2_TXL) |
 		(cConf->pll_od1_sel << LCD_PLL_OD1_TXL));
@@ -1950,7 +2022,8 @@ static int check_pll_txl(struct lcd_clk_config_s *cConf,
 				}
 				cConf->pll_fvco = pll_fvco;
 				n = 1;
-				od_fb = 0; /* pll default */
+				/* update od_fb to 1 for ss width */
+				od_fb = 1; /* pll default */
 				pll_fvco = pll_fvco / od_fb_table[od_fb];
 				m = pll_fvco / cConf->fin;
 				pll_frac = (pll_fvco % cConf->fin) *
@@ -2146,7 +2219,7 @@ static void lcd_pll_frac_generate_txl(struct lcd_config_s *pconf)
 		LCDPR("%s pll_fvco=%d\n", __func__, pll_fvco);
 
 	cConf->pll_fvco = pll_fvco;
-	od_fb = 0; /* pll default */
+	od_fb = 1; /* pll default */
 	pll_fvco = pll_fvco / od_fb_table[od_fb];
 	temp = cConf->fin * m / n;
 	if (pll_fvco >= temp) {
@@ -2265,6 +2338,52 @@ void lcd_set_spread_spectrum(void)
 	spin_unlock_irqrestore(&lcd_clk_lock, flags);
 }
 
+int lcd_encl_clk_msr(void)
+{
+	unsigned int clk_mux;
+	int encl_clk = 0;
+
+	clk_mux = 9;
+	encl_clk = meson_clk_measure(clk_mux);
+
+	return encl_clk;
+}
+
+void lcd_pll_reset(void)
+{
+	unsigned long flags = 0;
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
+	spin_lock_irqsave(&lcd_clk_lock, flags);
+	LCDPR("%s\n", __func__);
+
+	switch (lcd_drv->chip_type) {
+	case LCD_CHIP_M8:
+	case LCD_CHIP_M8M2:
+		lcd_pll_reset_m8();
+		break;
+	case LCD_CHIP_M8B:
+		lcd_pll_reset_m8b();
+		break;
+	case LCD_CHIP_G9TV:
+		lcd_pll_reset_g9tv();
+		break;
+	case LCD_CHIP_G9BB:
+		lcd_pll_reset_g9bb();
+		break;
+	case LCD_CHIP_GXTVBB:
+		lcd_pll_reset_gxtvbb();
+		break;
+	case LCD_CHIP_TXL:
+		lcd_pll_reset_txl();
+		break;
+	default:
+		break;
+	}
+
+	spin_unlock_irqrestore(&lcd_clk_lock, flags);
+}
+
 /* for frame rate change */
 void lcd_clk_update(struct lcd_config_s *pconf)
 {
diff --git a/drivers/amlogic/display/lcd/lcd_clk_config.h b/drivers/amlogic/display/lcd/lcd_clk_config.h
index be110c3..51640fc 100644
--- a/drivers/amlogic/display/lcd/lcd_clk_config.h
+++ b/drivers/amlogic/display/lcd/lcd_clk_config.h
@@ -315,10 +315,14 @@ enum div_sel_e {
 #define CRT_VID_CLK_IN_MAX_TXL      (3100 * 1000)
 #define ENCL_CLK_IN_MAX_TXL         (620 * 1000)
 
+extern int meson_clk_measure(unsigned int clk_mux);
 
 extern struct lcd_clk_config_s *get_lcd_clk_config(void);
 extern void lcd_clk_config_print(void);
 
+extern int lcd_encl_clk_msr(void);
+extern void lcd_pll_reset(void);
+
 extern char *lcd_get_spread_spectrum(void);
 extern void lcd_set_spread_spectrum(void);
 extern void lcd_clk_update(struct lcd_config_s *pconf);
diff --git a/drivers/amlogic/display/lcd/lcd_common.c b/drivers/amlogic/display/lcd/lcd_common.c
index 5f916a5..ad3c0d9 100644
--- a/drivers/amlogic/display/lcd/lcd_common.c
+++ b/drivers/amlogic/display/lcd/lcd_common.c
@@ -26,6 +26,9 @@
 #include <linux/io.h>
 #include <linux/of.h>
 #include <linux/reset.h>
+#ifdef CONFIG_AML_VPU
+#include <linux/amlogic/vpu.h>
+#endif
 #include <linux/amlogic/vout/lcd_vout.h>
 #include <linux/amlogic/vout/lcd_notify.h>
 #include <linux/amlogic/vout/lcd_unifykey.h>
@@ -315,6 +318,72 @@ void lcd_vbyone_pinmux_set(int status)
 #endif
 }
 
+unsigned int lcd_lvds_channel_on_value(struct lcd_config_s *pconf)
+{
+	unsigned int channel_on = 0;
+
+	if (pconf->lcd_control.lvds_config->dual_port == 0) {
+		if (pconf->lcd_control.lvds_config->lane_reverse == 0) {
+			switch (pconf->lcd_basic.lcd_bits) {
+			case 6:
+				channel_on = 0xf;
+				break;
+			case 8:
+				channel_on = 0x1f;
+				break;
+			case 10:
+			default:
+				channel_on = 0x3f;
+				break;
+			}
+		} else {
+			switch (pconf->lcd_basic.lcd_bits) {
+			case 6:
+				channel_on = 0x3c;
+				break;
+			case 8:
+				channel_on = 0x3e;
+				break;
+			case 10:
+			default:
+				channel_on = 0x3f;
+				break;
+			}
+		}
+		if (pconf->lcd_control.lvds_config->port_swap == 1)
+			channel_on = (channel_on << 6); /* use channel B */
+	} else {
+		if (pconf->lcd_control.lvds_config->lane_reverse == 0) {
+			switch (pconf->lcd_basic.lcd_bits) {
+			case 6:
+				channel_on = 0x3cf;
+				break;
+			case 8:
+				channel_on = 0x7df;
+				break;
+			case 10:
+			default:
+				channel_on = 0xfff;
+				break;
+			}
+		} else {
+			switch (pconf->lcd_basic.lcd_bits) {
+			case 6:
+				channel_on = 0xf3c;
+				break;
+			case 8:
+				channel_on = 0xfbe;
+				break;
+			case 10:
+			default:
+				channel_on = 0xfff;
+				break;
+			}
+		}
+	}
+	return channel_on;
+}
+
 int lcd_power_load_from_dts(struct lcd_config_s *pconf,
 		struct device_node *child)
 {
@@ -337,6 +406,7 @@ int lcd_power_load_from_dts(struct lcd_config_s *pconf,
 	} else {
 		i = 0;
 		while (i < LCD_PWR_STEP_MAX) {
+			lcd_power->power_on_step_max = i;
 			j = 4 * i;
 			ret = of_property_read_u32_index(child, "power_on_step",
 				j, &val);
@@ -387,6 +457,7 @@ int lcd_power_load_from_dts(struct lcd_config_s *pconf,
 	} else {
 		i = 0;
 		while (i < LCD_PWR_STEP_MAX) {
+			lcd_power->power_off_step_max = i;
 			j = 4 * i;
 			ret = of_property_read_u32_index(child,
 				"power_off_step", j, &val);
@@ -442,20 +513,20 @@ int lcd_power_load_from_dts(struct lcd_config_s *pconf,
 }
 
 int lcd_power_load_from_unifykey(struct lcd_config_s *pconf,
-		unsigned char *buf, int key_len)
+		unsigned char *buf, int key_len, int len)
 {
-	int i, len;
+	int i;
 	unsigned char *p;
 	unsigned int index;
 	int ret;
 
-	len = 10 + 36 + 18 + 31 + 20;
 	/* power: (5byte * n) */
 	p = buf + len;
-	i = 0;
 	if (lcd_debug_print_flag)
 		LCDPR("power_on step:\n");
+	i = 0;
 	while (i < LCD_PWR_STEP_MAX) {
+		pconf->lcd_power->power_on_step_max = i;
 		len += 5;
 		ret = lcd_unifykey_len_check(key_len, len);
 		if (ret < 0) {
@@ -463,6 +534,7 @@ int lcd_power_load_from_unifykey(struct lcd_config_s *pconf,
 			pconf->lcd_power->power_on_step[i].index = 0;
 			pconf->lcd_power->power_on_step[i].value = 0;
 			pconf->lcd_power->power_on_step[i].delay = 0;
+			LCDERR("unifykey power_on length is incorrect\n");
 			return -1;
 		}
 		pconf->lcd_power->power_on_step[i].type = *p;
@@ -499,10 +571,12 @@ int lcd_power_load_from_unifykey(struct lcd_config_s *pconf,
 			i++;
 		}
 	}
-	i = 0;
+
 	if (lcd_debug_print_flag)
 		LCDPR("power_off step:\n");
+	i = 0;
 	while (i < LCD_PWR_STEP_MAX) {
+		pconf->lcd_power->power_off_step_max = i;
 		len += 5;
 		ret = lcd_unifykey_len_check(key_len, len);
 		if (ret < 0) {
@@ -510,6 +584,7 @@ int lcd_power_load_from_unifykey(struct lcd_config_s *pconf,
 			pconf->lcd_power->power_off_step[i].index = 0;
 			pconf->lcd_power->power_off_step[i].value = 0;
 			pconf->lcd_power->power_off_step[i].delay = 0;
+			LCDERR("unifykey power_off length is incorrect\n");
 			return -1;
 		}
 		pconf->lcd_power->power_off_step[i].type = *p;
@@ -550,6 +625,31 @@ int lcd_power_load_from_unifykey(struct lcd_config_s *pconf,
 	return 0;
 }
 
+void lcd_hdr_vinfo_update(void)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct lcd_config_s *pconf;
+	struct master_display_info_s *hdr_vinfo;
+
+	pconf = lcd_drv->lcd_config;
+	hdr_vinfo = &lcd_drv->lcd_info->master_display_info;
+	hdr_vinfo->present_flag = pconf->hdr_info.hdr_support;
+	hdr_vinfo->features = pconf->hdr_info.features;
+	hdr_vinfo->primaries[0][0] = pconf->hdr_info.primaries_g_x;
+	hdr_vinfo->primaries[0][1] = pconf->hdr_info.primaries_g_y;
+	hdr_vinfo->primaries[1][0] = pconf->hdr_info.primaries_b_x;
+	hdr_vinfo->primaries[1][1] = pconf->hdr_info.primaries_b_y;
+	hdr_vinfo->primaries[2][0] = pconf->hdr_info.primaries_r_x;
+	hdr_vinfo->primaries[2][1] = pconf->hdr_info.primaries_r_y;
+	hdr_vinfo->white_point[0] = pconf->hdr_info.white_point_x;
+	hdr_vinfo->white_point[1] = pconf->hdr_info.white_point_y;
+	hdr_vinfo->luminance[0] = pconf->hdr_info.luma_max;
+	hdr_vinfo->luminance[1] = pconf->hdr_info.luma_min;
+
+	lcd_drv->lcd_info->hdr_info.sink_flag = 1;
+	lcd_drv->lcd_info->hdr_info.lumi_max = pconf->hdr_info.luma_max;
+}
+
 void lcd_tcon_config(struct lcd_config_s *pconf)
 {
 	unsigned short h_period, v_period, h_active, v_active;
@@ -566,8 +666,9 @@ void lcd_tcon_config(struct lcd_config_s *pconf)
 		h_delay = 0;
 		break;
 	}
-	h_period = pconf->lcd_basic.h_period;
-	v_period = pconf->lcd_basic.v_period;
+	/* use peroid_dft to avoid period changing offset */
+	h_period = pconf->lcd_timing.h_period_dft;
+	v_period = pconf->lcd_timing.v_period_dft;
 	h_active = pconf->lcd_basic.h_active;
 	v_active = pconf->lcd_basic.v_active;
 	hsync_bp = pconf->lcd_timing.hsync_bp;
@@ -800,8 +901,10 @@ int lcd_vmode_change(struct lcd_config_s *pconf)
 			(pclk / 1000000), ((pclk / 1000) % 1000));
 		pconf->lcd_timing.lcd_clk = pclk;
 	}
-	if (len > 0)
-		LCDPR("%s: %s\n", __func__, str);
+	if (lcd_debug_print_flag) {
+		if (len > 0)
+			LCDPR("%s: %s\n", __func__, str);
+	}
 
 	return 0;
 }
@@ -821,8 +924,11 @@ void lcd_venc_change(struct lcd_config_s *pconf)
 		lcd_vcbus_write(ENCL_VIDEO_MAX_LNCNT,
 			pconf->lcd_basic.v_period - 1);
 	}
-	LCDPR("venc changed: %d,%d\n",
-		pconf->lcd_basic.h_period, pconf->lcd_basic.v_period);
+	if (lcd_debug_print_flag) {
+		LCDPR("venc changed: %d,%d\n",
+			pconf->lcd_basic.h_period,
+			pconf->lcd_basic.v_period);
+	}
 
 	if (pconf->lcd_basic.v_period != vtotal)
 		aml_lcd_notifier_call_chain(LCD_EVENT_BACKLIGHT_UPDATE, NULL);
@@ -841,11 +947,17 @@ void lcd_clk_gate_switch(int status)
 			reset_control_deassert(pconf->rstc.encl);
 		if (pconf->rstc.vencl)
 			reset_control_deassert(pconf->rstc.vencl);
+#ifdef CONFIG_AML_VPU
+		switch_vpu_clk_gate_vmod(VPU_VENCL, VPU_CLK_GATE_ON);
+#endif
 	} else {
 		if (pconf->rstc.encl)
 			reset_control_assert(pconf->rstc.encl);
 		if (pconf->rstc.vencl)
 			reset_control_assert(pconf->rstc.vencl);
+#ifdef CONFIG_AML_VPU
+		switch_vpu_clk_gate_vmod(VPU_VENCL, VPU_CLK_GATE_OFF);
+#endif
 	}
 }
 
diff --git a/drivers/amlogic/display/lcd/lcd_common.h b/drivers/amlogic/display/lcd/lcd_common.h
index 01f014c..11afff7 100644
--- a/drivers/amlogic/display/lcd/lcd_common.h
+++ b/drivers/amlogic/display/lcd/lcd_common.h
@@ -25,6 +25,9 @@
 
 #define VPP_OUT_SATURATE            (1 << 0)
 
+extern struct mutex lcd_vout_mutex;
+extern unsigned char lcd_resume_flag;
+
 /* lcd common */
 extern int lcd_type_str_to_type(const char *str);
 extern char *lcd_type_type_to_str(int type);
@@ -36,11 +39,13 @@ extern void lcd_cpu_gpio_set(unsigned int index, int value);
 extern unsigned int lcd_cpu_gpio_get(unsigned int index);
 extern void lcd_ttl_pinmux_set(int status);
 extern void lcd_vbyone_pinmux_set(int status);
+extern unsigned int lcd_lvds_channel_on_value(struct lcd_config_s *pconf);
 extern int lcd_power_load_from_dts(struct lcd_config_s *pconf,
 		struct device_node *child);
 extern int lcd_power_load_from_unifykey(struct lcd_config_s *pconf,
-		unsigned char *buf, int key_len);
+		unsigned char *buf, int key_len, int len);
 
+extern void lcd_hdr_vinfo_update(void);
 extern void lcd_tcon_config(struct lcd_config_s *pconf);
 extern int lcd_vmode_change(struct lcd_config_s *pconf);
 extern void lcd_venc_change(struct lcd_config_s *pconf);
diff --git a/drivers/amlogic/display/lcd/lcd_debug.c b/drivers/amlogic/display/lcd/lcd_debug.c
index 0d4216d..eba1ac6 100644
--- a/drivers/amlogic/display/lcd/lcd_debug.c
+++ b/drivers/amlogic/display/lcd/lcd_debug.c
@@ -50,6 +50,9 @@ static const char *lcd_common_usage_str = {
 "    echo <cmd> ... > debug ; lcd common debug, use 'cat debug' for help\n"
 "    cat debug ; print help information for debug command\n"
 "\n"
+"    echo <on|off> <step_num> <delay> > power ; set power on/off step delay(unit: ms)\n"
+"    cat power ; print lcd power on/off step\n"
+"\n"
 "    cat key_valid ; print lcd_key_valid setting\n"
 "    cat config_load ; print lcd_config load_id(0=dts, 1=unifykey)\n"
 };
@@ -57,7 +60,8 @@ static const char *lcd_common_usage_str = {
 static const char *lcd_debug_usage_str = {
 "Usage:\n"
 "    echo clk <freq> > debug ; set lcd pixel clock, unit in Hz\n"
-"    echo basic <h_active> <v_active> <h_period> <v_period> > debug ; set lcd basic config\n"
+"    echo bit <lcd_bits> > debug ; set lcd bits\n"
+"    echo basic <h_active> <v_active> <h_period> <v_period> <lcd_bits> > debug ; set lcd basic config\n"
 "    echo sync <hs_width> <hs_bp> <hs_pol> <vs_width> <vs_bp> <vs_pol> > debug ; set lcd sync timing\n"
 "data format:\n"
 "    <xx_pol>       : 0=negative, 1=positive\n"
@@ -65,6 +69,8 @@ static const char *lcd_debug_usage_str = {
 "    echo info > debug ; show lcd infomation\n"
 "    echo reg > debug ; show lcd registers\n"
 "    echo dump > debug ; show lcd infomation & registers\n"
+"    echo key > debug ; show lcd_key_valid config, and lcd unifykey raw data\n"
+"\n"
 "    echo reset > debug; reset lcd driver\n"
 "    echo power <0|1> > debug ; lcd power control: 0=power off, 1=power on\n"
 };
@@ -216,6 +222,7 @@ static void lcd_info_print(void)
 			"dual_port         %u\n"
 			"pn_swap           %u\n"
 			"port_swap         %u\n"
+			"lane_reverse      %u\n"
 			"phy_vswing        %u\n"
 			"phy_preem         %u\n"
 			"phy_clk_vswing    %u\n"
@@ -224,6 +231,7 @@ static void lcd_info_print(void)
 			pconf->lcd_control.lvds_config->dual_port,
 			pconf->lcd_control.lvds_config->pn_swap,
 			pconf->lcd_control.lvds_config->port_swap,
+			pconf->lcd_control.lvds_config->lane_reverse,
 			pconf->lcd_control.lvds_config->phy_vswing,
 			pconf->lcd_control.lvds_config->phy_preem,
 			pconf->lcd_control.lvds_config->phy_clk_vswing,
@@ -236,14 +244,18 @@ static void lcd_info_print(void)
 			"color_fmt         %u\n"
 			"bit_rate          %u\n"
 			"phy_vswing        %u\n"
-			"phy_preemphasis   %u\n\n",
+			"phy_preemphasis   %u\n"
+			"intr_en           %u\n"
+			"vsync_intr_en     %u\n\n",
 			pconf->lcd_control.vbyone_config->lane_count,
 			pconf->lcd_control.vbyone_config->region_num,
 			pconf->lcd_control.vbyone_config->byte_mode,
 			pconf->lcd_control.vbyone_config->color_fmt,
 			pconf->lcd_control.vbyone_config->bit_rate,
-			pconf->lcd_control.lvds_config->phy_vswing,
-			pconf->lcd_control.lvds_config->phy_preem);
+			pconf->lcd_control.vbyone_config->phy_vswing,
+			pconf->lcd_control.vbyone_config->phy_preem,
+			pconf->lcd_control.vbyone_config->intr_en,
+			pconf->lcd_control.vbyone_config->vsync_intr_en);
 		break;
 	case LCD_MIPI:
 		dconf = pconf->lcd_control.mipi_config;
@@ -394,6 +406,9 @@ static void lcd_lvds_reg_print(void)
 	reg = LVDS_GEN_CNTL;
 	pr_info("LVDS_GEN_CNTL       [0x%04x] = 0x%08x\n",
 		reg, lcd_vcbus_read(reg));
+	reg = LCD_PORT_SWAP;
+	pr_info("LCD_PORT_SWAP       [0x%04x] = 0x%08x\n",
+		reg, lcd_vcbus_read(reg));
 	reg = HHI_LVDS_TX_PHY_CNTL0;
 	pr_info("LVDS_PHY_CNTL0      [0x%04x] = 0x%08x\n",
 		reg, lcd_hiu_read(reg));
@@ -491,6 +506,33 @@ static void lcd_reg_print(void)
 	}
 }
 
+static void lcd_hdr_info_print(void)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct lcd_config_s *pconf;
+
+	pconf = lcd_drv->lcd_config;
+	pr_info("lcd hdr info:\n"
+		"hdr_support          %d\n"
+		"features             %d\n"
+		"primaries_r_x        %d\n"
+		"primaries_r_y        %d\n"
+		"primaries_g_x        %d\n"
+		"primaries_g_y        %d\n"
+		"primaries_b_x        %d\n"
+		"primaries_b_y        %d\n"
+		"white_point_x        %d\n"
+		"white_point_y        %d\n"
+		"luma_max             %d\n"
+		"luma_min             %d\n\n",
+		pconf->hdr_info.hdr_support, pconf->hdr_info.features,
+		pconf->hdr_info.primaries_r_x, pconf->hdr_info.primaries_r_y,
+		pconf->hdr_info.primaries_g_x, pconf->hdr_info.primaries_g_y,
+		pconf->hdr_info.primaries_b_x, pconf->hdr_info.primaries_b_y,
+		pconf->hdr_info.white_point_x, pconf->hdr_info.white_point_y,
+		pconf->hdr_info.luma_max, pconf->hdr_info.luma_min);
+}
+
 #define LCD_ENC_TST_NUM_MAX    8
 static char *lcd_enc_tst_str[] = {
 	"0-None",        /* 0 */
@@ -515,10 +557,9 @@ static unsigned int lcd_enc_tst[][7] = {
 	{0,    0x074,   0x3fd,  0x1ad,   1,      0,        1},  /* 7 */
 };
 
-static void lcd_test(unsigned int num)
+static void lcd_debug_test(unsigned int num)
 {
-	unsigned int h_active;
-	unsigned int video_on_pixel;
+	unsigned int h_active, video_on_pixel;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	int flag;
 
@@ -544,6 +585,35 @@ static void lcd_test(unsigned int num)
 	}
 }
 
+static void lcd_test_check(void)
+{
+	unsigned int h_active, video_on_pixel;
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	unsigned int num;
+	int flag;
+
+	num = lcd_drv->lcd_test_flag;
+	num = (num >= LCD_ENC_TST_NUM_MAX) ? 0 : num;
+	flag = (num > 0) ? 1 : 0;
+	aml_lcd_notifier_call_chain(LCD_EVENT_TEST_PATTERN, &flag);
+
+	h_active = lcd_drv->lcd_config->lcd_basic.h_active;
+	video_on_pixel = lcd_drv->lcd_config->lcd_timing.video_on_pixel;
+	if (num >= 0) {
+		lcd_vcbus_write(ENCL_VIDEO_RGBIN_CTRL, lcd_enc_tst[num][6]);
+		lcd_vcbus_write(ENCL_TST_MDSEL, lcd_enc_tst[num][0]);
+		lcd_vcbus_write(ENCL_TST_Y, lcd_enc_tst[num][1]);
+		lcd_vcbus_write(ENCL_TST_CB, lcd_enc_tst[num][2]);
+		lcd_vcbus_write(ENCL_TST_CR, lcd_enc_tst[num][3]);
+		lcd_vcbus_write(ENCL_TST_CLRBAR_STRT, video_on_pixel);
+		lcd_vcbus_write(ENCL_TST_CLRBAR_WIDTH, (h_active / 9));
+		lcd_vcbus_write(ENCL_TST_EN, lcd_enc_tst[num][4]);
+		lcd_vcbus_setb(ENCL_VIDEO_MODE_ADV, lcd_enc_tst[num][5], 3, 1);
+		if (num > 0)
+			LCDPR("show test pattern: %s\n", lcd_enc_tst_str[num]);
+	}
+}
+
 static void lcd_debug_config_update(void)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
@@ -599,7 +669,7 @@ static ssize_t lcd_debug_store(struct class *class,
 
 	pconf = lcd_drv->lcd_config;
 	switch (buf[0]) {
-	case 'c':
+	case 'c': /* clk */
 		ret = sscanf(buf, "clk %d", &temp);
 		if (ret == 1) {
 			if (temp > 200) {
@@ -618,25 +688,50 @@ static ssize_t lcd_debug_store(struct class *class,
 		}
 		break;
 	case 'b':
-		ret = sscanf(buf, "basic %d %d %d %d",
-			&val[0], &val[1], &val[2], &val[3]);
-		if (ret == 4) {
-			pconf->lcd_basic.h_active = val[0];
-			pconf->lcd_basic.v_active = val[1];
-			pconf->lcd_basic.h_period = val[2];
-			pconf->lcd_basic.v_period = val[3];
-			pr_info("set h_active=%d, v_active=%d\n",
-				val[0], val[1]);
-			pr_info("set h_period=%d, v_period=%d\n",
-				val[2], val[3]);
-			lcd_tcon_config(pconf);
-			lcd_debug_config_update();
-		} else {
-			LCDERR("invalid data\n");
-			return -EINVAL;
+		if (buf[1] == 'a') { /* basic */
+			ret = sscanf(buf, "basic %d %d %d %d %d",
+				&val[0], &val[1], &val[2], &val[3], &val[4]);
+			if (ret == 4) {
+				pconf->lcd_basic.h_active = val[0];
+				pconf->lcd_basic.v_active = val[1];
+				pconf->lcd_basic.h_period = val[2];
+				pconf->lcd_basic.v_period = val[3];
+				pr_info("set h_active=%d, v_active=%d\n",
+					val[0], val[1]);
+				pr_info("set h_period=%d, v_period=%d\n",
+					val[2], val[3]);
+				lcd_tcon_config(pconf);
+				lcd_debug_config_update();
+			} else if (ret == 5) {
+				pconf->lcd_basic.h_active = val[0];
+				pconf->lcd_basic.v_active = val[1];
+				pconf->lcd_basic.h_period = val[2];
+				pconf->lcd_basic.v_period = val[3];
+				pconf->lcd_basic.lcd_bits = val[4];
+				pr_info("set h_active=%d, v_active=%d\n",
+					val[0], val[1]);
+				pr_info("set h_period=%d, v_period=%d\n",
+					val[2], val[3]);
+				pr_info("set lcd_bits=%d\n", val[4]);
+				lcd_tcon_config(pconf);
+				lcd_debug_config_update();
+			} else {
+				LCDERR("invalid data\n");
+				return -EINVAL;
+			}
+		} else if (buf[1] == 'i') { /* bit */
+			ret = sscanf(buf, "bit %d", &val[0]);
+			if (ret == 1) {
+				pconf->lcd_basic.lcd_bits = val[4];
+				pr_info("set lcd_bits=%d\n", val[4]);
+				lcd_debug_config_update();
+			} else {
+				LCDERR("invalid data\n");
+				return -EINVAL;
+			}
 		}
 		break;
-	case 's':
+	case 's': /* sync */
 		ret = sscanf(buf, "sync %d %d %d %d %d %d",
 			&val[0], &val[1], &val[2], &val[3], &val[4], &val[5]);
 		if (ret == 6) {
@@ -657,26 +752,27 @@ static ssize_t lcd_debug_store(struct class *class,
 			return -EINVAL;
 		}
 		break;
-	case 't':
+	case 't': /* test */
 		ret = sscanf(buf, "test %d", &temp);
 		if (ret == 1) {
-			lcd_test(temp);
+			lcd_drv->lcd_test_flag = (unsigned char)temp;
+			lcd_debug_test(temp);
 		} else {
 			LCDERR("invalid data\n");
 			return -EINVAL;
 		}
 		break;
-	case 'i':
+	case 'i': /* info */
 		LCDPR("driver version: %s\n", lcd_drv->version);
 		lcd_info_print();
 		break;
 	case 'r':
-		if (buf[2] == 'g') {
+		if (buf[2] == 'g') { /* reg */
 			LCDPR("driver version: %s\n", lcd_drv->version);
 			lcd_reg_print();
-		} else if (buf[2] == 's') {
+		} else if (buf[2] == 's') { /* reset */
 			lcd_drv->module_reset();
-		} else if (buf[2] == 'a') {
+		} else if (buf[2] == 'a') { /* range */
 			ret = sscanf(buf, "range %d %d %d %d %d %d",
 				&val[0], &val[1], &val[2], &val[3],
 				&val[4], &val[5]);
@@ -702,17 +798,28 @@ static ssize_t lcd_debug_store(struct class *class,
 			}
 		}
 		break;
-	case 'd':
+	case 'd': /* dump */
 		LCDPR("driver version: %s\n", lcd_drv->version);
 		lcd_info_print();
 		pr_info("\n");
 		lcd_reg_print();
+		pr_info("\n");
+		lcd_hdr_info_print();
+		break;
+	case 'k': /* key */
+		LCDPR("key_valid: %d, config_load: %d\n",
+			lcd_drv->lcd_key_valid, lcd_drv->lcd_config_load);
+		if (lcd_drv->lcd_key_valid)
+			lcd_unifykey_print();
 		break;
-	case 'p':
+	case 'h': /* hdr */
+		lcd_hdr_info_print();
+		break;
+	case 'p': /* power */
 		ret = sscanf(buf, "power %d", &temp);
 		if (ret == 1) {
 			LCDPR("power: %d\n", temp);
-			LCDPR("to do\n");
+			lcd_drv->power_tiny_ctrl(temp);
 		} else {
 			LCDERR("invalid data\n");
 			return -EINVAL;
@@ -747,6 +854,66 @@ static ssize_t lcd_debug_enable_store(struct class *class,
 	return count;
 }
 
+static ssize_t lcd_debug_power_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
+	lcd_power_info_print(lcd_drv->lcd_config, 1);
+	lcd_power_info_print(lcd_drv->lcd_config, 0);
+
+	return sprintf(buf, "\n");
+}
+
+static ssize_t lcd_debug_power_store(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	int ret = 0;
+	unsigned int i, delay;
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct lcd_power_ctrl_s *lcd_power;
+
+	lcd_power = lcd_drv->lcd_config->lcd_power;
+	switch (buf[1]) {
+	case 'n': /* on */
+		ret = sscanf(buf, "on %d %d", &i, &delay);
+		if (ret == 2) {
+			if (i >= lcd_power->power_on_step_max) {
+				pr_info("invalid power_on step: %d\n", i);
+				return -EINVAL;
+			}
+			lcd_power->power_on_step[i].delay = delay;
+			pr_info("set power_on step %d delay: %dms\n",
+				i, delay);
+		} else {
+			pr_info("invalid data\n");
+			return -EINVAL;
+		}
+		break;
+	case 'f': /* off */
+		ret = sscanf(buf, "off %d %d", &i, &delay);
+		if (ret == 1) {
+			if (i >= lcd_power->power_off_step_max) {
+				pr_info("invalid power_off step: %d\n", i);
+				return -EINVAL;
+			}
+			lcd_power->power_off_step[i].delay = delay;
+			pr_info("set power_off step %d delay: %dms\n",
+				i, delay);
+		} else {
+			pr_info("invalid data\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		pr_info("wrong command\n");
+		return -EINVAL;
+		break;
+	}
+
+	return count;
+}
+
 static ssize_t lcd_debug_frame_rate_show(struct class *class,
 		struct class_attribute *attr, char *buf)
 {
@@ -818,7 +985,7 @@ static ssize_t lcd_debug_fr_policy_store(struct class *class,
 
 	ret = sscanf(buf, "%d", &temp);
 	if (ret == 1) {
-		lcd_drv->fr_auto_policy = (unsigned char)temp;
+		lcd_drv->fr_auto_policy = temp;
 		pr_info("set fr_auto_policy: %d\n", temp);
 	} else {
 		pr_info("invalid data\n");
@@ -866,10 +1033,12 @@ static ssize_t lcd_debug_test_store(struct class *class,
 {
 	int ret = 0;
 	unsigned int temp = 0;
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 
 	ret = sscanf(buf, "%d", &temp);
 	if (ret == 1) {
-		lcd_test(temp);
+		lcd_drv->lcd_test_flag = (unsigned char)temp;
+		lcd_debug_test(temp);
 	} else {
 		pr_info("invalid data\n");
 		return -EINVAL;
@@ -1078,7 +1247,7 @@ static ssize_t lcd_debug_print_store(struct class *class,
 
 	ret = sscanf(buf, "%d", &temp);
 	if (ret == 1) {
-		lcd_debug_print_flag = temp;
+		lcd_debug_print_flag = (unsigned char)temp;
 		LCDPR("set debug print flag: %d\n", lcd_debug_print_flag);
 	} else {
 		pr_info("invalid data\n");
@@ -1088,33 +1257,12 @@ static ssize_t lcd_debug_print_store(struct class *class,
 	return count;
 }
 
-static ssize_t lcd_debug_key_show(struct class *class,
-		struct class_attribute *attr, char *buf)
-{
-	lcd_unifykey_print();
-	return sprintf(buf, "\n");
-}
-
-static ssize_t lcd_debug_key_valid_show(struct class *class,
-		struct class_attribute *attr, char *buf)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-
-	return sprintf(buf, "%d\n", lcd_drv->lcd_key_valid);
-}
-
-static ssize_t lcd_debug_config_load_show(struct class *class,
-		struct class_attribute *attr, char *buf)
-{
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-
-	return sprintf(buf, "%d\n", lcd_drv->lcd_config_load);
-}
-
 static struct class_attribute lcd_debug_class_attrs[] = {
 	__ATTR(help,        S_IRUGO | S_IWUSR, lcd_debug_common_help, NULL),
 	__ATTR(debug,       S_IRUGO | S_IWUSR, lcd_debug_show, lcd_debug_store),
 	__ATTR(enable,      S_IRUGO | S_IWUSR, NULL, lcd_debug_enable_store),
+	__ATTR(power,       S_IRUGO | S_IWUSR,
+		lcd_debug_power_show, lcd_debug_power_store),
 	__ATTR(frame_rate,  S_IRUGO | S_IWUSR,
 		lcd_debug_frame_rate_show, lcd_debug_frame_rate_store),
 	__ATTR(fr_policy,   S_IRUGO | S_IWUSR,
@@ -1126,10 +1274,6 @@ static struct class_attribute lcd_debug_class_attrs[] = {
 	__ATTR(reg,         S_IRUGO | S_IWUSR, NULL, lcd_debug_reg_store),
 	__ATTR(print,       S_IRUGO | S_IWUSR,
 		lcd_debug_print_show, lcd_debug_print_store),
-	__ATTR(key,         S_IRUGO | S_IWUSR, lcd_debug_key_show, NULL),
-	__ATTR(key_valid,   S_IRUGO | S_IWUSR, lcd_debug_key_valid_show, NULL),
-	__ATTR(config_load, S_IRUGO | S_IWUSR,
-		lcd_debug_config_load_show, NULL),
 };
 
 static const char *lcd_ttl_debug_usage_str = {
@@ -1146,12 +1290,13 @@ static const char *lcd_ttl_debug_usage_str = {
 
 static const char *lcd_lvds_debug_usage_str = {
 "Usage:\n"
-"    echo <repack> <dual_port> <pn_swap> <port_swap> > lvds ; set lvds config\n"
+"    echo <repack> <dual_port> <pn_swap> <port_swap> <lane_reverse> > lvds ; set lvds config\n"
 "data format:\n"
 "    <repack>    : 0=JEIDA mode, 1=VESA mode\n"
 "    <dual_port> : 0=single port, 1=dual port\n"
 "    <pn_swap>   : 0=normal, 1=swap p/n channels\n"
 "    <port_swap> : 0=normal, 1=swap A/B port\n"
+"	 <lane_reverse> : 0=normal, 1=swap A0-A4/B0-B4\n"
 "\n"
 "    echo <vswing> <preem> > phy ; set vbyone phy config\n"
 "data format:\n"
@@ -1174,6 +1319,15 @@ static const char *lcd_vbyone_debug_usage_str = {
 "    <preem>  : preemphasis level, support 0~7\n"
 "    <byte_mode>  : 3/4/5\n"
 "\n"
+"    echo intr <state> <en> > vbyone; enable or disable vbyone interrupt\n"
+"data format:\n"
+"    <state> : 0=temp no use intr, 1=temp use intr. keep effect until reset lcd driver\n"
+"    <en>    : 0=disable intr, 1=enable intr\n"
+"\n"
+"    echo vintr <en> > vbyone; enable or disable vbyone interrupt\n"
+"data format:\n"
+"    <en>    : 0=disable vsync monitor intr, 1=enable vsync monitor intr\n"
+"\n"
 };
 
 static const char *lcd_mipi_debug_usage_str = {
@@ -1218,13 +1372,6 @@ static ssize_t lcd_vx1_debug_show(struct class *class,
 	return sprintf(buf, "%s\n", lcd_vbyone_debug_usage_str);
 }
 
-static int lcd_vx1_intr_enable = 1;
-static ssize_t lcd_vx1_intr_debug_show(struct class *class,
-		struct class_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%d\n", lcd_vx1_intr_enable);
-}
-
 static ssize_t lcd_mipi_debug_show(struct class *class,
 		struct class_attribute *attr, char *buf)
 {
@@ -1243,15 +1390,19 @@ static ssize_t lcd_ttl_debug_store(struct class *class,
 	int ret = 0;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct ttl_config_s *ttl_conf;
+	unsigned int temp[5];
 
 	ttl_conf = lcd_drv->lcd_config->lcd_control.ttl_config;
-	ret = sscanf(buf, "%d %d %d", &ttl_conf->clk_pol,
-		&ttl_conf->sync_valid, &ttl_conf->swap_ctrl);
-	if (ret == 3) {
+	ret = sscanf(buf, "%d %d %d %d %d",
+		&temp[0], &temp[1], &temp[2], &temp[3], &temp[4]);
+	if (ret == 5) {
 		pr_info("set ttl config:\n"
-			"clk_pol=%d, sync_valid=0x%x, swap_ctrl=0x%x\n",
-			ttl_conf->clk_pol, ttl_conf->sync_valid,
-			ttl_conf->swap_ctrl);
+			"clk_pol=%d, de_valid=%d, de_valid=%d\n"
+			"rb_swap=%d, bit_swap=%d\n",
+			temp[0], temp[1], temp[2], temp[3], temp[4]);
+		ttl_conf->clk_pol = temp[0];
+		ttl_conf->sync_valid = ((temp[1] << 1) | temp[2]);
+		ttl_conf->swap_ctrl = ((temp[3] << 1) | temp[4]);
 		lcd_debug_config_update();
 	} else {
 		pr_info("invalid data\n");
@@ -1269,14 +1420,16 @@ static ssize_t lcd_lvds_debug_store(struct class *class,
 	struct lvds_config_s *lvds_conf;
 
 	lvds_conf = lcd_drv->lcd_config->lcd_control.lvds_config;
-	ret = sscanf(buf, "%d %d %d %d",
+	ret = sscanf(buf, "%d %d %d %d %d",
 		&lvds_conf->lvds_repack, &lvds_conf->dual_port,
-		&lvds_conf->pn_swap, &lvds_conf->port_swap);
-	if (ret == 4) {
+		&lvds_conf->pn_swap, &lvds_conf->port_swap,
+		&lvds_conf->lane_reverse);
+	if (ret == 5 || ret == 4) {
 		pr_info("set lvds config:\n"
-			"repack=%d, dual_port=%d, pn_swap=%d, port_swap=%d\n",
+			"repack=%d, dual_port=%d, pn_swap=%d, port_swap=%d, lane_reverse=%d\n",
 			lvds_conf->lvds_repack, lvds_conf->dual_port,
-			lvds_conf->pn_swap, lvds_conf->port_swap);
+			lvds_conf->pn_swap, lvds_conf->port_swap,
+			lvds_conf->lane_reverse);
 		lcd_debug_config_update();
 	} else {
 		pr_info("invalid data\n");
@@ -1286,47 +1439,58 @@ static ssize_t lcd_lvds_debug_store(struct class *class,
 	return count;
 }
 
+static int vx1_intr_state = 1;
 static ssize_t lcd_vx1_debug_store(struct class *class,
 		struct class_attribute *attr, const char *buf, size_t count)
 {
 	int ret = 0;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct vbyone_config_s *vx1_conf;
+	int val[2];
 
 	vx1_conf = lcd_drv->lcd_config->lcd_control.vbyone_config;
-	ret = sscanf(buf, "%d %d %d", &vx1_conf->lane_count,
-		&vx1_conf->region_num, &vx1_conf->byte_mode);
-	if (ret == 3) {
-		pr_info("set vbyone config:\n"
-			"lane_count=%d, region_num=%d, byte_mode=%d\n",
-			vx1_conf->lane_count, vx1_conf->region_num,
-			vx1_conf->byte_mode);
-		lcd_debug_config_update();
-	} else {
-		pr_info("invalid data\n");
-		return -EINVAL;
-	}
-
-	return count;
-}
-
-static ssize_t lcd_vx1_intr_debug_store(struct class *class,
-		struct class_attribute *attr, const char *buf, size_t count)
-{
-	int ret = 0;
-	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
-	struct vbyone_config_s *vx1_conf;
-	int val;
-
-	vx1_conf = lcd_drv->lcd_config->lcd_control.vbyone_config;
-	ret = sscanf(buf, "%d", &val);
-	if (ret == 1) {
-		pr_info("set vbyone interrupt enable: %d\n", val);
-		lcd_vbyone_interrupt_enable(val);
-		lcd_vx1_intr_enable = val;
+	if (buf[0] == 'i') { /* intr */
+		ret = sscanf(buf, "intr %d %d", &val[0], &val[1]);
+		if (ret == 1) {
+			pr_info("set vbyone interrupt enable: %d\n", val[0]);
+			vx1_intr_state = val[0];
+			lcd_vbyone_interrupt_enable(vx1_intr_state);
+		} else if (ret == 2) {
+			pr_info("set vbyone interrupt enable: %d %d\n",
+				val[0], val[1]);
+			vx1_intr_state = val[0];
+			vx1_conf->intr_en = val[1];
+			lcd_vbyone_interrupt_enable(vx1_intr_state);
+		} else {
+			pr_info("vx1_intr_enable: %d %d\n",
+				vx1_intr_state, vx1_conf->intr_en);
+			return -EINVAL;
+		}
+	} else if (buf[0] == 'v') { /* vintr */
+		ret = sscanf(buf, "vintr %d", &val[0]);
+		if (ret == 1) {
+			pr_info("set vbyone vsync interrupt enable: %d\n",
+				val[0]);
+			vx1_conf->vsync_intr_en = val[0];
+			lcd_vbyone_interrupt_enable(vx1_intr_state);
+		} else {
+			pr_info("vx1_vsync_intr_enable: %d\n",
+				vx1_conf->vsync_intr_en);
+			return -EINVAL;
+		}
 	} else {
-		pr_info("invalid data\n");
-		return -EINVAL;
+		ret = sscanf(buf, "%d %d %d", &vx1_conf->lane_count,
+			&vx1_conf->region_num, &vx1_conf->byte_mode);
+		if (ret == 3) {
+			pr_info("set vbyone config:\n"
+				"lane_count=%d, region_num=%d, byte_mode=%d\n",
+				vx1_conf->lane_count, vx1_conf->region_num,
+				vx1_conf->byte_mode);
+			lcd_debug_config_update();
+		} else {
+			pr_info("invalid data\n");
+			return -EINVAL;
+		}
 	}
 
 	return count;
@@ -1501,8 +1665,6 @@ static struct class_attribute lcd_interface_debug_class_attrs[] = {
 		lcd_lvds_debug_show, lcd_lvds_debug_store),
 	__ATTR(vbyone, S_IRUGO | S_IWUSR,
 		lcd_vx1_debug_show, lcd_vx1_debug_store),
-	__ATTR(vbyone_intr, S_IRUGO | S_IWUSR,
-		lcd_vx1_intr_debug_show, lcd_vx1_intr_debug_store),
 	__ATTR(mipi,   S_IRUGO | S_IWUSR,
 		lcd_mipi_debug_show, lcd_mipi_debug_store),
 	__ATTR(edp,    S_IRUGO | S_IWUSR,
@@ -1514,22 +1676,22 @@ static struct class_attribute lcd_phy_debug_class_attrs[] = {
 		lcd_phy_debug_show, lcd_phy_debug_store),
 };
 
-static struct class *lcd_debug_class;
-
 int lcd_class_creat(void)
 {
 	int i;
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	int type;
 
-	lcd_debug_class = class_create(THIS_MODULE, "lcd");
-	if (IS_ERR(lcd_debug_class)) {
+	lcd_drv->lcd_test_check = lcd_test_check;
+
+	lcd_drv->lcd_debug_class = class_create(THIS_MODULE, "lcd");
+	if (IS_ERR(lcd_drv->lcd_debug_class)) {
 		LCDERR("create lcd debug class fail\n");
 		return -1;
 	}
 
 	for (i = 0; i < ARRAY_SIZE(lcd_debug_class_attrs); i++) {
-		if (class_create_file(lcd_debug_class,
+		if (class_create_file(lcd_drv->lcd_debug_class,
 			&lcd_debug_class_attrs[i])) {
 			LCDERR("create lcd debug attribute %s fail\n",
 				lcd_debug_class_attrs[i].attr.name);
@@ -1541,7 +1703,7 @@ int lcd_class_creat(void)
 		if (strcmp(lcd_interface_debug_class_attrs[i].attr.name,
 			lcd_type_type_to_str(type)))
 			continue;
-		if (class_create_file(lcd_debug_class,
+		if (class_create_file(lcd_drv->lcd_debug_class,
 			&lcd_interface_debug_class_attrs[i])) {
 			LCDERR("create lcd_interface debug attribute %s fail\n",
 				lcd_interface_debug_class_attrs[i].attr.name);
@@ -1552,7 +1714,7 @@ int lcd_class_creat(void)
 	case LCD_LVDS:
 	case LCD_VBYONE:
 		for (i = 0; i < ARRAY_SIZE(lcd_phy_debug_class_attrs); i++) {
-			if (class_create_file(lcd_debug_class,
+			if (class_create_file(lcd_drv->lcd_debug_class,
 				&lcd_phy_debug_class_attrs[i])) {
 				LCDERR("create phy debug attribute %s fail\n",
 					lcd_phy_debug_class_attrs[i].attr.name);
@@ -1572,20 +1734,22 @@ int lcd_class_remove(void)
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	int type;
 
-	for (i = 0; i < ARRAY_SIZE(lcd_debug_class_attrs); i++)
-		class_remove_file(lcd_debug_class, &lcd_debug_class_attrs[i]);
+	for (i = 0; i < ARRAY_SIZE(lcd_debug_class_attrs); i++) {
+		class_remove_file(lcd_drv->lcd_debug_class,
+			&lcd_debug_class_attrs[i]);
+	}
 
 	type = lcd_drv->lcd_config->lcd_basic.lcd_type;
 	for (i = 0; i < ARRAY_SIZE(lcd_interface_debug_class_attrs); i++) {
 		if (strcmp(lcd_interface_debug_class_attrs[i].attr.name,
 			lcd_type_type_to_str(type)))
 			continue;
-		class_remove_file(lcd_debug_class,
+		class_remove_file(lcd_drv->lcd_debug_class,
 			&lcd_interface_debug_class_attrs[i]);
 	}
 
-	class_destroy(lcd_debug_class);
-	lcd_debug_class = NULL;
+	class_destroy(lcd_drv->lcd_debug_class);
+	lcd_drv->lcd_debug_class = NULL;
 
 	return 0;
 }
diff --git a/drivers/amlogic/display/lcd/lcd_extern/Kconfig b/drivers/amlogic/display/lcd/lcd_extern/Kconfig
index 0456af9..7fcac27 100644
--- a/drivers/amlogic/display/lcd/lcd_extern/Kconfig
+++ b/drivers/amlogic/display/lcd/lcd_extern/Kconfig
@@ -11,6 +11,13 @@ config AML_LCD_EXTERN_I2C_T5800Q
 	help
 		"Amlogic LCD external i2c_T5800Q init driver support"
 
+config AML_LCD_EXTERN_I2C_DLPC3439
+	boolean "lcd external i2c DLPC3439 init driver"
+	default n
+	depends on AML_LCD_EXTERN
+	help
+		"Amlogic LCD external i2c_DLPC3439 init driver support"
+
 config AML_LCD_EXTERN_I2C_ANX6345
 	boolean "lcd external i2c ANX6345 init driver"
 	default n
diff --git a/drivers/amlogic/display/lcd/lcd_extern/Makefile b/drivers/amlogic/display/lcd/lcd_extern/Makefile
index 4f11a06..d46cb86 100644
--- a/drivers/amlogic/display/lcd/lcd_extern/Makefile
+++ b/drivers/amlogic/display/lcd/lcd_extern/Makefile
@@ -1,4 +1,6 @@
 obj-$(CONFIG_AML_LCD_EXTERN)			+= lcd_extern.o ext_default.o
 obj-$(CONFIG_AML_LCD_EXTERN_I2C_T5800Q)		+= i2c_T5800Q.o
 obj-$(CONFIG_AML_LCD_EXTERN_SPI_LD070WS2)	+= spi_LD070WS2.o
+obj-$(CONFIG_AML_LCD_EXTERN_I2C_DLPC3439)		+= i2c_DLPC3439.o
+
 
diff --git a/drivers/amlogic/display/lcd/lcd_extern/ext_default.c b/drivers/amlogic/display/lcd/lcd_extern/ext_default.c
index f59e6fb..2361953 100644
--- a/drivers/amlogic/display/lcd/lcd_extern/ext_default.c
+++ b/drivers/amlogic/display/lcd/lcd_extern/ext_default.c
@@ -114,67 +114,172 @@ static int lcd_extern_power_cmd(unsigned char *init_table)
 		EXTERR("%s: cmd_size %d is invalid\n", __func__, len);
 		return -1;
 	}
-	switch (ext_config->type) {
-	case LCD_EXTERN_I2C:
-		while (i <= LCD_EXTERN_INIT_TABLE_MAX) {
-			if (init_table[i] == LCD_EXTERN_INIT_END) {
-				break;
-			} else if (init_table[i] == LCD_EXTERN_INIT_NONE) {
-				/* do nothing, only for delay */
-			} else if (init_table[i] == LCD_EXTERN_INIT_GPIO) {
-				if (init_table[i+1] < LCD_GPIO_MAX) {
-					lcd_extern_gpio_set(init_table[i+1],
-						init_table[i+2]);
+	if (len == LCD_EXTERN_DYNAMIC_LEN) {
+		switch (ext_config->type) {
+		case LCD_EXTERN_I2C:
+			while (i <= LCD_EXTERN_INIT_TABLE_MAX) {
+				if (init_table[i] == LCD_EXTERN_INIT_END) {
+					break;
+				} else if (init_table[i] ==
+						LCD_EXTERN_INIT_NONE) {
+					/* do nothing, only for delay */
+					if (init_table[i+1] > 0)
+						mdelay(init_table[i+1]);
+					i += 2;
+				} else if (init_table[i] ==
+						LCD_EXTERN_INIT_GPIO) {
+					if (init_table[i+1] < LCD_GPIO_MAX) {
+						lcd_extern_gpio_set(
+							init_table[i+1],
+							init_table[i+2]);
+					}
+					if (init_table[i+3] > 0)
+						mdelay(init_table[i+3]);
+					i += 4;
+				} else if (init_table[i] ==
+						LCD_EXTERN_INIT_CMD) {
+					ret = lcd_extern_i2c_write(
+						aml_default_i2c_client,
+						&init_table[i+2],
+						init_table[i+1]-1);
+					if (init_table[i+init_table[i+1]+1] > 0)
+						mdelay(init_table[i+
+							init_table[i+1]+1]);
+					i += (init_table[i+1] + 2);
+				} else if (init_table[i] ==
+						LCD_EXTERN_INIT_CMD2) {
+					ret = lcd_extern_i2c_write(
+						aml_default_i2c2_client,
+						&init_table[i+2],
+						init_table[i+1]-1);
+					if (init_table[i+init_table[i+1]+1] > 0)
+						mdelay(init_table[i+
+							init_table[i+1]+1]);
+					i += (init_table[i+1] + 2);
+				} else {
+					EXTERR("%s(%d: %s): type %d invalid\n",
+						__func__, ext_config->index,
+						ext_config->name,
+						ext_config->type);
 				}
-			} else if (init_table[i] == LCD_EXTERN_INIT_CMD) {
-				ret = lcd_extern_i2c_write(
-					aml_default_i2c_client,
-					&init_table[i+1], (len-2));
-			} else if (init_table[i] == LCD_EXTERN_INIT_CMD2) {
-				ret = lcd_extern_i2c_write(
-					aml_default_i2c2_client,
-					&init_table[i+1], (len-2));
-			} else {
-				EXTERR("%s(%d: %s): pwoer_type %d is invalid\n",
-					__func__, ext_config->index,
-					ext_config->name, ext_config->type);
 			}
-			if (init_table[i+len-1] > 0)
-				mdelay(init_table[i+len-1]);
-			i += len;
+			break;
+		case LCD_EXTERN_SPI:
+			while (i <= LCD_EXTERN_INIT_TABLE_MAX) {
+				if (init_table[i] == LCD_EXTERN_INIT_END) {
+					break;
+				} else if (init_table[i] ==
+					LCD_EXTERN_INIT_NONE) {
+					/* do nothing, only for delay */
+					if (init_table[i+1] > 0)
+						mdelay(init_table[i+1]);
+					i += 2;
+				} else if (init_table[i] ==
+					LCD_EXTERN_INIT_GPIO) {
+					if (init_table[i+1] < LCD_GPIO_MAX) {
+						lcd_extern_gpio_set(
+							init_table[i+1],
+							init_table[i+2]);
+					}
+					if (init_table[i+3] > 0)
+						mdelay(init_table[i+3]);
+					i += 4;
+				} else if (init_table[i] ==
+					LCD_EXTERN_INIT_CMD) {
+					ret = lcd_extern_spi_write(
+						&init_table[i+2],
+						init_table[i+1]-1);
+					if (init_table[i+init_table[i+1]+1] > 0)
+						mdelay(init_table[i+
+							init_table[i+1]+1]);
+					i += (init_table[i+1] + 2);
+				} else {
+					EXTERR("%s(%d: %s): type %d invalid\n",
+						__func__, ext_config->index,
+						ext_config->name,
+						ext_config->type);
+				}
+			}
+			break;
+		default:
+			EXTERR("%s(%d: %s): extern_type %d is not support\n",
+				__func__, ext_config->index,
+				ext_config->name, ext_config->type);
+			break;
 		}
-		break;
-	case LCD_EXTERN_SPI:
-		while (i <= LCD_EXTERN_INIT_TABLE_MAX) {
-			if (init_table[i] == LCD_EXTERN_INIT_END) {
-				break;
-			} else if (init_table[i] == LCD_EXTERN_INIT_NONE) {
-				/* do nothing, only for delay */
-			} else if (init_table[i] == LCD_EXTERN_INIT_GPIO) {
-				if (init_table[i+1] < LCD_GPIO_MAX) {
-					lcd_extern_gpio_set(init_table[i+1],
-						init_table[i+2]);
+	} else {
+		switch (ext_config->type) {
+		case LCD_EXTERN_I2C:
+			while (i <= LCD_EXTERN_INIT_TABLE_MAX) {
+				if (init_table[i] == LCD_EXTERN_INIT_END) {
+					break;
+				} else if (init_table[i] ==
+					LCD_EXTERN_INIT_NONE) {
+					/* do nothing, only for delay */
+				} else if (init_table[i] ==
+					LCD_EXTERN_INIT_GPIO) {
+					if (init_table[i+1] < LCD_GPIO_MAX) {
+						lcd_extern_gpio_set(
+							init_table[i+1],
+							init_table[i+2]);
+					}
+				} else if (init_table[i] ==
+						LCD_EXTERN_INIT_CMD) {
+					ret = lcd_extern_i2c_write(
+						aml_default_i2c_client,
+						&init_table[i+1], (len-2));
+				} else if (init_table[i] ==
+						LCD_EXTERN_INIT_CMD2) {
+					ret = lcd_extern_i2c_write(
+						aml_default_i2c2_client,
+						&init_table[i+1], (len-2));
+				} else {
+					EXTERR("%s(%d: %s): type %d invalid\n",
+						__func__, ext_config->index,
+						ext_config->name,
+						ext_config->type);
 				}
-			} else if (init_table[i] == LCD_EXTERN_INIT_CMD) {
-				ret = lcd_extern_spi_write(&init_table[i+1],
-					(len-1));
-			} else {
-				EXTERR("%s(%d: %s): pwoer_type %d is invalid\n",
-					__func__, ext_config->index,
-					ext_config->name, ext_config->type);
+				if (init_table[i+len-1] > 0)
+					mdelay(init_table[i+len-1]);
+				i += len;
 			}
-			if (init_table[i+len-1] > 0)
-				mdelay(init_table[i+len-1]);
-			i += len;
+			break;
+		case LCD_EXTERN_SPI:
+			while (i <= LCD_EXTERN_INIT_TABLE_MAX) {
+				if (init_table[i] == LCD_EXTERN_INIT_END) {
+					break;
+				} else if (init_table[i] ==
+						LCD_EXTERN_INIT_NONE) {
+					/* do nothing, only for delay */
+				} else if (init_table[i] ==
+						LCD_EXTERN_INIT_GPIO) {
+					if (init_table[i+1] < LCD_GPIO_MAX) {
+						lcd_extern_gpio_set(
+							init_table[i+1],
+							init_table[i+2]);
+					}
+				} else if (init_table[i] ==
+						LCD_EXTERN_INIT_CMD) {
+					ret = lcd_extern_spi_write(
+						&init_table[i+1], (len-1));
+				} else {
+					EXTERR("%s(%d: %s): type %d invalid\n",
+						__func__, ext_config->index,
+						ext_config->name,
+						ext_config->type);
+				}
+				if (init_table[i+len-1] > 0)
+					mdelay(init_table[i+len-1]);
+				i += len;
+			}
+			break;
+		default:
+			EXTERR("%s(%d: %s): extern_type %d is not support\n",
+				__func__, ext_config->index,
+				ext_config->name, ext_config->type);
+			break;
+		}
 		}
-		break;
-	default:
-		EXTERR("%s(%d: %s): extern_type %d is not support\n",
-			__func__, ext_config->index,
-			ext_config->name, ext_config->type);
-		break;
-	}
-
 	return ret;
 }
 
diff --git a/drivers/amlogic/display/lcd/lcd_extern/i2c_DLPC3439.c b/drivers/amlogic/display/lcd/lcd_extern/i2c_DLPC3439.c
new file mode 100644
index 0000000..04638e3
--- /dev/null
+++ b/drivers/amlogic/display/lcd/lcd_extern/i2c_DLPC3439.c
@@ -0,0 +1,196 @@
+/*
+ * drivers/amlogic/display/vout/lcd/lcd_extern/i2c_DLPC3439.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/amlogic/i2c-amlogic.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/amlogic/vout/lcd_extern.h>
+#include "lcd_extern.h"
+
+#define LCD_EXTERN_NAME			"i2c_DLPC3439"
+
+static struct i2c_client *aml_DLPC3439_i2c_client;
+static struct lcd_extern_config_s *ext_config;
+
+
+	/** Write: ImageCrop: 1920x1080
+	W 36 10 00 00 00 00 80 07 38 04 **/
+static unsigned char data_1[] = {0x10, 0x00, 0x00, 0x00, 0x00,
+		0x80, 0x07, 0x38, 0x04};
+	/** Write: DisplaySize: 1920x1080
+	W 36 12 80 07 38 04 **/
+static unsigned char data_2[] = {0x12, 0x80, 0x07, 0x38, 0x04};
+	/** Write: InputImageSize: 1920x1080
+	W 36 2e 80 07 38 04 **/
+static unsigned char data_3[] = {0x2e, 0x80, 0x07, 0x38, 0x04};
+	/** Write: InputSourceSelect; 0 = External Video Port
+	W 36 05 00 **/
+static unsigned char data_4[] = {0x05, 0x00};
+	/** Write: VideoSourceFormatSelect: 0x43=RGB888
+	W 36 07 43 **/
+static unsigned char data_5[] = {0x07, 0x43};
+
+static int lcd_extern_i2c_write(struct i2c_client *i2client,
+		unsigned char *buff, unsigned len)
+{
+	int ret = 0;
+	struct i2c_msg msg[] = {
+		{
+			.addr = i2client->addr,
+			.flags = 0,
+			.len = len,
+			.buf = buff,
+		}
+	};
+
+	ret = i2c_transfer(i2client->adapter, msg, 1);
+	if (ret < 0)
+		EXTERR("i2c write failed [addr 0x%02x]\n", i2client->addr);
+
+	return ret;
+}
+
+static int lcd_extern_power_on(void)
+{
+	int ret = 0;
+
+	lcd_extern_i2c_write(aml_DLPC3439_i2c_client, data_1, 9);
+	lcd_extern_i2c_write(aml_DLPC3439_i2c_client, data_2, 5);
+	lcd_extern_i2c_write(aml_DLPC3439_i2c_client, data_3, 5);
+	lcd_extern_i2c_write(aml_DLPC3439_i2c_client, data_4, 2);
+	lcd_extern_i2c_write(aml_DLPC3439_i2c_client, data_5, 2);
+
+	EXTPR("%s\n", __func__);
+	return ret;
+}
+
+static int lcd_extern_power_off(void)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int lcd_extern_driver_update(struct aml_lcd_extern_driver_s *ext_drv)
+{
+	int ret = 0;
+
+	if (ext_drv) {
+		ext_drv->power_on  = lcd_extern_power_on;
+		ext_drv->power_off = lcd_extern_power_off;
+	} else {
+		EXTERR("%s driver is null\n", LCD_EXTERN_NAME);
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int aml_DLPC3439_i2c_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		EXTERR("%s: functionality check failed\n", __func__);
+		return -ENODEV;
+	} else {
+		aml_DLPC3439_i2c_client = client;
+	}
+
+	EXTPR("%s OK\n", __func__);
+	return 0;
+}
+
+static int aml_DLPC3439_i2c_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct i2c_device_id aml_DLPC3439_i2c_id[] = {
+	{LCD_EXTERN_NAME, 0},
+	{ }
+};
+/* MODULE_DEVICE_TABLE(i2c, aml_DLPC3439_id); */
+
+static struct i2c_driver aml_DLPC3439_i2c_driver = {
+	.probe    = aml_DLPC3439_i2c_probe,
+	.remove   = aml_DLPC3439_i2c_remove,
+	.id_table = aml_DLPC3439_i2c_id,
+	.driver = {
+		.name = LCD_EXTERN_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+int aml_lcd_extern_i2c_DLPC3439_probe(struct aml_lcd_extern_driver_s *ext_drv)
+{
+	struct i2c_board_info i2c_info;
+	struct i2c_adapter *adapter;
+	struct i2c_client *i2c_client;
+	int ret = 0;
+
+	ext_config = &ext_drv->config;
+	memset(&i2c_info, 0, sizeof(i2c_info));
+
+	adapter = i2c_get_adapter(ext_drv->config.i2c_bus);
+	if (!adapter) {
+		EXTERR("%s failed to get i2c adapter\n", ext_drv->config.name);
+		return -1;
+	}
+
+	strncpy(i2c_info.type, ext_drv->config.name, I2C_NAME_SIZE);
+	i2c_info.addr = ext_drv->config.i2c_addr;
+	i2c_info.platform_data = &ext_drv->config;
+	i2c_info.flags = 0;
+	if (i2c_info.addr > 0x7f) {
+		EXTERR("%s invalid i2c address: 0x%02x\n",
+			ext_drv->config.name, ext_drv->config.i2c_addr);
+		return -1;
+	}
+	i2c_client = i2c_new_device(adapter, &i2c_info);
+	if (!i2c_client) {
+		EXTERR("%s failed to new i2c device\n", ext_drv->config.name);
+		return -1;
+	} else {
+		if (lcd_debug_print_flag) {
+			EXTPR("%s new i2c device succeed\n",
+				ext_drv->config.name);
+		}
+	}
+
+	if (!aml_DLPC3439_i2c_client) {
+		ret = i2c_add_driver(&aml_DLPC3439_i2c_driver);
+		if (ret) {
+			EXTERR("%s add i2c_driver failed\n",
+				ext_drv->config.name);
+			return -1;
+		}
+	}
+
+	ret = lcd_extern_driver_update(ext_drv);
+
+	if (lcd_debug_print_flag)
+		EXTPR("%s: %d\n", __func__, ret);
+	return ret;
+}
diff --git a/drivers/amlogic/display/lcd/lcd_extern/i2c_T5800Q.c b/drivers/amlogic/display/lcd/lcd_extern/i2c_T5800Q.c
index 898ec3f..187c643 100644
--- a/drivers/amlogic/display/lcd/lcd_extern/i2c_T5800Q.c
+++ b/drivers/amlogic/display/lcd/lcd_extern/i2c_T5800Q.c
@@ -150,7 +150,6 @@ static int lcd_extern_power_cmd(unsigned char *init_table)
 
 static int lcd_extern_power_ctrl(int flag)
 {
-	struct aml_lcd_extern_driver_s *ext_drv = aml_lcd_extern_get_driver();
 	int ret = 0;
 
 	if (flag)
@@ -225,12 +224,12 @@ static ssize_t lcd_extern_debug_write(struct class *class,
 		&temp[0], &temp[1], &temp[2], &temp[3],
 		&temp[4], &temp[5], &temp[6]);
 	EXTPR("T5800Q i2c write:\n");
-	for (i = 0; i < INIT_LEN; i++) {
+	for (i = 0; i < 7; i++) {
 		data[i] = (unsigned char)temp[i];
 		pr_info("0x%02x ", data[i]);
 	}
 	pr_info("\n");
-	lcd_extern_i2c_write(aml_T5800Q_i2c_client, data, INIT_LEN);
+	lcd_extern_i2c_write(aml_T5800Q_i2c_client, data, 7);
 
 	if (ret != 1 || ret != 2)
 		return -EINVAL;
diff --git a/drivers/amlogic/display/lcd/lcd_extern/lcd_extern.c b/drivers/amlogic/display/lcd/lcd_extern/lcd_extern.c
index bedf3fa..0cf3714 100644
--- a/drivers/amlogic/display/lcd/lcd_extern/lcd_extern.c
+++ b/drivers/amlogic/display/lcd/lcd_extern/lcd_extern.c
@@ -909,6 +909,10 @@ static int lcd_extern_add_i2c(struct aml_lcd_extern_driver_s *ext_drv)
 #ifdef CONFIG_AML_LCD_EXTERN_I2C_ANX6345
 		ret = aml_lcd_extern_i2c_anx6345_probe(ext_drv);
 #endif
+	} else if (strcmp(ext_drv->config.name, "i2c_DLPC3439") == 0) {
+#ifdef CONFIG_AML_LCD_EXTERN_I2C_DLPC3439
+		ret = aml_lcd_extern_i2c_DLPC3439_probe(ext_drv);
+#endif
 	} else {
 		EXTERR("invalid driver name: %s\n", ext_drv->config.name);
 		ret = -1;
diff --git a/drivers/amlogic/display/lcd/lcd_extern/lcd_extern.dts b/drivers/amlogic/display/lcd/lcd_extern/lcd_extern.dts
index 528d51c..9969b89 100644
--- a/drivers/amlogic/display/lcd/lcd_extern/lcd_extern.dts
+++ b/drivers/amlogic/display/lcd/lcd_extern/lcd_extern.dts
@@ -68,5 +68,15 @@ lcd_extern{
 
 		type = <2>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
 	};
+
+	extern_6{
+		index = <6>;
+		extern_name = "i2c_DLPC3439";
+		status = "disabled";
+
+		type = <0>; /** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		i2c_address = <0x1b>; /** 7bit i2c address */
+		i2c_bus = "i2c_bus_a";
+	};
 };
 
diff --git a/drivers/amlogic/display/lcd/lcd_extern/lcd_extern.h b/drivers/amlogic/display/lcd/lcd_extern/lcd_extern.h
index b8ed875..834a2b0 100644
--- a/drivers/amlogic/display/lcd/lcd_extern/lcd_extern.h
+++ b/drivers/amlogic/display/lcd/lcd_extern/lcd_extern.h
@@ -45,6 +45,10 @@ extern int aml_lcd_extern_default_probe(
 extern int aml_lcd_extern_i2c_T5800Q_probe(
 	struct aml_lcd_extern_driver_s *ext_drv);
 #endif
+#ifdef CONFIG_AML_LCD_EXTERN_I2C_DLPC3439
+extern int aml_lcd_extern_i2c_DLPC3439_probe(
+	struct aml_lcd_extern_driver_s *ext_drv);
+#endif
 #ifdef CONFIG_AML_LCD_EXTERN_I2C_TC101
 extern int aml_lcd_extern_i2c_tc101_probe(
 	struct aml_lcd_extern_driver_s *ext_drv);
diff --git a/drivers/amlogic/display/lcd/lcd_tablet/lcd_control.c b/drivers/amlogic/display/lcd/lcd_tablet/lcd_control.c
index 9fbd30a..15f4dec 100644
--- a/drivers/amlogic/display/lcd/lcd_tablet/lcd_control.c
+++ b/drivers/amlogic/display/lcd/lcd_tablet/lcd_control.c
@@ -755,7 +755,7 @@ static void lcd_set_tcon_t(struct Lcd_Config_s *pConf)
 
 	if (pConf->lcd_misc_ctrl.vpp_sel)
 		lcd_reg_clr_mask(VPP2_MISC, (VPP_OUT_SATURATE));
-	else
+	else if (lcd_reg_read(VPP_MISC) & VPP_OUT_SATURATE)
 		lcd_reg_clr_mask(VPP_MISC, (VPP_OUT_SATURATE));
 }
 
@@ -886,7 +886,7 @@ static void lcd_set_tcon_l(struct Lcd_Config_s *pConf)
 
 	if (pConf->lcd_misc_ctrl.vpp_sel)
 		lcd_reg_clr_mask(VPP2_MISC, (VPP_OUT_SATURATE));
-	else
+	else if (lcd_reg_read(VPP_MISC) & VPP_OUT_SATURATE)
 		lcd_reg_clr_mask(VPP_MISC, (VPP_OUT_SATURATE));
 }
 
diff --git a/drivers/amlogic/display/lcd/lcd_tablet/lcd_drv.c b/drivers/amlogic/display/lcd/lcd_tablet/lcd_drv.c
index 99a4f71..65b3011 100644
--- a/drivers/amlogic/display/lcd/lcd_tablet/lcd_drv.c
+++ b/drivers/amlogic/display/lcd/lcd_tablet/lcd_drv.c
@@ -51,7 +51,7 @@ static int lcd_type_supported(struct lcd_config_s *pconf)
 		ret = 0;
 		break;
 	default:
-		LCDPR("invalid lcd type: %s(%d)\n",
+		LCDERR("invalid lcd type: %s(%d)\n",
 			lcd_type_type_to_str(lcd_type), lcd_type);
 		break;
 	}
@@ -60,7 +60,7 @@ static int lcd_type_supported(struct lcd_config_s *pconf)
 
 static void lcd_lvds_phy_set(struct lcd_config_s *pconf, int status)
 {
-	unsigned int vswing, preem, clk_vswing, clk_preem;
+	unsigned int vswing, preem, clk_vswing, clk_preem, channel_on;
 	unsigned int data32;
 
 	if (lcd_debug_print_flag)
@@ -91,11 +91,14 @@ static void lcd_lvds_phy_set(struct lcd_config_s *pconf, int status)
 				__func__, clk_preem);
 			clk_preem = LVDS_PHY_CLK_PREEM_DFT;
 		}
+		channel_on = lcd_lvds_channel_on_value(pconf);
+
 		data32 = 0x606cca80 | (vswing << 26) | (preem << 0);
 		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, data32);
 		/*lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, 0x6c6cca80);*/
 		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL2, 0x0000006c);
-		data32 = 0x0fff0800 | (clk_vswing << 8) | (clk_preem << 5);
+		data32 = (channel_on << 16) | 0x0800 | /* DIF_TX_CTL5 */
+			(clk_vswing << 8) | (clk_preem << 5); /* DIF_TX_CTL4 */
 		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, data32);
 		/*lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, 0x0fff0800);*/
 	} else {
@@ -111,11 +114,20 @@ static void lcd_tcon_set(struct lcd_config_s *pconf)
 
 	lcd_vcbus_write(L_RGB_BASE_ADDR, 0);
 	lcd_vcbus_write(L_RGB_COEFF_ADDR, 0x400);
+	aml_lcd_notifier_call_chain(LCD_EVENT_GAMMA_UPDATE, NULL);
 
-	if (pconf->lcd_basic.lcd_bits == 6)
+	switch (pconf->lcd_basic.lcd_bits) {
+	case 6:
 		lcd_vcbus_write(L_DITH_CNTL_ADDR,  0x600);
-	else if (pconf->lcd_basic.lcd_bits == 8)
+		break;
+	case 8:
 		lcd_vcbus_write(L_DITH_CNTL_ADDR,  0x400);
+		break;
+	case 10:
+	default:
+		lcd_vcbus_write(L_DITH_CNTL_ADDR,  0x0);
+		break;
+	}
 
 	switch (pconf->lcd_basic.lcd_type) {
 	case LCD_LVDS:
@@ -182,8 +194,9 @@ static void lcd_tcon_set(struct lcd_config_s *pconf)
 	lcd_vcbus_write(L_TCON_MISC_SEL_ADDR,
 		((1 << STV1_SEL) | (1 << STV2_SEL)));
 
-	lcd_vcbus_write(VPP_MISC,
-		lcd_vcbus_read(VPP_MISC) & ~(VPP_OUT_SATURATE));
+	if (lcd_vcbus_read(VPP_MISC) & VPP_OUT_SATURATE)
+		lcd_vcbus_write(VPP_MISC,
+			lcd_vcbus_read(VPP_MISC) & ~(VPP_OUT_SATURATE));
 }
 
 static void lcd_ttl_control_set(struct lcd_config_s *pconf)
@@ -223,7 +236,7 @@ static void lcd_lvds_clk_util_set(struct lcd_config_s *pconf)
 static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 {
 	unsigned int bit_num = 1;
-	unsigned int pn_swap, port_swap;
+	unsigned int pn_swap, port_swap, lane_reverse;
 	unsigned int dual_port, fifo_mode;
 	unsigned int lvds_repack = 1;
 
@@ -232,14 +245,17 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 
 	lcd_lvds_clk_util_set(pconf);
 
-	lvds_repack = (pconf->lcd_control.lvds_config->lvds_repack) & 0x1;
+	lvds_repack = (pconf->lcd_control.lvds_config->lvds_repack) & 0x3;
 	pn_swap   = (pconf->lcd_control.lvds_config->pn_swap) & 0x1;
 	dual_port = (pconf->lcd_control.lvds_config->dual_port) & 0x1;
 	port_swap = (pconf->lcd_control.lvds_config->port_swap) & 0x1;
+	lane_reverse = (pconf->lcd_control.lvds_config->lane_reverse) & 0x1;
 
 	switch (pconf->lcd_basic.lcd_bits) {
 	case 10:
 		bit_num = 0;
+		if (lvds_repack == 1)
+			lvds_repack = 2;
 		break;
 	case 8:
 		bit_num = 1;
@@ -260,8 +276,7 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 		fifo_mode = 0x1;
 
 	lcd_vcbus_write(LVDS_PACK_CNTL_ADDR,
-		(lvds_repack << 0) | /* repack */
-		(port_swap << 2) | /* odd_even */
+		(lvds_repack << 0) | /* repack //[1:0] */
 		(0 << 3) |	/* reserve */
 		(0 << 4) |	/* lsb first */
 		(pn_swap << 5) | /* pn swap */
@@ -272,8 +287,15 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 		(1 << 12) |	/* g_select  //0:R, 1:G, 2:B, 3:0 */
 		(2 << 14));	/* b_select  //0:R, 1:G, 2:B, 3:0 */
 
+	lcd_vcbus_setb(LCD_PORT_SWAP, port_swap, 12, 1);
+
+	if (lane_reverse)
+		lcd_vcbus_setb(LVDS_GEN_CNTL, 0x03, 13, 2);
+
 	lcd_vcbus_write(LVDS_GEN_CNTL,
-		(lcd_vcbus_read(LVDS_GEN_CNTL) | (1 << 4) | (fifo_mode << 0)));
+		(lcd_vcbus_read(LVDS_GEN_CNTL) |
+		(1 << 4) | (fifo_mode << 0)));
+
 	lcd_vcbus_setb(LVDS_GEN_CNTL, 1, 3, 1);
 }
 
@@ -353,6 +375,7 @@ void lcd_tablet_driver_init_pre(void)
 	lcd_clk_set(pconf);
 	lcd_venc_set(pconf);
 	lcd_tcon_set(pconf);
+	lcd_drv->lcd_test_check();
 }
 
 int lcd_tablet_driver_init(void)
@@ -425,3 +448,56 @@ void lcd_tablet_driver_disable(void)
 		LCDPR("%s finished\n", __func__);
 }
 
+void lcd_tablet_driver_tiny_enable(void)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct lcd_config_s *pconf;
+	int ret;
+
+	pconf = lcd_drv->lcd_config;
+	ret = lcd_type_supported(pconf);
+	if (ret)
+		return;
+
+	/* init driver */
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_TTL:
+		lcd_ttl_control_set(pconf);
+		lcd_ttl_pinmux_set(1);
+		break;
+	case LCD_LVDS:
+		lcd_lvds_control_set(pconf);
+		lcd_lvds_phy_set(pconf, 1);
+		break;
+	default:
+		break;
+	}
+
+	LCDPR("enable driver\n");
+}
+
+void lcd_tablet_driver_tiny_disable(void)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct lcd_config_s *pconf;
+	int ret;
+
+	LCDPR("disable driver\n");
+	pconf = lcd_drv->lcd_config;
+	ret = lcd_type_supported(pconf);
+	if (ret)
+		return;
+
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_TTL:
+		lcd_ttl_pinmux_set(0);
+		break;
+	case LCD_LVDS:
+		lcd_lvds_phy_set(pconf, 0);
+		lcd_lvds_disable();
+		break;
+	default:
+		break;
+	}
+}
+
diff --git a/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.c b/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.c
index dc080b2..07ac51c 100644
--- a/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.c
+++ b/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.c
@@ -44,8 +44,6 @@
 
 #define PANEL_NAME    "panel"
 
-static DEFINE_MUTEX(lcd_vout_mutex);
-
 /* ************************************************** *
    vout server api
  * ************************************************** */
@@ -92,7 +90,8 @@ static int lcd_set_current_vmode(enum vmode_e mode)
 static int lcd_vmode_is_supported(enum vmode_e mode)
 {
 	mode &= VMODE_MODE_BIT_MASK;
-	LCDPR("%s vmode = %d\n", __func__, mode);
+	if (lcd_debug_print_flag)
+		LCDPR("%s vmode = %d\n", __func__, mode);
 
 	if (mode == VMODE_LCD)
 		return true;
@@ -181,12 +180,17 @@ static int lcd_set_vframe_rate_hint(int duration)
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct vinfo_s *info;
-	unsigned char fr_policy;
+	int fr_policy;
 	unsigned int frame_rate = 6000;
 	unsigned int duration_num = 60, duration_den = 1;
 	struct lcd_vframe_match_s *vtable = lcd_vframe_match_table_1;
 	int fps, i, n;
 
+	if (lcd_drv->lcd_status == 0) {
+		LCDPR("%s: lcd is disabled, exit\n", __func__);
+		return 0;
+	}
+
 	info = lcd_drv->lcd_info;
 
 	fr_policy = lcd_drv->fr_auto_policy;
@@ -216,6 +220,13 @@ static int lcd_set_vframe_rate_hint(int duration)
 	LCDPR("%s: policy = %d, duration = %d, fps = %d, frame_rate = %d\n",
 		__func__, fr_policy, duration, fps, frame_rate);
 
+	/* if the sync_duration is same as current */
+	if ((duration_num == info->sync_duration_num) &&
+		(duration_den == info->sync_duration_den)) {
+		LCDPR("%s: sync_duration is the same, exit\n", __func__);
+		return 0;
+	}
+
 	/* update vinfo */
 	info->sync_duration_num = duration_num;
 	info->sync_duration_den = duration_den;
@@ -231,6 +242,11 @@ static int lcd_set_vframe_rate_end_hint(void)
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct vinfo_s *info;
 
+	if (lcd_drv->lcd_status == 0) {
+		LCDPR("%s: lcd is disabled, exit\n", __func__);
+		return 0;
+	}
+
 	if (lcd_debug_print_flag)
 		LCDPR("fr_auto_policy = %d\n", lcd_drv->fr_auto_policy);
 	if (lcd_drv->fr_auto_policy) {
@@ -248,17 +264,44 @@ static int lcd_set_vframe_rate_end_hint(void)
 	return 0;
 }
 
+static int lcd_set_vframe_rate_policy(int policy)
+{
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
+	lcd_drv->fr_auto_policy = policy;
+	LCDPR("%s: %d\n", __func__, lcd_drv->fr_auto_policy);
+#endif
+	return 0;
+}
+
+static int lcd_get_vframe_rate_policy(void)
+{
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
+	return lcd_drv->fr_auto_policy;
+#else
+	return 0;
+#endif
+}
+
 #ifdef CONFIG_PM
 static int lcd_suspend(void)
 {
 	aml_lcd_notifier_call_chain(LCD_EVENT_POWER_OFF, NULL);
+	lcd_resume_flag = 0;
 	LCDPR("%s finished\n", __func__);
 	return 0;
 }
 static int lcd_resume(void)
 {
-	aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
-	LCDPR("%s finished\n", __func__);
+	if (lcd_resume_flag == 0) {
+		lcd_resume_flag = 1;
+		aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
+		LCDPR("%s finished\n", __func__);
+	}
+
 	return 0;
 }
 #endif
@@ -273,6 +316,8 @@ static struct vout_server_s lcd_vout_server = {
 		.disable = lcd_vout_disable,
 		.set_vframe_rate_hint = lcd_set_vframe_rate_hint,
 		.set_vframe_rate_end_hint = lcd_set_vframe_rate_end_hint,
+		.set_vframe_rate_policy = lcd_set_vframe_rate_policy,
+		.get_vframe_rate_policy = lcd_get_vframe_rate_policy,
 #ifdef CONFIG_PM
 		.vout_suspend = lcd_suspend,
 		.vout_resume = lcd_resume,
@@ -302,6 +347,8 @@ static void lcd_tablet_vinfo_update(void)
 		vinfo->sync_duration_den = pconf->lcd_timing.sync_duration_den;
 		vinfo->video_clk = pconf->lcd_timing.lcd_clk;
 		vinfo->viu_color_fmt = TVIN_RGB444;
+
+		lcd_hdr_vinfo_update();
 	}
 }
 
@@ -398,6 +445,8 @@ static void lcd_config_print(struct lcd_config_s *pconf)
 			pconf->lcd_control.lvds_config->dual_port);
 		LCDPR("port_swap = %d\n",
 			pconf->lcd_control.lvds_config->port_swap);
+		LCDPR("lane_reverse = %d\n",
+			pconf->lcd_control.lvds_config->lane_reverse);
 	}
 }
 
@@ -547,14 +596,27 @@ static int lcd_config_load_from_dts(struct lcd_config_s *pconf,
 	case LCD_LVDS:
 		lvdsconf = pconf->lcd_control.lvds_config;
 		ret = of_property_read_u32_array(child, "lvds_attr",
-			&para[0], 4);
+			&para[0], 5);
 		if (ret) {
-			LCDERR("failed to get lvds_attr\n");
+			if (lcd_debug_print_flag)
+				LCDERR("load 4 parameters in lvds_attr\n");
+			ret = of_property_read_u32_array(child, "lvds_attr",
+				&para[0], 4);
+			if (ret) {
+				if (lcd_debug_print_flag)
+					LCDPR("failed to get lvds_attr\n");
+			} else {
+				lvdsconf->lvds_repack = para[0];
+				lvdsconf->dual_port = para[1];
+				lvdsconf->pn_swap = para[2];
+				lvdsconf->port_swap = para[3];
+			}
 		} else {
-			pconf->lcd_control.lvds_config->lvds_repack = para[0];
-			pconf->lcd_control.lvds_config->dual_port = para[1];
-			pconf->lcd_control.lvds_config->pn_swap = para[2];
-			pconf->lcd_control.lvds_config->port_swap = para[3];
+				lvdsconf->lvds_repack = para[0];
+				lvdsconf->dual_port = para[1];
+				lvdsconf->pn_swap = para[2];
+				lvdsconf->port_swap = para[3];
+				lvdsconf->lane_reverse = para[4];
 		}
 		ret = of_property_read_u32_array(child, "phy_attr",
 			&para[0], 4);
@@ -618,16 +680,17 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 		return -1;
 	}
 
-	/* check lcd unifykey length */
-	len = 10 + 36 + 18 + 31 + 20;
+	/* step 1: check header */
+	len = LCD_UKEY_HEAD_SIZE;
 	ret = lcd_unifykey_len_check(key_len, len);
 	if (ret < 0) {
+		LCDERR("unifykey header length is incorrect\n");
 		kfree(para);
 		return -1;
 	}
 
-	/* header: 10byte */
 	lcd_unifykey_header_check(para, &lcd_header);
+	len = 10 + 36 + 18 + 31 + 20;
 	if (lcd_debug_print_flag) {
 		LCDPR("unifykey header:\n");
 		LCDPR("crc32             = 0x%08x\n", lcd_header.crc32);
@@ -636,6 +699,14 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 		LCDPR("reserved          = 0x%04x\n", lcd_header.reserved);
 	}
 
+	/* step 2: check lcd parameters */
+	ret = lcd_unifykey_len_check(key_len, len);
+	if (ret < 0) {
+		LCDERR("unifykey parameters length is incorrect\n");
+		kfree(para);
+		return -1;
+	}
+
 	/* basic: 36byte */
 	p = para + LCD_UKEY_HEAD_SIZE;
 	*(p + LCD_UKEY_MODEL_NAME - 1) = '\0'; /* ensure string ending */
@@ -703,33 +774,68 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 
 	/* interface: 20byte */
 	if (pconf->lcd_basic.lcd_type == LCD_LVDS) {
-		pconf->lcd_control.lvds_config->lvds_repack =
-				(*p | ((*(p + 1)) << 8)) & 0xff;
-		p += LCD_UKEY_IF_ATTR_0;
-		pconf->lcd_control.lvds_config->dual_port =
-				(*p | ((*(p + 1)) << 8)) & 0xff;
-		p += LCD_UKEY_IF_ATTR_1;
-		pconf->lcd_control.lvds_config->pn_swap  =
-				(*p | ((*(p + 1)) << 8)) & 0xff;
-		p += LCD_UKEY_IF_ATTR_2;
-		pconf->lcd_control.lvds_config->port_swap  =
-				(*p | ((*(p + 1)) << 8)) & 0xff;
-		p += LCD_UKEY_IF_ATTR_3;
-		pconf->lcd_control.lvds_config->phy_vswing =
-				(*p | ((*(p + 1)) << 8)) & 0xff;
-		p += LCD_UKEY_IF_ATTR_4;
-		pconf->lcd_control.lvds_config->phy_vswing =
-				(*p | ((*(p + 1)) << 8)) & 0xff;
-		p += LCD_UKEY_IF_ATTR_5;
-		pconf->lcd_control.lvds_config->phy_clk_vswing =
-				(*p | ((*(p + 1)) << 8)) & 0xff;
-		p += LCD_UKEY_IF_ATTR_6;
-		pconf->lcd_control.lvds_config->phy_clk_preem  =
-				(*p | ((*(p + 1)) << 8)) & 0xff;
-		p += LCD_UKEY_IF_ATTR_7;
-		/* dummy pointer */
-		p += LCD_UKEY_IF_ATTR_8;
-		p += LCD_UKEY_IF_ATTR_9;
+		if (lcd_header.version == 1) {
+			pconf->lcd_control.lvds_config->lvds_repack =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_0;
+			pconf->lcd_control.lvds_config->dual_port =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_1;
+			pconf->lcd_control.lvds_config->pn_swap  =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_2;
+			pconf->lcd_control.lvds_config->port_swap  =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_3;
+			pconf->lcd_control.lvds_config->phy_vswing =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_4;
+			pconf->lcd_control.lvds_config->phy_preem =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_5;
+			pconf->lcd_control.lvds_config->phy_clk_vswing =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_6;
+			pconf->lcd_control.lvds_config->phy_clk_preem  =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_7;
+			pconf->lcd_control.lvds_config->lane_reverse = 0;
+			p += LCD_UKEY_IF_ATTR_8;
+
+			/* dummy pointer */
+			p += LCD_UKEY_IF_ATTR_9;
+			}
+		else if (lcd_header.version == 2) {
+			pconf->lcd_control.lvds_config->lvds_repack =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_0;
+			pconf->lcd_control.lvds_config->dual_port =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_1;
+			pconf->lcd_control.lvds_config->pn_swap  =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_2;
+			pconf->lcd_control.lvds_config->port_swap  =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_3;
+			pconf->lcd_control.lvds_config->lane_reverse  =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_4;
+			pconf->lcd_control.lvds_config->phy_vswing =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_5;
+			pconf->lcd_control.lvds_config->phy_preem =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_6;
+			pconf->lcd_control.lvds_config->phy_clk_vswing =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_7;
+			pconf->lcd_control.lvds_config->phy_clk_preem  =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_8;
+			/* dummy pointer */
+			p += LCD_UKEY_IF_ATTR_9;
+			}
 	} else if (pconf->lcd_basic.lcd_type == LCD_TTL) {
 		pconf->lcd_control.ttl_config->clk_pol =
 			(*p | ((*(p + 1)) << 8)) & 0x1;
@@ -766,7 +872,8 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 		p += LCD_UKEY_IF_ATTR_9;
 	}
 
-	ret = lcd_power_load_from_unifykey(pconf, para, key_len);
+	/* step 3: check power sequence */
+	ret = lcd_power_load_from_unifykey(pconf, para, key_len, len);
 	if (ret < 0) {
 		kfree(para);
 		return -1;
@@ -797,8 +904,8 @@ static void lcd_config_init(struct lcd_config_s *pconf)
 	pconf->lcd_timing.lcd_clk_dft = pconf->lcd_timing.lcd_clk;
 	pconf->lcd_timing.h_period_dft = pconf->lcd_basic.h_period;
 	pconf->lcd_timing.v_period_dft = pconf->lcd_basic.v_period;
-
 	lcd_tcon_config(pconf);
+
 	lcd_clk_generate_parameter(pconf);
 	ss_level = pconf->lcd_timing.ss_level;
 	cconf->ss_level = (ss_level >= cconf->ss_level_max) ? 0 : ss_level;
@@ -916,6 +1023,8 @@ int lcd_tablet_probe(struct device *dev)
 	lcd_drv->driver_init_pre = lcd_tablet_driver_init_pre;
 	lcd_drv->driver_init = lcd_tablet_driver_init;
 	lcd_drv->driver_disable = lcd_tablet_driver_disable;
+	lcd_drv->driver_tiny_enable = lcd_tablet_driver_tiny_enable;
+	lcd_drv->driver_tiny_disable = lcd_tablet_driver_tiny_disable;
 
 	lcd_get_config(lcd_drv->lcd_config, dev);
 
diff --git a/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.h b/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.h
index 610a4ac..68fee7f 100644
--- a/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.h
+++ b/drivers/amlogic/display/lcd/lcd_tablet/lcd_tablet.h
@@ -19,10 +19,12 @@
 #ifndef __AML_LCD_TABLET_H__
 #define __AML_LCD_TABLET_H__
 
-#define LCD_DRV_VERSION    "20160630"
+#define LCD_DRV_VERSION    "20161130"
 
 extern void lcd_tablet_driver_init_pre(void);
 extern int lcd_tablet_driver_init(void);
 extern void lcd_tablet_driver_disable(void);
+extern void lcd_tablet_driver_tiny_enable(void);
+extern void lcd_tablet_driver_tiny_disable(void);
 
 #endif
diff --git a/drivers/amlogic/display/lcd/lcd_tv/lcd_drv.c b/drivers/amlogic/display/lcd/lcd_tv/lcd_drv.c
index b36adc7..9ba0a1a 100644
--- a/drivers/amlogic/display/lcd/lcd_tv/lcd_drv.c
+++ b/drivers/amlogic/display/lcd/lcd_tv/lcd_drv.c
@@ -46,6 +46,16 @@
 
 static int vx1_fsm_acq_st;
 
+#define VX1_TRAINING_TIMEOUT    60  /* vsync cnt */
+static int vx1_training_wait_cnt;
+static int vx1_training_stable_cnt;
+static int vx1_timeout_reset_flag;
+static struct tasklet_struct  lcd_vx1_reset_tasklet;
+static int lcd_vx1_intr_request;
+
+#define VX1_HPLL_INTERVAL (HZ)
+static struct timer_list vx1_hpll_timer;
+
 static int lcd_type_supported(struct lcd_config_s *pconf)
 {
 	int lcd_type = pconf->lcd_basic.lcd_type;
@@ -57,7 +67,7 @@ static int lcd_type_supported(struct lcd_config_s *pconf)
 		ret = 0;
 		break;
 	default:
-		LCDPR("invalid lcd type: %s(%d)\n",
+		LCDERR("invalid lcd type: %s(%d)\n",
 			lcd_type_type_to_str(lcd_type), lcd_type);
 		break;
 	}
@@ -101,7 +111,7 @@ static void lcd_vbyone_phy_set(struct lcd_config_s *pconf, int status)
 
 static void lcd_lvds_phy_set(struct lcd_config_s *pconf, int status)
 {
-	unsigned int vswing, preem, clk_vswing, clk_preem;
+	unsigned int vswing, preem, clk_vswing, clk_preem, channel_on;
 	unsigned int data32;
 
 	if (lcd_debug_print_flag)
@@ -132,11 +142,14 @@ static void lcd_lvds_phy_set(struct lcd_config_s *pconf, int status)
 				__func__, clk_preem);
 			clk_preem = LVDS_PHY_CLK_PREEM_DFT;
 		}
+		channel_on = lcd_lvds_channel_on_value(pconf);
+
 		data32 = 0x606cca80 | (vswing << 26) | (preem << 0);
 		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, data32);
 		/*lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL1, 0x6c6cca80);*/
 		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL2, 0x0000006c);
-		data32 = 0x0fff0800 | (clk_vswing << 8) | (clk_preem << 5);
+		data32 = (channel_on << 16) | 0x0800 | /* DIF_TX_CTL5 */
+			(clk_vswing << 8) | (clk_preem << 5); /* DIF_TX_CTL4 */
 		lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, data32);
 		/*lcd_hiu_write(HHI_DIF_CSI_PHY_CNTL3, 0x0fff0800);*/
 	} else {
@@ -150,9 +163,20 @@ static void lcd_tcon_set(struct lcd_config_s *pconf)
 {
 	lcd_vcbus_write(L_RGB_BASE_ADDR, 0);
 	lcd_vcbus_write(L_RGB_COEFF_ADDR, 0x400);
+	aml_lcd_notifier_call_chain(LCD_EVENT_GAMMA_UPDATE, NULL);
 
-	if (pconf->lcd_basic.lcd_bits == 8)
+	switch (pconf->lcd_basic.lcd_bits) {
+	case 8:
 		lcd_vcbus_write(L_DITH_CNTL_ADDR,  0x400);
+		break;
+	case 6:
+		lcd_vcbus_write(L_DITH_CNTL_ADDR,  0x600);
+		break;
+	case 10:
+	default:
+		lcd_vcbus_write(L_DITH_CNTL_ADDR,  0x0);
+		break;
+	}
 
 	switch (pconf->lcd_basic.lcd_type) {
 	case LCD_LVDS:
@@ -170,8 +194,9 @@ static void lcd_tcon_set(struct lcd_config_s *pconf)
 		break;
 	}
 
-	lcd_vcbus_write(VPP_MISC,
-		lcd_vcbus_read(VPP_MISC) & ~(VPP_OUT_SATURATE));
+	if (lcd_vcbus_read(VPP_MISC) & VPP_OUT_SATURATE)
+		lcd_vcbus_write(VPP_MISC,
+			lcd_vcbus_read(VPP_MISC) & ~(VPP_OUT_SATURATE));
 }
 
 static void lcd_lvds_clk_util_set(struct lcd_config_s *pconf)
@@ -198,7 +223,7 @@ static void lcd_lvds_clk_util_set(struct lcd_config_s *pconf)
 static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 {
 	unsigned int bit_num = 1;
-	unsigned int pn_swap, port_swap;
+	unsigned int pn_swap, port_swap, lane_reverse;
 	unsigned int dual_port, fifo_mode;
 	unsigned int lvds_repack = 1;
 
@@ -207,14 +232,17 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 
 	lcd_lvds_clk_util_set(pconf);
 
-	lvds_repack = (pconf->lcd_control.lvds_config->lvds_repack) & 0x1;
+	lvds_repack = (pconf->lcd_control.lvds_config->lvds_repack) & 0x3;
 	pn_swap   = (pconf->lcd_control.lvds_config->pn_swap) & 0x1;
 	dual_port = (pconf->lcd_control.lvds_config->dual_port) & 0x1;
 	port_swap = (pconf->lcd_control.lvds_config->port_swap) & 0x1;
+	lane_reverse = (pconf->lcd_control.lvds_config->lane_reverse) & 0x1;
 
 	switch (pconf->lcd_basic.lcd_bits) {
 	case 10:
 		bit_num = 0;
+		if (lvds_repack == 1)
+			lvds_repack = 2;
 		break;
 	case 8:
 		bit_num = 1;
@@ -235,8 +263,7 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 		fifo_mode = 0x1;
 
 	lcd_vcbus_write(LVDS_PACK_CNTL_ADDR,
-		(lvds_repack << 0) | /* repack */
-		(port_swap << 2) | /* odd_even */
+		(lvds_repack << 0) | /* repack //[1:0] */
 		(0 << 3) |	/* reserve */
 		(0 << 4) |	/* lsb first */
 		(pn_swap << 5) | /* pn swap */
@@ -247,8 +274,14 @@ static void lcd_lvds_control_set(struct lcd_config_s *pconf)
 		(1 << 12) |	/* g_select  //0:R, 1:G, 2:B, 3:0 */
 		(2 << 14));	/* b_select  //0:R, 1:G, 2:B, 3:0 */
 
+	lcd_vcbus_setb(LCD_PORT_SWAP, port_swap, 12, 1);
+
+	if (lane_reverse)
+		lcd_vcbus_setb(LVDS_GEN_CNTL, 0x03, 13, 2);
+
 	lcd_vcbus_write(LVDS_GEN_CNTL,
 		(lcd_vcbus_read(LVDS_GEN_CNTL) | (1 << 4) | (fifo_mode << 0)));
+
 	lcd_vcbus_setb(LVDS_GEN_CNTL, 1, 3, 1);
 }
 
@@ -346,8 +379,10 @@ static int lcd_vbyone_lanes_set(int lane_num, int byte_mode, int region_num,
 	default:
 		return -1;
 	}
-	LCDPR("byte_mode=%d, lane_num=%d, region_num=%d\n",
-		byte_mode, lane_num, region_num);
+	if (lcd_debug_print_flag) {
+		LCDPR("byte_mode=%d, lane_num=%d, region_num=%d\n",
+			byte_mode, lane_num, region_num);
+	}
 
 	sublane_num = lane_num / region_num; /* lane num in each region */
 	lcd_vcbus_setb(VBO_LANES, (lane_num - 1), 0, 3);
@@ -408,7 +443,10 @@ static void lcd_vbyone_wait_timing_stable(void)
 		timing_state = lcd_vcbus_read(VBO_INTR_STATE) & 0x1ff;
 		i--;
 	};
-	LCDPR("vbyone timing state: 0x%03x, i=%d\n", timing_state, (200 - i));
+	if (lcd_debug_print_flag) {
+		LCDPR("vbyone timing state: 0x%03x, i=%d\n",
+			timing_state, (200 - i));
+	}
 	mdelay(2);
 }
 
@@ -455,7 +493,7 @@ static void lcd_vbyone_control_set(struct lcd_config_s *pconf)
 		vin_bpp   = 0;
 		break;
 	default:
-		LCDPR("error: vbyone COLOR_FORMAT unsupport\n");
+		LCDERR("vbyone COLOR_FORMAT unsupport\n");
 		return;
 	}
 #else
@@ -507,27 +545,53 @@ static void lcd_vbyone_disable(void)
 	lcd_vcbus_setb(VBO_CTRL_L, 0, 0, 1);
 }
 
-#define VBYONE_INTR_UNMASK    0x2a00 /* enable htpdn_fail,lockn_fail,acq_hold */
+#define VBYONE_INTR_UNMASK   0x2bff /* 0x2a00 */
+			/* enable htpdn_fail,lockn_fail,acq_hold */
 void lcd_vbyone_interrupt_enable(int flag)
 {
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct vbyone_config_s *vx1_conf;
+
 	if (lcd_debug_print_flag)
 		LCDPR("%s: %d\n", __func__, flag);
 
+	vx1_conf = lcd_drv->lcd_config->lcd_control.vbyone_config;
 	if (flag) {
-		vx1_fsm_acq_st = 0;
-		/* clear interrupt */
-		lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0x01ff, 0, 9);
-		lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 0, 9);
-
-		/* set hold in FSM_ACQ */
-		lcd_vcbus_setb(VBO_FSM_HOLDER_L, 0xffff, 0, 16);
-		/* enable interrupt */
-		lcd_vcbus_setb(VBO_INTR_UNMASK, VBYONE_INTR_UNMASK, 0, 15);
+		if (vx1_conf->intr_en) {
+			vx1_fsm_acq_st = 0;
+			/* clear interrupt */
+			lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0x01ff, 0, 9);
+			lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 0, 9);
+
+			/* set hold in FSM_ACQ */
+			lcd_vcbus_setb(VBO_FSM_HOLDER_L, 0xffff, 0, 16);
+			/* enable interrupt */
+			lcd_vcbus_setb(VBO_INTR_UNMASK,
+				VBYONE_INTR_UNMASK, 0, 15);
+		} else {
+			/* mask interrupt */
+			lcd_vcbus_write(VBO_INTR_UNMASK, 0x0);
+			if (vx1_conf->vsync_intr_en) {
+				/* keep holder for vsync monitor enabled */
+				/* set hold in FSM_ACQ */
+				lcd_vcbus_setb(VBO_FSM_HOLDER_L, 0xffff, 0, 16);
+			} else {
+				/* release holder for vsync monitor disabled */
+				/* release hold in FSM_ACQ */
+				lcd_vcbus_setb(VBO_FSM_HOLDER_L, 0, 0, 16);
+			}
+
+			vx1_fsm_acq_st = 0;
+			/* clear interrupt */
+			lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0x01ff, 0, 9);
+			lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 0, 9);
+		}
 	} else {
 		/* mask interrupt */
 		lcd_vcbus_write(VBO_INTR_UNMASK, 0x0);
 		/* release hold in FSM_ACQ */
 		lcd_vcbus_setb(VBO_FSM_HOLDER_L, 0, 0, 16);
+		lcd_vx1_intr_request = 0;
 	}
 }
 
@@ -559,23 +623,39 @@ void lcd_vbyone_wait_stable(void)
 	int i = 5000;
 
 	while (((lcd_vcbus_read(VBO_STATUS_L) & 0x3f) != 0x20) && (i > 0)) {
-		udelay(10);
+		udelay(50);
 		i--;
 	}
 	LCDPR("%s status: 0x%x, i=%d\n",
 		__func__, lcd_vcbus_read(VBO_STATUS_L), (5000 - i));
+	vx1_training_wait_cnt = 0;
+	vx1_training_stable_cnt = 0;
+	vx1_fsm_acq_st = 0;
 	lcd_vbyone_interrupt_enable(1);
 }
 
+#define LCD_VX1_WAIT_STABLE_DELAY    300 /* ms */
+static void lcd_vx1_wait_stable_delayed(struct work_struct *work)
+{
+	if (lcd_vx1_intr_request == 0)
+		return;
+
+	lcd_vbyone_wait_stable();
+}
+
 static void lcd_vx1_wait_hpd(void)
 {
 	int i = 0;
-	LCDPR("vx1 wait hpd to low ...\n");
+
+	if (lcd_debug_print_flag)
+		LCDPR("vx1 wait hpd to low ...\n");
+
 	while (lcd_vcbus_read(VBO_STATUS_L) & 0x40) {
 		if (i++ >= 10000)
 			break;
 		udelay(50);
 	}
+	mdelay(10); /* add 10ms delay for compatibility */
 	if (lcd_vcbus_read(VBO_STATUS_L) & 0x40)
 		LCDPR("%s: hpd=%d\n", __func__,
 			((lcd_vcbus_read(VBO_STATUS_L) >> 6) & 0x1));
@@ -584,23 +664,186 @@ static void lcd_vx1_wait_hpd(void)
 			((lcd_vcbus_read(VBO_STATUS_L) >> 6) & 0x1), i);
 }
 
+#define LCD_PCLK_TOLERANCE          2000000  /* 2M */
+#define LCD_ENCL_CLK_ERR_CNT_MAX    3
+static unsigned char lcd_encl_clk_err_cnt;
+static void lcd_vx1_hpll_timer_handler(unsigned long arg)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	int encl_clk;
+#if 0
+	int pclk, pclk_min, pclk_max;
+#endif
+
+	if (lcd_drv->lcd_status == 0)
+		goto vx1_hpll_timer_end;
+
+#if 0
+	pclk = lcd_drv->lcd_config->lcd_timing.lcd_clk;
+	pclk_min = pclk - LCD_PCLK_TOLERANCE;
+	pclk_max = pclk + LCD_PCLK_TOLERANCE;
+	encl_clk = lcd_encl_clk_msr();
+	if ((encl_clk < pclk_min) || (encl_clk > pclk_max)) {
+		LCDPR("%s: pll frequency error: %d\n", __func__, encl_clk);
+		lcd_pll_reset();
+	}
+#else
+	encl_clk = lcd_encl_clk_msr();
+	if (encl_clk == 0)
+		lcd_encl_clk_err_cnt++;
+	else
+		lcd_encl_clk_err_cnt = 0;
+	if (lcd_encl_clk_err_cnt >= LCD_ENCL_CLK_ERR_CNT_MAX) {
+		LCDPR("%s: pll frequency error: %d\n", __func__, encl_clk);
+		lcd_pll_reset();
+		lcd_encl_clk_err_cnt = 0;
+	}
+#endif
+
+vx1_hpll_timer_end:
+	vx1_hpll_timer.expires = jiffies + VX1_HPLL_INTERVAL;
+	add_timer(&vx1_hpll_timer);
+}
+
+static void lcd_vx1_hold_reset(void)
+{
+	if (lcd_debug_print_flag)
+		LCDPR("%s\n", __func__);
+
+	vx1_fsm_acq_st = 0;
+	lcd_vcbus_write(VBO_INTR_UNMASK, 0x0); /* mask interrupt */
+	/* clear interrupt */
+	lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0x01ff, 0, 9);
+	lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 0, 9);
+
+	/* clear FSM_continue */
+	lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 15, 1);
+
+	/* force PHY to 0 */
+	lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 3, 8, 2);
+	lcd_vcbus_write(VBO_SOFT_RST, 0x1ff);
+	udelay(5);
+	/* clear lockn raising flag */
+	lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 1, 7, 1);
+	/* realease PHY */
+	lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 0, 8, 2);
+	/* clear lockn raising flag */
+	lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 7, 1);
+	lcd_vcbus_write(VBO_SOFT_RST, 0);
+
+	/* enable interrupt */
+	lcd_vcbus_setb(VBO_INTR_UNMASK, VBYONE_INTR_UNMASK, 0, 15);
+}
+
+static void lcd_vx1_timeout_reset(unsigned long data)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
+	if (vx1_timeout_reset_flag == 0)
+		return;
+
+	LCDPR("%s\n", __func__);
+	if (vx1_timeout_reset_flag == 1)
+		lcd_drv->module_reset();
+	else
+		lcd_drv->module_tiny_reset();
+	if (lcd_drv->lcd_config->lcd_control.vbyone_config->intr_en)
+		lcd_vx1_hold_reset();
+	vx1_timeout_reset_flag = 0;
+}
+
 static irqreturn_t lcd_vbyone_vsync_isr(int irq, void *dev_id)
 {
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct vbyone_config_s *vx1_conf;
+
+	if (lcd_drv->lcd_status == 0)
+		return IRQ_HANDLED;
+	if (lcd_vcbus_read(VBO_STATUS_L) & 0x40) /* hpd detect */
+		return IRQ_HANDLED;
+
 	lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 1, 0, 1);
 	lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 0, 1);
 
+	vx1_conf = lcd_drv->lcd_config->lcd_control.vbyone_config;
+	if (vx1_conf->vsync_intr_en == 0) {
+		vx1_training_wait_cnt = 0;
+		return IRQ_HANDLED;
+	}
+
+#if 0
+	if (vx1_conf->intr_en == 0) {
+		if ((lcd_vcbus_read(VBO_STATUS_L) & 0x3f) != 0x20)
+			if (vx1_timeout_reset_flag == 0) {
+				vx1_timeout_reset_flag = 1;
+				tasklet_schedule(&lcd_vx1_reset_tasklet);
+			}
+		}
+		return IRQ_HANDLED;
+	}
+#endif
+
+#if 1
+	if (vx1_training_wait_cnt >= VX1_TRAINING_TIMEOUT) {
+		if ((lcd_vcbus_read(VBO_STATUS_L) & 0x3f) != 0x20) {
+			if (vx1_timeout_reset_flag == 0) {
+				vx1_timeout_reset_flag = 1;
+				tasklet_schedule(&lcd_vx1_reset_tasklet);
+			}
+		} else {
+			vx1_training_stable_cnt++;
+			if (vx1_training_stable_cnt >= 5) {
+				vx1_training_wait_cnt = 0;
+				vx1_training_stable_cnt = 0;
+			}
+		}
+	} else {
+		vx1_training_wait_cnt++;
+	}
+#else
+	if ((lcd_vcbus_read(VBO_STATUS_L) & 0x3f) != 0x20) {
+		if (vx1_training_wait_cnt >= VX1_TRAINING_TIMEOUT) {
+			if (vx1_timeout_reset_flag == 0) {
+				vx1_timeout_reset_flag = 1;
+				tasklet_schedule(&lcd_vx1_reset_tasklet);
+			}
+		} else {
+			vx1_training_wait_cnt++;
+		}
+	} else {
+		vx1_training_stable_cnt++;
+		if (vx1_training_stable_cnt >= 5) {
+			vx1_training_wait_cnt = 0;
+			vx1_training_stable_cnt = 0;
+		}
+	}
+#endif
+
 	return IRQ_HANDLED;
 }
 
-#define VX1_LOCKN_WAIT_TIMEOUT    100
+#define VX1_LOCKN_WAIT_TIMEOUT    50
 static int vx1_lockn_wait_cnt;
+
+#define VX1_FSM_ACQ_NEXT_STEP_CONTINUE     0
+#define VX1_FSM_ACQ_NEXT_RELEASE_HOLDER    1
+#define VX1_FSM_ACQ_NEXT                   VX1_FSM_ACQ_NEXT_STEP_CONTINUE
 static irqreturn_t lcd_vbyone_interrupt_handler(int irq, void *dev_id)
 {
 	unsigned int data32, data32_1;
+	int encl_clk;
 
 	lcd_vcbus_write(VBO_INTR_UNMASK, 0x0);  /* mask interrupt */
 
+	encl_clk = lcd_encl_clk_msr();
 	data32 = (lcd_vcbus_read(VBO_INTR_STATE) & 0x7fff);
+#if 0
+	if (data32 & 0x1ff) { /* timing error */
+		LCDPR("vx1 timing err: VDE_CHK_LH=0x%04x,0x%04x\n",
+			lcd_vcbus_read(VBO_TMCHK_VDE_STATE_L),
+			lcd_vcbus_read(VBO_TMCHK_VDE_STATE_H));
+	}
+#endif
 	/* clear the interrupt */
 	data32_1 = ((data32 >> 9) << 3);
 	if (data32 & 0x1c0)
@@ -611,25 +854,27 @@ static irqreturn_t lcd_vbyone_interrupt_handler(int irq, void *dev_id)
 		data32_1 |= (1 << 0);
 	lcd_vcbus_setb(VBO_INTR_STATE_CTRL, data32_1, 0, 9);
 	lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 0, 9);
-	LCDPR("vx1 interrupt status = 0x%04x\n", data32);
+	LCDPR("vx1 intr status = 0x%04x, encl_clkmsr = %d",
+		data32, encl_clk);
 
 	if (data32 & 0x200) {
-		LCDPR("vx1 htpdn fall edge occurred\n");
+		LCDPR("vx1 htpdn fall occurred\n");
 		vx1_fsm_acq_st = 0;
 		lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 15, 1);
 	}
 #if 0
 	if (data32 & 0x400) {
-		LCDPR("vx1 htpdn raise edge occurred\n");
+		LCDPR("vx1 htpdn raise occurred\n");
 		vx1_fsm_acq_st = 0;
 		lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 15, 1);
 	}
 #endif
 	if (data32 & 0x800) {
-		LCDPR("vx1 lockn fall edge occurred\n");
+		LCDPR("vx1 lockn fall occurred\n");
 		vx1_fsm_acq_st = 0;
 		lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 15, 1);
 		if (vx1_lockn_wait_cnt++ > VX1_LOCKN_WAIT_TIMEOUT) {
+#if 0
 			LCDPR("vx1 sw reset for lockn timeout\n");
 			/* force PHY to 0 */
 			lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 3, 8, 2);
@@ -643,17 +888,25 @@ static irqreturn_t lcd_vbyone_interrupt_handler(int irq, void *dev_id)
 			lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 7, 1);
 			lcd_vcbus_write(VBO_SOFT_RST, 0);
 			vx1_lockn_wait_cnt = 0;
+#else
+			if (vx1_timeout_reset_flag == 0) {
+				vx1_timeout_reset_flag = 1;
+				tasklet_schedule(&lcd_vx1_reset_tasklet);
+				vx1_lockn_wait_cnt = 0;
+				return IRQ_HANDLED;
+			}
+#endif
 		}
 	}
 #if 0
 	if (data32 & 0x1000) {
-		LCDPR("vx1 lockn raise edge occurred\n");
+		LCDPR("vx1 lockn raise occurred\n");
 		vx1_fsm_acq_st = 0;
 		lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 15, 1);
 	}
 #endif
 	if (data32 & 0x2000) {
-		LCDPR("vx1 fsm_acq wait end\n");
+		/* LCDPR("vx1 fsm_acq wait end\n"); */
 		if (lcd_debug_print_flag) {
 			LCDPR("vx1 status 0: 0x%x, fsm_acq_st: %d\n",
 				lcd_vcbus_read(VBO_STATUS_L), vx1_fsm_acq_st);
@@ -677,23 +930,54 @@ static irqreturn_t lcd_vbyone_interrupt_handler(int irq, void *dev_id)
 		} else {
 			vx1_fsm_acq_st = 2;
 			/* set FSM_continue */
+#if (VX1_FSM_ACQ_NEXT == VX1_FSM_ACQ_NEXT_RELEASE_HOLDER)
+			lcd_vcbus_setb(VBO_FSM_HOLDER_L, 0, 0, 16);
+#else
+			lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 15, 1);
 			lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 1, 15, 1);
+#endif
 		}
 		LCDPR("vx1 status 1: 0x%x, fsm_acq_st: %d\n",
 			lcd_vcbus_read(VBO_STATUS_L), vx1_fsm_acq_st);
 	}
+
+	if (data32 & 0x1ff) {
+		LCDPR("vx1 reset for timing err\n");
+		vx1_fsm_acq_st = 0;
+#if 1
+		/* force PHY to 0 */
+		lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 3, 8, 2);
+		lcd_vcbus_write(VBO_SOFT_RST, 0x1ff);
+		udelay(5);
+		/* clear lockn raising flag */
+		lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 1, 7, 1);
+		/* realease PHY */
+		lcd_hiu_setb(HHI_LVDS_TX_PHY_CNTL0, 0, 8, 2);
+		/* clear lockn raising flag */
+		lcd_vcbus_setb(VBO_INTR_STATE_CTRL, 0, 7, 1);
+		lcd_vcbus_write(VBO_SOFT_RST, 0);
+#else
+		if (vx1_timeout_reset_flag == 0) {
+			vx1_timeout_reset_flag = 2;
+			tasklet_schedule(&lcd_vx1_reset_tasklet);
+			return IRQ_HANDLED;
+		}
+#endif
+	}
+
 	udelay(20);
-	if ((lcd_vcbus_read(VBO_STATUS_L) & 0x3f) == 0x20)
+	if ((lcd_vcbus_read(VBO_STATUS_L) & 0x3f) == 0x20) {
 		vx1_lockn_wait_cnt = 0;
+		/* vx1_training_wait_cnt = 0; */
+#if (VX1_FSM_ACQ_NEXT == VX1_FSM_ACQ_NEXT_RELEASE_HOLDER)
+		lcd_vcbus_setb(VBO_FSM_HOLDER_L, 0xffff, 0, 16);
+#endif
+		LCDPR("vx1 fsm stable\n");
+	}
 
 	/* enable interrupt */
 	lcd_vcbus_setb(VBO_INTR_UNMASK, VBYONE_INTR_UNMASK, 0, 15);
 
-	if (lcd_debug_print_flag) {
-		LCDPR("vx1 vx1_fsm_acq_st: %d\n", vx1_fsm_acq_st);
-		LCDPR("vx1 status: 0x%x\n\n", lcd_vcbus_read(VBO_STATUS_L));
-	}
-
 	return IRQ_HANDLED;
 }
 
@@ -779,7 +1063,7 @@ static void lcd_vbyone_config_set(struct lcd_config_s *pconf)
 	}
 	minlane = vbyone_lane_num[i];
 	if (lane_count < minlane) {
-		LCDPR("error: vbyone lane_num(%d) is less than min(%d)\n",
+		LCDERR("vbyone lane_num(%d) is less than min(%d)\n",
 			lane_count, minlane);
 		lane_count = minlane;
 		pconf->lcd_control.vbyone_config->lane_count = lane_count;
@@ -793,11 +1077,11 @@ static void lcd_vbyone_config_set(struct lcd_config_s *pconf)
 		bit_rate /= 2;
 	}
 	if (bit_rate > (VBYONE_BIT_RATE_MAX * 1000)) {
-		LCDPR("error: vbyone bit rate(%dKHz) is out of max(%dKHz)\n",
+		LCDERR("vbyone bit rate(%dKHz) is out of max(%dKHz)\n",
 			bit_rate, (VBYONE_BIT_RATE_MAX * 1000));
 	}
 	if (bit_rate < (VBYONE_BIT_RATE_MIN * 1000)) {
-		LCDPR("error: vbyone bit rate(%dKHz) is out of min(%dKHz)\n",
+		LCDERR("vbyone bit rate(%dKHz) is out of min(%dKHz)\n",
 			bit_rate, (VBYONE_BIT_RATE_MIN * 1000));
 	}
 	bit_rate = bit_rate * 1000; /* Hz */
@@ -867,7 +1151,6 @@ void lcd_tv_driver_init_pre(void)
 	if (ret)
 		return;
 
-	lcd_tv_config_update(pconf);
 #ifdef CONFIG_AML_VPU
 	request_vpu_clk_vmod(pconf->lcd_timing.lcd_clk, VPU_VENCL);
 	switch_vpu_mem_pd_vmod(VPU_VENCL, VPU_MEM_POWER_ON);
@@ -882,11 +1165,11 @@ void lcd_tv_driver_init_pre(void)
 	default:
 		break;
 	}
-	if (lcd_drv->lcd_status == 0) { /* init */
-		lcd_clk_set(pconf);
-		lcd_venc_set(pconf);
-		lcd_tcon_set(pconf);
-	}
+
+	lcd_clk_set(pconf);
+	lcd_venc_set(pconf);
+	lcd_tcon_set(pconf);
+	lcd_drv->lcd_test_check();
 }
 
 int lcd_tv_driver_init(void)
@@ -900,22 +1183,106 @@ int lcd_tv_driver_init(void)
 	if (ret)
 		return -1;
 
-	if (lcd_drv->lcd_status == 0) { /* init */
-		switch (pconf->lcd_basic.lcd_type) {
-		case LCD_LVDS:
-			lcd_lvds_control_set(pconf);
-			lcd_lvds_phy_set(pconf, 1);
-			break;
-		case LCD_VBYONE:
-			lcd_vbyone_pinmux_set(1);
-			lcd_vbyone_control_set(pconf);
-			lcd_vx1_wait_hpd();
-			lcd_vbyone_phy_set(pconf, 1);
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_LVDS:
+		lcd_lvds_control_set(pconf);
+		lcd_lvds_phy_set(pconf, 1);
+		break;
+	case LCD_VBYONE:
+		lcd_vbyone_pinmux_set(1);
+		lcd_vbyone_control_set(pconf);
+		lcd_vx1_wait_hpd();
+		lcd_vbyone_phy_set(pconf, 1);
+		lcd_vx1_intr_request = 1;
+		queue_delayed_work(lcd_drv->workqueue,
+				&lcd_drv->lcd_vx1_delayed_work,
+				msecs_to_jiffies(LCD_VX1_WAIT_STABLE_DELAY));
+		break;
+	default:
+		break;
+	}
+
+	lcd_vcbus_write(VENC_INTCTRL, 0x200);
+
+	if (lcd_debug_print_flag)
+		LCDPR("%s finished\n", __func__);
+	return 0;
+}
+
+void lcd_tv_driver_disable(void)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct lcd_config_s *pconf;
+	int ret;
+
+	vx1_training_wait_cnt = 0;
+	vx1_timeout_reset_flag = 0;
+
+	LCDPR("disable driver\n");
+	pconf = lcd_drv->lcd_config;
+	ret = lcd_type_supported(pconf);
+	if (ret)
+		return;
+
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_LVDS:
+		lcd_lvds_phy_set(pconf, 0);
+		lcd_lvds_disable();
+		break;
+	case LCD_VBYONE:
+		lcd_vbyone_interrupt_enable(0);
+		lcd_vbyone_phy_set(pconf, 0);
+		lcd_vbyone_pinmux_set(0);
+		lcd_vbyone_disable();
+		break;
+	default:
+		break;
+	}
+
+	lcd_vcbus_write(ENCL_VIDEO_EN, 0); /* disable encl */
+
+	lcd_clk_disable();
+	lcd_clk_gate_switch(0);
+#ifdef CONFIG_AML_VPU
+	switch_vpu_mem_pd_vmod(VPU_VENCL, VPU_MEM_POWER_DOWN);
+	release_vpu_clk_vmod(VPU_VENCL);
+#endif
+
+	if (lcd_debug_print_flag)
+		LCDPR("%s finished\n", __func__);
+}
+
+int lcd_tv_driver_change(void)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct lcd_config_s *pconf;
+	int ret;
+
+	pconf = lcd_drv->lcd_config;
+	LCDPR("tv driver change(ver %s): %s\n", lcd_drv->version,
+		lcd_type_type_to_str(pconf->lcd_basic.lcd_type));
+	ret = lcd_type_supported(pconf);
+	if (ret)
+		return -1;
+
+	lcd_tv_config_update(pconf);
+#ifdef CONFIG_AML_VPU
+	request_vpu_clk_vmod(pconf->lcd_timing.lcd_clk, VPU_VENCL);
+#endif
+
+	if (lcd_drv->lcd_status == 0) {
+		/* only change parameters when panel is off */
+		switch (pconf->lcd_timing.clk_change) {
+		case LCD_CLK_PLL_CHANGE:
+			lcd_clk_generate_parameter(pconf);
 			break;
 		default:
 			break;
 		}
-	} else { /* change */
+	} else {
+		if (pconf->lcd_basic.lcd_type == LCD_VBYONE)
+			lcd_vbyone_interrupt_enable(0);
+
 		switch (pconf->lcd_timing.clk_change) {
 		case LCD_CLK_PLL_CHANGE:
 			lcd_clk_generate_parameter(pconf);
@@ -928,18 +1295,47 @@ int lcd_tv_driver_init(void)
 			break;
 		}
 		lcd_venc_change(pconf);
-	}
-	if (pconf->lcd_basic.lcd_type == LCD_VBYONE)
-		lcd_vbyone_wait_stable();
 
-	lcd_vcbus_write(VENC_INTCTRL, 0x200);
+		if (pconf->lcd_basic.lcd_type == LCD_VBYONE)
+			lcd_vbyone_wait_stable();
+	}
 
 	if (lcd_debug_print_flag)
 		LCDPR("%s finished\n", __func__);
 	return 0;
 }
 
-void lcd_tv_driver_disable(void)
+void lcd_tv_driver_tiny_enable(void)
+{
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+	struct lcd_config_s *pconf;
+	int ret;
+
+	pconf = lcd_drv->lcd_config;
+	ret = lcd_type_supported(pconf);
+	if (ret)
+		return;
+
+	switch (pconf->lcd_basic.lcd_type) {
+	case LCD_LVDS:
+		lcd_lvds_control_set(pconf);
+		lcd_lvds_phy_set(pconf, 1);
+		break;
+	case LCD_VBYONE:
+		lcd_vbyone_pinmux_set(1);
+		lcd_vbyone_control_set(pconf);
+		lcd_vx1_wait_hpd();
+		lcd_vbyone_phy_set(pconf, 1);
+		lcd_vbyone_wait_stable();
+		break;
+	default:
+		break;
+	}
+
+	LCDPR("enable driver\n");
+}
+
+void lcd_tv_driver_tiny_disable(void)
 {
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct lcd_config_s *pconf;
@@ -965,26 +1361,27 @@ void lcd_tv_driver_disable(void)
 	default:
 		break;
 	}
-
-	lcd_vcbus_write(ENCL_VIDEO_EN, 0); /* disable encl */
-
-	lcd_clk_disable();
-	lcd_clk_gate_switch(0);
-#ifdef CONFIG_AML_VPU
-	switch_vpu_mem_pd_vmod(VPU_VENCL, VPU_MEM_POWER_DOWN);
-	release_vpu_clk_vmod(VPU_VENCL);
-#endif
-
-	if (lcd_debug_print_flag)
-		LCDPR("%s finished\n", __func__);
 }
 
 #define VBYONE_IRQF   IRQF_SHARED /* IRQF_DISABLED */ /* IRQF_SHARED */
 
 void lcd_vbyone_interrupt_up(void)
 {
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
 	lcd_vbyone_interrupt_init();
 	vx1_lockn_wait_cnt = 0;
+	vx1_training_wait_cnt = 0;
+	vx1_timeout_reset_flag = 0;
+	vx1_training_stable_cnt = 0;
+	lcd_vx1_intr_request = 0;
+	lcd_encl_clk_err_cnt = 0;
+
+	tasklet_init(&lcd_vx1_reset_tasklet, lcd_vx1_timeout_reset,
+		(unsigned long)123);
+
+	INIT_DELAYED_WORK(&lcd_drv->lcd_vx1_delayed_work,
+		lcd_vx1_wait_stable_delayed);
 
 	if (request_irq(INT_VIU_VSYNC, &lcd_vbyone_vsync_isr,
 		IRQF_SHARED, "vbyone_vsync", (void *)"vbyone_vsync")) {
@@ -1001,14 +1398,30 @@ void lcd_vbyone_interrupt_up(void)
 		if (lcd_debug_print_flag)
 			LCDPR("request vbyone irq successful\n");
 	}
+	lcd_vx1_intr_request = 1;
 	lcd_vbyone_interrupt_enable(1);
+
+	/* add timer to monitor hpll frequency */
+	init_timer(&vx1_hpll_timer);
+	/* vx1_hpll_timer.data = NULL; */
+	vx1_hpll_timer.function = lcd_vx1_hpll_timer_handler;
+	vx1_hpll_timer.expires = jiffies + VX1_HPLL_INTERVAL;
+	add_timer(&vx1_hpll_timer);
+	LCDPR("add vbyone hpll timer handler\n");
 }
 
 void lcd_vbyone_interrupt_down(void)
 {
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
+	del_timer_sync(&vx1_hpll_timer);
+
 	lcd_vbyone_interrupt_enable(0);
 	free_irq(INT_VENC_VX1, (void *)"vbyone");
 	free_irq(INT_VIU_VSYNC, (void *)"vbyone");
+	tasklet_kill(&lcd_vx1_reset_tasklet);
+	cancel_delayed_work(&lcd_drv->lcd_vx1_delayed_work);
+
 	if (lcd_debug_print_flag)
-			LCDPR("free vbyone irq\n");
+		LCDPR("free vbyone irq\n");
 }
diff --git a/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.c b/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.c
index a34dcd7..e69af1d 100644
--- a/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.c
+++ b/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.c
@@ -45,8 +45,6 @@
 static unsigned int lcd_output_vmode;
 static char lcd_output_name[30];
 
-static DEFINE_MUTEX(lcd_vout_mutex);
-
 /* ************************************************** *
    lcd mode function
  * ************************************************** */
@@ -226,6 +224,8 @@ static void lcd_vmode_vinfo_update(enum vmode_e mode)
 	lcd_drv->lcd_info->sync_duration_num = info->frame_rate;
 	lcd_drv->lcd_info->sync_duration_den = 1;
 	lcd_drv->lcd_info->video_clk = pconf->lcd_timing.lcd_clk;
+
+	lcd_hdr_vinfo_update();
 }
 
 /* ************************************************** *
@@ -280,8 +280,7 @@ static int lcd_set_current_vmode(enum vmode_e mode)
 	if (!(mode & VMODE_INIT_BIT_MASK)) {
 		switch (mode & VMODE_MODE_BIT_MASK) {
 		case VMODE_LCD:
-			lcd_drv->driver_init_pre();
-			ret = lcd_drv->driver_init();
+			ret = lcd_drv->driver_change();
 			break;
 		default:
 			ret = -EINVAL;
@@ -300,8 +299,11 @@ static int lcd_vmode_is_supported(enum vmode_e mode)
 
 	mode &= VMODE_MODE_BIT_MASK;
 	lcd_vmode = lcd_get_vmode(mode);
-	LCDPR("%s vmode = %d, lcd_vmode = %d(%s)\n",
-		__func__, mode, lcd_vmode, lcd_vmode_info[lcd_vmode].name);
+	if (lcd_debug_print_flag) {
+		LCDPR("%s vmode = %d, lcd_vmode = %d(%s)\n",
+			__func__, mode, lcd_vmode,
+			lcd_vmode_info[lcd_vmode].name);
+	}
 
 	if (lcd_vmode < LCD_VMODE_MAX)
 		return true;
@@ -385,12 +387,17 @@ static int lcd_set_vframe_rate_hint(int duration)
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct vinfo_s *info;
-	unsigned char fr_policy;
+	int fr_policy;
 	unsigned int frame_rate = 6000;
 	unsigned int duration_num = 60, duration_den = 1;
 	struct lcd_vframe_match_s *vtable = lcd_vframe_match_table_1;
 	int fps, i, n;
 
+	if (lcd_drv->lcd_status == 0) {
+		LCDPR("%s: lcd is disabled, exit\n", __func__);
+		return 0;
+	}
+
 	info = lcd_drv->lcd_info;
 
 	fr_policy = lcd_drv->fr_auto_policy;
@@ -420,6 +427,13 @@ static int lcd_set_vframe_rate_hint(int duration)
 	LCDPR("%s: policy = %d, duration = %d, fps = %d, frame_rate = %d\n",
 		__func__, fr_policy, duration, fps, frame_rate);
 
+	/* if the sync_duration is same as current */
+	if ((duration_num == info->sync_duration_num) &&
+		(duration_den == info->sync_duration_den)) {
+		LCDPR("%s: sync_duration is the same, exit\n", __func__);
+		return 0;
+	}
+
 	/* update vinfo */
 	info->sync_duration_num = duration_num;
 	info->sync_duration_den = duration_den;
@@ -435,6 +449,11 @@ static int lcd_set_vframe_rate_end_hint(void)
 	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
 	struct vinfo_s *info;
 
+	if (lcd_drv->lcd_status == 0) {
+		LCDPR("%s: lcd is disabled, exit\n", __func__);
+		return 0;
+	}
+
 	if (lcd_debug_print_flag)
 		LCDPR("fr_auto_policy = %d\n", lcd_drv->fr_auto_policy);
 	if (lcd_drv->fr_auto_policy) {
@@ -452,19 +471,48 @@ static int lcd_set_vframe_rate_end_hint(void)
 	return 0;
 }
 
+static int lcd_set_vframe_rate_policy(int policy)
+{
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
+	lcd_drv->fr_auto_policy = policy;
+	LCDPR("%s: %d\n", __func__, lcd_drv->fr_auto_policy);
+#endif
+	return 0;
+}
+
+static int lcd_get_vframe_rate_policy(void)
+{
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	struct aml_lcd_drv_s *lcd_drv = aml_lcd_get_driver();
+
+	return lcd_drv->fr_auto_policy;
+#else
+	return 0;
+#endif
+}
+
 #ifdef CONFIG_PM
 static int lcd_suspend(void)
 {
 	aml_lcd_notifier_call_chain(LCD_EVENT_POWER_OFF, NULL);
+	lcd_resume_flag = 0;
 	LCDPR("%s finished\n", __func__);
 	return 0;
 }
+
 static int lcd_resume(void)
 {
-	aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
-	LCDPR("%s finished\n", __func__);
+	if (lcd_resume_flag == 0) {
+		lcd_resume_flag = 1;
+		aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
+		LCDPR("%s finished\n", __func__);
+	}
+
 	return 0;
 }
+
 #endif
 
 static struct vout_server_s lcd_vout_server = {
@@ -477,6 +525,8 @@ static struct vout_server_s lcd_vout_server = {
 		.disable = lcd_vout_disable,
 		.set_vframe_rate_hint = lcd_set_vframe_rate_hint,
 		.set_vframe_rate_end_hint = lcd_set_vframe_rate_end_hint,
+		.set_vframe_rate_policy = lcd_set_vframe_rate_policy,
+		.get_vframe_rate_policy = lcd_get_vframe_rate_policy,
 #ifdef CONFIG_PM
 		.vout_suspend = lcd_suspend,
 		.vout_resume = lcd_resume,
@@ -581,6 +631,8 @@ static void lcd_config_print(struct lcd_config_s *pconf)
 			pconf->lcd_control.lvds_config->dual_port);
 		LCDPR("port_swap = %d\n",
 			pconf->lcd_control.lvds_config->port_swap);
+		LCDPR("lane_reverse = %d\n",
+			pconf->lcd_control.lvds_config->lane_reverse);
 	}
 }
 
@@ -694,14 +746,27 @@ static int lcd_config_load_from_dts(struct lcd_config_s *pconf,
 	case LCD_LVDS:
 		lvdsconf = pconf->lcd_control.lvds_config;
 		ret = of_property_read_u32_array(child, "lvds_attr",
-			&para[0], 4);
+			&para[0], 5);
 		if (ret) {
-			LCDERR("failed to get lvds_attr\n");
+			if (lcd_debug_print_flag)
+				LCDERR("load 4 parameters in lvds_attr\n");
+			ret = of_property_read_u32_array(child, "lvds_attr",
+				&para[0], 4);
+			if (ret) {
+				if (lcd_debug_print_flag)
+					LCDPR("failed to get lvds_attr\n");
+			} else {
+				lvdsconf->lvds_repack = para[0];
+				lvdsconf->dual_port = para[1];
+				lvdsconf->pn_swap = para[2];
+				lvdsconf->port_swap = para[3];
+			}
 		} else {
-			lvdsconf->lvds_repack = para[0];
-			lvdsconf->dual_port = para[1];
-			lvdsconf->pn_swap = para[2];
-			lvdsconf->port_swap = para[3];
+				lvdsconf->lvds_repack = para[0];
+				lvdsconf->dual_port = para[1];
+				lvdsconf->pn_swap = para[2];
+				lvdsconf->port_swap = para[3];
+				lvdsconf->lane_reverse = para[4];
 		}
 		ret = of_property_read_u32_array(child, "phy_attr",
 			&para[0], 4);
@@ -718,20 +783,25 @@ static int lcd_config_load_from_dts(struct lcd_config_s *pconf,
 				lvdsconf->phy_preem = para[1];
 				lvdsconf->phy_clk_vswing = 0;
 				lvdsconf->phy_clk_preem = 0;
-				LCDPR("set phy vswing=%d, preemphasis=%d\n",
+				if (lcd_debug_print_flag) {
+					LCDPR("phy vswing=%d, preemphasis=%d\n",
 					lvdsconf->phy_vswing,
 					lvdsconf->phy_preem);
+				}
 			}
 		} else {
 			lvdsconf->phy_vswing = para[0];
 			lvdsconf->phy_preem = para[1];
 			lvdsconf->phy_clk_vswing = para[2];
 			lvdsconf->phy_clk_preem = para[3];
-			LCDPR("set phy vswing=%d, preemphasis=%d\n",
-				lvdsconf->phy_vswing, lvdsconf->phy_preem);
-			LCDPR("set phy_clk vswing=%d, preemphasis=%d\n",
-				lvdsconf->phy_clk_vswing,
-				lvdsconf->phy_clk_preem);
+			if (lcd_debug_print_flag) {
+				LCDPR("phy vswing=%d, preemphasis=%d\n",
+					lvdsconf->phy_vswing,
+					lvdsconf->phy_preem);
+				LCDPR("phy_clk vswing=%d, preemphasis=%d\n",
+					lvdsconf->phy_clk_vswing,
+					lvdsconf->phy_clk_preem);
+			}
 		}
 		break;
 	case LCD_VBYONE:
@@ -745,6 +815,15 @@ static int lcd_config_load_from_dts(struct lcd_config_s *pconf,
 			pconf->lcd_control.vbyone_config->byte_mode = para[2];
 			pconf->lcd_control.vbyone_config->color_fmt = para[3];
 		}
+		ret = of_property_read_u32_array(child, "vbyone_intr_enable",
+			&para[0], 2);
+		if (ret) {
+			LCDERR("failed to get vbyone_intr_enable\n");
+		} else {
+			pconf->lcd_control.vbyone_config->intr_en = para[0];
+			pconf->lcd_control.vbyone_config->vsync_intr_en =
+				para[1];
+		}
 		ret = of_property_read_u32_array(child, "phy_attr",
 			&para[0], 2);
 		if (ret) {
@@ -753,9 +832,11 @@ static int lcd_config_load_from_dts(struct lcd_config_s *pconf,
 		} else {
 			pconf->lcd_control.vbyone_config->phy_vswing = para[0];
 			pconf->lcd_control.vbyone_config->phy_preem = para[1];
-			LCDPR("set phy vswing=%d, preemphasis=%d\n",
+			if (lcd_debug_print_flag) {
+				LCDPR("phy vswing=%d, preemphasis=%d\n",
 				pconf->lcd_control.vbyone_config->phy_vswing,
 				pconf->lcd_control.vbyone_config->phy_preem);
+			}
 		}
 		break;
 	default:
@@ -790,16 +871,17 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 		return -1;
 	}
 
-	/* check lcd unifykey length */
-	len = 10 + 36 + 18 + 31 + 20;
+	/* step 1: check header */
+	len = LCD_UKEY_HEAD_SIZE;
 	ret = lcd_unifykey_len_check(key_len, len);
 	if (ret < 0) {
+		LCDERR("unifykey header length is incorrect\n");
 		kfree(para);
 		return -1;
 	}
 
-	/* header: 10byte */
 	lcd_unifykey_header_check(para, &lcd_header);
+	len = 10 + 36 + 18 + 31 + 20;
 	if (lcd_debug_print_flag) {
 		LCDPR("unifykey header:\n");
 		LCDPR("crc32             = 0x%08x\n", lcd_header.crc32);
@@ -808,6 +890,14 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 		LCDPR("reserved          = 0x%04x\n", lcd_header.reserved);
 	}
 
+	/* step 2: check lcd parameters */
+	ret = lcd_unifykey_len_check(key_len, len);
+	if (ret < 0) {
+		LCDERR("unifykey parameters length is incorrect\n");
+		kfree(para);
+		return -1;
+	}
+
 	/* basic: 36byte */
 	p = para + LCD_UKEY_HEAD_SIZE;
 	*(p + LCD_UKEY_MODEL_NAME - 1) = '\0'; /* ensure string ending */
@@ -889,42 +979,80 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 		pconf->lcd_control.vbyone_config->phy_vswing =
 				(*p | ((*(p + 1)) << 8)) & 0xff;
 		p += LCD_UKEY_IF_ATTR_4;
-		pconf->lcd_control.vbyone_config->phy_preem  =
-				(*p | ((*(p + 1)) << 8)) & 0xff;
-		p += LCD_UKEY_IF_ATTR_5;
-		/* dummy pointer */
-		p += LCD_UKEY_IF_ATTR_6;
-		p += LCD_UKEY_IF_ATTR_7;
-		p += LCD_UKEY_IF_ATTR_8;
-		p += LCD_UKEY_IF_ATTR_9;
-	} else if (pconf->lcd_basic.lcd_type == LCD_LVDS) {
-		pconf->lcd_control.lvds_config->lvds_repack =
-				(*p | ((*(p + 1)) << 8)) & 0xff;
-		p += LCD_UKEY_IF_ATTR_0;
-		pconf->lcd_control.lvds_config->dual_port =
-				(*p | ((*(p + 1)) << 8)) & 0xff;
-		p += LCD_UKEY_IF_ATTR_1;
-		pconf->lcd_control.lvds_config->pn_swap  =
-				(*p | ((*(p + 1)) << 8)) & 0xff;
-		p += LCD_UKEY_IF_ATTR_2;
-		pconf->lcd_control.lvds_config->port_swap  =
-				(*p | ((*(p + 1)) << 8)) & 0xff;
-		p += LCD_UKEY_IF_ATTR_3;
-		pconf->lcd_control.lvds_config->phy_vswing =
-				(*p | ((*(p + 1)) << 8)) & 0xff;
-		p += LCD_UKEY_IF_ATTR_4;
-		pconf->lcd_control.lvds_config->phy_vswing =
+		pconf->lcd_control.vbyone_config->phy_preem =
 				(*p | ((*(p + 1)) << 8)) & 0xff;
 		p += LCD_UKEY_IF_ATTR_5;
-		pconf->lcd_control.lvds_config->phy_clk_vswing =
+		pconf->lcd_control.vbyone_config->intr_en =
 				(*p | ((*(p + 1)) << 8)) & 0xff;
 		p += LCD_UKEY_IF_ATTR_6;
-		pconf->lcd_control.lvds_config->phy_clk_preem  =
+		pconf->lcd_control.vbyone_config->vsync_intr_en =
 				(*p | ((*(p + 1)) << 8)) & 0xff;
 		p += LCD_UKEY_IF_ATTR_7;
 		/* dummy pointer */
 		p += LCD_UKEY_IF_ATTR_8;
 		p += LCD_UKEY_IF_ATTR_9;
+	} else if (pconf->lcd_basic.lcd_type == LCD_LVDS) {
+		if (lcd_header.version == 1) {
+			pconf->lcd_control.lvds_config->lvds_repack =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_0;
+			pconf->lcd_control.lvds_config->dual_port =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_1;
+			pconf->lcd_control.lvds_config->pn_swap  =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_2;
+			pconf->lcd_control.lvds_config->port_swap  =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_3;
+			pconf->lcd_control.lvds_config->phy_vswing =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_4;
+			pconf->lcd_control.lvds_config->phy_preem =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_5;
+			pconf->lcd_control.lvds_config->phy_clk_vswing =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_6;
+			pconf->lcd_control.lvds_config->phy_clk_preem  =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_7;
+			pconf->lcd_control.lvds_config->lane_reverse = 0;
+			p += LCD_UKEY_IF_ATTR_8;
+			/* dummy pointer */
+			p += LCD_UKEY_IF_ATTR_9;
+			}
+		else if (lcd_header.version == 2) {
+			pconf->lcd_control.lvds_config->lvds_repack =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_0;
+			pconf->lcd_control.lvds_config->dual_port =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_1;
+			pconf->lcd_control.lvds_config->pn_swap  =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_2;
+			pconf->lcd_control.lvds_config->port_swap  =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_3;
+			pconf->lcd_control.lvds_config->lane_reverse  =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_4;
+			pconf->lcd_control.lvds_config->phy_vswing =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_5;
+			pconf->lcd_control.lvds_config->phy_preem =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_6;
+			pconf->lcd_control.lvds_config->phy_clk_vswing =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_7;
+			pconf->lcd_control.lvds_config->phy_clk_preem  =
+					(*p | ((*(p + 1)) << 8)) & 0xff;
+			p += LCD_UKEY_IF_ATTR_8;
+			/* dummy pointer */
+			p += LCD_UKEY_IF_ATTR_9;
+			}
 	} else {
 		LCDERR("unsupport lcd_type: %d\n", pconf->lcd_basic.lcd_type);
 		p += LCD_UKEY_IF_ATTR_0;
@@ -939,7 +1067,8 @@ static int lcd_config_load_from_unifykey(struct lcd_config_s *pconf)
 		p += LCD_UKEY_IF_ATTR_9;
 	}
 
-	ret = lcd_power_load_from_unifykey(pconf, para, key_len);
+	/* step 3: check power sequence */
+	ret = lcd_power_load_from_unifykey(pconf, para, key_len, len);
 	if (ret < 0) {
 		kfree(para);
 		return -1;
@@ -976,10 +1105,10 @@ static void lcd_config_init(struct lcd_config_s *pconf)
 	pconf->lcd_timing.lcd_clk_dft = pconf->lcd_timing.lcd_clk;
 	pconf->lcd_timing.h_period_dft = pconf->lcd_basic.h_period;
 	pconf->lcd_timing.v_period_dft = pconf->lcd_basic.v_period;
+	lcd_tcon_config(pconf); /* before vmode_init to avoid period changing */
 
 	lcd_vmode_init(pconf);
 
-	lcd_tcon_config(pconf);
 	lcd_clk_generate_parameter(pconf);
 	ss_level = pconf->lcd_timing.ss_level;
 	cconf->ss_level = (ss_level >= cconf->ss_level_max) ? 0 : ss_level;
@@ -1003,11 +1132,13 @@ static int lcd_get_config(struct lcd_config_s *pconf, struct device *dev)
 			load_id = 1;
 	}
 	if (load_id) {
-		LCDPR("%s from unifykey\n", __func__);
+		if (lcd_debug_print_flag)
+			LCDPR("%s from unifykey\n", __func__);
 		lcd_drv->lcd_config_load = 1;
 		lcd_config_load_from_unifykey(pconf);
 	} else {
-		LCDPR("%s from dts\n", __func__);
+		if (lcd_debug_print_flag)
+			LCDPR("%s from dts\n", __func__);
 		lcd_drv->lcd_config_load = 0;
 		lcd_config_load_from_dts(pconf, dev);
 	}
@@ -1095,6 +1226,9 @@ int lcd_tv_probe(struct device *dev)
 	lcd_drv->driver_init_pre = lcd_tv_driver_init_pre;
 	lcd_drv->driver_init = lcd_tv_driver_init;
 	lcd_drv->driver_disable = lcd_tv_driver_disable;
+	lcd_drv->driver_change = lcd_tv_driver_change;
+	lcd_drv->driver_tiny_enable = lcd_tv_driver_tiny_enable;
+	lcd_drv->driver_tiny_disable = lcd_tv_driver_tiny_disable;
 
 	lcd_get_config(lcd_drv->lcd_config, dev);
 
diff --git a/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.h b/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.h
index e5bc48a..baa4345 100644
--- a/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.h
+++ b/drivers/amlogic/display/lcd/lcd_tv/lcd_tv.h
@@ -20,12 +20,15 @@
 #define __AML_LCD_TV_H__
 #include <linux/amlogic/vout/lcd_vout.h>
 
-#define LCD_DRV_VERSION    "20160630"
+#define LCD_DRV_VERSION    "20161130"
 
 extern void lcd_tv_config_update(struct lcd_config_s *pconf);
 extern void lcd_tv_driver_init_pre(void);
 extern int lcd_tv_driver_init(void);
 extern void lcd_tv_driver_disable(void);
+extern int lcd_tv_driver_change(void);
+extern void lcd_tv_driver_tiny_enable(void);
+extern void lcd_tv_driver_tiny_disable(void);
 
 extern void lcd_vbyone_wait_stable(void);
 extern void lcd_vbyone_interrupt_up(void);
diff --git a/drivers/amlogic/display/lcd/lcd_vout.c b/drivers/amlogic/display/lcd/lcd_vout.c
index d480ce1..3bb0fb6 100644
--- a/drivers/amlogic/display/lcd/lcd_vout.c
+++ b/drivers/amlogic/display/lcd/lcd_vout.c
@@ -22,6 +22,9 @@
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
 #include <linux/string.h>
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
@@ -44,11 +47,24 @@
 #include "lcd_reg.h"
 #include "lcd_common.h"
 
-unsigned int lcd_debug_print_flag;
+#define LCD_CDEV_NAME  "lcd"
+
+unsigned char lcd_debug_print_flag;
+unsigned char lcd_resume_flag;
 static struct aml_lcd_drv_s *lcd_driver;
 
+struct mutex lcd_vout_mutex;
+
 static char lcd_propname[20] = "lvds_0";
 
+struct lcd_cdev_s {
+	dev_t           devno;
+	struct cdev     cdev;
+	struct device   *dev;
+};
+
+static struct lcd_cdev_s *lcd_cdev;
+
 /* *********************************************************
  * lcd config define
  * ********************************************************* */
@@ -64,6 +80,7 @@ static struct lvds_config_s lcd_lvds_config = {
 	.dual_port = 0,
 	.pn_swap = 0,
 	.port_swap = 0,
+	.lane_reverse = 0,
 	.port_sel = 0,
 	.phy_vswing = LVDS_PHY_VSWING_DFT,
 	.phy_preem = LVDS_PHY_PREEM_DFT,
@@ -78,6 +95,8 @@ static struct vbyone_config_s lcd_vbyone_config = {
 	.bit_rate = 0,
 	.phy_vswing = VX1_PHY_VSWING_DFT,
 	.phy_preem = VX1_PHY_PREEM_DFT,
+	.intr_en = 1,
+	.vsync_intr_en = 1,
 };
 
 static unsigned char dsi_init_on_table[DSI_INIT_ON_MAX] = {0xff, 0xff};
@@ -157,6 +176,21 @@ static struct lcd_config_s lcd_config_dft = {
 		.gamma_b_coeff = 100,
 		*/
 	},
+	.hdr_info = {
+		.hdr_support = 0,
+		.features = 0,
+		.primaries_r_x = 0,
+		.primaries_r_y = 0,
+		.primaries_g_x = 0,
+		.primaries_g_y = 0,
+		.primaries_b_x = 0,
+		.primaries_b_y = 0,
+		.white_point_x = 0,
+		.white_point_y = 0,
+		.luma_max = 0,
+		.luma_min = 0,
+		.luma_avg = 0,
+	},
 	.lcd_control = {
 		.ttl_config = &lcd_ttl_config,
 		.lvds_config = &lcd_lvds_config,
@@ -179,6 +213,108 @@ struct aml_lcd_drv_s *aml_lcd_get_driver(void)
 }
 /* ********************************************************* */
 
+static void lcd_chip_detect(void)
+{
+	unsigned int cpu_type;
+
+	cpu_type = get_cpu_type();
+	switch (cpu_type) {
+	case MESON_CPU_MAJOR_ID_M8:
+		lcd_driver->chip_type = LCD_CHIP_M8;
+		break;
+	case MESON_CPU_MAJOR_ID_M8B:
+		lcd_driver->chip_type = LCD_CHIP_M8B;
+		break;
+	case MESON_CPU_MAJOR_ID_M8M2:
+		lcd_driver->chip_type = LCD_CHIP_M8M2;
+		break;
+	case MESON_CPU_MAJOR_ID_MG9TV:
+		lcd_driver->chip_type = LCD_CHIP_G9TV;
+		break;
+	case MESON_CPU_MAJOR_ID_GXTVBB:
+		lcd_driver->chip_type = LCD_CHIP_GXTVBB;
+		break;
+	case MESON_CPU_MAJOR_ID_TXL:
+		lcd_driver->chip_type = LCD_CHIP_TXL;
+		break;
+	default:
+		lcd_driver->chip_type = LCD_CHIP_MAX;
+	}
+
+	if (lcd_debug_print_flag)
+		LCDPR("check chip: %d\n", lcd_driver->chip_type);
+}
+
+static void lcd_power_tiny_ctrl(int status)
+{
+	struct lcd_power_ctrl_s *lcd_power = lcd_driver->lcd_config->lcd_power;
+	struct lcd_power_step_s *power_step;
+#ifdef CONFIG_AML_LCD_EXTERN
+	struct aml_lcd_extern_driver_s *ext_drv;
+#endif
+	int i, index;
+
+	LCDPR("%s: %d\n", __func__, status);
+	i = 0;
+	while (i < LCD_PWR_STEP_MAX) {
+		if (status)
+			power_step = &lcd_power->power_on_step[i];
+		else
+			power_step = &lcd_power->power_off_step[i];
+
+		if (power_step->type >= LCD_POWER_TYPE_MAX)
+			break;
+		if (lcd_debug_print_flag) {
+			LCDPR("power_tiny_ctrl: %d, step %d\n", status, i);
+			LCDPR("type=%d, index=%d, value=%d, delay=%d\n",
+				power_step->type, power_step->index,
+				power_step->value, power_step->delay);
+		}
+		switch (power_step->type) {
+		case LCD_POWER_TYPE_CPU:
+			index = power_step->index;
+			lcd_cpu_gpio_set(index, power_step->value);
+			break;
+		case LCD_POWER_TYPE_PMU:
+			LCDPR("to do\n");
+			break;
+		case LCD_POWER_TYPE_SIGNAL:
+			if (status)
+				lcd_driver->driver_tiny_enable();
+			else
+				lcd_driver->driver_tiny_disable();
+			break;
+#ifdef CONFIG_AML_LCD_EXTERN
+		case LCD_POWER_TYPE_EXTERN:
+			index = power_step->index;
+			ext_drv = aml_lcd_extern_get_driver(index);
+			if (ext_drv) {
+				if (status) {
+					if (ext_drv->power_on)
+						ext_drv->power_on();
+					else
+						LCDERR("no ext power on\n");
+				} else {
+					if (ext_drv->power_off)
+						ext_drv->power_off();
+					else
+						LCDERR("no ext power off\n");
+				}
+			}
+			break;
+#endif
+		default:
+			break;
+		}
+		if (power_step->delay)
+			mdelay(power_step->delay);
+		i++;
+	}
+
+	if (lcd_debug_print_flag)
+		LCDPR("%s: %d finished\n", __func__, status);
+}
+
 static void lcd_power_ctrl(int status)
 {
 	struct lcd_power_ctrl_s *lcd_power = lcd_driver->lcd_config->lcd_power;
@@ -252,23 +388,52 @@ static void lcd_power_ctrl(int status)
 
 static void lcd_module_enable(void)
 {
-	/*LCDPR("driver version: %s\n", lcd_driver->version);*/
+	mutex_lock(&lcd_vout_mutex);
+
 	lcd_driver->driver_init_pre();
 	lcd_driver->power_ctrl(1);
 	lcd_driver->lcd_status = 1;
+
+	mutex_unlock(&lcd_vout_mutex);
 }
 
 static void lcd_module_disable(void)
 {
+	mutex_lock(&lcd_vout_mutex);
+
 	lcd_driver->lcd_status = 0;
 	lcd_driver->power_ctrl(0);
+
+	mutex_unlock(&lcd_vout_mutex);
 }
 
 static void lcd_module_reset(void)
 {
-	lcd_module_disable();
-	mdelay(200);
-	lcd_module_enable();
+	mutex_lock(&lcd_vout_mutex);
+
+	lcd_driver->lcd_status = 0;
+	lcd_driver->power_ctrl(0);
+
+	mdelay(500);
+
+	lcd_driver->driver_init_pre();
+	lcd_driver->power_ctrl(1);
+	lcd_driver->lcd_status = 1;
+
+	mutex_unlock(&lcd_vout_mutex);
+}
+
+static void lcd_module_tiny_reset(void)
+{
+	mutex_lock(&lcd_vout_mutex);
+
+	lcd_driver->lcd_status = 0;
+	lcd_power_tiny_ctrl(0);
+	mdelay(500);
+	lcd_power_tiny_ctrl(1);
+	lcd_driver->lcd_status = 1;
+
+	mutex_unlock(&lcd_vout_mutex);
 }
 
 /* ****************************************
@@ -313,40 +478,181 @@ static int lcd_bl_select_notifier(struct notifier_block *nb,
 static struct notifier_block lcd_bl_select_nb = {
 	.notifier_call = lcd_bl_select_notifier,
 };
+
+static int lcd_reboot_notifier(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+	if (lcd_debug_print_flag)
+		LCDPR("%s: %lu\n", __func__, event);
+	if (lcd_driver->lcd_status == 0)
+		return NOTIFY_DONE;
+
+	aml_lcd_notifier_call_chain(LCD_EVENT_POWER_OFF, NULL);
+
+	return NOTIFY_OK;
+}
+static struct notifier_block lcd_reboot_nb = {
+	.notifier_call = lcd_reboot_notifier,
+};
 /* **************************************** */
 
-static void lcd_chip_detect(void)
+/* ************************************************************* */
+/* lcd ioctl                                                     */
+/* ************************************************************* */
+static int lcd_io_open(struct inode *inode, struct file *file)
 {
-	unsigned int cpu_type;
+	struct lcd_cdev_s *lcd_cdev;
 
-	cpu_type = get_cpu_type();
-	switch (cpu_type) {
-	case MESON_CPU_MAJOR_ID_M8:
-		lcd_driver->chip_type = LCD_CHIP_M8;
-		break;
-	case MESON_CPU_MAJOR_ID_M8B:
-		lcd_driver->chip_type = LCD_CHIP_M8B;
-		break;
-	case MESON_CPU_MAJOR_ID_M8M2:
-		lcd_driver->chip_type = LCD_CHIP_M8M2;
-		break;
-	case MESON_CPU_MAJOR_ID_MG9TV:
-		lcd_driver->chip_type = LCD_CHIP_G9TV;
-		break;
-	case MESON_CPU_MAJOR_ID_GXTVBB:
-		lcd_driver->chip_type = LCD_CHIP_GXTVBB;
+	LCDPR("%s\n", __func__);
+	lcd_cdev = container_of(inode->i_cdev, struct lcd_cdev_s, cdev);
+	file->private_data = lcd_cdev;
+	return 0;
+}
+
+static int lcd_io_release(struct inode *inode, struct file *file)
+{
+	LCDPR("%s\n", __func__);
+	file->private_data = NULL;
+	return 0;
+}
+
+static long lcd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	void __user *argp;
+	int mcd_nr;
+	struct lcd_hdr_info_s *hdr_info = &lcd_driver->lcd_config->hdr_info;
+
+	mcd_nr = _IOC_NR(cmd);
+	LCDPR("%s: cmd_dir = 0x%x, cmd_nr = 0x%x\n",
+		__func__, _IOC_DIR(cmd), mcd_nr);
+
+	argp = (void __user *)arg;
+	switch (mcd_nr) {
+	case LCD_IOC_NR_GET_HDR_INFO:
+		if (copy_to_user(argp, hdr_info, sizeof(struct lcd_hdr_info_s)))
+			ret = -EFAULT;
 		break;
-	case MESON_CPU_MAJOR_ID_TXL:
-		lcd_driver->chip_type = LCD_CHIP_TXL;
+	case LCD_IOC_NR_SET_HDR_INFO:
+		if (copy_from_user(hdr_info, argp,
+			sizeof(struct lcd_hdr_info_s))) {
+			ret = -EFAULT;
+		} else {
+			lcd_hdr_vinfo_update();
+			if (lcd_debug_print_flag) {
+				LCDPR("set hdr_info:\n"
+					"hdr_support          %d\n"
+					"features             %d\n"
+					"primaries_r_x        %d\n"
+					"primaries_r_y        %d\n"
+					"primaries_g_x        %d\n"
+					"primaries_g_y        %d\n"
+					"primaries_b_x        %d\n"
+					"primaries_b_y        %d\n"
+					"white_point_x        %d\n"
+					"white_point_y        %d\n"
+					"luma_max             %d\n"
+					"luma_min             %d\n\n",
+					hdr_info->hdr_support,
+					hdr_info->features,
+					hdr_info->primaries_r_x,
+					hdr_info->primaries_r_y,
+					hdr_info->primaries_g_x,
+					hdr_info->primaries_g_y,
+					hdr_info->primaries_b_x,
+					hdr_info->primaries_b_y,
+					hdr_info->white_point_x,
+					hdr_info->white_point_y,
+					hdr_info->luma_max,
+					hdr_info->luma_min);
+			}
+		}
 		break;
 	default:
-		lcd_driver->chip_type = LCD_CHIP_MAX;
+		LCDERR("not support ioctl cmd_nr: 0x%x\n", mcd_nr);
+		ret = -EINVAL;
+		break;
 	}
 
-	if (lcd_debug_print_flag)
-		LCDPR("check chip: %d\n", lcd_driver->chip_type);
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static long lcd_compat_ioctl(struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	unsigned long ret;
+
+	arg = (unsigned long)compat_ptr(arg);
+	ret = lcd_ioctl(file, cmd, arg);
+	return ret;
+}
+#endif
+
+static const struct file_operations lcd_fops = {
+	.owner          = THIS_MODULE,
+	.open           = lcd_io_open,
+	.release        = lcd_io_release,
+	.unlocked_ioctl = lcd_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl   = lcd_compat_ioctl,
+#endif
+};
+
+static int lcd_fops_create(void)
+{
+	int ret = 0;
+
+	lcd_cdev = kmalloc(sizeof(struct lcd_cdev_s), GFP_KERNEL);
+	if (!lcd_cdev) {
+		LCDERR("%s: failed to allocate lcd_cdev\n", __func__);
+		return -1;
+	}
+
+	ret = alloc_chrdev_region(&lcd_cdev->devno, 0, 1, LCD_CDEV_NAME);
+	if (ret < 0) {
+		LCDERR("%s: faild to alloc devno\n", __func__);
+		kfree(lcd_cdev);
+		lcd_cdev = NULL;
+		return -1;
+	}
+
+	cdev_init(&lcd_cdev->cdev, &lcd_fops);
+	lcd_cdev->cdev.owner = THIS_MODULE;
+	ret = cdev_add(&lcd_cdev->cdev, lcd_cdev->devno, 1);
+	if (ret) {
+		LCDERR("%s: failed to add cdev\n", __func__);
+		unregister_chrdev_region(lcd_cdev->devno, 1);
+		kfree(lcd_cdev);
+		lcd_cdev = NULL;
+		return -1;
+	}
+
+	lcd_cdev->dev = device_create(lcd_driver->lcd_debug_class, NULL,
+			lcd_cdev->devno, NULL, LCD_CDEV_NAME);
+	if (IS_ERR(lcd_cdev->dev)) {
+		LCDERR("%s: failed to add device\n", __func__);
+		ret = PTR_ERR(lcd_cdev->dev);
+		cdev_del(&lcd_cdev->cdev);
+		unregister_chrdev_region(lcd_cdev->devno, 1);
+		kfree(lcd_cdev);
+		lcd_cdev = NULL;
+		return -1;
+	}
+
+	LCDPR("%s OK\n", __func__);
+	return 0;
 }
 
+static void lcd_fops_remove(void)
+{
+	cdev_del(&lcd_cdev->cdev);
+	unregister_chrdev_region(lcd_cdev->devno, 1);
+	kfree(lcd_cdev);
+	lcd_cdev = NULL;
+}
+/* ************************************************************* */
+
 static void lcd_init_vout(void)
 {
 	switch (lcd_driver->lcd_mode) {
@@ -361,27 +667,11 @@ static void lcd_init_vout(void)
 		break;
 #endif
 	default:
-		LCDPR("invalid lcd mode\n");
+		LCDERR("invalid lcd mode: %d\n", lcd_driver->lcd_mode);
 		break;
 	}
 }
 
-static int lcd_reboot_notifier(struct notifier_block *nb,
-		unsigned long event, void *data)
-{
-	if (lcd_debug_print_flag)
-		LCDPR("%s: %lu\n", __func__, event);
-	if (lcd_driver->lcd_status == 0)
-		return NOTIFY_DONE;
-
-	aml_lcd_notifier_call_chain(LCD_EVENT_POWER_OFF, NULL);
-
-	return NOTIFY_OK;
-}
-static struct notifier_block lcd_reboot_nb = {
-	.notifier_call = lcd_reboot_notifier,
-};
-
 static int lcd_mode_probe(struct device *dev)
 {
 	int ret;
@@ -398,14 +688,15 @@ static int lcd_mode_probe(struct device *dev)
 		break;
 #endif
 	default:
-		LCDPR("invalid lcd mode\n");
+		LCDERR("invalid lcd mode: %d\n", lcd_driver->lcd_mode);
 		break;
 	}
 
 	lcd_class_creat();
+	lcd_fops_create();
 	ret = aml_lcd_notifier_register(&lcd_bl_select_nb);
 	if (ret)
-		LCDERR("register aml_bl_on_notifier failed\n");
+		LCDERR("register aml_bl_select_notifier failed\n");
 	ret = aml_lcd_notifier_register(&lcd_power_nb);
 	if (ret)
 		LCDPR("register lcd_power_notifier failed\n");
@@ -413,6 +704,10 @@ static int lcd_mode_probe(struct device *dev)
 	if (ret)
 		LCDERR("register lcd_reboot_notifier failed\n");
 
+	/* add notifier for video sync_duration info refresh */
+	vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE,
+		&lcd_driver->lcd_info->mode);
+
 	return 0;
 }
 
@@ -469,10 +764,13 @@ static void lcd_config_default(void)
 			- lcd_vcbus_read(ENCL_VIDEO_HAVON_BEGIN) + 1;
 	pconf->lcd_basic.v_active = lcd_vcbus_read(ENCL_VIDEO_VAVON_ELINE)
 			- lcd_vcbus_read(ENCL_VIDEO_VAVON_BLINE) + 1;
-	if (lcd_vcbus_read(ENCL_VIDEO_EN))
+	if (lcd_vcbus_read(ENCL_VIDEO_EN)) {
 		lcd_driver->lcd_status = 1;
-	else
+		lcd_resume_flag = 1;
+	} else {
 		lcd_driver->lcd_status = 0;
+		lcd_resume_flag = 0;
+	}
 	LCDPR("status: %d\n", lcd_driver->lcd_status);
 }
 
@@ -520,15 +818,18 @@ static int lcd_config_probe(void)
 	lcd_driver->lcd_config = &lcd_config_dft;
 	lcd_driver->lcd_config->pinmux_flag = 0;
 	lcd_driver->vpp_sel = 1;
+	lcd_driver->lcd_test_flag = 0;
 	lcd_driver->power_ctrl = lcd_power_ctrl;
 	lcd_driver->module_reset = lcd_module_reset;
+	lcd_driver->power_tiny_ctrl = lcd_power_tiny_ctrl;
+	lcd_driver->module_tiny_reset = lcd_module_tiny_reset;
 	lcd_config_default();
 	lcd_init_vout();
 
 	if (lcd_driver->lcd_key_valid) {
 		if (lcd_driver->workqueue) {
 			queue_delayed_work(lcd_driver->workqueue,
-				&lcd_driver->lcd_delayed_work,
+				&lcd_driver->lcd_probe_delayed_work,
 				msecs_to_jiffies(2000));
 		} else {
 			LCDPR("Warning: no lcd_probe_delayed workqueue\n");
@@ -551,8 +852,17 @@ static int lcd_config_probe(void)
 	return 0;
 }
 
+static void lcd_resume_work(struct work_struct *p_work)
+{
+	lcd_resume_flag = 1;
+	aml_lcd_notifier_call_chain(LCD_EVENT_POWER_ON, NULL);
+	LCDPR("%s finished\n", __func__);
+}
+
 static int lcd_probe(struct platform_device *pdev)
 {
+	int ret = 0;
+
 #ifdef LCD_DEBUG_INFO
 	lcd_debug_print_flag = 1;
 #else
@@ -560,24 +870,28 @@ static int lcd_probe(struct platform_device *pdev)
 #endif
 	lcd_driver = kmalloc(sizeof(struct aml_lcd_drv_s), GFP_KERNEL);
 	if (!lcd_driver) {
-		LCDERR("probe: Not enough memory\n");
+		LCDERR("%s: lcd driver no enough memory\n", __func__);
 		return -ENOMEM;
 	}
 	lcd_driver->dev = &pdev->dev;
 
+	mutex_init(&lcd_vout_mutex);
+
 	/* init workqueue */
-	INIT_DELAYED_WORK(&lcd_driver->lcd_delayed_work,
+	INIT_DELAYED_WORK(&lcd_driver->lcd_probe_delayed_work,
 		lcd_config_probe_delayed);
-	lcd_driver->workqueue = create_workqueue("lcd_probe_queue");
+	lcd_driver->workqueue = create_workqueue("lcd_work_queue");
 	if (lcd_driver->workqueue == NULL)
 		LCDERR("can't create lcd workqueue\n");
 
+	INIT_WORK(&(lcd_driver->lcd_resume_work), lcd_resume_work);
+
 	lcd_chip_detect();
 	lcd_ioremap();
 	lcd_clk_config_probe();
-	lcd_config_probe();
+	ret = lcd_config_probe();
 
-	LCDPR("%s\n", __func__);
+	LCDPR("%s %s\n", __func__, (ret ? "failed" : "ok"));
 	return 0;
 }
 
@@ -585,21 +899,43 @@ static int lcd_remove(struct platform_device *pdev)
 {
 	int ret;
 
-	ret = cancel_delayed_work(&lcd_driver->lcd_delayed_work);
+	ret = cancel_delayed_work(&lcd_driver->lcd_probe_delayed_work);
 	if (lcd_driver->workqueue)
 		destroy_workqueue(lcd_driver->workqueue);
 
 	if (lcd_driver) {
 		aml_lcd_notifier_unregister(&lcd_power_nb);
 		aml_lcd_notifier_unregister(&lcd_bl_select_nb);
+
+		lcd_fops_remove();
 		lcd_class_remove();
 		lcd_mode_remove(lcd_driver->dev);
 		kfree(lcd_driver);
 		lcd_driver = NULL;
 	}
+
+	LCDPR("%s\n", __func__);
 	return 0;
 }
 
+static int lcd_resume(struct platform_device *pdev)
+{
+	queue_work(lcd_driver->workqueue, &(lcd_driver->lcd_resume_work));
+
+	return 0;
+}
+
+static int lcd_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	if (lcd_driver->lcd_status) {
+		aml_lcd_notifier_call_chain(LCD_EVENT_POWER_OFF, NULL);
+		lcd_resume_flag = 0;
+		LCDPR("%s finished\n", __func__);
+	}
+	return 0;
+}
+
+
 #ifdef CONFIG_OF
 static const struct of_device_id lcd_dt_match[] = {
 	{
@@ -612,6 +948,8 @@ static const struct of_device_id lcd_dt_match[] = {
 static struct platform_driver lcd_platform_driver = {
 	.probe = lcd_probe,
 	.remove = lcd_remove,
+	.suspend = lcd_suspend,
+	.resume = lcd_resume,
 	.driver = {
 		.name = "mesonlcd",
 		.owner = THIS_MODULE,
@@ -624,7 +962,7 @@ static struct platform_driver lcd_platform_driver = {
 static int __init lcd_init(void)
 {
 	if (platform_driver_register(&lcd_platform_driver)) {
-		LCDPR("failed to register lcd driver module\n");
+		LCDERR("failed to register lcd driver module\n");
 		return -ENODEV;
 	}
 
@@ -639,15 +977,15 @@ static void __exit lcd_exit(void)
 arch_initcall(lcd_init);
 module_exit(lcd_exit);
 
-static int __init lcd_boot_para_setup(char *s)
+static int __init lcd_panel_type_para_setup(char *str)
 {
-	if (NULL != s)
-		sprintf(lcd_propname, "%s", s);
+	if (str != NULL)
+		sprintf(lcd_propname, "%s", str);
 
 	LCDPR("panel_type: %s\n", lcd_propname);
 	return 0;
 }
-__setup("panel_type=", lcd_boot_para_setup);
+__setup("panel_type=", lcd_panel_type_para_setup);
 
 MODULE_DESCRIPTION("Meson LCD Panel Driver");
 MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/display/osd/Makefile b/drivers/amlogic/display/osd/Makefile
index 0647800..9befbb1 100644
--- a/drivers/amlogic/display/osd/Makefile
+++ b/drivers/amlogic/display/osd/Makefile
@@ -1,6 +1,6 @@
 obj-$(CONFIG_AM_FB) += fb.o
-fb-objs = osd_hw.o osd_fb.o osd_debug.o
-fb-objs += osd_prot.o osd_antiflicker.o osd_clone.o
+fb-objs = osd_hw.o osd_fb.o osd_debug.o osd_backup.o
+fb-objs += osd_antiflicker.o osd_clone.o
 
 obj-$(CONFIG_FB_OSD_VSYNC_RDMA) += osd_rdma.o
 
diff --git a/drivers/amlogic/display/osd/osd.h b/drivers/amlogic/display/osd/osd.h
index a698698..25e7df0 100644
--- a/drivers/amlogic/display/osd/osd.h
+++ b/drivers/amlogic/display/osd/osd.h
@@ -49,6 +49,7 @@
 #define FBIOPUT_OSD_ROTATE_ON            0x4516
 #define FBIOPUT_OSD_ROTATE_ANGLE         0x4517
 #define FBIOPUT_OSD_SYNC_ADD             0x4518
+#define FBIOPUT_OSD_SYNC_RENDER_ADD      0x4519
 
 /* OSD color definition */
 #define KEYCOLOR_FLAG_TARGET  1
@@ -74,7 +75,7 @@
 #define OSD_RIGHT 1
 #define OSD_ORDER_01 1
 #define OSD_ORDER_10 2
-#define OSD_GLOBAL_ALPHA_DEF 0xff
+#define OSD_GLOBAL_ALPHA_DEF 0x100
 #define OSD_DATA_BIG_ENDIAN 0
 #define OSD_DATA_LITTLE_ENDIAN 1
 #define OSD_TC_ALPHA_ENABLE_DEF 0  /* disable tc_alpha */
@@ -162,6 +163,8 @@ enum osd_dev_e {
 enum reverse_info_e {
 	REVERSE_FALSE = 0,
 	REVERSE_TRUE,
+	REVERSE_X,
+	REVERSE_Y,
 	REVERSE_MAX
 };
 
@@ -178,6 +181,7 @@ enum hw_reg_index_e {
 	DISP_FREESCALE_ENABLE,
 	DISP_OSD_REVERSE,
 	DISP_OSD_ROTATE,
+	OSD_FIFO,
 	HW_REG_INDEX_MAX
 };
 
@@ -193,6 +197,8 @@ struct fb_geometry_s {
 	u32 height;
 	u32 canvas_idx;
 	u32 addr;
+	u32 xres;
+	u32 yres;
 };
 
 struct osd_scale_s {
@@ -226,6 +232,12 @@ struct osd_fence_map_s {
 	s32 in_fd;
 	s32 out_fd;
 	u32 val;
+	u32 ext_addr;
+	u32 format;
+	u32 width;
+	u32 height;
+	u32 op;
+	u32 reserve;
 	struct sync_fence *in_fence;
 	struct files_struct *files;
 };
@@ -249,9 +261,9 @@ struct hw_para_s {
 	struct pandata_s pandata[HW_OSD_COUNT];
 	struct pandata_s dispdata[HW_OSD_COUNT];
 	struct pandata_s scaledata[HW_OSD_COUNT];
-	struct pandata_s free_scale_data[HW_OSD_COUNT];
+	struct pandata_s free_src_data[HW_OSD_COUNT];
 	struct pandata_s free_dst_data[HW_OSD_COUNT];
-	struct pandata_s rotation_pandata[HW_OSD_COUNT];
+	/* struct pandata_s rotation_pandata[HW_OSD_COUNT]; */
 	struct pandata_s cursor_dispdata[HW_OSD_COUNT];
 
 	u32 gbl_alpha[HW_OSD_COUNT];
@@ -265,19 +277,18 @@ struct hw_para_s {
 	struct osd_scale_s scale[HW_OSD_COUNT];
 	struct osd_scale_s free_scale[HW_OSD_COUNT];
 	u32 free_scale_enable[HW_OSD_COUNT];
-	u32 free_scale_width[HW_OSD_COUNT];
-	u32 free_scale_height[HW_OSD_COUNT];
 	struct fb_geometry_s fb_gem[HW_OSD_COUNT];
 	const struct color_bit_define_s *color_info[HW_OSD_COUNT];
+	const struct color_bit_define_s *color_backup[HW_OSD_COUNT];
 	u32 scan_mode;
 	u32 order;
 	struct osd_3d_mode_s mode_3d[HW_OSD_COUNT];
 	u32 updated[HW_OSD_COUNT];
-	u32 block_windows[HW_OSD_COUNT][HW_OSD_BLOCK_REG_COUNT];
+	/* u32 block_windows[HW_OSD_COUNT][HW_OSD_BLOCK_REG_COUNT]; */
 	u32 block_mode[HW_OSD_COUNT];
 	u32 free_scale_mode[HW_OSD_COUNT];
 	u32 osd_reverse[HW_OSD_COUNT];
-	struct osd_rotate_s rotate[HW_OSD_COUNT];
+	/* struct osd_rotate_s rotate[HW_OSD_COUNT]; */
 	struct hw_list_s reg[HW_OSD_COUNT][HW_REG_INDEX_MAX];
 	u32 field_out_en;
 	u32 scale_workaround;
@@ -286,7 +297,9 @@ struct hw_para_s {
 	u32 angle[HW_OSD_COUNT];
 	u32 clone[HW_OSD_COUNT];
 	u32 bot_type;
+	u32 hw_reset_flag;
 	struct afbcd_data_s osd_afbcd[HW_OSD_COUNT];
+	u32 urgent[HW_OSD_COUNT];
 };
 
 #endif /* _OSD_H_ */
diff --git a/drivers/amlogic/display/osd/osd_backup.c b/drivers/amlogic/display/osd/osd_backup.c
new file mode 100644
index 0000000..0cc3544
--- /dev/null
+++ b/drivers/amlogic/display/osd/osd_backup.c
@@ -0,0 +1,517 @@
+/*
+ * drivers/amlogic/display/osd/osd_backup.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+
+/* Linux Headers */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+
+/* Local Headers */
+#include "osd_io.h"
+#include "osd_backup.h"
+
+const u16 osd_reg_backup[OSD_REG_BACKUP_COUNT] = {
+	0x1a10, 0x1a13,
+	0x1a17, 0x1a18, 0x1a19, 0x1a1a, 0x1a1b, 0x1a1c, 0x1a1d, 0x1a1e,
+	0x1a2b, 0x1a2d
+};
+
+const u16 osd_afbc_reg_backup[OSD_AFBC_REG_BACKUP_COUNT] = {
+	0x31aa, 0x31a9,
+	0x31a6, 0x31a5, 0x31a4, 0x31a3, 0x31a2, 0x31a1, 0x31a0
+};
+
+static u32 osd_backup_count = OSD_VALUE_COUNT;
+static u32 afbc_backup_count = OSD_AFBC_VALUE_COUNT;
+u32 osd_backup[OSD_VALUE_COUNT];
+u32 osd_afbc_backup[OSD_AFBC_VALUE_COUNT];
+module_param_array(osd_backup, uint, &osd_backup_count, 0444);
+MODULE_PARM_DESC(osd_backup, "\n osd register backup\n");
+module_param_array(osd_afbc_backup, uint, &afbc_backup_count, 0444);
+MODULE_PARM_DESC(osd_afbc_backup, "\n osd afbc register backup\n");
+
+/* 0: not backup */
+static u32 backup_enable;
+module_param(backup_enable, uint, 0444);
+void update_backup_reg(u32 addr, u32 value)
+{
+	u32 base = OSD1_AFBCD_ENABLE;
+
+	if (!backup_enable)
+		return;
+	if ((addr >= OSD1_AFBCD_ENABLE) &&
+		(addr <= OSD1_AFBCD_PIXEL_VSCOPE) &&
+		(backup_enable & HW_RESET_AFBCD_REGS)) {
+		osd_afbc_backup[addr - base] = value;
+	}
+	base = VIU_OSD1_CTRL_STAT;
+	if ((addr >= VIU_OSD1_CTRL_STAT) &&
+		(addr <= VIU_OSD1_CTRL_STAT2) &&
+		(backup_enable & HW_RESET_OSD1_REGS)) {
+		osd_backup[addr - base] = value;
+	}
+}
+
+s32 get_backup_reg(u32 addr, u32 *value)
+{
+	int i;
+	u32 base = OSD1_AFBCD_ENABLE;
+	if (!backup_enable || !value)
+		return -1;
+
+	if ((addr >= OSD1_AFBCD_ENABLE) &&
+		(addr <= OSD1_AFBCD_PIXEL_VSCOPE) &&
+		(backup_enable & HW_RESET_AFBCD_REGS)) {
+		for (i = 0; i < OSD_AFBC_REG_BACKUP_COUNT; i++)
+			if (addr == osd_afbc_reg_backup[i]) {
+				*value = osd_afbc_backup[addr - base];
+				return 0;
+			}
+	}
+	base = VIU_OSD1_CTRL_STAT;
+	if ((addr >= VIU_OSD1_CTRL_STAT) &&
+		(addr <= VIU_OSD1_CTRL_STAT2) &&
+		(backup_enable & HW_RESET_OSD1_REGS)) {
+		for (i = 0; i < OSD_REG_BACKUP_COUNT; i++)
+			if (addr == osd_reg_backup[i]) {
+				*value = osd_backup[addr - base];
+				return 0;
+			}
+	}
+	return -1;
+}
+
+void backup_regs_init(u32 backup_mask)
+{
+	int i = 0;
+	u32 addr;
+	u32 base = VIU_OSD1_CTRL_STAT;
+	if (backup_enable)
+		return;
+
+	while ((backup_mask & HW_RESET_OSD1_REGS)
+		&& (i < OSD_REG_BACKUP_COUNT)) {
+		addr = osd_reg_backup[i];
+		osd_backup[addr - base] =
+			osd_reg_read(addr);
+		i++;
+	}
+	i = 0;
+	base = OSD1_AFBCD_ENABLE;
+	while ((backup_mask & HW_RESET_AFBCD_REGS)
+		&& (i < OSD_AFBC_REG_BACKUP_COUNT)) {
+		addr = osd_afbc_reg_backup[i];
+		osd_afbc_backup[addr - base] =
+			osd_reg_read(addr);
+		i++;
+	}
+	backup_enable = backup_mask;
+	return;
+}
+
+u32 is_backup(void)
+{
+	return backup_enable;
+}
+
+#ifdef CONFIG_FB_OSD_VSYNC_RDMA
+/* recovery section */
+#define INVAILD_REG_ITEM {0xffff, 0x0, 0x0, 0x0}
+#define REG_RECOVERY_TABLE 5
+
+static struct reg_recovery_table gRecovery[REG_RECOVERY_TABLE];
+static u32 recovery_enable;
+
+static struct reg_item osd1_recovery_table[] = {
+	{VIU_OSD1_CTRL_STAT, 0x0, 0x401ff9f1, 1},
+	INVAILD_REG_ITEM, /* VIU_OSD1_COLOR_ADDR 0x1a11 */
+	INVAILD_REG_ITEM, /* VIU_OSD1_COLOR 0x1a12 */
+	{VIU_OSD1_BLK0_CFG_W4, 0x0, 0x0fff0fff, 1},
+	INVAILD_REG_ITEM, /* VIU_OSD1_BLK1_CFG_W4 0x1a14 */
+	INVAILD_REG_ITEM, /* VIU_OSD1_BLK2_CFG_W4 0x1a15 */
+	INVAILD_REG_ITEM, /* VIU_OSD1_BLK3_CFG_W4 0x1a16 */
+	{VIU_OSD1_TCOLOR_AG0, 0x0, 0xffffffff, 1},
+	{VIU_OSD1_TCOLOR_AG1, 0x0, 0xffffffff, 0},
+	{VIU_OSD1_TCOLOR_AG2, 0x0, 0xffffffff, 0},
+	{VIU_OSD1_TCOLOR_AG3, 0x0, 0xffffffff, 0},
+	{VIU_OSD1_BLK0_CFG_W0, 0x0, 0x30ffffff, 1},
+	{VIU_OSD1_BLK0_CFG_W1, 0x0, 0x1fff1fff, 1},
+	{VIU_OSD1_BLK0_CFG_W2, 0x0, 0x1fff1fff, 1},
+	{VIU_OSD1_BLK0_CFG_W3, 0x0, 0x0fff0fff, 1},
+	INVAILD_REG_ITEM, /* VIU_OSD1_BLK1_CFG_W0 0x1a1f */
+	INVAILD_REG_ITEM, /* VIU_OSD1_BLK1_CFG_W1 0x1a20 */
+	INVAILD_REG_ITEM, /* VIU_OSD1_BLK1_CFG_W2 0x1a21 */
+	INVAILD_REG_ITEM, /* VIU_OSD1_BLK1_CFG_W3 0x1a22 */
+	INVAILD_REG_ITEM, /* VIU_OSD1_BLK2_CFG_W0 0x1a23 */
+	INVAILD_REG_ITEM, /* VIU_OSD1_BLK2_CFG_W1 0x1a24 */
+	INVAILD_REG_ITEM, /* VIU_OSD1_BLK2_CFG_W2 0x1a25 */
+	INVAILD_REG_ITEM, /* VIU_OSD1_BLK2_CFG_W3 0x1a26 */
+	INVAILD_REG_ITEM, /* VIU_OSD1_BLK3_CFG_W0 0x1a27 */
+	INVAILD_REG_ITEM, /* VIU_OSD1_BLK3_CFG_W1 0x1a28 */
+	INVAILD_REG_ITEM, /* VIU_OSD1_BLK3_CFG_W2 0x1a29 */
+	INVAILD_REG_ITEM, /* VIU_OSD1_BLK3_CFG_W3 0x1a2a */
+	{VIU_OSD1_FIFO_CTRL_STAT, 0x0, 0xffc3ffff, 1},
+	INVAILD_REG_ITEM, /* VIU_OSD1_TEST_RDDATA 0x1a2c */
+	{VIU_OSD1_CTRL_STAT2, 0x0, 0x0000ffff, 1},
+};
+
+static struct reg_item osd_afbcd_recovery_table[] = {
+	{OSD1_AFBCD_ENABLE, 0x0, 0x0000ff01, 1},
+	{OSD1_AFBCD_MODE, 0x0, 0x937f007f, 1},
+	{OSD1_AFBCD_SIZE_IN, 0x0, 0xffffffff, 1},
+	{OSD1_AFBCD_HDR_PTR, 0x0, 0xffffffff, 1},
+	{OSD1_AFBCD_FRAME_PTR, 0x0, 0xffffffff, 1},
+	{OSD1_AFBCD_CHROMA_PTR, 0x0, 0xffffffff, 1},
+	{OSD1_AFBCD_CONV_CTRL, 0x0, 0x0000ffff, 1},
+	INVAILD_REG_ITEM, /* unused 0x31a7 */
+	INVAILD_REG_ITEM, /* OSD1_AFBCD_STATUS 0x31a8 */
+	{OSD1_AFBCD_PIXEL_HSCOPE, 0x0, 0xffffffff, 1},
+	{OSD1_AFBCD_PIXEL_VSCOPE, 0x0, 0xffffffff, 1}
+};
+
+static struct reg_item freescale_recovery_table[] = {
+	{VPP_OSD_VSC_PHASE_STEP, 0x0, 0x0fffffff, 1},
+	{VPP_OSD_VSC_INI_PHASE, 0x0, 0xffffffff, 1},
+	{VPP_OSD_VSC_CTRL0, 0x0, 0x01fb7b7f, 1},
+	{VPP_OSD_HSC_PHASE_STEP, 0x0, 0x0fffffff, 1},
+	{VPP_OSD_HSC_INI_PHASE, 0x0, 0xffffffff, 1},
+	{VPP_OSD_HSC_CTRL0, 0x0, 0x007b7b7f, 1},
+	{VPP_OSD_HSC_INI_PAT_CTRL, 0x0, 0x0000ff77, 1},
+	{VPP_OSD_SC_DUMMY_DATA, 0x0, 0xffffffff, 0},
+	{VPP_OSD_SC_CTRL0, 0x0, 0x00007ffb, 1},
+	{VPP_OSD_SCI_WH_M1, 0x0, 0x1fff1fff, 1},
+	{VPP_OSD_SCO_H_START_END, 0x0, 0x0fff0fff, 1},
+	{VPP_OSD_SCO_V_START_END, 0x0, 0x0fff0fff, 1},
+	{VPP_OSD_SCALE_COEF_IDX, 0x0, 0x0000c37f, 0},
+	{VPP_OSD_SCALE_COEF, 0x0, 0xffffffff, 0}
+};
+
+static struct reg_item osd2_recovery_table[] = {
+	{VIU_OSD2_CTRL_STAT, 0x0, 0x401ff9f1, 1},
+	INVAILD_REG_ITEM, /* VIU_OSD2_COLOR_ADDR 0x1a31 */
+	INVAILD_REG_ITEM, /* VIU_OSD2_COLOR 0x1a32 */
+	INVAILD_REG_ITEM, /* VIU_OSD2_HL1_H_START_END 0x1a33 */
+	INVAILD_REG_ITEM, /* VIU_OSD2_HL1_V_START_END 0x1a34 */
+	INVAILD_REG_ITEM, /* VIU_OSD2_HL2_H_START_END 0x1a35 */
+	INVAILD_REG_ITEM, /* VIU_OSD2_HL2_V_START_END 0x1a36 */
+	{VIU_OSD2_TCOLOR_AG0, 0x0, 0xffffffff, 1},
+	{VIU_OSD2_TCOLOR_AG1, 0x0, 0xffffffff, 0},
+	{VIU_OSD2_TCOLOR_AG2, 0x0, 0xffffffff, 0},
+	{VIU_OSD2_TCOLOR_AG3, 0x0, 0xffffffff, 0},
+	{VIU_OSD2_BLK0_CFG_W0, 0x0, 0x00ffffff, 1},
+	{VIU_OSD2_BLK0_CFG_W1, 0x0, 0x1fff1fff, 1},
+	{VIU_OSD2_BLK0_CFG_W2, 0x0, 0x1fff1fff, 1},
+	{VIU_OSD2_BLK0_CFG_W3, 0x0, 0x0fff0fff, 1},
+	{VIU_OSD2_BLK1_CFG_W0, 0x0, 0x00ffffff, 0},
+	{VIU_OSD2_BLK1_CFG_W1, 0x0, 0x1fff1fff, 0},
+	{VIU_OSD2_BLK1_CFG_W2, 0x0, 0x1fff1fff, 0},
+	{VIU_OSD2_BLK1_CFG_W3, 0x0, 0x0fff0fff, 0},
+	{VIU_OSD2_BLK2_CFG_W0, 0x0, 0x00ffffff, 0},
+	{VIU_OSD2_BLK2_CFG_W1, 0x0, 0x1fff1fff, 0},
+	{VIU_OSD2_BLK2_CFG_W2, 0x0, 0x1fff1fff, 0},
+	{VIU_OSD2_BLK2_CFG_W3, 0x0, 0x0fff0fff, 0},
+	{VIU_OSD2_BLK3_CFG_W0, 0x0, 0x00ffffff, 0},
+	{VIU_OSD2_BLK3_CFG_W1, 0x0, 0x1fff1fff, 0},
+	{VIU_OSD2_BLK3_CFG_W2, 0x0, 0x1fff1fff, 0},
+	{VIU_OSD2_BLK3_CFG_W3, 0x0, 0x0fff0fff, 0},
+	{VIU_OSD2_FIFO_CTRL_STAT, 0x0, 0xffc3ffff, 1},
+	INVAILD_REG_ITEM, /* VIU_OSD2_TEST_RDDATA 0x1a4c */
+	{VIU_OSD2_CTRL_STAT2, 0x0, 0x00007ffd, 1}
+};
+
+
+static struct reg_item misc_recovery_table[] = {
+	{VIU_OSD2_BLK0_CFG_W4, 0x0, 0x0fff0fff, 1},
+	{VIU_OSD2_BLK1_CFG_W4, 0x0, 0xffffffff, 0},
+	{VIU_OSD2_BLK2_CFG_W4, 0x0, 0xffffffff, 0},
+	{VIU_OSD2_BLK3_CFG_W4, 0x0, 0xffffffff, 0},
+	{VPU_RDARB_MODE_L1C2, 0x0, 0x00010000, 1},
+	{VIU_MISC_CTRL1, 0x0, 0x0000ff00, 1}
+};
+
+void recovery_regs_init(void)
+{
+	int i = 0;
+	if (recovery_enable)
+		return;
+	memset(gRecovery, 0, sizeof(gRecovery));
+	gRecovery[i].base_addr = VIU_OSD1_CTRL_STAT;
+	gRecovery[i].size = sizeof(osd1_recovery_table)
+		/ sizeof(struct reg_item);
+	gRecovery[i].table =
+		(struct reg_item *)&osd1_recovery_table[0];
+
+	i++;
+	gRecovery[i].base_addr = OSD1_AFBCD_ENABLE;
+	gRecovery[i].size = sizeof(osd_afbcd_recovery_table)
+		/ sizeof(struct reg_item);
+	gRecovery[i].table =
+		(struct reg_item *)&osd_afbcd_recovery_table[0];
+
+	i++;
+	gRecovery[i].base_addr = VPP_OSD_VSC_PHASE_STEP;
+	gRecovery[i].size = sizeof(freescale_recovery_table)
+		/ sizeof(struct reg_item);
+	gRecovery[i].table =
+		(struct reg_item *)&freescale_recovery_table[0];
+
+	i++;
+	gRecovery[i].base_addr = VIU_OSD2_CTRL_STAT;
+	gRecovery[i].size = sizeof(osd2_recovery_table)
+		/ sizeof(struct reg_item);
+	gRecovery[i].table =
+		(struct reg_item *)&osd2_recovery_table[0];
+
+	i++;
+	gRecovery[i].base_addr = 0xffffffff; /* not base addr */
+	gRecovery[i].size = sizeof(misc_recovery_table)
+		/ sizeof(struct reg_item);
+	gRecovery[i].table =
+		(struct reg_item *)&misc_recovery_table[0];
+	recovery_enable = 1;
+}
+
+int update_recovery_item(u32 addr, u32 value)
+{
+	u32 base, size;
+	int i;
+	struct reg_item *table = NULL;
+	int ret = -1;
+
+	if (!recovery_enable)
+		return ret;
+
+	base = addr & 0xfff0;
+	switch (base) {
+	case VIU_OSD1_CTRL_STAT:
+	case VIU_OSD1_BLK1_CFG_W1:
+		/* osd1 */
+		if (backup_enable &
+			HW_RESET_OSD1_REGS) {
+			ret = 1;
+			break;
+		}
+		base = gRecovery[0].base_addr;
+		size = gRecovery[0].size;
+		table = gRecovery[0].table;
+		if ((addr >= base) &&
+			(addr < base + size)) {
+			table[addr - base].val = value;
+			if (table[addr - base].recovery)
+				table[addr - base].recovery = 1;
+			ret = 0;
+		}
+		break;
+	case VIU_OSD2_CTRL_STAT:
+	case VIU_OSD2_BLK1_CFG_W1:
+		/* osd2 */
+		base = gRecovery[3].base_addr;
+		size = gRecovery[3].size;
+		table = gRecovery[3].table;
+		if ((addr >= base) &&
+			(addr < base + size)) {
+			table[addr - base].val = value;
+			if (table[addr - base].recovery)
+				table[addr - base].recovery = 1;
+			ret = 0;
+		}
+		break;
+	case OSD1_AFBCD_ENABLE:
+		/* osd1 afbcd */
+		if (backup_enable &
+			HW_RESET_AFBCD_REGS) {
+			ret = 1;
+			break;
+		}
+		base = gRecovery[1].base_addr;
+		size = gRecovery[1].size;
+		table = gRecovery[1].table;
+		if ((addr >= base) &&
+			(addr < base + size)) {
+			table[addr - base].val = value;
+			if (table[addr - base].recovery)
+				table[addr - base].recovery = 1;
+			ret = 0;
+		}
+		break;
+	case VPP_OSD_VSC_PHASE_STEP:
+		base = gRecovery[2].base_addr;
+		size = gRecovery[2].size;
+		table = gRecovery[2].table;
+		if ((addr >= base) &&
+			(addr < base + size)) {
+			table[addr - base].val = value;
+			if (table[addr - base].recovery)
+				table[addr - base].recovery = 1;
+			ret = 0;
+		}
+		break;
+	default:
+		break;
+	}
+	if ((addr == VIU_OSD2_BLK0_CFG_W4) ||
+		(addr == VIU_OSD2_BLK1_CFG_W4) ||
+		(addr == VIU_OSD2_BLK2_CFG_W4) ||
+		(addr == VIU_OSD2_BLK3_CFG_W4) ||
+		(addr == VPU_RDARB_MODE_L1C2) ||
+		(addr == VIU_MISC_CTRL1)) {
+		table = gRecovery[4].table;
+		for (i = 0; i <  gRecovery[4].size; i++) {
+			if (addr == table[i].addr) {
+				table[i].val = value;
+				if (table[i].recovery)
+					table[i].recovery = 1;
+				ret = 0;
+				break;
+			}
+		}
+	}
+	return ret;
+}
+
+s32 get_recovery_item(u32 addr, u32 *value, u32 *mask)
+{
+	u32 base, size;
+	int i;
+	struct reg_item *table = NULL;
+	int ret = -1;
+
+	if (!recovery_enable)
+		return ret;
+
+	base = addr & 0xfff0;
+	switch (base) {
+	case VIU_OSD1_CTRL_STAT:
+	case VIU_OSD1_BLK1_CFG_W1:
+		/* osd1 */
+		if (backup_enable &
+			HW_RESET_OSD1_REGS) {
+			ret = 2;
+			break;
+		}
+		base = gRecovery[0].base_addr;
+		size = gRecovery[0].size;
+		table = gRecovery[0].table;
+		if ((addr >= base) &&
+			(addr < base + size)) {
+			table += (addr - base);
+			ret = 0;
+		}
+		break;
+	case VIU_OSD2_CTRL_STAT:
+	case VIU_OSD2_BLK1_CFG_W1:
+		/* osd2 */
+		base = gRecovery[3].base_addr;
+		size = gRecovery[3].size;
+		table = gRecovery[3].table;
+		if ((addr >= base) &&
+			(addr < base + size)) {
+			table += (addr - base);
+			ret = 0;
+		}
+		break;
+	case OSD1_AFBCD_ENABLE:
+		/* osd1 afbcd */
+		if (backup_enable &
+			HW_RESET_AFBCD_REGS) {
+			ret = 2;
+			break;
+		}
+		base = gRecovery[1].base_addr;
+		size = gRecovery[1].size;
+		table = gRecovery[1].table;
+		if ((addr >= base) &&
+			(addr < base + size)) {
+			table += (addr - base);
+			ret = 0;
+		}
+		break;
+	case VPP_OSD_VSC_PHASE_STEP:
+		base = gRecovery[2].base_addr;
+		size = gRecovery[2].size;
+		table = gRecovery[2].table;
+		if ((addr >= base) &&
+			(addr < base + size)) {
+			table += (addr - base);
+			ret = 0;
+		}
+		break;
+	default:
+		break;
+	}
+
+	if ((addr == VIU_OSD2_BLK0_CFG_W4) ||
+		(addr == VIU_OSD2_BLK1_CFG_W4) ||
+		(addr == VIU_OSD2_BLK2_CFG_W4) ||
+		(addr == VIU_OSD2_BLK3_CFG_W4) ||
+		(addr == VPU_RDARB_MODE_L1C2) ||
+		(addr == VIU_MISC_CTRL1)) {
+		table = gRecovery[4].table;
+		for (i = 0; i <  gRecovery[4].size; i++) {
+			if (addr == table[i].addr) {
+				table += i;
+				ret = 0;
+				break;
+			}
+		}
+	}
+	if (ret == 0 && table) {
+		if (table->recovery == 1) {
+			u32 regmask = table->mask;
+			u32 real_value = osd_reg_read(addr);
+			if ((real_value & regmask)
+				== (table->val & regmask)) {
+				ret = 1;
+				*mask = regmask;
+				*value = real_value;
+			} else {
+				*mask = regmask;
+				*value = real_value & ~(regmask);
+				*value |= (table->val & regmask);
+			}
+			table->recovery = 2;
+		} else if (table->recovery == 2)
+			ret = 1;
+		else
+			ret = -1;
+	}
+	/* ret = 1, 2 need not recovery,
+		ret = 0 need recovery,
+		ret = -1, not find */
+	return ret;
+}
+#else
+void recovery_regs_init(void)
+{
+	return;
+}
+
+int update_recovery_item(u32 addr, u32 value)
+{
+	addr = 0;
+	value = 0;
+	return 0;
+}
+s32 get_recovery_item(u32 addr, u32 *value, u32 *mask)
+{
+	addr = 0;
+	value = NULL;
+	mask = NULL;
+	return 0;
+}
+#endif
diff --git a/drivers/amlogic/display/osd/osd_backup.h b/drivers/amlogic/display/osd/osd_backup.h
new file mode 100644
index 0000000..7702290
--- /dev/null
+++ b/drivers/amlogic/display/osd/osd_backup.h
@@ -0,0 +1,63 @@
+/*
+ * drivers/amlogic/display/osd/osd_backup.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef _OSD_BACKUP_H_
+#define _OSD_BACKUP_H_
+
+#include "osd_reg.h"
+
+#define OSD_REG_BACKUP_COUNT 12
+#define OSD_AFBC_REG_BACKUP_COUNT 9
+
+#define OSD_VALUE_COUNT (VIU_OSD1_CTRL_STAT2 - VIU_OSD1_CTRL_STAT + 1)
+#define OSD_AFBC_VALUE_COUNT (OSD1_AFBCD_PIXEL_VSCOPE - OSD1_AFBCD_ENABLE + 1)
+
+extern const u16 osd_reg_backup[OSD_REG_BACKUP_COUNT];
+extern const u16 osd_afbc_reg_backup[OSD_AFBC_REG_BACKUP_COUNT];
+extern u32 osd_backup[OSD_VALUE_COUNT];
+extern u32 osd_afbc_backup[OSD_AFBC_VALUE_COUNT];
+
+enum hw_reset_flag_e {
+	HW_RESET_NONE = 0,
+	HW_RESET_AFBCD_REGS = 0x80000000,
+	HW_RESET_OSD1_REGS = 0x00000001,
+	HW_RESET_AFBCD_HARDWARE = 0x80000000,
+};
+
+struct reg_item {
+	u32 addr;
+	u32 val;
+	u32 mask;
+	int recovery;
+};
+
+struct reg_recovery_table {
+	u32 base_addr;
+	u32 size;
+	struct reg_item *table;
+};
+
+extern void update_backup_reg(u32 addr, u32 value);
+extern s32 get_backup_reg(u32 addr, u32 *value);
+extern void backup_regs_init(u32 backup_mask);
+extern u32 is_backup(void);
+
+extern void recovery_regs_init(void);
+extern int update_recovery_item(u32 addr, u32 value);
+extern s32 get_recovery_item(u32 addr, u32 *value, u32 *mask);
+#endif
+
diff --git a/drivers/amlogic/display/osd/osd_canvas.h b/drivers/amlogic/display/osd/osd_canvas.h
index ee6ca69..d36c21c 100644
--- a/drivers/amlogic/display/osd/osd_canvas.h
+++ b/drivers/amlogic/display/osd/osd_canvas.h
@@ -25,4 +25,7 @@
 #define OSD4_CANVAS_INDEX 0x42
 #define ALLOC_CANVAS_INDEX 0x44
 
+#define EXTERN1_CANVAS 0x41
+#define EXTERN2_CANVAS 0x42
+
 #endif
diff --git a/drivers/amlogic/display/osd/osd_debug.c b/drivers/amlogic/display/osd/osd_debug.c
index 741ac63..3b6050a 100644
--- a/drivers/amlogic/display/osd/osd_debug.c
+++ b/drivers/amlogic/display/osd/osd_debug.c
@@ -103,7 +103,7 @@ static void osd_debug_dump_value(void)
 		osd_log_info("\ty_start: 0x%08x, y_end: 0x%08x\n",
 				pdata->y_start, pdata->y_end);
 
-		pdata = &hwpara->free_scale_data[index];
+		pdata = &hwpara->free_src_data[index];
 		osd_log_info("free-scale src data:\n");
 		osd_log_info("\tx_start: 0x%08x, x_end: 0x%08x\n",
 				pdata->x_start, pdata->x_end);
@@ -168,6 +168,9 @@ static void osd_debug_dump_register_all(void)
 
 	if ((get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) ||
 		(get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)) {
+		reg = VIU_MISC_CTRL1;
+			osd_log_info("reg[0x%x]: 0x%08x\n",
+				reg, osd_reg_read(reg));
 		for (reg = OSD1_AFBCD_ENABLE;
 			reg <= OSD1_AFBCD_PIXEL_VSCOPE; reg++)
 			osd_log_info("reg[0x%x]: 0x%08x\n",
diff --git a/drivers/amlogic/display/osd/osd_fb.c b/drivers/amlogic/display/osd/osd_fb.c
index a783003..0330aa2 100644
--- a/drivers/amlogic/display/osd/osd_fb.c
+++ b/drivers/amlogic/display/osd/osd_fb.c
@@ -41,11 +41,12 @@
 #include <linux/of_reserved_mem.h>
 #include <linux/uaccess.h>
 #include <linux/dma-mapping.h>
-#include <ion/ion.h>
 #include <meson_ion.h>
 /* Amlogic Headers */
 #include <linux/amlogic/vout/vout_notify.h>
 #include <linux/amlogic/instaboot/instaboot.h>
+#include <sw_sync.h>
+#include <sync.h>
 
 /* Local Headers */
 #include "osd.h"
@@ -286,6 +287,8 @@ static int early_suspend_flag;
 static int early_resume_flag;
 #endif
 
+static int osd_shutdown_flag;
+
 unsigned int osd_log_level;
 int int_viu_vsync = -ENXIO;
 #ifdef CONFIG_FB_OSD_VSYNC_RDMA
@@ -641,6 +644,7 @@ static int osd_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
 	unsigned long ret;
 	u32 flush_rate;
 	struct fb_sync_request_s sync_request;
+	struct fb_sync_request_render_s sync_request_render;
 	struct fb_dmabuf_export dmaexp;
 
 	switch (cmd) {
@@ -660,6 +664,10 @@ static int osd_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
 		ret = copy_from_user(&sync_request, argp,
 				sizeof(struct fb_sync_request_s));
 		break;
+	case FBIOPUT_OSD_SYNC_RENDER_ADD:
+		ret = copy_from_user(&sync_request_render, argp,
+				sizeof(struct fb_sync_request_render_s));
+		break;
 	case FBIO_WAITFORVSYNC:
 	case FBIOGET_OSD_SCALE_AXIS:
 	case FBIOPUT_OSD_ORDER:
@@ -709,12 +717,6 @@ static int osd_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
 		osd_get_order_hw(info->node, &osd_order);
 		ret = copy_to_user(argp, &osd_order, sizeof(u32));
 		break;
-	case FBIOPUT_OSD_FREE_SCALE_WIDTH:
-		osd_set_free_scale_width_hw(info->node, arg);
-		break;
-	case FBIOPUT_OSD_FREE_SCALE_HEIGHT:
-		osd_set_free_scale_height_hw(info->node, arg);
-		break;
 	case FBIOPUT_OSD_FREE_SCALE_ENABLE:
 		osd_set_free_scale_enable_hw(info->node, arg);
 		break;
@@ -738,13 +740,13 @@ static int osd_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
 			return -EFAULT;
 		break;
 	case FBIOPUT_OSD_REVERSE:
+		if (arg >= REVERSE_MAX)
+			arg = REVERSE_FALSE;
 		osd_set_reverse_hw(info->node, arg);
 		break;
 	case FBIOPUT_OSD_ROTATE_ON:
-		osd_set_rotate_on_hw(info->node, arg);
 		break;
 	case FBIOPUT_OSD_ROTATE_ANGLE:
-		osd_set_rotate_angle_hw(info->node, arg);
 		break;
 	case FBIOPUT_OSD_SRCCOLORKEY:
 		switch (fbdev->color->color_index) {
@@ -855,6 +857,36 @@ static int osd_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
 			info->var.yoffset = sync_request.yoffset;
 		}
 		break;
+	case FBIOPUT_OSD_SYNC_RENDER_ADD:
+		{
+			ion_phys_addr_t addr;
+			size_t len;
+			u32 phys_addr;
+
+			ret = meson_ion_share_fd_to_phys(fb_ion_client,
+				sync_request_render.shared_fd, &addr, &len);
+			if (ret == 0) {
+				phys_addr = addr +
+					sync_request_render.yoffset
+					* info->fix.line_length;
+			} else
+				phys_addr = 0;
+			sync_request_render.out_fen_fd =
+				osd_sync_request_render(info->node,
+				info->var.yres,
+				&sync_request_render, phys_addr);
+			ret = copy_to_user(argp,
+				&sync_request_render,
+				sizeof(struct fb_sync_request_render_s));
+			if (sync_request_render.out_fen_fd  < 0) {
+				/* fence create fail. */
+				ret = -1;
+			} else {
+				info->var.xoffset = sync_request_render.xoffset;
+				info->var.yoffset = sync_request_render.yoffset;
+			}
+		}
+		break;
 	case FBIOGET_DMABUF:
 		{
 			if (info->node == DEV_OSD0 && osd_get_afbc()) {
@@ -878,6 +910,7 @@ static int osd_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
 	case FBIO_WAITFORVSYNC:
 		osd_wait_vsync_event();
 		ret = copy_to_user(argp, &ret, sizeof(u32));
+		break;
 	default:
 		break;
 	}
@@ -942,9 +975,9 @@ static int osd_compat_ioctl(struct fb_info *info,
 	arg = (unsigned long)compat_ptr(arg);
 
 	/* handle fbio cursor command for 32-bit app */
-	if ((cmd & 0xFFFF) == (FBIO_CURSOR & 0xFFFF)) {
+	if ((cmd & 0xFFFF) == (FBIO_CURSOR & 0xFFFF))
 		ret = osd_compat_cursor(info, arg);
-	} else
+	else
 		ret = osd_ioctl(info, cmd, arg);
 
 	return ret;
@@ -1050,6 +1083,8 @@ static int osd_open(struct fb_info *info, int arg)
 				(unsigned long)fb_rmem_size[fb_index] / SZ_1M);
 		}
 	} else {
+		if (!fb_ion_client)
+			fb_ion_client = meson_ion_client_create(-1, "meson-fb");
 		fb_rmem_size[fb_index] = fb_memsize[fb_index];
 		if (fb_index == DEV_OSD0)
 			fb_rmem_paddr[fb_index] = fb_rmem.base;
@@ -1256,7 +1291,8 @@ int osd_notify_callback(struct notifier_block *block, unsigned long cmd,
 		osd_log_err("current vinfo NULL\n");
 		return -1;
 	}
-	osd_log_info("current vmode=%s\n", vinfo->name);
+	osd_log_info("current vmode=%s, cmd: 0x%lx\n",
+		vinfo->name, cmd);
 	switch (cmd) {
 #if 0
 	case VOUT_EVENT_MODE_CHANGE_PRE:
@@ -1311,9 +1347,9 @@ int osd_notify_callback(struct notifier_block *block, unsigned long cmd,
 			/*
 			 * if osd layer preblend,
 			 * it's position is controlled by vpp.
-			 */
 			if (fb_dev->preblend_enable)
 				break;
+			*/
 			fb_dev->osd_ctl.disp_start_x = disp_rect->x;
 			fb_dev->osd_ctl.disp_start_y = disp_rect->y;
 			osd_log_dbg("set disp axis: x:%d y:%d w:%d h:%d\n",
@@ -1349,31 +1385,6 @@ int osd_notify_callback(struct notifier_block *block, unsigned long cmd,
 static struct notifier_block osd_notifier_nb = {
 	.notifier_call	= osd_notify_callback,
 };
-static ssize_t store_preblend_enable(struct device *device,
-				     struct device_attribute *attr,
-				     const char *buf, size_t count)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	struct osd_fb_dev_s *fbdev = (struct osd_fb_dev_s *)fb_info->par;
-	int res = 0;
-	int ret = 0;
-
-	ret = kstrtoint(buf, 0, &res);
-	fbdev->preblend_enable = res;
-	vout_notifier_call_chain(VOUT_EVENT_OSD_PREBLEND_ENABLE,
-				 &fbdev->preblend_enable);
-	return count;
-}
-
-static ssize_t show_preblend_enable(struct device *device,
-				    struct device_attribute *attr,
-				    char *buf)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	struct osd_fb_dev_s *fbdev = (struct osd_fb_dev_s *)fb_info->par;
-	return snprintf(buf, PAGE_SIZE, "preblend[%s]\n",
-			fbdev->preblend_enable ? "enable" : "disable");
-}
 
 static ssize_t store_enable_3d(struct device *device,
 			       struct device_attribute *attr,
@@ -1608,21 +1619,6 @@ static ssize_t store_scale_axis(struct device *device,
 	return count;
 }
 
-static ssize_t store_scale_width(struct device *device,
-				 struct device_attribute *attr,
-				 const char *buf, size_t count)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	unsigned int free_scale_width = 0;
-	int res = 0;
-	int ret = 0;
-
-	ret = kstrtoint(buf, 0 , &res);
-	free_scale_width = res;
-	osd_set_free_scale_width_hw(fb_info->node, free_scale_width);
-
-	return count;
-}
 
 static ssize_t show_scale_width(struct device *device,
 				struct device_attribute *attr,
@@ -1635,21 +1631,6 @@ static ssize_t show_scale_width(struct device *device,
 			free_scale_width);
 }
 
-static ssize_t store_scale_height(struct device *device,
-				  struct device_attribute *attr,
-				  const char *buf, size_t count)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	unsigned int free_scale_height = 0;
-	int res = 0;
-	int ret = 0;
-
-	ret = kstrtoint(buf, 0 , &res);
-	free_scale_height = res;
-	osd_set_free_scale_height_hw(fb_info->node, free_scale_height);
-	return count;
-}
-
 static ssize_t show_scale_height(struct device *device,
 				 struct device_attribute *attr,
 				 char *buf)
@@ -1915,11 +1896,14 @@ static ssize_t show_osd_reverse(struct device *device,
 				struct device_attribute *attr,
 				char *buf)
 {
+	char *str[4] = {"NONE", "ALL", "X_REV", "Y_REV"};
 	struct fb_info *fb_info = dev_get_drvdata(device);
 	unsigned int osd_reverse = 0;
 	osd_get_reverse_hw(fb_info->node, &osd_reverse);
+	if (osd_reverse >= REVERSE_MAX)
+		osd_reverse = REVERSE_FALSE;
 	return snprintf(buf, PAGE_SIZE, "osd_reverse:[%s]\n",
-			osd_reverse ? "TRUE" : "FALSE");
+			str[osd_reverse]);
 }
 
 static ssize_t store_osd_reverse(struct device *device,
@@ -1933,96 +1917,9 @@ static ssize_t store_osd_reverse(struct device *device,
 
 	ret = kstrtoint(buf, 0, &res);
 	osd_reverse = res;
+	if (osd_reverse >= REVERSE_MAX)
+		osd_reverse = REVERSE_FALSE;
 	osd_set_reverse_hw(fb_info->node, osd_reverse);
-
-	return count;
-}
-static ssize_t show_rotate_on(struct device *device,
-			      struct device_attribute *attr,
-			      char *buf)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	unsigned int osd_rotate = 0;
-	osd_get_rotate_on_hw(fb_info->node, &osd_rotate);
-	return snprintf(buf, PAGE_SIZE, "osd_rotate:[%s]\n",
-			osd_rotate ? "ON" : "OFF");
-}
-
-static ssize_t store_rotate_on(struct device *device,
-			       struct device_attribute *attr,
-			       const char *buf, size_t count)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	unsigned int osd_rotate = 0;
-	int res = 0;
-	int ret = 0;
-
-	ret = kstrtoint(buf, 0, &res);
-	osd_rotate = res;
-	osd_set_rotate_on_hw(fb_info->node, osd_rotate);
-	return count;
-}
-
-static ssize_t show_prot_state(struct device *device,
-			       struct device_attribute *attr,
-			       char *buf)
-{
-	int pos = 0;
-	unsigned int osd_rotate = 0;
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	osd_get_rotate_on_hw(fb_info->node, &osd_rotate);
-	pos += snprintf(buf + pos, PAGE_SIZE, "%d", osd_rotate);
-	return pos;
-}
-
-static ssize_t show_rotate_angle(struct device *device,
-				 struct device_attribute *attr,
-				 char *buf)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	unsigned int osd_rotate_angle = 0;
-	osd_get_rotate_angle_hw(fb_info->node, &osd_rotate_angle);
-	return snprintf(buf, PAGE_SIZE, "osd_rotate:%d\n", osd_rotate_angle);
-}
-
-static ssize_t store_rotate_angle(struct device *device,
-				  struct device_attribute *attr,
-				  const char *buf, size_t count)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	unsigned int osd_rotate_angle = 0;
-	int res = 0;
-	int ret = 0;
-
-	ret = kstrtoint(buf, 0, &res);
-	osd_rotate_angle = res;
-	osd_set_rotate_angle_hw(fb_info->node, osd_rotate_angle);
-	return count;
-}
-
-static ssize_t show_prot_canvas(struct device *device,
-				struct device_attribute *attr,
-				char *buf)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	int x_start, y_start, x_end, y_end;
-	osd_get_prot_canvas_hw(fb_info->node,
-			&x_start, &y_start, &x_end, &y_end);
-	return snprintf(buf, PAGE_SIZE, "%d %d %d %d\n",
-			x_start, y_start, x_end, y_end);
-}
-
-static ssize_t store_prot_canvas(struct device *device,
-				 struct device_attribute *attr,
-				 const char *buf, size_t count)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	int parsed[4];
-	if (likely(parse_para(buf, 4, parsed) == 4))
-		osd_set_prot_canvas_hw(fb_info->node, parsed[0],
-				parsed[1], parsed[2], parsed[3]);
-	else
-		osd_log_err("set prot canvas error\n");
 	return count;
 }
 
@@ -2067,9 +1964,7 @@ static ssize_t show_update_freescale(struct device *device,
 				     struct device_attribute *attr,
 				     char *buf)
 {
-	struct fb_info *fb_info = dev_get_drvdata(device);
 	unsigned int update_state = 0;
-	osd_get_update_state_hw(fb_info->node, &update_state);
 	return snprintf(buf, PAGE_SIZE, "update_state:[%s]\n",
 			update_state ? "TRUE" : "FALSE");
 }
@@ -2078,14 +1973,12 @@ static ssize_t store_update_freescale(struct device *device,
 				      struct device_attribute *attr,
 				      const char *buf, size_t count)
 {
-	struct fb_info *fb_info = dev_get_drvdata(device);
 	unsigned int update_state = 0;
 	int res = 0;
 	int ret = 0;
 
 	ret = kstrtoint(buf, 0, &res);
 	update_state = res;
-	osd_set_update_state_hw(fb_info->node, update_state);
 	return count;
 }
 
@@ -2213,17 +2106,27 @@ static struct para_osd_info_s para_osd_info[OSD_END + 2] = {
 	},
 	/* reverse_mode */
 	{
-		"true",	REVERSE_TRUE,
+		"false", REVERSE_FALSE,
 		OSD_SECOND_GROUP_START - 1, OSD_SECOND_GROUP_START + 1,
-		OSD_SECOND_GROUP_START,	OSD_END
+		OSD_SECOND_GROUP_START, OSD_END
 	},
 	{
-		"false", REVERSE_FALSE,
-		OSD_SECOND_GROUP_START,	OSD_SECOND_GROUP_START + 2,
+		"true", REVERSE_TRUE,
+		OSD_SECOND_GROUP_START, OSD_SECOND_GROUP_START + 2,
 		OSD_SECOND_GROUP_START, OSD_END
 	},
 	{
-		"tail",	OSD_INVALID_INFO, OSD_END,
+		"x_rev", REVERSE_X,
+		OSD_SECOND_GROUP_START + 1, OSD_SECOND_GROUP_START + 3,
+		OSD_SECOND_GROUP_START, OSD_END
+	},
+	{
+		"y_rev", REVERSE_Y,
+		OSD_SECOND_GROUP_START + 2, OSD_SECOND_GROUP_START + 4,
+		OSD_SECOND_GROUP_START, OSD_END
+	},
+	{
+		"tail", OSD_INVALID_INFO, OSD_END,
 		0, 0,
 		OSD_END + 1
 	},
@@ -2297,16 +2200,14 @@ static struct device_attribute osd_attrs[] = {
 			show_order, store_order),
 	__ATTR(enable_3d, S_IRUGO | S_IWUSR,
 			show_enable_3d, store_enable_3d),
-	__ATTR(preblend_enable, S_IRUGO | S_IWUSR,
-			show_preblend_enable, store_preblend_enable),
 	__ATTR(free_scale, S_IRUGO | S_IWUSR | S_IWGRP,
 			show_free_scale, store_free_scale),
 	__ATTR(scale_axis, S_IRUGO | S_IWUSR,
 			show_scale_axis, store_scale_axis),
-	__ATTR(scale_width, S_IRUGO | S_IWUSR | S_IWGRP,
-			show_scale_width, store_scale_width),
-	__ATTR(scale_height, S_IRUGO | S_IWUSR | S_IWGRP,
-			show_scale_height, store_scale_height),
+	__ATTR(scale_width, S_IRUGO | S_IRUSR,
+			show_scale_width, NULL),
+	__ATTR(scale_height, S_IRUGO | S_IRUSR,
+			show_scale_height, NULL),
 	__ATTR(color_key, S_IRUGO | S_IWUSR,
 			show_color_key, store_color_key),
 	__ATTR(enable_key, S_IRUGO | S_IWUSR | S_IWGRP,
@@ -2329,16 +2230,8 @@ static struct device_attribute osd_attrs[] = {
 			show_freescale_mode, store_freescale_mode),
 	__ATTR(flush_rate, S_IRUGO | S_IRUSR,
 			show_flush_rate, NULL),
-	__ATTR(prot_on, S_IRUGO | S_IWUSR | S_IWGRP,
-			show_rotate_on, store_rotate_on),
-	__ATTR(prot_angle, S_IRUGO | S_IWUSR | S_IWGRP,
-			show_rotate_angle, store_rotate_angle),
-	__ATTR(prot_canvas, S_IRUGO | S_IWUSR | S_IWGRP,
-			show_prot_canvas, store_prot_canvas),
 	__ATTR(osd_reverse, S_IRUGO | S_IWUSR,
 			show_osd_reverse, store_osd_reverse),
-	__ATTR(prot_state, S_IRUGO | S_IRUSR,
-			show_prot_state, NULL),
 	__ATTR(osd_antiflicker, S_IRUGO | S_IWUSR,
 			show_antiflicker, store_antiflicker),
 	__ATTR(update_freescale, S_IRUGO | S_IWUSR,
@@ -2476,7 +2369,6 @@ static int osd_probe(struct platform_device *pdev)
 	enum vmode_e logo_init = 0;
 	const void *prop;
 	int prop_idx = 0;
-	int rotation = 0;
 	const char *str;
 	int i;
 	int ret = 0;
@@ -2531,6 +2423,14 @@ static int osd_probe(struct platform_device *pdev)
 	if (prop)
 		prop_idx = of_read_ulong(prop, 1);
 	osd_set_pxp_mode(prop_idx);
+
+	prop = of_get_property(pdev->dev.of_node, "ddr_urgent", NULL);
+	if (prop) {
+		prop_idx = of_read_ulong(prop, 1);
+		osd_set_urgent(0, (prop_idx != 0) ? 1 : 0);
+		osd_set_urgent(1, (prop_idx != 0) ? 1 : 0);
+	}
+
 	/* if osd_init_hw is not set by logo, set vmode and init osd hw */
 	logo_init = osd_get_init_hw_flag();
 	if (logo_init == 0) {
@@ -2586,14 +2486,7 @@ static int osd_probe(struct platform_device *pdev)
 					fb_def_var[index].bits_per_pixel = 32;
 			}
 		}
-		/* get roataion from dtd */
-		if (index == DEV_OSD0) {
-			prop = of_get_property(pdev->dev.of_node,
-					"rotation", NULL);
-			if (prop)
-				prop_idx = of_read_ulong(prop, 1);
-			rotation = prop_idx;
-		}
+
 		_fbdev_set_default(fbdev, index);
 		if (NULL == fbdev->color) {
 			osd_log_err("fbdev->color NULL\n");
@@ -2638,17 +2531,7 @@ static int osd_probe(struct platform_device *pdev)
 	early_suspend.resume = osd_late_resume;
 	register_early_suspend(&early_suspend);
 #endif
-	/* init osd rotate */
-	if (rotation == 90 || rotation == 270) {
-		osd_set_prot_canvas_hw(0, 0, 0,
-				var_screeninfo[0] - 1, var_screeninfo[1] - 1);
-		if (rotation == 90)
-			osd_set_rotate_angle_hw(0, 1);
-		else {
-			osd_set_rotate_angle_hw(0, 2);
-			osd_set_rotate_on_hw(0, 1);
-		}
-	}
+
 	/* init osd reverse */
 	if (osd_info.index == DEV_ALL) {
 		osd_set_reverse_hw(0, osd_info.osd_reverse);
@@ -2700,6 +2583,15 @@ static int osd_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static void osd_shutdown(struct platform_device *pdev)
+{
+	if (!osd_shutdown_flag) {
+		osd_shutdown_flag = 1;
+		osd_shutdown_hw();
+	}
+	return;
+}
+
 /* Process kernel command line parameters */
 static int __init osd_setup_attribute(char *options)
 {
@@ -2769,6 +2661,7 @@ const struct dev_pm_ops osd_pm = {
 static struct platform_driver osd_driver = {
 	.probe      = osd_probe,
 	.remove     = osd_remove,
+	.shutdown = osd_shutdown,
 #ifdef CONFIG_PM
 	.suspend  = osd_suspend,
 	.resume    = osd_resume,
diff --git a/drivers/amlogic/display/osd/osd_fb.h b/drivers/amlogic/display/osd/osd_fb.h
index cefe664..40c6123 100644
--- a/drivers/amlogic/display/osd/osd_fb.h
+++ b/drivers/amlogic/display/osd/osd_fb.h
@@ -61,10 +61,10 @@ struct osd_fb_dev_s {
 	bool dis_osd_mchange;
 };
 
-#define OSD_INVALID_INFO        0xffffffff
-#define OSD_FIRST_GROUP_START   1
-#define OSD_SECOND_GROUP_START  4
-#define OSD_END                 5
+#define OSD_INVALID_INFO 0xffffffff
+#define OSD_FIRST_GROUP_START 1
+#define OSD_SECOND_GROUP_START 4
+#define OSD_END 7
 
 extern phys_addr_t get_fb_rmem_paddr(int index);
 extern void __iomem *get_fb_rmem_vaddr(int index);
diff --git a/drivers/amlogic/display/osd/osd_hw.c b/drivers/amlogic/display/osd/osd_hw.c
index 7d5d9ed..df0d7b6 100644
--- a/drivers/amlogic/display/osd/osd_hw.c
+++ b/drivers/amlogic/display/osd/osd_hw.c
@@ -43,13 +43,11 @@
 #ifdef CONFIG_AML_VPU
 #include <linux/amlogic/vpu.h>
 #endif
-#ifdef CONFIG_AM_VIDEO
-#include <linux/amlogic/amports/vframe_receiver.h>
-#include <linux/amlogic/amports/vframe_provider.h>
-#endif
 #ifdef CONFIG_AM_VECM
 #include <linux/amlogic/amvecm/ve.h>
 #endif
+#include <linux/amlogic/amports/video.h>
+
 
 /* Local Headers */
 #include <vout/vpp.h>
@@ -60,17 +58,17 @@
 #include "osd_log.h"
 #include "osd_reg.h"
 #include "osd_io.h"
+#include "osd_backup.h"
 
 #include "osd_hw.h"
 #include "osd_hw_def.h"
-#include "../ppmgr/ppmgr_pri.h"
 
 #ifdef CONFIG_AML_VSYNC_FIQ_ENABLE
-#define  FIQ_VSYNC
+#define FIQ_VSYNC
 #endif
-#define	VOUT_ENCI	1
-#define	VOUT_ENCP	2
-#define	VOUT_ENCT	3
+#define VOUT_ENCI	1
+#define VOUT_ENCP	2
+#define VOUT_ENCT	3
 #define OSD_TYPE_TOP_FIELD 0
 #define OSD_TYPE_BOT_FIELD 1
 
@@ -78,13 +76,11 @@
 
 struct hw_para_s osd_hw;
 static DEFINE_MUTEX(osd_mutex);
-static DEFINE_SPINLOCK(osd_onoff_lock);
 static DECLARE_WAIT_QUEUE_HEAD(osd_vsync_wq);
 
 static bool vsync_hit;
-static bool osd_vf_need_update;
 static bool osd_update_window_axis;
-static bool osd_afbc_dec_enable;
+static int osd_afbc_dec_enable;
 static void osd_clone_pan(u32 index, u32 yoffset, int debug_flag);
 
 #ifdef CONFIG_FB_OSD_SUPPORT_SYNC_FENCE
@@ -102,17 +98,6 @@ static void osd_pan_display_fence(struct osd_fence_map_s *fence_map);
 #endif
 
 static int pxp_mode;
-#ifdef CONFIG_AM_VIDEO
-static struct vframe_s vf;
-static struct vframe_provider_s osd_vf_prov;
-static unsigned char osd_vf_prov_init;
-#endif
-static int g_vf_visual_width;
-static int g_vf_width;
-static int g_vf_height;
-
-static int g_rotation_width;
-static int g_rotation_height;
 
 static __nosavedata int use_h_filter_mode = -1;
 static __nosavedata int use_v_filter_mode = -1;
@@ -125,11 +110,23 @@ static unsigned int osd_v_filter_mode = 1;
 module_param(osd_v_filter_mode, uint, 0664);
 MODULE_PARM_DESC(osd_v_filter_mode, "osd_v_filter_mode");
 
+static unsigned int osd_auto_adjust_filter = 1;
+module_param(osd_auto_adjust_filter, uint, 0664);
+MODULE_PARM_DESC(osd_auto_adjust_filter, "osd_auto_adjust_filter");
+
 static int osd_init_hw_flag;
 static int osd_logo_index = 1;
 module_param(osd_logo_index, int, 0664);
 MODULE_PARM_DESC(osd_logo_index, "osd_logo_index");
 
+module_param(osd_afbc_dec_enable, int, 0664);
+MODULE_PARM_DESC(osd_afbc_dec_enable, "osd_afbc_dec_enable");
+
+static u32 osd_vpp_misc;
+static u32 osd_vpp_misc_mask = OSD_RELATIVE_BITS;
+module_param(osd_vpp_misc, uint, 0444);
+MODULE_PARM_DESC(osd_vpp_misc, "osd_vpp_misc");
+
 static unsigned int osd_filter_coefs_bicubic_sharp[] = {
 	0x01fa008c, 0x01fa0100, 0xff7f0200, 0xfe7f0300,
 	0xfd7e0500, 0xfc7e0600, 0xfb7d0800, 0xfb7c0900,
@@ -246,20 +243,9 @@ static unsigned int *filter_table[] = {
 	osd_filter_coefs_3point_bspline
 };
 
-/* should be same as osd rdma backup addr */
-const u16 osd_reg_backup[OSD_REG_BACKUP_COUNT] = {
-	0x1a10, 0x1a11, 0x1a12, 0x1a13,
-	0x1a17, 0x1a18, 0x1a19, 0x1a1a, 0x1a1b, 0x1a1c, 0x1a1d, 0x1a1e,
-	0x1a2b, 0x1a2c, 0x1a2d,
-};
-
-const u16 osd_afbc_reg_backup[OSD_AFBC_REG_BACKUP_COUNT] = {
-	0x31aa, 0x31a9,
-	0x31a7, 0x31a6, 0x31a5, 0x31a4, 0x31a3, 0x31a2, 0x31a1, 0x31a0
-};
-
+#ifdef CONFIG_AM_VECM
 static bool osd_hdr_on;
-static u32 osd_reset_status;
+#endif
 
 static void osd_vpu_power_on(void)
 {
@@ -383,6 +369,7 @@ int osd_sync_request(u32 index, u32 yres, u32 xoffset, u32 yoffset,
 		return -ENOMEM;
 	}
 	mutex_lock(&post_fence_list_lock);
+	fence_map->op = 0xffffffff;
 	fence_map->fb_index = index;
 	fence_map->buf_num = buf_num;
 	fence_map->yoffset = yoffset;
@@ -400,6 +387,52 @@ int osd_sync_request(u32 index, u32 yres, u32 xoffset, u32 yoffset,
 	return  out_fence_fd;
 }
 
+int osd_sync_request_render(u32 index, u32 yres,
+	struct fb_sync_request_render_s *request,
+	u32 phys_addr)
+{
+	int out_fence_fd = -1;
+	int buf_num = 0;
+	u32 xoffset, yoffset;
+	s32 in_fence_fd;
+	struct osd_fence_map_s *fence_map =
+		kzalloc(sizeof(struct osd_fence_map_s), GFP_KERNEL);
+
+	xoffset = request->xoffset;
+	yoffset = request->yoffset;
+	in_fence_fd = request->in_fen_fd;
+	buf_num = find_buf_num(yres, yoffset);
+	if (!fence_map) {
+		osd_log_err("could not allocate osd_fence_map\n");
+		return -ENOMEM;
+	}
+	mutex_lock(&post_fence_list_lock);
+	fence_map->op = 0xffffffff;
+	fence_map->fb_index = index;
+	fence_map->buf_num = buf_num;
+	fence_map->yoffset = yoffset;
+	fence_map->xoffset = xoffset;
+	fence_map->yres = yres;
+	fence_map->in_fd = in_fence_fd;
+	fence_map->ext_addr = phys_addr;
+	if (fence_map->ext_addr) {
+		fence_map->format = request->format;
+		fence_map->width = request->width;
+		fence_map->height = request->height;
+		fence_map->reserve = request->reserve;
+	}
+	fence_map->op = request->op;
+	fence_map->in_fence = sync_fence_fdget(in_fence_fd);
+	fence_map->files = current->files;
+	fence_map->out_fd =
+		out_fence_create(&out_fence_fd, &fence_map->val, buf_num);
+	list_add_tail(&fence_map->list, &post_fence_list);
+	mutex_unlock(&post_fence_list_lock);
+	queue_kthread_work(&buffer_toggle_worker, &buffer_toggle_work);
+	request->out_fen_fd = out_fence_fd;
+	return  out_fence_fd;
+}
+
 static int osd_wait_buf_ready(struct osd_fence_map_s *fence_map)
 {
 	s32 ret = -1;
@@ -413,7 +446,7 @@ static int osd_wait_buf_ready(struct osd_fence_map_s *fence_map)
 		ret = -1;/* no fence ,output directly. */
 		return ret;
 	}
-	ret = sync_fence_wait(buf_ready_fence, -1);
+	ret = sync_fence_wait(buf_ready_fence, 4000);
 	if (ret < 0) {
 		osd_log_err("Sync Fence wait error:%d\n", ret);
 		osd_log_err("-----wait buf idx:[%d] ERROR\n"
@@ -432,34 +465,15 @@ int osd_sync_request(u32 index, u32 yres, u32 xoffset, u32 yoffset,
 	osd_log_err("osd_sync_request not supported\n");
 	return -5566;
 }
-#endif
 
-#ifdef CONFIG_AM_VIDEO
-static struct vframe_s *osd_vf_peek(void *arg)
-{
-	if (osd_vf_need_update && (vf.width > 0) && (vf.height > 0))
-		return &vf;
-	else
-		return NULL;
-}
 
-static struct vframe_s *osd_vf_get(void *arg)
+int osd_sync_request_render(u32 index, u32 yres,
+	struct fb_sync_request_render_s *request,
+	u32 phys_addr)
 {
-	if (osd_vf_need_update) {
-		vf_ext_light_unreg_provider(&osd_vf_prov);
-		osd_vf_need_update = false;
-		return &vf;
-	}
-	return NULL;
+	osd_log_err("osd_sync_request_render not supported\n");
+	return -5566;
 }
-
-#define PROVIDER_NAME   "osd"
-static const struct vframe_operations_s osd_vf_provider = {
-	.peek = osd_vf_peek,
-	.get  = osd_vf_get,
-	.put  = NULL,
-};
-
 #endif
 
 void osd_update_3d_mode(void)
@@ -581,228 +595,129 @@ static inline void walk_through_update_list(void)
 }
 
 /*************** for GXL/GXM hardware alpha bug workaround ***************/
-#ifdef CONFIG_AM_VECM
-static void hdr_load_osd_csc(void)
-{
-	u32 i = 0;
-	u32 addr_port;
-	u32 data_port;
-	struct hdr_osd_lut_s *lut = &hdr_osd_reg.lut_val;
-
-	/* check osd matrix enable status */
-	if ((hdr_osd_reg.viu_osd1_matrix_ctrl & 0x00000001) != 0x0) {
-		/* osd matrix, VPP_MATRIX_0 */
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_MATRIX_PRE_OFFSET0_1,
-			hdr_osd_reg.viu_osd1_matrix_pre_offset0_1);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_MATRIX_PRE_OFFSET0_1,
-			hdr_osd_reg.viu_osd1_matrix_pre_offset0_1);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_MATRIX_COEF00_01,
-			hdr_osd_reg.viu_osd1_matrix_coef00_01);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_MATRIX_COEF02_10,
-			hdr_osd_reg.viu_osd1_matrix_coef02_10);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_MATRIX_COEF11_12,
-			hdr_osd_reg.viu_osd1_matrix_coef11_12);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_MATRIX_COEF20_21,
-			hdr_osd_reg.viu_osd1_matrix_coef20_21);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_MATRIX_COEF22_30,
-			hdr_osd_reg.viu_osd1_matrix_coef22_30);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_MATRIX_COEF31_32,
-			hdr_osd_reg.viu_osd1_matrix_coef31_32);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_MATRIX_COEF40_41,
-			hdr_osd_reg.viu_osd1_matrix_coef40_41);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_MATRIX_COLMOD_COEF42,
-			hdr_osd_reg.viu_osd1_matrix_colmod_coef42);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_MATRIX_OFFSET0_1,
-			hdr_osd_reg.viu_osd1_matrix_offset0_1);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_MATRIX_OFFSET2,
-			hdr_osd_reg.viu_osd1_matrix_offset2);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_MATRIX_CTRL,
-			hdr_osd_reg.viu_osd1_matrix_ctrl);
-	}
-
-	/* restore eotf lut */
-	if ((hdr_osd_reg.viu_osd1_eotf_ctl & 0x80000000) != 0) {
-		addr_port = VIU_OSD1_EOTF_LUT_ADDR_PORT;
-		data_port = VIU_OSD1_EOTF_LUT_DATA_PORT;
-		VSYNCOSD_EX_WR_MPEG_REG(addr_port, 0);
-		for (i = 0; i < 16; i++)
-			VSYNCOSD_EX_WR_MPEG_REG(data_port,
-				lut->r_map[i * 2]
-				| (lut->r_map[i * 2 + 1] << 16));
-		VSYNCOSD_EX_WR_MPEG_REG(data_port,
-			lut->r_map[33 - 1]
-			| (lut->g_map[0] << 16));
-		for (i = 0; i < 16; i++)
-			VSYNCOSD_EX_WR_MPEG_REG(data_port,
-				lut->g_map[i * 2 + 1]
-				| (lut->b_map[i * 2 + 2] << 16));
-		for (i = 0; i < 16; i++)
-			VSYNCOSD_EX_WR_MPEG_REG(data_port,
-				lut->b_map[i * 2]
-				| (lut->b_map[i * 2 + 1] << 16));
-		VSYNCOSD_EX_WR_MPEG_REG(data_port, lut->b_map[33 - 1]);
-
-		/* load eotf matrix */
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_EOTF_COEF00_01,
-			hdr_osd_reg.viu_osd1_eotf_coef00_01);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_EOTF_COEF02_10,
-			hdr_osd_reg.viu_osd1_eotf_coef02_10);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_EOTF_COEF11_12,
-			hdr_osd_reg.viu_osd1_eotf_coef11_12);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_EOTF_COEF20_21,
-			hdr_osd_reg.viu_osd1_eotf_coef20_21);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_EOTF_COEF22_RS,
-			hdr_osd_reg.viu_osd1_eotf_coef22_rs);
-		VSYNCOSD_EX_WR_MPEG_REG(
-			VIU_OSD1_EOTF_CTL,
-			hdr_osd_reg.viu_osd1_eotf_ctl);
-	}
-	/* restore oetf lut */
-	if ((hdr_osd_reg.viu_osd1_oetf_ctl & 0xe0000000) != 0) {
-		addr_port = VIU_OSD1_OETF_LUT_ADDR_PORT;
-		data_port = VIU_OSD1_OETF_LUT_DATA_PORT;
-		VSYNCOSD_EX_WR_MPEG_REG(addr_port, 0);
-		for (i = 0; i < 20; i++)
-			VSYNCOSD_EX_WR_MPEG_REG(data_port,
-				lut->or_map[i * 2]
-				| (lut->or_map[i * 2 + 1] << 16));
-		VSYNCOSD_EX_WR_MPEG_REG(data_port,
-			lut->or_map[41 - 1]
-			| (lut->og_map[0] << 16));
-		for (i = 0; i < 20; i++)
-			VSYNCOSD_EX_WR_MPEG_REG(data_port,
-				lut->og_map[i * 2 + 1]
-				| (lut->og_map[i * 2 + 2] << 16));
-		for (i = 0; i < 20; i++)
-			VSYNCOSD_EX_WR_MPEG_REG(data_port,
-				lut->ob_map[i * 2]
-				| (lut->ob_map[i * 2 + 1] << 16));
-		VSYNCOSD_EX_WR_MPEG_REG(data_port,
-			lut->ob_map[41 - 1]);
-
-		VSYNCOSD_EX_WR_MPEG_REG
-			(VIU_OSD1_OETF_CTL,
-			hdr_osd_reg.viu_osd1_oetf_ctl);
-	}
-}
-#endif
-
-void osd_hw_reset(void)
+u32 osd_get_hw_reset_flag(void)
 {
-	/* only called by vsync irq or rdma irq */
-	u32 reset_bit = 0;
-#ifndef CONFIG_FB_OSD_VSYNC_RDMA
-	u32 i;
-	u32 osd_value_backup[OSD_REG_BACKUP_COUNT];
-	u32 osd_afbc_value_backup[OSD_AFBC_REG_BACKUP_COUNT];
-#endif
-
+	u32 hw_reset_flag = HW_RESET_NONE;
+	u32 cpu_type;
+	cpu_type = get_cpu_type();
 	/* check hw version */
-	if (get_cpu_type() < MESON_CPU_MAJOR_ID_GXTVBB)
-		return;
-	if (osd_hw.osd_afbcd[OSD1].enable &&
-		((get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) ||
-		(get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)))
-		reset_bit = 1<<31;
-#ifdef CONFIG_AM_VECM
-	if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)
-		&& (get_cpu_type() <= MESON_CPU_MAJOR_ID_TXL)) {
-		if (((hdr_osd_reg.viu_osd1_matrix_ctrl & 0x00000001) != 0x0) ||
-			((hdr_osd_reg.viu_osd1_eotf_ctl & 0x80000000) != 0) ||
-			((hdr_osd_reg.viu_osd1_oetf_ctl & 0xe0000000) != 0)) {
-			reset_bit |= 1;
+	switch (cpu_type) {
+	case MESON_CPU_MAJOR_ID_GXTVBB:
+		if (osd_hw.osd_afbcd[OSD1].enable)
+			hw_reset_flag |= HW_RESET_AFBCD_REGS;
+		break;
+	case MESON_CPU_MAJOR_ID_GXM:
+		/* same bit, but gxm only reset hardware, not top reg*/
+		if (osd_hw.osd_afbcd[OSD1].enable)
+			hw_reset_flag |= HW_RESET_AFBCD_HARDWARE;
+#ifndef CONFIG_AM_VECM
+		break;
+#else
+	case MESON_CPU_MAJOR_ID_GXL:
+	case MESON_CPU_MAJOR_ID_TXL:
+		if (((hdr_osd_reg.viu_osd1_matrix_ctrl & 0x00000001)
+			!= 0x0) ||
+			((hdr_osd_reg.viu_osd1_eotf_ctl & 0x80000000)
+			!= 0) ||
+			((hdr_osd_reg.viu_osd1_oetf_ctl & 0xe0000000)
+			!= 0)) {
+			hw_reset_flag |= HW_RESET_OSD1_REGS;
 			osd_hdr_on = true;
 		} else if (osd_hdr_on) {
-			reset_bit |= 1;
+			hw_reset_flag |= HW_RESET_OSD1_REGS;
 			osd_hdr_on = false;
 		}
-	}
+		break;
 #endif
+	default:
+		hw_reset_flag = HW_RESET_NONE;
+		break;
+	}
+	return hw_reset_flag;
+}
 
-	osd_reset_status = reset_bit;
-	if (reset_bit == 0)
+void osd_hw_reset(void)
+{
+	/* only called by vsync irq or rdma irq */
+	u32 backup_mask;
+	u32 reset_bit =
+		osd_get_hw_reset_flag();
+	backup_mask = is_backup();
+	osd_hw.hw_reset_flag = reset_bit;
+	if (reset_bit == HW_RESET_NONE)
 		return;
-
-#ifndef CONFIG_FB_OSD_VSYNC_RDMA
 	spin_lock_irqsave(&osd_lock, lock_flags);
-	if (reset_bit & 1) {
-		/* backup osd regs */
-		for (i = 0; i < OSD_REG_BACKUP_COUNT; i++)
-			osd_value_backup[i] =
-				VSYNCOSD_RD_MPEG_REG(
-				osd_reg_backup[i]);
-	}
+	if ((reset_bit & HW_RESET_OSD1_REGS)
+		&& !(backup_mask & HW_RESET_OSD1_REGS))
+		reset_bit &= ~HW_RESET_OSD1_REGS;
 
-	if (reset_bit & 0x80000000) {
-		/* backup osd afbc regs */
-		for (i = 0; i < OSD_AFBC_REG_BACKUP_COUNT; i++)
-			osd_afbc_value_backup[i] =
-				VSYNCOSD_RD_MPEG_REG(
-				osd_afbc_reg_backup[i]);
-	}
+	if ((get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB)
+		&& (reset_bit & HW_RESET_AFBCD_REGS)
+		&& !(backup_mask & HW_RESET_AFBCD_REGS))
+		reset_bit &= ~HW_RESET_AFBCD_REGS;
 
-	VSYNCOSD_IRQ_SET_MPEG_REG_MASK(
-		VIU_SW_RESET, reset_bit);
-	VSYNCOSD_IRQ_CLR_MPEG_REG_MASK(
+#ifndef CONFIG_FB_OSD_VSYNC_RDMA
+	/* if not osd rdma, don't reset osd1 for hdr */
+	reset_bit &= ~HW_RESET_OSD1_REGS;
+	backup_mask &= ~HW_RESET_OSD1_REGS;
+
+	VSYNCOSD_IRQ_WR_MPEG_REG(
 		VIU_SW_RESET, reset_bit);
+	VSYNCOSD_IRQ_WR_MPEG_REG(
+		VIU_SW_RESET, 0);
 
-	if (reset_bit & 1) {
+	if (reset_bit & HW_RESET_OSD1_REGS) {
 		/* restore osd regs */
-		for (i = 0; i < OSD_REG_BACKUP_COUNT; i++)
-			VSYNCOSD_IRQ_WR_MPEG_REG
-				(osd_reg_backup[i],
-				osd_value_backup[i]);
+		int i;
+		u32 addr;
+		u32 base = VIU_OSD1_CTRL_STAT;
+		for (i = 0; i < OSD_REG_BACKUP_COUNT; i++) {
+			addr = osd_reg_backup[i];
+			VSYNCOSD_IRQ_WR_MPEG_REG(
+				addr, osd_backup[addr - base]);
+		}
 	}
 
-	if (reset_bit & 0x80000000) {
-		/* restore osd regs */
+	if ((get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB)
+		&& (reset_bit & HW_RESET_AFBCD_REGS)) {
+		/* restore osd afbcd regs */
+		int i;
+		u32 addr;
+		u32 value;
+		u32 base = OSD1_AFBCD_ENABLE;
 		for (i = 0; i < OSD_AFBC_REG_BACKUP_COUNT; i++) {
-			if (osd_afbc_reg_backup[i]
-				== OSD1_AFBCD_ENABLE)
-				VSYNCOSD_IRQ_WR_MPEG_REG
-					(osd_afbc_reg_backup[i],
-					osd_afbc_value_backup[i] | 0x100);
-			else
-				VSYNCOSD_IRQ_WR_MPEG_REG
-					(osd_afbc_reg_backup[i],
-					osd_afbc_value_backup[i]);
+			addr = osd_afbc_reg_backup[i];
+			value = osd_afbc_backup[addr - base];
+			if (addr == OSD1_AFBCD_ENABLE)
+				value |= 0x100;
+			VSYNCOSD_IRQ_WR_MPEG_REG(
+				addr, value);
 		}
 	}
-	spin_unlock_irqrestore(&osd_lock, lock_flags);
-#ifdef CONFIG_AM_VECM
-	/* write new osd hdr regs */
-	if (reset_bit & 1)
-		hdr_load_osd_csc();
-#endif
 #else
-	/* wrtie into rdma local buffer and flush into rdma table at last */
-	if (reset_bit & 1)
-		hdr_load_osd_csc();
-	spin_lock_irqsave(&osd_lock, lock_flags);
 	osd_rdma_reset_and_flush(reset_bit);
-	spin_unlock_irqrestore(&osd_lock, lock_flags);
 #endif
+	spin_unlock_irqrestore(&osd_lock, lock_flags);
+	/* maybe change reset bit */
+	osd_hw.hw_reset_flag = reset_bit;
 	return;
 }
 
+static int notify_to_amvideo(void)
+{
+	u32 para[2];
+	para[0] = osd_vpp_misc;
+	para[1] = osd_vpp_misc_mask;
+	pr_debug(
+		"osd notify_to_amvideo vpp misc:0x%08x, mask:0x%08x\n",
+		para[0], para[1]);
+#ifdef CONFIG_FB_OSD_VSYNC_RDMA
+	amvideo_notifier_call_chain(
+		AMVIDEO_UPDATE_OSD_MODE,
+		(void *)&para[0]);
+#endif
+	return 0;
+}
 /*************** end of GXL/GXM hardware alpha bug workaround ***************/
 
 #ifdef FIQ_VSYNC
@@ -851,7 +766,7 @@ u32 osd_get_afbc(void)
 
 u32 osd_get_reset_status(void)
 {
-	return osd_reset_status;
+	return osd_hw.hw_reset_flag;
 }
 
 void osd_wait_vsync_hw(void)
@@ -884,19 +799,43 @@ int osd_set_scan_mode(u32 index)
 	vinfo = get_current_vinfo();
 	if (vinfo) {
 		osd_hw.scale_workaround = 0;
+		if (osd_auto_adjust_filter) {
+			osd_h_filter_mode = 1;
+			osd_v_filter_mode = 1;
+		}
 		switch (vinfo->mode) {
 		case VMODE_480I:
 		case VMODE_480CVBS:
+			if (osd_hw.free_scale_mode[index]) {
+				osd_hw.field_out_en = 1;
+				switch (osd_hw.free_src_data[index].y_end) {
+				case 719:
+					osd_hw.bot_type = 2;
+					break;
+				case 1079:
+					osd_hw.bot_type = 3;
+					break;
+				default:
+					osd_hw.bot_type = 2;
+					break;
+				}
+			}
+			osd_hw.scan_mode = real_scan_mode = SCAN_MODE_INTERLACE;
+			if (osd_auto_adjust_filter) {
+				osd_h_filter_mode = 6;
+				osd_v_filter_mode = 6;
+			}
+			break;
 		case VMODE_576I:
 		case VMODE_576CVBS:
 			if (osd_hw.free_scale_mode[index]) {
 				osd_hw.field_out_en = 1;
-				switch (osd_hw.free_scale_data[index].y_end) {
+				switch (osd_hw.free_src_data[index].y_end) {
 				case 719:
 					osd_hw.bot_type = 2;
 					break;
 				case 1079:
-					osd_hw.bot_type = 3;
+					osd_hw.bot_type = 2;
 					break;
 				default:
 					osd_hw.bot_type = 2;
@@ -904,12 +843,16 @@ int osd_set_scan_mode(u32 index)
 				}
 			}
 			osd_hw.scan_mode = real_scan_mode = SCAN_MODE_INTERLACE;
+			if (osd_auto_adjust_filter) {
+				osd_h_filter_mode = 6;
+				osd_v_filter_mode = 6;
+			}
 			break;
 		case VMODE_1080I:
 		case VMODE_1080I_50HZ:
 			if (osd_hw.free_scale_mode[index]) {
 				osd_hw.field_out_en = 1;
-				switch (osd_hw.free_scale_data[index].y_end) {
+				switch (osd_hw.free_src_data[index].y_end) {
 				case 719:
 					osd_hw.bot_type = 1;
 					break;
@@ -936,6 +879,15 @@ int osd_set_scan_mode(u32 index)
 			}
 			osd_hw.field_out_en = 0;
 			break;
+		case VMODE_480P:
+		case VMODE_576P:
+			if (osd_auto_adjust_filter) {
+				osd_h_filter_mode = 6;
+				osd_v_filter_mode = 6;
+			}
+			if (osd_hw.free_scale_mode[index])
+				osd_hw.field_out_en = 0;
+			break;
 		default:
 			if (osd_hw.free_scale_mode[index])
 				osd_hw.field_out_en = 0;
@@ -960,6 +912,9 @@ int osd_set_scan_mode(u32 index)
 
 void  osd_set_gbl_alpha_hw(u32 index, u32 gbl_alpha)
 {
+	/* normalized */
+	if (gbl_alpha == 0xff)
+		gbl_alpha = 0x100;
 	if (osd_hw.gbl_alpha[index] != gbl_alpha) {
 		osd_hw.gbl_alpha[index] = gbl_alpha;
 		add_to_update_list(index, OSD_GBL_ALPHA);
@@ -1028,6 +983,7 @@ void osd_set_color_mode(u32 index, const struct color_bit_define_s *color)
 {
 	if (color != osd_hw.color_info[index]) {
 		osd_hw.color_info[index] = color;
+		osd_hw.color_backup[index] = color;
 		add_to_update_list(index, OSD_COLOR_MODE);
 	}
 }
@@ -1104,10 +1060,9 @@ void osd_setup_hw(u32 index,
 	disp_data.y_start = disp_start_y;
 	if (likely(osd_hw.free_scale_enable[OSD1] && index == OSD1)) {
 		if (!(osd_hw.free_scale_mode[OSD1])) {
-			pan_data.x_end = xoffset + g_vf_visual_width;
-			pan_data.y_end = yoffset + g_vf_height;
-			disp_data.x_end = disp_start_x + g_vf_width;
-			disp_data.y_end = disp_start_y + g_vf_height;
+			osd_log_info(
+				"osd[%d] osd_setup_hw scale mode is error %d\n",
+				index, osd_hw.free_scale_mode[OSD1]);
 		} else {
 			pan_data.x_end = xoffset + (disp_end_x - disp_start_x);
 			pan_data.y_end = yoffset + (disp_end_y - disp_start_y);
@@ -1117,14 +1072,8 @@ void osd_setup_hw(u32 index,
 	} else {
 		pan_data.x_end = xoffset + (disp_end_x - disp_start_x);
 		pan_data.y_end = yoffset + (disp_end_y - disp_start_y);
-		if (likely(osd_hw.rotate[index].on_off
-					&& osd_hw.rotate[index].on_off > 0)) {
-			disp_data.x_end = disp_start_x + g_rotation_height;
-			disp_data.y_end = disp_start_y + g_rotation_width;
-		} else {
-			disp_data.x_end = disp_end_x;
-			disp_data.y_end = disp_end_y;
-		}
+		disp_data.x_end = disp_end_x;
+		disp_data.y_end = disp_end_y;
 	}
 	if (osd_hw.fb_gem[index].addr != fbmem
 		|| osd_hw.fb_gem[index].width != w
@@ -1165,6 +1114,8 @@ void osd_setup_hw(u32 index,
 			else
 				osd_hw.osd_afbcd[index].conv_lbuf_len = 1024;
 		}
+		osd_hw.fb_gem[index].xres = xres;
+		osd_hw.fb_gem[index].yres = yres;
 		osd_log_info("osd[%d] canvas.idx =0x%x\n",
 			index, osd_hw.fb_gem[index].canvas_idx);
 		osd_log_info("osd[%d] canvas.addr=0x%x\n",
@@ -1174,9 +1125,9 @@ void osd_setup_hw(u32 index,
 		osd_log_info("osd[%d] canvas.height=%d\n",
 			index, osd_hw.fb_gem[index].height);
 		osd_log_info("osd[%d] frame.width=%d\n",
-			index, xres);
+			index, osd_hw.fb_gem[index].xres);
 		osd_log_info("osd[%d] frame.height=%d\n",
-			index, yres);
+			index, osd_hw.fb_gem[index].yres);
 #ifdef CONFIG_AML_CANVAS
 		canvas_config(osd_hw.fb_gem[index].canvas_idx,
 			osd_hw.fb_gem[index].addr,
@@ -1190,6 +1141,7 @@ void osd_setup_hw(u32 index,
 	if ((color != osd_hw.color_info[index]) || (index == OSD2)) {
 		update_color_mode = 1;
 		osd_hw.color_info[index] = color;
+		osd_hw.color_backup[index] = color;
 	}
 	/* osd blank only control by /sys/class/graphcis/fbx/blank */
 #if 0
@@ -1234,6 +1186,9 @@ void osd_setpal_hw(u32 index,
 		   unsigned transp
 		  )
 {
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB)
+		return;
+
 	if (regno < 256) {
 		u32 pal;
 		pal = ((red   & 0xff) << 24) |
@@ -1262,98 +1217,6 @@ void osd_set_order_hw(u32 index, u32 order)
 	osd_wait_vsync_hw();
 }
 
-/* vpu free scale mode */
-static void osd_set_free_scale_enable_mode0(u32 index, u32 enable)
-{
-	static struct pandata_s save_disp_data = {0, 0, 0, 0};
-#ifdef CONFIG_AM_VIDEO
-#ifdef CONFIG_POST_PROCESS_MANAGER
-	int mode_changed = 0;
-	if ((index == OSD1) && (osd_hw.free_scale_enable[index] != enable))
-		mode_changed = 1;
-#endif
-#endif
-	osd_log_info("osd%d free scale %s\n",
-			index, enable ? "ENABLE" : "DISABLE");
-	enable = (enable & 0xffff ? 1 : 0);
-	osd_hw.free_scale_enable[index] = enable;
-	if (index == OSD1) {
-		if (enable) {
-			osd_vf_need_update = true;
-#ifdef CONFIG_AM_VIDEO
-			if ((osd_hw.free_scale_data[OSD1].x_end > 0)
-			    && (osd_hw.free_scale_data[OSD1].x_end > 0)) {
-				vf.width = osd_hw.free_scale_data[index].x_end -
-				    osd_hw.free_scale_data[index].x_start + 1;
-				vf.height =
-				    osd_hw.free_scale_data[index].y_end -
-				    osd_hw.free_scale_data[index].y_start + 1;
-			} else {
-				vf.width = osd_hw.free_scale_width[OSD1];
-				vf.height = osd_hw.free_scale_height[OSD1];
-			}
-			vf.type = (VIDTYPE_NO_VIDEO_ENABLE | VIDTYPE_PROGRESSIVE
-				| VIDTYPE_VIU_FIELD | VIDTYPE_VSCALE_DISABLE);
-			vf.ratio_control = DISP_RATIO_FORCECONFIG
-				| DISP_RATIO_NO_KEEPRATIO;
-			if (osd_vf_prov_init == 0) {
-				vf_provider_init(&osd_vf_prov,
-					PROVIDER_NAME, &osd_vf_provider, NULL);
-				osd_vf_prov_init = 1;
-			}
-			vf_reg_provider(&osd_vf_prov);
-			memcpy(&save_disp_data, &osd_hw.dispdata[OSD1],
-					sizeof(struct pandata_s));
-			g_vf_visual_width =
-				vf.width - 1 - osd_hw.dispdata[OSD1].x_start;
-			g_vf_width = vf.width - 1;
-			g_vf_height = vf.height - 1;
-			osd_hw.dispdata[OSD1].x_end =
-				osd_hw.dispdata[OSD1].x_start + vf.width - 1;
-			osd_hw.dispdata[OSD1].y_end =
-				osd_hw.dispdata[OSD1].y_start + vf.height - 1;
-#endif
-			osd_set_scan_mode(index);
-			spin_lock_irqsave(&osd_lock, lock_flags);
-			osd_hw.reg[index][DISP_GEOMETRY].update_func();
-			osd_hw.reg[index][OSD_COLOR_MODE].update_func();
-			osd_hw.reg[index][OSD_ENABLE].update_func();
-			spin_unlock_irqrestore(&osd_lock, lock_flags);
-		} else {
-			osd_vf_need_update = false;
-			osd_set_scan_mode(index);
-			if (save_disp_data.x_end <= save_disp_data.x_start ||
-			    save_disp_data.y_end <= save_disp_data.y_start)
-				return;
-			memcpy(&osd_hw.dispdata[OSD1], &save_disp_data,
-					sizeof(struct pandata_s));
-			spin_lock_irqsave(&osd_lock, lock_flags);
-			osd_hw.reg[index][DISP_GEOMETRY].update_func();
-			osd_hw.reg[index][OSD_COLOR_MODE].update_func();
-			osd_hw.reg[index][OSD_ENABLE].update_func();
-			spin_unlock_irqrestore(&osd_lock, lock_flags);
-#ifdef CONFIG_AM_VIDEO
-			vf_unreg_provider(&osd_vf_prov);
-#endif
-		}
-	} else {
-		spin_lock_irqsave(&osd_lock, lock_flags);
-		osd_hw.reg[index][DISP_GEOMETRY].update_func();
-		osd_hw.reg[index][OSD_COLOR_MODE].update_func();
-		osd_hw.reg[index][OSD_ENABLE].update_func();
-		spin_unlock_irqrestore(&osd_lock, lock_flags);
-	}
-	osd_wait_vsync_hw();
-#ifdef CONFIG_AM_VIDEO
-#ifdef CONFIG_POST_PROCESS_MANAGER
-	if (mode_changed) {
-		/* extern void vf_ppmgr_reset(int type); */
-		vf_ppmgr_reset(1);
-	}
-#endif
-#endif
-}
-
 /* osd free scale mode */
 static void osd_set_free_scale_enable_mode1(u32 index, u32 enable)
 {
@@ -1367,16 +1230,6 @@ static void osd_set_free_scale_enable_mode1(u32 index, u32 enable)
 	osd_hw.free_scale[index].v_enable = v_enable;
 	osd_hw.free_scale_enable[index] = enable;
 	if (osd_hw.free_scale_enable[index]) {
-		if ((osd_hw.free_scale_data[index].x_end > 0) && h_enable) {
-			osd_hw.free_scale_width[index] =
-				osd_hw.free_scale_data[index].x_end -
-				osd_hw.free_scale_data[index].x_start + 1;
-		}
-		if ((osd_hw.free_scale_data[index].y_end > 0) && v_enable) {
-			osd_hw.free_scale_height[index] =
-				osd_hw.free_scale_data[index].y_end -
-				osd_hw.free_scale_data[index].y_start + 1;
-		}
 		ret = osd_set_scan_mode(index);
 		spin_lock_irqsave(&osd_lock, lock_flags);
 		if (ret)
@@ -1403,8 +1256,10 @@ void osd_set_free_scale_enable_hw(u32 index, u32 enable)
 {
 	if (osd_hw.free_scale_mode[index])
 		osd_set_free_scale_enable_mode1(index, enable);
-	else
-		osd_set_free_scale_enable_mode0(index, enable);
+	else if (enable)
+		osd_log_info(
+			"osd[%d] free_scale_enable_hw mode is error %d\n",
+			index, osd_hw.free_scale_mode[index]);
 }
 
 void osd_get_free_scale_enable_hw(u32 index, u32 *free_scale_enable)
@@ -1427,54 +1282,32 @@ void osd_set_4k2k_fb_mode_hw(u32 fb_for_4k2k)
 	osd_hw.fb_for_4k2k = fb_for_4k2k;
 }
 
-void osd_set_free_scale_width_hw(u32 index, u32 width)
-{
-	osd_hw.free_scale_width[index] = width;
-	if (osd_hw.free_scale_enable[index] &&
-	    (!osd_hw.free_scale_mode[index])) {
-		osd_vf_need_update = true;
-#ifdef CONFIG_AM_VIDEO
-		vf.width = osd_hw.free_scale_width[index];
-#endif
-	}
-}
-
 void osd_get_free_scale_width_hw(u32 index, u32 *free_scale_width)
 {
-	*free_scale_width = osd_hw.free_scale_width[index];
-}
-
-void osd_set_free_scale_height_hw(u32 index, u32 height)
-{
-	osd_hw.free_scale_height[index] = height;
-	if (osd_hw.free_scale_enable[index] &&
-	    (!osd_hw.free_scale_mode[index])) {
-		osd_vf_need_update = true;
-#ifdef CONFIG_AM_VIDEO
-		vf.height = osd_hw.free_scale_height[index];
-#endif
-	}
+	*free_scale_width = osd_hw.free_src_data[index].x_end -
+		osd_hw.free_src_data[index].x_start + 1;
 }
 
 void osd_get_free_scale_height_hw(u32 index, u32 *free_scale_height)
 {
-	*free_scale_height = osd_hw.free_scale_height[index];
+	*free_scale_height = osd_hw.free_src_data[index].y_end -
+		osd_hw.free_src_data[index].y_start + 1;
 }
 
 void osd_get_free_scale_axis_hw(u32 index, s32 *x0, s32 *y0, s32 *x1, s32 *y1)
 {
-	*x0 = osd_hw.free_scale_data[index].x_start;
-	*y0 = osd_hw.free_scale_data[index].y_start;
-	*x1 = osd_hw.free_scale_data[index].x_end;
-	*y1 = osd_hw.free_scale_data[index].y_end;
+	*x0 = osd_hw.free_src_data[index].x_start;
+	*y0 = osd_hw.free_src_data[index].y_start;
+	*x1 = osd_hw.free_src_data[index].x_end;
+	*y1 = osd_hw.free_src_data[index].y_end;
 }
 
 void osd_set_free_scale_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1)
 {
-	osd_hw.free_scale_data[index].x_start = x0;
-	osd_hw.free_scale_data[index].y_start = y0;
-	osd_hw.free_scale_data[index].x_end = x1;
-	osd_hw.free_scale_data[index].y_end = y1;
+	osd_hw.free_src_data[index].x_start = x0;
+	osd_hw.free_src_data[index].y_start = y0;
+	osd_hw.free_src_data[index].x_end = x1;
+	osd_hw.free_src_data[index].y_end = y1;
 }
 
 void osd_get_scale_axis_hw(u32 index, s32 *x0, s32 *y0, s32 *x1, s32 *y1)
@@ -1528,8 +1361,9 @@ void osd_get_window_axis_hw(u32 index, s32 *x0, s32 *y0, s32 *x1, s32 *y1)
 void osd_set_window_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1)
 {
 	const struct vinfo_s *vinfo;
-	mutex_lock(&osd_mutex);
+	s32 temp_y0, temp_y1;
 	vinfo = get_current_vinfo();
+	mutex_lock(&osd_mutex);
 	if (vinfo) {
 		switch (vinfo->mode) {
 		case VMODE_480I:
@@ -1538,34 +1372,36 @@ void osd_set_window_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1)
 		case VMODE_576CVBS:
 		case VMODE_1080I:
 		case VMODE_1080I_50HZ:
-			osd_hw.free_dst_data[index].y_start = y0 / 2;
-			osd_hw.free_dst_data[index].y_end = y1 / 2;
+			temp_y0 = y0 / 2;
+			temp_y1 = y1 / 2;
 			break;
 		default:
-			osd_hw.free_dst_data[index].y_start = y0;
-			osd_hw.free_dst_data[index].y_end = y1;
+			temp_y0 = y0;
+			temp_y1 = y1;
 			break;
 		}
 	} else {
-		osd_hw.free_dst_data[index].y_start = y0;
-		osd_hw.free_dst_data[index].y_end = y1;
+		temp_y0 = y0;
+		temp_y1 = y1;
 	}
+	osd_hw.free_dst_data[index].y_start = temp_y0;
+	osd_hw.free_dst_data[index].y_end = temp_y1;
 	osd_hw.free_dst_data[index].x_start = x0;
 	osd_hw.free_dst_data[index].x_end = x1;
 #if defined(CONFIG_FB_OSD2_CURSOR)
 	osd_hw.cursor_dispdata[index].x_start = x0;
 	osd_hw.cursor_dispdata[index].x_end = x1;
-	osd_hw.cursor_dispdata[index].y_start = y0;
-	osd_hw.cursor_dispdata[index].y_end = y1;
+	osd_hw.cursor_dispdata[index].y_start = temp_y0;
+	osd_hw.cursor_dispdata[index].y_end = temp_y1;
 #endif
 	if (osd_hw.free_dst_data[index].y_end >= 2159) {
 		if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)
-			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x00202000);
+			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x002020ff);
 		else if (get_cpu_type() ==
 			MESON_CPU_MAJOR_ID_GXTVBB)
 			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0xff);
 		else
-			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x00808000);
+			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x008080ff);
 	}
 	osd_update_window_axis = true;
 	mutex_unlock(&osd_mutex);
@@ -1573,14 +1409,18 @@ void osd_set_window_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1)
 
 void osd_get_block_windows_hw(u32 index, u32 *windows)
 {
+	/*
 	memcpy(windows, osd_hw.block_windows[index],
 	       sizeof(osd_hw.block_windows[index]));
+	*/
 }
 
 void osd_set_block_windows_hw(u32 index, u32 *windows)
 {
+	/*
 	memcpy(osd_hw.block_windows[index], windows,
 	       sizeof(osd_hw.block_windows[index]));
+	*/
 	add_to_update_list(index, DISP_GEOMETRY);
 	osd_wait_vsync_hw();
 }
@@ -1592,7 +1432,7 @@ void osd_get_block_mode_hw(u32 index, u32 *mode)
 
 void osd_set_block_mode_hw(u32 index, u32 mode)
 {
-	osd_hw.block_mode[index] = mode;
+	/* osd_hw.block_mode[index] = mode; */
 	add_to_update_list(index, DISP_GEOMETRY);
 	osd_wait_vsync_hw();
 }
@@ -1630,7 +1470,7 @@ void osd_enable_hw(u32 index, u32 enable)
 		osd_log_info("osd[%d] enable: %d (%s)\n",
 				index, enable, current->comm);
 	} else {
-		osd_log_dbg2("osd[%d] enable: %d (%s)\n",
+		osd_log_info("osd[%d] enable: %d (%s)\n",
 				index, enable, current->comm);
 	}
 
@@ -1639,10 +1479,10 @@ void osd_enable_hw(u32 index, u32 enable)
 			!osd_hw.enable[index] &&
 			osd_hw.osd_afbcd[index].enable && enable) {
 		spin_lock_irqsave(&osd_lock, lock_flags);
-		osd_reg_set_mask(VIU_SW_RESET, 1 << 31);
-		osd_reg_clr_mask(VIU_SW_RESET, 1 << 31);
+		osd_reg_write(VIU_SW_RESET, 0x80000000);
+		osd_reg_write(VIU_SW_RESET, 0);
 		spin_unlock_irqrestore(&osd_lock, lock_flags);
-		osd_afbc_dec_enable = false;
+		osd_afbc_dec_enable = 0;
 
 		add_to_update_list(index, OSD_COLOR_MODE);
 		add_to_update_list(index, OSD_GBL_ALPHA);
@@ -1697,63 +1537,6 @@ void osd_get_flush_rate_hw(u32 *break_rate)
 	*break_rate = vinfo->sync_duration_num / vinfo->sync_duration_den;
 }
 
-void osd_set_rotate_angle_hw(u32 index, u32 angle)
-{
-	osd_hw.rotate[index].angle = angle;
-	add_to_update_list(index, DISP_OSD_ROTATE);
-	osd_wait_vsync_hw();
-}
-
-void osd_get_rotate_angle_hw(u32 index, u32 *angle)
-{
-	*angle = osd_hw.rotate[index].angle;
-}
-void osd_set_rotate_on_hw(u32 index, u32 on_off)
-{
-	osd_hw.rotate[index].on_off = on_off;
-	if (on_off) {
-		g_rotation_width = osd_hw.rotation_pandata[index].x_end -
-				   osd_hw.rotation_pandata[index].x_start;
-		g_rotation_height = osd_hw.rotation_pandata[index].y_end -
-				    osd_hw.rotation_pandata[index].y_start;
-		osd_hw.dispdata[index].x_end = osd_hw.dispdata[OSD1].x_start +
-					g_rotation_height;
-		osd_hw.dispdata[index].y_end = osd_hw.dispdata[OSD1].y_start +
-					g_rotation_width;
-	} else {
-		spin_lock_irqsave(&osd_lock, lock_flags);
-		if (is_meson_m8_cpu()) {
-			osd_reg_set_mask(VPU_SW_RESET, 1 << 8);
-			osd_reg_clr_mask(VPU_SW_RESET, 1 << 8);
-		}
-		if (index == OSD1) {
-			if (is_meson_m8_cpu()) {
-				osd_reg_set_mask(VIU_SW_RESET, 1 << 0);
-				osd_reg_clr_mask(VIU_SW_RESET, 1 << 0);
-			}
-			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_FIFO_CTRL_STAT,
-					1 << 0);
-		} else {
-			osd_reg_set_mask(VIU_SW_RESET, 1 << 1);
-			osd_reg_clr_mask(VIU_SW_RESET, 1 << 1);
-			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD2_FIFO_CTRL_STAT,
-					1 << 0);
-		}
-		spin_unlock_irqrestore(&osd_lock, lock_flags);
-	}
-	spin_lock_irqsave(&osd_lock, lock_flags);
-	osd_hw.reg[index][OSD_COLOR_MODE].update_func();
-	osd_hw.reg[index][DISP_GEOMETRY].update_func();
-	osd_hw.reg[index][DISP_OSD_ROTATE].update_func();
-	spin_unlock_irqrestore(&osd_lock, lock_flags);
-	osd_wait_vsync_hw();
-}
-
-void osd_get_rotate_on_hw(u32 index, u32 *on_off)
-{
-	*on_off = osd_hw.rotate[index].on_off;
-}
-
 void osd_set_antiflicker_hw(u32 index, u32 vmode, u32 yres)
 {
 	bool osd_need_antiflicker = false;
@@ -1786,22 +1569,6 @@ void osd_get_antiflicker_hw(u32 index, u32 *on_off)
 	*on_off = osd_hw.antiflicker_mode;
 }
 
-void osd_get_update_state_hw(u32 index, u32 *up_free)
-{
-	if (osd_vf_need_update)
-		*up_free = 1;
-	else
-		*up_free = 0;
-}
-
-void osd_set_update_state_hw(u32 index, u32 up_free)
-{
-	if (up_free > 0)
-		osd_vf_need_update = true;
-	else
-		osd_vf_need_update = false;
-}
-
 void osd_clone_pan(u32 index, u32 yoffset, int debug_flag)
 {
 	s32 offset = 0;
@@ -1873,6 +1640,7 @@ void osd_set_clone_hw(u32 index, u32 clone)
 	if (osd_hw.clone[index]) {
 		if (osd_hw.angle[index]) {
 			osd_hw.color_info[index] = osd_hw.color_info[OSD1];
+			osd_hw.color_backup[index] = osd_hw.color_info[OSD1];
 			ret = osd_clone_task_start();
 			if (ret)
 				osd_clone_pan(index,
@@ -1899,7 +1667,9 @@ void osd_get_clone_hw(u32 index, u32 *clone)
 
 void osd_set_reverse_hw(u32 index, u32 reverse)
 {
+	char *str[4] = {"NONE", "ALL", "X_REV", "Y_REV"};
 	osd_hw.osd_reverse[index] = reverse;
+	pr_info("set osd%d reverse as %s\n", index, str[reverse]);
 	add_to_update_list(index, DISP_OSD_REVERSE);
 	osd_wait_vsync_hw();
 }
@@ -1909,38 +1679,6 @@ void osd_get_reverse_hw(u32 index, u32 *reverse)
 	*reverse = osd_hw.osd_reverse[index];
 }
 
-void osd_set_prot_canvas_hw(u32 index, s32 x_start, s32 y_start, s32 x_end,
-			    s32 y_end)
-{
-	osd_hw.rotation_pandata[index].x_start = x_start;
-	osd_hw.rotation_pandata[index].y_start = y_start;
-	osd_hw.rotation_pandata[index].x_end = x_end;
-	osd_hw.rotation_pandata[index].y_end = y_end;
-	if (osd_hw.rotate[index].on_off && osd_hw.rotate[index].angle > 0) {
-		g_rotation_width = osd_hw.rotation_pandata[index].x_end -
-				   osd_hw.rotation_pandata[index].x_start;
-		g_rotation_height = osd_hw.rotation_pandata[index].y_end -
-				    osd_hw.rotation_pandata[index].y_start;
-		osd_hw.dispdata[index].x_end = osd_hw.dispdata[OSD1].x_start +
-				g_rotation_height;
-		osd_hw.dispdata[index].y_end = osd_hw.dispdata[OSD1].y_start +
-				g_rotation_width;
-		spin_lock_irqsave(&osd_lock, lock_flags);
-		osd_hw.reg[index][DISP_GEOMETRY].update_func();
-		osd_hw.reg[index][OSD_COLOR_MODE].update_func();
-		spin_unlock_irqrestore(&osd_lock, lock_flags);
-	}
-}
-
-void osd_get_prot_canvas_hw(u32 index, s32 *x_start, s32 *y_start, s32 *x_end,
-			    s32 *y_end)
-{
-	*x_start = osd_hw.rotation_pandata[index].x_start;
-	*y_start = osd_hw.rotation_pandata[index].y_start;
-	*x_end = osd_hw.rotation_pandata[index].x_end;
-	*y_end = osd_hw.rotation_pandata[index].y_end;
-}
-
 void osd_switch_free_scale(
 	u32 pre_index, u32 pre_enable, u32 pre_scale,
 	u32 next_index, u32 next_enable, u32 next_scale)
@@ -1971,18 +1709,6 @@ void osd_switch_free_scale(
 		osd_hw.free_scale[pre_index].v_enable = v_enable;
 		osd_hw.free_scale_enable[pre_index] = pre_scale;
 		osd_hw.enable[pre_index] = pre_enable;
-		if ((osd_hw.free_scale_data[pre_index].x_end > 0)
-			&& h_enable && pre_scale) {
-			osd_hw.free_scale_width[pre_index] =
-				osd_hw.free_scale_data[pre_index].x_end -
-				osd_hw.free_scale_data[pre_index].x_start + 1;
-		}
-		if ((osd_hw.free_scale_data[pre_index].y_end > 0)
-			&& v_enable && pre_scale) {
-			osd_hw.free_scale_height[pre_index] =
-			osd_hw.free_scale_data[pre_index].y_end -
-				osd_hw.free_scale_data[pre_index].y_start + 1;
-		}
 
 		h_enable = (next_scale & 0xffff0000 ? 1 : 0);
 		v_enable = (next_scale & 0xffff ? 1 : 0);
@@ -1990,26 +1716,15 @@ void osd_switch_free_scale(
 		osd_hw.free_scale[next_index].v_enable = v_enable;
 		osd_hw.free_scale_enable[next_index] = next_scale;
 		osd_hw.enable[next_index] = next_enable;
-		if ((osd_hw.free_scale_data[next_index].x_end > 0)
-			&& h_enable && next_scale) {
-			osd_hw.free_scale_width[next_index] =
-				osd_hw.free_scale_data[next_index].x_end -
-				osd_hw.free_scale_data[next_index].x_start + 1;
-		}
-		if ((osd_hw.free_scale_data[next_index].y_end > 0)
-			&& v_enable && next_scale) {
-			osd_hw.free_scale_height[next_index] =
-				osd_hw.free_scale_data[next_index].y_end -
-				osd_hw.free_scale_data[next_index].y_start + 1;
-		}
+
 		osd_set_scan_mode(next_index);
 		spin_lock_irqsave(&osd_lock, lock_flags);
 		if (next_index == OSD1
 			&& osd_hw.osd_afbcd[next_index].enable
 			&& next_enable) {
-			osd_reg_set_mask(VIU_SW_RESET, 1 << 31);
-			osd_reg_clr_mask(VIU_SW_RESET, 1 << 31);
-			osd_afbc_dec_enable = false;
+			osd_reg_write(VIU_SW_RESET, 0x80000000);
+			osd_reg_write(VIU_SW_RESET, 0);
+			osd_afbc_dec_enable = 0;
 			osd_hw.reg[next_index][OSD_GBL_ALPHA].update_func();
 		}
 
@@ -2032,13 +1747,82 @@ void osd_switch_free_scale(
 		osd_wait_vsync_hw();
 	} else {
 		osd_enable_hw(pre_index, pre_enable);
-		osd_set_free_scale_enable_mode0(pre_index, pre_scale);
 		osd_enable_hw(next_index, next_enable);
-		osd_set_free_scale_enable_mode0(next_index, next_scale);
 	}
 }
 
+void osd_get_urgent(u32 index, u32 *urgent)
+{
+	*urgent = osd_hw.urgent[index];
+}
+
+void osd_set_urgent(u32 index, u32 urgent)
+{
+	osd_hw.urgent[index] = urgent;
+	add_to_update_list(index, OSD_FIFO);
+	osd_wait_vsync_hw();
+}
+
 #ifdef CONFIG_FB_OSD_SUPPORT_SYNC_FENCE
+enum {
+	HAL_PIXEL_FORMAT_RGBA_8888 = 1,
+	HAL_PIXEL_FORMAT_RGBX_8888 = 2,
+	HAL_PIXEL_FORMAT_RGB_888 = 3,
+	HAL_PIXEL_FORMAT_RGB_565 = 4,
+	HAL_PIXEL_FORMAT_BGRA_8888 = 5,
+};
+
+static u32 extern_canvas[2] = {EXTERN1_CANVAS, EXTERN2_CANVAS};
+static int ext_canvas_id;
+static bool use_ext;
+const struct color_bit_define_s extern_color_format_array[] = {
+	/*32 bit color RGBA */
+	{
+		COLOR_INDEX_32_ABGR, 2, 5,
+		0, 8, 0, 8, 8, 0, 16, 8, 0, 24, 8, 0,
+		0, 4
+	},
+	/*32 bit color RGBX */
+	{
+		COLOR_INDEX_32_XBGR, 2, 5,
+		0, 8, 0, 8, 8, 0, 16, 8, 0, 24, 0, 0,
+		0, 4
+	},
+	/*24 bit color RGB */
+	{
+		COLOR_INDEX_24_RGB, 5, 7,
+		16, 8, 0, 8, 8, 0, 0, 8, 0, 0, 0, 0,
+		0, 3
+	},
+	/*16 bit color BGR */
+	{
+		COLOR_INDEX_16_565, 4, 4,
+		11, 5, 0, 5, 6, 0, 0, 5, 0, 0, 0, 0,
+		0, 2
+	},
+	/*32 bit color BGRA */
+	{
+		COLOR_INDEX_32_ARGB, 1, 5,
+		16, 8, 0, 8, 8, 0, 0, 8, 0, 24, 8, 0,
+		0, 4
+	},
+};
+
+static const struct color_bit_define_s *convert_hal_format(u32 format)
+{
+	const struct color_bit_define_s *color = NULL;
+	switch (format) {
+	case HAL_PIXEL_FORMAT_RGBA_8888:
+	case HAL_PIXEL_FORMAT_RGBX_8888:
+	case HAL_PIXEL_FORMAT_RGB_888:
+	case HAL_PIXEL_FORMAT_RGB_565:
+	case HAL_PIXEL_FORMAT_BGRA_8888:
+		color = &extern_color_format_array[format - 1];
+		break;
+	}
+	return color;
+}
+
 static void osd_pan_display_fence(struct osd_fence_map_s *fence_map)
 {
 	s32 ret = 1;
@@ -2046,6 +1830,11 @@ static void osd_pan_display_fence(struct osd_fence_map_s *fence_map)
 	u32 index = fence_map->fb_index;
 	u32 xoffset = fence_map->xoffset;
 	u32 yoffset = fence_map->yoffset;
+	u32 ext_addr = fence_map->ext_addr;
+	const struct color_bit_define_s *color = NULL;
+	bool color_mode = false;
+	u32 osd_enable = 0;
+	bool skip = false;
 	if (index >= 2)
 		return;
 	if (timeline_created) { /* out fence created success. */
@@ -2054,15 +1843,87 @@ static void osd_pan_display_fence(struct osd_fence_map_s *fence_map)
 			osd_log_dbg("fence wait ret %d\n", ret);
 	}
 	if (ret) {
-		if (xoffset != osd_hw.pandata[index].x_start
-		    || yoffset != osd_hw.pandata[index].y_start) {
+		if (fence_map->op == 0xffffffff)
+			skip = true;
+		else
+			osd_enable = (fence_map->op & 1) ? DISABLE : ENABLE;
+		if (ext_addr && fence_map->width
+				&& fence_map->height && index == OSD1) {
 			spin_lock_irqsave(&osd_lock, lock_flags);
-			diff_x = xoffset - osd_hw.pandata[index].x_start;
-			diff_y = yoffset - osd_hw.pandata[index].y_start;
-			osd_hw.pandata[index].x_start += diff_x;
-			osd_hw.pandata[index].x_end   += diff_x;
-			osd_hw.pandata[index].y_start += diff_y;
-			osd_hw.pandata[index].y_end   += diff_y;
+			use_ext = true;
+			osd_hw.fb_gem[index].canvas_idx =
+				extern_canvas[ext_canvas_id];
+			ext_canvas_id ^= 1;
+			color = convert_hal_format(fence_map->format);
+			if (color)
+				osd_hw.color_info[index] = color;
+			else
+				osd_log_err("fence color format error %d\n",
+					fence_map->format);
+			canvas_config(osd_hw.fb_gem[index].canvas_idx,
+				ext_addr,
+				fence_map->width *
+				osd_hw.color_info[index]->bpp,
+				fence_map->height,
+				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+			osd_hw.pandata[index].x_start = 0;
+			osd_hw.pandata[index].x_end = fence_map->width - 1;
+			osd_hw.pandata[index].y_start = 0;
+			osd_hw.pandata[index].y_end = fence_map->height - 1;
+			if (index == OSD1 &&
+				osd_hw.osd_afbcd[index].enable == ENABLE) {
+				osd_hw.osd_afbcd[index].phy_addr =
+					ext_addr;
+			}
+			osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+			osd_hw.reg[index][DISP_GEOMETRY].update_func();
+			if (osd_hw.free_scale_enable[index]
+					&& osd_update_window_axis) {
+				osd_hw.reg[index][DISP_FREESCALE_ENABLE]
+					.update_func();
+				osd_update_window_axis = false;
+			}
+			if ((osd_hw.osd_afbcd[index].enable == DISABLE)
+				&& (osd_enable != osd_hw.enable[index])
+				&& skip == false) {
+				osd_hw.enable[index] = osd_enable;
+				osd_hw.reg[index][OSD_ENABLE].update_func();
+			}
+			spin_unlock_irqrestore(&osd_lock, lock_flags);
+			osd_wait_vsync_hw();
+		} else if (xoffset != osd_hw.pandata[index].x_start
+			|| yoffset != osd_hw.pandata[index].y_start
+			|| (use_ext && index == OSD1)) {
+			spin_lock_irqsave(&osd_lock, lock_flags);
+			if ((use_ext) && (index == OSD1)) {
+				osd_hw.fb_gem[index].canvas_idx =
+					OSD1_CANVAS_INDEX;
+				osd_hw.pandata[index].x_start = xoffset;
+				osd_hw.pandata[index].x_end   = xoffset -
+					osd_hw.fb_gem[index].xres + 1;
+				osd_hw.pandata[index].y_start = yoffset;
+				osd_hw.pandata[index].x_end   = yoffset -
+					osd_hw.fb_gem[index].yres + 1;
+				osd_hw.color_info[index] =
+					osd_hw.color_backup[index];
+				canvas_config(osd_hw.fb_gem[0].canvas_idx,
+					osd_hw.fb_gem[0].addr,
+					osd_hw.fb_gem[0].width,
+					osd_hw.fb_gem[0].height,
+					CANVAS_ADDR_NOWRAP,
+					CANVAS_BLKMODE_LINEAR);
+				use_ext = false;
+				color_mode = true;
+			} else {
+				diff_x = xoffset -
+					osd_hw.pandata[index].x_start;
+				diff_y = yoffset -
+					osd_hw.pandata[index].y_start;
+				osd_hw.pandata[index].x_start += diff_x;
+				osd_hw.pandata[index].x_end   += diff_x;
+				osd_hw.pandata[index].y_start += diff_y;
+				osd_hw.pandata[index].y_end   += diff_y;
+			}
 			if (index == OSD1 &&
 				osd_hw.osd_afbcd[index].enable == ENABLE) {
 				/*osd_hw.osd_afbcd[index].phy_addr =
@@ -2077,6 +1938,8 @@ static void osd_pan_display_fence(struct osd_fence_map_s *fence_map)
 					[osd_hw.pandata[index].y_start /
 					osd_hw.osd_afbcd[index].frame_height];
 			}
+			if (color_mode)
+				osd_hw.reg[index][OSD_COLOR_MODE].update_func();
 			osd_hw.reg[index][DISP_GEOMETRY].update_func();
 			if (osd_hw.free_scale_enable[index]
 					&& osd_update_window_axis) {
@@ -2084,6 +1947,21 @@ static void osd_pan_display_fence(struct osd_fence_map_s *fence_map)
 					.update_func();
 				osd_update_window_axis = false;
 			}
+			if ((osd_hw.osd_afbcd[index].enable == DISABLE)
+				&& (osd_enable != osd_hw.enable[index])
+				&& skip == false) {
+				osd_hw.enable[index] = osd_enable;
+				osd_hw.reg[index][OSD_ENABLE].update_func();
+			}
+			spin_unlock_irqrestore(&osd_lock, lock_flags);
+			osd_wait_vsync_hw();
+		} else if ((osd_enable != osd_hw.enable[index])
+					&& skip == false) {
+			spin_lock_irqsave(&osd_lock, lock_flags);
+			if (osd_hw.osd_afbcd[index].enable == DISABLE) {
+				osd_hw.enable[index] = osd_enable;
+				osd_hw.reg[index][OSD_ENABLE].update_func();
+			}
 			spin_unlock_irqrestore(&osd_lock, lock_flags);
 			osd_wait_vsync_hw();
 		}
@@ -2154,6 +2032,7 @@ static  void  osd1_update_disp_scale_enable(void)
 				VIU_OSD1_BLK0_CFG_W0,
 				1 << 14);
 	}
+	remove_from_update_list(OSD1, DISP_SCALE_ENABLE);
 }
 
 static  void  osd2_update_disp_scale_enable(void)
@@ -2179,12 +2058,13 @@ static  void  osd2_update_disp_scale_enable(void)
 			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0,
 					1 << 14);
 	}
+	remove_from_update_list(OSD2, DISP_SCALE_ENABLE);
 }
 
 static void osd_super_scale_enable(u32 index)
 {
 	u32 data32 = 0x0;
-
+	u32 src_w = 0, src_h = 0;
 	osd_super_scale_mem_power_on();
 	/* enable osd scaler path */
 	if (index == OSD1)
@@ -2204,8 +2084,11 @@ static void osd_super_scale_enable(u32 index)
 	VSYNCOSD_WR_MPEG_REG(OSDSR_UK_GRAD2DADJA_LIMIT, 0xffffff);
 	VSYNCOSD_WR_MPEG_REG(OSDSR_UK_BST_GAIN, 0x7a7a3a50);
 	/* config osd super scaler input size */
-	data32 = (osd_hw.free_scale_height[index] & 0x1fff)
-		| (osd_hw.free_scale_width[index] & 0x1fff) << 16;
+	src_w = osd_hw.free_src_data[OSD1].x_end -
+		osd_hw.free_src_data[OSD1].x_start + 1;
+	src_h = osd_hw.free_src_data[OSD1].y_end -
+		osd_hw.free_src_data[OSD1].y_start + 1;
+	data32 = (src_w & 0x1fff) | (src_h & 0x1fff) << 16;
 	VSYNCOSD_WR_MPEG_REG(OSDSR_HV_SIZEIN, data32);
 	/* config osd super scaler output size */
 	data32 = ((osd_hw.free_dst_data[index].x_end & 0xfff) |
@@ -2258,8 +2141,11 @@ static void osd1_update_disp_freescale_enable(void)
 		(hf_bank_len / 2 - 1) > 0 ? (hf_bank_len / 2 - 1) : 0;
 	vsc_ini_rpt_p0_num =
 		(vf_bank_len / 2 - 1) > 0 ? (vf_bank_len / 2 - 1) : 0;
-	src_w = osd_hw.free_scale_width[OSD1];
-	src_h = osd_hw.free_scale_height[OSD1];
+
+	src_w = osd_hw.free_src_data[OSD1].x_end -
+		osd_hw.free_src_data[OSD1].x_start + 1;
+	src_h = osd_hw.free_src_data[OSD1].y_end -
+		osd_hw.free_src_data[OSD1].y_start + 1;
 	dst_w = osd_hw.free_dst_data[OSD1].x_end -
 		osd_hw.free_dst_data[OSD1].x_start + 1;
 	dst_h = osd_hw.free_dst_data[OSD1].y_end -
@@ -2406,8 +2292,11 @@ static void osd2_update_disp_freescale_enable(void)
 		(hf_bank_len / 2 - 1) > 0 ? (hf_bank_len / 2 - 1) : 0;
 	vsc_ini_rpt_p0_num =
 		(vf_bank_len / 2 - 1) > 0 ? (vf_bank_len / 2 - 1) : 0;
-	src_w = osd_hw.free_scale_width[OSD2];
-	src_h = osd_hw.free_scale_height[OSD2];
+
+	src_w = osd_hw.free_src_data[OSD2].x_end -
+		osd_hw.free_src_data[OSD2].x_start + 1;
+	src_h = osd_hw.free_src_data[OSD2].y_end -
+		osd_hw.free_src_data[OSD2].y_start + 1;
 	dst_w = osd_hw.free_dst_data[OSD2].x_end -
 		osd_hw.free_dst_data[OSD2].x_start + 1;
 	dst_h = osd_hw.free_dst_data[OSD2].y_end -
@@ -2545,8 +2434,8 @@ static void osd1_update_color_mode(void)
 		data32 |= VSYNCOSD_RD_MPEG_REG(VIU_OSD1_BLK0_CFG_W0)
 			& 0x30007040;
 		data32 |= osd_hw.fb_gem[OSD1].canvas_idx << 16;
-		if (!osd_hw.rotate[OSD1].on_off)
-			data32 |= OSD_DATA_LITTLE_ENDIAN << 15;
+		/* if (!osd_hw.rotate[OSD1].on_off) */
+		data32 |= OSD_DATA_LITTLE_ENDIAN << 15;
 		data32 |= osd_hw.color_info[OSD1]->hw_colormat << 2;
 		if (get_cpu_type() < MESON_CPU_MAJOR_ID_GXTVBB) {
 			if (osd_hw.color_info[OSD1]->color_index <
@@ -2556,9 +2445,11 @@ static void osd1_update_color_mode(void)
 		/* osd_blk_mode */
 		data32 |=  osd_hw.color_info[OSD1]->hw_blkmode << 8;
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W0, data32);
+		/*
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK1_CFG_W0, data32);
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK2_CFG_W0, data32);
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK3_CFG_W0, data32);
+		*/
 		if (osd_hw.osd_afbcd[OSD1].enable) {
 			/* only the RGBA32 mode */
 			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_MODE,
@@ -2573,11 +2464,22 @@ static void osd1_update_color_mode(void)
 				(osd_hw.osd_afbcd[OSD1].conv_lbuf_len
 				& 0xffff));
 			/* afbc mode RGBA32 -> RGB24
-			 VSYNCOSD_WR_MPEG_REG_BITS(OSD1_AFBCD_CHROMA_PTR,
-				0x1b, 24, 8);
+			data32 = (0x1b << 24) |
+				(osd_hw.osd_afbcd[OSD1].phy_addr & 0xffffff);
+			VSYNCOSD_WR_MPEG_REG(
+				OSD1_AFBCD_CHROMA_PTR,
+				data32);
 			*/
-			VSYNCOSD_WR_MPEG_REG_BITS(OSD1_AFBCD_CHROMA_PTR,
+			VSYNCOSD_WR_MPEG_REG_BITS(
+				OSD1_AFBCD_CHROMA_PTR,
 				0xe4, 24, 8);
+			/*
+			data32 = (0xe4 << 24) |
+				(osd_hw.osd_afbcd[OSD1].phy_addr & 0xffffff);
+			VSYNCOSD_WR_MPEG_REG(
+				OSD1_AFBCD_CHROMA_PTR,
+				data32);
+			*/
 		}
 		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
 			enum color_index_e idx =
@@ -2604,8 +2506,8 @@ static void osd2_update_color_mode(void)
 		data32 |= VSYNCOSD_RD_MPEG_REG(VIU_OSD2_BLK0_CFG_W0)
 			& 0x30007040;
 		data32 |= osd_hw.fb_gem[OSD2].canvas_idx << 16;
-		if (!osd_hw.rotate[OSD2].on_off)
-			data32 |= OSD_DATA_LITTLE_ENDIAN << 15;
+		/* if (!osd_hw.rotate[OSD2].on_off) */
+		data32 |= OSD_DATA_LITTLE_ENDIAN << 15;
 		data32 |= osd_hw.color_info[OSD2]->hw_colormat << 2;
 		if (get_cpu_type() != MESON_CPU_MAJOR_ID_GXTVBB) {
 			if (osd_hw.color_info[OSD2]->color_index <
@@ -2634,104 +2536,67 @@ static void osd2_update_color_mode(void)
 
 static void osd1_update_enable(void)
 {
-	u32 video_enable = 0;
 	if (((get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) ||
 		(get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)) &&
 		(osd_hw.enable[OSD1] == ENABLE)) {
-		if (((VSYNCOSD_RD_MPEG_REG(VPP_MISC) &
-			VPP_OSD1_POSTBLEND) == 0) &&
-			((VSYNCOSD_RD_MPEG_REG(VPU_RDARB_MODE_L1C2) &
-			(1<<16)) == 0)) {
+		if ((VSYNCOSD_RD_MPEG_REG(VPU_RDARB_MODE_L1C2) &
+			(1 << 16)) == 0) {
 			VSYNCOSD_WR_MPEG_REG_BITS(VPU_RDARB_MODE_L1C2,
 				1, 16, 1);
 		}
 	}
+
+	if (osd_hw.enable[OSD1] == ENABLE)
+		osd_vpp_misc |= VPP_OSD1_POSTBLEND;
+	else
+		osd_vpp_misc &= ~VPP_OSD1_POSTBLEND;
+
+	if (osd_hw.enable[OSD1] == ENABLE) {
+		VSYNCOSD_SET_MPEG_REG_MASK(
+			VIU_OSD1_CTRL_STAT, 1 << 0);
+		VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
+			VPP_OSD1_POSTBLEND | VPP_POSTBLEND_EN);
+		notify_to_amvideo();
+	} else {
+		notify_to_amvideo();
+		VSYNCOSD_CLR_MPEG_REG_MASK(
+			VPP_MISC,
+			VPP_OSD1_POSTBLEND);
+		VSYNCOSD_CLR_MPEG_REG_MASK(
+			VIU_OSD1_CTRL_STAT, 1 << 0);
+
+	}
 	if ((osd_hw.osd_afbcd[OSD1].enable == ENABLE) &&
 		((get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB) ||
 		(get_cpu_type() == MESON_CPU_MAJOR_ID_GXM))) {
-		/*VSYNCOSD_CLR_MPEG_REG_MASK(
-			VIU_OSD1_CTRL_STAT,
-			1 << 21);*/
-		if (osd_hw.free_scale_mode[OSD1]) {
-			if (osd_hw.enable[OSD1] == ENABLE) {
-				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
-						VPP_OSD1_POSTBLEND |
-						VPP_POSTBLEND_EN);
-				VSYNCOSD_SET_MPEG_REG_MASK(
-						VIU_OSD1_CTRL_STAT,
-						1 << 0);
-			} else {
-				VSYNCOSD_CLR_MPEG_REG_MASK(
-						VIU_OSD1_CTRL_STAT,
-						1 << 0);
-				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-					VPP_OSD1_POSTBLEND);
-			}
-		}
 		if (osd_hw.enable[OSD1] == ENABLE) {
 			if (!osd_afbc_dec_enable &&
 					osd_hw.osd_afbcd[OSD1].phy_addr != 0) {
-				VSYNCOSD_WR_MPEG_REG_BITS(
-						OSD1_AFBCD_ENABLE,
-						1, 8, 1);
-				osd_afbc_dec_enable = true;
+				VSYNCOSD_WR_MPEG_REG(
+					OSD1_AFBCD_ENABLE,
+					0x8100);
+				osd_afbc_dec_enable = 1;
 			}
 			VSYNCOSD_WR_MPEG_REG_BITS(
 				VIU_OSD1_CTRL_STAT2,
 				1, 15, 1);
-			VSYNCOSD_WR_MPEG_REG_BITS(
-				VIU_MISC_CTRL1,
-				0x90, 8, 8);
+
 		} else {
 			if (osd_afbc_dec_enable) {
-				VSYNCOSD_WR_MPEG_REG_BITS(
+				VSYNCOSD_WR_MPEG_REG(
 					OSD1_AFBCD_ENABLE,
-					0, 8, 1);
-				osd_afbc_dec_enable = false;
+					0x8000);
+				osd_afbc_dec_enable = 0;
 			}
 			VSYNCOSD_WR_MPEG_REG_BITS(
 				VIU_OSD1_CTRL_STAT2,
 				0, 15, 1);
+		}
+		if ((VSYNCOSD_RD_MPEG_REG(VIU_MISC_CTRL1) &
+			(0xff << 8)) != 0x9000) {
 			VSYNCOSD_WR_MPEG_REG_BITS(
 				VIU_MISC_CTRL1,
-				0, 8, 8);
-		}
-	} else if (osd_hw.free_scale_mode[OSD1]) {
-		if (osd_hw.enable[OSD1] == ENABLE) {
-			VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
-				VPP_OSD1_POSTBLEND | VPP_POSTBLEND_EN);
-			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_CTRL_STAT, 1 << 0);
-		} else {
-			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_CTRL_STAT, 1 << 0);
-			VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-				VPP_OSD1_POSTBLEND);
-		}
-	} else {
-		video_enable |= VSYNCOSD_RD_MPEG_REG(VPP_MISC)&VPP_VD1_PREBLEND;
-		if (osd_hw.enable[OSD1] == ENABLE) {
-			if (osd_hw.free_scale_enable[OSD1]) {
-				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-						VPP_OSD1_POSTBLEND);
-				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
-						VPP_OSD1_PREBLEND
-						| VPP_VD1_POSTBLEND
-						| VPP_PREBLEND_EN);
-			} else {
-				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-						VPP_OSD1_PREBLEND);
-				if (!video_enable)
-					VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-							VPP_VD1_POSTBLEND);
-				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
-						VPP_OSD1_POSTBLEND);
-			}
-		} else {
-			if (osd_hw.free_scale_enable[OSD1])
-				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-						VPP_OSD1_PREBLEND);
-			else
-				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-						VPP_OSD1_POSTBLEND);
+				0x90, 8, 8);
 		}
 	}
 	remove_from_update_list(OSD1, OSD_ENABLE);
@@ -2739,201 +2604,63 @@ static void osd1_update_enable(void)
 
 static void osd2_update_enable(void)
 {
-	u32 video_enable = 0;
-
-	if (osd_hw.free_scale_mode[OSD2]) {
-		if (osd_hw.enable[OSD2] == ENABLE) {
-			VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
-				VPP_OSD2_POSTBLEND
-				| VPP_POSTBLEND_EN);
-			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD2_CTRL_STAT,
-				1 << 0);
-		} else {
-			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_CTRL_STAT,
-				1 << 0);
-			VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-				VPP_OSD2_POSTBLEND);
-		}
+	if (osd_hw.enable[OSD2] == ENABLE)
+		osd_vpp_misc |= VPP_OSD2_POSTBLEND;
+	else
+		osd_vpp_misc &= ~VPP_OSD2_POSTBLEND;
+
+	if (osd_hw.enable[OSD2] == ENABLE) {
+		VSYNCOSD_SET_MPEG_REG_MASK(
+			VIU_OSD2_CTRL_STAT,
+			1 << 0);
+		VSYNCOSD_SET_MPEG_REG_MASK(
+			VPP_MISC,
+			VPP_OSD2_POSTBLEND
+			| VPP_POSTBLEND_EN);
+		notify_to_amvideo();
 	} else {
-		video_enable |= VSYNCOSD_RD_MPEG_REG(VPP_MISC)&VPP_VD1_PREBLEND;
-		if (osd_hw.enable[OSD2] == ENABLE) {
-			if (osd_hw.free_scale_enable[OSD2]) {
-				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-					VPP_OSD2_POSTBLEND);
-				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
-					VPP_OSD2_PREBLEND
-					| VPP_VD1_POSTBLEND);
-			} else {
-				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-					VPP_OSD2_PREBLEND);
-				if (!video_enable)
-					VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-						VPP_VD1_POSTBLEND);
-				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
-					VPP_OSD2_POSTBLEND);
-			}
-		} else {
-			if (osd_hw.free_scale_enable[OSD2])
-				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-					VPP_OSD2_PREBLEND);
-			else
-				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
-					VPP_OSD2_POSTBLEND);
-		}
+		notify_to_amvideo();
+		VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC,
+			VPP_OSD2_POSTBLEND);
+		VSYNCOSD_CLR_MPEG_REG_MASK(
+			VIU_OSD2_CTRL_STAT,
+			1 << 0);
 	}
 	remove_from_update_list(OSD2, OSD_ENABLE);
 }
 
 static void osd1_update_disp_osd_reverse(void)
 {
-	if (osd_hw.osd_reverse[OSD1])
+	if (osd_hw.osd_reverse[OSD1] == REVERSE_TRUE)
 		VSYNCOSD_WR_MPEG_REG_BITS(VIU_OSD1_BLK0_CFG_W0, 3, 28, 2);
+	else if (osd_hw.osd_reverse[OSD1] == REVERSE_X)
+		VSYNCOSD_WR_MPEG_REG_BITS(VIU_OSD1_BLK0_CFG_W0, 1, 28, 2);
+	else if (osd_hw.osd_reverse[OSD1] == REVERSE_Y)
+		VSYNCOSD_WR_MPEG_REG_BITS(VIU_OSD1_BLK0_CFG_W0, 2, 28, 2);
 	else
-		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0, 3 << 28);
+		VSYNCOSD_WR_MPEG_REG_BITS(VIU_OSD1_BLK0_CFG_W0, 0, 28, 2);
 	remove_from_update_list(OSD1, DISP_OSD_REVERSE);
 }
 
 static void osd2_update_disp_osd_reverse(void)
 {
-	if (osd_hw.osd_reverse[OSD2])
+	if (osd_hw.osd_reverse[OSD2] == REVERSE_TRUE)
 		VSYNCOSD_WR_MPEG_REG_BITS(VIU_OSD2_BLK0_CFG_W0, 3, 28, 2);
+	else if (osd_hw.osd_reverse[OSD2] == REVERSE_X)
+		VSYNCOSD_WR_MPEG_REG_BITS(VIU_OSD2_BLK0_CFG_W0, 1, 28, 2);
+	else if (osd_hw.osd_reverse[OSD2] == REVERSE_Y)
+		VSYNCOSD_WR_MPEG_REG_BITS(VIU_OSD2_BLK0_CFG_W0, 2, 28, 2);
 	else
-		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 3 << 28);
+		VSYNCOSD_WR_MPEG_REG_BITS(VIU_OSD2_BLK0_CFG_W0, 0, 28, 2);
 	remove_from_update_list(OSD2, DISP_OSD_REVERSE);
 }
 static void osd1_update_disp_osd_rotate(void)
 {
-	unsigned char	x_rev = 0, y_rev = 0;
-	unsigned char	bpp = 32;
-	unsigned int	x_start;
-	unsigned int	x_end;
-	unsigned int	y_start;
-	unsigned int	y_end;
-	unsigned int	y_len_m1;
-	if (osd_hw.color_info[OSD1]->color_index <= COLOR_INDEX_08_PAL256)
-		bpp = 8;
-	else if (osd_hw.color_info[OSD1]->color_index <= COLOR_INDEX_16_565)
-		bpp = 16;
-	else if (osd_hw.color_info[OSD1]->color_index <= COLOR_INDEX_24_RGB)
-		bpp = 24;
-	else if (osd_hw.color_info[OSD1]->color_index <= COLOR_INDEX_32_ARGB)
-		bpp = 32;
-	switch (osd_hw.rotate[OSD1].angle) {
-	case 0:/* clockwise H flip (dst ) */
-		x_rev = 0;
-		y_rev = 0;
-		break;/* clockwise */
-	case 1:
-		y_rev = 1;
-		break;
-	case 2:/* anti-clockwise */
-		x_rev = 1;
-		break;
-	case 3:/* anti-clockwise H flip(dst) */
-		x_rev = 1;
-		y_rev = 1;
-		break;
-	}
-	x_start = osd_hw.rotation_pandata[OSD1].x_start;
-	x_end = osd_hw.rotation_pandata[OSD1].x_end;
-	y_start = osd_hw.rotation_pandata[OSD1].y_start;
-	y_end = osd_hw.rotation_pandata[OSD1].y_end;
-	y_len_m1 = y_end - y_start;
-	if (is_meson_m8_cpu()) {
-		osd_set_prot(
-			x_rev,
-			y_rev,
-			(bpp >> 3) - 1,
-			0, /* conv_422to444, */
-			OSD_DATA_LITTLE_ENDIAN,
-			HOLD_LINES,
-			x_start,
-			x_end,
-			y_start,
-			y_end,
-			y_len_m1,
-			Y_STEP,
-			PAT_START_PTR,
-			PAT_END_PTR,
-			PAT_VAL,
-			osd_hw.fb_gem[OSD1].canvas_idx,
-			CID_VALUE,
-			CID_MODE,
-			CUGT, /* urgent bit */
-			REQ_ONOFF_EN,
-			REQ_ON_MAX,
-			REQ_OFF_MIN,
-			OSD1,
-			osd_hw.rotate[OSD1].on_off);
-	}
 	remove_from_update_list(OSD1, DISP_OSD_ROTATE);
 }
 
 static void osd2_update_disp_osd_rotate(void)
 {
-	unsigned char	x_rev = 0, y_rev = 0;
-	unsigned char	bpp = 32;
-	unsigned int	x_start;
-	unsigned int	x_end;
-	unsigned int	y_start;
-	unsigned int	y_end;
-	unsigned int	y_len_m1;
-	if (osd_hw.color_info[OSD2]->color_index <= COLOR_INDEX_08_PAL256)
-		bpp = 8;
-	else if (osd_hw.color_info[OSD2]->color_index <= COLOR_INDEX_16_565)
-		bpp = 16;
-	else if (osd_hw.color_info[OSD2]->color_index <= COLOR_INDEX_24_RGB)
-		bpp = 24;
-	else if (osd_hw.color_info[OSD2]->color_index <= COLOR_INDEX_32_ARGB)
-		bpp = 32;
-	switch (osd_hw.rotate[OSD2].angle) {
-	case 0:/* clockwise H flip (dst ) */
-		x_rev = 0;
-		y_rev = 0;
-		break;/* clockwise */
-	case 1:
-		y_rev = 1;
-		break;
-	case 2:/* anti-clockwise */
-		x_rev = 1;
-		break;
-	case 3:/* anti-clockwise H flip(dst) */
-		x_rev = 1;
-		y_rev = 1;
-		break;
-	}
-	x_start = osd_hw.rotation_pandata[OSD2].x_start;
-	x_end = osd_hw.rotation_pandata[OSD2].x_end;
-	y_start = osd_hw.rotation_pandata[OSD2].y_start;
-	y_end = osd_hw.rotation_pandata[OSD2].y_end;
-	y_len_m1 = y_end - y_start;
-	if (is_meson_m8_cpu()) {
-		osd_set_prot(
-			x_rev,
-			y_rev,
-			(bpp >> 3) - 1, /* bytes_per_pixel, */
-			0, /* conv_422to444, */
-			OSD_DATA_LITTLE_ENDIAN,
-			HOLD_LINES,
-			x_start,
-			x_end,
-			y_start,
-			y_end,
-			y_len_m1,
-			Y_STEP,
-			PAT_START_PTR,
-			PAT_END_PTR,
-			PAT_VAL,
-			osd_hw.fb_gem[OSD2].canvas_idx,
-			CID_VALUE,
-			CID_MODE,
-			CUGT, /* urgent bit */
-			REQ_ONOFF_EN,
-			REQ_ON_MAX,
-			REQ_OFF_MIN,
-			OSD2,
-			osd_hw.rotate[OSD2].on_off);
-	}
 	remove_from_update_list(OSD2, DISP_OSD_ROTATE);
 }
 
@@ -2957,9 +2684,11 @@ static void osd1_update_color_key_enable(void)
 	data32 &= ~(1 << 6);
 	data32 |= (osd_hw.color_key_enable[OSD1] << 6);
 	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W0, data32);
+	/*
 	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK1_CFG_W0, data32);
 	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK2_CFG_W0, data32);
 	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK3_CFG_W0, data32);
+	*/
 	remove_from_update_list(OSD1, OSD_COLOR_KEY_ENABLE);
 }
 
@@ -2992,39 +2721,48 @@ static void osd2_update_gbl_alpha(void)
 }
 static void osd2_update_order(void)
 {
-	unsigned long flags;
-	spin_lock_irqsave(&osd_onoff_lock, flags);
 	switch (osd_hw.order) {
 	case  OSD_ORDER_01:
+#ifndef CONFIG_FB_OSD_VSYNC_RDMA
 		osd_reg_clr_mask(VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+#endif
+		osd_vpp_misc &= ~(VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
 		break;
 	case  OSD_ORDER_10:
+#ifndef CONFIG_FB_OSD_VSYNC_RDMA
 		osd_reg_set_mask(VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+#endif
+		osd_vpp_misc |= (VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
 		break;
 	default:
 		break;
 	}
-	spin_unlock_irqrestore(&osd_onoff_lock, flags);
+	notify_to_amvideo();
 	remove_from_update_list(OSD2, OSD_CHANGE_ORDER);
 }
 static void osd1_update_order(void)
 {
-	unsigned long flags;
-	spin_lock_irqsave(&osd_onoff_lock, flags);
 	switch (osd_hw.order) {
 	case  OSD_ORDER_01:
+#ifndef CONFIG_FB_OSD_VSYNC_RDMA
 		osd_reg_clr_mask(VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+#endif
+		osd_vpp_misc &= ~(VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
 		break;
 	case  OSD_ORDER_10:
+#ifndef CONFIG_FB_OSD_VSYNC_RDMA
 		osd_reg_set_mask(VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+#endif
+		osd_vpp_misc |= (VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
 		break;
 	default:
 		break;
 	}
-	spin_unlock_irqrestore(&osd_onoff_lock, flags);
+	notify_to_amvideo();
 	remove_from_update_list(OSD1, OSD_CHANGE_ORDER);
 }
 
+#if 0
 static void osd_block_update_disp_geometry(u32 index)
 {
 	u32 data32;
@@ -3208,6 +2946,7 @@ static void osd_block_update_disp_geometry(u32 index)
 		break;
 	}
 }
+#endif
 
 static void osd1_2x_scale_update_geometry(void)
 {
@@ -3228,8 +2967,11 @@ static void osd1_2x_scale_update_geometry(void)
 			osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
 		VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_FRAME_PTR,
 			osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-		VSYNCOSD_WR_MPEG_REG_BITS(OSD1_AFBCD_CHROMA_PTR,
-			(osd_hw.osd_afbcd[OSD1].phy_addr & 0xffffff), 0, 24);
+		data32 = (0xe4 << 24) |
+			(osd_hw.osd_afbcd[OSD1].phy_addr & 0xffffff);
+		VSYNCOSD_WR_MPEG_REG(
+			OSD1_AFBCD_CHROMA_PTR,
+			data32);
 	}
 
 	data32 = ((osd_hw.scaledata[OSD1].y_start
@@ -3289,72 +3031,19 @@ static void osd1_basic_update_disp_geometry(void)
 {
 	u32 data32;
 
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8) {
-		data32 = (osd_hw.dispdata[OSD1].x_start & 0xfff)
-			| (osd_hw.dispdata[OSD1].x_end & 0xfff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 , data32);
-		if (osd_hw.scan_mode == SCAN_MODE_INTERLACE)
-			data32 = ((osd_hw.dispdata[OSD1].y_start >> 1) & 0xfff)
-				| ((((osd_hw.dispdata[OSD1].y_end + 1)
-					>> 1) - 1) & 0xfff) << 16;
-		else
-			data32 = (osd_hw.dispdata[OSD1].y_start & 0xfff)
-				| (osd_hw.dispdata[OSD1].y_end
-					& 0xfff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4, data32);
-	} else {
-		if (osd_hw.free_scale_mode[OSD1] == 0) {
-			if (osd_hw.free_scale_enable[OSD1] == 1) {
-				data32 = (osd_hw.free_scale_data[OSD1].x_start
-						& 0xfff)
-					| (osd_hw.free_scale_data[OSD1].x_end
-						& 0xfff) << 16;
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3,
-						data32);
-				data32 = (osd_hw.free_scale_data[OSD1].y_start
-						& 0xfff)
-					| (osd_hw.free_scale_data[OSD1].y_end
-						& 0xfff) << 16;
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4,
-						data32);
-			} else {
-				data32 = (osd_hw.dispdata[OSD1].x_start
-						& 0xfff)
-					| (osd_hw.dispdata[OSD1].x_end
-						& 0xfff) << 16;
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3,
-						data32);
-				if (osd_hw.scan_mode == SCAN_MODE_INTERLACE)
-					data32 = ((osd_hw.dispdata[OSD1].y_start
-							>> 1) & 0xfff)
-					    | ((((osd_hw.dispdata[OSD1].y_end
-							+ 1) >> 1) - 1)
-							& 0xfff) << 16;
-				else
-					data32 = (osd_hw.dispdata[OSD1].y_start
-							& 0xfff)
-						| (osd_hw.dispdata[OSD1].y_end
-							& 0xfff) << 16;
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4,
-						data32);
-			}
-		} else {
-			data32 = (osd_hw.dispdata[OSD1].x_start & 0xfff)
-				| (osd_hw.dispdata[OSD1].x_end & 0xfff) << 16;
-			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 , data32);
-			if (osd_hw.scan_mode == SCAN_MODE_INTERLACE)
-				data32 = ((osd_hw.dispdata[OSD1].y_start >> 1)
-						& 0xfff)
-					| ((((osd_hw.dispdata[OSD1].y_end + 1)
-						>> 1) - 1) & 0xfff) << 16;
-			else
-				data32 = (osd_hw.dispdata[OSD1].y_start & 0xfff)
-					| (osd_hw.dispdata[OSD1].y_end
-						& 0xfff) << 16;
-			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4, data32);
-		}
-	}
-	/* enable osd 2x scale */
+	data32 = (osd_hw.dispdata[OSD1].x_start & 0xfff)
+		| (osd_hw.dispdata[OSD1].x_end & 0xfff) << 16;
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 , data32);
+	if (osd_hw.scan_mode == SCAN_MODE_INTERLACE)
+		data32 = ((osd_hw.dispdata[OSD1].y_start >> 1) & 0xfff)
+			| ((((osd_hw.dispdata[OSD1].y_end + 1)
+			>> 1) - 1) & 0xfff) << 16;
+	else
+		data32 = (osd_hw.dispdata[OSD1].y_start & 0xfff)
+			| (osd_hw.dispdata[OSD1].y_end
+			& 0xfff) << 16;
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4, data32);
+
 	if (osd_hw.osd_afbcd[OSD1].enable)
 		VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_SIZE_IN,
 			((osd_hw.osd_afbcd[OSD1].frame_width
@@ -3362,109 +3051,42 @@ static void osd1_basic_update_disp_geometry(void)
 			((osd_hw.osd_afbcd[OSD1].frame_height
 			& 0xffff) << 0));
 
+	/* enable osd 2x scale */
 	if (osd_hw.scale[OSD1].h_enable || osd_hw.scale[OSD1].v_enable) {
 		osd1_2x_scale_update_geometry();
 	} else if (osd_hw.free_scale_enable[OSD1]
-		   && (osd_hw.free_scale_data[OSD1].x_end > 0)
-		   && (osd_hw.free_scale_data[OSD1].y_end > 0)
-		   && (!osd_hw.rotate[OSD1].on_off)) {
+		   && (osd_hw.free_src_data[OSD1].x_end > 0)
+		   && (osd_hw.free_src_data[OSD1].y_end > 0)) {
 		/* enable osd free scale */
-		data32 = (osd_hw.free_scale_data[OSD1].x_start & 0x1fff) |
-			 (osd_hw.free_scale_data[OSD1].x_end & 0x1fff) << 16;
+		data32 = (osd_hw.free_src_data[OSD1].x_start & 0x1fff) |
+			 (osd_hw.free_src_data[OSD1].x_end & 0x1fff) << 16;
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
 		if (osd_hw.osd_afbcd[OSD1].enable) {
 			data32 =
-				(osd_hw.free_scale_data[OSD1].x_end & 0x1fff) |
-				(osd_hw.free_scale_data[OSD1].x_start & 0x1fff)
+				(osd_hw.free_src_data[OSD1].x_end & 0x1fff) |
+				(osd_hw.free_src_data[OSD1].x_start & 0x1fff)
 				<< 16;
 			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_HSCOPE, data32);
 			data32 =
-				(osd_hw.free_scale_data[OSD1].y_end & 0x1fff) |
-				(osd_hw.free_scale_data[OSD1].y_start & 0x1fff)
+				(osd_hw.free_src_data[OSD1].y_end & 0x1fff) |
+				(osd_hw.free_src_data[OSD1].y_start & 0x1fff)
 				<< 16;
 			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_VSCOPE, data32);
 			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_HDR_PTR,
 				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
 			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_FRAME_PTR,
 				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG_BITS(
-				OSD1_AFBCD_CHROMA_PTR,
-				(osd_hw.osd_afbcd[OSD1].phy_addr & 0xffffff),
-				0, 24);
-		}
-		data32 = ((osd_hw.free_scale_data[OSD1].y_start
-				+ osd_hw.pandata[OSD1].y_start) & 0x1fff)
-			 | ((osd_hw.free_scale_data[OSD1].y_end
-				+ osd_hw.pandata[OSD1].y_start) & 0x1fff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2, data32);
-	} else if (osd_hw.free_scale_enable[OSD1]
-		   && (osd_hw.free_scale_data[OSD1].x_end > 0)
-		   && (osd_hw.free_scale_data[OSD1].y_end > 0)
-		   && (osd_hw.rotate[OSD1].on_off
-			   && osd_hw.rotate[OSD1].angle > 0)) {
-		data32 = (osd_hw.rotation_pandata[OSD1].x_start & 0x1fff) |
-			 (osd_hw.rotation_pandata[OSD1].x_end & 0x1fff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
-		if (osd_hw.osd_afbcd[OSD1].enable) {
-			data32 = (osd_hw.rotation_pandata[OSD1].x_end
-					& 0x1fff) |
-					(osd_hw.rotation_pandata[OSD1].x_start
-					& 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_HSCOPE, data32);
-			data32 = (osd_hw.rotation_pandata[OSD1].y_end
-				& 0x1fff) |
-				(osd_hw.rotation_pandata[OSD1].y_start
-				& 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_VSCOPE, data32);
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_HDR_PTR,
-				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_FRAME_PTR,
-				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG_BITS(
-				OSD1_AFBCD_CHROMA_PTR,
-				(osd_hw.osd_afbcd[OSD1].phy_addr & 0xffffff),
-				0, 24);
-		}
-		data32 = ((osd_hw.rotation_pandata[OSD1].y_start
-				+ osd_hw.pandata[OSD1].y_start) & 0x1fff)
-			 | ((osd_hw.rotation_pandata[OSD1].y_end
-				+ osd_hw.pandata[OSD1].y_start) & 0x1fff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2, data32);
-		if (is_meson_m8_cpu())
-			VSYNCOSD_WR_MPEG_REG(VPU_PROT1_Y_START_END, data32);
-	} else if (osd_hw.rotate[OSD1].on_off
-		   && osd_hw.rotate[OSD1].angle > 0) {
-		/* enable osd rotation */
-		data32 = (osd_hw.rotation_pandata[OSD1].x_start & 0x1fff) |
-			 (osd_hw.rotation_pandata[OSD1].x_end & 0x1fff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
-		if (osd_hw.osd_afbcd[OSD1].enable) {
-			data32 = (osd_hw.rotation_pandata[OSD1].x_end
-					& 0x1fff) |
-					(osd_hw.rotation_pandata[OSD1].x_start
-					& 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_HSCOPE, data32);
-			data32 = (osd_hw.rotation_pandata[OSD1].y_end
-				& 0x1fff) |
-				(osd_hw.rotation_pandata[OSD1].y_start
-				& 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_PIXEL_VSCOPE, data32);
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_HDR_PTR,
-				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_FRAME_PTR,
-				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG_BITS(
+			data32 = (0xe4 << 24) |
+				(osd_hw.osd_afbcd[OSD1].phy_addr & 0xffffff);
+			VSYNCOSD_WR_MPEG_REG(
 				OSD1_AFBCD_CHROMA_PTR,
-				(osd_hw.osd_afbcd[OSD1].phy_addr & 0xffffff),
-				0, 24);
+				data32);
 		}
-		data32 = ((osd_hw.rotation_pandata[OSD1].y_start
-				+ osd_hw.pandata[OSD1].y_start) & 0x1fff)
-			 | ((osd_hw.rotation_pandata[OSD1].y_end
-				+ osd_hw.pandata[OSD1].y_start) & 0x1fff) << 16;
+		data32 = ((osd_hw.free_src_data[OSD1].y_start
+			+ osd_hw.pandata[OSD1].y_start) & 0x1fff)
+			| ((osd_hw.free_src_data[OSD1].y_end
+			+ osd_hw.pandata[OSD1].y_start) & 0x1fff) << 16;
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2, data32);
-		if (is_meson_m8_cpu())
-			VSYNCOSD_WR_MPEG_REG(VPU_PROT1_Y_START_END, data32);
 	} else {
 		/* normal mode */
 		data32 = (osd_hw.pandata[OSD1].x_start & 0x1fff)
@@ -3486,10 +3108,11 @@ static void osd1_basic_update_disp_geometry(void)
 				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
 			VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_FRAME_PTR,
 				osd_hw.osd_afbcd[OSD1].phy_addr >> 4);
-			VSYNCOSD_WR_MPEG_REG_BITS(
+			data32 = (0xe4 << 24) |
+				(osd_hw.osd_afbcd[OSD1].phy_addr & 0xffffff);
+			VSYNCOSD_WR_MPEG_REG(
 				OSD1_AFBCD_CHROMA_PTR,
-				(osd_hw.osd_afbcd[OSD1].phy_addr & 0xffffff),
-				0, 24);
+				data32);
 		}
 		data32 = (osd_hw.pandata[OSD1].y_start & 0x1fff)
 			| (osd_hw.pandata[OSD1].y_end & 0x1fff) << 16;
@@ -3499,27 +3122,30 @@ static void osd1_basic_update_disp_geometry(void)
 	if (osd_hw.osd_afbcd[OSD1].enable &&
 		!osd_afbc_dec_enable &&
 		osd_hw.osd_afbcd[OSD1].phy_addr != 0) {
-		VSYNCOSD_WR_MPEG_REG_BITS(OSD1_AFBCD_ENABLE, 1, 8, 1);
-		osd_afbc_dec_enable = true;
+		VSYNCOSD_WR_MPEG_REG(OSD1_AFBCD_ENABLE, 0x8100);
+		osd_afbc_dec_enable = 1;
 	}
 	data32 = VSYNCOSD_RD_MPEG_REG(VIU_OSD1_CTRL_STAT);
-	data32 &= 0xfffffff0;
-	data32 |= HW_OSD_BLOCK_ENABLE_0;
+	data32 &= ~0x1ff00e;
+	data32 |= osd_hw.gbl_alpha[OSD1] << 12;
+	/* data32 |= HW_OSD_BLOCK_ENABLE_0; */
 	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_CTRL_STAT, data32);
 }
 
 static void osd1_update_disp_geometry(void)
 {
-	u32 data32;
-
 	if ((osd_hw.block_mode[OSD1]) &&
 		(get_cpu_type() <= MESON_CPU_MAJOR_ID_GXBB)) {
 		/* multi block */
+		/*
 		osd_block_update_disp_geometry(OSD1);
 		data32 = VSYNCOSD_RD_MPEG_REG(VIU_OSD1_CTRL_STAT);
 		data32 &= 0xfffffff0;
 		data32 |= (osd_hw.block_mode[OSD1] & HW_OSD_BLOCK_ENABLE_MASK);
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_CTRL_STAT, data32);
+		*/
+		osd_log_info(
+			"osd1_update_disp_geometry: not support block mode\n");
 	} else {
 		/* single block */
 		osd1_basic_update_disp_geometry();
@@ -3562,16 +3188,16 @@ static void osd2_update_disp_geometry(void)
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2, data32);
 #endif
 	} else if (osd_hw.free_scale_enable[OSD2]
-		   && (osd_hw.free_scale_data[OSD2].x_end > 0)
-		   && (osd_hw.free_scale_data[OSD2].y_end > 0)) {
+		   && (osd_hw.free_src_data[OSD2].x_end > 0)
+		   && (osd_hw.free_src_data[OSD2].y_end > 0)) {
 		/* enable osd free scale */
-		data32 = (osd_hw.free_scale_data[OSD2].x_start & 0x1fff)
-			| (osd_hw.free_scale_data[OSD2].x_end & 0x1fff) << 16;
+		data32 = (osd_hw.free_src_data[OSD2].x_start & 0x1fff)
+			| (osd_hw.free_src_data[OSD2].x_end & 0x1fff) << 16;
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
-		data32 = ((osd_hw.free_scale_data[OSD2].y_start
-				+ osd_hw.pandata[OSD2].y_start) & 0x1fff)
-			 | ((osd_hw.free_scale_data[OSD2].y_end
-				+ osd_hw.pandata[OSD2].y_start) & 0x1fff) << 16;
+		data32 = ((osd_hw.free_src_data[OSD2].y_start
+			+ osd_hw.pandata[OSD2].y_start) & 0x1fff)
+			| ((osd_hw.free_src_data[OSD2].y_end
+			+ osd_hw.pandata[OSD2].y_start) & 0x1fff) << 16;
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2, data32);
 	} else {
 		data32 = (osd_hw.pandata[OSD2].x_start & 0x1fff)
@@ -3581,8 +3207,14 @@ static void osd2_update_disp_geometry(void)
 			| (osd_hw.pandata[OSD2].y_end & 0x1fff) << 16;
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2, data32);
 	}
+	data32 = VSYNCOSD_RD_MPEG_REG(VIU_OSD2_CTRL_STAT);
+	data32 &= ~0x1ff000;
+	data32 |= osd_hw.gbl_alpha[OSD2] << 12;
+	/* data32 |= HW_OSD_BLOCK_ENABLE_0; */
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_CTRL_STAT, data32);
 	remove_from_update_list(OSD2, DISP_GEOMETRY);
 }
+
 static void osd1_update_disp_3d_mode(void)
 {
 	/*step 1 . set pan data */
@@ -3615,6 +3247,54 @@ static void osd2_update_disp_3d_mode(void)
 	osd_hw.mode_3d[OSD2].left_right ^= 1;
 }
 
+static void osd1_update_fifo(void)
+{
+	u32 data32;
+	data32 = osd_hw.urgent[OSD1] & 1;
+	data32 |= 4 << 5; /* hold_fifo_lines */
+	/* burst_len_sel: 3=64 */
+	data32 |= 3  << 10;
+	/* fifo_depth_val: 32*8=256 */
+	data32 |= 32 << 12;
+	/* if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) */
+	/*
+	 * bit 23:22, fifo_ctrl
+	 * 00 : for 1 word in 1 burst
+	 * 01 : for 2 words in 1 burst
+	 * 10 : for 4 words in 1 burst
+	 * 11 : reserved
+	*/
+	data32 |= 2 << 22;
+	/* bit 28:24, fifo_lim */
+	data32 |= 2 << 24;
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_FIFO_CTRL_STAT, data32);
+	remove_from_update_list(OSD1, OSD_FIFO);
+}
+
+static void osd2_update_fifo(void)
+{
+	u32 data32;
+	data32 = osd_hw.urgent[OSD2] & 1;
+	data32 |= 4 << 5; /* hold_fifo_lines */
+	/* burst_len_sel: 3=64 */
+	data32 |= 3  << 10;
+	/* fifo_depth_val: 32*8=256 */
+	data32 |= 32 << 12;
+	/* if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) */
+	/*
+	 * bit 23:22, fifo_ctrl
+	 * 00 : for 1 word in 1 burst
+	 * 01 : for 2 words in 1 burst
+	 * 10 : for 4 words in 1 burst
+	 * 11 : reserved
+	*/
+	data32 |= 2 << 22;
+	/* bit 28:24, fifo_lim */
+	data32 |= 2 << 24;
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_FIFO_CTRL_STAT, data32);
+	remove_from_update_list(OSD2, OSD_FIFO);
+}
+
 void osd_init_scan_mode(void)
 {
 #define	VOUT_ENCI	1
@@ -3638,17 +3318,32 @@ void osd_init_scan_mode(void)
 void osd_init_hw(u32 logo_loaded)
 {
 	u32 group, idx, data32;
+	osd_vpu_power_on();
 
+	if (get_cpu_type() ==
+		MESON_CPU_MAJOR_ID_GXTVBB)
+		backup_regs_init(HW_RESET_AFBCD_REGS);
+	else if (get_cpu_type() ==
+		MESON_CPU_MAJOR_ID_GXM)
+		backup_regs_init(HW_RESET_OSD1_REGS);
+	else if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)
+		&& (get_cpu_type() <= MESON_CPU_MAJOR_ID_TXL))
+		backup_regs_init(HW_RESET_OSD1_REGS);
+	else
+		backup_regs_init(HW_RESET_NONE);
+
+	recovery_regs_init();
 	for (group = 0; group < HW_OSD_COUNT; group++)
 		for (idx = 0; idx < HW_REG_INDEX_MAX; idx++)
 			osd_hw.reg[group][idx].update_func =
 				hw_func_array[group][idx];
 	osd_hw.updated[OSD1] = 0;
 	osd_hw.updated[OSD2] = 0;
-	osd_hdr_on = false;
-	osd_reset_status = 0;
+	osd_hw.urgent[OSD1] = 1;
+	osd_hw.urgent[OSD2] = 1;
 
-	osd_vpu_power_on();
+	osd_hdr_on = false;
+	osd_hw.hw_reset_flag = HW_RESET_NONE;
 
 	/* here we will init default value ,these value only set once . */
 	if ((get_cpu_type() == MESON_CPU_MAJOR_ID_M6TV)
@@ -3697,6 +3392,11 @@ void osd_init_hw(u32 logo_loaded)
 		osd_reg_write(VIU_OSD2_FIFO_CTRL_STAT, data32);
 		osd_reg_set_mask(VPP_MISC, VPP_POSTBLEND_EN);
 		osd_reg_clr_mask(VPP_MISC, VPP_PREBLEND_EN);
+		osd_vpp_misc =
+			osd_reg_read(VPP_MISC) & OSD_RELATIVE_BITS;
+		osd_vpp_misc &=
+			~(VPP_OSD1_POSTBLEND | VPP_OSD2_POSTBLEND);
+		notify_to_amvideo();
 		osd_reg_clr_mask(VPP_MISC,
 			VPP_OSD1_POSTBLEND | VPP_OSD2_POSTBLEND);
 		/* just disable osd to avoid booting hang up */
@@ -3709,20 +3409,32 @@ void osd_init_hw(u32 logo_loaded)
 		osd_reg_write(VIU_OSD1_CTRL_STAT , data32);
 		osd_reg_write(VIU_OSD2_CTRL_STAT , data32);
 	}
+	osd_vpp_misc =
+		osd_reg_read(VPP_MISC) & OSD_RELATIVE_BITS;
 #if defined(CONFIG_FB_OSD2_CURSOR)
+	osd_vpp_misc |= (VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+	notify_to_amvideo();
 	osd_reg_set_mask(VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
 	osd_hw.order = OSD_ORDER_10;
 #else
+	osd_vpp_misc &= ~(VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+	notify_to_amvideo();
 	osd_reg_clr_mask(VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
 	osd_hw.order = OSD_ORDER_01;
 #endif
 	osd_hw.enable[OSD2] = osd_hw.enable[OSD1] = DISABLE;
 	osd_hw.fb_gem[OSD1].canvas_idx = OSD1_CANVAS_INDEX;
 	osd_hw.fb_gem[OSD2].canvas_idx = OSD2_CANVAS_INDEX;
+	osd_hw.fb_gem[OSD1].xres = 0;
+	osd_hw.fb_gem[OSD1].yres = 0;
+	osd_hw.fb_gem[OSD2].xres = 0;
+	osd_hw.fb_gem[OSD2].yres = 0;
 	osd_hw.gbl_alpha[OSD1] = OSD_GLOBAL_ALPHA_DEF;
 	osd_hw.gbl_alpha[OSD2] = OSD_GLOBAL_ALPHA_DEF;
 	osd_hw.color_info[OSD1] = NULL;
 	osd_hw.color_info[OSD2] = NULL;
+	osd_hw.color_backup[OSD1] = NULL;
+	osd_hw.color_backup[OSD2] = NULL;
 	osd_hw.color_key[OSD1] = osd_hw.color_key[OSD2] = 0xffffffff;
 	osd_hw.free_scale_enable[OSD1] = osd_hw.free_scale_enable[OSD2] = 0;
 	osd_hw.scale[OSD1].h_enable = osd_hw.scale[OSD1].v_enable = 0;
@@ -3733,37 +3445,42 @@ void osd_init_hw(u32 logo_loaded)
 	osd_hw.free_scale[OSD1].h_enable = 0;
 	osd_hw.free_scale[OSD2].v_enable = 0;
 	osd_hw.free_scale[OSD2].v_enable = 0;
-	osd_hw.osd_reverse[OSD1] = osd_hw.osd_reverse[OSD2] = 0;
+	osd_hw.osd_reverse[OSD1] = REVERSE_FALSE;
+	osd_hw.osd_reverse[OSD2] = REVERSE_FALSE;
+	/*
 	osd_hw.rotation_pandata[OSD1].x_start = 0;
 	osd_hw.rotation_pandata[OSD1].y_start = 0;
 	osd_hw.rotation_pandata[OSD2].x_start = 0;
 	osd_hw.rotation_pandata[OSD2].y_start = 0;
+	*/
 	osd_hw.antiflicker_mode = 0;
+	osd_hw.color_key_enable[OSD1] = 0;
+	osd_hw.color_key_enable[OSD2] = 0;
 	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_M8) {
-		osd_hw.free_scale_data[OSD1].x_start = 0;
-		osd_hw.free_scale_data[OSD1].x_end = 0;
-		osd_hw.free_scale_data[OSD1].y_start = 0;
-		osd_hw.free_scale_data[OSD1].y_end = 0;
-		osd_hw.free_scale_data[OSD2].x_start = 0;
-		osd_hw.free_scale_data[OSD2].x_end = 0;
-		osd_hw.free_scale_data[OSD2].y_start = 0;
-		osd_hw.free_scale_data[OSD2].y_end = 0;
+		osd_hw.free_src_data[OSD1].x_start = 0;
+		osd_hw.free_src_data[OSD1].x_end = 0;
+		osd_hw.free_src_data[OSD1].y_start = 0;
+		osd_hw.free_src_data[OSD1].y_end = 0;
+		osd_hw.free_src_data[OSD2].x_start = 0;
+		osd_hw.free_src_data[OSD2].x_end = 0;
+		osd_hw.free_src_data[OSD2].y_start = 0;
+		osd_hw.free_src_data[OSD2].y_end = 0;
 		osd_hw.free_scale_mode[OSD1] = 0;
 		osd_hw.free_scale_mode[OSD2] = 1;
 		if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)
-			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x00202000);
+			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x002020ff);
 		else if (get_cpu_type() ==
 			MESON_CPU_MAJOR_ID_GXTVBB)
 			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0xff);
 		else
-			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x00808000);
+			osd_reg_write(VPP_OSD_SC_DUMMY_DATA, 0x008080ff);
 	} else {
 		osd_hw.free_scale_mode[OSD1] = 0;
 		osd_hw.free_scale_mode[OSD2] = 0;
 	}
-	/*osd_hw.osd_afbcd[OSD1].enable = 0;
-	osd_hw.osd_afbcd[OSD2].enable = 0;*/
-	memset(osd_hw.rotate, 0, sizeof(struct osd_rotate_s));
+	/* osd_hw.osd_afbcd[OSD1].enable = 0;
+		osd_hw.osd_afbcd[OSD2].enable = 0; */
+	/* memset(osd_hw.rotate, 0, sizeof(struct osd_rotate_s)); */
 
 #ifdef CONFIG_FB_OSD_SUPPORT_SYNC_FENCE
 	INIT_LIST_HEAD(&post_fence_list);
@@ -3817,30 +3534,12 @@ void osd_cursor_hw(u32 index, s16 x, s16 y, s16 xstart, s16 ystart, u32 osd_w,
 	    && (osd_hw.scaledata[OSD2].x_end > 0)) {
 		x = x * osd_hw.scaledata[OSD2].x_end /
 			osd_hw.scaledata[OSD2].x_start;
-		if (osd_hw.scaledata[OSD2].x_end >
-				osd_hw.scaledata[OSD2].x_start) {
-			disp_tmp.x_start = osd_hw.dispdata[OSD1].x_start *
-				osd_hw.scaledata[OSD2].x_end /
-				osd_hw.scaledata[OSD2].x_start;
-			disp_tmp.x_end = osd_hw.dispdata[OSD1].x_end *
-				osd_hw.scaledata[OSD2].x_end /
-				osd_hw.scaledata[OSD2].x_start;
-		}
 	}
 	if (osd_hw.scale[OSD2].v_enable && (osd_hw.scaledata[OSD2].y_start > 0)
 	    && (osd_hw.scaledata[OSD2].y_end > 0)) {
 		y = y * osd_hw.scaledata[OSD2].y_end /
 			osd_hw.scaledata[OSD2].y_start;
-		if (osd_hw.scaledata[OSD2].y_end >
-				osd_hw.scaledata[OSD2].y_start) {
-			disp_tmp.y_start = osd_hw.dispdata[OSD1].y_start *
-				osd_hw.scaledata[OSD2].y_end /
-				osd_hw.scaledata[OSD2].y_start;
-			disp_tmp.y_end = osd_hw.dispdata[OSD1].y_end *
-				osd_hw.scaledata[OSD2].y_end /
-					 osd_hw.scaledata[OSD2].y_start;
 		}
-	}
 	x += xstart;
 	y += ystart;
 	/*
@@ -3896,6 +3595,8 @@ void osd_cursor_hw(u32 index, s16 x, s16 y, s16 xstart, s16 ystart, u32 osd_w,
 void  osd_suspend_hw(void)
 {
 	osd_hw.reg_status_save = osd_reg_read(VPP_MISC) & OSD_RELATIVE_BITS;
+	osd_vpp_misc &= ~OSD_RELATIVE_BITS;
+	notify_to_amvideo();
 	osd_reg_clr_mask(VPP_MISC, OSD_RELATIVE_BITS);
 	/* VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, OSD_RELATIVE_BITS); */
 	osd_log_info("osd_suspended\n");
@@ -3904,12 +3605,29 @@ void  osd_suspend_hw(void)
 
 void osd_resume_hw(void)
 {
+	if (osd_hw.reg_status_save &
+		(VPP_OSD1_POSTBLEND | VPP_OSD2_POSTBLEND))
+		osd_hw.reg_status_save |= VPP_POSTBLEND_EN;
+	osd_vpp_misc = osd_hw.reg_status_save & OSD_RELATIVE_BITS;
+	notify_to_amvideo();
 	osd_reg_set_mask(VPP_MISC, osd_hw.reg_status_save);
 	/* VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC, osd_hw.reg_status_save); */
 	osd_log_info("osd_resumed\n");
 	return;
 }
 
+void osd_shutdown_hw(void)
+{
+#ifdef CONFIG_VSYNC_RDMA
+	enable_rdma(0);
+#endif
+#ifdef CONFIG_FB_OSD_VSYNC_RDMA
+	osd_rdma_enable(0);
+#endif
+	pr_info("osd_shutdown\n");
+	return;
+}
+
 #ifdef CONFIG_HIBERNATION
 static unsigned int fb0_cfg_w0_save;
 static u32 __nosavedata free_scale_enable[HW_OSD_COUNT];
@@ -3933,17 +3651,21 @@ void  osd_freeze_hw(void)
 #endif
 #ifdef CONFIG_FB_OSD_VSYNC_RDMA
 	osd_rdma_enable(0);
-#endif
+	if (get_backup_reg(VIU_OSD1_BLK0_CFG_W0,
+		&fb0_cfg_w0_save) != 0)
+		fb0_cfg_w0_save =
+			osd_reg_read(VIU_OSD1_BLK0_CFG_W0);
+#else
 	fb0_cfg_w0_save = osd_reg_read(VIU_OSD1_BLK0_CFG_W0);
+#endif
 	pr_debug("osd_freezed\n");
-
 	return;
 }
 void osd_thaw_hw(void)
 {
 	pr_debug("osd_thawed\n");
 #ifdef CONFIG_FB_OSD_VSYNC_RDMA
-	osd_rdma_enable(1);
+	osd_rdma_enable(2);
 #endif
 #ifdef CONFIG_VSYNC_RDMA
 	enable_rdma(1);
@@ -3954,7 +3676,7 @@ void osd_restore_hw(void)
 {
 	osd_reg_write(VIU_OSD1_BLK0_CFG_W0, fb0_cfg_w0_save);
 #ifdef CONFIG_FB_OSD_VSYNC_RDMA
-	osd_rdma_enable(1);
+	osd_rdma_enable(2);
 #endif
 #ifdef CONFIG_VSYNC_RDMA
 	enable_rdma(1);
diff --git a/drivers/amlogic/display/osd/osd_hw.h b/drivers/amlogic/display/osd/osd_hw.h
index a46edf4..bf73f58 100644
--- a/drivers/amlogic/display/osd/osd_hw.h
+++ b/drivers/amlogic/display/osd/osd_hw.h
@@ -19,19 +19,14 @@
 #define _OSD_HW_H_
 
 #include "osd.h"
+#include "osd_sync.h"
 
 #define REG_OFFSET (0x20)
-#define OSD_RELATIVE_BITS 0x33370
+#define OSD_RELATIVE_BITS 0x33330
 #ifdef CONFIG_FB_OSD_VSYNC_RDMA
 #include "osd_rdma.h"
 #endif
 
-#define OSD_REG_BACKUP_COUNT 15
-#define OSD_AFBC_REG_BACKUP_COUNT 10
-
-extern const u16 osd_reg_backup[OSD_REG_BACKUP_COUNT];
-extern const u16 osd_afbc_reg_backup[OSD_AFBC_REG_BACKUP_COUNT];
-
 #ifdef CONFIG_HIBERNATION
 extern void osd_freeze_hw(void);
 extern void osd_thaw_hw(void);
@@ -78,9 +73,7 @@ extern void osd_set_free_scale_mode_hw(u32 index, u32 freescale_mode);
 extern void osd_get_free_scale_mode_hw(u32 index, u32 *freescale_mode);
 extern void osd_set_4k2k_fb_mode_hw(u32 fb_for_4k2k);
 extern void osd_get_free_scale_mode_hw(u32 index, u32 *freescale_mode);
-extern void osd_set_free_scale_width_hw(u32 index, u32 width);
 extern void osd_get_free_scale_width_hw(u32 index, u32 *free_scale_width);
-extern void osd_set_free_scale_height_hw(u32 index, u32 height);
 extern void osd_get_free_scale_height_hw(u32 index, u32 *free_scale_height);
 extern void osd_get_free_scale_axis_hw(u32 index, s32 *x0, s32 *y0, s32 *x1,
 				       s32 *y1);
@@ -102,24 +95,14 @@ extern void osd_set_2x_scale_hw(u32 index, u16 h_scale_enable,
 extern void osd_get_flush_rate_hw(u32 *break_rate);
 extern void osd_set_reverse_hw(u32 index, u32 reverse);
 extern void osd_get_reverse_hw(u32 index, u32 *reverse);
-extern void osd_set_rotate_on_hw(u32 index, u32 on_off);
-extern void osd_get_rotate_on_hw(u32 index, u32 *on_off);
 extern void osd_set_antiflicker_hw(u32 index, u32 vmode, u32 yres);
 extern void osd_get_antiflicker_hw(u32 index, u32 *on_off);
-extern void osd_set_update_state_hw(u32 index, u32 up_free);
-extern void osd_get_update_state_hw(u32 index, u32 *up_free);
 extern void osd_get_angle_hw(u32 index, u32 *angle);
 extern void osd_set_angle_hw(u32 index, u32 angle, u32  virtual_osd1_yres,
 			     u32 virtual_osd2_yres);
 extern void osd_get_clone_hw(u32 index, u32 *clone);
 extern void osd_set_clone_hw(u32 index, u32 clone);
 extern void osd_set_update_pan_hw(u32 index);
-extern void osd_set_rotate_angle_hw(u32 index, u32 angle);
-extern void osd_get_rotate_angle_hw(u32 index, u32 *angle);
-extern void osd_get_prot_canvas_hw(u32 index, s32 *x_start, s32 *y_start,
-				   s32 *x_end, s32 *y_end);
-extern void osd_set_prot_canvas_hw(u32 index, s32 x_start, s32 y_start,
-				   s32 x_end, s32 y_end);
 extern void osd_setpal_hw(u32 index, unsigned regno, unsigned red,
 			  unsigned green, unsigned blue, unsigned transp);
 extern void osd_enable_hw(u32 index, u32 enable);
@@ -127,6 +110,9 @@ extern void osd_pan_display_hw(u32 index, unsigned int xoffset,
 			       unsigned int yoffset);
 extern int osd_sync_request(u32 index, u32 yres, u32 xoffset, u32 yoffset,
 			    s32 in_fence_fd);
+extern int osd_sync_request_render(u32 index, u32 yres,
+	struct fb_sync_request_render_s *request,
+	u32 phys_addr);
 extern s32  osd_wait_vsync_event(void);
 #if defined(CONFIG_FB_OSD2_CURSOR)
 extern void osd_cursor_hw(u32 index, s16 x, s16 y, s16 xstart, s16 ystart,
@@ -135,6 +121,7 @@ extern void osd_cursor_hw(u32 index, s16 x, s16 y, s16 xstart, s16 ystart,
 extern void osd_init_scan_mode(void);
 extern void osd_suspend_hw(void);
 extern void osd_resume_hw(void);
+extern void osd_shutdown_hw(void);
 extern void osd_init_hw(u32 logo_loaded);
 extern void osd_init_scan_mode(void);
 extern void osd_set_logo_index(int index);
@@ -157,4 +144,6 @@ extern u32 osd_get_reset_status(void);
 extern void osd_switch_free_scale(
 	u32 pre_index, u32 pre_enable, u32 pre_scale,
 	u32 next_index, u32 next_enable, u32 next_scale);
+extern void osd_get_urgent(u32 index, u32 *urgent);
+extern void osd_set_urgent(u32 index, u32 urgent);
 #endif
diff --git a/drivers/amlogic/display/osd/osd_hw_def.h b/drivers/amlogic/display/osd/osd_hw_def.h
index 54b7886..ac2beb9 100644
--- a/drivers/amlogic/display/osd/osd_hw_def.h
+++ b/drivers/amlogic/display/osd/osd_hw_def.h
@@ -34,6 +34,7 @@ static void osd1_update_disp_osd_reverse(void);
 static void osd1_update_disp_osd_rotate(void);
 static void osd1_update_disp_scale_enable(void);
 static void osd1_update_disp_3d_mode(void);
+static void osd1_update_fifo(void);
 
 static void osd2_update_color_mode(void);
 static void osd2_update_enable(void);
@@ -48,6 +49,7 @@ static void osd2_update_disp_osd_reverse(void);
 static void osd2_update_disp_osd_rotate(void);
 static void osd2_update_disp_scale_enable(void);
 static void osd2_update_disp_3d_mode(void);
+static void osd2_update_fifo(void);
 
 LIST_HEAD(update_list);
 static DEFINE_SPINLOCK(osd_lock);
@@ -69,6 +71,7 @@ static update_func_t hw_func_array[HW_OSD_COUNT][HW_REG_INDEX_MAX] = {
 		osd1_update_disp_freescale_enable,
 		osd1_update_disp_osd_reverse,
 		osd1_update_disp_osd_rotate,
+		osd1_update_fifo,
 	},
 	{
 		osd2_update_color_mode,
@@ -83,6 +86,7 @@ static update_func_t hw_func_array[HW_OSD_COUNT][HW_REG_INDEX_MAX] = {
 		osd2_update_disp_freescale_enable,
 		osd2_update_disp_osd_reverse,
 		osd2_update_disp_osd_rotate,
+		osd2_update_fifo,
 	},
 };
 
diff --git a/drivers/amlogic/display/osd/osd_io.h b/drivers/amlogic/display/osd/osd_io.h
index 280230e..98580c2 100644
--- a/drivers/amlogic/display/osd/osd_io.h
+++ b/drivers/amlogic/display/osd/osd_io.h
@@ -22,6 +22,7 @@
 #include <linux/amlogic/iomap.h>
 
 #include "osd_log.h"
+#include "osd_backup.h"
 
 static inline uint32_t osd_cbus_read(uint32_t reg)
 {
@@ -48,6 +49,8 @@ static inline uint32_t osd_reg_read(uint32_t reg)
 {
 	uint32_t ret = 0;
 
+	/* if (get_backup_reg(reg, &ret) != 0) */
+	/* not read from bakcup */
 	ret = (uint32_t)aml_read_vcbus(reg);
 	osd_log_dbg3("%s(0x%x)=0x%x\n", __func__, reg, ret);
 
@@ -58,6 +61,7 @@ static inline void osd_reg_write(uint32_t reg,
 				 const uint32_t val)
 {
 	aml_write_vcbus(reg, val);
+	update_backup_reg(reg, val);
 	osd_log_dbg3("%s(0x%x, 0x%x)\n", __func__, reg, val);
 };
 
@@ -91,11 +95,6 @@ int VSYNCOSD_SET_MPEG_REG_MASK(u32 reg, u32 mask);
 int VSYNCOSD_CLR_MPEG_REG_MASK(u32 reg, u32 mask);
 
 int VSYNCOSD_IRQ_WR_MPEG_REG(u32 reg, u32 val);
-int VSYNCOSD_IRQ_WR_MPEG_REG_BITS(u32 reg, u32 val, u32 start, u32 len);
-int VSYNCOSD_IRQ_SET_MPEG_REG_MASK(u32 reg, u32 mask);
-int VSYNCOSD_IRQ_CLR_MPEG_REG_MASK(u32 reg, u32 mask);
-/* write to the rdma local buffer and flush into reg buffer at end */
-int VSYNCOSD_EX_WR_MPEG_REG(u32 reg, u32 val);
 #else
 #define VSYNCOSD_RD_MPEG_REG(reg) osd_reg_read(reg)
 #define VSYNCOSD_WR_MPEG_REG(reg, val) osd_reg_write(reg, val)
@@ -105,11 +104,6 @@ int VSYNCOSD_EX_WR_MPEG_REG(u32 reg, u32 val);
 #define VSYNCOSD_CLR_MPEG_REG_MASK(reg, mask) osd_reg_clr_mask(reg, mask)
 
 #define VSYNCOSD_IRQ_WR_MPEG_REG(reg, val) osd_reg_write(reg, val)
-#define VSYNCOSD_IRQ_WR_MPEG_REG_BITS(reg, val, start, len) \
-	osd_reg_set_bits(reg, val, start, len)
-#define VSYNCOSD_IRQ_SET_MPEG_REG_MASK(reg, mask) osd_reg_set_mask(reg, mask)
-#define VSYNCOSD_IRQ_CLR_MPEG_REG_MASK(reg, mask) osd_reg_clr_mask(reg, mask)
-#define VSYNCOSD_EX_WR_MPEG_REG(reg, val) osd_reg_write(reg, val)
 #endif
 
 #endif
diff --git a/drivers/amlogic/display/osd/osd_rdma.c b/drivers/amlogic/display/osd/osd_rdma.c
index 520f6a8..52f874c 100644
--- a/drivers/amlogic/display/osd/osd_rdma.c
+++ b/drivers/amlogic/display/osd/osd_rdma.c
@@ -40,12 +40,22 @@
 #include "osd_reg.h"
 #include "osd_rdma.h"
 #include "osd_hw.h"
+#include "osd_backup.h"
+#ifdef CONFIG_AML_RDMA
+#include <linux/amlogic/rdma/rdma_mgr.h>
+#ifdef CONFIG_AM_VECM
+#include <linux/amlogic/amvecm/ve.h>
+#endif
+#endif
+
+#ifndef CONFIG_AML_RDMA
+#define OSD_RDMA_ISR
+#endif
 
 #define RDMA_TABLE_INTERNAL_COUNT 512
 
 static DEFINE_SPINLOCK(rdma_lock);
 static struct rdma_table_item *rdma_table;
-static struct rdma_table_item *rdma_table_internal;
 static struct device *osd_rdma_dev;
 static struct page *table_pages;
 static void *osd_rdma_table_virt;
@@ -54,17 +64,19 @@ static u32 table_paddr;
 static void *table_vaddr;
 static u32 rdma_enable;
 static u32 item_count;
-static u32 item_count_internal;
 static u32 rdma_debug;
 static bool osd_rdma_init_flag;
-static int ctrl_ahb_rd_burst_size = 3;
-static int ctrl_ahb_wr_burst_size = 3;
 #define OSD_RDMA_UPDATE_RETRY_COUNT 100
 static unsigned int debug_rdma_status;
 static unsigned int rdma_irq_count;
 static unsigned int rdma_lost_count;
 static unsigned int dump_reg_trigger;
+static unsigned int rdma_recovery_count;
+#ifdef OSD_RDMA_ISR
 static unsigned int second_rdma_irq;
+#endif
+
+static int osd_rdma_handle = -1;
 
 static int osd_rdma_init(void);
 
@@ -87,36 +99,10 @@ static inline void osd_rdma_mem_cpy(struct rdma_table_item *dst,
 		: "x5", "x6");
 }
 
-/*once init, will update config in every osd rdma interrupt*/
-int osd_rdma_update_config(char is_init)
-{
-	static u32 config;
-
-	if (is_init) {
-		config  = 0;
-		config |= 1                         << 7;   /* [31: 6] Rsrv.*/
-		config |= 1                         << 6;   /* [31: 6] Rsrv.*/
-		config |= ctrl_ahb_wr_burst_size    <<
-			4;
-		/* [ 5: 4] ctrl_ahb_wr_burst_size. 0=16; 1=24; 2=32; 3=48.*/
-		config |= ctrl_ahb_rd_burst_size    <<
-			2;
-		/* [ 3: 2] ctrl_ahb_rd_burst_size. 0=16; 1=24; 2=32; 3=48.*/
-		config |= 0                         << 1;
-		/* [    1] ctrl_sw_reset.*/
-		config |= 0                         << 0;
-		/* [    0] ctrl_free_clk_enable.*/
-		osd_reg_write(RDMA_CTRL, config);
-	} else {
-		osd_reg_write(RDMA_CTRL, (1<<27)|config);
-	}
-	return 0;
-
-}
-EXPORT_SYMBOL(osd_rdma_update_config);
-
 static inline void reset_rdma_table(void)
 {
+	struct rdma_table_item *temp_tbl = NULL;
+	struct rdma_table_item request_item;
 	unsigned long flags;
 	u32 old_count;
 	u32 end_addr;
@@ -134,31 +120,78 @@ static inline void reset_rdma_table(void)
 
 	spin_lock_irqsave(&rdma_lock, flags);
 	if (!OSD_RDMA_STATUS_IS_REJECT) {
+		u32 val, mask;
+		int iret;
+		if (item_count > 2)
+			temp_tbl = kzalloc(
+				sizeof(struct rdma_table_item)
+				* item_count, GFP_KERNEL);
 		end_addr = osd_reg_read(END_ADDR) + 1;
 		if (end_addr > table_paddr)
 			old_count = (end_addr - table_paddr) >> 3;
 		else
 			old_count = 0;
 		osd_reg_write(END_ADDR, table_paddr - 1);
-		if (old_count < item_count) {
-			for (i = 0; i < item_count - old_count; i++) {
-				if (rdma_table[old_count + i].addr
-					== OSD_RDMA_FLAG_REG)
-					continue;
+
+		for (i = (int)(item_count - 1);
+			i >= 0; i--) {
+			if (!temp_tbl)
+				break;
+			if (rdma_table[i].addr ==
+				OSD_RDMA_FLAG_REG)
+				continue;
+			if (rdma_table[i].addr ==
+				VPP_MISC)
+				continue;
+			iret = get_recovery_item(
+					rdma_table[i].addr,
+					&val, &mask);
+			if (!iret) {
+				request_item.addr =
+					rdma_table[i].addr;
+				request_item.val = val;
 				osd_rdma_mem_cpy(
-					&rdma_table[1 + j],
-					&rdma_table[old_count + i], 8);
+					&temp_tbl[j], &request_item, 8);
 				j++;
+				pr_debug(
+					"recovery -- 0x%04x:0x%08x, mask:0x%08x\n",
+					rdma_table[i].addr,
+					val, mask);
+				rdma_recovery_count++;
+			} else if ((iret < 0) && (i >= old_count)) {
+				request_item.addr =
+					rdma_table[i].addr;
+				request_item.val =
+					rdma_table[i].val;
+				osd_rdma_mem_cpy(
+					&temp_tbl[j], &request_item, 8);
+				j++;
+				pr_debug(
+					"recovery -- 0x%04x:0x%08x, mask:0x%08x\n",
+					rdma_table[i].addr,
+					rdma_table[i].val,
+					mask);
+				pr_debug(
+					"recovery -- i:%d, item_count:%d, old_count:%d\n",
+					i, item_count, old_count);
+				rdma_recovery_count++;
 			}
-			item_count = j + 2;
-		} else {
-			item_count = 2;
 		}
+		for (i = 0; i < j; i++) {
+			osd_rdma_mem_cpy(
+				&rdma_table[1 + i],
+				&temp_tbl[j - i - 1], 8);
+			update_recovery_item(
+				temp_tbl[j - i - 1].addr,
+				temp_tbl[j - i - 1].val);
+		}
+		item_count = j + 2;
 		osd_rdma_mem_cpy(rdma_table, &reset_item[0], 8);
 		osd_rdma_mem_cpy(&rdma_table[item_count - 1],
 			&reset_item[1], 8);
 		osd_reg_write(END_ADDR,
 			(table_paddr + item_count * 8 - 1));
+		kfree(temp_tbl);
 	}
 	spin_unlock_irqrestore(&rdma_lock, flags);
 }
@@ -196,6 +229,8 @@ static int update_table_item(u32 addr, u32 val, u8 irq_mode)
 			&request_item, 8);
 		request_item.addr = addr;
 		request_item.val = val;
+		update_backup_reg(addr, val);
+		update_recovery_item(addr, val);
 		osd_rdma_mem_cpy(
 			&rdma_table[item_count - 1],
 			&request_item, 8);
@@ -232,6 +267,8 @@ static int update_table_item(u32 addr, u32 val, u8 irq_mode)
 	osd_rdma_mem_cpy(&rdma_table[item_count], &request_item, 8);
 	request_item.addr = addr;
 	request_item.val = val;
+	update_backup_reg(addr, val);
+	update_recovery_item(addr, val);
 	osd_rdma_mem_cpy(&rdma_table[item_count - 1], &request_item, 8);
 	item_count++;
 	paddr = table_paddr + item_count * 8 - 1;
@@ -254,29 +291,13 @@ static int update_table_item(u32 addr, u32 val, u8 irq_mode)
 	return ret;
 }
 
-static inline int update_table_item_internal(u32 addr, u32 val)
-{
-	struct rdma_table_item request_item;
-	if (item_count_internal > 500) {
-		/* rdma table is full */
-		pr_info("update_table_item_internal overflow!\n");
-		return -1;
-	}
-	request_item.addr = addr;
-	request_item.val = val;
-	memcpy(
-		&rdma_table_internal[item_count_internal],
-		&request_item, 8);
-	item_count_internal++;
-	return 0;
-}
-
 static inline u32 read_reg_internal(u32 addr)
 {
 	int  i;
 	u32 val = 0;
 	if (rdma_enable) {
-		for (i = (item_count - 1); i >= 0; i--) {
+		for (i = (int)(item_count - 1);
+			i >= 0; i--) {
 			if (addr == rdma_table[i].addr) {
 				val = rdma_table[i].val;
 				break;
@@ -305,12 +326,14 @@ static inline int wrtie_reg_internal(u32 addr, u32 val)
 	/* TODO remove the Done write operation to save the time */
 	request_item.addr = OSD_RDMA_FLAG_REG;
 	request_item.val = OSD_RDMA_STATUS_MARK_TBL_DONE;
-	memcpy(
+	osd_rdma_mem_cpy(
 		&rdma_table[item_count],
 		&request_item, 8);
 	request_item.addr = addr;
 	request_item.val = val;
-	memcpy(
+	update_backup_reg(addr, val);
+	update_recovery_item(addr, val);
+	osd_rdma_mem_cpy(
 		&rdma_table[item_count - 1],
 		&request_item, 8);
 	item_count++;
@@ -320,21 +343,30 @@ static inline int wrtie_reg_internal(u32 addr, u32 val)
 u32 VSYNCOSD_RD_MPEG_REG(u32 addr)
 {
 	int  i;
+	bool find = false;
 	u32 val = 0;
 	unsigned long flags;
 
 	if (rdma_enable) {
 		spin_lock_irqsave(&rdma_lock, flags);
-		for (i = (item_count - 1); i >= 0; i--) {
+		/* 1st, read from rdma table */
+		for (i = (int)(item_count - 1);
+			i >= 0; i--) {
 			if (addr == rdma_table[i].addr) {
 				val = rdma_table[i].val;
 				break;
 			}
 		}
-		spin_unlock_irqrestore(&rdma_lock, flags);
 		if (i >= 0)
+			find = true;
+		else if (get_backup_reg(addr, &val) == 0)
+			find = true;
+		 /* 2nd, read from backup reg */
+		spin_unlock_irqrestore(&rdma_lock, flags);
+		if (find)
 			return val;
 	}
+	/* 3rd, read from osd reg */
 	return osd_reg_read(addr);
 }
 EXPORT_SYMBOL(VSYNCOSD_RD_MPEG_REG);
@@ -407,77 +439,306 @@ int VSYNCOSD_IRQ_WR_MPEG_REG(u32 addr, u32 val)
 }
 EXPORT_SYMBOL(VSYNCOSD_IRQ_WR_MPEG_REG);
 
-int VSYNCOSD_IRQ_WR_MPEG_REG_BITS(u32 addr, u32 val, u32 start, u32 len)
+/* number lines before vsync for reset */
+static unsigned int reset_line;
+module_param(reset_line, uint, 0664);
+MODULE_PARM_DESC(reset_line, "reset_line");
+
+static unsigned int disable_osd_rdma_reset;
+module_param(disable_osd_rdma_reset, uint, 0664);
+MODULE_PARM_DESC(disable_osd_rdma_reset, "disable_osd_rdma_reset");
+
+#ifdef CONFIG_AML_RDMA
+static int osd_reset_rdma_handle = -1;
+
+void set_reset_rdma_trigger_line(void)
 {
-	unsigned long read_val;
-	unsigned long write_val;
-	int ret = 0;
-	if (rdma_enable) {
-		read_val = VSYNCOSD_RD_MPEG_REG(addr);
-		write_val = (read_val & ~(((1L << (len)) - 1) << (start)))
-			    | ((unsigned int)(val) << (start));
-		ret = update_table_item(addr, write_val, 1);
-	} else
-		osd_reg_set_bits(addr, val, start, len);
-	return ret;
+	int trigger_line;
+	switch (aml_read_vcbus(VPU_VIU_VENC_MUX_CTRL) & 0x3) {
+	case 0:
+		trigger_line = aml_read_vcbus(ENCL_VIDEO_VAVON_ELINE)
+			- aml_read_vcbus(ENCL_VIDEO_VSO_BLINE) - reset_line;
+		break;
+	case 1:
+		if ((aml_read_vcbus(ENCI_VIDEO_MODE) & 1) == 0)
+			trigger_line = 260; /* 480i */
+		else
+			trigger_line = 310; /* 576i */
+		break;
+	case 2:
+		if (aml_read_vcbus(ENCP_VIDEO_MODE) & (1 << 12))
+			trigger_line = aml_read_vcbus(ENCP_DE_V_END_EVEN);
+		else
+			trigger_line = aml_read_vcbus(ENCP_VIDEO_VAVON_ELINE)
+				- aml_read_vcbus(ENCP_VIDEO_VSO_BLINE)
+				- reset_line;
+		break;
+	case 3:
+		trigger_line = aml_read_vcbus(ENCT_VIDEO_VAVON_ELINE)
+			- aml_read_vcbus(ENCT_VIDEO_VSO_BLINE) - reset_line;
+		break;
+	}
+	aml_write_vcbus(VPP_INT_LINE_NUM, trigger_line);
 }
-EXPORT_SYMBOL(VSYNCOSD_IRQ_WR_MPEG_REG_BITS);
 
-int VSYNCOSD_IRQ_SET_MPEG_REG_MASK(u32 addr, u32 _mask)
+#ifdef CONFIG_AM_VECM
+static void hdr_restore_osd_csc(void)
 {
-	unsigned long read_val;
-	unsigned long write_val;
-	int ret = 0;
-	if (rdma_enable) {
-		read_val = VSYNCOSD_RD_MPEG_REG(addr);
-		write_val = read_val | _mask;
-		ret = update_table_item(addr, write_val, 1);
-	} else
-		osd_reg_set_mask(addr, _mask);
-	return ret;
+	u32 i = 0;
+	u32 addr_port;
+	u32 data_port;
+	struct hdr_osd_lut_s *lut = &hdr_osd_reg.lut_val;
+
+	if ((osd_reset_rdma_handle == -1)
+		|| disable_osd_rdma_reset)
+		return;
+	/* check osd matrix enable status */
+	if (hdr_osd_reg.viu_osd1_matrix_ctrl & 0x00000001) {
+		/* osd matrix, VPP_MATRIX_0 */
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_MATRIX_PRE_OFFSET0_1,
+			hdr_osd_reg.viu_osd1_matrix_pre_offset0_1);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_MATRIX_PRE_OFFSET2,
+			hdr_osd_reg.viu_osd1_matrix_pre_offset2);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_MATRIX_COEF00_01,
+			hdr_osd_reg.viu_osd1_matrix_coef00_01);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_MATRIX_COEF02_10,
+			hdr_osd_reg.viu_osd1_matrix_coef02_10);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_MATRIX_COEF11_12,
+			hdr_osd_reg.viu_osd1_matrix_coef11_12);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_MATRIX_COEF20_21,
+			hdr_osd_reg.viu_osd1_matrix_coef20_21);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_MATRIX_COEF22_30,
+			hdr_osd_reg.viu_osd1_matrix_coef22_30);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_MATRIX_COEF31_32,
+			hdr_osd_reg.viu_osd1_matrix_coef31_32);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_MATRIX_COEF40_41,
+			hdr_osd_reg.viu_osd1_matrix_coef40_41);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_MATRIX_COLMOD_COEF42,
+			hdr_osd_reg.viu_osd1_matrix_colmod_coef42);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_MATRIX_OFFSET0_1,
+			hdr_osd_reg.viu_osd1_matrix_offset0_1);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_MATRIX_OFFSET2,
+			hdr_osd_reg.viu_osd1_matrix_offset2);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_MATRIX_CTRL,
+			hdr_osd_reg.viu_osd1_matrix_ctrl);
+	}
+	/* restore eotf lut */
+	if ((hdr_osd_reg.viu_osd1_eotf_ctl & 0x80000000) != 0) {
+		addr_port = VIU_OSD1_EOTF_LUT_ADDR_PORT;
+		data_port = VIU_OSD1_EOTF_LUT_DATA_PORT;
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			addr_port, 0);
+		for (i = 0; i < 16; i++)
+			rdma_write_reg(
+				osd_reset_rdma_handle,
+				data_port,
+				lut->r_map[i * 2]
+				| (lut->r_map[i * 2 + 1] << 16));
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			data_port,
+			lut->r_map[EOTF_LUT_SIZE - 1]
+			| (lut->g_map[0] << 16));
+		for (i = 0; i < 16; i++)
+			rdma_write_reg(
+				osd_reset_rdma_handle,
+				data_port,
+				lut->g_map[i * 2 + 1]
+				| (lut->b_map[i * 2 + 2] << 16));
+		for (i = 0; i < 16; i++)
+			rdma_write_reg(
+				osd_reset_rdma_handle,
+				data_port,
+				lut->b_map[i * 2]
+				| (lut->b_map[i * 2 + 1] << 16));
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			data_port, lut->b_map[EOTF_LUT_SIZE - 1]);
+
+		/* load eotf matrix */
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_EOTF_COEF00_01,
+			hdr_osd_reg.viu_osd1_eotf_coef00_01);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_EOTF_COEF02_10,
+			hdr_osd_reg.viu_osd1_eotf_coef02_10);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_EOTF_COEF11_12,
+			hdr_osd_reg.viu_osd1_eotf_coef11_12);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_EOTF_COEF20_21,
+			hdr_osd_reg.viu_osd1_eotf_coef20_21);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_EOTF_COEF22_RS,
+			hdr_osd_reg.viu_osd1_eotf_coef22_rs);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_EOTF_CTL,
+			hdr_osd_reg.viu_osd1_eotf_ctl);
+	}
+	/* restore oetf lut */
+	if ((hdr_osd_reg.viu_osd1_oetf_ctl & 0xe0000000) != 0) {
+		addr_port = VIU_OSD1_OETF_LUT_ADDR_PORT;
+		data_port = VIU_OSD1_OETF_LUT_DATA_PORT;
+		for (i = 0; i < 20; i++) {
+			rdma_write_reg(
+				osd_reset_rdma_handle,
+				addr_port, i);
+			rdma_write_reg(
+				osd_reset_rdma_handle,
+				data_port,
+				lut->or_map[i * 2]
+				| (lut->or_map[i * 2 + 1] << 16));
+		}
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			addr_port, 20);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			data_port,
+			lut->or_map[41 - 1]
+			| (lut->og_map[0] << 16));
+		for (i = 0; i < 20; i++) {
+			rdma_write_reg(
+				osd_reset_rdma_handle,
+				addr_port, 21 + i);
+			rdma_write_reg(
+				osd_reset_rdma_handle,
+				data_port,
+				lut->og_map[i * 2 + 1]
+				| (lut->og_map[i * 2 + 2] << 16));
+		}
+		for (i = 0; i < 20; i++) {
+			rdma_write_reg(
+				osd_reset_rdma_handle,
+				addr_port, 41 + i);
+			rdma_write_reg(
+				osd_reset_rdma_handle,
+				data_port,
+				lut->ob_map[i * 2]
+				| (lut->ob_map[i * 2 + 1] << 16));
+		}
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			addr_port, 61);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			data_port,
+			lut->ob_map[41 - 1]);
+		rdma_write_reg(
+			osd_reset_rdma_handle,
+			VIU_OSD1_OETF_CTL,
+			hdr_osd_reg.viu_osd1_oetf_ctl);
+	}
 }
-EXPORT_SYMBOL(VSYNCOSD_IRQ_SET_MPEG_REG_MASK);
+#endif
 
-int VSYNCOSD_IRQ_CLR_MPEG_REG_MASK(u32 addr, u32 _mask)
+static void osd_reset_rdma_func(u32 reset_bit)
 {
-	unsigned long read_val;
-	unsigned long write_val;
-	int ret = 0;
-	if (rdma_enable) {
-		read_val = VSYNCOSD_RD_MPEG_REG(addr);
-		write_val = read_val & (~_mask);
-		ret = update_table_item(addr, write_val, 1);
+	if ((disable_osd_rdma_reset == 0)
+		&& reset_bit){
+		rdma_write_reg(osd_reset_rdma_handle,
+			VIU_SW_RESET, 1);
+		rdma_write_reg(osd_reset_rdma_handle,
+			VIU_SW_RESET, 0);
+#ifdef CONFIG_AM_VECM
+		hdr_restore_osd_csc();
+#endif
+		set_reset_rdma_trigger_line();
+		rdma_config(osd_reset_rdma_handle, 1 << 6);
 	} else
-		osd_reg_clr_mask(addr, _mask);
-	return ret;
+		rdma_clear(osd_reset_rdma_handle);
 }
-EXPORT_SYMBOL(VSYNCOSD_IRQ_CLR_MPEG_REG_MASK);
 
-int VSYNCOSD_EX_WR_MPEG_REG(u32 addr, u32 val)
+static void osd_reset_rdma_irq(void *arg)
 {
-	int ret = -1;
-	if (rdma_enable && rdma_table_internal)
-		ret = update_table_item_internal(addr, val);
-	if (ret != 0) {
-		ret = 0;
-		if (rdma_enable)
-			ret = update_table_item(addr, val, 1);
-		else
-			osd_reg_write(addr, val);
+	return;
+}
+
+static void osd_rdma_irq(void *arg)
+{
+	u32 rdma_status;
+	if (osd_rdma_handle == -1)
+		return;
+
+	rdma_status = osd_reg_read(RDMA_STATUS);
+	debug_rdma_status = rdma_status;
+	OSD_RDMA_STATUS_CLEAR_REJECT;
+	reset_rdma_table();
+	osd_update_scan_mode();
+	osd_update_3d_mode();
+	osd_update_vsync_hit();
+	osd_hw_reset();
+	rdma_irq_count++;
+	{
+		/*This is a memory barrier*/
+		wmb();
 	}
-	return ret;
+	return;
 }
-EXPORT_SYMBOL(VSYNCOSD_EX_WR_MPEG_REG);
+
+static struct rdma_op_s osd_reset_rdma_op = {
+	osd_reset_rdma_irq,
+	NULL
+};
+
+static struct rdma_op_s osd_rdma_op = {
+	osd_rdma_irq,
+	NULL
+};
+#endif
 
 static int start_osd_rdma(char channel)
 {
+#ifndef CONFIG_AML_RDMA
 	char intr_bit = 8 * channel;
 	char rw_bit = 4 + channel;
 	char inc_bit = channel;
 	u32 data32;
-	char is_init = 1;
-
-	osd_rdma_update_config(is_init);
+	data32  = 0;
+	data32 |= 1 << 7; /* [31: 6] Rsrv. */
+	data32 |= 1 << 6; /* [31: 6] Rsrv. */
+	data32 |= 3 << 4;
+	/* [ 5: 4] ctrl_ahb_wr_burst_size. 0=16; 1=24; 2=32; 3=48. */
+	data32 |= 3 << 2;
+	/* [ 3: 2] ctrl_ahb_rd_burst_size. 0=16; 1=24; 2=32; 3=48. */
+	data32 |= 0 << 1;
+	/* [    1] ctrl_sw_reset.*/
+	data32 |= 0 << 0;
+	/* [    0] ctrl_free_clk_enable.*/
+	osd_reg_write(RDMA_CTRL, data32);
 
 	data32  = osd_reg_read(RDMA_ACCESS_AUTO);
 	/*
@@ -493,11 +754,17 @@ static int start_osd_rdma(char channel)
 	 */
 	data32 &= ~(1 << inc_bit);
 	osd_reg_write(RDMA_ACCESS_AUTO, data32);
+#else
+	rdma_config(channel,
+		RDMA_TRIGGER_VSYNC_INPUT
+		| RDMA_AUTO_START_MASK);
+#endif
 	return 1;
 }
 
 static int stop_rdma(char channel)
 {
+#ifndef CONFIG_AML_RDMA
 	char intr_bit = 8 * channel;
 	u32 data32 = 0x0;
 
@@ -507,17 +774,26 @@ static int stop_rdma(char channel)
 	/* [23: 16] interrupt inputs enable mask
 	for auto-start 1: vsync int bit 0*/
 	osd_reg_write(RDMA_ACCESS_AUTO, data32);
+#else
+	rdma_clear(channel);
+	if (osd_reset_rdma_handle != -1)
+		rdma_clear(osd_reset_rdma_handle);
+#endif
 	return 0;
 }
 
 
 void osd_rdma_interrupt_done_clear(void)
 {
+	u32 rdma_status;
 	if (rdma_reset_tigger_flag) {
-		pr_info("osd rdma restart!\n");
+		rdma_status =
+			osd_reg_read(RDMA_STATUS);
+		pr_info("osd rdma restart! 0x%x\n",
+			rdma_status);
 		rdma_reset_tigger_flag = 0;
 		osd_rdma_enable(0);
-		osd_rdma_enable(1);
+		osd_rdma_enable(2);
 	}
 }
 int read_rdma_table(void)
@@ -544,7 +820,8 @@ int osd_rdma_enable(u32 enable)
 	int ret = 0;
 	unsigned long flags;
 
-	if (enable == rdma_enable)
+	if ((enable && rdma_enable)
+		|| (!enable && !rdma_enable))
 		return 0;
 
 	ret = osd_rdma_init();
@@ -571,73 +848,57 @@ EXPORT_SYMBOL(osd_rdma_enable);
 
 int osd_rdma_reset_and_flush(u32 reset_bit)
 {
-	unsigned long read_val;
-	unsigned long write_val;
-	unsigned long flags;
-	u32 osd_backup[OSD_REG_BACKUP_COUNT];
-	u32 afbc_backup[OSD_AFBC_REG_BACKUP_COUNT];
-	struct rdma_table_item request_item;
 	int i, ret = 0;
+	unsigned long flags;
+	u32 reset_reg_mask;
+	u32 base;
+	u32 addr;
+	u32 value;
+
 	spin_lock_irqsave(&rdma_lock, flags);
-	i = 0;
-	while ((reset_bit & 1)
-		&& (i < OSD_REG_BACKUP_COUNT)) {
-		osd_backup[i] = read_reg_internal(
-			osd_reg_backup[i]);
-		i++;
+	reset_reg_mask = reset_bit;
+	reset_reg_mask &= ~HW_RESET_OSD1_REGS;
+	if (disable_osd_rdma_reset != 0) {
+		reset_reg_mask = 0;
+		reset_bit = 0;
 	}
-	i = 0;
-	while ((reset_bit & 0x80000000)
-		&& (i < OSD_AFBC_REG_BACKUP_COUNT)) {
-		afbc_backup[i] = read_reg_internal(
-			osd_afbc_reg_backup[i]);
-		i++;
+
+	if (reset_reg_mask) {
+		wrtie_reg_internal(VIU_SW_RESET,
+			reset_reg_mask);
+		wrtie_reg_internal(VIU_SW_RESET, 0);
 	}
-	read_val = read_reg_internal(VIU_SW_RESET);
-	write_val = read_val | reset_bit;
-	wrtie_reg_internal(VIU_SW_RESET, write_val);
 
-	read_val = read_reg_internal(VIU_SW_RESET);
-	write_val = read_val & (~reset_bit);
-	wrtie_reg_internal(VIU_SW_RESET, write_val);
+	/* same bit, but gxm only reset hardware, not top reg*/
+	if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)
+		reset_bit &= ~HW_RESET_AFBCD_REGS;
 
 	i = 0;
-	while ((reset_bit & 1)
+	base = VIU_OSD1_CTRL_STAT;
+	while ((reset_bit & HW_RESET_OSD1_REGS)
 		&& (i < OSD_REG_BACKUP_COUNT)) {
+		addr = osd_reg_backup[i];
 		wrtie_reg_internal(
-			osd_reg_backup[i], osd_backup[i]);
+			addr, osd_backup[addr - base]);
 		i++;
 	}
 	i = 0;
-	while ((reset_bit & 0x80000000)
+	base = OSD1_AFBCD_ENABLE;
+	while ((reset_bit & HW_RESET_AFBCD_REGS)
 		&& (i < OSD_AFBC_REG_BACKUP_COUNT)) {
-		if (osd_afbc_reg_backup[i]
-			== OSD1_AFBCD_ENABLE)
-			wrtie_reg_internal(
-				osd_afbc_reg_backup[i],
-				afbc_backup[i] | 0x100);
-		else
-			wrtie_reg_internal(
-				osd_afbc_reg_backup[i],
-				afbc_backup[i]);
+		addr = osd_afbc_reg_backup[i];
+		value = osd_afbc_backup[addr - base];
+		if (addr == OSD1_AFBCD_ENABLE)
+			value |=  0x100;
+		wrtie_reg_internal(
+			addr, value);
 		i++;
 	}
-	if (item_count + item_count_internal < 500) {
-		request_item.addr = OSD_RDMA_FLAG_REG;
-		request_item.val = OSD_RDMA_STATUS_MARK_TBL_DONE;
-		memcpy(
-			&rdma_table[item_count + item_count_internal - 1],
-			&request_item, 8);
-		memcpy(
-			&rdma_table[item_count - 1],
-			&rdma_table_internal[0],
-			8 * item_count_internal);
-		item_count = item_count + item_count_internal;
-		osd_reg_write(END_ADDR, (table_paddr + item_count * 8 - 1));
-	} else {
-		pr_info("osd_rdma_reset_and_flush item overflow %d + %d\n",
-			item_count, item_count_internal);
+	if (item_count < 500)
 		osd_reg_write(END_ADDR, (table_paddr + item_count * 8 - 1));
+	else {
+		pr_info("osd_rdma_reset_and_flush item overflow %d\n",
+			item_count);
 		ret = -1;
 	}
 	if (dump_reg_trigger > 0) {
@@ -647,6 +908,13 @@ int osd_rdma_reset_and_flush(u32 reset_bit)
 				rdma_table[i].val);
 		dump_reg_trigger--;
 	}
+
+#ifdef CONFIG_AML_RDMA
+	if (osd_reset_rdma_handle != -1)
+		osd_reset_rdma_func(
+			reset_bit & HW_RESET_OSD1_REGS);
+#endif
+
 	spin_unlock_irqrestore(&rdma_lock, flags);
 	return ret;
 }
@@ -654,21 +922,29 @@ EXPORT_SYMBOL(osd_rdma_reset_and_flush);
 
 static void osd_rdma_release(struct device *dev)
 {
+#ifdef CONFIG_AML_RDMA
+	if (osd_reset_rdma_handle != -1) {
+		rdma_unregister(osd_reset_rdma_handle);
+		osd_reset_rdma_handle = -1;
+	}
+	if (osd_rdma_handle != -1) {
+		rdma_unregister(osd_rdma_handle);
+		osd_rdma_handle = -1;
+	}
+#endif
 	kfree(dev);
 	osd_rdma_dev = NULL;
-	kfree(rdma_table_internal);
-	rdma_table_internal = NULL;
 }
 
+#ifdef OSD_RDMA_ISR
 static irqreturn_t osd_rdma_isr(int irq, void *dev_id)
 {
 	u32 rdma_status;
 	rdma_status = osd_reg_read(RDMA_STATUS);
 	debug_rdma_status = rdma_status;
-	if (rdma_status & (1 << (24+OSD_RDMA_CHANNEL_INDEX))) {
+	if (rdma_status & (1 << (24 + OSD_RDMA_CHANNEL_INDEX))) {
 		OSD_RDMA_STATUS_CLEAR_REJECT;
 		reset_rdma_table();
-		item_count_internal = 0;
 		osd_update_scan_mode();
 		osd_update_3d_mode();
 		osd_update_vsync_hit();
@@ -678,7 +954,8 @@ static irqreturn_t osd_rdma_isr(int irq, void *dev_id)
 			/*This is a memory barrier*/
 			wmb();
 		}
-		osd_reg_write(RDMA_CTRL, 1 << (24+OSD_RDMA_CHANNEL_INDEX));
+		osd_reg_write(RDMA_CTRL,
+			1 << (24 + OSD_RDMA_CHANNEL_INDEX));
 	} else
 		rdma_lost_count++;
 	rdma_status = osd_reg_read(RDMA_STATUS);
@@ -691,6 +968,7 @@ static irqreturn_t osd_rdma_isr(int irq, void *dev_id)
 	}
 	return IRQ_HANDLED;
 }
+#endif
 
 static int osd_rdma_init(void)
 {
@@ -720,16 +998,9 @@ static int osd_rdma_init(void)
 		goto error2;
 	}
 
-	rdma_table_internal = kzalloc(
-		RDMA_TABLE_INTERNAL_COUNT * sizeof(struct rdma_table_item),
-		GFP_KERNEL);
-
-	if (!rdma_table_internal) {
-		osd_log_err("osd rdma dma alloc failed2!\n");
-		goto error2;
-	}
-	item_count_internal = 0;
+#ifdef OSD_RDMA_ISR
 	second_rdma_irq = 0;
+#endif
 	dump_reg_trigger = 0;
 	table_vaddr = osd_rdma_table_virt;
 	table_paddr = osd_rdma_table_phy;
@@ -742,6 +1013,7 @@ static int osd_rdma_init(void)
 		goto error2;
 	}
 
+#ifdef OSD_RDMA_ISR
 	if (rdma_mgr_irq_request) {
 		second_rdma_irq = 1;
 		pr_info("osd rdma request irq as second interrput function!\n");
@@ -751,15 +1023,35 @@ static int osd_rdma_init(void)
 		osd_log_err("can't request irq for rdma\n");
 		goto error2;
 	}
-
+#endif
 	osd_rdma_init_flag = true;
+	osd_reg_write(OSD_RDMA_FLAG_REG, 0x0);
+
+#ifdef CONFIG_AML_RDMA
+	if ((get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)
+		&& (get_cpu_type() <= MESON_CPU_MAJOR_ID_TXL)) {
+		osd_reset_rdma_op.arg = osd_rdma_dev;
+		osd_reset_rdma_handle =
+			rdma_register(&osd_reset_rdma_op,
+			NULL, PAGE_SIZE);
+		pr_info("%s:osd reset rdma handle = %d.\n", __func__,
+				osd_reset_rdma_handle);
+	}
+	osd_rdma_op.arg = osd_rdma_dev;
+	osd_rdma_handle =
+		rdma_register(&osd_rdma_op,
+		NULL, PAGE_SIZE);
+	pr_info("%s:osd rdma handle = %d.\n", __func__,
+		osd_rdma_handle);
+#else
+	osd_rdma_handle = 3; /* use channel 3 as default */
+#endif
+
 	return 0;
 
 error2:
 	kfree(osd_rdma_dev);
 	osd_rdma_dev = NULL;
-	kfree(rdma_table_internal);
-	rdma_table_internal = NULL;
 	return -1;
 }
 
@@ -784,3 +1076,6 @@ module_param(rdma_lost_count, uint, 0664);
 MODULE_PARM_DESC(dump_reg_trigger, "\n dump_reg_trigger\n");
 module_param(dump_reg_trigger, uint, 0664);
 
+MODULE_PARM_DESC(rdma_recovery_count, "\n rdma_recovery_count\n");
+module_param(rdma_recovery_count, uint, 0664);
+
diff --git a/drivers/amlogic/display/osd/osd_rdma.h b/drivers/amlogic/display/osd/osd_rdma.h
index fbbf6bb..793a1df 100644
--- a/drivers/amlogic/display/osd/osd_rdma.h
+++ b/drivers/amlogic/display/osd/osd_rdma.h
@@ -29,7 +29,7 @@ struct rdma_table_item {
 
 #define TABLE_SIZE	 PAGE_SIZE
 #define MAX_TABLE_ITEM	 (TABLE_SIZE/sizeof(struct rdma_table_item_t))
-#define OSD_RDMA_CHANNEL_INDEX	3  /*auto  1,2,3   manual is */
+#define OSD_RDMA_CHANNEL_INDEX	osd_rdma_handle
 #define START_ADDR	(RDMA_AHB_START_ADDR_MAN+(OSD_RDMA_CHANNEL_INDEX<<1))
 #define END_ADDR	(RDMA_AHB_END_ADDR_MAN+(OSD_RDMA_CHANNEL_INDEX<<1))
 
@@ -70,5 +70,4 @@ extern int rdma_mgr_irq_request;
 #ifdef CONFIG_VSYNC_RDMA
 extern void osd_rdma_interrupt_done_clear(void);
 #endif
-
 #endif
diff --git a/drivers/amlogic/display/osd/osd_sync.h b/drivers/amlogic/display/osd/osd_sync.h
index e05108d..21ecc35 100644
--- a/drivers/amlogic/display/osd/osd_sync.h
+++ b/drivers/amlogic/display/osd/osd_sync.h
@@ -19,9 +19,6 @@
 #ifndef _OSD_SYNC_H_
 #define _OSD_SYNC_H_
 
-#include <sw_sync.h>
-#include <sync.h>
-
 struct fb_sync_request_s {
 	unsigned int xoffset;
 	unsigned int yoffset;
@@ -29,4 +26,16 @@ struct fb_sync_request_s {
 	int out_fen_fd;
 };
 
+struct fb_sync_request_render_s {
+	unsigned int    xoffset;
+	unsigned int    yoffset;
+	int             in_fen_fd;
+	int             out_fen_fd;
+	int             width;
+	int             height;
+	int             format;
+	int             shared_fd;
+	u32             op;
+	u32             reserve;
+};
 #endif
diff --git a/drivers/amlogic/display/osd_ext/Makefile b/drivers/amlogic/display/osd_ext/Makefile
index 1718623..0f09d40 100644
--- a/drivers/amlogic/display/osd_ext/Makefile
+++ b/drivers/amlogic/display/osd_ext/Makefile
@@ -1,5 +1,5 @@
 obj-$(CONFIG_AM_FB_EXT) += fb_ext.o
-fb_ext-objs = osd_hw.o osd_fb.o osd_clone.o osd_prot.o
+fb_ext-objs = osd_hw.o osd_fb.o osd_clone.o
 
 ccflags-y += -Idrivers/staging/android/
 ccflags-y += -Idrivers/amlogic/display/
diff --git a/drivers/amlogic/display/osd_ext/osd_fb.c b/drivers/amlogic/display/osd_ext/osd_fb.c
index c2f074f..ccd955c 100644
--- a/drivers/amlogic/display/osd_ext/osd_fb.c
+++ b/drivers/amlogic/display/osd_ext/osd_fb.c
@@ -419,10 +419,8 @@ static int osd_ext_ioctl(struct fb_info *info, unsigned int cmd,
 				1 : 0, arg & 0xffff ? 1 : 0);
 		break;
 	case FBIOPUT_OSD_ROTATE_ON:
-		osd_ext_set_rotate_on_hw(info->node - 2, arg);
 		break;
 	case FBIOPUT_OSD_ROTATE_ANGLE:
-		osd_ext_set_rotate_angle_hw(info->node - 2, arg);
 		break;
 	case FBIOPUT_OSD_SRCCOLORKEY:
 		switch (fbdev->color->color_index) {
@@ -678,8 +676,10 @@ int osd_ext_notify_callback(struct notifier_block *block, unsigned long cmd,
 			if (!disp_rect)
 				break;
 			fb_dev = gp_fbdev_list[i];
+			/*
 			if (fb_dev->preblend_enable)
 				break;
+			*/
 			fb_dev->osd_ctl.disp_start_x = disp_rect->x;
 			fb_dev->osd_ctl.disp_start_y = disp_rect->y;
 			osd_log_info("set disp axis: x:%d y:%d w:%d h:%d\n",
@@ -717,30 +717,6 @@ static struct notifier_block osd_ext_notifier_nb = {
 	.notifier_call	= osd_ext_notify_callback,
 };
 
-static ssize_t store_preblend_enable(struct device *device,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	struct osd_fb_dev_s *fbdev = (struct osd_fb_dev_s *)fb_info->par;
-	int res = 0;
-	int ret = 0;
-
-	ret = kstrtoint(buf, 0, &res);
-	fbdev->preblend_enable = res;
-	vout_notifier_call_chain(VOUT_EVENT_OSD_PREBLEND_ENABLE,
-				 &fbdev->preblend_enable);
-	return count;
-}
-
-static ssize_t show_preblend_enable(struct device *device,
-		struct device_attribute *attr, char *buf)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	struct osd_fb_dev_s *fbdev = (struct osd_fb_dev_s *)fb_info->par;
-	return snprintf(buf, PAGE_SIZE, "preblend[%s]\n",
-			fbdev->preblend_enable ? "enable" : "disable");
-}
-
 static ssize_t store_enable_3d(struct device *device,
 		struct device_attribute *attr, const char *buf, size_t count)
 {
@@ -1314,91 +1290,6 @@ static ssize_t store_angle(struct device *device, struct device_attribute *attr,
 	return count;
 }
 
-static ssize_t show_rotate_on(struct device *device,
-			      struct device_attribute *attr,
-			      char *buf)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	unsigned int osd_ext_rotate = 0;
-
-	osd_ext_get_rotate_on_hw(fb_info->node - 2, &osd_ext_rotate);
-	return snprintf(buf, PAGE_SIZE, "osd_ext_rotate:[%s]\n",
-			osd_ext_rotate ? "ON" : "OFF");
-}
-
-static ssize_t store_rotate_on(struct device *device,
-			       struct device_attribute *attr,
-			       const char *buf, size_t count)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	unsigned int osd_rotate = 0;
-	int res = 0;
-	int ret = 0;
-
-	ret = kstrtoint(buf, 0, &res);
-	osd_rotate = res;
-	osd_ext_set_rotate_on_hw(fb_info->node - 2, osd_rotate);
-
-	return count;
-}
-
-static ssize_t show_rotate_angle(struct device *device,
-				 struct device_attribute *attr,
-				 char *buf)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	unsigned int osd_ext_rotate_angle = 0;
-
-	osd_ext_get_rotate_angle_hw(fb_info->node - 2, &osd_ext_rotate_angle);
-	return snprintf(buf, PAGE_SIZE, "osd_ext_rotate:%d\n",
-			osd_ext_rotate_angle);
-}
-
-static ssize_t store_rotate_angle(struct device *device,
-				  struct device_attribute *attr,
-				  const char *buf, size_t count)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	unsigned int osd_rotate_angle = 0;
-	int res = 0;
-	int ret = 0;
-
-	ret = kstrtoint(buf, 0, &res);
-	osd_rotate_angle = res;
-	osd_ext_set_rotate_angle_hw(fb_info->node - 2, osd_rotate_angle);
-
-	return count;
-}
-
-static ssize_t show_prot_canvas(struct device *device,
-				struct device_attribute *attr,
-				char *buf)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	int x_start, y_start, x_end, y_end;
-
-	osd_ext_get_prot_canvas_hw(fb_info->node - 2,
-			&x_start, &y_start, &x_end, &y_end);
-
-	return snprintf(buf, PAGE_SIZE, "%d %d %d %d\n",
-			x_start, y_start, x_end, y_end);
-}
-
-static ssize_t store_prot_canvas(struct device *device,
-				 struct device_attribute *attr,
-				 const char *buf, size_t count)
-{
-	struct fb_info *fb_info = dev_get_drvdata(device);
-	int parsed[4];
-
-	if (likely(parse_para(buf, 4, parsed) == 4))
-		osd_ext_set_prot_canvas_hw(fb_info->node - 2,
-				parsed[0], parsed[1], parsed[2], parsed[3]);
-	else
-		osd_log_err("set prot canvas error\n");
-
-	return count;
-}
 static struct device_attribute osd_ext_attrs[] = {
 	__ATTR(scale, S_IRUGO | S_IWUSR | S_IWGRP,
 			show_scale, store_scale),
@@ -1406,8 +1297,6 @@ static struct device_attribute osd_ext_attrs[] = {
 			show_order, store_order),
 	__ATTR(enable_3d, S_IRUGO | S_IWUSR,
 			show_enable_3d, store_enable_3d),
-	__ATTR(preblend_enable, S_IRUGO | S_IWUSR,
-			show_preblend_enable, store_preblend_enable),
 	__ATTR(free_scale, S_IRUGO | S_IWUSR | S_IWGRP,
 			show_free_scale, store_free_scale),
 	__ATTR(scale_axis, S_IRUGO | S_IWUSR,
@@ -1438,12 +1327,6 @@ static struct device_attribute osd_ext_attrs[] = {
 			show_clone, store_clone),
 	__ATTR(angle, S_IRUGO | S_IWUSR,
 			show_angle, store_angle),
-	__ATTR(prot_on, S_IRUGO | S_IWUSR | S_IWGRP,
-			show_rotate_on, store_rotate_on),
-	__ATTR(prot_angle, S_IRUGO | S_IWUSR,
-			show_rotate_angle, store_rotate_angle),
-	__ATTR(prot_canvas, S_IRUGO | S_IWUSR,
-			show_prot_canvas, store_prot_canvas),
 };
 
 #ifdef CONFIG_PM
diff --git a/drivers/amlogic/display/osd_ext/osd_hw.c b/drivers/amlogic/display/osd_ext/osd_hw.c
index b3b0c88..299c199 100644
--- a/drivers/amlogic/display/osd_ext/osd_hw.c
+++ b/drivers/amlogic/display/osd_ext/osd_hw.c
@@ -92,8 +92,6 @@ static unsigned char osd_ext_vf_prov_init;
 static int g_vf_visual_width;
 static int g_vf_width;
 static int g_vf_height;
-static int g_rotation_width;
-static int g_rotation_height;
 
 static unsigned int filt_coef0[] = { /* bicubic */
 	0x00800000,
@@ -452,19 +450,6 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 	unsigned int odd_even;
 	unsigned int scan_line_number = 0;
 	unsigned char output_type = 0;
-	u32 data32 = 0;
-
-	if (get_cpu_type() == MESON_CPU_MAJOR_ID_M8) {
-		if (osd_ext_hw.rotate[OSD1].on_off > 0 &&
-				osd_ext_hw.rotate[OSD1].angle > 0) {
-			data32 = ((osd_ext_hw.rotation_pandata[OSD1].y_start +
-				   osd_ext_hw.pandata[OSD1].y_start) & 0x1fff)
-				 | ((osd_ext_hw.rotation_pandata[OSD1].y_end +
-					osd_ext_hw.pandata[OSD1].y_start) &
-						 0x1fff) << 16;
-			osd_reg_write(VPU_PROT1_Y_START_END, data32);
-		}
-	}
 
 	output_type = osd_reg_read(VPU_VIU_VENC_MUX_CTRL) & 0xc;
 	osd_ext_hw.scan_mode = SCAN_MODE_PROGRESSIVE;
@@ -537,10 +522,6 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 	osd_ext_update_3d_mode(osd_ext_hw.mode_3d[OSD1].enable,
 			       osd_ext_hw.mode_3d[OSD2].enable);
 
-	if (osd_ext_hw.rotate[OSD1].on_off > 0 &&
-			osd_ext_hw.rotate[OSD1].angle > 0)
-		osd_reg_write(VIU2_OSD1_BLK0_CFG_W2, data32);
-
 	if (!vsync_hit) {
 #ifdef FIQ_VSYNC
 		fiq_bridge_pulse_trigger(&osd_ext_hw.fiq_handle_item);
@@ -716,29 +697,15 @@ void osd_ext_setup(struct osd_ctl_s *osd_ext_ctl,
 	disp_data.y_start = disp_start_y;
 
 	if (likely(osd_ext_hw.free_scale_enable[OSD1] && index == OSD1)) {
-		if (!osd_ext_hw.free_scale_mode[OSD1]) {
-			pan_data.x_end = xoffset + g_vf_visual_width;
-			pan_data.y_end = yoffset + g_vf_height;
-			disp_data.x_end = disp_start_x + g_vf_width;
-			disp_data.y_end = disp_start_y + g_vf_height;
-		} else {
-			pan_data.x_end = xoffset + (disp_end_x - disp_start_x);
-			pan_data.y_end = yoffset + (disp_end_y - disp_start_y);
-			disp_data.x_end = disp_end_x;
-			disp_data.y_end = disp_end_y;
-		}
+		pan_data.x_end = xoffset + (disp_end_x - disp_start_x);
+		pan_data.y_end = yoffset + (disp_end_y - disp_start_y);
+		disp_data.x_end = disp_end_x;
+		disp_data.y_end = disp_end_y;
 	} else {
 		pan_data.x_end = xoffset + (disp_end_x - disp_start_x);
 		pan_data.y_end = yoffset + (disp_end_y - disp_start_y);
-
-		if (likely(osd_ext_hw.rotate[index].on_off &&
-			   osd_ext_hw.rotate[index].on_off > 0)) {
-			disp_data.x_end = disp_start_x + g_rotation_height;
-			disp_data.y_end = disp_start_y + g_rotation_width;
-		} else {
-			disp_data.x_end = disp_end_x;
-			disp_data.y_end = disp_end_y;
-		}
+		disp_data.x_end = disp_end_x;
+		disp_data.y_end = disp_end_y;
 	}
 
 	if (osd_ext_hw.fb_gem[index].addr != fbmem ||
@@ -1221,108 +1188,6 @@ void osd_ext_enable_3d_mode_hw(int index, int enable)
 	}
 }
 
-void osd_ext_set_rotate_angle_hw(u32 index, u32 angle)
-{
-	osd_ext_hw.rotate[index].angle = angle;
-	add_to_update_list(index, DISP_OSD_ROTATE);
-	osd_ext_wait_vsync_hw();
-}
-
-void osd_ext_get_rotate_angle_hw(u32 index, u32 *angle)
-{
-	*angle = osd_ext_hw.rotate[index].angle;
-}
-
-void osd_ext_set_rotate_on_hw(u32 index, u32 on_off)
-{
-	static struct pandata_s save_disp_data = {0, 0, 0, 0};
-	static struct pandata_s save_disp_data2 = {0, 0, 0, 0};
-
-	if (get_cpu_type() != MESON_CPU_MAJOR_ID_M8)
-		return;
-
-	osd_ext_hw.rotate[index].on_off = on_off;
-
-	if (on_off) {
-		if (index == OSD1)
-			memcpy(&save_disp_data, &osd_ext_hw.dispdata[index],
-					sizeof(struct pandata_s));
-		else if (index == OSD2)
-			memcpy(&save_disp_data2, &osd_ext_hw.dispdata[index],
-					sizeof(struct pandata_s));
-
-		g_rotation_width = osd_ext_hw.rotation_pandata[index].x_end -
-				   osd_ext_hw.rotation_pandata[index].x_start;
-		g_rotation_height = osd_ext_hw.rotation_pandata[index].y_end -
-				    osd_ext_hw.rotation_pandata[index].y_start;
-		osd_ext_hw.dispdata[index].x_end =
-			osd_ext_hw.dispdata[OSD1].x_start + g_rotation_height;
-		osd_ext_hw.dispdata[index].y_end =
-			osd_ext_hw.dispdata[OSD1].y_start + g_rotation_width;
-	} else {
-		osd_reg_set_mask(VPU_SW_RESET, 1 << 8);
-		osd_reg_clr_mask(VPU_SW_RESET, 1 << 8);
-
-		if (index == OSD1) {
-			osd_reg_set_mask(VIU2_SW_RESET, 1 << 0);
-			osd_reg_clr_mask(VIU2_SW_RESET, 1 << 0);
-			osd_reg_set_mask(VIU2_OSD1_FIFO_CTRL_STAT, 1 << 0);
-			memcpy(&osd_ext_hw.dispdata[index], &save_disp_data,
-					sizeof(struct pandata_s));
-		} else {
-			osd_reg_set_mask(VIU2_SW_RESET, 1 << 1);
-			osd_reg_clr_mask(VIU2_SW_RESET, 1 << 1);
-			osd_reg_set_mask(VIU2_OSD1_FIFO_CTRL_STAT, 1 << 0);
-			memcpy(&osd_ext_hw.dispdata[index], &save_disp_data2,
-					sizeof(struct pandata_s));
-		}
-	}
-
-	add_to_update_list(index, OSD_COLOR_MODE);
-	add_to_update_list(index, DISP_GEOMETRY);
-	add_to_update_list(index, DISP_OSD_ROTATE);
-	osd_ext_wait_vsync_hw();
-}
-
-void osd_ext_get_rotate_on_hw(u32 index, u32 *on_off)
-{
-	*on_off = osd_ext_hw.rotate[index].on_off;
-}
-
-
-void osd_ext_set_prot_canvas_hw(u32 index, s32 x_start, s32 y_start, s32 x_end,
-				s32 y_end)
-{
-	osd_ext_hw.rotation_pandata[index].x_start = x_start;
-	osd_ext_hw.rotation_pandata[index].y_start = y_start;
-	osd_ext_hw.rotation_pandata[index].x_end = x_end;
-	osd_ext_hw.rotation_pandata[index].y_end = y_end;
-
-	if (osd_ext_hw.rotate[index].on_off &&
-			osd_ext_hw.rotate[index].angle > 0) {
-		g_rotation_width = osd_ext_hw.rotation_pandata[index].x_end -
-				   osd_ext_hw.rotation_pandata[index].x_start;
-		g_rotation_height = osd_ext_hw.rotation_pandata[index].y_end -
-				    osd_ext_hw.rotation_pandata[index].y_start;
-		osd_ext_hw.dispdata[index].x_end =
-			osd_ext_hw.dispdata[OSD1].x_start + g_rotation_height;
-		osd_ext_hw.dispdata[index].y_end =
-			osd_ext_hw.dispdata[OSD1].y_start + g_rotation_width;
-
-		add_to_update_list(index, DISP_GEOMETRY);
-		add_to_update_list(index, OSD_COLOR_MODE);
-	}
-}
-
-void osd_ext_get_prot_canvas_hw(u32 index, s32 *x_start, s32 *y_start,
-				s32 *x_end, s32 *y_end)
-{
-	*x_start = osd_ext_hw.rotation_pandata[index].x_start;
-	*y_start = osd_ext_hw.rotation_pandata[index].y_start;
-	*x_end = osd_ext_hw.rotation_pandata[index].x_end;
-	*y_end = osd_ext_hw.rotation_pandata[index].y_end;
-}
-
 #ifdef CONFIG_FB_OSD_SUPPORT_SYNC_FENCE
 void osd_ext_pan_display_fence(struct osd_fence_map_s *fence_map)
 {
@@ -1726,9 +1591,8 @@ static void osd1_update_color_mode(void)
 		data32 |= osd_reg_read(VIU2_OSD1_BLK0_CFG_W0) & 0x30007040;
 		data32 |= osd_ext_hw.fb_gem[OSD1].canvas_idx << 16;
 
-		if (!osd_ext_hw.rotate[OSD1].on_off)
-			data32 |= OSD_DATA_LITTLE_ENDIAN << 15;
-
+		/* if (!osd_ext_hw.rotate[OSD1].on_off) */
+		data32 |= OSD_DATA_LITTLE_ENDIAN << 15;
 		data32 |= osd_ext_hw.color_info[OSD1]->hw_colormat << 2;
 
 		if (osd_ext_hw.color_info[OSD1]->color_index <
@@ -1755,8 +1619,8 @@ static void osd2_update_color_mode(void)
 		data32 |= osd_reg_read(VIU2_OSD2_BLK0_CFG_W0) & 0x30007040;
 		data32 |= osd_ext_hw.fb_gem[OSD2].canvas_idx << 16;
 
-		if (!osd_ext_hw.rotate[OSD1].on_off)
-			data32 |= OSD_DATA_LITTLE_ENDIAN << 15;
+		/* if (!osd_ext_hw.rotate[OSD1].on_off) */
+		data32 |= OSD_DATA_LITTLE_ENDIAN << 15;
 
 		data32 |= osd_ext_hw.color_info[OSD2]->hw_colormat << 2;
 
@@ -1852,155 +1716,12 @@ static void osd2_update_enable(void)
 
 static void osd1_update_disp_osd_rotate(void)
 {
-	unsigned char x_rev = 0, y_rev = 0;
-	unsigned char bpp = 32;
-	unsigned int x_start;
-	unsigned int x_end;
-	unsigned int y_start;
-	unsigned int y_end;
-	unsigned int y_len_m1;
-
-	if (osd_ext_hw.color_info[OSD1]->color_index <= COLOR_INDEX_08_PAL256)
-		bpp = 8;
-	else if (osd_ext_hw.color_info[OSD1]->color_index <= COLOR_INDEX_16_565)
-		bpp = 16;
-	else if (osd_ext_hw.color_info[OSD1]->color_index <= COLOR_INDEX_24_RGB)
-		bpp = 24;
-	else if (osd_ext_hw.color_info[OSD1]->color_index <=
-			COLOR_INDEX_32_ARGB)
-		bpp = 32;
-
-	switch (osd_ext_hw.rotate[OSD1].angle) {
-	case 0:/* clockwise H flip (dst ) */
-		x_rev = 0;
-		y_rev = 0;
-		break;/* clockwise */
-
-	case 1:
-		y_rev = 1;
-		break;
-
-	case 2:/* anti-clockwise */
-		x_rev = 1;
-		break;
-
-	case 3:/* anti-clockwise H flip(dst) */
-		x_rev = 1;
-		y_rev = 1;
-		break;
-	}
-
-	x_start = osd_ext_hw.rotation_pandata[OSD1].x_start;
-	x_end = osd_ext_hw.rotation_pandata[OSD1].x_end;
-	y_start = osd_ext_hw.rotation_pandata[OSD1].y_start;
-	y_end = osd_ext_hw.rotation_pandata[OSD1].y_end;
-	y_len_m1 = y_end - y_start;
-
-	if (get_cpu_type() == MESON_CPU_MAJOR_ID_M8) {
-		osd_ext_set_prot(
-			x_rev,
-			y_rev,
-			(bpp >> 3) - 1, /* bytes_per_pixel, */
-			0, /* conv_422to444, */
-			OSD_DATA_LITTLE_ENDIAN, /* little_endian, */
-			HOLD_LINES, /* hold_lines, */
-			x_start,
-			x_end,
-			y_start,
-			y_end,
-			y_len_m1,
-			Y_STEP,
-			PAT_START_PTR,
-			PAT_END_PTR,
-			PAT_VAL,
-			osd_ext_hw.fb_gem[OSD1].canvas_idx,
-			CID_VALUE,
-			CID_MODE,
-			CUGT, /* urgent bit */
-			REQ_ONOFF_EN,
-			REQ_ON_MAX,
-			REQ_OFF_MIN,
-			OSD1,
-			osd_ext_hw.rotate[OSD1].on_off);
-		remove_from_update_list(OSD1, DISP_OSD_ROTATE);
-	}
+	remove_from_update_list(OSD1, DISP_OSD_ROTATE);
 }
 
 static void osd2_update_disp_osd_rotate(void)
 {
-	unsigned char	x_rev = 0, y_rev = 0;
-	unsigned char	bpp = 32;
-	unsigned int	x_start;
-	unsigned int	x_end;
-	unsigned int	y_start;
-	unsigned int	y_end;
-	unsigned int	y_len_m1;
-
-	if (osd_ext_hw.color_info[OSD2]->color_index <= COLOR_INDEX_08_PAL256)
-		bpp = 8;
-	else if (osd_ext_hw.color_info[OSD2]->color_index <= COLOR_INDEX_16_565)
-		bpp = 16;
-	else if (osd_ext_hw.color_info[OSD2]->color_index <= COLOR_INDEX_24_RGB)
-		bpp = 24;
-	else if (osd_ext_hw.color_info[OSD2]->color_index <=
-			COLOR_INDEX_32_ARGB)
-		bpp = 32;
-
-	switch (osd_ext_hw.rotate[OSD2].angle) {
-	case 0:/* clockwise H flip (dst ) */
-		x_rev = 0;
-		y_rev = 0;
-		break;/* clockwise */
-
-	case 1:
-		y_rev = 1;
-		break;
-
-	case 2:/* anti-clockwise */
-		x_rev = 1;
-		break;
-
-	case 3:/* anti-clockwise H flip(dst) */
-		x_rev = 1;
-		y_rev = 1;
-		break;
-	}
-
-	x_start = osd_ext_hw.rotation_pandata[OSD2].x_start;
-	x_end = osd_ext_hw.rotation_pandata[OSD2].x_end;
-	y_start = osd_ext_hw.rotation_pandata[OSD2].y_start;
-	y_end = osd_ext_hw.rotation_pandata[OSD2].y_end;
-	y_len_m1 = y_end - y_start;
-
-	/* #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8 */
-	if (get_cpu_type() == MESON_CPU_MAJOR_ID_M8) {
-		osd_ext_set_prot(
-			x_rev,
-			y_rev,
-			(bpp >> 3) - 1, /* bytes_per_pixel, */
-			0, /* conv_422to444, */
-			OSD_DATA_LITTLE_ENDIAN, /* little_endian, */
-			HOLD_LINES, /* hold_lines, */
-			x_start,
-			x_end,
-			y_start,
-			y_end,
-			y_len_m1,
-			Y_STEP,
-			PAT_START_PTR,
-			PAT_END_PTR,
-			PAT_VAL,
-			osd_ext_hw.fb_gem[OSD2].canvas_idx,
-			CID_VALUE,
-			CID_MODE,
-			CUGT, /* urgent bit */
-			REQ_ONOFF_EN,
-			REQ_ON_MAX,
-			REQ_OFF_MIN,
-			OSD2,
-			osd_ext_hw.rotate[OSD2].on_off);
-		remove_from_update_list(OSD2, DISP_OSD_ROTATE);
-	}
+	remove_from_update_list(OSD2, DISP_OSD_ROTATE);
 }
 
 static void osd1_update_color_key(void)
@@ -2315,35 +2036,20 @@ static void osd1_update_disp_geometry(void)
 				HW_OSD_BLOCK_ENABLE_MASK);
 		osd_reg_write(VIU2_OSD1_CTRL_STAT, data32);
 	} else {
-		if (osd_ext_hw.rotate[OSD1].on_off > 0 &&
-				osd_ext_hw.rotate[OSD1].angle > 0) {
-			data32 = (osd_ext_hw.dispdata[OSD1].x_start & 0xfff) |
-				((osd_ext_hw.dispdata[OSD1].x_start +
-				  g_rotation_height) & 0xfff) << 16;
-			osd_reg_write(VIU2_OSD1_BLK0_CFG_W3, data32);
-			data32 = (osd_ext_hw.dispdata[OSD1].y_start & 0xfff) |
-				((osd_ext_hw.dispdata[OSD1].y_start +
-				  g_rotation_width) & 0xfff) << 16;
-			osd_reg_write(VIU2_OSD1_BLK0_CFG_W4, data32);
-		} else {
-			data32 = (osd_ext_hw.dispdata[OSD1].x_start & 0xfff) |
-			    (osd_ext_hw.dispdata[OSD1].x_end & 0xfff) << 16;
-			osd_reg_write(VIU2_OSD1_BLK0_CFG_W3, data32);
-
-			if (osd_ext_hw.scan_mode == SCAN_MODE_INTERLACE)
-				data32 = ((osd_ext_hw.dispdata[OSD1].y_start >>
-						1) & 0xfff)
-					| ((((osd_ext_hw.dispdata[OSD1].y_end +
-						1) >> 1) - 1) & 0xfff) << 16;
-			else
-				data32 = (osd_ext_hw.dispdata[OSD1].y_start &
-						0xfff)
-					| (osd_ext_hw.dispdata[OSD1].y_end &
-						0xfff) << 16;
-
-			osd_reg_write(VIU2_OSD1_BLK0_CFG_W4, data32);
-		}
-
+		data32 = (osd_ext_hw.dispdata[OSD1].x_start & 0xfff) |
+			(osd_ext_hw.dispdata[OSD1].x_end & 0xfff) << 16;
+		osd_reg_write(VIU2_OSD1_BLK0_CFG_W3, data32);
+		if (osd_ext_hw.scan_mode == SCAN_MODE_INTERLACE)
+			data32 = ((osd_ext_hw.dispdata[OSD1].y_start >>
+				1) & 0xfff)
+				| ((((osd_ext_hw.dispdata[OSD1].y_end +
+				1) >> 1) - 1) & 0xfff) << 16;
+		else
+			data32 = (osd_ext_hw.dispdata[OSD1].y_start &
+				0xfff)
+				| (osd_ext_hw.dispdata[OSD1].y_end &
+					0xfff) << 16;
+		osd_reg_write(VIU2_OSD1_BLK0_CFG_W4, data32);
 		/* enable osd 2x scale */
 		if (osd_ext_hw.scale[OSD1].h_enable ||
 				osd_ext_hw.scale[OSD1].v_enable) {
@@ -2400,14 +2106,6 @@ static void osd1_update_disp_geometry(void)
 				   osd_ext_hw.pandata[OSD1].y_start)
 				  & 0x1fff) << 16;
 			osd_reg_write(VIU2_OSD1_BLK0_CFG_W2, data32);
-		} else if (osd_ext_hw.rotate[OSD1].on_off > 0
-			   && osd_ext_hw.rotate[OSD1].angle > 0) {
-			/* enable osd rotation */
-			data32 = (osd_ext_hw.rotation_pandata[OSD1].x_start
-					& 0x1fff)
-				| (osd_ext_hw.rotation_pandata[OSD1].x_end
-					& 0x1fff) << 16;
-			osd_reg_write(VIU2_OSD1_BLK0_CFG_W1, data32);
 		} else {
 			/* normal mode */
 			data32 =
@@ -2571,12 +2269,13 @@ void osd_ext_init_hw(u32 logo_loaded)
 	osd_ext_hw.scale[OSD2].h_enable = osd_ext_hw.scale[OSD2].v_enable = 0;
 	osd_ext_hw.mode_3d[OSD2].enable = osd_ext_hw.mode_3d[OSD1].enable = 0;
 	osd_ext_hw.block_mode[OSD1] = osd_ext_hw.block_mode[OSD2] = 0;
+	/*
 	osd_ext_hw.rotation_pandata[OSD1].x_start =
 		osd_ext_hw.rotation_pandata[OSD1].y_start = 0;
 	osd_ext_hw.rotation_pandata[OSD2].x_start =
 		osd_ext_hw.rotation_pandata[OSD2].y_start = 0;
 	memset(osd_ext_hw.rotate, 0, sizeof(struct osd_rotate_s));
-
+	*/
 	osd_get_hw_para(&osd_hw);
 
 #ifdef CONFIG_FB_OSD_SUPPORT_SYNC_FENCE
@@ -2750,31 +2449,16 @@ void osd_ext_clone_pan(u32 index)
 	py0 = osd_ext_hw.pandata[index].y_start;
 	py1 = osd_ext_hw.pandata[index].y_end;
 	if (osd_ext_hw.clone[index]) {
-		if (osd_ext_hw.rotate[index].on_off > 0 &&
-				osd_ext_hw.rotate[index].angle > 0) {
-			if (osd_hw->pandata[index].y_start < height_osd0) {
-				if (py0 >= height_osd2)
-					offset -= g_rotation_height + 1;
-				else
-					offset = 0;
-			} else {
-				if (py0 < height_osd2)
-					offset += g_rotation_height + 1;
-				else
-					offset = 0;
-			}
+		if (py0 < height_osd0) {
+			if (py0 >= height_osd2)
+				offset -= py1 - py0 + 1;
+			else
+				offset = 0;
 		} else {
-			if (py0 < height_osd0) {
-				if (py0 >= height_osd2)
-					offset -= py1 - py0 + 1;
-				else
-					offset = 0;
-			} else {
-				if (py0 < height_osd2)
-					offset += py1 - py0 + 1;
-				else
-					offset = 0;
-			}
+			if (py0 < height_osd2)
+				offset += py1 - py0 + 1;
+			else
+				offset = 0;
 		}
 
 		osd_ext_hw.pandata[index].y_start += offset;
diff --git a/drivers/amlogic/display/osd_ext/osd_hw.h b/drivers/amlogic/display/osd_ext/osd_hw.h
index 34eb7ed..14584ac65 100644
--- a/drivers/amlogic/display/osd_ext/osd_hw.h
+++ b/drivers/amlogic/display/osd_ext/osd_hw.h
@@ -81,14 +81,6 @@ extern void osd_ext_set_block_mode_hw(u32 index, u32 mode);
 extern void osd_ext_enable_3d_mode_hw(int index, int enable);
 extern void osd_ext_set_2x_scale_hw(u32 index, u16 h_scale_enable,
 				    u16 v_scale_enable);
-extern void osd_ext_set_rotate_on_hw(u32 index, u32 on_off);
-extern void osd_ext_get_rotate_on_hw(u32 index, u32 *on_off);
-extern void osd_ext_set_rotate_angle_hw(u32 index, u32 angle);
-extern void osd_ext_get_rotate_angle_hw(u32 index, u32 *angle);
-extern void osd_ext_get_prot_canvas_hw(u32 index, s32 *x_start, s32 *y_start,
-				       s32 *x_end, s32 *y_end);
-extern void osd_ext_set_prot_canvas_hw(u32 index, s32 x_start, s32 y_start,
-				       s32 x_end, s32 y_end);
 extern void osd_ext_setpal_hw(u32 index, unsigned regno, unsigned red,
 			      unsigned green, unsigned blue, unsigned transp);
 extern void osd_ext_enable_hw(u32 index, int enable);
diff --git a/drivers/amlogic/display/vout/Kconfig b/drivers/amlogic/display/vout/Kconfig
index f2588ea..1d5e002 100644
--- a/drivers/amlogic/display/vout/Kconfig
+++ b/drivers/amlogic/display/vout/Kconfig
@@ -23,6 +23,13 @@ config AML_VOUT_FRAMERATE_AUTOMATION
 	help
 		framerate adjustment automatically from video source
 
+config AML_VOUT_CC_BYPASS
+	boolean "closed caption bypass"
+	default n
+	depends on AM_TV_OUTPUT
+	help
+		add cvbsout closed caption bypass function
+
 config AML_VDAC_HW_SWITCH
 	boolean "vdac hardware switch"
 	default n
@@ -30,4 +37,10 @@ config AML_VDAC_HW_SWITCH
 	help
 		vdac hardware switch of cvbs/ypbpr for mx.
 
+config AML_WSS
+	bool "WSS function"
+	default y
+	depends on AM_TV_OUTPUT
+	help
+		Wide Screen Signalling config.
 endmenu
diff --git a/drivers/amlogic/display/vout/Makefile b/drivers/amlogic/display/vout/Makefile
index 7fc25dd..5933ce5 100644
--- a/drivers/amlogic/display/vout/Makefile
+++ b/drivers/amlogic/display/vout/Makefile
@@ -2,4 +2,6 @@ obj-$(CONFIG_AM_VOUT) += vout_notify.o vout_serve.o vinfo.o vdac_dev.o
 
 obj-$(CONFIG_AM_TV_OUTPUT) += tv_vout.o tv_out_reg.o enc_clk_config.o
 
+obj-$(CONFIG_AML_WSS)	+= wss.o
+
 ccflags-y += -Idrivers/amlogic/display/
diff --git a/drivers/amlogic/display/vout/tv_out_reg.h b/drivers/amlogic/display/vout/tv_out_reg.h
index 3a99990..02daa18 100644
--- a/drivers/amlogic/display/vout/tv_out_reg.h
+++ b/drivers/amlogic/display/vout/tv_out_reg.h
@@ -621,6 +621,14 @@
  *         0=ENCL, 1=ENCI, 2=ENCP, 3=ENCT. */
 #define VPU_VIU_VENC_MUX_CTRL                      0x271a
 
+/* ********************************
+*[ 31 : 29 ] R,Current ENCI field status;
+*[ 28 : 25 ] R,Reserved;
+*[ 24 : 16 ] R,Current ENCI line counter status;
+*[ 15 : 11 ] R,Reserved;
+*[ 10 : 0 ] R,Current ENCI pixel counter status */
+#define ENCI_INFO_READ                           0x271c
+
 /* Bit  6 RW, gclk_mpeg_vpu_misc
  * Bit  5 RW, gclk_mpeg_venc_l_top
  * Bit  4 RW, gclk_mpeg_vencl_int
diff --git a/drivers/amlogic/display/vout/tv_vout.c b/drivers/amlogic/display/vout/tv_vout.c
index d8cfc1c..470ef8a 100644
--- a/drivers/amlogic/display/vout/tv_vout.c
+++ b/drivers/amlogic/display/vout/tv_vout.c
@@ -31,7 +31,8 @@
 #include <linux/slab.h>
 #include <linux/interrupt.h>
 #include <linux/ctype.h>
-#include <linux/major.h>
+/*#include <linux/major.h>*/
+#include <linux/cdev.h>
 #include <linux/delay.h>
 #include <linux/uaccess.h>
 #ifdef CONFIG_INSTABOOT
@@ -53,11 +54,26 @@
 #include "vout_log.h"
 #include "enc_clk_config.h"
 #include "tv_out_reg.h"
+#ifdef CONFIG_AML_WSS
+#include "wss.h"
+#endif
+
+#ifdef CONFIG_AML_VOUT_CC_BYPASS
+/* interrupt source */
+#define INT_VIU_VSYNC    35
+#endif
 
 #define PIN_MUX_REG_0 0x202c
 #define P_PIN_MUX_REG_0 CBUS_REG_ADDR(PIN_MUX_REG_0)
 static struct disp_module_info_s disp_module_info __nosavedata;
 static struct disp_module_info_s *info __nosavedata;
+#ifdef CONFIG_AML_VOUT_CC_BYPASS
+static struct CCring_MGR_s CC_ringbuf;
+static spinlock_t tvout_clk_lock;
+static unsigned int vsync_empty_flag;
+static unsigned int vsync_empty_flag_evn;
+static unsigned int vsync_empty_flag_odd;
+#endif
 
 static void vdac_power_level_store(char *para);
 SET_TV_CLASS_ATTR(vdac_power_level, vdac_power_level_store)
@@ -91,6 +107,11 @@ static int cur_fr_vsource = 0;
 
 #endif
 
+#ifdef CONFIG_AML_WSS
+struct class_attribute class_TV_attr_wss = __ATTR(wss, S_IRUGO | S_IWUSR,
+			aml_TV_attr_wss_show, aml_TV_attr_wss_store);
+#endif /*CONFIG_AML_WSS*/
+
 static int tv_vdac_power_level;
 
 static DEFINE_MUTEX(setmode_mutex);
@@ -179,7 +200,9 @@ static void cvbs_cntl_output(unsigned int open)
 		/* must enable adc bandgap, the adc ref signal for demod */
 		vdac_enable(0, 0x8);
 	} else if (open == 1) { /* open */
-		if (cpu_after_eq(MESON_CPU_MAJOR_ID_GXL))
+		if (cpu_after_eq(MESON_CPU_MAJOR_ID_TXL))
+			cntl0 = 0x620001;
+		else if (cpu_after_eq(MESON_CPU_MAJOR_ID_GXL))
 			cntl0 = 0xb0001;
 		else
 			cntl0 = 0x1;
@@ -244,6 +267,12 @@ static void cvbs_performance_enhancement(enum tvmode_e mode)
 		index = (index >= max) ? 0 : index;
 		s = tvregs_576cvbs_performance_gxtvbb[index];
 		type = 5;
+	} else if (cpu_after_eq(MESON_CPU_MAJOR_ID_TXL)) {
+		max = sizeof(tvregs_576cvbs_performance_txl)
+			/ sizeof(struct reg_s *);
+		index = (index >= max) ? 0 : index;
+		s = tvregs_576cvbs_performance_txl[index];
+		type = 8;
 	} else if (cpu_after_eq(MESON_CPU_MAJOR_ID_GXL)) {
 		if (is_meson_gxl_package_905L()) {
 			max = sizeof(tvregs_576cvbs_performance_905l)
@@ -499,9 +528,10 @@ static void tv_out_late_open_vdac(enum tvmode_e mode)
 
 static void tv_out_enable_cvbs_gate(void)
 {
-	tv_out_hiu_set_mask(HHI_GCLK_OTHER,
+	/*do it by vpu ctrl*/
+	/*tv_out_hiu_set_mask(HHI_GCLK_OTHER,
 		(1<<DAC_CLK) | (1<<GCLK_VENCI_INT) |
-		(1<<VCLK2_VENCI1) | (1<<VCLK2_VENCI));
+		(1<<VCLK2_VENCI1) | (1<<VCLK2_VENCI));*/
 	tv_out_hiu_set_mask(HHI_VID_CLK_CNTL2,
 		(1<<ENCI_GATE_VCLK) | (1<<VDAC_GATE_VCLK));
 }
@@ -536,7 +566,18 @@ int tv_out_setmode(enum tvmode_e mode)
 	tv_out_set_clk_gate(mode);
 	tv_out_init_off(mode);
 	/* Before setting clk for CVBS, disable ENCP/I to avoid hungup */
-	tv_out_reg_write(ENCP_VIDEO_EN, 0);
+	switch (mode) {
+	case TVMODE_480I:
+	case TVMODE_480I_RPT:
+	case TVMODE_480CVBS:
+	case TVMODE_576I:
+	case TVMODE_576I_RPT:
+	case TVMODE_576CVBS:
+		tv_out_reg_write(ENCP_VIDEO_EN, 0);
+		break;
+	default:
+		break;
+	}
 	tv_out_reg_write(ENCI_VIDEO_EN, 0);
 	tv_out_set_clk(mode);
 	ret = tv_out_set_venc(mode);
@@ -566,12 +607,111 @@ static const enum tvmode_e vmode_tvmode_map(enum vmode_e mode)
 	return TVMODE_MAX;
 }
 
+static int vout_open(struct inode *inode, struct file *file)
+{
+	struct disp_module_info_s *dinfo;
+	/* Get the per-device structure that contains this cdev */
+	dinfo = container_of(inode->i_cdev, struct disp_module_info_s, cdev);
+	file->private_data = dinfo;
+	return 0;
+}
+
+static int vout_release(struct inode *inode, struct file *file)
+{
+	file->private_data = NULL;
+	return 0;
+}
+
+static long vout_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	long ret = 0;
+#ifdef CONFIG_AML_VOUT_CC_BYPASS
+	unsigned int CC_2byte_data = 0;
+	unsigned long flags = 0;
+	void __user *argp = (void __user *)arg;
+#endif
+	vout_log_info("[tv..] %s: cmd_nr = 0x%x\n",
+			__func__, _IOC_NR(cmd));
+	if (_IOC_TYPE(cmd) != _TM_V) {
+		vout_log_err("%s invalid command: %u\n", __func__, cmd);
+		return -ENOSYS;
+	}
+	switch (cmd) {
+#ifdef CONFIG_AML_VOUT_CC_BYPASS
+	case VOUT_IOC_CC_OPEN:
+		spin_lock_irqsave(&tvout_clk_lock, flags);
+		memset(&CC_ringbuf, 0, sizeof(struct CCring_MGR_s));
+		spin_unlock_irqrestore(&tvout_clk_lock, flags);
+		tv_out_reg_setb(ENCI_VBI_SETTING, 0x3, 0, 2);
+		break;
+	case VOUT_IOC_CC_CLOSE:
+		spin_lock_irqsave(&tvout_clk_lock, flags);
+		memset(&CC_ringbuf, 0, sizeof(struct CCring_MGR_s));
+		spin_unlock_irqrestore(&tvout_clk_lock, flags);
+		tv_out_reg_setb(ENCI_VBI_SETTING, 0x0, 0, 2);
+		break;
+	case VOUT_IOC_CC_DATA: {
+		struct vout_CCparm_s parm = {0};
+		spin_lock_irqsave(&tvout_clk_lock, flags);
+		if (copy_from_user(&parm, argp,
+				sizeof(struct vout_CCparm_s))) {
+			vout_log_err("VOUT_IOC_CC_DATAinvalid parameter\n");
+			ret = -EFAULT;
+			spin_unlock_irqrestore(&tvout_clk_lock, flags);
+			break;
+		}
+
+		if (parm.type != 0) {
+			spin_unlock_irqrestore(&tvout_clk_lock, flags);
+			break;
+		}
+		/*cc standerd:nondisplay control byte + display control byte
+		our chip high-low 16bits is opposite*/
+		CC_2byte_data = parm.data2 << 8 | parm.data1;
+		if ((CC_ringbuf.wp + 1)%MAX_RING_BUFF_LEN != CC_ringbuf.rp) {
+			CC_ringbuf.CCdata[CC_ringbuf.wp].type = parm.type;
+			CC_ringbuf.CCdata[CC_ringbuf.wp].data = CC_2byte_data;
+			CC_ringbuf.wp = (CC_ringbuf.wp + 1)%MAX_RING_BUFF_LEN;
+			/*vout_log_info("CCringbuf Write :0x%x wp:%d\n",
+						CC_2byte_data, CC_ringbuf.wp);*/
+		}
+		else
+			vout_log_err("CCringbuf is FULL!! can't write.\n");
+
+		spin_unlock_irqrestore(&tvout_clk_lock, flags);
+		break;
+	}
+#endif
+	default:
+		ret = -ENOIOCTLCMD;
+		vout_log_err("%s %d is not supported command\n",
+				__func__, cmd);
+		break;
+	}
+	vout_log_info("vout_ioctl..out.ret=0x%lx\n", ret);
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static long vout_compat_ioctl(struct file *file, unsigned int cmd,
+	unsigned long arg)
+{
+	unsigned long ret;
+	arg = (unsigned long)compat_ptr(arg);
+	ret = vout_ioctl(file, cmd, arg);
+	return ret;
+}
+#endif
+
 static const struct file_operations am_tv_fops = {
-	.open	= NULL,
+	.open	= vout_open,
 	.read	= NULL,/* am_tv_read, */
 	.write	= NULL,
-	.unlocked_ioctl	= NULL,/* am_tv_ioctl, */
-	.release	= NULL,
+	.unlocked_ioctl	= vout_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = vout_compat_ioctl,
+#endif
+	.release	= vout_release,
 	.poll		= NULL,
 };
 
@@ -591,8 +731,6 @@ static const struct vinfo_s *get_valid_vinfo(char  *mode)
 			}
 		}
 	}
-	if (vinfo)
-		strcpy(vinfo->ext_name, mode);
 	return vinfo;
 }
 
@@ -740,6 +878,23 @@ static void tv_out_vpu_power_ctrl(int status)
 		release_vpu_clk_vmod(vpu_mod);
 	}
 }
+
+static void tv_out_vpu_gate_ctrl(int status)
+{
+	int vpu_mod;
+
+	if (get_cpu_type() < MESON_CPU_MAJOR_ID_M8)
+		return;
+
+	if (info->vinfo == NULL)
+		return;
+	vpu_mod = tv_out_enci_is_required(info->vinfo->mode);
+	vpu_mod = (vpu_mod) ? VPU_VENCI : VPU_VENCP;
+	if (status)
+		switch_vpu_clk_gate_vmod(vpu_mod, VPU_CLK_GATE_ON);
+	else
+		switch_vpu_clk_gate_vmod(vpu_mod, VPU_CLK_GATE_OFF);
+}
 #endif
 
 static int tv_set_current_vmode(enum vmode_e mode)
@@ -782,6 +937,7 @@ static int tv_set_current_vmode(enum vmode_e mode)
 
 #ifdef CONFIG_AML_VPU
 	tv_out_vpu_power_ctrl(1);
+	tv_out_vpu_gate_ctrl(1);
 #endif
 	tv_out_reg_write(VPP_POSTBLEND_H_SIZE, info->vinfo->width);
 	if (mode & VMODE_INIT_BIT_MASK) {
@@ -821,6 +977,7 @@ static int tv_module_disable(enum vmode_e cur_vmod)
 
 #ifdef CONFIG_AML_VPU
 	tv_out_vpu_power_ctrl(0);
+	tv_out_vpu_gate_ctrl(0);
 #endif
 	/* video_dac_disable(); */
 	return 0;
@@ -1162,6 +1319,29 @@ static int tv_set_vframe_rate_end_hint(void)
 	return 0;
 }
 
+static int tv_set_vframe_rate_policy(int policy)
+{
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	if ((policy >= 0) && (policy < 3)) {
+		fr_auto_policy = policy;
+	} else if (policy == 3) {
+		fr_auto_policy = fr_auto_policy_hold;
+		tv_set_vframe_rate_end_hint();
+	}
+	vout_log_info("%s: %d\n", __func__, fr_auto_policy);
+#endif
+	return 0;
+}
+
+static int tv_get_vframe_rate_policy(void)
+{
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	return fr_auto_policy;
+#else
+	return 0;
+#endif
+}
+
 #ifdef CONFIG_PM
 static int tv_suspend(void)
 {
@@ -1191,6 +1371,8 @@ static struct vout_server_s tv_server = {
 		.disable = tv_module_disable,
 		.set_vframe_rate_hint = tv_set_vframe_rate_hint,
 		.set_vframe_rate_end_hint = tv_set_vframe_rate_end_hint,
+		.set_vframe_rate_policy = tv_set_vframe_rate_policy,
+		.get_vframe_rate_policy = tv_get_vframe_rate_policy,
 #ifdef CONFIG_PM
 		.vout_suspend = tv_suspend,
 		.vout_resume = tv_resume,
@@ -1278,10 +1460,10 @@ static void vdac_power_level_store(char *para)
  */
 static void policy_framerate_automation_store(char *para)
 {
-	int policy = 0;
+	unsigned long policy = 0;
 	int ret = 0;
-	ret = kstrtoul(para, 10, (unsigned long *)&policy);
-	if ((policy >= 0) && (policy < 3)) {
+	ret = kstrtoul(para, 10, &policy);
+	if (policy < 3) {
 		fr_auto_policy_hold = policy;
 		fr_auto_policy = fr_auto_policy_hold;
 		snprintf(policy_fr_auto_switch, 40, "%d\n", fr_auto_policy);
@@ -1293,10 +1475,10 @@ static void policy_framerate_automation_store(char *para)
 
 static void policy_framerate_automation_switch_store(char *para)
 {
-	int policy = 0;
+	unsigned long policy = 0;
 	int ret = 0;
-	ret = kstrtoul(para, 10, (unsigned long *)&policy);
-	if ((policy >= 0) && (policy < 3)) {
+	ret = kstrtoul(para, 10, &policy);
+	if (policy < 3) {
 		fr_auto_policy = policy;
 	} else if (policy == 3) {
 		fr_auto_policy = fr_auto_policy_hold;
@@ -1643,24 +1825,41 @@ static  struct  class_attribute   *tv_attr[] = {
 	&class_TV_attr_policy_fr_auto_switch,
 #endif
 	&class_TV_attr_debug,
+#ifdef CONFIG_AML_WSS
+	&class_TV_attr_wss,
+#endif
 };
 
-
-
 static int create_tv_attr(struct disp_module_info_s *info)
 {
 	/* create base class for display */
 	int i;
+	int ret = 0;
 	info->base_class = class_create(THIS_MODULE, info->name);
 	if (IS_ERR(info->base_class)) {
-		vout_log_err("create tv display class fail\n");
-		return  -1;
+		ret = PTR_ERR(info->base_class);
+		goto fail_create_class;
 	}
 	/* create class attr */
 	for (i = 0; i < ARRAY_SIZE(tv_attr); i++) {
-		if (class_create_file(info->base_class, tv_attr[i]))
-			vout_log_err("create disp attribute %s fail\n",
-				     tv_attr[i]->attr.name);
+		if (class_create_file(info->base_class, tv_attr[i]) < 0)
+			goto fail_class_create_file;
+	}
+	cdev_init(&info->cdev, &am_tv_fops);
+	info->cdev.owner = THIS_MODULE;
+	ret = cdev_add(&info->cdev, info->devno, 1);
+	if (ret)
+		goto fail_add_cdev;
+
+	/*info->dev = device_create(info->base_class, NULL,
+				MKDEV(info->major, 0), NULL, info->name);*/
+	info->dev = device_create(info->base_class, NULL, info->devno,
+			NULL, info->name);
+	if (IS_ERR(info->dev)) {
+		ret = PTR_ERR(info->dev);
+		goto fail_create_device;
+	} else {
+		vout_log_info("create cdev %s\n", info->name);
 	}
 
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
@@ -1668,6 +1867,22 @@ static int create_tv_attr(struct disp_module_info_s *info)
 	sprintf(policy_fr_auto_switch, "%d", DEFAULT_POLICY_FR_AUTO);
 #endif
 	return 0;
+
+fail_create_device:
+	vout_log_info("[tv.] : tv device create error.\n");
+	cdev_del(&info->cdev);
+fail_add_cdev:
+	vout_log_info("[tv.] : tv add device error.\n");
+	kfree(info);
+fail_class_create_file:
+	vout_log_info("[tv.] : tv class create file error.\n");
+	for (i = 0; i < ARRAY_SIZE(tv_attr); i++)
+		class_remove_file(info->base_class, tv_attr[i]);
+	class_destroy(info->base_class);
+fail_create_class:
+	vout_log_info("[tv.] : tv class create error.\n");
+	unregister_chrdev_region(info->devno, 1);
+	return ret;
 }
 /* **************************************************** */
 
@@ -1691,9 +1906,114 @@ static struct syscore_ops tvconf_ops = {
 };
 #endif
 
+#ifdef CONFIG_AML_VOUT_CC_BYPASS
+static irqreturn_t tvout_vsync_isr(int irq, void *dev_id)
+{
+	unsigned int CC_2byte_data;
+	unsigned long flags = 0;
+	struct vout_CCparm_s parm = {0};
+
+	spin_lock_irqsave(&tvout_clk_lock, flags);
+	if (CC_ringbuf.rp != CC_ringbuf.wp) {
+		parm.type = CC_ringbuf.CCdata[CC_ringbuf.rp].type;
+		CC_2byte_data = CC_ringbuf.CCdata[CC_ringbuf.rp].data;
+		vsync_empty_flag = 0;
+		vsync_empty_flag_evn = 0;
+		vsync_empty_flag_odd = 0;
+	} else {
+		if (vsync_empty_flag == 0) {
+			if ((tv_out_reg_read(ENCI_INFO_READ)&
+							0x20000000) == 0x0) {
+				tv_out_reg_write(ENCI_VBI_CCDT_EVN, 0x8080);
+				vsync_empty_flag_evn = 1;
+				/*vout_log_info("empty!W EVN 0.encinfo:0x%x\n",
+				tv_out_reg_read(ENCI_INFO_READ));*/
+			} else {
+				tv_out_reg_write(ENCI_VBI_CCDT_ODD, 0x8080);
+				vsync_empty_flag_odd = 1;
+				/*vout_log_info("empty! W ODD 0.encinfo:0x%x\n",
+				tv_out_reg_read(ENCI_INFO_READ));*/
+			}
+			vsync_empty_flag = vsync_empty_flag_evn &
+					vsync_empty_flag_odd;
+		}
+		spin_unlock_irqrestore(&tvout_clk_lock, flags);
+		return IRQ_HANDLED;
+	}
+
+	if (parm.type == 0) {
+		if ((((CC_2byte_data>>8)&0x7f) >= 0x1) &&
+				(((CC_2byte_data>>8)&0x7f) < 0x10)) {
+			/*vout_log_info("W xds_odd_DATA:0x%x\n",
+				CC_2byte_data);*/
+			if ((tv_out_reg_read(ENCI_INFO_READ)&
+							0x20000000) != 0x0) {
+				tv_out_reg_write(ENCI_VBI_CCDT_ODD,
+								CC_2byte_data);
+				if (((tv_out_reg_read(ENCI_INFO_READ)>>16)&
+							0xff) <= 0x15)
+					CC_ringbuf.rp = (CC_ringbuf.rp +
+							1)%MAX_RING_BUFF_LEN;
+				/*else
+					vout_log_info("enci xds send late\n");*/
+			} else {
+				/*vout_log_info("ENV VYSNC.encinfo:0x%x.\n",
+					tv_out_reg_read(ENCI_INFO_READ));*/
+				tv_out_reg_write(ENCI_VBI_CCDT_ODD, 0x8080);
+			}
+		} else {
+			if ((tv_out_reg_read(ENCI_INFO_READ)&
+						0x20000000) == 0x0){
+				/*vout_log_info("W ENV_DATA:0x%x, rp:%d\n",
+						CC_2byte_data, CC_ringbuf.rp);*/
+				tv_out_reg_write(ENCI_VBI_CCDT_EVN,
+						CC_2byte_data);
+				if (((tv_out_reg_read(ENCI_INFO_READ)>>16)&
+							0xff) <= 0x15)
+					CC_ringbuf.rp = (CC_ringbuf.rp +
+						1)%MAX_RING_BUFF_LEN;
+				/*else
+					vout_log_info("enci ENV send late\n");*/
+			} else {
+				/*vout_log_info("now ODD VYSNC.encinfo:0x%x.\n",
+					tv_out_reg_read(ENCI_INFO_READ));*/
+				tv_out_reg_write(ENCI_VBI_CCDT_EVN, 0x8080);
+			}
+		}
+	}
+#if 0
+	else if (parm.type == 1) {
+		if ((tv_out_reg_read(ENCI_INFO_READ)&0x20000000) != 0x0) {
+			/*vout_log_info("W ODD_DATA:0x%x, rp:%d\n",
+					CC_2byte_data, CC_ringbuf.rp);*/
+			tv_out_reg_write(ENCI_VBI_CCDT_ODD,
+					CC_2byte_data);
+			/*vout_log_info("R ODD ENCI_INFO:0x%x\n",
+					tv_out_reg_read(ENCI_INFO_READ));*/
+			if (((tv_out_reg_read(ENCI_INFO_READ)>>16)&
+					0xff) <= 0x15)
+					CC_ringbuf.rp = (CC_ringbuf.rp +
+						1)%MAX_RING_BUFF_LEN;
+				/*else
+					vout_log_info("enci ODD send late\n");*/
+		} else {
+			/*vout_log_info("now ENV VYSNC.encinfo:0x%x.\n",
+					tv_out_reg_read(ENCI_INFO_READ));*/
+			tv_out_reg_write(ENCI_VBI_CCDT_ODD, 0x8080);
+		}
+	}
+#endif
+	else
+		vout_log_err("vsync_isr.type:%d Unknown\n",
+			parm.type);
+	spin_unlock_irqrestore(&tvout_clk_lock, flags);
+	return IRQ_HANDLED;
+}
+#endif
+
 static int tvout_probe(struct platform_device *pdev)
 {
-	int  ret;
+	int ret = 0;
 #ifdef CONFIG_INSTABOOT
 	INIT_LIST_HEAD(&tvconf_ops.node);
 	register_syscore_ops(&tvconf_ops);
@@ -1701,22 +2021,39 @@ static int tvout_probe(struct platform_device *pdev)
 	tv_out_ioremap();
 	info = &disp_module_info;
 	vout_log_info("%s\n", __func__);
+#ifdef CONFIG_AML_VOUT_CC_BYPASS
+	memset(&CC_ringbuf, 0, sizeof(struct CCring_MGR_s));
+	CC_ringbuf.max_len = MAX_RING_BUFF_LEN;
+	spin_lock_init(&tvout_clk_lock);
+#endif
 	sprintf(info->name, TV_CLASS_NAME);
-	ret = register_chrdev(0, info->name, &am_tv_fops);
+	/*ret = register_chrdev(0, info->name, &am_tv_fops);*/
+	ret = alloc_chrdev_region(&info->devno, 0, 1, info->name);
 	if (ret < 0) {
-		vout_log_err("register char dev tv error\n");
+		vout_log_err("alloc_chrdev_region error\n");
 		return  ret;
 	}
-	info->major = ret;
+	/*info->major = ret;*/
 	_init_vout();
-	vout_log_err("major number %d for disp\n", ret);
+	vout_log_err("chrdev devno %d for disp\n", info->devno);
 	if (vout_register_server(&tv_server))
 		vout_log_err("register tv module server fail\n");
 	else
 		vout_log_info("register tv module server ok\n");
-	create_tv_attr(info);
-
+	ret = create_tv_attr(info);
+	if (ret < 0) {
+		vout_log_err("create_tv_attr error\n");
+		return -1;
+	}
+#ifdef CONFIG_AML_VOUT_CC_BYPASS
+	if (request_irq(INT_VIU_VSYNC, &tvout_vsync_isr,
+		IRQF_SHARED, "tvout_vsync", (void *)"tvout_vsync")) {
+		vout_log_err("can't request vsync_irq for tvout\n");
+	} else
+		vout_log_info("request tvout vsync_irq successful\n");
+#endif
 	vout_log_info("%s OK\n", __func__);
+
 	return 0;
 }
 
@@ -1724,13 +2061,17 @@ static int tvout_remove(struct platform_device *pdev)
 {
 	int i;
 
+#ifdef CONFIG_AML_VOUT_CC_BYPASS
+	free_irq(INT_VIU_VSYNC, (void *)"tvout_vsync");
+#endif
 	if (info->base_class) {
 		for (i = 0; i < ARRAY_SIZE(tv_attr); i++)
 			class_remove_file(info->base_class, tv_attr[i]);
 		class_destroy(info->base_class);
 	}
 	if (info) {
-		unregister_chrdev(info->major, info->name);
+		/*unregister_chrdev(info->major, info->name);*/
+		cdev_del(&info->cdev);
 		kfree(info);
 	}
 	vout_unregister_server(&tv_server);
@@ -1766,7 +2107,10 @@ static int __init tv_init_module(void)
 		vout_log_err("%s failed to register module\n", __func__);
 		return -ENODEV;
 	}
-
+#ifdef CONFIG_AML_VOUT_CC_BYPASS
+	memset(&CC_ringbuf, 0, sizeof(struct CCring_MGR_s));
+	CC_ringbuf.max_len = MAX_RING_BUFF_LEN;
+#endif
 	return 0;
 }
 
diff --git a/drivers/amlogic/display/vout/tv_vout.h b/drivers/amlogic/display/vout/tv_vout.h
index 3045d19..8daea61 100644
--- a/drivers/amlogic/display/vout/tv_vout.h
+++ b/drivers/amlogic/display/vout/tv_vout.h
@@ -25,6 +25,14 @@
 #define TV_CLASS_NAME	"tv"
 #define	MAX_NUMBER_PARA  10
 
+#define _TM_V 'V'
+#ifdef CONFIG_AML_VOUT_CC_BYPASS
+#define MAX_RING_BUFF_LEN 128
+#define VOUT_IOC_CC_OPEN           _IO(_TM_V, 0x01)
+#define VOUT_IOC_CC_CLOSE          _IO(_TM_V, 0x02)
+#define VOUT_IOC_CC_DATA           _IOW(_TM_V, 0x03, struct vout_CCparm_s)
+#endif
+
 #define print_info(fmt, args...) pr_info(fmt, ##args)
 
 #define SHOW_INFO(name) \
@@ -55,14 +63,38 @@ __ATTR(name, S_IRUGO|S_IWUSR, \
 		aml_TV_attr_##name##_show, aml_TV_attr_##name##_store);
 
 struct disp_module_info_s {
-	unsigned int major;  /* dev major number */
+	/* unsigned int major;  dev major number */
 	struct vinfo_s *vinfo;
 	char name[20];
+	struct cdev   cdev;
+	dev_t         devno;
 	struct class  *base_class;
+	struct device *dev;
 };
 
 static  DEFINE_MUTEX(TV_mutex);
 
+#ifdef CONFIG_AML_VOUT_CC_BYPASS
+struct CCparm_s {
+	unsigned int type;
+	unsigned int data;
+};
+
+struct CCring_MGR_s {
+	unsigned int max_len;
+	unsigned int rp;
+	unsigned int wp;
+	int over_flag;
+	struct CCparm_s CCdata[MAX_RING_BUFF_LEN];
+};
+
+struct vout_CCparm_s {
+	unsigned int type;
+	unsigned char data1;
+	unsigned char data2;
+};
+#endif
+
 struct vmode_tvmode_tab_s {
 	enum tvmode_e tvmode;
 	enum vmode_e  mode;
@@ -99,13 +131,6 @@ static struct vmode_tvmode_tab_s mode_tab[] = {
 	{TVMODE_4K2K_SMPTE_60HZ_Y420, VMODE_4K2K_SMPTE_60HZ_Y420},
 	{TVMODE_4K2K_60HZ_Y420, VMODE_4K2K_60HZ_Y420},
 	{TVMODE_4K2K_50HZ_Y420, VMODE_4K2K_50HZ_Y420},
-	{TVMODE_4K2K_50HZ_Y420_10BIT, VMODE_4K2K_50HZ_Y420_10BIT},
-	{TVMODE_4K2K_60HZ_Y420_10BIT, VMODE_4K2K_60HZ_Y420_10BIT},
-	{TVMODE_4K2K_50HZ_Y422_10BIT, VMODE_4K2K_50HZ_Y422_10BIT},
-	{TVMODE_4K2K_60HZ_Y422_10BIT, VMODE_4K2K_60HZ_Y422_10BIT},
-	{TVMODE_4K2K_24HZ_Y444_10BIT, VMODE_4K2K_24HZ_Y444_10BIT},
-	{TVMODE_4K2K_25HZ_Y444_10BIT, VMODE_4K2K_25HZ_Y444_10BIT},
-	{TVMODE_4K2K_30HZ_Y444_10BIT, VMODE_4K2K_30HZ_Y444_10BIT},
 	{TVMODE_4K2K_60HZ, VMODE_4K2K_60HZ},
 	{TVMODE_4K2K_50HZ, VMODE_4K2K_50HZ},
 	{TVMODE_VGA, VMODE_VGA},
@@ -880,97 +905,6 @@ static struct vinfo_s tv_info[] = {
 		.video_clk         = 495000000,
 		.viu_color_fmt     = TVIN_YUV444,
 	},
-	{ /* VMODE_4K2K_60HZ_Y420_10BIT */
-		.name              = "2160p60hz42010bit",
-		.mode              = VMODE_4K2K_60HZ_Y420_10BIT,
-		.width             = 3840,
-		.height            = 2160,
-		.field_height      = 2160,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 60,
-		.sync_duration_den = 1,
-		.video_clk         = 594000000,
-		.viu_color_fmt     = TVIN_YUV444,
-	},
-	{ /* VMODE_4K2K_50HZ_Y420_10BIT */
-		.name              = "2160p50hz42010bit",
-		.mode              = VMODE_4K2K_50HZ_Y420_10BIT,
-		.width             = 3840,
-		.height            = 2160,
-		.field_height      = 2160,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 50,
-		.sync_duration_den = 1,
-		.video_clk         = 594000000,
-		.viu_color_fmt     = TVIN_YUV444,
-	},
-	{ /* VMODE_4K2K_60HZ_Y422_10BIT */
-		.name              = "2160p60hz42210bit",
-		.mode              = VMODE_4K2K_60HZ_Y422_10BIT,
-		.width             = 3840,
-		.height            = 2160,
-		.field_height      = 2160,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 60,
-		.sync_duration_den = 1,
-		.video_clk         = 594000000,
-		.viu_color_fmt     = TVIN_YUV444,
-	},
-	{ /* VMODE_4K2K_50HZ_Y420_10BIT */
-		.name              = "2160p50hz42210bit",
-		.mode              = VMODE_4K2K_50HZ_Y422_10BIT,
-		.width             = 3840,
-		.height            = 2160,
-		.field_height      = 2160,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 50,
-		.sync_duration_den = 1,
-		.video_clk         = 594000000,
-		.viu_color_fmt     = TVIN_YUV444,
-	},
-	{ /* VMODE_4K2K_24HZ_Y444_10BIT */
-		.name              = "2160p24hz44410bit",
-		.mode              = VMODE_4K2K_24HZ_Y444_10BIT,
-		.width             = 3840,
-		.height            = 2160,
-		.field_height      = 2160,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 24,
-		.sync_duration_den = 1,
-		.video_clk         = 297000000,
-		.viu_color_fmt     = TVIN_YUV444,
-	},
-	{ /* VMODE_4K2K_25HZ_Y444_10BIT */
-		.name              = "2160p25hz44410bit",
-		.mode              = VMODE_4K2K_25HZ_Y444_10BIT,
-		.width             = 3840,
-		.height            = 2160,
-		.field_height      = 2160,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 25,
-		.sync_duration_den = 1,
-		.video_clk         = 297000000,
-		.viu_color_fmt     = TVIN_YUV444,
-	},
-	{ /* VMODE_4K2K_30HZ_Y444_10BIT */
-		.name              = "2160p30hz44410bit",
-		.mode              = VMODE_4K2K_30HZ_Y444_10BIT,
-		.width             = 3840,
-		.height            = 2160,
-		.field_height      = 2160,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 30,
-		.sync_duration_den = 1,
-		.video_clk         = 297000000,
-		.viu_color_fmt     = TVIN_YUV444,
-	},
 	{ /* VMODE_4K2K_60HZ_Y420 */
 		.name              = "2160p60hz420",
 		.mode              = VMODE_4K2K_60HZ_Y420,
@@ -1231,6 +1165,112 @@ static struct vinfo_s tv_info[] = {
 		.video_clk         = 148500000,
 		.viu_color_fmt     = TVIN_YUV444,
 	},
+/* VMODE for 3D Frame Packing */
+	{ /* VMODE_1080FP60HZ */
+		.name              = "1080fp60hz",
+		.mode              = VMODE_1080FP60HZ,
+		.width             = 1920,
+		.height            = 1080 + 1125,
+		.field_height      = 1080 + 1125,
+		.aspect_ratio_num  = 16,
+		.aspect_ratio_den  = 9,
+		.sync_duration_num = 60,
+		.sync_duration_den = 1,
+		.video_clk         = 297000000,
+		.viu_color_fmt     = TVIN_YUV444,
+	},
+	{ /* VMODE_1080FP50HZ */
+		.name              = "1080fp50hz",
+		.mode              = VMODE_1080FP50HZ,
+		.width             = 1920,
+		.height            = 1080 + 1125,
+		.field_height      = 1080 + 1125,
+		.aspect_ratio_num  = 16,
+		.aspect_ratio_den  = 9,
+		.sync_duration_num = 50,
+		.sync_duration_den = 1,
+		.video_clk         = 297000000,
+		.viu_color_fmt     = TVIN_YUV444,
+	},
+	{ /* VMODE_1080FP30HZ */
+		.name              = "1080fp30hz",
+		.mode              = VMODE_1080FP30HZ,
+		.width             = 1920,
+		.height            = 1080 + 1125,
+		.field_height      = 1080 + 1125,
+		.aspect_ratio_num  = 16,
+		.aspect_ratio_den  = 9,
+		.sync_duration_num = 30,
+		.sync_duration_den = 1,
+		.video_clk         = 148500000,
+		.viu_color_fmt     = TVIN_YUV444,
+	},
+	{ /* VMODE_1080FP25HZ */
+		.name              = "1080fp25hz",
+		.mode              = VMODE_1080FP25HZ,
+		.width             = 1920,
+		.height            = 1080 + 1125,
+		.field_height      = 1080 + 1125,
+		.aspect_ratio_num  = 16,
+		.aspect_ratio_den  = 9,
+		.sync_duration_num = 25,
+		.sync_duration_den = 1,
+		.video_clk         = 148500000,
+		.viu_color_fmt     = TVIN_YUV444,
+	},
+	{ /* VMODE_1080FP24HZ */
+		.name              = "1080fp24hz",
+		.mode              = VMODE_1080FP24HZ,
+		.width             = 1920,
+		.height            = 1080 + 1125,
+		.field_height      = 1080 + 1125,
+		.aspect_ratio_num  = 16,
+		.aspect_ratio_den  = 9,
+		.sync_duration_num = 24,
+		.sync_duration_den = 1,
+		.video_clk         = 148500000,
+		.viu_color_fmt     = TVIN_YUV444,
+	},
+	{ /* VMODE_720FP60HZ */
+		.name              = "720fp60hz",
+		.mode              = VMODE_720FP60HZ,
+		.width             = 1280,
+		.height            = 720 + 750,
+		.field_height      = 720 + 750,
+		.aspect_ratio_num  = 16,
+		.aspect_ratio_den  = 9,
+		.sync_duration_num = 60,
+		.sync_duration_den = 1,
+		.video_clk         = 148500000,
+		.viu_color_fmt     = TVIN_YUV444,
+	},
+	{ /* VMODE_720FP50HZ */
+		.name              = "720fp50hz",
+		.mode              = VMODE_720FP50HZ,
+		.width             = 1280,
+		.height            = 720 + 750,
+		.field_height      = 720 + 750,
+		.aspect_ratio_num  = 16,
+		.aspect_ratio_den  = 9,
+		.sync_duration_num = 50,
+		.sync_duration_den = 1,
+		.video_clk         = 148500000,
+		.viu_color_fmt     = TVIN_YUV444,
+	},
+/* VMODE for 3D Frame Packing END */
+	{ /* NULL mode, used as temporary witch mode state */
+		.name              = "null",
+		.mode              = VMODE_NULL,
+		.width             = 1920,
+		.height            = 1080,
+		.field_height      = 1080,
+		.aspect_ratio_num  = 16,
+		.aspect_ratio_den  = 9,
+		.sync_duration_num = 60,
+		.sync_duration_den = 1,
+		.video_clk         = 1485000000,
+		.viu_color_fmt     = TVIN_YUV444,
+	},
 };
 
 #endif
diff --git a/drivers/amlogic/display/vout/tvregs.h b/drivers/amlogic/display/vout/tvregs.h
index e2d4e42..155da6a 100644
--- a/drivers/amlogic/display/vout/tvregs.h
+++ b/drivers/amlogic/display/vout/tvregs.h
@@ -235,6 +235,36 @@ static const struct reg_s *tvregs_576cvbs_performance_905l[] = {
 	tvregs_576cvbs_china_mobile_905l
 };
 
+static const struct reg_s tvregs_576cvbs_china_sarft_txl[] = {
+	{ENCI_YC_DELAY,				0x333	},
+	{ENCI_VIDEO_SAT,			0xf4	},
+	{VENC_VDAC_DAC0_FILT_CTRL1,	0xfc48	},
+	{ENCI_SYNC_ADJ,				0x8c00	},
+	{MREG_END_MARKER,			0		}
+};
+
+static const struct reg_s tvregs_576cvbs_china_telecom_txl[] = {
+	{ENCI_YC_DELAY,				0x333	},
+	{ENCI_VIDEO_SAT,			0xf4	},
+	{VENC_VDAC_DAC0_FILT_CTRL1,	0xfc48	},
+	{ENCI_SYNC_ADJ,				0x8c00	},
+	{MREG_END_MARKER,			0		}
+};
+
+static const struct reg_s tvregs_576cvbs_china_mobile_txl[] = {
+	{ENCI_YC_DELAY,				0x333	},
+	{ENCI_VIDEO_SAT,			0xf4	},
+	{VENC_VDAC_DAC0_FILT_CTRL1,	0xfc48	},
+	{ENCI_SYNC_ADJ,				0x8c00	},
+	{MREG_END_MARKER,			0		}
+};
+
+static const struct reg_s *tvregs_576cvbs_performance_txl[] = {
+	tvregs_576cvbs_china_sarft_txl,
+	tvregs_576cvbs_china_telecom_txl,
+	tvregs_576cvbs_china_mobile_txl
+};
+
 #endif
 
 /* ALL REGISTERS WITH HDMITX MODE MOVE TO HDMITX DRIVER */
diff --git a/drivers/amlogic/display/vout/vdac_dev.c b/drivers/amlogic/display/vout/vdac_dev.c
index 796ff4f..0def80e 100644
--- a/drivers/amlogic/display/vout/vdac_dev.c
+++ b/drivers/amlogic/display/vout/vdac_dev.c
@@ -32,6 +32,9 @@
 #include <linux/amlogic/vout/vout_notify.h>
 #include <linux/io.h>
 #include <linux/mutex.h>
+#ifdef CONFIG_AML_VPU
+#include <linux/amlogic/vpu.h>
+#endif
 
 #define AMVDAC_NAME               "amvdac"
 #define AMVDAC_DRIVER_NAME        "amvdac"
@@ -67,6 +70,10 @@ static bool vdac_init_succ_flag;
 */
 static unsigned int pri_flag;
 
+#ifdef CONFIG_AML_VPU
+static unsigned int vpu_gate;
+#endif
+
 static unsigned int vdac_cntl0_bit9;
 module_param(vdac_cntl0_bit9, uint, 0644);
 MODULE_PARM_DESC(vdac_cntl0_bit9, "vdac_cntl0_bit9");
@@ -346,6 +353,56 @@ void vdac_set_ctrl0_ctrl1(unsigned int ctrl0, unsigned int ctrl1)
 }
 EXPORT_SYMBOL(vdac_set_ctrl0_ctrl1);
 
+#ifdef CONFIG_AML_VPU
+void vpu_clk_gate_set(bool on, unsigned int module_sel)
+{
+	bool enable = 0;
+	switch (module_sel & 0x1f) {
+	case VDAC_MODULE_ATV_DEMOD: /* dtv demod */
+		if (on)
+			vpu_gate |= VDAC_MODULE_ATV_DEMOD;
+		else
+			vpu_gate &= ~VDAC_MODULE_ATV_DEMOD;
+		break;
+	case VDAC_MODULE_DTV_DEMOD: /* atv demod */
+		if (on)
+			vpu_gate |= VDAC_MODULE_DTV_DEMOD;
+		else
+			vpu_gate &= ~VDAC_MODULE_DTV_DEMOD;
+		break;
+	case VDAC_MODULE_TVAFE: /* cvbs in demod */
+		if (on)
+			vpu_gate |= VDAC_MODULE_TVAFE;
+		else
+			vpu_gate &= ~VDAC_MODULE_TVAFE;
+		break;
+	case VDAC_MODULE_CVBS_OUT: /* cvbs in demod */
+		if (on)
+			vpu_gate |= VDAC_MODULE_CVBS_OUT;
+		else
+			vpu_gate &= ~VDAC_MODULE_CVBS_OUT;
+		break;
+	case VDAC_MODULE_AUDIO_OUT: /* audio out ctrl*/
+		if (on)
+			vpu_gate |= VDAC_MODULE_AUDIO_OUT;
+		else
+			vpu_gate &= ~VDAC_MODULE_AUDIO_OUT;
+		break;
+	default:
+		pr_err("module_sel: 0x%x wrong module index !! ", module_sel);
+		break;
+	}
+	if ((vpu_gate & 0x1f) == 0)
+		enable = 0;
+	else
+		enable = 1;
+	if (enable)
+		switch_vpu_clk_gate_vmod(VPU_VENC_DAC, VPU_CLK_GATE_ON);
+	else
+		switch_vpu_clk_gate_vmod(VPU_VENC_DAC, VPU_CLK_GATE_OFF);
+}
+#endif
+
 /* dac ctl,
  * module index: atv demod:0x01; dtv demod:0x02; tvafe:0x4; dac:0x8
 */
@@ -372,7 +429,7 @@ void vdac_enable(bool on, unsigned int module_sel)
 			pri_flag &= ~VDAC_MODULE_ATV_DEMOD;
 			if (pri_flag & VDAC_MODULE_CVBS_OUT)
 				break;
-			vdac_out_cntl0_bit0(0, 0x4);
+			vdac_out_cntl0_bit0(0, VDAC_MODULE_ATV_DEMOD);
 			/* Disable AFE output buffer */
 			vdac_hiu_reg_setb(HHI_VDAC_CNTL0, 0, 10, 1);
 			/* enable dac output */
@@ -442,6 +499,9 @@ void vdac_enable(bool on, unsigned int module_sel)
 		break;
 	}
 	mutex_unlock(&vdac_mutex);
+#ifdef CONFIG_AML_VPU
+	vpu_clk_gate_set(on, module_sel);
+#endif
 }
 EXPORT_SYMBOL(vdac_enable);
 
diff --git a/drivers/amlogic/display/vout/vinfo.c b/drivers/amlogic/display/vout/vinfo.c
index c3b024c..321d43d 100644
--- a/drivers/amlogic/display/vout/vinfo.c
+++ b/drivers/amlogic/display/vout/vinfo.c
@@ -53,9 +53,6 @@ static struct vmode_match_s vmode_match_table[] = {
 	{"1080p30hz",     VMODE_1080P_30HZ},
 	{"1080p50hz",     VMODE_1080P_50HZ},
 	{"1080p24hz",     VMODE_1080P_24HZ},
-	{"2160p30hz44410bit", VMODE_4K2K_30HZ_Y444_10BIT},
-	{"2160p25hz44410bit", VMODE_4K2K_25HZ_Y444_10BIT},
-	{"2160p24hz44410bit", VMODE_4K2K_24HZ_Y444_10BIT},
 	{"2160p30hz",     VMODE_4K2K_30HZ},
 	{"2160p25hz",     VMODE_4K2K_25HZ},
 	{"2160p24hz",     VMODE_4K2K_24HZ},
@@ -67,10 +64,6 @@ static struct vmode_match_s vmode_match_table[] = {
 	{"smpte60hz420",  VMODE_4K2K_SMPTE_60HZ_Y420},
 	{"smpte60hz",     VMODE_4K2K_SMPTE_60HZ},
 	{"4k2k5g",        VMODE_4K2K_FAKE_5G},
-	{"2160p60hz42010bit", VMODE_4K2K_60HZ_Y420_10BIT},
-	{"2160p50hz42010bit", VMODE_4K2K_50HZ_Y420_10BIT},
-	{"2160p60hz42210bit", VMODE_4K2K_60HZ_Y422_10BIT},
-	{"2160p50hz42210bit", VMODE_4K2K_50HZ_Y422_10BIT},
 	{"2160p60hz420",  VMODE_4K2K_60HZ_Y420},
 	{"2160p60hz",     VMODE_4K2K_60HZ},
 	{"2160p50hz420",  VMODE_4K2K_50HZ_Y420},
diff --git a/drivers/amlogic/display/vout/vout_notify.c b/drivers/amlogic/display/vout/vout_notify.c
index 6474ad3..739075c 100644
--- a/drivers/amlogic/display/vout/vout_notify.c
+++ b/drivers/amlogic/display/vout/vout_notify.c
@@ -199,6 +199,52 @@ int set_vframe_rate_end_hint(void)
 }
 EXPORT_SYMBOL(set_vframe_rate_end_hint);
 
+/*
+*interface export to client who want to notify about source fr_policy.
+*/
+int set_vframe_rate_policy(int policy)
+{
+	int r = -1;
+	struct vout_server_s  *p_server;
+
+	/* mutex_lock(&vout_mutex); */
+	list_for_each_entry(p_server, &vout_module.vout_server_list, list) {
+		if ((p_server->op.set_vframe_rate_policy != NULL) &&
+		    (p_server->op.set_vframe_rate_policy(policy) == 0)) {
+			/* mutex_unlock(&vout_mutex); */
+			return 0;
+		}
+	}
+
+	/* mutex_unlock(&vout_mutex); */
+
+	return r;
+}
+EXPORT_SYMBOL(set_vframe_rate_policy);
+
+/*
+*interface export to client who want to notify about source fr_policy.
+*/
+int get_vframe_rate_policy(void)
+{
+	int r = -1;
+	struct vout_server_s  *p_server;
+
+	/* mutex_lock(&vout_mutex); */
+	list_for_each_entry(p_server, &vout_module.vout_server_list, list) {
+		if (p_server->op.get_vframe_rate_policy != NULL) {
+			r = p_server->op.get_vframe_rate_policy();
+			/* mutex_unlock(&vout_mutex); */
+			return r;
+		}
+	}
+
+	/* mutex_unlock(&vout_mutex); */
+
+	return r;
+}
+EXPORT_SYMBOL(get_vframe_rate_policy);
+
 #ifdef CONFIG_SCREEN_ON_EARLY
 static int wake_up_flag;
 void wakeup_early_suspend_proc(void)
diff --git a/drivers/amlogic/display/vout/vout_serve.c b/drivers/amlogic/display/vout/vout_serve.c
index fae61b3..3eb53b5 100644
--- a/drivers/amlogic/display/vout/vout_serve.c
+++ b/drivers/amlogic/display/vout/vout_serve.c
@@ -83,8 +83,14 @@ static ssize_t axis_show(struct class *class, struct class_attribute *attr,
 			 char *buf);
 static ssize_t axis_store(struct class *class, struct class_attribute *attr,
 			  const char *buf, size_t count);
+static ssize_t fr_policy_show(struct class *class,
+		struct class_attribute *attr, char *buf);
+static ssize_t fr_policy_store(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t count);
 static CLASS_ATTR(mode, S_IWUSR | S_IRUGO, mode_show, mode_store);
 static CLASS_ATTR(axis, S_IWUSR | S_IRUGO, axis_show, axis_store);
+static CLASS_ATTR(fr_policy, S_IWUSR | S_IRUGO,
+		fr_policy_show, fr_policy_store);
 
 static ssize_t mode_show(struct class *class, struct class_attribute *attr,
 			 char *buf)
@@ -127,6 +133,38 @@ static ssize_t axis_store(struct class *class, struct class_attribute *attr,
 	return count;
 }
 
+static ssize_t fr_policy_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+	int policy;
+	int ret = 0;
+
+	policy = get_vframe_rate_policy();
+	ret = sprintf(buf, "%d\n", policy);
+
+	return ret;
+}
+
+static ssize_t fr_policy_store(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	int policy;
+	int ret = 0;
+
+	mutex_lock(&vout_mutex);
+	ret = sscanf(buf, "%d", &policy);
+	if (ret == 1) {
+		ret = set_vframe_rate_policy(policy);
+		if (ret)
+			pr_info("%s: %d failed\n", __func__, policy);
+	} else {
+		pr_info("%s: invalid data\n", __func__);
+		return -EINVAL;
+	}
+	mutex_unlock(&vout_mutex);
+	return count;
+}
+
 static int parse_para(const char *para, int para_num, int *result)
 {
 	char *token = NULL;
@@ -318,6 +356,7 @@ static ssize_t vout_attr_vinfo_show(struct class *class,
 		struct class_attribute *attr, char *buf)
 {
 	const struct vinfo_s *info = NULL;
+	ssize_t len = 0;
 
 	info = get_current_vinfo();
 	if (info == NULL) {
@@ -325,7 +364,7 @@ static ssize_t vout_attr_vinfo_show(struct class *class,
 		return sprintf(buf, "\n");
 	}
 
-	pr_info("current vinfo:\n"
+	len = sprintf(buf, "current vinfo:\n"
 		"    name:                  %s\n"
 		"    mode:                  %d\n"
 		"    width:                 %d\n"
@@ -338,14 +377,34 @@ static ssize_t vout_attr_vinfo_show(struct class *class,
 		"    screen_real_width:     %d\n"
 		"    screen_real_height:    %d\n"
 		"    video_clk:             %d\n"
-		"    viu_color_fmt:         %d\n",
+		"    viu_color_fmt:         %d\n\n",
 		info->name, info->mode,
 		info->width, info->height, info->field_height,
 		info->aspect_ratio_num, info->aspect_ratio_den,
 		info->sync_duration_num, info->sync_duration_den,
 		info->screen_real_width, info->screen_real_height,
 		info->video_clk, info->viu_color_fmt);
-	return sprintf(buf, "\n");
+	len += sprintf(buf+len, "hdr_info:\n"
+		"    present_flag          %d\n"
+		"    features              0x%x\n"
+		"    primaries             0x%x, 0x%x\n"
+		"                          0x%x, 0x%x\n"
+		"                          0x%x, 0x%x\n"
+		"    white_point           0x%x, 0x%x\n"
+		"    luminance             %d, %d\n\n",
+		info->master_display_info.present_flag,
+		info->master_display_info.features,
+		info->master_display_info.primaries[0][0],
+		info->master_display_info.primaries[0][1],
+		info->master_display_info.primaries[1][0],
+		info->master_display_info.primaries[1][1],
+		info->master_display_info.primaries[2][0],
+		info->master_display_info.primaries[2][1],
+		info->master_display_info.white_point[0],
+		info->master_display_info.white_point[1],
+		info->master_display_info.luminance[0],
+		info->master_display_info.luminance[1]);
+	return len;
 }
 
 static struct  class_attribute  class_attr_vinfo =
@@ -365,18 +424,20 @@ static int create_vout_attr(void)
 
 	/* create vout class attr files */
 	ret = class_create_file(vout_class, &class_attr_mode);
-
 	if (ret != 0)
-		vout_log_err("create class attr failed!\n");
+		vout_log_err("create class attr mode failed!\n");
 
 	ret = class_create_file(vout_class, &class_attr_axis);
+	if (ret != 0)
+		vout_log_err("create class attr axis failed!\n");
 
+	ret = class_create_file(vout_class, &class_attr_fr_policy);
 	if (ret != 0)
-		vout_log_err("create class attr failed!\n");
+		vout_log_err("create class attr fr_policy failed!\n");
 
 	ret = class_create_file(vout_class, &class_attr_vinfo);
 	if (ret != 0)
-		vout_log_err("create class attr failed!\n");
+		vout_log_err("create class attr vinfo failed!\n");
 
 	/*
 	 * init /sys/class/display/mode
@@ -527,6 +588,7 @@ static int meson_vout_remove(struct platform_device *pdev)
 #endif
 	class_remove_file(vout_class, &class_attr_mode);
 	class_remove_file(vout_class, &class_attr_axis);
+	class_remove_file(vout_class, &class_attr_fr_policy);
 	class_remove_file(vout_class, &class_attr_vinfo);
 	class_destroy(vout_class);
 	return 0;
diff --git a/drivers/amlogic/display/vout/wss.c b/drivers/amlogic/display/vout/wss.c
new file mode 100644
index 0000000..c6cde3d
--- /dev/null
+++ b/drivers/amlogic/display/vout/wss.c
@@ -0,0 +1,471 @@
+/*************************************************************
+ * Amlogic
+ * wss module: Wide Screen Signalling
+ *
+ * Copyright (C) 2010 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * Author:   jets.yan@amlogic
+ *
+ *
+ **************************************************************/
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/ctype.h>
+#include <linux/slab.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include "wss.h"
+#include "tv_out_reg.h"
+
+static void wss_set_output(unsigned int cmd, unsigned int mode,
+				unsigned int line, unsigned int data,
+				unsigned int start, unsigned length) {
+	int value;
+	pr_info("[%s], line = %d, data = 0x%x, start_bit = %d, length = %d\n",
+				__func__, line, data, start, length);
+	switch (cmd) {
+	case WSS_576I_CMD_CC:
+	case WSS_480I_CMD_CC:
+		tv_out_reg_write(ENCI_VBI_CCDT_EVN, data);
+		/*tv_out_reg_write(ENCI_VBI_CCDT_ODD, data);*/
+		/*480cvbs default envline 21,oddline 21
+		  576cvbs default envline 21,oddline 22*/
+		/*if( mode == 480 )
+			tv_out_reg_write(ENCI_VBI_CC525_LN, WSS_480I_CC_LINE);
+		else if( mode == 576 )
+			tv_out_reg_write(ENCI_VBI_CC625_LN, WSS_576I_CC_LINE);*/
+		tv_out_reg_setb(ENCI_VBI_SETTING, 0x1, 0, 2);
+		break;
+	default:
+		tv_out_reg_setb(ENCI_VBI_WSSDT, data, start, length);
+		value = tv_out_reg_read(ENCI_VBI_WSSDT);
+		if ((value&0xf) == 0x0)/* correct the bit3: odd_parity_bit */
+			tv_out_reg_setb(ENCI_VBI_WSSDT, 1, 3, 1);
+		tv_out_reg_write(ENCI_VBI_WSS_LN, line-1);
+		if (mode == 480)
+			tv_out_reg_setb(ENCI_VBI_SETTING, 0x3, 2, 2);
+		/* 480i, enable even field for line 20,
+			enable odd field for line 283 */
+		else if (mode == 576)
+			tv_out_reg_setb(ENCI_VBI_SETTING, 0x1, 2, 2);
+		/* 576i, should enable odd field for line 23 */
+		break;
+	}
+	return;
+}
+
+static void wss_close_output(unsigned int mode)
+{
+	pr_info("[%s] close mode = %d\n", __func__, mode);
+	tv_out_reg_setb(ENCI_VBI_SETTING, 0x0, 2, 2);
+
+	return;
+}
+
+/* for 576i, according to <ETSI EN 300294 V1.4.1> */
+
+static struct wss_info_t wss_info[] = {
+	/* cmd, line, start, length, mask, description */
+	{
+		WSS_576I_CMD_AR,
+		WSS_576I_LINE,
+		WSS_576I_AR_START,
+		WSS_576I_AR_LENGTH,
+		WSS_576I_AR_MASK,
+		"wss aspect ratio option:\n"
+		"0: full format 4:3\n"
+		"1: box 16:9 Top\n"
+		"2: box 14:9 Top\n"
+		"3: full format 4:3(shoot and protect 14:9 Centre)\n"
+		"4: box 14:9 Centre\n"
+		"5: box > 16:9 Centre\n"
+		"6: box 16:9 Centre\n"
+		"7: full format 16:9(anamorphic)\n"
+	},
+
+	{
+		WSS_576I_CMD_MODE,
+		WSS_576I_LINE,
+		WSS_576I_MODE_START,
+		WSS_576I_MODE_LENGTH,
+		WSS_576I_MODE_MASK,
+		"wss mode option:\n"
+		"0: Camera mode\n"
+		"1: film mode\n"
+	},
+
+	{
+		WSS_576I_CMD_CODING,
+		WSS_576I_LINE,
+		WSS_576I_CODING_START,
+		WSS_576I_CODING_LENGTH,
+		WSS_576I_CODING_MASK,
+		"wss coding option:\n"
+		"0: standard coding\n"
+		"1: Motion Adaptive Colour Plus\n"
+	},
+
+	{
+		WSS_576I_CMD_HELPER,
+		WSS_576I_LINE,
+		WSS_576I_HELPER_START,
+		WSS_576I_HELPER_LENGTH,
+		WSS_576I_HELPER_MASK,
+		"wss helper option:\n"
+		"0: no helper\n"
+		"1: modulated helper\n"
+	},
+
+	{
+		WSS_576I_CMD_TTX_SUBT,
+		WSS_576I_LINE,
+		WSS_576I_TTX_SUBT_START,
+		WSS_576I_TTX_SUBT_LENGTH,
+		WSS_576I_TTX_SUBT_MASK,
+		"wss ttx-subt option:\n"
+		"0: no subtitles within Teletext\n"
+		"1: subtitles within Teletext\n"
+	},
+
+	{
+		WSS_576I_CMD_OPEN_SUBT,
+		WSS_576I_LINE,
+		WSS_576I_OPEN_SUBT_START,
+		WSS_576I_OPEN_SUBT_LENGTH,
+		WSS_576I_OPEN_SUBT_MASK,
+		"wss open subtitle option:\n"
+		"0: no open subtitles\n"
+		"1: subtitles out of active image area\n"
+		"2: subtitles in active image area\n"
+		"3: reserved\n"
+	},
+
+	{
+		WSS_576I_CMD_SURROUND_SND,
+		WSS_576I_LINE,
+		WSS_576I_SURROUND_SND_START,
+		WSS_576I_SURROUND_SND_LENGTH,
+		WSS_576I_SURROUND_SND_MASK,
+		"wss surround sound option:\n"
+		"0: no surround sound information\n"
+		"1: surround sound mode\n"
+	},
+
+	{
+		WSS_576I_CMD_CGMS_A,
+		WSS_576I_LINE,
+		WSS_576I_CGMS_A_START,
+		WSS_576I_CGMS_A_LENGTH,
+		WSS_576I_CGMS_A_MASK,
+		"wss cgms option:\n"
+		"0: no copy right asserted or status unknown / copying not restricted\n"
+		"1: copy right asserted / copying not restricted\n"
+		"2: no copy right asserted or status unknown / copying restricted\n"
+		"3: copy right asserted / copying restricted\n"
+	},
+
+	{
+		WSS_576I_CMD_FULL,
+		WSS_576I_LINE,
+		WSS_576I_FULL_START,
+		WSS_576I_FULL_LENGTH,
+		WSS_576I_FULL_MASK,
+		"please input full wss data(14 bits)!\n"
+	},
+
+	{
+		WSS_576I_CMD_CC,
+		WSS_576I_CC_LINE,
+		WSS_576I_CC_START,
+		WSS_576I_CC_LENGTH,
+		WSS_576I_CC_MASK,
+		"please input a param to run this!ex: echo CC data > /sys/class/tv/wss\n"
+	},
+
+	{
+		WSS_480I_CMD_AR,
+		WSS_480I_LINE,
+		WSS_480I_AR_START,
+		WSS_480I_AR_LENGTH,
+		WSS_480I_AR_MASK,
+		"wss aspect ratio option:\n"
+		"0: 4:3 normal\n"
+		"1: 4:3 letter box\n"
+		"2: 16:9 normal\n"
+		"3: not defined\n"
+	},
+
+	{
+		WSS_480I_CMD_CGMS_A,
+		WSS_480I_LINE,
+		WSS_480I_CGMS_A_START,
+		WSS_480I_CGMS_A_LENGTH,
+		WSS_480I_CGMS_A_MASK,
+		"wss cgms option:\n"
+		"0: copying is permitted without restriction\n"
+		"1: Condition not to be used\n"
+		"2: one generation of copies may be made\n"
+		"3: no copying is permitted\n"
+	},
+
+	{
+		WSS_480I_CMD_PSP,
+		WSS_480I_LINE,
+		WSS_480I_PSP_START,
+		WSS_480I_PSP_LENGTH,
+		WSS_480I_PSP_MASK,
+		"wss psp option:\n"
+		"0: psp off\n"
+		"1: psp on, split burst off\n"
+		"2: psp on, 2-line split burst on\n"
+		"3: psp on, 4-line split burst on\n"
+	},
+
+	{
+		WSS_480I_CMD_PRE_RECORDED,
+		WSS_480I_LINE,
+		WSS_480I_PRE_RECORDED_START,
+		WSS_480I_PRE_RECORDED_LENGTH,
+		WSS_480I_PRE_RECORDED_MASK,
+		"wss analogue source bit option:\n"
+		"0: not analogue pre-recorded packaged medium\n"
+		"1: analogue pre-recorded packaged medium\n"
+	},
+
+	{
+		WSS_480I_CMD_CC,
+		WSS_480I_CC_LINE,
+		WSS_480I_CC_START,
+		WSS_480I_CC_LENGTH,
+		WSS_480I_CC_MASK,
+		"please echo CC data to /sys/class/tv/wss\n"
+	},
+
+	{
+		WSS_480I_CMD_OFF,
+		WSS_480I_LINE,
+		WSS_480I_FULL_START,
+		WSS_480I_FULL_LENGTH,
+		WSS_480I_FULL_MASK,
+		"please input full wss data(12 bits)!\n"
+	},
+};
+
+static unsigned int wss_params_mapping(unsigned int cmd, unsigned int param)
+{
+	unsigned int value = param;
+	switch (cmd) {
+	case WSS_576I_CMD_AR:
+		switch (value) {
+		case 1:
+			value = WSS_576I_BITS_AR_BOX_169_TOP;
+			break;
+		case 2:
+			value = WSS_576I_BITS_AR_BOX_149_TOP;
+			break;
+		case 3:
+			value = WSS_576I_BITS_AR_FULL_43_SHOOT;
+			break;
+		case 4:
+			value = WSS_576I_BITS_AR_BOX_149_CENTRE;
+			break;
+		case 5:
+			value = WSS_576I_BITS_AR_BOX_OVER_169_CENTRE;
+			break;
+		case 6:
+			value = WSS_576I_BITS_AR_BOX_169_CENTRE;
+			break;
+		case 7:
+			value = WSS_576I_BITS_AR_FULL_169;
+			break;
+		case 0:
+		default:
+			value = WSS_576I_BITS_AR_FULL_43;
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+	return value;
+}
+
+static void wss_process_cmd(unsigned int cmd, unsigned int param)
+{
+	unsigned int value, mode = 576;
+	unsigned int i, max = sizeof(wss_info)/sizeof(struct wss_info_t);
+/* pr_info("[%s] cmd = 0x%x, param = 0x%x\n", __FUNCTION__, cmd, param); */
+	if (cmd == WSS_576I_CMD_OFF)
+		wss_close_output(576);
+	else if (cmd == WSS_480I_CMD_OFF)
+		wss_close_output(480);
+	else {
+		if ((cmd >= WSS_576I_CMD_AR) && (cmd <= WSS_576I_CMD_OFF))
+			mode = 576;
+		else if ((cmd >= WSS_480I_CMD_AR) && (cmd <= WSS_480I_CMD_OFF))
+			mode = 480;
+
+		for (i = 0; i < max; i++) {
+			if (cmd == wss_info[i].wss_cmd) {
+				value = param & wss_info[i].mask;
+				value = wss_params_mapping(cmd, value);
+				wss_set_output(cmd, mode, wss_info[i].wss_line,
+				value, wss_info[i].start, wss_info[i].length);
+			}
+		}
+	}
+
+	return;
+}
+
+static void wss_process_description(unsigned int cmd)
+{
+	unsigned int i, max = sizeof(wss_info)/sizeof(struct wss_info_t);
+	for (i = 0; i < max; i++) {
+		if (cmd == wss_info[i].wss_cmd)
+			pr_info("%s", wss_info[i].description);
+	}
+	return;
+}
+
+static void wss_show_status(unsigned int mode, char *wss_cmd)
+{
+	unsigned int data = tv_out_reg_read(ENCI_VBI_WSSDT);
+
+	if (wss_cmd == NULL) {
+		pr_info("wss_show_status wss_cmd is null\n");
+		return;
+	}
+/* pr_info("[%s] mode = %d, wss_cmd = |%s|\n", __FUNCTION__, mode, wss_cmd); */
+	if (mode == VMODE_576CVBS) {
+		if (!strncmp(wss_cmd, "cgms", strlen("cgms"))) {
+			data = (data>>WSS_576I_CGMS_A_START) &
+							WSS_576I_CGMS_A_MASK;
+			switch (data) {
+			case 0:
+				pr_info("cgms 0: no copy right asserted or status unknown / copying not restricted\n");
+				break;
+			case 1:
+				pr_info("cgms 1: copy right asserted / copying not restricted\n");
+				break;
+			case 2:
+				pr_info("cgms 2: no copy right asserted or status unknown / copying restricted\n");
+				break;
+			case 3:
+				pr_info("cgms 3: copy right asserted / copying restricted\n");
+				break;
+			default:
+				break;
+			}
+		}
+	}
+	return;
+}
+
+static void wss_dispatch_cmd(char *p)
+{
+	int argn, i, cmd_max, ret;
+	char *para = NULL, *argv[2] = {NULL, NULL};
+	unsigned int cmd = 0xff, param = 0;
+	unsigned long param_l = 0;
+	char *wss_480i_cmd[] = {"ar", "cgms", "psp", "prerec", "CC", "off"};
+	char *wss_576i_cmd[] = {"ar", "mode", "coding", "helper",
+		"ttxsubt", "opensubt", "surrsnd", "cgms", "full", "CC", "off"};
+	enum vmode_e mode;
+	mode = get_current_vmode();
+	pr_info("[%s]: current_vmode = 0x%x, user input = %s\n",
+			__func__, mode, p);
+	for (argn = 0; argn < 2; argn++) {
+		para = strsep(&p, " ");
+		if (para == NULL)
+			break;
+		argv[argn] = para;
+	}
+	if (!strncmp(argv[0], "status", strlen("status")))
+		cmd = 0xee;
+	else {
+		if (mode == VMODE_480CVBS) {
+			cmd_max = sizeof(wss_480i_cmd);
+			for (i = 0; i < cmd_max; i++) {
+				if (!strncmp(argv[0], wss_480i_cmd[i],
+						strlen(wss_480i_cmd[i]))) {
+					cmd = WSS_480I_CMD_AR + i;
+					break;
+				}
+			}
+		} else if (mode == VMODE_576CVBS) {
+			cmd_max = sizeof(wss_576i_cmd);
+			for (i = 0; i < cmd_max; i++) {
+				if (!strncmp(argv[0], wss_576i_cmd[i],
+						strlen(wss_576i_cmd[i]))) {
+					cmd = WSS_576I_CMD_AR + i;
+					break;
+				}
+			}
+		} else
+			return;
+	}
+	pr_info("[%s] wss cmd = 0x%x, argn = %d\n", __func__, cmd, argn);
+	if (cmd == 0xff) {
+		pr_info("[%s] invalid cmd = %s\n", __func__, argv[0]);
+		return;
+	} else if (cmd == 0xee) {/* inquire status */
+		wss_show_status(mode, argv[1]);
+		return;
+	}
+	if ((cmd == WSS_576I_CMD_OFF) || (cmd == WSS_480I_CMD_OFF))
+		wss_process_cmd(cmd, 0);
+	else if (argn == 1)
+		wss_process_description(cmd);
+	else {
+		ret = kstrtoul(argv[1], 16, &param_l);
+		param = (unsigned int)param_l;
+		wss_process_cmd(cmd, param);
+	}
+	return;
+}
+
+/*****************************************************************
+**
+**	aml_wss sysfs interface
+**
+******************************************************************/
+ssize_t aml_TV_attr_wss_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	unsigned int enable = ((tv_out_reg_read(ENCI_VBI_SETTING)&0xc)
+							== 0)?0:1;
+	unsigned int line = tv_out_reg_read(ENCI_VBI_WSS_LN)+1;
+	unsigned int data = tv_out_reg_read(ENCI_VBI_WSSDT);
+
+	if (enable == 1)
+		return sprintf(buf, "wss line:%d data 0x%x\n", line, data);
+	return sprintf(buf, "wss is closed!\n");
+}
+
+ssize_t aml_TV_attr_wss_store(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	char *p = NULL;
+	p = kstrdup(buf, GFP_KERNEL);
+	wss_dispatch_cmd(p);
+	kfree(p);
+	return count;
+}
+
diff --git a/drivers/amlogic/display/vout/wss.h b/drivers/amlogic/display/vout/wss.h
new file mode 100644
index 0000000..7e3891b
--- /dev/null
+++ b/drivers/amlogic/display/vout/wss.h
@@ -0,0 +1,183 @@
+/*************************************************************
+*Amlogic
+*wss module: Wide Screen Signalling
+*
+*Copyright (C) 2010 Amlogic, Inc.
+*
+*This program is free software; you can redistribute it and/or modify
+*it under the terms of the GNU General Public License as published by
+*the Free Software Foundation; either version 2 of the named License,
+*or any later version.
+*
+*This program is distributed in the hope that it will be useful,
+*but WITHOUT ANY WARRANTY; without even the implied warranty of
+*MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*GNU General Public License for more details.
+*
+*
+*Author:   jets.yan@amlogic
+*
+*
+**************************************************************/
+
+#ifndef __WSS_H__
+#define __WSS_H__
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+/* for 576i, according to <ETSI EN 300294 V1.4.1> */
+
+#define WSS_576I_LINE							23
+
+#define WSS_576I_AR_START						0x0
+#define WSS_576I_AR_LENGTH						0x4
+#define WSS_576I_AR_MASK						0x7
+	#define WSS_576I_BITS_AR_FULL_43				0x1
+	#define WSS_576I_BITS_AR_BOX_149_CENTRE		0x8
+	#define WSS_576I_BITS_AR_BOX_149_TOP			0x4
+	#define WSS_576I_BITS_AR_BOX_169_CENTRE		0xd
+	#define WSS_576I_BITS_AR_BOX_169_TOP			0x2
+	#define WSS_576I_BITS_AR_BOX_OVER_169_CENTRE	0xb
+	#define WSS_576I_BITS_AR_FULL_43_SHOOT			0x7
+	#define WSS_576I_BITS_AR_FULL_169				0xe
+
+
+#define WSS_576I_MODE_START						0x4
+#define WSS_576I_MODE_LENGTH					0x1
+#define WSS_576I_MODE_MASK						0x1
+	#define WSS_576I_BITS_MODE_CAMERA				0x0
+	#define WSS_576I_BITS_MODE_FILM					0x1
+
+#define WSS_576I_CODING_START					0x5
+#define WSS_576I_CODING_LENGTH					0x1
+#define WSS_576I_CODING_MASK					0x1
+	#define WSS_576I_BITS_STANDARD_CODING			0x0
+	#define WSS_576I_BITS_MOTION_COLOUR_PLUS		0x1
+
+#define WSS_576I_HELPER_START					0x6
+#define WSS_576I_HELPER_LENGTH					0x1
+#define WSS_576I_HELPER_MASK					0x1
+	#define WSS_576I_BITS_NO_HELPER					0x0
+	#define WSS_576I_BITS_MODULATED_HELPER			0x1
+
+#define WSS_576I_TTX_SUBT_START					0x8
+#define WSS_576I_TTX_SUBT_LENGTH				0x1
+#define WSS_576I_TTX_SUBT_MASK					0x1
+	#define WSS_576I_BITS_TTX_NO_SUBT				0x0
+	#define WSS_576I_BITS_TTX_SUBT					0x1
+
+#define WSS_576I_OPEN_SUBT_START				0x9
+#define WSS_576I_OPEN_SUBT_LENGTH				0x2
+#define WSS_576I_OPEN_SUBT_MASK					0x3
+	#define WSS_576I_BITS_NO_OPEN_SUBT				0x0
+	#define WSS_576I_BITS_SUBT_OUT_AREA				0x1
+	#define WSS_576I_BITS_SUBT_IN_AREA				0x2
+
+#define WSS_576I_SURROUND_SND_START				0xb
+#define WSS_576I_SURROUND_SND_LENGTH			0x1
+#define WSS_576I_SURROUND_SND_MASK				0x1
+	#define WSS_576I_BITS_NO_SURR_SOUND				0x0
+	#define WSS_576I_BITS_SURR_SOUND				0x1
+
+#define WSS_576I_CGMS_A_START					0xc
+#define WSS_576I_CGMS_A_LENGTH					0x2
+#define WSS_576I_CGMS_A_MASK					0x3
+	#define WSS_576I_BITS_NO_COPYRIGHT				0x0
+	#define WSS_576I_BITS_HAS_COPYRIGHT				0x1
+	#define WSS_576I_BITS_COPYRIGHT_NOT_RESTRICTED	0x0
+	#define WSS_576I_BITS_COPYRIGHT_RESTRICTED		0x1
+
+#define WSS_576I_FULL_START						0x0
+#define WSS_576I_FULL_LENGTH					0xe
+#define WSS_576I_FULL_MASK						0x3fff
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+/* for 480i, according to <IEC 61880:1998> */
+
+#define WSS_480I_LINE							20
+
+#define WSS_480I_AR_START						0x0
+#define WSS_480I_AR_LENGTH						0x2
+#define WSS_480I_AR_MASK						0x3
+#define WSS_480I_AR_BITS_43						0x0
+#define WSS_480I_AR_BITS_43_LB					0x1
+#define WSS_480I_AR_BITS_169					0x2
+#define WSS_480I_AR_BITS_RESERVED				0x3
+
+#define WSS_480I_CGMS_A_START					0x7
+#define WSS_480I_CGMS_A_LENGTH					0x2
+#define WSS_480I_CGMS_A_MASK					0x3
+#define	WSS_480I_CGMS_A_PERMITTED				0x0
+#define WSS_480I_CGMS_A_NOT_USED				0x1
+#define WSS_480I_CGMS_A_ONE_COPY				0x2
+#define WSS_480I_CGMS_A_NO_COPY					0x3
+
+#define WSS_480I_PSP_START						0x9
+#define WSS_480I_PSP_LENGTH						0x2
+#define WSS_480I_PSP_MASK						0x3
+#define WSS_480I_PSP_OFF						0x0
+#define WSS_480I_PSP_SPLIT_OFF					0x1
+#define WSS_480I_PSP_SPLIT_2LINE				0x2
+#define WSS_480I_PSP_SPLIT_4LINE				0x3
+
+#define WSS_480I_PRE_RECORDED_START				0xb
+#define WSS_480I_PRE_RECORDED_LENGTH			0x1
+#define WSS_480I_PRE_RECORDED_MASK				0x1
+#define WSS_480I_PRE_RECORDED_NO				0x0
+#define WSS_480I_PRE_RECORDED_YES				0x1
+
+#define WSS_480I_FULL_START						0x0
+#define WSS_480I_FULL_LENGTH					0xc
+#define WSS_480I_FULL_MASK						0x7ff
+
+#define WSS_576I_CC_START                       0x0
+#define WSS_576I_CC_LINE						0x1615
+/*line evn 21,odd 22*/
+#define WSS_576I_CC_LENGTH						0x2
+#define WSS_576I_CC_MASK                        0xffff
+
+#define WSS_480I_CC_START                       0x0
+#define WSS_480I_CC_LINE						0x1211
+/*line evn 17,odd 18,reault all 21*/
+#define WSS_480I_CC_LENGTH						0x2
+#define WSS_480I_CC_MASK                        0xffff
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+/* common struct for 480i/576i wss */
+
+enum WSS_576I_CMD {
+	WSS_576I_CMD_AR = 0x0,
+	WSS_576I_CMD_MODE = 0x1,
+	WSS_576I_CMD_CODING = 0x2,
+	WSS_576I_CMD_HELPER = 0x3,
+	WSS_576I_CMD_TTX_SUBT = 0x4,
+	WSS_576I_CMD_OPEN_SUBT = 0x5,
+	WSS_576I_CMD_SURROUND_SND = 0x6,
+	WSS_576I_CMD_CGMS_A = 0x7,
+	WSS_576I_CMD_FULL = 0x8,
+	WSS_576I_CMD_CC = 0x9,
+	WSS_576I_CMD_OFF = 0xa,
+
+	WSS_480I_CMD_AR = 0x10,
+	WSS_480I_CMD_CGMS_A = 0x11,
+	WSS_480I_CMD_PSP = 0x12,
+	WSS_480I_CMD_PRE_RECORDED = 0x13,
+	WSS_480I_CMD_CC = 0x14,
+	WSS_480I_CMD_OFF = 0x15,
+
+};
+
+struct wss_info_t {
+	unsigned int	wss_cmd;
+	unsigned int	wss_line;
+	unsigned int	start;
+	unsigned int	length;
+	unsigned int	mask;
+	char			*description;
+};
+
+ssize_t aml_TV_attr_wss_show(struct class *class,
+			struct class_attribute *attr, char *buf);
+ssize_t  aml_TV_attr_wss_store(struct class *class,
+	struct class_attribute *attr, const char *buf, size_t count);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+
+#endif
diff --git a/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c b/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c
index 8556450..1258124 100644
--- a/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c
+++ b/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c
@@ -29,6 +29,7 @@ static struct hdmi_format_para fmt_para_1920x1080p60_16x9 = {
 	.tmds_clk = 148500,
 	.timing = {
 		.pixel_freq = 148500,
+		.frac_freq = 148352,
 		.h_freq = 67500,
 		.v_freq = 60000,
 		.vsync_polarity = 1,
@@ -60,6 +61,7 @@ static struct hdmi_format_para fmt_para_1920x1080p30_16x9 = {
 	.tmds_clk = 74250,
 	.timing = {
 		.pixel_freq = 74250,
+		.frac_freq = 74176,
 		.h_freq = 67500,
 		.v_freq = 30000,
 		.vsync_polarity = 1,
@@ -119,9 +121,9 @@ static struct hdmi_format_para fmt_para_1920x1080p25_16x9 = {
 	.progress_mode = 1,
 	.scrambler_en = 0,
 	.tmds_clk_div40 = 0,
-	.tmds_clk = 148500,
+	.tmds_clk = 74250,
 	.timing = {
-		.pixel_freq = 148500,
+		.pixel_freq = 74250,
 		.h_freq = 56250,
 		.v_freq = 50000,
 		.vsync_polarity = 1,
@@ -153,6 +155,7 @@ static struct hdmi_format_para fmt_para_1920x1080p24_16x9 = {
 	.tmds_clk = 74250,
 	.timing = {
 		.pixel_freq = 74250,
+		.frac_freq = 74176,
 		.h_freq = 27000,
 		.v_freq = 24000,
 		.vsync_polarity = 1,
@@ -184,6 +187,7 @@ static struct hdmi_format_para fmt_para_3840x2160p30_16x9 = {
 	.tmds_clk = 297000,
 	.timing = {
 		.pixel_freq = 297000,
+		.frac_freq = 296703,
 		.h_freq = 67500,
 		.v_freq = 30000,
 		.vsync_polarity = 1,
@@ -215,6 +219,7 @@ static struct hdmi_format_para fmt_para_3840x2160p60_16x9 = {
 	.tmds_clk = 594000,
 	.timing = {
 		.pixel_freq = 594000,
+		.frac_freq = 593407,
 		.h_freq = 135000,
 		.v_freq = 60000,
 		.vsync_polarity = 1,
@@ -308,6 +313,7 @@ static struct hdmi_format_para fmt_para_3840x2160p24_16x9 = {
 	.tmds_clk = 297000,
 	.timing = {
 		.pixel_freq = 297000,
+		.frac_freq = 296703,
 		.h_freq = 54000,
 		.v_freq = 24000,
 		.vsync_polarity = 1,
@@ -339,6 +345,7 @@ static struct hdmi_format_para fmt_para_4096x2160p24_256x135 = {
 	.tmds_clk = 297000,
 	.timing = {
 		.pixel_freq = 297000,
+		.frac_freq = 296703,
 		.h_freq = 54000,
 		.v_freq = 24000,
 		.vsync_polarity = 1,
@@ -401,6 +408,7 @@ static struct hdmi_format_para fmt_para_4096x2160p30_256x135 = {
 	.tmds_clk = 297000,
 	.timing = {
 		.pixel_freq = 297000,
+		.frac_freq = 296703,
 		.h_freq = 67500,
 		.v_freq = 30000,
 		.vsync_polarity = 1,
@@ -463,6 +471,7 @@ static struct hdmi_format_para fmt_para_4096x2160p60_256x135 = {
 	.tmds_clk = 594000,
 	.timing = {
 		.pixel_freq = 594000,
+		.frac_freq = 593407,
 		.h_freq = 135000,
 		.v_freq = 60000,
 		.vsync_polarity = 1,
@@ -494,6 +503,7 @@ static struct hdmi_format_para fmt_para_1920x1080i60_16x9 = {
 	.tmds_clk = 74250,
 	.timing = {
 		.pixel_freq = 74250,
+		.frac_freq = 74176,
 		.h_freq = 33750,
 		.v_freq = 60000,
 		.vsync_polarity = 1,
@@ -556,6 +566,7 @@ static struct hdmi_format_para fmt_para_1280x720p60_16x9 = {
 	.tmds_clk = 74250,
 	.timing = {
 		.pixel_freq = 74250,
+		.frac_freq = 74176,
 		.h_freq = 45000,
 		.v_freq = 60000,
 		.vsync_polarity = 1,
@@ -615,9 +626,10 @@ static struct hdmi_format_para fmt_para_720x480p60_16x9 = {
 	.progress_mode = 1,
 	.scrambler_en = 0,
 	.tmds_clk_div40 = 0,
-	.tmds_clk = 27000,
+	.tmds_clk = 27027,
 	.timing = {
-		.pixel_freq = 27000,
+		.pixel_freq = 27027,
+		.frac_freq = 27000,
 		.h_freq = 31469,
 		.v_freq = 59940,
 		.vsync_polarity = 0,
@@ -646,9 +658,10 @@ static struct hdmi_format_para fmt_para_720x480i60_16x9 = {
 	.progress_mode = 0,
 	.scrambler_en = 0,
 	.tmds_clk_div40 = 0,
-	.tmds_clk = 27000,
+	.tmds_clk = 27027,
 	.timing = {
-		.pixel_freq = 27000,
+		.pixel_freq = 27027,
+		.frac_freq = 27000,
 		.h_freq = 15734,
 		.v_freq = 59940,
 		.vsync_polarity = 0,
@@ -742,6 +755,7 @@ static struct hdmi_format_para fmt_para_3840x1080p120_16x9 = {
 	.tmds_clk = 594000,
 	.timing = {
 		.pixel_freq = 594000,
+		.frac_freq = 593407,
 		.h_freq = 135000,
 		.v_freq = 120000,
 		.vsync_polarity = 1,
@@ -804,6 +818,7 @@ static struct hdmi_format_para fmt_para_3840x540p240_16x9 = {
 	.tmds_clk = 594000,
 	.timing = {
 		.pixel_freq = 594000,
+		.frac_freq = 593407,
 		.h_freq = 135000,
 		.v_freq = 120000,
 		.vsync_polarity = 1,
@@ -930,6 +945,7 @@ static struct hdmi_format_para fmt_para_3840x2160p60_16x9_y420 = {
 	.tmds_clk = 594000,
 	.timing = {
 		.pixel_freq = 594000,
+		.frac_freq = 593407,
 		.h_freq = 135000,
 		.v_freq = 60000,
 		.vsync_polarity = 1,
@@ -962,6 +978,7 @@ static struct hdmi_format_para fmt_para_4096x2160p60_256x135_y420 = {
 	.tmds_clk = 594000,
 	.timing = {
 		.pixel_freq = 594000,
+		.frac_freq = 593407,
 		.h_freq = 135000,
 		.v_freq = 60000,
 		.vsync_polarity = 1,
@@ -1033,7 +1050,7 @@ struct hdmi_format_para *hdmi_get_fmt_paras(enum hdmi_vic vic)
 		if (vic == all_fmt_paras[i]->vic)
 			return all_fmt_paras[i];
 	}
-	return NULL;
+	return &fmt_para_non_hdmi_fmt;
 }
 
 static struct parse_cd parse_cd_[] = {
@@ -1055,6 +1072,39 @@ static struct parse_cr parse_cr_[] = {
 	{COLORRANGE_FUL, "full",},
 };
 
+const char *hdmi_get_str_cd(struct hdmi_format_para *para)
+{
+	int i;
+
+	for (i = 0; i < sizeof(parse_cd_) / sizeof(struct parse_cd); i++) {
+		if (para->cd == parse_cd_[i].cd)
+			return parse_cd_[i].name;
+	}
+	return NULL;
+}
+
+const char *hdmi_get_str_cs(struct hdmi_format_para *para)
+{
+	int i;
+
+	for (i = 0; i < sizeof(parse_cs_) / sizeof(struct parse_cs); i++) {
+		if (para->cs == parse_cs_[i].cs)
+			return parse_cs_[i].name;
+	}
+	return NULL;
+}
+
+const char *hdmi_get_str_cr(struct hdmi_format_para *para)
+{
+	int i;
+
+	for (i = 0; i < sizeof(parse_cr_) / sizeof(struct parse_cr); i++) {
+		if (para->cr == parse_cr_[i].cr)
+			return parse_cr_[i].name;
+	}
+	return NULL;
+}
+
 /* parse the string from "dhmitx output FORMAT" */
 static void hdmi_parse_attr(struct hdmi_format_para *para, char const *name)
 {
@@ -1099,7 +1149,7 @@ static void hdmi_parse_attr(struct hdmi_format_para *para, char const *name)
  * or 3840x2160p60hz, 2160p60hz
  * or 3840x2160p60hz420, 2160p60hz420 (Y420 mode)
  */
-struct hdmi_format_para *hdmi_get_fmt_name(char const *name)
+struct hdmi_format_para *hdmi_get_fmt_name(char const *name, char const *attr)
 {
 	int i;
 	char *lname;
@@ -1109,10 +1159,7 @@ struct hdmi_format_para *hdmi_get_fmt_name(char const *name)
 	if (!name)
 		return NULL;
 
-	for (i = 0; i < sizeof(all_fmt_paras) /
-		sizeof(struct hdmi_format_para *); i++) {
-		if (!all_fmt_paras[i])
-			break;
+	for (i = 0; all_fmt_paras[i]; i++) {
 		lname = all_fmt_paras[i]->name;
 		if (lname && (strncmp(name, lname, strlen(lname)) == 0)) {
 			vic = all_fmt_paras[i]->vic;
@@ -1130,10 +1177,14 @@ struct hdmi_format_para *hdmi_get_fmt_name(char const *name)
 		memset(&para->ext_name[0], 0, sizeof(para->ext_name));
 		memcpy(&para->ext_name[0], name, strlen(name));
 		hdmi_parse_attr(para, name);
+		hdmi_parse_attr(para, attr);
 	} else {
 		para = &fmt_para_non_hdmi_fmt;
 		hdmi_parse_attr(para, name);
+		hdmi_parse_attr(para, attr);
 	}
+	if (strstr(name, "420"))
+		para->cs = COLORSPACE_YUV420;
 	return para;
 }
 
@@ -1305,6 +1356,16 @@ struct hdmi_audio_fs_ncts aud_32k_para = {
 		.n = 3072,
 		.cts = 222750,
 	},
+	.array[12] = {
+		.tmds_clk = 593407,
+		.n = 5824,
+		.cts = 843750,
+	},
+	.array[13] = {
+		.tmds_clk = 594000,
+		.n = 3072,
+		.cts = 445500,
+	},
 	.def_n = 4096,
 };
 
@@ -1410,6 +1471,16 @@ struct hdmi_audio_fs_ncts aud_44k1_para = {
 		.n = 4707,
 		.cts = 247500,
 	},
+	.array[12] = {
+		.tmds_clk = 593407,
+		.n = 8918,
+		.cts = 937500,
+	},
+	.array[13] = {
+		.tmds_clk = 594000,
+		.n = 9408,
+		.cts = 990000,
+	},
 	.def_n = 6272,
 };
 
@@ -1515,6 +1586,16 @@ struct hdmi_audio_fs_ncts aud_48k_para = {
 		.n = 5120,
 		.cts = 247500,
 	},
+	.array[12] = {
+		.tmds_clk = 593407,
+		.n = 5824,
+		.cts = 562500,
+	},
+	.array[13] = {
+		.tmds_clk = 594000,
+		.n = 6144,
+		.cts = 594000,
+	},
 	.def_n = 6144,
 };
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdcp22/hdcp_main.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdcp22/hdcp_main.c
index 625aa19..4c4e7b3 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdcp22/hdcp_main.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdcp22/hdcp_main.c
@@ -354,14 +354,12 @@ static long cmd_hpi_write(struct esm_device *esm,
 	if (ret)
 		pr_info("copy left %ld Bytes\n", ret);
 	if (krequest.offset == 0x40) {
-		hd_set_reg_bits(P_PREG_PAD_GPIO1_EN_N, 3, 21, 2);
-		hd_set_reg_bits(P_PERIPHS_PIN_MUX_1, 3, 24, 2); /* MUX DDC */
+		hdmitx_set_reg_bits(HDMITX_DWC_MC_CLKDIS, 1, 6, 1);
 		hdmitx_wr_reg(HDMITX_DWC_HDCP22REG_CTRL, 0x6);
 		hdmitx_set_reg_bits(HDMITX_TOP_SW_RESET, 1, 5, 1);
 		udelay(10);
 		hdmitx_set_reg_bits(HDMITX_TOP_SW_RESET, 0, 5, 1);
 		udelay(10);
-		hdmitx_set_reg_bits(HDMITX_DWC_MC_CLKDIS, 1, 6, 1);
 		hdmitx_wr_reg(HDMITX_DWC_HDCP22REG_MASK, 0);
 		hdmitx_wr_reg(HDMITX_DWC_HDCP22REG_MUTE, 0);
 		set_pkf_duk_nonce();
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
index 5ddb16f..ce84aec 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
@@ -58,6 +58,7 @@
 #define HDMI_EDID_BLOCK_TYPE_EXTENDED_TAG       7
 
 /* DRM stands for "Dynamic Range and Mastering " */
+#define EXTENSION_VENDOR_SPECIFIC 0x1
 #define EXTENSION_COLORMETRY_TAG 0x5
 #define EXTENSION_DRM_TAG	0x6
 #define EXTENSION_Y420_VDB_TAG	0xe
@@ -341,6 +342,15 @@ static void set_vsdb_dc_420_cap(struct rx_cap *pRXCap,
 	pRXCap->dc_48bit_420 = !!(edid_offset[6] & (1 << 2));
 }
 
+/* Special FBC check */
+static int check_fbc_special(unsigned char *edid_dat)
+{
+	if ((edid_dat[250] == 0xfb) && (edid_dat[251] == 0x0c))
+		return 1;
+	else
+		return 0;
+}
+
 int Edid_Parse_check_HDMI_VSDB(struct hdmitx_dev *hdev,
 	unsigned char *buff)
 {
@@ -365,10 +375,14 @@ int Edid_Parse_check_HDMI_VSDB(struct hdmitx_dev *hdev,
 	}
 
 	set_vsdb_phy_addr(&info->vsdb_phy_addr, &buff[BlockAddr]);
-	rx_edid_physical_addr(info->vsdb_phy_addr.a,
-		info->vsdb_phy_addr.b,
-		info->vsdb_phy_addr.c,
-		info->vsdb_phy_addr.d);
+	if ((check_fbc_special(&hdev->EDID_buf[0])) ||
+	    (check_fbc_special(&hdev->EDID_buf1[0])))
+		rx_edid_physical_addr(0, 0, 0, 0);
+	else
+		rx_edid_physical_addr(info->vsdb_phy_addr.a,
+			info->vsdb_phy_addr.b,
+			info->vsdb_phy_addr.c,
+			info->vsdb_phy_addr.d);
 	set_vsdb_dc_cap(&hdev->RXCap, &buff[BlockAddr]);
 
 	if (temp_addr >= VSpecificBoundary) {
@@ -813,6 +827,87 @@ static void Edid_ParsingSpeakerDATABlock(struct hdmitx_info *info,
 	}
 }
 
+static void Edid_ParsingVendSpec(struct rx_cap *pRXCap,
+	unsigned char *buf)
+{
+	struct dv_info *dv = &pRXCap->dv_info;
+	unsigned char *dat = buf;
+	unsigned char len;
+	unsigned char pos = 0;
+
+	len = dat[pos] & 0x1f;
+	pos++;
+
+	if (dat[pos] != 1) {
+		pr_info("hdmitx: edid: parsing fail %s[%d]\n", __func__,
+			__LINE__);
+		return;
+	} else
+		pos++;
+
+	dv->ieeeoui = dat[pos++];
+	dv->ieeeoui += dat[pos++] << 8;
+	dv->ieeeoui += dat[pos++] << 16;
+
+	dv->ver = (dat[pos] >> 5) & 0x7;
+	/* Refer to DV 2.6 Page 11 */
+	if (dv->ver == 0) {
+		dv->sup_yuv422_12bit = dat[pos] & 0x1;
+		dv->sup_2160p60hz = (dat[pos] >> 1) & 0x1;
+		dv->sup_global_dimming = (dat[pos] >> 2) & 0x1;
+		pos++;
+		dv->vers.ver0.chrom_red_primary_x =
+			(dat[pos+1] << 8) | (dat[pos] >> 4);
+		dv->vers.ver0.chrom_red_primary_y =
+			(dat[pos+2] << 8) | (dat[pos] & 0xf);
+		pos += 3;
+		dv->vers.ver0.chrom_green_primary_x =
+			(dat[pos+1] << 8) | (dat[pos] >> 4);
+		dv->vers.ver0.chrom_green_primary_y =
+			(dat[pos+2] << 8) | (dat[pos] & 0xf);
+		pos += 3;
+		dv->vers.ver0.chrom_blue_primary_x =
+			(dat[pos+1] << 8) | (dat[pos] >> 4);
+		dv->vers.ver0.chrom_blue_primary_y =
+			(dat[pos+2] << 8) | (dat[pos] & 0xf);
+		pos += 3;
+		dv->vers.ver0.chrom_white_primary_x =
+			(dat[pos+1] << 8) | (dat[pos] >> 4);
+		dv->vers.ver0.chrom_white_primary_y =
+			(dat[pos+2] << 8) | (dat[pos] & 0xf);
+		pos += 3;
+		dv->vers.ver0.target_min_pq =
+			(dat[pos+1] << 8) | (dat[pos] >> 4);
+		dv->vers.ver0.target_max_pq =
+			(dat[pos+2] << 8) | (dat[pos] & 0xf);
+		pos += 3;
+		dv->vers.ver0.dm_major_ver = dat[pos] >> 4;
+		dv->vers.ver0.dm_minor_ver = dat[pos] & 0xf;
+		pos++;
+	}
+	/* Refer to DV 2.6 Page 14 */
+	if (dv->ver == 1) {
+		dv->vers.ver1.dm_version = (dat[pos] >> 2) & 0x7;
+		dv->sup_yuv422_12bit = dat[pos] & 0x1;
+		dv->sup_2160p60hz = (dat[pos] >> 1) & 0x1;
+		pos++;
+		dv->sup_global_dimming = dat[pos] & 0x1;
+		dv->vers.ver1.target_max_lum = dat[pos] >> 1;
+		pos++;
+		dv->colorimetry = dat[pos] & 0x1;
+		dv->vers.ver1.target_min_lum = dat[pos] >> 1;
+		pos += 2; /* byte8 is reserved as 0 */
+		dv->vers.ver1.chrom_red_primary_x = dat[pos++];
+		dv->vers.ver1.chrom_red_primary_y = dat[pos++];
+		dv->vers.ver1.chrom_green_primary_x = dat[pos++];
+		dv->vers.ver1.chrom_green_primary_y = dat[pos++];
+		dv->vers.ver1.chrom_blue_primary_x = dat[pos++];
+		dv->vers.ver1.chrom_blue_primary_y = dat[pos++];
+	}
+	if (pos > len)
+		pr_info("hdmitx: edid: maybe invalid dv%d data\n", dv->ver);
+	return;
+}
 
 /* ----------------------------------------------------------- */
 static int Edid_ParsingY420VDBBlock(struct rx_cap *pRXCap,
@@ -1095,70 +1190,84 @@ static int hdmitx_edid_3d_parse(struct rx_cap *pRXCap, unsigned char *dat,
 	unsigned size)
 {
 	int j = 0;
-	int bit = 16;
 	unsigned int base = 0;
 	unsigned int pos = base + 1;
 
-	if (dat[base] & (1<<7))
+	if (dat[base] & (1 << 7))
 		pos += 2;
-	if (dat[base] & (1<<6))
+	if (dat[base] & (1 << 6))
 		pos += 2;
-	if (dat[base] & (1<<5)) {
+	if (dat[base] & (1 << 5)) {
 		pRXCap->threeD_present = dat[pos] >> 7;
 		pRXCap->threeD_Multi_present = (dat[pos] >> 5) & 0x3;
 		pos += 1;
-		pRXCap->hdmi_vic_LEN = (dat[pos]) >> 5;
-		pRXCap->HDMI_3D_LEN = (dat[pos]) & 0x1f;
+		pRXCap->hdmi_vic_LEN = dat[pos] >> 5;
+		pRXCap->HDMI_3D_LEN = dat[pos] & 0x1f;
 		pos += pRXCap->hdmi_vic_LEN + 1;
-		if ((pRXCap->threeD_Multi_present == 0x01) ||
-			(pRXCap->threeD_Multi_present == 0x2)) {
+
+		if (pRXCap->threeD_Multi_present == 0x01) {
 			pRXCap->threeD_Structure_ALL_15_0 =
 				(dat[pos] << 8) + dat[pos+1];
+			pRXCap->threeD_MASK_15_0 = 0;
 			pos += 2;
 		}
-		if (pRXCap->threeD_Multi_present == 0x2) {
-			pRXCap->threeD_MASK_15_0 = (dat[pos] << 8)
-				+ dat[pos+1];
+		if (pRXCap->threeD_Multi_present == 0x02) {
+			pRXCap->threeD_Structure_ALL_15_0 =
+				(dat[pos] << 8) + dat[pos+1];
+			pos += 2;
+			pRXCap->threeD_MASK_15_0 = (dat[pos] << 8) + dat[pos+1];
 			pos += 2;
 		}
 	}
 	while (pos < size) {
-		if ((dat[pos] & 0xf) == 0x0) { /* frame packing */
-			pRXCap->support_3d_format[pRXCap->VIC[((dat[pos]
-				& 0xf0) >> 4)]].frame_packing = 1;
-			pRXCap->support_3d_format[pRXCap->VIC[((
-				dat[pos+1] & 0xf0) >> 4)]].frame_packing = 1;
-		}
-		if ((dat[pos] & 0xf) == 0x6) { /* top and bottom */
-			pRXCap->support_3d_format[pRXCap->VIC[((dat[pos]
-				& 0xf0) >> 4)]].top_and_bottom = 1;
-			pRXCap->support_3d_format[pRXCap->VIC[((dat[pos+1]
-				& 0xf0) >> 4)]].top_and_bottom = 1;
-		}
-		if ((dat[pos] & 0xf) == 0x8) { /* top and bottom */
-			pRXCap->support_3d_format[pRXCap->VIC[((dat[pos]
-				& 0xf0) >> 4)]].side_by_side = 1;
-			pRXCap->support_3d_format[pRXCap->VIC[((dat[pos+1]
-				& 0xf0) >> 4)]].side_by_side = 1;
-		}
-		pos += 2;
-	}
-
-	while (bit--) {
-		if (((pRXCap->threeD_MASK_15_0) >> j) & 0x1) {
+		if ((dat[pos] & 0xf) < 0x8) {
 			/* frame packing */
-			if (pRXCap->threeD_Structure_ALL_15_0 & (1 << 0))
-				pRXCap->support_3d_format[pRXCap->VIC[j]].
-					frame_packing = 1;
-			/* top and bottom */
-			if (pRXCap->threeD_Structure_ALL_15_0 & (1 << 6))
-				pRXCap->support_3d_format[pRXCap->VIC[j]].
-					top_and_bottom = 1;
+			if ((dat[pos] & 0xf) == T3D_FRAME_PACKING)
+				pRXCap->support_3d_format[pRXCap->VIC[((dat[pos]
+					& 0xf0) >> 4)]].frame_packing = 1;
 			/* top and bottom */
-			if (pRXCap->threeD_Structure_ALL_15_0 & (1 << 8))
-				pRXCap->support_3d_format[pRXCap->VIC[j]].
-					side_by_side = 1;
-		j++;
+			if ((dat[pos] & 0xf) == T3D_TAB)
+				pRXCap->support_3d_format[pRXCap->VIC[((dat[pos]
+					& 0xf0) >> 4)]].top_and_bottom = 1;
+			pos += 1;
+		} else {
+			/* SidebySide */
+			if ((dat[pos] & 0xf) == T3D_SBS_HALF)
+				if ((dat[pos+1] >> 4) < 0xb)
+					pRXCap->support_3d_format[pRXCap->VIC[
+						((dat[pos] & 0xf0) >> 4)]]
+						.side_by_side = 1;
+			pos += 2;
+		}
+	}
+	if (pRXCap->threeD_MASK_15_0 == 0) {
+		for (j = 0; (j < 16) && (j < pRXCap->VIC_count); j++) {
+			pRXCap->support_3d_format[pRXCap->VIC[j]].frame_packing
+				= 1;
+			pRXCap->support_3d_format[pRXCap->VIC[j]].top_and_bottom
+				= 1;
+			pRXCap->support_3d_format[pRXCap->VIC[j]].side_by_side
+				= 1;
+		}
+	} else {
+		for (j = 0; j < 16; j++) {
+			if (((pRXCap->threeD_MASK_15_0) >> j) & 0x1) {
+				/* frame packing */
+				if (pRXCap->threeD_Structure_ALL_15_0
+					& (1 << 0))
+					pRXCap->support_3d_format[pRXCap->
+						VIC[j]].frame_packing = 1;
+				/* top and bottom */
+				if (pRXCap->threeD_Structure_ALL_15_0
+					& (1 << 6))
+					pRXCap->support_3d_format[pRXCap->
+						VIC[j]].top_and_bottom = 1;
+				/* top and bottom */
+				if (pRXCap->threeD_Structure_ALL_15_0
+					& (1 << 8))
+					pRXCap->support_3d_format[pRXCap->
+						VIC[j]].side_by_side = 1;
+			}
 		}
 	}
 	return 1;
@@ -1252,7 +1361,7 @@ static int hdmitx_edid_block_parse(struct hdmitx_dev *hdmitx_device,
 				goto case_hf;
 			pRXCap->ColorDeepSupport =
 				(unsigned long)BlockBuf[offset+5];
-			pRXCap->Max_TMDS_Clock =
+			pRXCap->Max_TMDS_Clock1 =
 				(unsigned long)BlockBuf[offset+6];
 			if (count > 7) {
 				tmp = BlockBuf[offset+7];
@@ -1285,6 +1394,7 @@ static int hdmitx_edid_block_parse(struct hdmitx_dev *hdmitx_device,
 				(BlockBuf[offset+1] == 0x5d) &&
 				(BlockBuf[offset+2] == 0xc4))
 				pRXCap->HF_IEEEOUI = 0xd85dc4;
+			pRXCap->Max_TMDS_Clock2 = BlockBuf[offset+4];
 			pRXCap->scdc_present =
 				!!(BlockBuf[offset+5] & (1 << 7));
 			pRXCap->scdc_rr_capable =
@@ -1314,6 +1424,10 @@ static int hdmitx_edid_block_parse(struct hdmitx_dev *hdmitx_device,
 
 				ext_tag = BlockBuf[offset+1];
 				switch (ext_tag) {
+				case EXTENSION_VENDOR_SPECIFIC:
+					Edid_ParsingVendSpec(pRXCap,
+						&BlockBuf[offset]);
+					break;
 				case EXTENSION_COLORMETRY_TAG:
 					pRXCap->colorimetry_data =
 						BlockBuf[offset + 2];
@@ -1461,7 +1575,7 @@ static int edid_check_valid(unsigned char *buf)
 }
 
 /* retrun 1 valid edid */
-static int check_dvi_hdmi_edid_valid(unsigned char *buf)
+int check_dvi_hdmi_edid_valid(unsigned char *buf)
 {
 	unsigned int chksum = 0;
 	unsigned int i = 0;
@@ -1585,10 +1699,13 @@ int hdmitx_edid_parse(struct hdmitx_dev *hdmitx_device)
 	struct rx_cap *pRXCap = &(hdmitx_device->RXCap);
 	struct vinfo_s *info = NULL;
 
-	if (check_dvi_hdmi_edid_valid(hdmitx_device->EDID_buf))
+	if (check_dvi_hdmi_edid_valid(hdmitx_device->EDID_buf)) {
 		EDID_buf = hdmitx_device->EDID_buf;
-	else
+		memcpy(hdmitx_device->EDID_buf1, hdmitx_device->EDID_buf,
+			EDID_MAX_BLOCK * 128);
+	} else
 		EDID_buf = hdmitx_device->EDID_buf1;
+	hdmitx_device->edid_ptr = EDID_buf;
 	hdmi_print(0, "EDID Parser:\n");
 	memset(rptx_edid_buf, 0, sizeof(rptx_edid_buf));
 	rptx_edid_aud = &rptx_edid_buf[0];
@@ -1774,69 +1891,33 @@ int hdmitx_edid_parse(struct hdmitx_dev *hdmitx_device)
 }
 
 static struct dispmode_vic dispmode_vic_tab[] = {
-	{"480i_4_3",  HDMI_480i60},
-	{"480i_rpt",  HDMI_480i60_16x9_rpt},
-	{"480i60hz",	  HDMI_480i60_16x9},
-	{"480p_4_3",  HDMI_480p60},
-	{"480p_rpt",  HDMI_480p60_16x9_rpt},
-	{"480p60hz",	  HDMI_480p60_16x9},
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	{"480p59hz",  HDMI_480p60_16x9},
-#endif
-	{"576i_4_3",  HDMI_576i50},
-	{"576i_rpt",  HDMI_576i50_16x9_rpt},
-	{"576i50hz",	  HDMI_576i50_16x9},
-	{"576p_4_3",  HDMI_576p50},
-	{"576p_rpt",  HDMI_576p50_16x9_rpt},
-	{"576p50hz",	  HDMI_576p50_16x9},
-	{"720p50hz",  HDMI_720p50},
-	{"720p60hz",	  HDMI_720p60},
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	{"720p59hz",  HDMI_720p60},
-#endif
+	{"480i60hz", HDMI_480i60_16x9},
+	{"480p60hz", HDMI_480p60_16x9},
+	{"576i50hz", HDMI_576i50_16x9},
+	{"576p50hz", HDMI_576p50_16x9},
+	{"720p50hz", HDMI_720p50},
+	{"720p60hz", HDMI_720p60},
 	{"1080i50hz", HDMI_1080i50},
-	{"1080i60hz",	 HDMI_1080i60},
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	{"1080i59hz", HDMI_1080i60},
-#endif
+	{"1080i60hz", HDMI_1080i60},
 	{"1080p50hz", HDMI_1080p50},
 	{"1080p30hz", HDMI_1080p30},
 	{"1080p25hz", HDMI_1080p25},
 	{"1080p24hz", HDMI_1080p24},
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	{"1080p23hz", HDMI_1080p24},
-#endif
-	{"1080p60hz",	 HDMI_1080p60},
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	{"1080p59hz", HDMI_1080p60},
-#endif
-	{"2160p30hz44410bit", HDMI_3840x2160p30_16x9},
-	{"2160p25hz44410bit", HDMI_3840x2160p25_16x9},
-	{"2160p24hz44410bit", HDMI_3840x2160p24_16x9},
-	{"2160p30hz",  HDMI_4k2k_30},
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	{"4k2k29hz",  HDMI_4k2k_30},
-#endif
-	{"2160p25hz",  HDMI_4k2k_25},
-	{"2160p24hz",  HDMI_4k2k_24},
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	{"4k2k23hz",  HDMI_4k2k_24},
-#endif
+	{"1080p60hz", HDMI_1080p60},
+	{"2160p30hz", HDMI_4k2k_30},
+	{"2160p25hz", HDMI_4k2k_25},
+	{"2160p24hz", HDMI_4k2k_24},
 	{"smpte24hz", HDMI_4k2k_smpte_24},
 	{"smpte25hz", HDMI_4096x2160p25_256x135},
 	{"smpte30hz", HDMI_4096x2160p30_256x135},
 	{"smpte50hz", HDMI_4096x2160p50_256x135},
-	{"2160p60hz42010bit", HDMI_4k2k_60_y420},
-	{"2160p50hz42010bit", HDMI_4k2k_50_y420},
-	{"2160p60hz42210bit", HDMI_4k2k_60},
-	{"2160p50hz42210bit", HDMI_4k2k_50},
 	{"smpte50hz420", HDMI_4096x2160p50_256x135_Y420},
 	{"smpte60hz", HDMI_4096x2160p60_256x135},
 	{"smpte60hz420", HDMI_4096x2160p60_256x135_Y420},
 	{"2160p60hz", HDMI_4k2k_60},
 	{"2160p50hz", HDMI_4k2k_50},
-	{"2160p60hz420", HDMI_4k2k_60_y420},
-	{"2160p50hz420", HDMI_4k2k_50_y420},
+	{"2160p60hz420", HDMI_3840x2160p60_16x9_Y420},
+	{"2160p50hz420", HDMI_3840x2160p50_16x9_Y420},
 };
 
 int hdmitx_edid_VIC_support(enum hdmi_vic vic)
@@ -1884,12 +1965,134 @@ const char *hdmitx_edid_vic_tab_map_string(enum hdmi_vic vic)
 	return disp_str;
 }
 
+/* For some TV's EDID, there maybe exist some information ambiguous.
+ * Such as EDID declears support 2160p60hz(Y444 8bit), but no valid
+ * Max_TMDS_Clock2 to indicate that it can support 5.94G signal.
+ */
+bool hdmitx_edid_check_valid_mode(struct hdmitx_dev *hdev,
+	struct hdmi_format_para *para)
+{
+	bool valid = 0;
+	struct rx_cap *pRXCap = NULL;
+	unsigned int rx_max_tmds_clk = 0;
+	unsigned int calc_tmds_clk = 0;
+	int i = 0;
+	int svd_flag = 0;
+
+	if (!hdev || !para)
+		return 0;
+
+	if (strcmp(para->sname, "invalid") == 0)
+		return 0;
+	/* exclude such as: 2160p60hz YCbCr444 10bit */
+	switch (para->vic) {
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+	case HDMI_4096x2160p50_256x135:
+	case HDMI_4096x2160p60_256x135:
+	case HDMI_3840x2160p50_64x27:
+	case HDMI_3840x2160p60_64x27:
+		if ((para->cs == COLORSPACE_RGB444) ||
+			(para->cs == COLORSPACE_YUV444))
+			if (para->cd != COLORDEPTH_24B)
+				return 0;
+		if (para->cs == COLORSPACE_YUV422)
+			if (para->cd != COLORDEPTH_48B)
+				return 0;
+		break;
+	default:
+		break;
+	}
+
+	pRXCap = &(hdev->RXCap);
+
+	/* DVI case, only 8bit */
+	if (pRXCap->IEEEOUI != 0x0c03) {
+		if (para->cd != COLORDEPTH_24B)
+			return 0;
+	}
+
+	/* target mode is not contained at RX SVD */
+	for (i = 0; (i < pRXCap->VIC_count) && (i < VIC_MAX_NUM); i++) {
+		if ((para->vic & 0xff) == (pRXCap->VIC[i] & 0xff))
+			svd_flag = 1;
+	}
+	if (svd_flag == 0)
+		return 0;
+
+	/* Get RX Max_TMDS_Clock */
+	if (pRXCap->Max_TMDS_Clock2)
+		rx_max_tmds_clk = pRXCap->Max_TMDS_Clock2 * 5;
+	else {
+		/* Default min is 74.25 / 5 */
+		if (pRXCap->Max_TMDS_Clock1 < 0xf)
+			pRXCap->Max_TMDS_Clock1 = 0x1e;
+		rx_max_tmds_clk = pRXCap->Max_TMDS_Clock1 * 5;
+	}
+
+	calc_tmds_clk = para->tmds_clk;
+	if (para->cs == COLORSPACE_YUV420)
+		calc_tmds_clk = calc_tmds_clk / 2;
+	if (para->cs != COLORSPACE_YUV422) {
+		switch (para->cd) {
+		case COLORDEPTH_30B:
+			calc_tmds_clk = calc_tmds_clk * 5 / 4;
+			break;
+		case COLORDEPTH_36B:
+			calc_tmds_clk = calc_tmds_clk * 3 / 2;
+			break;
+		case COLORDEPTH_48B:
+			calc_tmds_clk = calc_tmds_clk * 2;
+			break;
+		case COLORDEPTH_24B:
+		default:
+			calc_tmds_clk = calc_tmds_clk * 1;
+			break;
+		}
+	}
+	calc_tmds_clk = calc_tmds_clk / 1000;
+	pr_info("RX tmds clk: %d   Calc clk: %d\n", rx_max_tmds_clk,
+		calc_tmds_clk);
+	if (calc_tmds_clk < rx_max_tmds_clk)
+		valid = 1;
+	else
+		valid = 0;
+
+	return valid;
+}
+
+/*
+ * For some TVs, their EDID declare support 2160p60hz(>3.4Gbps) on SVDs,
+ * but no HF_IEEEOUT, so consider they don't support that format.
+ */
+static enum hdmi_vic hdmitx_edid_recheck_format(struct hdmitx_dev *hdev,
+	enum hdmi_vic vic)
+{
+	struct rx_cap *pRXCap = &(hdev->RXCap);
+
+	switch (vic) {
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+	case HDMI_4096x2160p50_256x135:
+	case HDMI_4096x2160p60_256x135:
+	case HDMI_3840x2160p50_64x27:
+	case HDMI_3840x2160p60_64x27:
+		break;
+	default:
+		return vic;
+	}
+
+	if (!pRXCap->HF_IEEEOUI || ((pRXCap->Max_TMDS_Clock2 * 5) < 340))
+		vic = HDMI_Unkown;
+	return vic;
+}
+
 /* force_flag: 0 means check with RX's edid */
 /* 1 means no check wich RX's edid */
-enum hdmi_vic hdmitx_edid_get_VIC(struct hdmitx_dev *hdmitx_device,
+enum hdmi_vic hdmitx_edid_get_VIC(struct hdmitx_dev *hdev,
 	const char *disp_mode, char force_flag)
 {
-	struct rx_cap *pRXCap = &(hdmitx_device->RXCap);
+	struct rx_cap *pRXCap = &(hdev->RXCap);
 	int  j;
 	enum hdmi_vic vic = hdmitx_edid_vic_tab_map_vic(disp_mode);
 
@@ -1903,6 +2106,7 @@ enum hdmi_vic hdmitx_edid_get_VIC(struct hdmitx_dev *hdmitx_device,
 				vic = HDMI_Unkown;
 		}
 	}
+	vic = hdmitx_edid_recheck_format(hdev, vic);
 	return vic;
 }
 
@@ -2116,8 +2320,7 @@ int hdmitx_edid_dump(struct hdmitx_dev *hdmitx_device, char *buffer,
 		pRXCap->native_Mode, pRXCap->native_VIC);
 
 	pos += snprintf(buffer+pos, buffer_len-pos,
-		"ColorDeepSupport %x, MaxTMDSClock %d\n",
-		pRXCap->ColorDeepSupport, pRXCap->Max_TMDS_Clock);
+		"ColorDeepSupport %x\n", pRXCap->ColorDeepSupport);
 
 	for (i = 0 ; i < pRXCap->VIC_count ; i++) {
 		pos += snprintf(buffer+pos, buffer_len-pos, "%d ",
@@ -2138,8 +2341,16 @@ int hdmitx_edid_dump(struct hdmitx_dev *hdmitx_device, char *buffer,
 		"Speaker Allocation: %x\n", pRXCap->RxSpeakerAllocation);
 	pos += snprintf(buffer+pos, buffer_len-pos, "Vendor: 0x%x\n",
 		pRXCap->IEEEOUI);
-	pos += snprintf(buffer+pos, buffer_len-pos, "Vendor2: 0x%x\n",
-		pRXCap->HF_IEEEOUI);
+
+	pos += snprintf(buffer+pos, buffer_len-pos,
+		"MaxTMDSClock1 %d MHz\n", pRXCap->Max_TMDS_Clock1 * 5);
+
+	if (pRXCap->HF_IEEEOUI) {
+		pos += snprintf(buffer+pos, buffer_len-pos, "Vendor2: 0x%x\n",
+			pRXCap->HF_IEEEOUI);
+		pos += snprintf(buffer+pos, buffer_len-pos,
+			"MaxTMDSClock2 %d MHz\n", pRXCap->Max_TMDS_Clock2 * 5);
+	}
 	if (pRXCap->colorimetry_data)
 		pos += snprintf(buffer+pos, buffer_len-pos,
 			"ColorMetry: 0x%x\n", pRXCap->colorimetry_data);
@@ -2163,6 +2374,15 @@ int hdmitx_edid_dump(struct hdmitx_dev *hdmitx_device, char *buffer,
 	}
 #endif
 
+	if (pRXCap->dv_info.ieeeoui == 0x00d046)
+		pos += snprintf(buffer+pos, buffer_len-pos,
+			"  DolbyVision%d", pRXCap->dv_info.ver);
+	if (pRXCap->hdr_sup_eotf_smpte_st_2084)
+		pos += snprintf(buffer+pos, buffer_len-pos, "  HDR");
+	if (pRXCap->dc_y444 || pRXCap->dc_30bit || pRXCap->dc_30bit_420)
+		pos += snprintf(buffer+pos, buffer_len-pos, "  DeepColor");
+	pos += snprintf(buffer+pos, buffer_len-pos, "\n");
+
 	/* for checkvalue which maybe used by application to adjust
 		whether edid is changed */
 	pos += snprintf(buffer+pos, buffer_len-pos,
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
index 6717bc1..766c95e 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
@@ -82,9 +82,13 @@ static int edid_rx_ext_data(unsigned char *ext, unsigned char regaddr,
 static void gpio_read_edid(unsigned char *rx_edid);
 static void hdmitx_get_edid(struct hdmitx_dev *hdev);
 static void hdmitx_set_drm_pkt(struct master_display_info_s *data);
+static void hdmitx_set_vsif_pkt(enum eotf_type type, uint8_t tunnel_mode);
 static int check_fbc_special(unsigned char *edid_dat);
 static int hdcp_tst_sig;
 
+/* add attr for hdmi output colorspace and colordepth */
+static char fmt_attr[16];
+
 #ifndef CONFIG_AM_TV_OUTPUT
 /* Fake vinfo */
 const struct vinfo_s vinfo_1080p60hz = {
@@ -106,19 +110,25 @@ const struct vinfo_s *get_current_vinfo(void)
 #endif
 
 struct hdmi_config_platform_data *hdmi_pdata;
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 static int suspend_flag;
-#endif
 
 static struct hdmitx_dev hdmitx_device;
 static struct switch_dev sdev = { /* android ics switch device */
 	.name = "hdmi",
 };
+static struct switch_dev hdmi_audio = {
+	.name = "hdmi_audio",
+};
 static struct switch_dev hdmi_power = { /* android ics switch device */
 	.name = "hdmi_power",
 };
+static struct switch_dev hdmi_hdr = {
+	.name = "hdmi_hdr",
+};
 static int edid_read_flag __nosavedata;
 
+static int hdmi_init;
+
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
 static void hdmitx_early_suspend(struct early_suspend *h)
@@ -128,11 +138,11 @@ static void hdmitx_early_suspend(struct early_suspend *h)
 	if (info && (strncmp(info->name, "panel", 5) == 0
 		|| strncmp(info->name, "null", 4) == 0))
 		return;
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 	suspend_flag = 1;
-#endif
 	phdmi->hpd_lock = 1;
 	hdcp_tst_sig = 1;
+	pr_info("%s[%d] set hdcp_pwr as %d\n", __func__, __LINE__,
+		hdcp_tst_sig);
 	msleep(20);
 	phdmi->HWOp.CntlMisc(phdmi, MISC_AVMUTE_OP, SET_AVMUTE);
 	mdelay(100);
@@ -196,9 +206,7 @@ static void hdmitx_late_resume(struct early_suspend *h)
 		CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
 	hdmitx_device.internal_mode_change = 0;
 	set_disp_mode_auto();
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 	suspend_flag = 0;
-#endif
 	switch_set_state(&sdev, hdmitx_device.hpd_state);
 	switch_set_state(&hdmi_power, hdmitx_device.hpd_state);
 	pr_info("amhdmitx: late resume module %d\n", __LINE__);
@@ -353,12 +361,6 @@ static  int  set_disp_mode(const char *mode)
 		vic = HDMI_4k2k_24;
 	else if (strncmp(mode, "smpte24hz", strlen("smpte24hz")) == 0)
 		vic = HDMI_4k2k_smpte_24;
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	else if (strncmp(mode, "4k2k29hz", strlen("4k2k29hz")) == 0)
-		vic = HDMI_4k2k_30;
-	else if (strncmp(mode, "4k2k23hz", strlen("4k2k23hz")) == 0)
-		vic = HDMI_4k2k_24;
-#endif
 	else
 		;/* nothing */
 
@@ -428,7 +430,6 @@ static void hdmitx_pre_display_init(void)
 	hdmitx_device.internal_mode_change = 0;
 }
 
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 /*  */
 /* input para: name of vmode, such as "1080p50hz" */
 /* return values: */
@@ -453,7 +454,38 @@ int hdmitx_is_vmode_supported(char *mode_name)
 }
 EXPORT_SYMBOL(hdmitx_is_vmode_supported);
 
-#endif
+/* fr_tab[]
+ * 1080p24hz, 24:1
+ * 1080p23.976hz, 2997:125
+ * 25/50/100/200hz, no change
+ */
+static struct frac_rate_table fr_tab[] = {
+	{"24hz", 24, 1, 2997, 125},
+	{"30hz", 30, 1, 2997, 100},
+	{"60hz", 60, 1, 2997, 50},
+	{"120hz", 120, 1, 2997, 25},
+	{"240hz", 120, 1, 5994, 25},
+	{NULL},
+};
+
+static void recalc_vinfo_sync_duration(struct vinfo_s *info, unsigned int frac)
+{
+	struct frac_rate_table *fr = &fr_tab[0];
+
+	while (fr->hz) {
+		if (strstr(info->name, fr->hz)) {
+			if (frac) {
+				info->sync_duration_num = fr->sync_num_dec;
+				info->sync_duration_den = fr->sync_den_dec;
+			} else {
+				info->sync_duration_num = fr->sync_num_int;
+				info->sync_duration_den = fr->sync_den_int;
+			}
+			break;
+		}
+		fr++;
+	}
+}
 
 static int set_disp_mode_auto(void)
 {
@@ -477,6 +509,8 @@ static int set_disp_mode_auto(void)
 		return -1;
 
 	info->fresh_tx_hdr_pkt = hdmitx_set_drm_pkt;
+	info->fresh_tx_vsif_pkt = hdmitx_set_vsif_pkt;
+	info->dv_info = &hdev->RXCap.dv_info;
 	info->hdr_info.hdr_support = (hdev->RXCap.hdr_sup_eotf_sdr << 0)
 			| (hdev->RXCap.hdr_sup_eotf_hdr << 1)
 			| (hdev->RXCap.hdr_sup_eotf_smpte_st_2084 << 2);
@@ -497,16 +531,25 @@ static int set_disp_mode_auto(void)
 		hdev->HWOp.CntlConfig(hdev, CONF_CLR_VSDB_PACKET, 0);
 		hdev->HWOp.CntlMisc(hdev, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
 		hdev->HWOp.CntlConfig(hdev, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
-		hdev->para = para = hdmi_get_fmt_name("invalid");
+		hdev->para = para = hdmi_get_fmt_name("invalid", fmt_attr);
 		return -1;
-	} else
+	} else {
 		memcpy(mode, info->name, strlen(info->name));
-	if ((info->name) && (info->name[0]))
-		para = hdmi_get_fmt_name(info->name);
-	if ((info->ext_name) && (info->ext_name[0])) {
-		para = hdmi_get_fmt_name(info->ext_name);
-		pr_info("hdmitx: get ext_name %s\n", hdev->para->ext_name);
+		if (strstr(mode, "fp")) {
+			int i = 0;
+			for (; mode[i]; i++) {
+				if ((mode[i] == 'f') && (mode[i + 1] == 'p')) {
+					/* skip "f", 1080fp60hz -> 1080p60hz */
+					do {
+						mode[i] = mode[i + 1];
+						i++;
+					} while (mode[i]);
+					break;
+				}
+			}
+		}
 	}
+	para = hdmi_get_fmt_name(mode, fmt_attr);
 	hdev->para = para;
 	/* msleep(500); */
 	vic = hdmitx_edid_get_VIC(hdev, mode, 1);
@@ -524,10 +567,8 @@ static int set_disp_mode_auto(void)
 	else {
 	/* nothing */
 	}
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 	if (suspend_flag == 1)
 		vic_ready = HDMI_Unkown;
-#endif
 	if ((vic_ready != HDMI_Unkown) && (vic_ready == vic)) {
 		hdmi_print(IMP, SYS "[%s] ALREADY init VIC = %d\n",
 			__func__, vic);
@@ -555,6 +596,11 @@ static int set_disp_mode_auto(void)
 	hdev->cur_VIC = HDMI_Unkown;
 /* if vic is HDMI_Unkown, hdmitx_set_display will disable HDMI */
 	ret = hdmitx_set_display(hdev, vic);
+	pr_info("%s %d %d\n", info->name, info->sync_duration_num,
+		info->sync_duration_den);
+	recalc_vinfo_sync_duration(info, hdev->frac_rate_policy);
+	pr_info("%s %d %d\n", info->name, info->sync_duration_num,
+		info->sync_duration_den);
 	if (ret >= 0) {
 		hdev->HWOp.Cntl(hdev, HDMITX_AVMUTE_CNTL, AVMUTE_CLEAR);
 		hdev->cur_VIC = vic;
@@ -577,26 +623,6 @@ static int set_disp_mode_auto(void)
 				(hpdmode == 2)?1:0);
 		}
 	}
-	if (hdev->para->cs == COLORSPACE_YUV420) {
-		switch (hdev->cur_VIC) {
-		/* Currently, only below formats support 420 mode */
-		case HDMI_3840x2160p60_16x9:
-		case HDMI_3840x2160p50_16x9:
-		case HDMI_3840x2160p50_16x9_Y420:
-		case HDMI_3840x2160p60_16x9_Y420:
-		case HDMI_4096x2160p60_256x135:
-		case HDMI_4096x2160p50_256x135:
-		case HDMI_4096x2160p50_256x135_Y420:
-		case HDMI_4096x2160p60_256x135_Y420:
-			pr_info("configure mode420, VIC = %d\n",
-				hdev->cur_VIC);
-			hdev->HWOp.CntlMisc(hdev, MISC_CONF_MODE420, 0);
-			break;
-		default:
-			pr_info("mode420 is not supported at VIC: %d for now.\n",
-				hdev->cur_VIC);
-		}
-	}
 	hdmitx_set_audio(hdev, &(hdev->cur_audio_param), hdmi_ch);
 	hdev->output_blank_flag = 1;
 	if (hdev->hdcp_mode == 1) {
@@ -635,7 +661,23 @@ static ssize_t store_disp_mode(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
 	set_disp_mode(buf);
-	return 16;
+	return count;
+}
+
+static ssize_t show_attr(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	int pos = 0;
+
+	pos += snprintf(buf+pos, PAGE_SIZE, "%s\n\r", fmt_attr);
+	return pos;
+}
+
+static ssize_t store_attr(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	memcpy(fmt_attr, buf, sizeof(fmt_attr));
+	return count;
 }
 
 /*aud_mode attr*/
@@ -884,65 +926,19 @@ static ssize_t show_rawedid(struct device *dev,
 	struct hdmitx_dev *hdev = &hdmitx_device;
 	int num;
 
-	if (hdev->EDID_buf[0x7e] < 4)
-		num = (hdev->EDID_buf[0x7e]+1)*0x80;
+	if (hdev->edid_ptr[0x7e] < 4)
+		num = (hdev->edid_ptr[0x7e]+1)*0x80;
 	else
 		num = 0x100;
 
 	for (i = 0; i < num; i++)
-		pos += snprintf(buf+pos, PAGE_SIZE, "%02x", hdev->EDID_buf[i]);
+		pos += snprintf(buf+pos, PAGE_SIZE, "%02x", hdev->edid_ptr[i]);
 
 	pos += snprintf(buf+pos, PAGE_SIZE, "\n");
 
 	return pos;
 }
 
-static void dump_tx_info(void)
-{
-	struct hdmitx_dev *hdev = &hdmitx_device;
-
-	pr_info("dump tx info\n");
-	pr_info("cur_VIC=%d\n", hdev->cur_VIC);
-	if (hdev->cur_video_param)
-		pr_info("cur_video_param->VIC=%d\n",
-			hdev->cur_video_param->VIC);
-	if (hdev->para) {
-		pr_info("name=%s\n", hdev->para->ext_name);
-		pr_info("cd=%d\n", hdev->para->cd);
-		pr_info("cs=%d\n", hdev->para->cs);
-	}
-}
-
-/*config attr*/
-static ssize_t show_config(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	int pos = 0;
-	unsigned char *aud_conf;
-
-	dump_tx_info();
-	switch (hdmitx_device.tx_aud_cfg) {
-	case 0:
-	aud_conf = "off";
-	break;
-	case 1:
-	aud_conf = "on";
-	break;
-	case 2:
-	aud_conf = "auto";
-	break;
-	default:
-	aud_conf = "none";
-	}
-	pos += snprintf(buf+pos, PAGE_SIZE,
-		"disp switch (force or edid): %s\n",
-		(hdmitx_device.disp_switch_config ==
-		DISP_SWITCH_FORCE)?"force":"edid");
-	pos += snprintf(buf+pos, PAGE_SIZE, "audio config: %s\n",
-		aud_conf);
-	return pos;
-}
-
 void hdmitx_audio_mute_op(unsigned int flag)
 {
 	hdmitx_device.tx_aud_cfg = flag;
@@ -955,6 +951,22 @@ void hdmitx_audio_mute_op(unsigned int flag)
 }
 EXPORT_SYMBOL(hdmitx_audio_mute_op);
 
+static void hdr_work_func(struct work_struct *work)
+{
+	struct hdmitx_dev *hdev =
+		container_of(work, struct hdmitx_dev, work_hdr);
+
+	if (hdev->hdr_src_feature == 0) {
+		unsigned char DRM_HB[3] = {0x87, 0x1, 26};
+		unsigned char DRM_DB[26] = {0x0};
+		hdev->HWOp.SetPacket(HDMI_PACKET_DRM, DRM_DB, DRM_HB);
+		hdev->HWOp.CntlConfig(hdev, CONF_AVI_BT2020, CLR_AVI_BT2020);
+		msleep(1500);
+		hdev->HWOp.SetPacket(HDMI_PACKET_DRM, NULL, NULL);
+	}
+	/* switch_set_state(&hdmi_hdr, hdev->hdr_src_feature); */
+}
+
 #define GET_LOW8BIT(a)	((a) & 0xff)
 #define GET_HIGH8BIT(a)	(((a) >> 8) & 0xff)
 static void hdmitx_set_drm_pkt(struct master_display_info_s *data)
@@ -962,6 +974,7 @@ static void hdmitx_set_drm_pkt(struct master_display_info_s *data)
 	struct hdmitx_dev *hdev = &hdmitx_device;
 	unsigned char DRM_HB[3] = {0x87, 0x1, 26};
 	unsigned char DRM_DB[26] = {0x0};
+	static int hdr_state;
 
 	if ((!data) || (!(hdev->RXCap.hdr_sup_eotf_smpte_st_2084) &&
 		!(hdev->RXCap.hdr_sup_eotf_hdr) &&
@@ -976,6 +989,11 @@ static void hdmitx_set_drm_pkt(struct master_display_info_s *data)
 	}
 
 	hdev->hdr_src_feature = (((data->features >> 16) & 0xff) == 0x9);
+	if (hdr_state != hdev->hdr_src_feature) {
+		hdr_state = hdev->hdr_src_feature;
+		schedule_work(&hdev->work_hdr);
+	}
+
 	/* update DRM data */
 	if ((hdev->RXCap.hdr_sup_eotf_smpte_st_2084) && hdev->hdr_src_feature)
 		DRM_DB[0] = 0x02; /* SMPTE ST 2084 */
@@ -1007,12 +1025,144 @@ static void hdmitx_set_drm_pkt(struct master_display_info_s *data)
 	DRM_DB[19] = GET_HIGH8BIT(data->luminance[0]);
 	DRM_DB[20] = GET_LOW8BIT(data->luminance[1]);
 	DRM_DB[21] = GET_HIGH8BIT(data->luminance[1]);
+	DRM_DB[22] = GET_LOW8BIT(data->max_content);
+	DRM_DB[23] = GET_HIGH8BIT(data->max_content);
+	DRM_DB[24] = GET_LOW8BIT(data->max_frame_average);
+	DRM_DB[25] = GET_HIGH8BIT(data->max_frame_average);
 
 	hdmitx_device.HWOp.SetPacket(HDMI_PACKET_DRM, DRM_DB, DRM_HB);
 	hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AVI_BT2020,
 			SET_AVI_BT2020);
 }
 
+static void hdmitx_set_vsif_pkt(enum eotf_type type, uint8_t tunnel_mode)
+{
+	struct hdmitx_dev *hdev = &hdmitx_device;
+	unsigned char VEN_HB[3] = {0x81, 0x01};
+	unsigned char VEN_DB[24] = {0x00};
+	unsigned char len = 0;
+	unsigned int vic = hdev->cur_VIC;
+	unsigned int hdmi_vic_4k_flag = 0;
+
+	if (get_cpu_type() < MESON_CPU_MAJOR_ID_GXL) {
+		pr_info("hdmitx: not support DolbyVision\n");
+		return;
+	}
+
+	if ((vic == HDMI_3840x2160p30_16x9) ||
+	    (vic == HDMI_3840x2160p25_16x9) ||
+	    (vic == HDMI_3840x2160p24_16x9) ||
+	    (vic == HDMI_4096x2160p24_256x135))
+		hdmi_vic_4k_flag = 1;
+
+	switch (type) {
+	case EOTF_T_DOLBYVISION:
+		len = 0x18;
+		break;
+	case EOTF_T_HDR10:
+		len = 0x05;
+		break;
+	case EOTF_T_SDR:
+		len = 0x05;
+		break;
+	case EOTF_T_NULL:
+	default:
+		len = 0x05;
+		break;
+	}
+
+	VEN_HB[2] = len;
+	VEN_DB[0] = 0x03;
+	VEN_DB[1] = 0x0c;
+	VEN_DB[2] = 0x00;
+	VEN_DB[3] = 0x00;
+
+	if (hdmi_vic_4k_flag) {
+		VEN_DB[3] = 0x20;
+		if (vic == HDMI_3840x2160p30_16x9)
+			VEN_DB[4] = 0x1;
+		else if (vic == HDMI_3840x2160p25_16x9)
+			VEN_DB[4] = 0x2;
+		else if (vic == HDMI_3840x2160p24_16x9)
+			VEN_DB[4] = 0x3;
+		else if (vic == HDMI_4096x2160p24_256x135)
+			VEN_DB[4] = 0x4;
+		else
+			VEN_DB[4] = 0x0;
+	}
+
+	if (type == EOTF_T_DOLBYVISION) {
+		hdev->HWOp.SetPacket(HDMI_PACKET_VEND, VEN_DB, VEN_HB);
+		if (tunnel_mode == 1) {
+			hdev->HWOp.CntlConfig(hdev, CONF_AVI_RGBYCC_INDIC,
+				COLORSPACE_RGB444);
+			hdev->HWOp.CntlConfig(hdev, CONF_AVI_Q01,
+				RGB_RANGE_FUL);
+		} else {
+			hdev->HWOp.CntlConfig(hdev, CONF_AVI_RGBYCC_INDIC,
+				COLORSPACE_YUV422);
+			hdev->HWOp.CntlConfig(hdev, CONF_AVI_YQ01,
+				YCC_RANGE_FUL);
+		}
+	} else {
+		if (hdmi_vic_4k_flag)
+			hdev->HWOp.SetPacket(HDMI_PACKET_VEND, VEN_DB, VEN_HB);
+		else
+			hdev->HWOp.SetPacket(HDMI_PACKET_VEND, NULL, NULL);
+		hdev->HWOp.CntlConfig(hdev, CONF_AVI_RGBYCC_INDIC,
+			hdev->para->cs);
+		hdev->HWOp.CntlConfig(hdev, CONF_AVI_Q01, RGB_RANGE_LIM);
+		hdev->HWOp.CntlConfig(hdev, CONF_AVI_YQ01, YCC_RANGE_LIM);
+	}
+}
+
+/*config attr*/
+static ssize_t show_config(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	int pos = 0;
+	unsigned char *conf;
+	struct hdmitx_dev *hdev = &hdmitx_device;
+
+	pos += snprintf(buf+pos, PAGE_SIZE, "cur_VIC: %d\n", hdev->cur_VIC);
+	if (hdev->cur_video_param)
+		pos += snprintf(buf+pos, PAGE_SIZE,
+			"cur_video_param->VIC=%d\n",
+			hdev->cur_video_param->VIC);
+	if (hdev->para) {
+		pos += snprintf(buf+pos, PAGE_SIZE, "cd = %d\n",
+			hdev->para->cd);
+		pos += snprintf(buf+pos, PAGE_SIZE, "cs = %d\n",
+			hdev->para->cs);
+	}
+
+	switch (hdev->tx_aud_cfg) {
+	case 0:
+		conf = "off";
+		break;
+	case 1:
+		conf = "on";
+		break;
+	case 2:
+		conf = "auto";
+		break;
+	default:
+		conf = "none";
+	}
+	pos += snprintf(buf+pos, PAGE_SIZE, "audio config: %s\n", conf);
+
+	if (hdev->flag_3dfp)
+		conf = "FramePacking";
+	else if (hdev->flag_3dss)
+		conf = "SidebySide";
+	else if (hdev->flag_3dtb)
+		conf = "TopButtom";
+	else
+		conf = "off";
+	pos += snprintf(buf+pos, PAGE_SIZE, "3D config: %s\n", conf);
+	return pos;
+}
+
 static ssize_t store_config(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
@@ -1029,25 +1179,35 @@ static ssize_t store_config(struct device *dev,
 		else
 			hdmitx_device.unplug_powerdown = 1;
 	} else if (strncmp(buf, "3d", 2) == 0) {
-		/* First, disable HDMI TMDS */
-		hdmitx_device.HWOp.CntlMisc(&hdmitx_device,
-			MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
 		/* Second, set 3D parameters */
-		if (strncmp(buf+2, "tb", 2) == 0)
-			hdmi_set_3d(&hdmitx_device, 6, 0);
-		else if (strncmp(buf+2, "lr", 2) == 0) {
+		if (strncmp(buf+2, "tb", 2) == 0) {
+			hdmitx_device.flag_3dtb = 1;
+			hdmitx_device.flag_3dss = 0;
+			hdmitx_device.flag_3dfp = 0;
+			hdmi_set_3d(&hdmitx_device, T3D_TAB, 0);
+		} else if ((strncmp(buf+2, "lr", 2) == 0) ||
+			(strncmp(buf+2, "ss", 2) == 0)) {
 			unsigned long sub_sample_mode = 0;
+			hdmitx_device.flag_3dtb = 0;
+			hdmitx_device.flag_3dss = 1;
+			hdmitx_device.flag_3dfp = 0;
 			if (buf[2])
 				ret = kstrtoul(buf+2, 10,
 					&sub_sample_mode);
-		/* side by side */
-			hdmi_set_3d(&hdmitx_device, 8, sub_sample_mode);
-		} else if (strncmp(buf+2, "off", 3) == 0)
-			hdmi_set_3d(&hdmitx_device, 0xf, 0);
-		/* Last, delay sometime and enable HDMI TMDS */
-		msleep(20);
-		hdmitx_device.HWOp.CntlMisc(&hdmitx_device,
-			MISC_TMDS_PHY_OP, TMDS_PHY_ENABLE);
+			/* side by side */
+			hdmi_set_3d(&hdmitx_device, T3D_SBS_HALF,
+				sub_sample_mode);
+		} else if (strncmp(buf+2, "fp", 2) == 0) {
+			hdmitx_device.flag_3dtb = 0;
+			hdmitx_device.flag_3dss = 0;
+			hdmitx_device.flag_3dfp = 1;
+			hdmi_set_3d(&hdmitx_device, T3D_FRAME_PACKING, 0);
+		} else if (strncmp(buf+2, "off", 3) == 0) {
+			hdmitx_device.flag_3dfp = 0;
+			hdmitx_device.flag_3dtb = 0;
+			hdmitx_device.flag_3dss = 0;
+			hdmi_set_3d(&hdmitx_device, T3D_DISABLE, 0);
+		}
 	} else if (strncmp(buf, "audio_", 6) == 0) {
 		if (strncmp(buf+6, "off", 3) == 0) {
 			hdmitx_audio_mute_op(0);
@@ -1075,7 +1235,9 @@ static ssize_t store_config(struct device *dev,
 		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXTVBB)
 			hdmitx_device.HWOp.SetPacket(HDMI_PACKET_DRM,
 				DRM_DB, DRM_HB);
-	}
+	} else if (strncmp(buf, "vsif", 4) == 0)
+		hdmitx_set_vsif_pkt(buf[4] - '0', buf[5] == '1');
+
 	return 16;
 }
 
@@ -1084,19 +1246,13 @@ static ssize_t store_debug(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
 	hdmitx_device.HWOp.DebugFun(&hdmitx_device, buf);
-	return 16;
+	return count;
 }
 
 /* support format lists */
 const char *disp_mode_t[] = {
-	"480i60hz",
-	"480i_rpt",
 	"480p60hz",
-	"480p_rpt",
-	"576i50hz",
-	"576i_rpt",
 	"576p50hz",
-	"576p_rpt",
 	"720p60hz",
 	"1080i60hz",
 	"1080p60hz",
@@ -1155,6 +1311,23 @@ static ssize_t show_disp_cap(struct device *dev,
 
 
 /**/
+static int local_support_3dfp(enum hdmi_vic vic)
+{
+	switch (vic) {
+	case HDMI_1280x720p50_16x9:
+	case HDMI_1280x720p60_16x9:
+	case HDMI_1920x1080p24_16x9:
+	case HDMI_1920x1080p25_16x9:
+	case HDMI_1920x1080p30_16x9:
+	case HDMI_1920x1080p50_16x9:
+	case HDMI_1920x1080p60_16x9:
+		return 1;
+		break;
+	default:
+		return 0;
+		break;
+	}
+}
 static ssize_t show_disp_cap_3d(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
@@ -1162,23 +1335,28 @@ static ssize_t show_disp_cap_3d(struct device *dev,
 	int j = 0;
 	enum hdmi_vic vic;
 
+	pos += snprintf(buf+pos, PAGE_SIZE, "3D support lists:\n");
 	for (i = 0; disp_mode_t[i]; i++) {
+		/* 3D is not supported under 4k modes */
+		if (strstr(disp_mode_t[i], "2160p") ||
+			strstr(disp_mode_t[i], "smpte"))
+			continue;
 		vic = hdmitx_edid_get_VIC(&hdmitx_device,
 			disp_mode_t[i], 0);
-	if (vic == hdmitx_device.cur_VIC) {
 		for (j = 0; j < hdmitx_device.RXCap.VIC_count; j++) {
 			if (vic == hdmitx_device.RXCap.VIC[j])
 				break;
 		}
-		pos += snprintf(buf+pos, PAGE_SIZE, "%s ",
+		pos += snprintf(buf+pos, PAGE_SIZE, "\n%s ",
 			disp_mode_t[i]);
-		if (hdmitx_device.RXCap.support_3d_format[
-			hdmitx_device.RXCap.VIC[j]].frame_packing == 1){
+		if (local_support_3dfp(vic)
+			&& (hdmitx_device.RXCap.support_3d_format[
+			hdmitx_device.RXCap.VIC[j]].frame_packing == 1)) {
 			pos += snprintf(buf+pos, PAGE_SIZE,
 				"FramePacking ");
 		}
 		if (hdmitx_device.RXCap.support_3d_format[
-			hdmitx_device.RXCap.VIC[j]].top_and_bottom == 1){
+			hdmitx_device.RXCap.VIC[j]].top_and_bottom == 1) {
 			pos += snprintf(buf+pos, PAGE_SIZE,
 				"TopBottom ");
 		}
@@ -1188,7 +1366,6 @@ static ssize_t show_disp_cap_3d(struct device *dev,
 				"SidebySide ");
 		}
 	}
-	}
 	pos += snprintf(buf+pos, PAGE_SIZE, "\n");
 
 	return pos;
@@ -1239,41 +1416,105 @@ static ssize_t show_aud_cap(struct device *dev,
 static ssize_t show_dc_cap(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
+	enum hdmi_vic vic = HDMI_Unkown;
 	int pos = 0;
 	struct rx_cap *pRXCap = &(hdmitx_device.RXCap);
 
-	pos += snprintf(buf + pos, PAGE_SIZE, "DeepColor:\n");
-
+#if 0
+	if (pRXCap->dc_48bit_420)
+		pos += snprintf(buf + pos, PAGE_SIZE, "420,16bit\n");
+	if (pRXCap->dc_36bit_420)
+		pos += snprintf(buf + pos, PAGE_SIZE, "420,12bit\n");
+#endif
+	if (pRXCap->dc_30bit_420) {
+		pos += snprintf(buf + pos, PAGE_SIZE, "420,10bit\n");
+		pos += snprintf(buf + pos, PAGE_SIZE, "420,8bit\n");
+	} else {
+		vic = hdmitx_edid_get_VIC(&hdmitx_device, "2160p60hz420", 0);
+		if (vic != HDMI_Unkown) {
+			pos += snprintf(buf + pos, PAGE_SIZE, "420,8bit\n");
+			goto next444;
+		}
+		vic = hdmitx_edid_get_VIC(&hdmitx_device, "2160p50hz420", 0);
+		if (vic != HDMI_Unkown) {
+			pos += snprintf(buf + pos, PAGE_SIZE, "420,8bit\n");
+			goto next444;
+		}
+	}
+next444:
 	if (pRXCap->dc_y444) {
-		if (pRXCap->dc_30bit)
-			pos += snprintf(buf + pos, PAGE_SIZE, "  Y444 10bit\n");
+#if 0
 		if (pRXCap->dc_36bit)
-			pos += snprintf(buf + pos, PAGE_SIZE, "  Y444 12bit\n");
-		if (pRXCap->dc_48bit)
-			pos += snprintf(buf + pos, PAGE_SIZE, "  Y444 16bit\n");
-		if (pRXCap->dc_30bit)
-			pos += snprintf(buf + pos, PAGE_SIZE, "  Y422 10bit\n");
+			pos += snprintf(buf + pos, PAGE_SIZE, "444,12bit\n");
 		if (pRXCap->dc_36bit)
-			pos += snprintf(buf + pos, PAGE_SIZE, "  Y422 12bit\n");
+			pos += snprintf(buf + pos, PAGE_SIZE, "422,12bit\n");
+#endif
+		if (pRXCap->dc_30bit) {
+			pos += snprintf(buf + pos, PAGE_SIZE, "444,10bit\n");
+			pos += snprintf(buf + pos, PAGE_SIZE, "444,8bit\n");
+		}
+#if 0
+		if (pRXCap->dc_48bit)
+			pos += snprintf(buf + pos, PAGE_SIZE, "444,16bit\n");
+#endif
+		if (pRXCap->dc_30bit) {
+			pos += snprintf(buf + pos, PAGE_SIZE, "422,10bit\n");
+			pos += snprintf(buf + pos, PAGE_SIZE, "422,8bit\n");
+			goto nextrgb;
+		}
+	} else {
+		if (pRXCap->native_Mode & (1 << 5))
+			pos += snprintf(buf + pos, PAGE_SIZE, "444,8bit\n");
+		if (pRXCap->native_Mode & (1 << 4))
+			pos += snprintf(buf + pos, PAGE_SIZE, "422,8bit\n");
 	}
-
-	if (pRXCap->dc_30bit)
-		pos += snprintf(buf + pos, PAGE_SIZE, "  RGB 10bit\n");
-	if (pRXCap->dc_36bit)
-		pos += snprintf(buf + pos, PAGE_SIZE, "  RGB 12bit\n");
+nextrgb:
+#if 0
 	if (pRXCap->dc_48bit)
-		pos += snprintf(buf + pos, PAGE_SIZE, "  RGB 16bit\n");
+		pos += snprintf(buf + pos, PAGE_SIZE, "rgb,16bit\n");
+	if (pRXCap->dc_36bit)
+		pos += snprintf(buf + pos, PAGE_SIZE, "rgb,12bit\n");
+#endif
+	if (pRXCap->dc_30bit)
+		pos += snprintf(buf + pos, PAGE_SIZE, "rgb,10bit\n");
+	pos += snprintf(buf + pos, PAGE_SIZE, "rgb,8bit\n");
+	return pos;
+}
 
-	if (pRXCap->dc_30bit_420)
-		pos += snprintf(buf + pos, PAGE_SIZE, "  Y420 10bit\n");
-	if (pRXCap->dc_36bit_420)
-		pos += snprintf(buf + pos, PAGE_SIZE, "  Y420 12bit\n");
-	if (pRXCap->dc_48bit_420)
-		pos += snprintf(buf + pos, PAGE_SIZE, "  Y420 16bit\n");
+static bool valid_mode;
+static char cvalid_mode[32];
+static ssize_t show_valid_mode(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	int pos = 0;
+	struct hdmi_format_para *para = NULL;
+
+	if (cvalid_mode[0])
+		para = hdmi_get_fmt_name(cvalid_mode, cvalid_mode);
+	if (para) {
+		pr_info("sname = %s\n", para->sname);
+		pr_info("char_clk = %d\n", para->tmds_clk);
+		pr_info("cd = %d\n", para->cd);
+		pr_info("cs = %d\n", para->cs);
+	}
+
+	valid_mode = hdmitx_edid_check_valid_mode(&hdmitx_device, para);
+
+	pos += snprintf(buf + pos, PAGE_SIZE, "%d\n\r", valid_mode);
 
 	return pos;
 }
 
+static ssize_t store_valid_mode(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	memset(cvalid_mode, 0, sizeof(cvalid_mode));
+	memcpy(cvalid_mode, buf, sizeof(cvalid_mode));
+	cvalid_mode[31] = '\0';
+	return count;
+}
+
+
 /**/
 static ssize_t show_hdr_cap(struct device *dev,
 	struct device_attribute *attr, char *buf)
@@ -1303,6 +1544,36 @@ static ssize_t show_hdr_cap(struct device *dev,
 	return pos;
 }
 
+static ssize_t show_dv_cap(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	int pos = 0;
+	const struct dv_info *dv = &(hdmitx_device.RXCap.dv_info);
+
+	if (dv->ieeeoui != 0x00d046)
+		return pos;
+	pos += snprintf(buf + pos, PAGE_SIZE,
+		"DolbyVision%d RX support list:\n", dv->ver);
+	if (dv->sup_yuv422_12bit)
+		pos += snprintf(buf + pos, PAGE_SIZE, "    yuv422_12bit\n");
+	pos += snprintf(buf + pos, PAGE_SIZE,
+		"    2160p%shz: 1\n", dv->sup_2160p60hz ? "60" : "30");
+	if (dv->sup_global_dimming)
+		pos += snprintf(buf + pos, PAGE_SIZE, "    global dimming\n");
+	if (dv->colorimetry)
+		pos += snprintf(buf + pos, PAGE_SIZE, "    colorimetry\n");
+	pos += snprintf(buf + pos, PAGE_SIZE,
+		"    IEEEOUI: 0x%06x\n", dv->ieeeoui);
+	if (dv->ver == 0)
+		pos += snprintf(buf + pos, PAGE_SIZE, "    DM Ver: %x:%x\n",
+			dv->vers.ver0.dm_major_ver, dv->vers.ver0.dm_minor_ver);
+	if (dv->ver == 1)
+		pos += snprintf(buf + pos, PAGE_SIZE, "    DM Ver: %x\n",
+			dv->vers.ver1.dm_version);
+
+	return pos;
+}
+
 static ssize_t show_aud_ch(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
@@ -1358,6 +1629,7 @@ static ssize_t store_aud_output_chs(struct device *dev,
 	int tmp = -1;
 	int ret = 0;
 	unsigned long msk;
+	static unsigned int update_flag = -1;
 
 	if (isdigit(buf[0]))
 		tmp = buf[0] - '0';
@@ -1365,7 +1637,10 @@ static ssize_t store_aud_output_chs(struct device *dev,
 	if (!((tmp == 2) || (tmp == 4) || (tmp == 6) || (tmp == 8))) {
 		pr_info("err chn setting, must be 2, 4, 6 or 8, Rst as def\n");
 		hdev->aud_output_ch = 0;
-		hdmitx_set_audio(hdev, &(hdev->cur_audio_param), 0);
+		if (update_flag != hdev->aud_output_ch) {
+			update_flag = hdev->aud_output_ch;
+			hdmitx_set_audio(hdev, &(hdev->cur_audio_param), 0);
+		}
 		return count;
 	}
 
@@ -1380,9 +1655,10 @@ static ssize_t store_aud_output_chs(struct device *dev,
 	}
 
 	hdev->aud_output_ch = (tmp << 4) + msk;
-
-	hdmitx_set_audio(hdev, &(hdev->cur_audio_param), 0);
-
+	if (update_flag != hdev->aud_output_ch) {
+		update_flag = hdev->aud_output_ch;
+		hdmitx_set_audio(hdev, &(hdev->cur_audio_param), 0);
+	}
 	return count;
 }
 
@@ -1469,6 +1745,34 @@ static ssize_t show_phy(struct device *dev,
 	return 0;
 }
 
+static ssize_t store_frac_rate(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	int val = 0;
+
+	if (isdigit(buf[0])) {
+		val = buf[0] - '0';
+		pr_info("hdmitx: set frac_rate_policy as %d\n", val);
+		if ((val == 0) || (val == 1))
+			hdmitx_device.frac_rate_policy = val;
+		else
+			pr_info("only accept as 0 or 1\n");
+	}
+
+	return count;
+}
+
+static ssize_t show_frac_rate(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	int pos = 0;
+
+	pos += snprintf(buf + pos, PAGE_SIZE, "%d\n",
+		hdmitx_device.frac_rate_policy);
+
+	return pos;
+}
+
 static ssize_t store_hdcp_clkdis(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
@@ -1488,6 +1792,11 @@ static ssize_t show_hdcp_clkdis(struct device *dev,
 static ssize_t store_hdcp_pwr(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
+	if (buf[0] == '1') {
+		hdcp_tst_sig = 1;
+		pr_info("%s[%d] set hdcp_pwr as %d\n", __func__, __LINE__,
+			hdcp_tst_sig);
+	}
 	return count;
 }
 
@@ -1497,9 +1806,11 @@ static ssize_t show_hdcp_pwr(struct device *dev,
 	int pos = 0;
 
 	pos += snprintf(buf + pos, PAGE_SIZE, "%d\n", !!hdcp_tst_sig);
-	if (hdcp_tst_sig == 1)
+	if (hdcp_tst_sig == 1) {
 		hdcp_tst_sig = 0;
-
+		pr_info("%s[%d] set hdcp_pwr as %d\n", __func__, __LINE__,
+			hdcp_tst_sig);
+	}
 	return pos;
 }
 
@@ -1641,6 +1952,10 @@ EXPORT_SYMBOL(direct_hdcptx14_stop);
 static ssize_t store_hdcp_ctrl(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
+	if (hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_14_LSTORE,
+		0) == 0)
+		return count;
+
 	dev_warn(dev, "hdmitx20: %s\n", buf);
 	if (strncmp(buf, "stop", 4) == 0) {
 		if (strncmp(buf+4, "14", 2) == 0)
@@ -1740,6 +2055,15 @@ static ssize_t show_hpd_state(struct device *dev,
 	return pos;
 }
 
+static ssize_t show_hdmi_init(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	int pos = 0;
+
+	pos += snprintf(buf+pos, PAGE_SIZE, "%d\n\r", hdmi_init);
+	return pos;
+}
+
 static ssize_t show_ready(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
@@ -1784,22 +2108,9 @@ void hdmi_print(int dbg_lvl, const char *fmt, ...)
 	}
 }
 
-static ssize_t store_output_rgb(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	if (strncmp(buf, "1", 1) == 0)
-		hdmitx_output_rgb();
-
-	hdmitx_set_display(&hdmitx_device, hdmitx_device.cur_VIC);
-
-	return count;
-}
-
-static DEVICE_ATTR(output_rgb, S_IWUSR | S_IWGRP,
-	NULL, store_output_rgb);
-
 static DEVICE_ATTR(disp_mode, S_IWUSR | S_IRUGO | S_IWGRP,
 	show_disp_mode, store_disp_mode);
+static DEVICE_ATTR(attr, S_IWUSR | S_IRUGO | S_IWGRP, show_attr, store_attr);
 static DEVICE_ATTR(aud_mode, S_IWUSR | S_IRUGO, show_aud_mode,
 	store_aud_mode);
 static DEVICE_ATTR(edid, S_IWUSR | S_IRUGO, show_edid, store_edid);
@@ -1810,7 +2121,10 @@ static DEVICE_ATTR(debug, S_IWUSR, NULL, store_debug);
 static DEVICE_ATTR(disp_cap, S_IRUGO, show_disp_cap, NULL);
 static DEVICE_ATTR(aud_cap, S_IRUGO, show_aud_cap, NULL);
 static DEVICE_ATTR(hdr_cap, S_IRUGO, show_hdr_cap, NULL);
+static DEVICE_ATTR(dv_cap, S_IRUGO, show_dv_cap, NULL);
 static DEVICE_ATTR(dc_cap, S_IRUGO, show_dc_cap, NULL);
+static DEVICE_ATTR(valid_mode, S_IWUSR | S_IRUGO | S_IWGRP, show_valid_mode,
+	store_valid_mode);
 static DEVICE_ATTR(aud_ch, S_IWUSR | S_IRUGO | S_IWGRP, show_aud_ch,
 	store_aud_ch);
 static DEVICE_ATTR(aud_output_chs, S_IWUSR | S_IRUGO | S_IWGRP,
@@ -1819,6 +2133,8 @@ static DEVICE_ATTR(avmute, S_IWUSR | S_IRUGO | S_IWGRP, show_avmute,
 	store_avmute);
 static DEVICE_ATTR(vic, S_IWUSR | S_IRUGO | S_IWGRP, show_vic, store_vic);
 static DEVICE_ATTR(phy, S_IWUSR | S_IRUGO | S_IWGRP, show_phy, store_phy);
+static DEVICE_ATTR(frac_rate_policy, S_IWUSR | S_IRUGO | S_IWGRP,
+	show_frac_rate, store_frac_rate);
 static DEVICE_ATTR(hdcp_clkdis, S_IWUSR | S_IRUGO | S_IWGRP, show_hdcp_clkdis,
 	store_hdcp_clkdis);
 static DEVICE_ATTR(hdcp_pwr, S_IWUSR | S_IRUGO | S_IWGRP, show_hdcp_pwr,
@@ -1835,6 +2151,7 @@ static DEVICE_ATTR(disp_cap_3d, S_IRUGO, show_disp_cap_3d, NULL);
 static DEVICE_ATTR(hdcp_ksv_info, S_IRUGO, show_hdcp_ksv_info, NULL);
 static DEVICE_ATTR(hdcp_ver, S_IRUGO, show_hdcp_ver, NULL);
 static DEVICE_ATTR(hpd_state, S_IRUGO, show_hpd_state, NULL);
+static DEVICE_ATTR(hdmi_init, S_IRUGO, show_hdmi_init, NULL);
 static DEVICE_ATTR(ready, S_IWUSR | S_IRUGO | S_IWGRP, show_ready, store_ready);
 static DEVICE_ATTR(support_3d, S_IRUGO, show_support_3d, NULL);
 
@@ -1845,19 +2162,15 @@ static DEVICE_ATTR(support_3d, S_IRUGO, show_support_3d, NULL);
 static int hdmitx_notify_callback_v(struct notifier_block *block,
 	unsigned long cmd , void *para)
 {
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 	enum hdmi_vic vic_ready = HDMI_Unkown;
 	enum hdmi_vic vic_now = HDMI_Unkown;
 	const struct vinfo_s *info = NULL;
-	enum fine_tune_mode_e fine_tune_mode = get_hpll_tune_mode();
-#endif
 	if (get_cur_vout_index() != 1)
 		return 0;
 
 	if (cmd != VOUT_EVENT_MODE_CHANGE)
 		return 0;
 
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 	if (suspend_flag == 1)
 		return 0;
 	/* vic_ready got from IP */
@@ -1871,14 +2184,6 @@ static int hdmitx_notify_callback_v(struct notifier_block *block,
 	}
 
 	vic_now = hdmitx_edid_get_VIC(&hdmitx_device, info->name, 1);
-	if ((HDMI_Unkown != vic_ready) && (vic_ready == vic_now)) {
-		if (KEEP_HPLL != fine_tune_mode) {
-			hdmitx_device.HWOp.CntlMisc(&hdmitx_device,
-				MISC_FINE_TUNE_HPLL, fine_tune_mode);
-			return 0;
-		}
-	}
-#endif
 	if (hdmitx_device.vic_count == 0) {
 		if (is_dispmode_valid_for_hdmi()) {
 			hdmitx_device.mux_hpd_if_pin_high_flag = 1;
@@ -2102,9 +2407,12 @@ static void hdmitx_get_edid(struct hdmitx_dev *hdev)
 			return;
 		} else {
 			hdev->HWOp.CntlDDC(hdev, DDC_PIN_MUX_OP, PIN_UNMUX);
-			gpio_read_edid(hdev->EDID_buf1);
-			msleep(20);
 			gpio_read_edid(hdev->EDID_buf);
+			/* If EDID is not correct at first time, then retry */
+			if (!check_dvi_hdmi_edid_valid(hdev->EDID_buf)) {
+				msleep(40);
+				gpio_read_edid(hdev->EDID_buf1);
+			}
 			edid_read_flag = 1;
 		}
 	} else {
@@ -2119,8 +2427,10 @@ static void hdmitx_get_edid(struct hdmitx_dev *hdev)
 		hdev->HWOp.CntlDDC(hdev, DDC_EDID_GET_DATA, 1);
 		hdev->HWOp.CntlDDC(hdev, DDC_PIN_MUX_OP, PIN_UNMUX);
 	}
-	/* compare EDID_buf & EDID_buf1 */
-	hdmitx_edid_buf_compare_print(hdev);
+	if (!check_dvi_hdmi_edid_valid(hdev->EDID_buf)) {
+		/* compare EDID_buf & EDID_buf1 */
+		hdmitx_edid_buf_compare_print(hdev);
+	}
 	hdmitx_edid_clear(hdev);
 	hdmitx_edid_parse(hdev);
 	mutex_unlock(&getedid_mutex);
@@ -2134,9 +2444,9 @@ static int get_downstream_hdcp_ver(void)
 		goto next;
 	if (hdcp_rd_hdcp22_ver())
 		return 22;
-next:	if (hdcp_rd_hdcp14_ver())
-		return 14;
-	return 0;
+next:
+	/* if (hdcp_rd_hdcp14_ver()) */
+	return 14;
 }
 
 static DEFINE_MUTEX(setclk_mutex);
@@ -2152,7 +2462,6 @@ void hdmitx_hpd_plugin_handler(struct work_struct *work)
 	pr_info("hdmitx: plugin\n");
 	hdev->hdmitx_event &= ~HDMI_TX_HPD_PLUGIN;
 	/* start reading E-EDID */
-	hdev->hpd_state = 1;
 	rx_repeat_hpd_state(1);
 	hdmitx_get_edid(hdev);
 	if (check_fbc_special(&hdev->EDID_buf[0])
@@ -2166,7 +2475,9 @@ void hdmitx_hpd_plugin_handler(struct work_struct *work)
 	rx_set_receive_hdcp(bksv_buf, 1, 1, 0, 0);
 	set_disp_mode_auto();
 	hdmitx_set_audio(hdev, &(hdev->cur_audio_param), hdmi_ch);
+	hdev->hpd_state = 1;
 	switch_set_state(&sdev, 1);
+	switch_set_state(&hdmi_audio, 1);
 
 	mutex_unlock(&setclk_mutex);
 }
@@ -2203,7 +2514,6 @@ void hdmitx_hpd_plugout_handler(struct work_struct *work)
 		return;
 	}
 	hdev->ready = 0;
-	hdev->hpd_state = 0;
 	rx_repeat_hpd_state(0);
 	hdev->HWOp.CntlConfig(hdev, CONF_CLR_AVI_PACKET, 0);
 	hdev->HWOp.CntlDDC(hdev, DDC_HDCP_MUX_INIT, 1);
@@ -2219,7 +2529,9 @@ void hdmitx_hpd_plugout_handler(struct work_struct *work)
 	clear_hdr_info(hdev);
 	hdmitx_edid_clear(hdev);
 	hdmitx_edid_ram_buffer_clear(hdev);
+	hdev->hpd_state = 0;
 	switch_set_state(&sdev, 0);
+	switch_set_state(&hdmi_audio, 0);
 	mutex_unlock(&setclk_mutex);
 }
 
@@ -2263,6 +2575,7 @@ static int hdmi_task_handle(void *data)
 		MISC_HPD_GPI_ST, 0));
 	hdmitx_device->hpd_state = sdev.state;
 	switch_set_state(&hdmi_power, hdmitx_device->hpd_state);
+	INIT_WORK(&hdmitx_device->work_hdr, hdr_work_func);
 
 /* When init hdmi, clear the hdmitx module edid ram and edid buffer. */
 	hdmitx_edid_ram_buffer_clear(hdmitx_device);
@@ -2291,6 +2604,7 @@ static int hdmi_task_handle(void *data)
 		HDMITX_HWCMD_MUX_HPD_IF_PIN_HIGH, 0);
 
 	hdmitx_device->HWOp.SetupIRQ(hdmitx_device);
+	hdmi_init = 1;
 	return 0;
 }
 
@@ -2588,6 +2902,41 @@ static struct i2c_driver i2c_gpio_edid_driver = {
 	},
 };
 
+static int get_dt_vend_init_data(struct device_node *np,
+	struct vendor_info_data *vend)
+{
+	int ret;
+
+	ret = of_property_read_string(np, "vendor_name",
+		(const char **)&(vend->vendor_name));
+	if (ret)
+		hdmi_print(INF, SYS "not find vendor name\n");
+
+	ret = of_property_read_u32(np, "vendor_id", &(vend->vendor_id));
+	if (ret)
+		hdmi_print(INF, SYS "not find vendor id\n");
+
+	ret = of_property_read_string(np, "product_desc",
+		(const char **)&(vend->product_desc));
+	if (ret)
+		hdmi_print(INF, SYS "not find product desc\n");
+#if 0
+	ret = of_property_read_string(np, "cec_osd_string",
+		(const char **)&(vend->cec_osd_string));
+	if (ret)
+		hdmi_print(INF, SYS "not find cec osd string\n");
+
+	ret = of_property_read_u32(np, "cec_config", &(vend->cec_config));
+	if (ret)
+		hdmi_print(INF, SYS "not find cec config\n");
+
+	ret = of_property_read_u32(np, "ao_cec", &(vend->ao_cec));
+	if (ret)
+		hdmi_print(INF, SYS "not find ao cec\n");
+#endif
+	return 0;
+}
+
 static int amhdmitx_probe(struct platform_device *pdev)
 {
 	int r, ret = 0;
@@ -2600,6 +2949,8 @@ static int amhdmitx_probe(struct platform_device *pdev)
 	struct device_node *init_data;
 #endif
 	hdmitx_device.hdtx_dev = &pdev->dev;
+	/* init para for NULL protection */
+	hdmitx_device.para = hdmi_get_fmt_name("invalid", fmt_attr);
 	hdmi_print(IMP, SYS "amhdmitx_probe\n");
 
 	r = alloc_chrdev_region(&hdmitx_id, 0, HDMI_TX_COUNT,
@@ -2649,6 +3000,7 @@ static int amhdmitx_probe(struct platform_device *pdev)
 	}
 	hdmitx_device.hdtx_dev = dev;
 	ret = device_create_file(dev, &dev_attr_disp_mode);
+	ret = device_create_file(dev, &dev_attr_attr);
 	ret = device_create_file(dev, &dev_attr_aud_mode);
 	ret = device_create_file(dev, &dev_attr_edid);
 	ret = device_create_file(dev, &dev_attr_rawedid);
@@ -2658,11 +3010,13 @@ static int amhdmitx_probe(struct platform_device *pdev)
 	ret = device_create_file(dev, &dev_attr_disp_cap_3d);
 	ret = device_create_file(dev, &dev_attr_aud_cap);
 	ret = device_create_file(dev, &dev_attr_hdr_cap);
+	ret = device_create_file(dev, &dev_attr_dv_cap);
 	ret = device_create_file(dev, &dev_attr_aud_ch);
 	ret = device_create_file(dev, &dev_attr_aud_output_chs);
 	ret = device_create_file(dev, &dev_attr_avmute);
 	ret = device_create_file(dev, &dev_attr_vic);
 	ret = device_create_file(dev, &dev_attr_phy);
+	ret = device_create_file(dev, &dev_attr_frac_rate_policy);
 	ret = device_create_file(dev, &dev_attr_hdcp_clkdis);
 	ret = device_create_file(dev, &dev_attr_hdcp_pwr);
 	ret = device_create_file(dev, &dev_attr_hdcp_ksv_info);
@@ -2673,13 +3027,11 @@ static int amhdmitx_probe(struct platform_device *pdev)
 	ret = device_create_file(dev, &dev_attr_div40);
 	ret = device_create_file(dev, &dev_attr_hdcp_ctrl);
 	ret = device_create_file(dev, &dev_attr_hpd_state);
+	ret = device_create_file(dev, &dev_attr_hdmi_init);
 	ret = device_create_file(dev, &dev_attr_ready);
 	ret = device_create_file(dev, &dev_attr_support_3d);
 	ret = device_create_file(dev, &dev_attr_dc_cap);
-	ret = device_create_file(dev, &dev_attr_output_rgb);
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	register_hdmi_edid_supported_func(hdmitx_is_vmode_supported);
-#endif
+	ret = device_create_file(dev, &dev_attr_valid_mode);
 
 #ifdef CONFIG_AM_TV_OUTPUT
 	vout_register_client(&hdmitx_notifier_nb_v);
@@ -2738,7 +3090,11 @@ static int amhdmitx_probe(struct platform_device *pdev)
 			sizeof(struct vendor_info_data), GFP_KERNEL);
 		if (!hdmitx_device.config_data.vend_data)
 			hdmi_print(INF, SYS
-				"can not get vend_data mem\n");
+				"can not get vend_data dat\n");
+		ret = get_dt_vend_init_data(init_data,
+			hdmitx_device.config_data.vend_data);
+		if (ret)
+			hdmi_print(INF, SYS "not find vend_init_data\n");
 	}
 /* Get power control */
 		ret = of_property_read_u32(pdev->dev.of_node,
@@ -2810,7 +3166,9 @@ static int amhdmitx_probe(struct platform_device *pdev)
 		clk_prepare_enable(hdmitx_device.clk_pixel);
 
 	switch_dev_register(&sdev);
+	switch_dev_register(&hdmi_audio);
 	switch_dev_register(&hdmi_power);
+	switch_dev_register(&hdmi_hdr);
 
 	hdmitx_init_parameters(&hdmitx_device.hdmi_info);
 	HDMITX_Meson_Init(&hdmitx_device);
@@ -2835,7 +3193,10 @@ static int amhdmitx_remove(struct platform_device *pdev)
 {
 	struct device *dev = hdmitx_device.hdtx_dev;
 	switch_dev_unregister(&sdev);
+	switch_dev_unregister(&hdmi_audio);
 	switch_dev_unregister(&hdmi_power);
+	switch_dev_unregister(&hdmi_hdr);
+	cancel_work_sync(&hdmitx_device.work_hdr);
 
 	if (hdmitx_device.HWOp.UnInit)
 		hdmitx_device.HWOp.UnInit(&hdmitx_device);
@@ -2853,6 +3214,7 @@ static int amhdmitx_remove(struct platform_device *pdev)
 
 	/* Remove the cdev */
 	device_remove_file(dev, &dev_attr_disp_mode);
+	device_remove_file(dev, &dev_attr_attr);
 	device_remove_file(dev, &dev_attr_aud_mode);
 	device_remove_file(dev, &dev_attr_edid);
 	device_remove_file(dev, &dev_attr_rawedid);
@@ -2861,15 +3223,18 @@ static int amhdmitx_remove(struct platform_device *pdev)
 	device_remove_file(dev, &dev_attr_disp_cap);
 	device_remove_file(dev, &dev_attr_disp_cap_3d);
 	device_remove_file(dev, &dev_attr_hdr_cap);
+	device_remove_file(dev, &dev_attr_dv_cap);
 	device_remove_file(dev, &dev_attr_dc_cap);
+	device_remove_file(dev, &dev_attr_valid_mode);
 	device_remove_file(dev, &dev_attr_hpd_state);
+	device_remove_file(dev, &dev_attr_hdmi_init);
 	device_remove_file(dev, &dev_attr_ready);
 	device_remove_file(dev, &dev_attr_support_3d);
 	device_remove_file(dev, &dev_attr_avmute);
 	device_remove_file(dev, &dev_attr_vic);
+	device_remove_file(dev, &dev_attr_frac_rate_policy);
 	device_remove_file(dev, &dev_attr_hdcp_pwr);
 	device_remove_file(dev, &dev_attr_aud_output_chs);
-	device_remove_file(dev, &dev_attr_output_rgb);
 	device_remove_file(dev, &dev_attr_div40);
 
 	cdev_del(&hdmitx_device.cdev);
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c
index 2bf3f6b..20e8940 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c
@@ -34,8 +34,8 @@
 #include <linux/amlogic/hdmi_tx/hdmi_tx_compliance.h>
 
 static unsigned char hdmi_output_rgb;
-static void hdmitx_set_spd_info(struct hdmitx_dev *hdmitx_device);
-static void hdmi_set_vend_spec_infofram(struct hdmitx_dev *hdmitx_device,
+static void hdmitx_set_spd_info(struct hdmitx_dev *hdev);
+static void hdmi_set_vend_spec_infofram(struct hdmitx_dev *hdev,
 	enum hdmi_vic VideoCode);
 
 static struct hdmitx_vidpara hdmi_tx_video_params[] = {
@@ -593,8 +593,7 @@ void hdmitx_output_rgb(void)
 	hdmi_output_rgb = 1;
 }
 
-int hdmitx_set_display(struct hdmitx_dev *hdmitx_device,
-	enum hdmi_vic VideoCode)
+int hdmitx_set_display(struct hdmitx_dev *hdev, enum hdmi_vic VideoCode)
 {
 	struct hdmitx_vidpara *param = NULL;
 	enum hdmi_vic vic;
@@ -607,28 +606,25 @@ int hdmitx_set_display(struct hdmitx_dev *hdmitx_device,
 	for (i = 0; i < 32; i++)
 		AVI_DB[i] = 0;
 
-	vic = hdmitx_device->HWOp.GetState(hdmitx_device,
-		STAT_VIDEO_VIC, 0);
+	vic = hdev->HWOp.GetState(hdev, STAT_VIDEO_VIC, 0);
 	hdmi_print(IMP, SYS "already init VIC = %d  Now VIC = %d\n",
 		vic, VideoCode);
 	if ((vic != HDMI_Unkown) && (vic == VideoCode)) {
-		hdmitx_device->cur_VIC = vic;
+		hdev->cur_VIC = vic;
 		/* return 1; */
 	}
 
 	param = hdmi_get_video_param(VideoCode);
-	hdmitx_device->cur_video_param = param;
+	hdev->cur_video_param = param;
 	if (param) {
 		param->color = param->color_prefer;
 		if (hdmi_output_rgb) {
 			param->color = COLORSPACE_RGB444;
-			hdmitx_device->para->cs =
-				hdmitx_device->cur_video_param->color;
 		} else {
 			/* HDMI CT 7-24 Pixel Encoding
 			 * YCbCr to YCbCr Sink
 			 */
-			switch (hdmitx_device->RXCap.native_Mode & 0x30) {
+			switch (hdev->RXCap.native_Mode & 0x30) {
 			case 0x20:/*bit5==1, then support YCBCR444 + RGB*/
 			case 0x30:
 				param->color = COLORSPACE_YUV444;
@@ -651,25 +647,24 @@ int hdmitx_set_display(struct hdmitx_dev *hdmitx_device,
 				break;
 			}
 			if (param->color == COLORSPACE_RGB444) {
-				hdmitx_device->para->cs =
-					hdmitx_device->cur_video_param->color;
+				hdev->para->cs = hdev->cur_video_param->color;
 				pr_info("hdmitx: rx edid only support RGB format\n");
 			}
 
 		}
-		if (hdmitx_device->HWOp.SetDispMode(hdmitx_device) >= 0) {
+		if (hdev->HWOp.SetDispMode(hdev) >= 0) {
 			/* HDMI CT 7-33 DVI Sink, no HDMI VSDB nor any
 			 * other VSDB, No GB or DI expected
 			 * TMDS_MODE[hdmi_config]
 			 * 0: DVI Mode	   1: HDMI Mode
 			 */
-			if (is_dvi_device(&hdmitx_device->RXCap)) {
+			if (is_dvi_device(&hdev->RXCap)) {
 				hdmi_print(1, "Sink is DVI device\n");
-				hdmitx_device->HWOp.CntlConfig(hdmitx_device,
+				hdev->HWOp.CntlConfig(hdev,
 					CONF_HDMI_DVI_MODE, DVI_MODE);
 			} else {
 				hdmi_print(1, "Sink is HDMI device\n");
-				hdmitx_device->HWOp.CntlConfig(hdmitx_device,
+				hdev->HWOp.CntlConfig(hdev,
 					CONF_HDMI_DVI_MODE, HDMI_MODE);
 			}
 			hdmi_tx_construct_avi_packet(param, (char *)AVI_DB);
@@ -678,21 +673,23 @@ int hdmitx_set_display(struct hdmitx_dev *hdmitx_device,
 				(VideoCode == HDMI_4k2k_25) ||
 				(VideoCode == HDMI_4k2k_24) ||
 				(VideoCode == HDMI_4k2k_smpte_24))
-				hdmi_set_vend_spec_infofram(hdmitx_device,
-					VideoCode);
-			else
-				hdmi_set_vend_spec_infofram(hdmitx_device, 0);
+				hdmi_set_vend_spec_infofram(hdev, VideoCode);
+			else if ((!hdev->flag_3dfp) && (!hdev->flag_3dtb) &&
+				(!hdev->flag_3dss))
+				hdmi_set_vend_spec_infofram(hdev, 0);
+			else /* nothing */
+				;
 			ret = 0;
 		}
 	}
-	hdmitx_set_spd_info(hdmitx_device);
+	hdmitx_set_spd_info(hdev);
 #if 0
-	hdmitx_special_handler_video(hdmitx_device);
+	hdmitx_special_handler_video(hdev);
 #endif
 	return ret;
 }
 
-static void hdmi_set_vend_spec_infofram(struct hdmitx_dev *hdmitx_device,
+static void hdmi_set_vend_spec_infofram(struct hdmitx_dev *hdev,
 	enum hdmi_vic VideoCode)
 {
 	int i;
@@ -700,7 +697,7 @@ static void hdmi_set_vend_spec_infofram(struct hdmitx_dev *hdmitx_device,
 	unsigned char VEN_HB[3];
 	VEN_HB[0] = 0x81;
 	VEN_HB[1] = 0x01;
-	VEN_HB[2] = 0x6;
+	VEN_HB[2] = 0x5;
 
 	for (i = 0; i < 0x6; i++)
 		VEN_DB[i] = 0;
@@ -709,7 +706,7 @@ static void hdmi_set_vend_spec_infofram(struct hdmitx_dev *hdmitx_device,
 	VEN_DB[2] = 0x00;
 	VEN_DB[3] = 0x20;    /* 4k x 2k  Spec P156 */
 	if (VideoCode == 0) {	   /* For non-4kx2k mode setting */
-		hdmitx_device->HWOp.SetPacket(HDMI_PACKET_VEND, NULL, VEN_HB);
+		hdev->HWOp.SetPacket(HDMI_PACKET_VEND, NULL, VEN_HB);
 		return;
 	}
 	if (VideoCode == HDMI_4k2k_30)
@@ -722,10 +719,10 @@ static void hdmi_set_vend_spec_infofram(struct hdmitx_dev *hdmitx_device,
 		VEN_DB[4] = 0x4;
 	else
 		;
-	hdmitx_device->HWOp.SetPacket(HDMI_PACKET_VEND, VEN_DB, VEN_HB);
+	hdev->HWOp.SetPacket(HDMI_PACKET_VEND, VEN_DB, VEN_HB);
 }
 
-int hdmi_set_3d(struct hdmitx_dev *hdmitx_device, int type, unsigned int param)
+int hdmi_set_3d(struct hdmitx_dev *hdev, int type, unsigned int param)
 {
 	int i;
 	unsigned char VEN_DB[6];
@@ -733,8 +730,8 @@ int hdmi_set_3d(struct hdmitx_dev *hdmitx_device, int type, unsigned int param)
 	VEN_HB[0] = 0x81;
 	VEN_HB[1] = 0x01;
 	VEN_HB[2] = 0x6;
-	if (type == 0xf)
-		hdmitx_device->HWOp.SetPacket(HDMI_PACKET_VEND, NULL, VEN_HB);
+	if (type == T3D_DISABLE)
+		hdev->HWOp.SetPacket(HDMI_PACKET_VEND, NULL, VEN_HB);
 	else {
 		for (i = 0; i < 0x6; i++)
 			VEN_DB[i] = 0;
@@ -744,7 +741,7 @@ int hdmi_set_3d(struct hdmitx_dev *hdmitx_device, int type, unsigned int param)
 		VEN_DB[3] = 0x40;
 		VEN_DB[4] = type<<4;
 		VEN_DB[5] = param<<4;
-		hdmitx_device->HWOp.SetPacket(HDMI_PACKET_VEND, VEN_DB, VEN_HB);
+		hdev->HWOp.SetPacket(HDMI_PACKET_VEND, VEN_DB, VEN_HB);
 	}
 	return 0;
 
@@ -752,14 +749,14 @@ int hdmi_set_3d(struct hdmitx_dev *hdmitx_device, int type, unsigned int param)
 
 /* Set Source Product Descriptor InfoFrame
  */
-static void hdmitx_set_spd_info(struct hdmitx_dev *hdmitx_device)
+static void hdmitx_set_spd_info(struct hdmitx_dev *hdev)
 {
 	unsigned char SPD_DB[25] = {0x00};
 	unsigned char SPD_HB[3] = {0x83, 0x1, 0x19};
 	unsigned int len = 0;
 	struct vendor_info_data *vend_data;
-	if (hdmitx_device->config_data.vend_data)
-		vend_data = hdmitx_device->config_data.vend_data;
+	if (hdev->config_data.vend_data)
+		vend_data = hdev->config_data.vend_data;
 	else {
 		hdmi_print(INF, SYS "packet: can\'t get vendor data\n");
 		return;
@@ -774,5 +771,6 @@ static void hdmitx_set_spd_info(struct hdmitx_dev *hdmitx_device)
 		strncpy(&SPD_DB[8], vend_data->product_desc,
 			(len > 16) ? 16 : len);
 	}
-	hdmitx_device->HWOp.SetPacket(HDMI_SOURCE_DESCRIPTION, SPD_DB, SPD_HB);
+	SPD_DB[24] = 0x1;
+	hdev->HWOp.SetPacket(HDMI_SOURCE_DESCRIPTION, SPD_DB, SPD_HB);
 }
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/common.h b/drivers/amlogic/hdmi/hdmi_tx_20/hw/common.h
index 36e1c5b..234b088 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/common.h
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/common.h
@@ -3,6 +3,7 @@
 #define __HDMITX_HW_COMMON_H__
 
 #include <linux/amlogic/hdmi_tx/hdmi_tx_ddc.h>
+#include <linux/amlogic/hdmi_tx/hdmi_common.h>
 #include "mach_reg.h"
 #include "hdmi_tx_reg.h"
 /*
@@ -28,5 +29,10 @@ int hdmitx_ddc_hw_op_gxtvbb(enum ddc_op cmd);
 int hdmitx_hpd_hw_op_gxl(enum hpd_op cmd);
 int read_hpd_gpio_gxl(void);
 int hdmitx_ddc_hw_op_gxl(enum ddc_op cmd);
+void set_gxl_hpll_clk_out(unsigned frac_rate, unsigned clk);
+void set_hpll_sspll_gxl(enum hdmi_vic vic);
+void set_hpll_od1_gxl(unsigned div);
+void set_hpll_od2_gxl(unsigned div);
+void set_hpll_od3_gxl(unsigned div);
 
 #endif
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/enc_cfg_hw.c b/drivers/amlogic/hdmi/hdmi_tx_20/hw/enc_cfg_hw.c
index e29feeb..c2b29c7 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/enc_cfg_hw.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/enc_cfg_hw.c
@@ -712,7 +712,7 @@ struct vic_tvregs_set {
 	const struct reg_s *reg_setting;
 };
 
-/* Using tvmode as index */
+/* Using HDMI VIC as index */
 static struct vic_tvregs_set tvregsTab[] = {
 	{HDMI_720x480i60_16x9, tvregs_480i},
 	{HDMI_2880x480i60_16x9, tvregs_480i},
@@ -776,3 +776,239 @@ void set_vmode_enc_hw(enum hdmi_vic vic)
 	} else
 		pr_info("hdmitx: not find VIC: %d\n", vic);
 }
+
+/*
+ * For 3D FramePacket Setting
+ */
+static const struct reg_s tvregs_3dfp_1080p60[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x897,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x8C9,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0xC0,},
+	{P_ENCP_VIDEO_HAVON_END, 0x83F,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x29,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x8C5,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x2C,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x5,},
+	{P_ENCP_DVI_HSO_BEGIN, 0x2,},
+	{P_ENCP_DVI_HSO_END, 0x2E,},
+	{P_ENCP_DVI_VSO_BLINE_EVN, 0x0,},
+	{P_ENCP_DVI_VSO_BLINE_ODD, 0x0,},
+	{P_ENCP_DVI_VSO_ELINE_EVN, 0x5,},
+	{P_ENCP_DVI_VSO_ELINE_ODD, 0x0,},
+	{P_ENCP_DVI_VSO_BEGIN_EVN, 0x2,},
+	{P_ENCP_DVI_VSO_BEGIN_ODD, 0x0,},
+	{P_ENCP_DVI_VSO_END_EVN, 0x2,},
+	{P_ENCP_DVI_VSO_END_ODD, 0x0,},
+	{P_ENCP_DE_H_BEGIN, 0xC2,},
+	{P_ENCP_DE_H_END, 0x842,},
+	{P_ENCP_DE_V_BEGIN_EVEN, 0x29,},
+	{P_ENCP_DE_V_END_EVEN, 0x8C6,},
+	{P_ENCP_DE_V_BEGIN_ODD, 0x0,},
+	{P_ENCP_DE_V_END_ODD, 0x0,},
+
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_s tvregs_3dfp_1080p24[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0xABD,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x8C9,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0xC0,},
+	{P_ENCP_VIDEO_HAVON_END, 0x83F,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x29,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x8C5,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x2C,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x5,},
+	{P_ENCP_DVI_HSO_BEGIN, 0x2,},
+	{P_ENCP_DVI_HSO_END, 0x2E,},
+	{P_ENCP_DVI_VSO_BLINE_EVN, 0x0,},
+	{P_ENCP_DVI_VSO_BLINE_ODD, 0x0,},
+	{P_ENCP_DVI_VSO_ELINE_EVN, 0x5,},
+	{P_ENCP_DVI_VSO_ELINE_ODD, 0x0,},
+	{P_ENCP_DVI_VSO_BEGIN_EVN, 0x2,},
+	{P_ENCP_DVI_VSO_BEGIN_ODD, 0x0,},
+	{P_ENCP_DVI_VSO_END_EVN, 0x2,},
+	{P_ENCP_DVI_VSO_END_ODD, 0x0,},
+	{P_ENCP_DE_H_BEGIN, 0xC2,},
+	{P_ENCP_DE_H_END, 0x842,},
+	{P_ENCP_DE_V_BEGIN_EVEN, 0x29,},
+	{P_ENCP_DE_V_END_EVEN, 0x8C6,},
+	{P_ENCP_DE_V_BEGIN_ODD, 0x0,},
+	{P_ENCP_DE_V_END_ODD, 0x0,},
+
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_s tvregs_3dfp_1080p50[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0xA4F,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x8C9,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0xC0,},
+	{P_ENCP_VIDEO_HAVON_END, 0x83F,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x29,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x8C5,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x2C,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x5,},
+	{P_ENCP_DVI_HSO_BEGIN, 0x2,},
+	{P_ENCP_DVI_HSO_END, 0x2E,},
+	{P_ENCP_DVI_VSO_BLINE_EVN, 0x0,},
+	{P_ENCP_DVI_VSO_BLINE_ODD, 0x0,},
+	{P_ENCP_DVI_VSO_ELINE_EVN, 0x5,},
+	{P_ENCP_DVI_VSO_ELINE_ODD, 0x0,},
+	{P_ENCP_DVI_VSO_BEGIN_EVN, 0x2,},
+	{P_ENCP_DVI_VSO_BEGIN_ODD, 0x0,},
+	{P_ENCP_DVI_VSO_END_EVN, 0x2,},
+	{P_ENCP_DVI_VSO_END_ODD, 0x0,},
+	{P_ENCP_DE_H_BEGIN, 0xC2,},
+	{P_ENCP_DE_H_END, 0x842,},
+	{P_ENCP_DE_V_BEGIN_EVEN, 0x29,},
+	{P_ENCP_DE_V_END_EVEN, 0x8C6,},
+	{P_ENCP_DE_V_BEGIN_ODD, 0x0,},
+	{P_ENCP_DE_V_END_ODD, 0x0,},
+
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_s tvregs_3dfp_720p50[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x7BB,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x5DB,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0x104,},
+	{P_ENCP_VIDEO_HAVON_END, 0x603,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x19,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x5D6,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x28,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x5,},
+	{P_ENCP_DVI_HSO_BEGIN, 0x2,},
+	{P_ENCP_DVI_HSO_END, 0x2A,},
+	{P_ENCP_DVI_VSO_BLINE_EVN, 0x0,},
+	{P_ENCP_DVI_VSO_BLINE_ODD, 0x0,},
+	{P_ENCP_DVI_VSO_ELINE_EVN, 0x5,},
+	{P_ENCP_DVI_VSO_ELINE_ODD, 0x0,},
+	{P_ENCP_DVI_VSO_BEGIN_EVN, 0x2,},
+	{P_ENCP_DVI_VSO_BEGIN_ODD, 0x0,},
+	{P_ENCP_DVI_VSO_END_EVN, 0x2,},
+	{P_ENCP_DVI_VSO_END_ODD, 0x0,},
+	{P_ENCP_DE_H_BEGIN, 0x106,},
+	{P_ENCP_DE_H_END, 0x606,},
+	{P_ENCP_DE_V_BEGIN_EVEN, 0x19,},
+	{P_ENCP_DE_V_END_EVEN, 0x5D7,},
+	{P_ENCP_DE_V_BEGIN_ODD, 0x0,},
+	{P_ENCP_DE_V_END_ODD, 0x0,},
+
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_s tvregs_3dfp_720p60[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x671,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x5DB,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0x104,},
+	{P_ENCP_VIDEO_HAVON_END, 0x603,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x19,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x5D6,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x28,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x5,},
+	{P_ENCP_DVI_HSO_BEGIN, 0x2,},
+	{P_ENCP_DVI_HSO_END, 0x2A,},
+	{P_ENCP_DVI_VSO_BLINE_EVN, 0x0,},
+	{P_ENCP_DVI_VSO_BLINE_ODD, 0x0,},
+	{P_ENCP_DVI_VSO_ELINE_EVN, 0x5,},
+	{P_ENCP_DVI_VSO_ELINE_ODD, 0x0,},
+	{P_ENCP_DVI_VSO_BEGIN_EVN, 0x2,},
+	{P_ENCP_DVI_VSO_BEGIN_ODD, 0x0,},
+	{P_ENCP_DVI_VSO_END_EVN, 0x2,},
+	{P_ENCP_DVI_VSO_END_ODD, 0x0,},
+	{P_ENCP_DE_H_BEGIN, 0x106,},
+	{P_ENCP_DE_H_END, 0x606,},
+	{P_ENCP_DE_V_BEGIN_EVEN, 0x19,},
+	{P_ENCP_DE_V_END_EVEN, 0x5D7,},
+	{P_ENCP_DE_V_BEGIN_ODD, 0x0,},
+	{P_ENCP_DE_V_END_ODD, 0x0,},
+
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0},
+};
+
+/* Using HDMI VIC as index */
+static struct vic_tvregs_set tvregsTab_3dfp[] = {
+	{HDMI_1920x1080p60_16x9, tvregs_3dfp_1080p60},
+	{HDMI_1920x1080p30_16x9, tvregs_3dfp_1080p60},
+	{HDMI_1920x1080p50_16x9, tvregs_3dfp_1080p50},
+	{HDMI_1920x1080p25_16x9, tvregs_3dfp_1080p50},
+	{HDMI_1920x1080p24_16x9, tvregs_3dfp_1080p24},
+	{HDMI_1280x720p60_16x9, tvregs_3dfp_720p60},
+	{HDMI_1280x720p50_16x9, tvregs_3dfp_720p50},
+};
+
+static const struct reg_s *tvregs_3dfp_setting_mode(enum hdmi_vic vic)
+{
+	int i = 0;
+	for (i = 0; i < ARRAY_SIZE(tvregsTab_3dfp); i++) {
+		if (vic == tvregsTab_3dfp[i].vic)
+			return tvregsTab_3dfp[i].reg_setting;
+	}
+	return NULL;
+}
+
+void set_vmode_3dfp_enc_hw(enum hdmi_vic vic)
+{
+	const struct reg_s *s = tvregs_3dfp_setting_mode(vic);
+
+	if (s) {
+		pr_info("hdmitx: set 3dfp enc for VIC: %d\n", vic);
+		while (MREG_END_MARKER != s->reg)
+			setreg(s++);
+	} else
+		pr_info("hdmitx: not find VIC: %d\n", vic);
+}
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c
index eb2a260..69cb041 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c
@@ -450,21 +450,7 @@ static int hdmitx_uboot_already_display(void)
 /* for 30bits colordepth */
 static void set_vmode_clk(struct hdmitx_dev *hdev)
 {
-	enum hdmi_vic vic = hdev->cur_VIC;
-
-	pr_info("hdmitx: set clk: VIC = %d  cd = %d\n", vic, hdev->para->cd);
-	if (hdev->para->cs != COLORSPACE_YUV422) {
-		switch (hdev->para->cd) {
-		case COLORDEPTH_30B:
-			hdmitx_set_clk_30b(vic);
-			break;
-		case COLORDEPTH_24B:
-		default:
-			hdmitx_set_clk(vic);
-			break;
-		}
-	} else
-		hdmitx_set_clk(vic);
+	hdmitx_set_clk(hdev);
 }
 
 static void hdmi_hwp_init(struct hdmitx_dev *hdev)
@@ -839,7 +825,6 @@ static void hdmi_tvenc1080i_set(struct hdmitx_vidpara *param)
 		(0 << 12)
 	);
 	hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
-
 }
 
 static void hdmi_tvenc4k2k_set(struct hdmitx_vidpara *param)
@@ -1702,17 +1687,8 @@ static void hdmitx_set_pll(struct hdmitx_dev *hdev)
 	hdmi_print(IMP, SYS "param->VIC:%d\n", hdev->cur_video_param->VIC);
 
 	cur_vout_index = get_cur_vout_index();
-/* TODO
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	if (hdmitx_set_pll_fr_auto(hdev))
-		return;
-#endif
-*/
 	set_vmode_clk(hdev);
 
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	hdev->HWOp.CntlMisc(hdev, MISC_FINE_TUNE_HPLL, get_hpll_tune_mode());
-#endif
 }
 
 static void set_phy_by_mode(unsigned int mode)
@@ -1761,6 +1737,28 @@ static void hdmitx_set_phy(struct hdmitx_dev *hdev)
 {
 	if (!hdev)
 		return;
+	hd_write_reg(P_HHI_HDMI_PHY_CNTL0, 0x0);
+#if 1
+/* P_HHI_HDMI_PHY_CNTL1	bit[1]: enable clock	bit[0]: soft reset */
+#define RESET_HDMI_PHY() \
+do { \
+	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0xf, 0, 4); \
+	mdelay(2); \
+	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0xe, 0, 4); \
+	mdelay(2); \
+} while (0)
+
+	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0x0390, 16, 16);
+	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0x1, 17, 1);
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)
+		hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0x0, 17, 1);
+	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0x0, 0, 4);
+	msleep(100);
+	RESET_HDMI_PHY();
+	RESET_HDMI_PHY();
+	RESET_HDMI_PHY();
+#undef RESET_HDMI_PHY
+#endif
 	switch (hdev->cur_VIC) {
 	case HDMI_4k2k_24:
 	case HDMI_4k2k_25:
@@ -1794,34 +1792,19 @@ static void hdmitx_set_phy(struct hdmitx_dev *hdev)
 		break;
 	case HDMI_1080p60:
 	case HDMI_1080p50:
-		set_phy_by_mode(3);
+		if (hdev->flag_3dfp)
+			set_phy_by_mode(2);
+		else
+			set_phy_by_mode(3);
 		break;
 	default:
-		set_phy_by_mode(4);
+		if (hdev->flag_3dfp)
+			set_phy_by_mode(3);
+		else
+			set_phy_by_mode(4);
 		break;
 	}
-#if 1
-/* P_HHI_HDMI_PHY_CNTL1	bit[1]: enable clock	bit[0]: soft reset */
-#define RESET_HDMI_PHY() \
-do { \
-	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0xf, 0, 4); \
-	mdelay(2); \
-	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0xe, 0, 4); \
-	mdelay(2); \
-} while (0)
-
-	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0x0390, 16, 16);
-	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0x1, 17, 1);
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL)
-		hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0x0, 17, 1);
-	hd_set_reg_bits(P_HHI_HDMI_PHY_CNTL1, 0x0, 0, 4);
-	msleep(100);
-	RESET_HDMI_PHY();
-	RESET_HDMI_PHY();
-	RESET_HDMI_PHY();
-#undef RESET_HDMI_PHY
-#endif
-	hdmi_print(IMP, SYS "phy setting done\n");
+	hdmi_print(IMP, SYS "PHY Setting Done\n");
 }
 
 static void set_tmds_clk_div40(unsigned int div40)
@@ -1916,7 +1899,15 @@ static int hdmitx_set_dispmode(struct hdmitx_dev *hdev)
 		hdev->cur_video_param->color = COLORSPACE_f;
 	hdmitx_set_pll(hdev);
 	/*hdmitx_set_phy(hdev);*/
-	set_vmode_enc_hw(hdev->cur_video_param->VIC);
+	if (hdev->flag_3dfp)
+		set_vmode_3dfp_enc_hw(hdev->cur_video_param->VIC);
+	else
+		set_vmode_enc_hw(hdev->cur_video_param->VIC);
+	/* Ignore 3dfp hdmi_tvenc_set, move to set_vmode_3dfp_enc_hw */
+	if (hdev->flag_3dfp) {
+		hd_write_reg(P_VPU_HDMI_SETTING, 0x8e);
+		goto next;
+	}
 	switch (hdev->cur_video_param->VIC) {
 	case HDMI_480i60:
 	case HDMI_480i60_16x9:
@@ -1949,6 +1940,7 @@ static int hdmitx_set_dispmode(struct hdmitx_dev *hdev)
 	default:
 		hdmi_tvenc_set(hdev->cur_video_param);
 	}
+next:
 /* [ 3: 2] chroma_dnsmp. 0=use pixel 0; 1=use pixel 1; 2=use average. */
 /* [	5] hdmi_dith_md: random noise selector. */
 	hd_write_reg(P_VPU_HDMI_FMT_CTRL, (((TX_INPUT_COLOR_FORMAT ==
@@ -1965,10 +1957,38 @@ static int hdmitx_set_dispmode(struct hdmitx_dev *hdev)
 	case COLORDEPTH_30B:
 	case COLORDEPTH_36B:
 	case COLORDEPTH_48B:
-		hd_set_reg_bits(P_VPU_HDMI_FMT_CTRL, 0, 4, 1);
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXM) {
+			unsigned int hs_flag = 0;
+			/* 12-10 dithering on */
+			hd_set_reg_bits(P_VPU_HDMI_FMT_CTRL, 1, 4, 1);
+			/* hsync/vsync not invert */
+			hs_flag = (hd_read_reg(P_VPU_HDMI_SETTING) >> 2) & 0x3;
+			hd_set_reg_bits(P_VPU_HDMI_SETTING, 0, 2, 2);
+			/* 12-10 rounding off */
+			hd_set_reg_bits(P_VPU_HDMI_FMT_CTRL, 0, 10, 1);
+			/* 10-8 dithering off (2x2 old dither) */
+			hd_set_reg_bits(P_VPU_HDMI_DITH_CNTL, 0, 4, 1);
+			/* set hsync/vsync */
+			hd_set_reg_bits(P_VPU_HDMI_DITH_CNTL, hs_flag, 2, 2);
+		} else {
+			hd_set_reg_bits(P_VPU_HDMI_FMT_CTRL, 0, 4, 1);
+			hd_set_reg_bits(P_VPU_HDMI_FMT_CTRL, 0, 10, 1);
+		}
 		break;
 	default:
-		hd_set_reg_bits(P_VPU_HDMI_FMT_CTRL, 1, 4, 1);
+		if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXM) {
+			/* 12-10 dithering off */
+			hd_set_reg_bits(P_VPU_HDMI_FMT_CTRL, 0, 4, 1);
+			/* 12-10 rounding on */
+			hd_set_reg_bits(P_VPU_HDMI_FMT_CTRL, 1, 10, 1);
+			/* 10-8 dithering on (2x2 old dither) */
+			hd_set_reg_bits(P_VPU_HDMI_DITH_CNTL, 1, 4, 1);
+			/* set hsync/vsync as default 0 */
+			hd_set_reg_bits(P_VPU_HDMI_DITH_CNTL, 0, 2, 2);
+		} else {
+			hd_set_reg_bits(P_VPU_HDMI_FMT_CTRL, 0, 4, 1);
+			hd_set_reg_bits(P_VPU_HDMI_FMT_CTRL, 1, 10, 1);
+		}
 		break;
 	}
 
@@ -1977,7 +1997,9 @@ static int hdmitx_set_dispmode(struct hdmitx_dev *hdev)
 	/* move hdmitx_set_pll() to the end of this function. */
 	/* hdmitx_set_pll(param); */
 	hdev->cur_VIC = hdev->cur_video_param->VIC;
-	hdmitx_set_phy(hdev);
+	/* For 3D, enable phy by SystemControl at last step */
+	if ((!hdev->flag_3dfp) && (!hdev->flag_3dtb) && (!hdev->flag_3dss))
+		hdmitx_set_phy(hdev);
 	switch (hdev->cur_video_param->VIC) {
 	case HDMI_480i60:
 	case HDMI_480i60_16x9:
@@ -2036,24 +2058,26 @@ static void hdmitx_set_packet(int type, unsigned char *DB, unsigned char *HB)
 	case HDMI_PACKET_AVI:
 		break;
 	case HDMI_PACKET_VEND:
-		if (!DB) {
+		if ((!DB) || (!HB)) {
 			hdmitx_set_reg_bits(HDMITX_DWC_FC_DATAUTO0, 0, 3, 1);
 			return;
 		}
 		hdmitx_wr_reg(HDMITX_DWC_FC_VSDIEEEID0, DB[0]);
 		hdmitx_wr_reg(HDMITX_DWC_FC_VSDIEEEID1, DB[1]);
 		hdmitx_wr_reg(HDMITX_DWC_FC_VSDIEEEID2, DB[2]);
+		hdmitx_wr_reg(HDMITX_DWC_FC_VSDPAYLOAD0, DB[3]);
+		hdmitx_wr_reg(HDMITX_DWC_FC_VSDSIZE, HB[2]);
 		if (DB[3] == 0x20) { /* set HDMI VIC */
 			hdmitx_wr_reg(HDMITX_DWC_FC_AVIVID, 0);
-			hdmitx_wr_reg(HDMITX_DWC_FC_VSDPAYLOAD0, DB[3]);
 			hdmitx_wr_reg(HDMITX_DWC_FC_VSDPAYLOAD1, DB[4]);
-			hdmitx_wr_reg(HDMITX_DWC_FC_VSDSIZE, 5);
 		}
 		if (DB[3] == 0x40) { /* 3D VSI */
-			hdmitx_wr_reg(HDMITX_DWC_FC_VSDPAYLOAD0, DB[3]);
 			hdmitx_wr_reg(HDMITX_DWC_FC_VSDPAYLOAD1, DB[4]);
 			hdmitx_wr_reg(HDMITX_DWC_FC_VSDPAYLOAD2, DB[5]);
-			hdmitx_wr_reg(HDMITX_DWC_FC_VSDSIZE, 6);
+			if ((DB[4] >> 4) == T3D_FRAME_PACKING)
+				hdmitx_wr_reg(HDMITX_DWC_FC_VSDSIZE, 5);
+			else
+				hdmitx_wr_reg(HDMITX_DWC_FC_VSDSIZE, 6);
 		}
 		/* Enable VSI packet */
 		hdmitx_set_reg_bits(HDMITX_DWC_FC_DATAUTO0, 1, 3, 1);
@@ -2082,6 +2106,11 @@ static void hdmitx_set_packet(int type, unsigned char *DB, unsigned char *HB)
 		break;
 	case HDMI_SOURCE_DESCRIPTION:
 		pkt_data_len = 25;
+		for (i = 0; i < 25; i++)
+			hdmitx_wr_reg(HDMITX_DWC_FC_SPDVENDORNAME0 + i, DB[i]);
+		hdmitx_set_reg_bits(HDMITX_DWC_FC_DATAUTO0, 1, 4, 1);
+		hdmitx_set_reg_bits(HDMITX_DWC_FC_DATAUTO2, 0x1, 4, 4);
+		hdmitx_set_reg_bits(HDMITX_DWC_FC_PACKET_TX_EN, 1, 4, 1);
 	default:
 		break;
 	}
@@ -2350,7 +2379,7 @@ static void set_aud_acr_pkt(struct hdmitx_dev *hdev,
 {
 	unsigned int data32;
 	unsigned int aud_n_para;
-
+	unsigned int char_rate;
 
 	/* audio packetizer config */
 	hdmitx_wr_reg(HDMITX_DWC_AUD_INPUTCLKFS, tx_aud_src ? 4 : 0);
@@ -2359,12 +2388,24 @@ static void set_aud_acr_pkt(struct hdmitx_dev *hdev,
 	|| (audio_param->type == CT_DTS_HD_MA))
 		hdmitx_wr_reg(HDMITX_DWC_AUD_INPUTCLKFS, 2);
 
+	if ((hdev->frac_rate_policy) && (hdev->para->timing.frac_freq))
+		char_rate = hdev->para->timing.frac_freq;
+	else
+		char_rate = hdev->para->timing.pixel_freq;
 	if (hdev->para->cs == COLORSPACE_YUV422)
 		aud_n_para = hdmi_get_aud_n_paras(audio_param->sample_rate,
-			COLORDEPTH_24B, hdev->para->timing.pixel_freq);
+			COLORDEPTH_24B, char_rate);
 	else
 		aud_n_para = hdmi_get_aud_n_paras(audio_param->sample_rate,
-			hdev->para->cd, hdev->para->timing.pixel_freq);
+			hdev->para->cd, char_rate);
+	/* N must mutiples 4 for DD+ */
+	switch (audio_param->type) {
+	case CT_DOLBY_D:
+		aud_n_para *= 4;
+		break;
+	default:
+		break;
+	}
 	pr_info("hdmitx aud_n_para = %d\n", aud_n_para);
 
 	/* ACR packet configuration */
@@ -2904,6 +2945,39 @@ static void hdmitx_debug(struct hdmitx_dev *hdev, const char *buf)
 		dd();
 		hdev->HWOp.CntlDDC(hdev, DDC_RESET_EDID, 0);
 		hdev->HWOp.CntlDDC(hdev, DDC_EDID_READ_DATA, 0);
+		return;
+	} else if (strncmp(tmpbuf, "bist", 4) == 0) {
+		if (strncmp(tmpbuf + 4, "off", 3) == 0) {
+			hd_set_reg_bits(P_ENCP_VIDEO_MODE_ADV, 1, 3, 1);
+			hd_write_reg(P_VENC_VIDEO_TST_EN, 0);
+			return;
+		}
+		hd_set_reg_bits(P_HHI_GCLK_OTHER, 1, 3, 1);
+		hd_set_reg_bits(P_ENCP_VIDEO_MODE_ADV, 0, 3, 1);
+		hd_write_reg(P_VENC_VIDEO_TST_EN, 1);
+		if (strncmp(tmpbuf+4, "line", 4) == 0) {
+			hd_write_reg(P_VENC_VIDEO_TST_MDSEL, 2);
+			return;
+		}
+		if (strncmp(tmpbuf+4, "dot", 3) == 0) {
+			hd_write_reg(P_VENC_VIDEO_TST_MDSEL, 3);
+			return;
+		}
+		if (strncmp(tmpbuf+4, "start", 5) == 0) {
+			ret = kstrtoul(tmpbuf + 9, 10, &value);
+			hd_write_reg(P_VENC_VIDEO_TST_CLRBAR_STRT, value);
+			return;
+		}
+		if (strncmp(tmpbuf+4, "shift", 5) == 0) {
+			ret = kstrtoul(tmpbuf + 9, 10, &value);
+			hd_write_reg(P_VENC_VIDEO_TST_VDCNT_STSET, value);
+			return;
+		}
+		hd_write_reg(P_VENC_VIDEO_TST_MDSEL, 1);
+		value = 1920;
+		ret = kstrtoul(tmpbuf + 4, 10, &value);
+		hd_write_reg(P_VENC_VIDEO_TST_CLRBAR_WIDTH, value / 8);
+		return;
 	} else if (strncmp(tmpbuf, "dumptiming", 10) == 0) {
 		hdmitx_dump_inter_timing();
 		return;
@@ -3479,7 +3553,7 @@ static int hdmitx_cntl_ddc(struct hdmitx_dev *hdev, unsigned cmd,
 		break;
 	case DDC_HDCP_MUX_INIT:
 		if (argv == 2)
-			; /* hdmitx_hdcp_opr(5); */
+			hdmitx_ddc_hw_op(DDC_MUX_DDC);
 		if (argv == 1)
 			hdmitx_hdcp_opr(6);
 		break;
@@ -3751,11 +3825,13 @@ static int hdmitx_cntl_config(struct hdmitx_dev *hdev, unsigned cmd,
 		break;
 	case CONF_CLR_AVI_PACKET:
 		hdmitx_wr_reg(HDMITX_DWC_FC_AVIVID, 0);
-		hdmitx_wr_reg(HDMITX_DWC_FC_VSDPAYLOAD1, 0);
+		if (hdmitx_rd_reg(HDMITX_DWC_FC_VSDPAYLOAD0) == 0x20)
+			hdmitx_wr_reg(HDMITX_DWC_FC_VSDPAYLOAD1, 0);
 		hd_write_reg(P_ISA_DEBUG_REG0, 0);
 		break;
 	case CONF_CLR_VSDB_PACKET:
-		hdmitx_wr_reg(HDMITX_DWC_FC_VSDPAYLOAD1, 0);
+		if (hdmitx_rd_reg(HDMITX_DWC_FC_VSDPAYLOAD0) == 0x20)
+			hdmitx_wr_reg(HDMITX_DWC_FC_VSDPAYLOAD1, 0);
 		break;
 	case CONF_VIDEO_MAPPING:
 		config_video_mapping(hdev->para->cs, hdev->para->cd);
@@ -3770,6 +3846,16 @@ static int hdmitx_cntl_config(struct hdmitx_dev *hdev, unsigned cmd,
 		if (argv == CLR_AVI_BT2020)
 			hdmitx_set_avi_colorimetry(hdev->para);
 		break;
+	case CONF_AVI_RGBYCC_INDIC:
+		hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF0, argv, 0, 2);
+		hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF0, 0, 7, 1);
+		break;
+	case CONF_AVI_Q01:
+		hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF2, argv, 2, 2);
+		break;
+	case CONF_AVI_YQ01:
+		hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF3, argv, 2, 2);
+		break;
 	default:
 		hdmi_print(ERR, "config: ""hdmitx: unknown cmd: 0x%x\n", cmd);
 	}
@@ -3820,41 +3906,12 @@ static int hdmitx_cntl_misc(struct hdmitx_dev *hdev, unsigned cmd,
 		break;
 	case MISC_VIID_IS_USING:
 		break;
-	case MISC_CONF_MODE420:
-		hd_write_reg(P_VPU_HDMI_SETTING, 0x10e);
-		break;
 	case MISC_TMDS_CLK_DIV40:
 		set_tmds_clk_div40(argv);
 		break;
 	case MISC_AVMUTE_OP:
 		config_avmute(argv);
 		break;
-	case MISC_FINE_TUNE_HPLL:
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-		if (hdmi_get_current_vinfo()) {
-			switch (hdmi_get_current_vinfo()->mode) {
-			case VMODE_720P:
-			case VMODE_1080I:
-			case VMODE_1080P:
-			case VMODE_1080P_24HZ:
-			case VMODE_4K2K_30HZ:
-			case VMODE_4K2K_24HZ:
-			case VMODE_4K2K_60HZ_Y420:
-			case VMODE_4K2K_SMPTE_60HZ_Y420:
-				hdmitx_fine_tune_hpll(argv);
-				break;
-			case VMODE_4K2K_60HZ:
-				if (argv == DOWN_HPLL)
-					pr_info("TODO: 4k60hz\n");
-				 else if (argv == UP_HPLL)
-					pr_info("TODO: 4k60hz\n");
-				break;
-			default:
-				break;
-			}
-		}
-		break;
-#endif
 	case MISC_HDCP_CLKDIS:
 		hdmitx_set_reg_bits(HDMITX_DWC_MC_CLKDIS, argv, 6, 1);
 		break;
@@ -4022,12 +4079,15 @@ void hdmitx_set_avi_colorimetry(struct hdmi_format_para *para)
 	case HDMI_720x480i240_16x9:
 		/* C1C0 601 */
 		hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF1, 1, 6, 2);
+		hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF2, 0, 4, 3);
 		break;
 	default:
 		/* C1C0 709 */
 		hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF1, 2, 6, 2);
+		hdmitx_set_reg_bits(HDMITX_DWC_FC_AVICONF2, 0, 4, 3);
 		break;
 	}
+#if 0
 	switch (para->vic) {
 	case HDMI_3840x2160p24_16x9:
 	case HDMI_3840x2160p25_16x9:
@@ -4054,6 +4114,7 @@ void hdmitx_set_avi_colorimetry(struct hdmi_format_para *para)
 	default:
 		break;
 	}
+#endif
 }
 
 /*
@@ -4325,11 +4386,16 @@ static void config_hdmi20_tx(enum hdmi_vic vic,
 	data32  = (GET_TIMING(h_blank)>>8)&0x1f;
 	hdmitx_wr_reg(HDMITX_DWC_FC_INHBLANK1,  data32);
 
-	data32  = GET_TIMING(v_active)&0xff;
-	hdmitx_wr_reg(HDMITX_DWC_FC_INVACTV0,   data32);
-	data32  = (GET_TIMING(v_active)>>8)&0x1f;
-	hdmitx_wr_reg(HDMITX_DWC_FC_INVACTV1,   data32);
-
+	if (hdev->flag_3dfp) {
+		data32 = (((GET_TIMING(v_active)) * 2) + (GET_TIMING(v_blank)));
+		hdmitx_wr_reg(HDMITX_DWC_FC_INVACTV0, data32 & 0xff);
+		hdmitx_wr_reg(HDMITX_DWC_FC_INVACTV1, (data32 >> 8) & 0x1f);
+	} else {
+		data32 = GET_TIMING(v_active) & 0xff;
+		hdmitx_wr_reg(HDMITX_DWC_FC_INVACTV0, data32);
+		data32 = (GET_TIMING(v_active) >> 8) & 0x1f;
+		hdmitx_wr_reg(HDMITX_DWC_FC_INVACTV1, data32);
+	}
 	data32  = GET_TIMING(v_blank)&0xff;
 	hdmitx_wr_reg(HDMITX_DWC_FC_INVBLANK,   data32);
 
@@ -4500,15 +4566,9 @@ static void config_hdmi20_tx(enum hdmi_vic vic,
 	hdmitx_wr_reg(HDMITX_DWC_FC_CTRLQLOW, 3);
 
 	/* packet scheduller configuration for SPD, VSD, ISRC1/2, ACP. */
-	data32  = 0;
-	data32 |= (0 << 4);
-	data32 |= (0 << 3);
-	data32 |= (0 << 2);
-	data32 |= (0 << 1);
-	data32 |= (0 << 0);
-	hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO0, data32);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_DATAUTO0, 0, 0, 3);
+	hdmitx_set_reg_bits(HDMITX_DWC_FC_DATAUTO0, 0, 4, 4);
 	hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO1, 0);
-	hdmitx_wr_reg(HDMITX_DWC_FC_DATAUTO2, 0);
 	hdmitx_wr_reg(HDMITX_DWC_FC_DATMAN, 0);
 
 	/* packet scheduller configuration for AVI, GCP, AUDI, ACR. */
@@ -4607,7 +4667,8 @@ static void config_hdmi20_tx(enum hdmi_vic vic,
 	hdmitx_wr_reg(HDMITX_DWC_A_VIDPOLCFG,   data32);
 
 	hdmitx_wr_reg(HDMITX_DWC_A_OESSWCFG,    0x40);
-	hdmitx_hdcp_opr(0);
+	if (hdmitx_hdcp_opr(0xa))
+		hdmitx_hdcp_opr(0);
 	/* Interrupts */
 	/* Clear interrupts */
 	hdmitx_wr_reg(HDMITX_DWC_IH_FC_STAT0,  0xff);
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.c b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.c
index e14bc9a..4df3b16 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.c
@@ -1,11 +1,16 @@
+#include <linux/module.h>
 #include <linux/printk.h>
 #include <linux/kernel.h>
+#include <linux/delay.h>
 #include <linux/amlogic/cpu_version.h>
 #include "common.h"
 #include "mach_reg.h"
-#include "mach_reg_gxtvbb.h"
 #include "hw_clk.h"
 
+/* local frac_rate flag */
+static uint32_t frac_rate;
+/* enable or disable HDMITX SSPLL, enable by default */
+static int sspll_en = 1;
 
 /*
  * HDMITX Clock configuration
@@ -37,20 +42,6 @@ static inline int check_div(unsigned int div)
 	return div;
 }
 
-#define WAIT_FOR_PLL_LOCKED(reg)                        \
-	do {                                                \
-		unsigned int cnt = 10;                          \
-		unsigned int time_out = 0;                      \
-		while (cnt--) {                                 \
-			time_out = 0;                               \
-			while ((!(hd_read_reg(reg) & (1 << 31)))\
-				& (time_out < 10000))               \
-				time_out++;                            \
-			}                                               \
-		if (cnt < 9)                                     \
-			pr_info("pll[0x%x] reset %d times\n", reg, 9 - cnt);\
-	} while (0)
-
 static void set_hdmitx_sys_clk(void)
 {
 	hd_set_reg_bits(P_HHI_HDMI_CLK_CNTL, 0, 9, 3);
@@ -71,7 +62,40 @@ static void set_gxb_hpll_clk_out(unsigned clk)
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
 		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4c00, 0, 16);
+		if (frac_rate)
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4a05, 0, 16);
+		else
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4c00, 0, 16);
+		break;
+	case 5405400:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x58000270);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x135c5091);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		if (frac_rate)
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4800, 0, 16);
+		else
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x49cd, 0, 16);
+		break;
+	case 4455000:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800025c);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x135c5091);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		if (frac_rate)
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4b84, 0, 16);
+		else
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4d00, 0, 16);
 		break;
 	case 3712500:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800024d);
@@ -83,7 +107,10 @@ static void set_gxb_hpll_clk_out(unsigned clk)
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
 		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4580, 0, 16);
+		if (frac_rate)
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4443, 0, 16);
+		else
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4580, 0, 16);
 		break;
 	case 3450000:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x58000247);
@@ -96,6 +123,21 @@ static void set_gxb_hpll_clk_out(unsigned clk)
 		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4300, 0, 16);
 		break;
+	case 3243240:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x58000243);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0d5c5091);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00000e55);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
+		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4300, 0, 16);
+		if (frac_rate)
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4800, 0, 16);
+		else
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4914, 0, 16);
+		break;
 	case 2970000:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800023d);
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
@@ -106,9 +148,12 @@ static void set_gxb_hpll_clk_out(unsigned clk)
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
 		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4e00, 0, 16);
+		if (frac_rate)
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4d03, 0, 16);
+		else
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4e00, 0, 16);
 		break;
-	case 4320000:
+	case 4324320:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800025a);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x00000000);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0d5c5091);
@@ -118,6 +163,10 @@ static void set_gxb_hpll_clk_out(unsigned clk)
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
 		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
 		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		if (frac_rate)
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
+		else
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4171, 0, 16);
 		break;
 	default:
 		pr_info("error hpll clk: %d\n", clk);
@@ -130,7 +179,38 @@ static void set_gxtvbb_hpll_clk_out(unsigned clk)
 	switch (clk) {
 	case 5940000:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800027b);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4300, 0, 16);
+		if (frac_rate)
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4281, 0, 16);
+		else
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4300, 0, 16);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x12dc5081);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00002e55);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		break;
+	case 5405400:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x58000270);
+		if (frac_rate)
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4200, 0, 16);
+		else
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4273, 0, 16);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x12dc5081);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00002e55);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		break;
+	case 4455000:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800025c);
+		if (frac_rate)
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x42e1, 0, 16);
+		else
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4340, 0, 16);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x12dc5081);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
@@ -141,7 +221,10 @@ static void set_gxtvbb_hpll_clk_out(unsigned clk)
 		break;
 	case 3712500:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800024d);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4160, 0, 16);
+		if (frac_rate)
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4111, 0, 16);
+		else
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4160, 0, 16);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0d5c5091);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
@@ -160,9 +243,25 @@ static void set_gxtvbb_hpll_clk_out(unsigned clk)
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
 		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		break;
+	case 3243240:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x58000243);
+		if (frac_rate)
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4200, 0, 16);
+		else
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4245, 0, 16);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0d5c5091);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x00002e55);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x4, 28, 3);
+		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		break;
 	case 2970000:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800023d);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4380, 0, 16);
+		if (frac_rate)
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4341, 0, 16);
+		else
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4380, 0, 16);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0d5c5091);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
@@ -172,9 +271,13 @@ static void set_gxtvbb_hpll_clk_out(unsigned clk)
 		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
 		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x4e00, 0, 16);
 		break;
-	case 4320000:
+	case 4324320:
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x5800025a);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x00000000);
+		if (frac_rate)
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x0, 0, 16);
+		else
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x405c, 0, 16);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0d5c5091);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x801da72c);
 		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x71486980);
@@ -189,75 +292,6 @@ static void set_gxtvbb_hpll_clk_out(unsigned clk)
 	}
 }
 
-static void set_gxl_hpll_clk_out(unsigned clk)
-{
-	switch (clk) {
-	case 5940000:
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x400002f7);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x800cb200);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x860f30c4);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x0c8e0000);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x001fa729);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x01a31500);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
-		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
-		break;
-	case 3712500:
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x4000029a);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x800cb2c0);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x860f30c4);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x0c8e0000);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x001fa729);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x01a31500);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
-		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
-		break;
-	case 3450000:
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x4000028f);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x800cb300);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x860f30c4);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x0c8e0000);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x001fa729);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x01a31500);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
-		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
-		break;
-	case 2970000:
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x4000027b);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x800cb300);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x860f30c4);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x0c8e0000);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x001fa729);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x01a31500);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
-		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
-		break;
-	case 4320000:
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x400002b4);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x800cb000);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x860f30c4);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x0c8e0000);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x001fa729);
-		hd_write_reg(P_HHI_HDMI_PLL_CNTL6, 0x01a31500);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
-		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
-		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
-		break;
-	default:
-		pr_info("error hpll clk: %d\n", clk);
-		break;
-	}
-}
-
 static void set_hpll_clk_out(unsigned clk)
 {
 	pr_info("config HPLL = %d\n", clk);
@@ -271,13 +305,15 @@ static void set_hpll_clk_out(unsigned clk)
 		break;
 	case MESON_CPU_MAJOR_ID_GXL:
 	case MESON_CPU_MAJOR_ID_GXM:
-		set_gxl_hpll_clk_out(clk);
+	default:
+		set_gxl_hpll_clk_out(frac_rate, clk);
 		break;
 	}
 
 	pr_info("config HPLL done\n");
 }
 
+/* HERE MUST BE BIT OPERATION!!! */
 static void set_hpll_sspll(enum hdmi_vic vic)
 {
 	switch (get_cpu_type()) {
@@ -287,20 +323,7 @@ static void set_hpll_sspll(enum hdmi_vic vic)
 		break;
 	case MESON_CPU_MAJOR_ID_GXL:
 	case MESON_CPU_MAJOR_ID_GXM:
-		switch (vic) {
-		case HDMI_1920x1080p60_16x9:
-		case HDMI_1920x1080p50_16x9:
-			hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x868b48c4);
-			break;
-		case HDMI_1280x720p60_16x9:
-		case HDMI_1280x720p50_16x9:
-		case HDMI_1920x1080i60_16x9:
-		case HDMI_1920x1080i50_16x9:
-			hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x864348c4);
-			break;
-		default:
-			break;
-		}
+		set_hpll_sspll_gxl(vic);
 		break;
 	default:
 		break;
@@ -309,117 +332,90 @@ static void set_hpll_sspll(enum hdmi_vic vic)
 
 static void set_hpll_od1(unsigned div)
 {
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
+	switch (get_cpu_type()) {
+	case MESON_CPU_MAJOR_ID_GXBB:
+	case MESON_CPU_MAJOR_ID_GXTVBB:
 		switch (div) {
 		case 1:
-			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 0, 21, 2);
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0, 16, 2);
 			break;
 		case 2:
-			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 1, 21, 2);
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 1, 16, 2);
 			break;
 		case 4:
-			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 2, 21, 2);
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 2, 16, 2);
+			break;
+		case 8:
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 3, 16, 2);
 			break;
 		default:
-			pr_info("Err %s[%d]\n", __func__, __LINE__);
 			break;
 		}
-		return;
-	}
-
-	/* other than GXL */
-	switch (div) {
-	case 1:
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0, 16, 2);
-		break;
-	case 2:
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 1, 16, 2);
-		break;
-	case 4:
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 2, 16, 2);
-		break;
-	case 8:
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 3, 16, 2);
 		break;
+	case MESON_CPU_MAJOR_ID_GXL:
+	case MESON_CPU_MAJOR_ID_GXM:
 	default:
+		set_hpll_od1_gxl(div);
 		break;
 	}
 }
 
 static void set_hpll_od2(unsigned div)
 {
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
+	switch (get_cpu_type()) {
+	case MESON_CPU_MAJOR_ID_GXBB:
+	case MESON_CPU_MAJOR_ID_GXTVBB:
 		switch (div) {
 		case 1:
-			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 0, 23, 2);
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0, 22, 2);
 			break;
 		case 2:
-			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 1, 23, 2);
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 1, 22, 2);
 			break;
 		case 4:
-			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 2, 23, 2);
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 2, 22, 2);
+			break;
+		case 8:
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 3, 22, 2);
 			break;
 		default:
-			pr_info("Err %s[%d]\n", __func__, __LINE__);
 			break;
 		}
-		return;
-	}
-
-	/* other than GXL */
-	switch (div) {
-	case 1:
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0, 22, 2);
-		break;
-	case 2:
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 1, 22, 2);
-		break;
-	case 4:
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 2, 22, 2);
-		break;
-	case 8:
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 3, 22, 2);
 		break;
+	case MESON_CPU_MAJOR_ID_GXL:
+	case MESON_CPU_MAJOR_ID_GXM:
 	default:
+		set_hpll_od2_gxl(div);
 		break;
 	}
 }
 
 static void set_hpll_od3(unsigned div)
 {
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXL) {
+	switch (get_cpu_type()) {
+	case MESON_CPU_MAJOR_ID_GXBB:
+	case MESON_CPU_MAJOR_ID_GXTVBB:
 		switch (div) {
 		case 1:
-			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 0, 19, 2);
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0, 18, 2);
 			break;
 		case 2:
-			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 1, 19, 2);
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 1, 18, 2);
 			break;
 		case 4:
-			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL3, 2, 19, 2);
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 2, 18, 2);
+			break;
+		case 8:
+			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 3, 18, 2);
 			break;
 		default:
-			pr_info("Err %s[%d]\n", __func__, __LINE__);
 			break;
 		}
-		return;
-	}
-
-	/* other than GXL */
-	switch (div) {
-	case 1:
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0, 18, 2);
-		break;
-	case 2:
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 1, 18, 2);
-		break;
-	case 4:
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 2, 18, 2);
-		break;
-	case 8:
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 3, 18, 2);
 		break;
+	case MESON_CPU_MAJOR_ID_GXL:
+	case MESON_CPU_MAJOR_ID_GXM:
 	default:
+		set_hpll_od3_gxl(div);
 		break;
 	}
 }
@@ -564,15 +560,15 @@ static void set_enci_div(unsigned div)
 /* mode hpll_clk_out od1 od2(PHY) od3
  * vid_pll_div vid_clk_div hdmi_tx_pixel_div encp_div enci_div
  */
-static struct hw_enc_clk_val_group setting_enc_clk_val[] = {
+static struct hw_enc_clk_val_group setting_enc_clk_val_24[] = {
 	{{HDMI_720x480i60_16x9,
 	  HDMI_720x576i50_16x9,
 	  HDMI_VIC_END},
-		4320000, 4, 4, 1, VID_PLL_DIV_5, 1, 2, -1, 2},
+		4324320, 4, 4, 1, VID_PLL_DIV_5, 1, 2, -1, 2},
 	{{HDMI_720x576p50_16x9,
 	  HDMI_720x480p60_16x9,
 	  HDMI_VIC_END},
-		4320000, 4, 4, 1, VID_PLL_DIV_5, 1, 2, 1, -1},
+		4324320, 4, 4, 1, VID_PLL_DIV_5, 1, 2, 1, -1},
 	{{HDMI_1280x720p50_16x9,
 	  HDMI_1280x720p60_16x9,
 	  HDMI_VIC_END},
@@ -597,7 +593,7 @@ static struct hw_enc_clk_val_group setting_enc_clk_val[] = {
 	  HDMI_4096x2160p25_256x135,
 	  HDMI_4096x2160p30_256x135,
 	  HDMI_VIC_END},
-		2970000, 1, 1, 1, VID_PLL_DIV_5, 2, 1, 1, -1},
+		5940000, 2, 1, 1, VID_PLL_DIV_5, 2, 1, 1, -1},
 	{{HDMI_3840x2160p60_16x9,
 	  HDMI_3840x2160p50_16x9,
 	  HDMI_4096x2160p60_256x135,
@@ -609,20 +605,39 @@ static struct hw_enc_clk_val_group setting_enc_clk_val[] = {
 	  HDMI_3840x2160p60_16x9_Y420,
 	  HDMI_3840x2160p50_16x9_Y420,
 	  HDMI_VIC_END},
-		2970000, 1, 1, 1, VID_PLL_DIV_5, 1, 2, 1, -1},
+		5940000, 2, 1, 1, VID_PLL_DIV_5, 1, 2, 1, -1},
 	{{HDMI_VIC_FAKE,
 	  HDMI_VIC_END},
 		3450000, 1, 2, 2, VID_PLL_DIV_5, 1, 1, 1, -1},
 };
 
-/* mode hpll_clk_out od1 od2(PHY) od3
- * vid_pll_div vid_clk_div hdmi_tx_pixel_div encp_div enci_div
- */
+/* For colordepth 10bits */
 static struct hw_enc_clk_val_group setting_enc_clk_val_30[] = {
+	{{HDMI_720x480i60_16x9,
+	  HDMI_720x576i50_16x9,
+	  HDMI_VIC_END},
+		5405400, 4, 4, 1, VID_PLL_DIV_6p25, 1, 2, -1, 2},
+	{{HDMI_720x576p50_16x9,
+	  HDMI_720x480p60_16x9,
+	  HDMI_VIC_END},
+		5405400, 4, 4, 1, VID_PLL_DIV_6p25, 1, 2, 1, -1},
+	{{HDMI_1280x720p50_16x9,
+	  HDMI_1280x720p60_16x9,
+	  HDMI_VIC_END},
+		3712500, 4, 1, 1, VID_PLL_DIV_6p25, 1, 2, 1, -1},
+	{{HDMI_1920x1080i60_16x9,
+	  HDMI_1920x1080i50_16x9,
+	  HDMI_VIC_END},
+		3712500, 4, 1, 1, VID_PLL_DIV_6p25, 1, 2, 1, -1},
 	{{HDMI_1920x1080p60_16x9,
 	  HDMI_1920x1080p50_16x9,
 	  HDMI_VIC_END},
 		3712500, 1, 2, 2, VID_PLL_DIV_6p25, 1, 1, 1, -1},
+	{{HDMI_1920x1080p30_16x9,
+	  HDMI_1920x1080p24_16x9,
+	  HDMI_1920x1080p25_16x9,
+	  HDMI_VIC_END},
+		3712500, 2, 2, 2, VID_PLL_DIV_6p25, 1, 1, 1, -1},
 	{{HDMI_4096x2160p60_256x135_Y420,
 	  HDMI_4096x2160p50_256x135_Y420,
 	  HDMI_3840x2160p60_16x9_Y420,
@@ -632,6 +647,9 @@ static struct hw_enc_clk_val_group setting_enc_clk_val_30[] = {
 	{{HDMI_3840x2160p24_16x9,
 	  HDMI_3840x2160p25_16x9,
 	  HDMI_3840x2160p30_16x9,
+	  HDMI_4096x2160p24_256x135,
+	  HDMI_4096x2160p25_256x135,
+	  HDMI_4096x2160p30_256x135,
 	  HDMI_VIC_END},
 		3712500, 1, 1, 1, VID_PLL_DIV_6p25, 1, 2, 2, -1},
 	{{HDMI_VIC_FAKE,
@@ -639,30 +657,134 @@ static struct hw_enc_clk_val_group setting_enc_clk_val_30[] = {
 		3450000, 1, 2, 2, VID_PLL_DIV_5, 1, 1, 1, -1},
 };
 
-void hdmitx_set_clk(enum hdmi_vic vic)
+/* For colordepth 12bits */
+static struct hw_enc_clk_val_group setting_enc_clk_val_36[] = {
+	{{HDMI_720x480i60_16x9,
+	  HDMI_720x576i50_16x9,
+	  HDMI_VIC_END},
+		3243240, 2, 4, 1, VID_PLL_DIV_7p5, 1, 2, -1, 2},
+	{{HDMI_720x576p50_16x9,
+	  HDMI_720x480p60_16x9,
+	  HDMI_VIC_END},
+		3243240, 2, 4, 1, VID_PLL_DIV_7p5, 1, 2, 1, -1},
+	{{HDMI_1280x720p50_16x9,
+	  HDMI_1280x720p60_16x9,
+	  HDMI_VIC_END},
+		4455000, 4, 1, 1, VID_PLL_DIV_7p5, 1, 2, 1, -1},
+	{{HDMI_1920x1080i60_16x9,
+	  HDMI_1920x1080i50_16x9,
+	  HDMI_VIC_END},
+		4455000, 4, 1, 1, VID_PLL_DIV_7p5, 1, 2, 1, -1},
+	{{HDMI_1920x1080p60_16x9,
+	  HDMI_1920x1080p50_16x9,
+	  HDMI_VIC_END},
+		4455000, 1, 2, 2, VID_PLL_DIV_7p5, 1, 1, 1, -1},
+	{{HDMI_1920x1080p30_16x9,
+	  HDMI_1920x1080p24_16x9,
+	  HDMI_1920x1080p25_16x9,
+	  HDMI_VIC_END},
+		4455000, 2, 2, 2, VID_PLL_DIV_7p5, 1, 1, 1, -1},
+	{{HDMI_4096x2160p60_256x135_Y420,
+	  HDMI_4096x2160p50_256x135_Y420,
+	  HDMI_3840x2160p60_16x9_Y420,
+	  HDMI_3840x2160p50_16x9_Y420,
+	  HDMI_VIC_END},
+		4455000, 1, 1, 1, VID_PLL_DIV_7p5, 1, 2, 1, -1},
+	{{HDMI_3840x2160p24_16x9,
+	  HDMI_3840x2160p25_16x9,
+	  HDMI_3840x2160p30_16x9,
+	  HDMI_4096x2160p24_256x135,
+	  HDMI_4096x2160p25_256x135,
+	  HDMI_4096x2160p30_256x135,
+	  HDMI_VIC_END},
+		4455000, 1, 1, 1, VID_PLL_DIV_7p5, 1, 2, 2, -1},
+	{{HDMI_VIC_FAKE,
+	  HDMI_VIC_END},
+		3450000, 1, 2, 2, VID_PLL_DIV_5, 1, 1, 1, -1},
+};
+
+/* For 3D Frame Packing Clock Setting
+ * mode hpll_clk_out od1 od2(PHY) od3
+ * vid_pll_div vid_clk_div hdmi_tx_pixel_div encp_div enci_div
+ */
+static struct hw_enc_clk_val_group setting_3dfp_enc_clk_val[] = {
+	{{HDMI_1920x1080p60_16x9,
+	  HDMI_1920x1080p50_16x9,
+	  HDMI_VIC_END},
+		2970000, 1, 1, 2, VID_PLL_DIV_5, 1, 1, 1, -1},
+	{{HDMI_1280x720p50_16x9,
+	  HDMI_1280x720p60_16x9,
+	  HDMI_1920x1080p30_16x9,
+	  HDMI_1920x1080p24_16x9,
+	  HDMI_1920x1080p25_16x9,
+	  HDMI_VIC_END},
+		2970000, 1, 2, 2, VID_PLL_DIV_5, 1, 1, 1, -1},
+	/* NO 2160p mode*/
+	{{HDMI_VIC_FAKE,
+	  HDMI_VIC_END},
+		3450000, 1, 2, 2, VID_PLL_DIV_5, 1, 1, 1, -1},
+};
+
+static void hdmitx_set_clk_(enum hdmi_vic vic, enum hdmi_color_depth cd)
 {
 	int i = 0;
 	int j = 0;
 	struct hw_enc_clk_val_group *p_enc = NULL;
 
-	p_enc = &setting_enc_clk_val[0];
-	for (j = 0; j < sizeof(setting_enc_clk_val)
-		/ sizeof(struct hw_enc_clk_val_group); j++) {
-		for (i = 0; ((i < GROUP_MAX) && (p_enc[j].group[i]
-			!= HDMI_VIC_END)); i++) {
-			if (vic == p_enc[j].group[i])
-				goto next;
+	if (cd == COLORDEPTH_24B) {
+		p_enc = &setting_enc_clk_val_24[0];
+		for (j = 0; j < sizeof(setting_enc_clk_val_24)
+			/ sizeof(struct hw_enc_clk_val_group); j++) {
+			for (i = 0; ((i < GROUP_MAX) && (p_enc[j].group[i]
+				!= HDMI_VIC_END)); i++) {
+				if (vic == p_enc[j].group[i])
+					goto next;
+			}
 		}
-	}
-	if (j == sizeof(setting_enc_clk_val)
-		/ sizeof(struct hw_enc_clk_val_group)) {
-		pr_info("Not find VIC = %d for hpll setting\n", vic);
+		if (j == sizeof(setting_enc_clk_val_24)
+			/ sizeof(struct hw_enc_clk_val_group)) {
+			pr_info("Not find VIC = %d for hpll setting\n", vic);
+			return;
+		}
+	} else if (cd == COLORDEPTH_30B) {
+		p_enc = &setting_enc_clk_val_30[0];
+		for (j = 0; j < sizeof(setting_enc_clk_val_30)
+			/ sizeof(struct hw_enc_clk_val_group); j++) {
+			for (i = 0; ((i < GROUP_MAX) && (p_enc[j].group[i]
+				!= HDMI_VIC_END)); i++) {
+				if (vic == p_enc[j].group[i])
+					goto next;
+			}
+		}
+		if (j == sizeof(setting_enc_clk_val_30) /
+			sizeof(struct hw_enc_clk_val_group)) {
+			pr_info("Not find VIC = %d for hpll setting\n", vic);
+			return;
+		}
+	} else if (cd == COLORDEPTH_36B) {
+		p_enc = &setting_enc_clk_val_36[0];
+		for (j = 0; j < sizeof(setting_enc_clk_val_36)
+			/ sizeof(struct hw_enc_clk_val_group); j++) {
+			for (i = 0; ((i < GROUP_MAX) && (p_enc[j].group[i]
+				!= HDMI_VIC_END)); i++) {
+				if (vic == p_enc[j].group[i])
+					goto next;
+			}
+		}
+		if (j == sizeof(setting_enc_clk_val_36) /
+			sizeof(struct hw_enc_clk_val_group)) {
+			pr_info("Not find VIC = %d for hpll setting\n", vic);
+			return;
+		}
+	} else {
+		pr_info("not support colordepth 48bits\n");
 		return;
 	}
 next:
 	set_hdmitx_sys_clk();
 	set_hpll_clk_out(p_enc[j].hpll_clk_out);
-	set_hpll_sspll(vic);
+	if ((cd == COLORDEPTH_24B) && sspll_en)
+		set_hpll_sspll(vic);
 	set_hpll_od1(p_enc[j].od1);
 	set_hpll_od2(p_enc[j].od2);
 	set_hpll_od3(p_enc[j].od3);
@@ -674,14 +796,14 @@ void hdmitx_set_clk(enum hdmi_vic vic)
 	set_enci_div(p_enc[j].enci_div);
 }
 
-void hdmitx_set_clk_30b(enum hdmi_vic vic)
+static void hdmitx_set_3dfp_clk(enum hdmi_vic vic)
 {
 	int i = 0;
 	int j = 0;
 	struct hw_enc_clk_val_group *p_enc = NULL;
 
-	p_enc = &setting_enc_clk_val_30[0];
-	for (j = 0; j < sizeof(setting_enc_clk_val_30)
+	p_enc = &setting_3dfp_enc_clk_val[0];
+	for (j = 0; j < sizeof(setting_3dfp_enc_clk_val)
 		/ sizeof(struct hw_enc_clk_val_group); j++) {
 		for (i = 0; ((i < GROUP_MAX) && (p_enc[j].group[i]
 			!= HDMI_VIC_END)); i++) {
@@ -689,14 +811,15 @@ void hdmitx_set_clk_30b(enum hdmi_vic vic)
 				goto next;
 		}
 	}
-	if (j == sizeof(setting_enc_clk_val_30) /
-		sizeof(struct hw_enc_clk_val_group)) {
+	if (j == sizeof(setting_3dfp_enc_clk_val)
+		/ sizeof(struct hw_enc_clk_val_group)) {
 		pr_info("Not find VIC = %d for hpll setting\n", vic);
 		return;
 	}
 next:
 	set_hdmitx_sys_clk();
 	set_hpll_clk_out(p_enc[j].hpll_clk_out);
+	set_hpll_sspll(vic);
 	set_hpll_od1(p_enc[j].od1);
 	set_hpll_od2(p_enc[j].od2);
 	set_hpll_od3(p_enc[j].od3);
@@ -708,28 +831,41 @@ void hdmitx_set_clk_30b(enum hdmi_vic vic)
 	set_enci_div(p_enc[j].enci_div);
 }
 
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-int hdmitx_fine_tune_hpll(enum fine_tune_mode_e mode)
+static int likely_frac_rate_mode(char *m)
+{
+	if (strstr(m, "24hz") || strstr(m, "30hz") || strstr(m, "60hz")
+		|| strstr(m, "120hz") || strstr(m, "240hz"))
+		return 1;
+	else
+		return 0;
+}
+
+void hdmitx_set_clk(struct hdmitx_dev *hdev)
 {
-	static unsigned int save_div_frac;
-
-	if (mode == DOWN_HPLL) {
-		save_div_frac = hd_read_reg(P_HHI_HDMI_PLL_CNTL2);
-		if (is_meson_gxl_cpu() || is_meson_gxm_cpu()) {
-			if ((save_div_frac & 0xfff) == 0x300)
-				hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2,
-					0x280 , 0, 11);
-			else if ((save_div_frac & 0xfff) == 0x200)
-				hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2,
-					0x100 , 0, 11);
-		} else
-			hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2,
-				0xd03 , 0, 11);
-	} else if (mode == UP_HPLL) {
-		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2,
-		save_div_frac&0xfff , 0, 11);
+	enum hdmi_vic vic = hdev->cur_VIC;
+	struct hdmi_format_para *para = NULL;
+
+	frac_rate = hdev->frac_rate_policy;
+	pr_info("hdmitx: set clk: VIC = %d  cd = %d  frac_rate = %d\n", vic,
+		hdev->para->cd, frac_rate);
+	para = hdmi_get_fmt_paras(vic);
+	if (para && (para->name) && likely_frac_rate_mode(para->name))
+		;
+	else {
+		pr_info("hdmitx: %s doesn't have frac_rate\n", para->name);
+		frac_rate = 0;
 	}
 
-	return 0;
+	if (hdev->flag_3dfp) {
+		hdmitx_set_3dfp_clk(vic);
+		return;
+	}
+	if (hdev->para->cs != COLORSPACE_YUV422)
+		hdmitx_set_clk_(vic, hdev->para->cd);
+	else
+		hdmitx_set_clk_(vic, COLORDEPTH_24B);
 }
-#endif
+
+MODULE_PARM_DESC(sspll_en, "\n hdmitx sspll_en\n");
+module_param(sspll_en, int, 0664);
+
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.h b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.h
index d06984e..ad7f379 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.h
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_clk.h
@@ -3,6 +3,7 @@
 #define __HW_ENC_CLK_CONFIG_H__
 
 #include <linux/amlogic/hdmi_tx/hdmi_common.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
 #include <linux/amlogic/vout/vinfo.h>
 
 #define VID_PLL_DIV_1      0
@@ -35,13 +36,7 @@ struct hw_enc_clk_val_group {
 	unsigned enci_div;
 };
 
-void hdmitx_set_clk(enum hdmi_vic vic); /* For 24bits */
-void hdmitx_set_clk_30b(enum hdmi_vic vic); /* For 30bits */
-
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-/* for framerate-auto, fine tune for clock */
-int hdmitx_fine_tune_hpll(enum fine_tune_mode_e mode);
-#endif
+void hdmitx_set_clk(struct hdmitx_dev *hdev);
 
 #endif
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_gxbb.c b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_gxbb.c
index 35d7646..3ff8202 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_gxbb.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_gxbb.c
@@ -1,7 +1,6 @@
 #include <linux/printk.h>
 #include "common.h"
 #include "mach_reg.h"
-#include "mach_reg_gxbb.h"
 
 /*
  * NAME		PAD		PINMUX		GPIO
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_gxl.c b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_gxl.c
index e518ca9..53d5a25 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_gxl.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_gxl.c
@@ -1,7 +1,33 @@
 #include <linux/printk.h>
 #include "common.h"
 #include "mach_reg.h"
-#include "mach_reg_gxtvbb.h"
+
+/*
+ * From GXL chips, registers names changes.
+ * Added new HHI_HDMI_PLL_CNTL1 but addessed as 0xc9.
+ * It's different with HHI_HDMI_PLL_CNTL2 0xc9 in previouse chips.
+ */
+#ifdef P_HHI_HDMI_PLL_CNTL2
+#undef P_HHI_HDMI_PLL_CNTL2
+#endif
+#ifdef P_HHI_HDMI_PLL_CNTL3
+#undef P_HHI_HDMI_PLL_CNTL3
+#endif
+#ifdef P_HHI_HDMI_PLL_CNTL4
+#undef P_HHI_HDMI_PLL_CNTL4
+#endif
+#ifdef P_HHI_HDMI_PLL_CNTL5
+#undef P_HHI_HDMI_PLL_CNTL5
+#endif
+#ifdef P_HHI_HDMI_PLL_CNTL6
+#undef P_HHI_HDMI_PLL_CNTL6
+#endif
+
+#define P_HHI_HDMI_PLL_CNTL1 (0xc883c000 + (0xc9 << 2))
+#define P_HHI_HDMI_PLL_CNTL2 (0xc883c000 + (0xca << 2))
+#define P_HHI_HDMI_PLL_CNTL3 (0xc883c000 + (0xcb << 2))
+#define P_HHI_HDMI_PLL_CNTL4 (0xc883c000 + (0xcc << 2))
+#define P_HHI_HDMI_PLL_CNTL5 (0xc883c000 + (0xcd << 2))
 
 /*
  * NAME		PAD		PINMUX		GPIO
@@ -69,3 +95,218 @@ int hdmitx_ddc_hw_op_gxl(enum ddc_op cmd)
 	}
 	return ret;
 }
+
+void set_gxl_hpll_clk_out(unsigned frac_rate, unsigned clk)
+{
+	switch (clk) {
+	case 5940000:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x4000027b);
+		if (frac_rate)
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL1, 0x800cb281);
+		else
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL1, 0x800cb300);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0xc60f30e0);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0c8e0000);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x001fa729);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x01a31500);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		break;
+	case 5405400:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x400002e1);
+		if (frac_rate)
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL1, 0x800cb000);
+		else
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL1, 0x800cb0e6);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x860f30c4);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0c8e0000);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x001fa729);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x01a31500);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		break;
+	case 4455000:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x400002b9);
+		if (frac_rate)
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL1, 0x800cb1c2);
+		else
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL1, 0x800cb280);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x860f30c4);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0c8e0000);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x001fa729);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x01a31500);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		break;
+	case 3712500:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x4000029a);
+		if (frac_rate)
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL1, 0x800cb222);
+		else
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL1, 0x800cb2c0);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x860f30c4);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0c8e0000);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x001fa729);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x01a31500);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		break;
+	case 3450000:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x4000028f);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL1, 0x800cb300);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x860f30c4);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0c8e0000);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x001fa729);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x01a31500);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		break;
+	case 3243240:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x40000287);
+		if (frac_rate)
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL1, 0x800cb000);
+		else
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL1, 0x800cb08a);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x860f30c4);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0c8e0000);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x001fa729);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x01a31500);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		break;
+	case 2970000:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x4000027b);
+		if (frac_rate)
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL1, 0x800cb281);
+		else
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL1, 0x800cb300);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x860f30c4);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0c8e0000);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x001fa729);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x01a31500);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		break;
+	case 4324320:
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL, 0x400002b4);
+		if (frac_rate)
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL1, 0x800cb000);
+		else
+			hd_write_reg(P_HHI_HDMI_PLL_CNTL1, 0x800cb0b8);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL2, 0x860f30c4);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL3, 0x0c8e0000);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL4, 0x001fa729);
+		hd_write_reg(P_HHI_HDMI_PLL_CNTL5, 0x01a31500);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x1, 28, 1);
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL, 0x0, 28, 1);
+		WAIT_FOR_PLL_LOCKED(P_HHI_HDMI_PLL_CNTL);
+		pr_info("HPLL: 0x%x\n", hd_read_reg(P_HHI_HDMI_PLL_CNTL));
+		break;
+	default:
+		pr_info("error hpll clk: %d\n", clk);
+		break;
+	}
+}
+
+void set_hpll_sspll_gxl(enum hdmi_vic vic)
+{
+	switch (vic) {
+	case HDMI_1920x1080p60_16x9:
+	case HDMI_1920x1080p50_16x9:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x68b48c4, 0, 30);
+		break;
+	case HDMI_1280x720p60_16x9:
+	case HDMI_1280x720p50_16x9:
+	case HDMI_1920x1080i60_16x9:
+	case HDMI_1920x1080i50_16x9:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x64348c4, 0, 30);
+		break;
+	case HDMI_3840x2160p50_16x9:
+	case HDMI_3840x2160p60_16x9:
+	case HDMI_4096x2160p50_256x135:
+	case HDMI_4096x2160p60_256x135:
+		break;
+	case HDMI_3840x2160p50_16x9_Y420:
+	case HDMI_3840x2160p60_16x9_Y420:
+	case HDMI_4096x2160p50_256x135_Y420:
+	case HDMI_4096x2160p60_256x135_Y420:
+	case HDMI_3840x2160p30_16x9:
+	case HDMI_3840x2160p25_16x9:
+	case HDMI_3840x2160p24_16x9:
+	case HDMI_4096x2160p30_256x135:
+	case HDMI_4096x2160p25_256x135:
+	case HDMI_4096x2160p24_256x135:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0x62b44c4, 0, 30);
+		break;
+	default:
+		break;
+	}
+}
+
+void set_hpll_od1_gxl(unsigned div)
+{
+	switch (div) {
+	case 1:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0, 21, 2);
+		break;
+	case 2:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 1, 21, 2);
+		break;
+	case 4:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 2, 21, 2);
+		break;
+	default:
+		pr_info("Err %s[%d]\n", __func__, __LINE__);
+		break;
+	}
+}
+
+void set_hpll_od2_gxl(unsigned div)
+{
+	switch (div) {
+	case 1:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0, 23, 2);
+		break;
+	case 2:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 1, 23, 2);
+		break;
+	case 4:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 2, 23, 2);
+		break;
+	default:
+		pr_info("Err %s[%d]\n", __func__, __LINE__);
+		break;
+	}
+}
+
+void set_hpll_od3_gxl(unsigned div)
+{
+	switch (div) {
+	case 1:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 0, 19, 2);
+		break;
+	case 2:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 1, 19, 2);
+		break;
+	case 4:
+		hd_set_reg_bits(P_HHI_HDMI_PLL_CNTL2, 2, 19, 2);
+		break;
+	default:
+		pr_info("Err %s[%d]\n", __func__, __LINE__);
+		break;
+	}
+}
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_gxtvbb.c b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_gxtvbb.c
index cc8bd51..3867f2b 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_gxtvbb.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hw_gxtvbb.c
@@ -2,7 +2,6 @@
 #include <linux/kernel.h>
 #include "common.h"
 #include "mach_reg.h"
-#include "mach_reg_gxtvbb.h"
 
 /*
  * NAME		PAD		PINMUX		GPIO
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/mach_reg.h b/drivers/amlogic/hdmi/hdmi_tx_20/hw/mach_reg.h
index 3e97e81..98b90f3 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/mach_reg.h
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/mach_reg.h
@@ -18,6 +18,7 @@
 #ifndef __MACH_REG_H__
 #define __MACH_REG_H__
 #include <linux/amlogic/iomap.h>
+#include <linux/delay.h>
 
 #define OFFSET	24
 #define CBUS_REG_ADDR(reg)  ((IO_CBUS_BASE << OFFSET) + (reg << 2))
@@ -34,6 +35,24 @@ void sec_reg_write(unsigned *addr, unsigned value);
 unsigned sec_reg_read(unsigned *addr);
 void init_reg_map(void);
 
+#define WAIT_FOR_PLL_LOCKED(reg)				\
+	do {							\
+		unsigned int st = 0, cnt = 10;			\
+		while (cnt--) {                                 \
+			udelay(5);				\
+			st = !!(hd_read_reg(reg) & (1 << 31));	\
+			if (st)					\
+				break;				\
+			else {					\
+				/* reset hpll */		\
+				hd_set_reg_bits(reg, 1, 28, 1);	\
+				hd_set_reg_bits(reg, 0, 28, 1);	\
+			}					\
+		}						\
+		if (cnt < 9)					\
+			pr_info("pll[0x%x] reset %d times\n", reg, 9 - cnt);\
+	} while (0)
+
 #define P_PREG_PAD_GPIO6_EN_N nCBUS_REG_ADDR(0x08)
 #define P_PREG_PAD_GPIO6_O    nCBUS_REG_ADDR(0x09)
 #define P_PREG_PAD_GPIO6_I    nCBUS_REG_ADDR(0x0a)
@@ -299,6 +318,23 @@ void init_reg_map(void);
 #define VENC_DVI_SETTING 0x1b62	/* register.h:8014 */
 #define P_VENC_DVI_SETTING VCBUS_REG_ADDR(VENC_DVI_SETTING)
 
+#define VENC_VIDEO_TST_EN 0x1b70
+#define P_VENC_VIDEO_TST_EN VCBUS_REG_ADDR(VENC_VIDEO_TST_EN)
+#define VENC_VIDEO_TST_MDSEL 0x1b71
+#define P_VENC_VIDEO_TST_MDSEL VCBUS_REG_ADDR(VENC_VIDEO_TST_MDSEL)
+#define VENC_VIDEO_TST_Y 0x1b72
+#define P_VENC_VIDEO_TST_Y VCBUS_REG_ADDR(VENC_VIDEO_TST_Y)
+#define VENC_VIDEO_TST_CB 0x1b73
+#define P_VENC_VIDEO_TST_CB VCBUS_REG_ADDR(VENC_VIDEO_TST_CB)
+#define VENC_VIDEO_TST_CR 0x1b74
+#define P_VENC_VIDEO_TST_CR VCBUS_REG_ADDR(VENC_VIDEO_TST_CR)
+#define VENC_VIDEO_TST_CLRBAR_STRT 0x1b75
+#define P_VENC_VIDEO_TST_CLRBAR_STRT VCBUS_REG_ADDR(VENC_VIDEO_TST_CLRBAR_STRT)
+#define VENC_VIDEO_TST_CLRBAR_WIDTH 0x1b76
+#define P_VENC_VIDEO_TST_CLRBAR_WIDTH \
+		VCBUS_REG_ADDR(VENC_VIDEO_TST_CLRBAR_WIDTH)
+#define VENC_VIDEO_TST_VDCNT_STSET 0x1b77
+#define P_VENC_VIDEO_TST_VDCNT_STSET VCBUS_REG_ADDR(VENC_VIDEO_TST_VDCNT_STSET)
 #define VENC_VDAC_SETTING 0x1b7e
 #define P_VENC_VDAC_SETTING VCBUS_REG_ADDR(VENC_VDAC_SETTING)
 #define ENCP_VIDEO_EN 0x1b80	/* register.h:8078 */
@@ -757,6 +793,9 @@ void init_reg_map(void);
 #define P_VPU_HDMI_DATA_OVR VCBUS_REG_ADDR(VPU_HDMI_DATA_OVR)
 #define VPU_HDMI_FMT_CTRL 0x2743
 #define P_VPU_HDMI_FMT_CTRL VCBUS_REG_ADDR(VPU_HDMI_FMT_CTRL)
+/* For GXM and later */
+#define VPU_HDMI_DITH_CNTL 0x27fc
+#define P_VPU_HDMI_DITH_CNTL VCBUS_REG_ADDR(VPU_HDMI_DITH_CNTL)
 
 /* c_always_on_pointer.h:71 */
 #define AO_RTI_PULL_UP_REG ((0x00 << 10) | (0x0B << 2))
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/tvenc_conf.h b/drivers/amlogic/hdmi/hdmi_tx_20/hw/tvenc_conf.h
index 04f28f5..e384fa1 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/tvenc_conf.h
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/tvenc_conf.h
@@ -18,3 +18,4 @@
 #include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
 
 void set_vmode_enc_hw(enum hdmi_vic vic);
+void set_vmode_3dfp_enc_hw(enum hdmi_vic vic); /* For 3D Frame Packing */
diff --git a/drivers/amlogic/rdma/rdma_mgr.c b/drivers/amlogic/rdma/rdma_mgr.c
index afe39cd..32c952b 100644
--- a/drivers/amlogic/rdma/rdma_mgr.c
+++ b/drivers/amlogic/rdma/rdma_mgr.c
@@ -50,21 +50,21 @@
 #define rdma_io_read(addr) readl(addr)
 #define rdma_io_write(addr, val) writel((val), addr);
 
-#define RDMA_VSYNC_INPUT_TRIG		0x1
-#define SKIP_OSD_CHANNEL
+/* #define SKIP_OSD_CHANNEL */
 
 int rdma_mgr_irq_request;
+int rdma_reset_tigger_flag;
 
 static int debug_flag;
 /* burst size 0=16; 1=24; 2=32; 3=48.*/
 static int ctrl_ahb_rd_burst_size = 3;
 static int ctrl_ahb_wr_burst_size = 3;
-static int rdma_watchdog = 4;
+static int rdma_watchdog = 10;
 static int reset_count;
 static int rdma_watchdog_count;
-static int rdma_vsync_isr_done;
-static int rdma_monitor_reg;
 static int rdma_force_reset = -1;
+static u16 trace_reg;
+
 #define RDMA_NUM 8
 struct rdma_regadr_s {
 	u32 rdma_ahb_start_addr;
@@ -90,6 +90,7 @@ struct rdma_instance_s {
 	u32 *rdma_table_addr;
 	u32 rdma_table_phy_addr;
 	int rdma_item_count;
+	int rdma_write_count;
 	unsigned char keep_buf;
 	unsigned char used;
 	int prev_trigger_type;
@@ -167,44 +168,62 @@ static struct rdma_regadr_s rdma_regadr[RDMA_NUM] = {
 int rdma_register(struct rdma_op_s *rdma_op, void *op_arg, int table_size)
 {
 	int i;
+	unsigned long flags;
 	struct rdma_device_info *info = &rdma_info;
 	dma_addr_t dma_handle;
+	spin_lock_irqsave(&rdma_lock, flags);
 	for (i = 1; i < RDMA_NUM; i++) {
 		/* 0 is reserved for RDMA MANUAL */
 		if (info->rdma_ins[i].op == NULL &&
 				info->rdma_ins[i].used == 0) {
-			info->rdma_ins[i].not_process = 0;
-			info->rdma_ins[i].op_arg = op_arg;
-
-			if (info->rdma_ins[i].rdma_table_size == 0) {
-				info->rdma_ins[i].rdma_table_addr =
-					dma_alloc_coherent(
-					&info->rdma_dev->dev, table_size,
-					&dma_handle, GFP_KERNEL);
-				info->rdma_ins[i].rdma_table_phy_addr
-					= (u32)(dma_handle);
-
-				info->rdma_ins[i].reg_buf =
-					kmalloc(table_size, GFP_KERNEL);
-				pr_info("%s, rdma_table_addr %p rdma_table_addr_phy %x reg_buf %p\n",
-					__func__,
-					info->rdma_ins[i].rdma_table_addr,
-					info->rdma_ins[i].rdma_table_phy_addr,
-					info->rdma_ins[i].reg_buf);
-				info->rdma_ins[i].rdma_table_size = table_size;
-			}
 			info->rdma_ins[i].op = rdma_op;
 			break;
 		}
 	}
+	spin_unlock_irqrestore(&rdma_lock, flags);
 	if (i < RDMA_NUM) {
+		info->rdma_ins[i].not_process = 0;
+		info->rdma_ins[i].op_arg = op_arg;
+		info->rdma_ins[i].rdma_item_count = 0;
+		info->rdma_ins[i].rdma_write_count = 0;
+		if (info->rdma_ins[i].rdma_table_size == 0) {
+			info->rdma_ins[i].rdma_table_addr =
+				dma_alloc_coherent(
+				&info->rdma_dev->dev, table_size,
+				&dma_handle, GFP_KERNEL);
+			info->rdma_ins[i].rdma_table_phy_addr
+				= (u32)(dma_handle);
+			info->rdma_ins[i].reg_buf =
+				kmalloc(table_size, GFP_KERNEL);
+			pr_info("%s, rdma_table_addr %p rdma_table_addr_phy %x reg_buf %p\n",
+				__func__,
+				info->rdma_ins[i].rdma_table_addr,
+				info->rdma_ins[i].rdma_table_phy_addr,
+				info->rdma_ins[i].reg_buf);
+			info->rdma_ins[i].rdma_table_size = table_size;
+		}
+
 		if (info->rdma_ins[i].rdma_table_addr == NULL ||
 			info->rdma_ins[i].reg_buf == NULL) {
+			if (!info->rdma_ins[i].keep_buf) {
+				kfree(info->rdma_ins[i].reg_buf);
+				info->rdma_ins[i].reg_buf = NULL;
+			}
+			if (info->rdma_ins[i].rdma_table_addr) {
+				dma_free_coherent(
+				&info->rdma_dev->dev,
+				table_size,
+				info->rdma_ins[i].rdma_table_addr,
+				(dma_addr_t)
+				info->rdma_ins[i].rdma_table_phy_addr);
+				info->rdma_ins[i].rdma_table_addr = NULL;
+			}
+			info->rdma_ins[i].rdma_table_size  = 0;
 			info->rdma_ins[i].op = NULL;
 			i = -1;
 			pr_info("%s: memory allocate fail\n",
 				__func__);
-		}	else
+		} else
 			pr_info("%s success, handle %d table_size %d\n",
 				__func__, i, table_size);
 		return i;
@@ -213,35 +232,30 @@ int rdma_register(struct rdma_op_s *rdma_op, void *op_arg, int table_size)
 }
 EXPORT_SYMBOL(rdma_register);
 
-
 void rdma_unregister(int i)
 {
 	unsigned long flags;
 	struct rdma_device_info *info = &rdma_info;
 	pr_info("%s(%d)\r\n", __func__, i);
 	if (i > 0 && i < RDMA_NUM && info->rdma_ins[i].op) {
-		int table_size;
-
 		/*rdma_clear(i);*/
-		spin_lock_irqsave(&rdma_lock, flags);
-		table_size = info->rdma_ins[i].rdma_table_size;
-		info->rdma_ins[i].op = NULL;
-		if (!info->rdma_ins[i].keep_buf)
-			info->rdma_ins[i].rdma_table_size = 0;
-		spin_unlock_irqrestore(&rdma_lock, flags);
-
 		info->rdma_ins[i].op_arg = NULL;
 		if (!info->rdma_ins[i].keep_buf) {
 			kfree(info->rdma_ins[i].reg_buf);
 			info->rdma_ins[i].reg_buf = NULL;
-			if (info->rdma_ins[i].rdma_table_addr) {
-				dma_free_coherent(&info->rdma_dev->dev,
-				table_size,
-				info->rdma_ins[i].rdma_table_addr,
-				(dma_addr_t)
-				info->rdma_ins[i].rdma_table_phy_addr);
-			}
 		}
+		if (info->rdma_ins[i].rdma_table_addr) {
+			dma_free_coherent(&info->rdma_dev->dev,
+			info->rdma_ins[i].rdma_table_size,
+			info->rdma_ins[i].rdma_table_addr,
+			(dma_addr_t)
+			info->rdma_ins[i].rdma_table_phy_addr);
+			info->rdma_ins[i].rdma_table_addr = NULL;
+		}
+		info->rdma_ins[i].rdma_table_size = 0;
+		spin_lock_irqsave(&rdma_lock, flags);
+		info->rdma_ins[i].op = NULL;
+		spin_unlock_irqrestore(&rdma_lock, flags);
 	}
 }
 EXPORT_SYMBOL(rdma_unregister);
@@ -251,15 +265,17 @@ static void rdma_reset(unsigned char external_reset)
 		pr_info("%s(%d)\n",
 			__func__, external_reset);
 
-	if (external_reset)	{
-		WRITE_MPEG_REG(RESET4_REGISTER,
-				   (1 << 5));
+	if (external_reset) {
+		WRITE_MPEG_REG(
+			RESET4_REGISTER,
+			(1 << 5));
 	} else {
 		WRITE_VCBUS_REG(RDMA_CTRL, (0x1 << 1));
 		WRITE_VCBUS_REG(RDMA_CTRL, (0x1 << 1));
-		WRITE_VCBUS_REG(RDMA_CTRL, (ctrl_ahb_wr_burst_size << 4) |
+		WRITE_VCBUS_REG(RDMA_CTRL,
+			(ctrl_ahb_wr_burst_size << 4) |
 			(ctrl_ahb_rd_burst_size << 2) |
-			 (0x0 << 1));
+			(0x0 << 1));
 	}
 	reset_count++;
 }
@@ -289,18 +305,15 @@ irqreturn_t rdma_mgr_isr(int irq, void *dev_id)
 		if (i == 3)
 			continue;
 #endif
-		if (ins->prev_trigger_type	== RDMA_VSYNC_INPUT_TRIG) {
-			rdma_vsync_isr_done = 1;
-		}
 		if (rdma_status & (1 << ins->rdma_regadr->irq_status_bitpos)) {
 			if (debug_flag & 2)
 				pr_info("%s: process %d\r\n", __func__, i);
 
-			WRITE_VCBUS_REG(RDMA_CTRL,
-				(1 << ins->rdma_regadr->clear_irq_bitpos));
-
 			if (ins->op && ins->op->irq_cb)
 				ins->op->irq_cb(ins->op->arg);
+
+			WRITE_VCBUS_REG(RDMA_CTRL,
+				(1 << ins->rdma_regadr->clear_irq_bitpos));
 		}
 	}
 	rdma_status = READ_VCBUS_REG(RDMA_STATUS);
@@ -320,7 +333,7 @@ irqreturn_t rdma_mgr_isr(int irq, void *dev_id)
 		0x1~0xff, interrupt input trigger mode
 		0x100, RDMA_TRIGGER_MANUAL
 		> 0x100, debug mode
-
+		0x80000, auto start mode, for osd
 	return:
 		-1, fail
 		0, rdma table is empty, will not have rdma irq
@@ -333,10 +346,14 @@ int rdma_config(int handle, int trigger_type)
 	unsigned long flags;
 	struct rdma_device_info *info = &rdma_info;
 	struct rdma_instance_s *ins = &info->rdma_ins[handle];
+	bool auto_start = false;
 
-	if (handle == 0)
-		pr_info("%s error, rdma_config(handle == 0) not allowed\n",
-			__func__);
+	if (handle == 0 || handle >= RDMA_NUM) {
+		pr_info(
+			"%s error, rdma_config(handle == %d) not allowed\n",
+			__func__, handle);
+		return -1;
+	}
 
 	spin_lock_irqsave(&rdma_lock, flags);
 	if (ins->op == NULL) {
@@ -347,7 +364,35 @@ int rdma_config(int handle, int trigger_type)
 		return -1;
 	}
 
-	if (ins->rdma_item_count <= 0 || trigger_type == 0) {
+	if (trigger_type & RDMA_AUTO_START_MASK)
+		auto_start = true;
+
+	trigger_type &= ~RDMA_AUTO_START_MASK;
+	if (auto_start) {
+		WRITE_VCBUS_REG_BITS(
+			ins->rdma_regadr->trigger_mask_reg,
+			0,
+			ins->rdma_regadr->trigger_mask_reg_bitpos,
+			8);
+
+		WRITE_VCBUS_REG_BITS(
+			ins->rdma_regadr->addr_inc_reg,
+			0,
+			ins->rdma_regadr->addr_inc_reg_bitpos,
+			1);
+		WRITE_VCBUS_REG_BITS(
+			ins->rdma_regadr->rw_flag_reg,
+			1,
+			ins->rdma_regadr->rw_flag_reg_bitpos,
+			1);
+		WRITE_VCBUS_REG_BITS(
+			ins->rdma_regadr->trigger_mask_reg,
+			trigger_type,
+			ins->rdma_regadr->trigger_mask_reg_bitpos,
+			8);
+		ret = 1;
+		ins->rdma_write_count = 0;
+	} else if (ins->rdma_item_count <= 0 || trigger_type == 0) {
 		if (trigger_type == RDMA_TRIGGER_MANUAL)
 			WRITE_VCBUS_REG(RDMA_ACCESS_MAN,
 				READ_VCBUS_REG(RDMA_ACCESS_MAN) & (~1));
@@ -358,13 +403,13 @@ int rdma_config(int handle, int trigger_type)
 		WRITE_VCBUS_REG_BITS(
 			ins->rdma_regadr->trigger_mask_reg,
 			0, ins->rdma_regadr->trigger_mask_reg_bitpos, 8);
-		rdma_vsync_isr_done = 1;
+		ins->rdma_write_count = 0;
 		ret = 0;
 	} else {
 		memcpy(ins->rdma_table_addr, ins->reg_buf,
 			ins->rdma_item_count * 2 * sizeof(u32));
-
 		if (trigger_type > 0 && trigger_type <= RDMA_TRIGGER_MANUAL) {
+			ins->rdma_write_count = ins->rdma_item_count;
 			ins->prev_trigger_type = trigger_type;
 			if (trigger_type == RDMA_TRIGGER_MANUAL) {
 				/*manual RDMA*/
@@ -390,14 +435,15 @@ int rdma_config(int handle, int trigger_type)
 				1,
 				man_ins->rdma_regadr->rw_flag_reg_bitpos,
 				1);
-		/* Manual-start RDMA*/
+				/* Manual-start RDMA*/
 				WRITE_VCBUS_REG(RDMA_ACCESS_MAN,
 					READ_VCBUS_REG(RDMA_ACCESS_MAN) | 1);
 
 				if (debug_flag & 2)
 					pr_info("%s: manual config %d:\r\n",
 					__func__, ins->rdma_item_count);
-			} else { /* interrupt input trigger RDMA */
+			} else {
+				/* interrupt input trigger RDMA */
 				if (debug_flag & 2)
 					pr_info("%s: case 3 : %d:\r\n",
 					__func__ , ins->rdma_item_count);
@@ -441,6 +487,7 @@ int rdma_config(int handle, int trigger_type)
 					ins->rdma_table_addr[i << 1],
 					ins->rdma_table_addr[(i << 1) + 1]);
 			}
+			ins->rdma_write_count = 0;
 		} else if (trigger_type == 0x102) { /* debug mode */
 			int i;
 			for (i = 0; i < ins->rdma_item_count; i++) {
@@ -451,6 +498,7 @@ int rdma_config(int handle, int trigger_type)
 					ins->reg_buf[i << 1],
 					ins->reg_buf[(i << 1) + 1]);
 			}
+			ins->rdma_write_count = 0;
 		}
 		ret = 1;
 	}
@@ -468,17 +516,23 @@ EXPORT_SYMBOL(rdma_config);
 int rdma_clear(int handle)
 {
 	int ret = 0;
+	unsigned long flags;
 	struct rdma_device_info *info = &rdma_info;
 	struct rdma_instance_s *ins = &info->rdma_ins[handle];
-	if (handle == 0 || ins->op == NULL) {
+	spin_lock_irqsave(&rdma_lock, flags);
+	if (handle <= 0 ||
+		handle >= RDMA_NUM ||
+		ins->op == NULL) {
+		spin_unlock_irqrestore(&rdma_lock, flags);
 		pr_info("%s error, handle (%d) not register\n",
 			__func__, handle);
 		return -1;
 	}
-
-	WRITE_VCBUS_REG_BITS(ins->rdma_regadr->trigger_mask_reg,
+	WRITE_VCBUS_REG_BITS(
+		ins->rdma_regadr->trigger_mask_reg,
 		0, ins->rdma_regadr->trigger_mask_reg_bitpos, 8);
-
+	ins->rdma_write_count = 0;
+	spin_unlock_irqrestore(&rdma_lock, flags);
 	return ret;
 }
 EXPORT_SYMBOL(rdma_clear);
@@ -486,6 +540,9 @@ EXPORT_SYMBOL(rdma_clear);
 u32 rdma_read_reg(int handle, u32 adr)
 {
 	int i;
+	u32 *write_table;
+	int match = 0;
+	int read_from = 0;
 	struct rdma_device_info *info = &rdma_info;
 	struct rdma_instance_s *ins = &info->rdma_ins[handle];
 	u32 read_val = READ_VCBUS_REG(adr);
@@ -493,30 +550,72 @@ u32 rdma_read_reg(int handle, u32 adr)
 	for (i = (ins->rdma_item_count - 1) ; i >= 0; i--) {
 		if (ins->reg_buf[i << 1] == adr) {
 			read_val = ins->reg_buf[(i << 1) + 1];
+			match = 1;
+			read_from = 1;
 			break;
 		}
 	}
+	if (!match) {
+		write_table = ins->rdma_table_addr;
+		for (i = (ins->rdma_write_count - 1);
+			i >= 0; i--) {
+			if (write_table[i << 1] == adr) {
+				read_val =
+					write_table[(i << 1) + 1];
+				read_from = 2;
+				break;
+			}
+		}
+	}
+	if (adr == trace_reg) {
+		if (read_from == 2)
+			pr_info("(%s) handle %d, %04x=0x%08x from write table(%d)\n",
+				__func__,
+				handle, adr,
+				read_val,
+				ins->rdma_write_count);
+		else if (read_from == 1)
+			pr_info("(%s) handle %d, %04x=0x%08x from item table(%d)\n",
+				__func__,
+				handle, adr,
+				read_val,
+				ins->rdma_item_count);
+		else
+			pr_info("(%s) handle %d, %04x=0x%08x from real reg\n",
+				__func__,
+				handle, adr,
+				read_val);
+	}
 	return read_val;
 }
 EXPORT_SYMBOL(rdma_read_reg);
 
-
-int rdma_reset_tigger_flag = 0;
 int rdma_watchdog_setting(int flag)
 {
-	if (rdma_vsync_isr_done) {
-		rdma_watchdog_count = 0;
-		rdma_vsync_isr_done = 0;
-	}
+	int ret = 0;
 	if (flag == 0)
 		rdma_watchdog_count = 0;
 	else
 		rdma_watchdog_count++;
+
 	if (debug_flag & 8) {
 		rdma_force_reset = 1;
 		debug_flag = 0;
 	}
-	return 0;
+	if (((rdma_watchdog > 0) &&
+		(rdma_watchdog_count > rdma_watchdog))
+		|| (rdma_force_reset > 0)) {
+		pr_info("%s rdma reset: %d, force flag:%d\n",
+			__func__,
+			rdma_watchdog_count,
+			rdma_force_reset);
+		rdma_watchdog_count = 0;
+		rdma_force_reset = 0;
+		rdma_reset(1);
+		rdma_reset_tigger_flag = 1;
+		ret = 1;
+	}
+	return ret;
 }
 EXPORT_SYMBOL(rdma_watchdog_setting);
 
@@ -545,26 +644,17 @@ int rdma_write_reg(int handle, u32 adr, u32 val)
 			WRITE_VCBUS_REG(ins->reg_buf[i << 1],
 				ins->reg_buf[(i << 1) + 1]);
 		ins->rdma_item_count = 0;
+		ins->rdma_write_count = 0;
 		ins->reg_buf[ins->rdma_item_count << 1] = adr;
 		ins->reg_buf[(ins->rdma_item_count << 1) + 1] = val;
 		ins->rdma_item_count++;
 	}
-	if ((rdma_watchdog > 0) && (rdma_watchdog_count > rdma_watchdog)) {
-		pr_info("%s rdma reset :%d\n",
-		__func__, rdma_watchdog_count);
-		rdma_watchdog_count = 0;
-		rdma_reset(1);
-		rdma_config(handle, ins->prev_trigger_type);
-		rdma_reset_tigger_flag = 1;
-	}
-	if (rdma_force_reset == 1) {
-		rdma_force_reset = 0;
-		rdma_reset_tigger_flag = 1;
-		rdma_watchdog_count = 0;
-		rdma_reset(1);
-		rdma_config(handle, ins->prev_trigger_type);
-		pr_info("%s rdma force reset\n", __func__);
-	}
+	if (adr == trace_reg)
+		pr_info("(%s) handle %d, %04x=0x%08x (%d)\n",
+			__func__,
+			handle, adr,
+			val,
+			ins->rdma_item_count);
 	return 0;
 }
 EXPORT_SYMBOL(rdma_write_reg);
@@ -572,7 +662,9 @@ EXPORT_SYMBOL(rdma_write_reg);
 int rdma_write_reg_bits(int handle, u32 adr, u32 val, u32 start, u32 len)
 {
 	int i;
+	u32 *write_table;
 	int match = 0;
+	int read_from = 0;
 	struct rdma_device_info *info = &rdma_info;
 	struct rdma_instance_s *ins = &info->rdma_ins[handle];
 	u32 read_val = READ_VCBUS_REG(adr);
@@ -585,11 +677,47 @@ int rdma_write_reg_bits(int handle, u32 adr, u32 val, u32 start, u32 len)
 		if (ins->reg_buf[i<<1] == adr) {
 			read_val = ins->reg_buf[(i<<1)+1];
 			match = 1;
+			read_from = 1;
 			break;
 		}
 	}
+	if (!match) {
+		write_table = ins->rdma_table_addr;
+		for (i = (ins->rdma_write_count - 1);
+			i >= 0; i--) {
+			if (write_table[i << 1] == adr) {
+				read_val =
+					write_table[(i << 1) + 1];
+				read_from = 2;
+				break;
+			}
+		}
+	}
 	write_val = (read_val & ~(((1L<<(len))-1)<<(start)))
 		|((unsigned int)(val) << (start));
+
+	if (adr == trace_reg) {
+		if (read_from == 2)
+			pr_info("(%s) handle %d, %04x=0x%08x->0x%08x from write table(%d)\n",
+				__func__,
+				handle, adr,
+				read_val,
+				write_val,
+				ins->rdma_write_count);
+		else if (read_from == 1)
+			pr_info("(%s) handle %d, %04x=0x%08x->0x%08x from item table(%d)\n",
+				__func__,
+				handle, adr,
+				read_val,
+				write_val,
+				ins->rdma_item_count);
+		else
+			pr_info("(%s) handle %d, %04x=0x%08x->0x%08x from real reg\n",
+				__func__,
+				handle, adr,
+				read_val,
+				write_val);
+	}
 	if (match) {
 		ins->reg_buf[(i << 1) + 1] = write_val;
 		return 0;
@@ -612,15 +740,15 @@ module_param(rdma_watchdog, uint, 0664);
 MODULE_PARM_DESC(reset_count, "\n reset_count\n");
 module_param(reset_count, uint, 0664);
 
-MODULE_PARM_DESC(rdma_monitor_reg, "\n rdma_monitor_reg\n");
-module_param(rdma_monitor_reg, uint, 0664);
-
 MODULE_PARM_DESC(ctrl_ahb_rd_burst_size, "\n ctrl_ahb_rd_burst_size\n");
 module_param(ctrl_ahb_rd_burst_size, uint, 0664);
 
 MODULE_PARM_DESC(ctrl_ahb_wr_burst_size, "\n ctrl_ahb_wr_burst_size\n");
 module_param(ctrl_ahb_wr_burst_size, uint, 0664);
 
+MODULE_PARM_DESC(trace_reg, "\n trace_addr\n");
+module_param(trace_reg, ushort, 0664);
+
 /* static int __devinit rdma_probe(struct platform_device *pdev) */
 static int rdma_probe(struct platform_device *pdev)
 {
@@ -632,16 +760,20 @@ static int rdma_probe(struct platform_device *pdev)
 
 	pr_info("%s\n", __func__);
 	rdma_mgr_irq_request = 0;
+	trace_reg = 0;
+
 	for (i = 0; i < RDMA_NUM; i++) {
-			info->rdma_ins[i].rdma_table_size = 0;
-			info->rdma_ins[i].rdma_regadr = &rdma_regadr[i];
-			info->rdma_ins[i].keep_buf = 1;
-			/*do not change it in normal case*/
-			info->rdma_ins[i].used = 0;
+		info->rdma_ins[i].rdma_table_size = 0;
+		info->rdma_ins[i].rdma_regadr = &rdma_regadr[i];
+		info->rdma_ins[i].keep_buf = 1;
+		/*do not change it in normal case*/
+		info->rdma_ins[i].used = 0;
+		info->rdma_ins[i].prev_trigger_type = 0;
+		info->rdma_ins[i].rdma_write_count = 0;
 	}
 	WRITE_MPEG_REG(RESET4_REGISTER,
 				   (1 << 5));
-#if 1
+#ifdef SKIP_OSD_CHANNEL
 	info->rdma_ins[3].used = 1; /* OSD driver uses this channel */
 #endif
 	if (int_rdma  == -ENXIO) {
@@ -656,7 +788,8 @@ static int rdma_probe(struct platform_device *pdev)
 
 	rdma_mgr_irq_request = 1;
 	data32  = 0;
-	data32 |= 0 << 6;
+	data32 |= 1 << 7; /* wrtie ddr urgent */
+	data32 |= 1 << 6; /* read ddr urgent */
 	data32 |= ctrl_ahb_wr_burst_size << 4;
 	data32 |= ctrl_ahb_rd_burst_size << 2;
 	data32 |= 0 << 1;
diff --git a/drivers/amlogic/vfm/vfm.c b/drivers/amlogic/vfm/vfm.c
index 55f066b..53384c4 100644
--- a/drivers/amlogic/vfm/vfm.c
+++ b/drivers/amlogic/vfm/vfm.c
@@ -126,7 +126,7 @@ static int vfm_map_remove_by_index(int index)
 	return ret;
 }
 
-static int vfm_map_remove(char *id)
+int vfm_map_remove(char *id)
 {
 	int i;
 	int index;
@@ -144,7 +144,7 @@ static int vfm_map_remove(char *id)
 	return ret;
 }
 
-static int vfm_map_add(char *id, char *name_chain)
+int vfm_map_add(char *id, char *name_chain)
 {
 	int i, j;
 	int ret = -1;
@@ -230,6 +230,7 @@ static char *vf_get_receiver_name_inmap(int i, const char *provider_name)
 {
 	int j;
 	int provide_namelen = strlen(provider_name);
+	bool found = false;
 	char *receiver_name = NULL;
 	int namelen;
 
@@ -239,16 +240,25 @@ static char *vf_get_receiver_name_inmap(int i, const char *provider_name)
 			pr_err("%s:vfm_map:%s\n", __func__,
 				vfm_map[i]->name[j]);
 		}
-		if (!strncmp(vfm_map[i]->name[j], provider_name, namelen)) {
-			if ((namelen == provide_namelen) ||
-			    (provider_name[namelen] == '.')) {
-				if ((j + 1) < vfm_map[i]->vfm_map_size) {
-					receiver_name =
-					vfm_map[i]->name[j + 1];
-				}
+		if ((!strncmp(vfm_map[i]->name[j], provider_name, namelen)) &&
+			((j + 1) < vfm_map[i]->vfm_map_size)) {
+			receiver_name = vfm_map[i]->name[j + 1];
+
+			if (namelen == provide_namelen) {
+				/* exact match */
+				receiver_name = vfm_map[i]->name[j + 1];
+				found = true;
 				break;
+			} else if (provider_name[namelen] == '.') {
+				/* continue looking, an exact matching
+				 * has higher priority
+				 */
+				receiver_name = vfm_map[i]->name[j + 1];
 			}
 		}
+
+		if (found)
+			break;
 	}
 	return receiver_name;
 }
@@ -272,7 +282,11 @@ static void vfm_init(void)
 {
 #if (defined CONFIG_POST_PROCESS_MANAGER) && (defined CONFIG_DEINTERLACE)
 	char def_id[] = "default";
+#ifndef CONFIG_MULTI_DEC
 	char def_name_chain[] = "decoder ppmgr deinterlace amvideo";
+#else
+	char def_name_chain[] = "decoder amvideo";
+#endif
 #elif (defined CONFIG_POST_PROCESS_MANAGER)
 	char def_id[] = "default";
 	char def_name_chain[] = "decoder ppmgr amvideo";
@@ -305,9 +319,6 @@ static void vfm_init(void)
 				 */
 #endif				/*
 				 */
-	char def_osd_id[] = "default_osd";
-	char def_osd_name_chain[] = "osd amvideo4osd";
-	/* char def_osd_name_chain[] = "osd amvideo"; */
 #ifdef CONFIG_VDIN_MIPI
 	char def_mipi_id[] = "default_mipi";
 	char def_mipi_name_chain[] = "vdin mipi";
@@ -315,7 +326,7 @@ static void vfm_init(void)
 				 */
 #ifdef CONFIG_V4L_AMLOGIC_VIDEO2
 	char def_amlvideo2_id[] = "default_amlvideo2";
-	char def_amlvideo2_chain[] = "vdin1 amlvideo2_1";
+	char def_amlvideo2_chain[] = "vdin1 amlvideo2.1";
 #endif				/*
 				 */
 #if (defined CONFIG_TVIN_AFE) || (defined CONFIG_TVIN_HDMI)
@@ -328,10 +339,18 @@ static void vfm_init(void)
 #endif
 #endif				/*
 				 */
+#ifdef CONFIG_AM_VDEC_DV
+	char def_dvbl_id[] = "dvblpath";
+/*	char def_dvbl_chain[] = "dvbldec dvbl amvideo";*/
+	char def_dvbl_chain[] = "dvbldec amvideo";
+
+	char def_dvel_id[] = "dvelpath";
+	char def_dvel_chain[] = "dveldec dvel";
+#endif
+
 	int i;
 	for (i = 0; i < VFM_MAP_COUNT; i++)
 		vfm_map[i] = NULL;
-	vfm_map_add(def_osd_id, def_osd_name_chain);
 	vfm_map_add(def_id, def_name_chain);
 #ifdef CONFIG_VDIN_MIPI
 	vfm_map_add(def_mipi_id, def_mipi_name_chain);
@@ -350,6 +369,10 @@ static void vfm_init(void)
 	vfm_map_add(def_amlvideo2_id, def_amlvideo2_chain);
 #endif				/*
 				 */
+#ifdef CONFIG_AM_VDEC_DV
+	vfm_map_add(def_dvbl_id, def_dvbl_chain);
+	vfm_map_add(def_dvel_id, def_dvel_chain);
+#endif
 }
 
 /*
@@ -428,18 +451,26 @@ static void vfm_dump_provider(const char *name)
 				HZ);
 			pr_info("vf index=%d\n", vf->index);
 			pr_info("vf->pts=%d\n", vf->pts);
-			pr_info("vf canvas0Addr=%x\n", vf->canvas0Addr);
-			pr_info("vf canvas1Addr=%x\n", vf->canvas1Addr);
-			pr_info("vf canvas0Addr.y.addr=%x(%d)\n",
-				canvas_get_addr(
-				canvasY(vf->canvas0Addr)),
-				canvas_get_addr(
-				canvasY(vf->canvas0Addr)));
-			pr_info("vf canvas0Adr.uv.adr=%x(%d)\n",
-				canvas_get_addr(
-				canvasUV(vf->canvas0Addr)),
-				canvas_get_addr(
-				canvasUV(vf->canvas0Addr)));
+			pr_info("vf->type=%d\n", vf->type);
+			if (vf->type & VIDTYPE_COMPRESS) {
+				pr_info("vf compHeadAddr=%x\n",
+						vf->compHeadAddr);
+				pr_info("vf compBodyAddr =%x\n",
+						vf->compBodyAddr);
+			} else {
+				pr_info("vf canvas0Addr=%x\n", vf->canvas0Addr);
+				pr_info("vf canvas1Addr=%x\n", vf->canvas1Addr);
+				pr_info("vf canvas0Addr.y.addr=%x(%d)\n",
+					canvas_get_addr(
+					canvasY(vf->canvas0Addr)),
+					canvas_get_addr(
+					canvasY(vf->canvas0Addr)));
+				pr_info("vf canvas0Adr.uv.adr=%x(%d)\n",
+					canvas_get_addr(
+					canvasUV(vf->canvas0Addr)),
+					canvas_get_addr(
+					canvasUV(vf->canvas0Addr)));
+			}
 		}
 		spin_unlock_irqrestore(&lock, flags);
 	}
@@ -450,12 +481,66 @@ static void vfm_dump_provider(const char *name)
 #define VFM_CMD_ADD 1
 #define VFM_CMD_RM  2
 #define VFM_CMD_DUMP  3
+#define VFM_CMD_ADDDUMMY 4
+
+/*
+    dummy receiver
+*/
+
+static int dummy_receiver_event_fun(int type, void *data, void *arg)
+{
+	struct vframe_receiver_s *dummy_vf_recv
+		= (struct vframe_receiver_s *)arg;
+	if (type == VFRAME_EVENT_PROVIDER_UNREG) {
+		char *provider_name = (char *)data;
+		pr_info("%s, provider %s unregistered\n",
+			__func__, provider_name);
+	} else if (type ==
+		VFRAME_EVENT_PROVIDER_VFRAME_READY) {
+		struct vframe_s *vframe_tmp = vf_get(dummy_vf_recv->name);
+		while (vframe_tmp) {
+			vf_put(vframe_tmp, dummy_vf_recv->name);
+			vf_notify_provider(dummy_vf_recv->name,
+				VFRAME_EVENT_RECEIVER_PUT, NULL);
+			vframe_tmp = vf_get(dummy_vf_recv->name);
+		}
+	} else if (type == VFRAME_EVENT_PROVIDER_QUREY_STATE) {
+		return RECEIVER_ACTIVE;
+	} else if (type == VFRAME_EVENT_PROVIDER_REG) {
+		char *provider_name = (char *)data;
+		pr_info("%s, provider %s registered\n",
+			__func__, provider_name);
+	}
+	return 0;
+}
+
+static const struct vframe_receiver_op_s dummy_vf_receiver = {
+	.event_cb = dummy_receiver_event_fun
+};
+
+static void add_dummy_receiver(char *vfm_name_)
+{
+	struct vframe_receiver_s *dummy_vf_recv =
+	 kmalloc(sizeof(struct vframe_receiver_s), GFP_KERNEL);
+	pr_info("%s(%s)\n", __func__, vfm_name_);
+	if (dummy_vf_recv) {
+		char *vfm_name = kmalloc(16, GFP_KERNEL);
+		snprintf(vfm_name, 16, "%s", vfm_name_);
+		vf_receiver_init(dummy_vf_recv, vfm_name,
+			&dummy_vf_receiver, dummy_vf_recv);
+		vf_reg_receiver(dummy_vf_recv);
+		pr_info("%s: %s\n", __func__, dummy_vf_recv->name);
+	}
+}
+
+/**/
 
 /*
  * echo add <name> <node1 node2 ...> > /sys/class/vfm/map
  * echo rm <name>                    > /sys/class/vfm/map
  * echo rm all                       > /sys/class/vfm/map
  * echo dump providername			> /sys/class/vfm/map
+ * echo dummy name > /sys/class/vfm/map
  * <name> the name of the path.
  * <node1 node2 ...> the name of the nodes in the path.
 */
@@ -467,7 +552,11 @@ static ssize_t vfm_map_store(struct class *class,
 	int i = 0;
 	int cmd = 0;
 	char *id = NULL;
+#ifdef CONFIG_MULTI_DEC
+	if (strncmp(buf, "dummy", 5))
+#else
 	if (vfm_debug_flag & 0x10000)
+#endif
 		return count;
 	pr_err("%s:%s\n", __func__, buf);
 	buf_orig = kstrdup(buf, GFP_KERNEL);
@@ -485,6 +574,8 @@ static ssize_t vfm_map_store(struct class *class,
 				cmd = VFM_CMD_RM;
 			else if (!strcmp(token, "dump"))
 				cmd = VFM_CMD_DUMP;
+			else if (!strcmp(token, "dummy"))
+				cmd = VFM_CMD_ADDDUMMY;
 			else
 				break;
 		} else if (i == 1) {
@@ -498,6 +589,8 @@ static ssize_t vfm_map_store(struct class *class,
 					count = 0;
 			} else if (cmd == VFM_CMD_DUMP) {
 				vfm_dump_provider(token);
+			} else if (cmd == VFM_CMD_ADDDUMMY) {
+				add_dummy_receiver(token);
 			}
 			break;
 		}
diff --git a/drivers/amlogic/vfm/vfm.h b/drivers/amlogic/vfm/vfm.h
index ee85619..61f7472 100644
--- a/drivers/amlogic/vfm/vfm.h
+++ b/drivers/amlogic/vfm/vfm.h
@@ -19,6 +19,10 @@
 #ifndef __AML_VFM_H
 #define __AML_VFM_H
 
+extern int vfm_map_add(char *id, char *name_chain);
+
+extern int vfm_map_remove(char *id);
+
 char *vf_get_provider_name(const char *receiver_name);
 
 char *vf_get_receiver_name(const char *provider_name);
diff --git a/drivers/amlogic/vfm/vframe_provider.c b/drivers/amlogic/vfm/vframe_provider.c
index e962878..d49ea7b 100644
--- a/drivers/amlogic/vfm/vframe_provider.c
+++ b/drivers/amlogic/vfm/vframe_provider.c
@@ -61,7 +61,8 @@ struct vframe_provider_s *vf_get_provider_by_name(const char *provider_name)
 		int namelen = strlen(provider_name);
 		for (i = 0; i < MAX_PROVIDER_NUM; i++) {
 			p = provider_table[i];
-			if (p && !strncmp(p->name, provider_name, namelen)) {
+			if (p && p->name && !strncmp(p->name,
+					provider_name, namelen)) {
 				if (strlen(p->name) == namelen
 					|| p->name[namelen] == '.')
 					break;
@@ -101,6 +102,26 @@ int vf_notify_provider(const char *receiver_name, int event_type, void *data)
 }
 EXPORT_SYMBOL(vf_notify_provider);
 
+int vf_notify_provider_by_name(const char *provider_name, int event_type,
+							   void *data)
+{
+	int ret = -1;
+	struct vframe_provider_s *provider =
+		vf_get_provider_by_name(provider_name);
+	if (provider) {
+		if (provider->ops && provider->ops->event_cb) {
+			provider->ops->event_cb(event_type, data,
+				provider->op_arg);
+			ret = 0;
+		}
+	} else{
+		/* pr_err("Error: %s, fail to get provider of receiver %s\n",
+				__func__, receiver_name); */
+	}
+	return ret;
+}
+EXPORT_SYMBOL(vf_notify_provider_by_name);
+
 void vf_provider_init(struct vframe_provider_s *prov,
 		const char *name,
 		const struct vframe_operations_s *ops, void *op_arg)
diff --git a/drivers/amlogic/vfm/vframe_receiver.c b/drivers/amlogic/vfm/vframe_receiver.c
index 74e77d6..79233db 100644
--- a/drivers/amlogic/vfm/vframe_receiver.c
+++ b/drivers/amlogic/vfm/vframe_receiver.c
@@ -29,7 +29,7 @@
 /* Local headers */
 #include "vfm.h"
 
-#define MAX_RECEIVER_NUM    8
+#define MAX_RECEIVER_NUM    16
 struct vframe_receiver_s *receiver_table[MAX_RECEIVER_NUM];
 
 int receiver_list(char *buf)
diff --git a/drivers/amlogic/vpu/Makefile b/drivers/amlogic/vpu/Makefile
index fae0ee5..a4e0fb6 100644
--- a/drivers/amlogic/vpu/Makefile
+++ b/drivers/amlogic/vpu/Makefile
@@ -1,2 +1,2 @@
-obj-$(CONFIG_AML_VPU)	+= vpu.o
+obj-$(CONFIG_AML_VPU)	+= vpu.o vpu_ctrl.o vpu_reg.o
 
diff --git a/drivers/amlogic/vpu/vpu.c b/drivers/amlogic/vpu/vpu.c
index 2c389e5..f21859a 100644
--- a/drivers/amlogic/vpu/vpu.c
+++ b/drivers/amlogic/vpu/vpu.c
@@ -29,12 +29,15 @@
 #include <linux/amlogic/vout/vinfo.h>
 #include "vpu_reg.h"
 #include "vpu.h"
+#include "vpu_clk.h"
+#include "vpu_module.h"
 
-#define VPU_VERION        "v02"
+/* v03: add vpu clk gate control */
+#define VPU_VERION        "v03"
 
-static int vpu_debug_print_flag;
+enum vpu_chip_e vpu_chip_type;
+int vpu_debug_print_flag;
 static spinlock_t vpu_lock;
-static spinlock_t vpu_mem_lock;
 static DEFINE_MUTEX(vpu_mutex);
 
 static unsigned int clk_vmod[VPU_MAX];
@@ -48,7 +51,7 @@ static struct vpu_conf_s vpu_conf = {
 	.fclk_type = 0,
 };
 
-static int vpu_chip_valid_check(void)
+int vpu_chip_valid_check(void)
 {
 	int ret = 0;
 
@@ -130,7 +133,7 @@ static void vpu_chip_detect(void)
 		VPUPR("detect chip type: %d\n", vpu_chip_type);
 }
 
-static enum vpu_mod_e get_vpu_mod(unsigned int vmod)
+enum vpu_mod_e get_vpu_mod(unsigned int vmod)
 {
 	/* for lcd_tv & hdmi use the same display mode, we can't recognized
 	the right vpu_vmod here, so we bypass this function */
@@ -642,371 +645,6 @@ int release_vpu_clk_vmod(unsigned int vmod)
 }
 
 /* *********************************************** */
-/* VPU_MEM_PD control */
-/* *********************************************** */
-/*
- *  Function: switch_vpu_mem_pd_vmod
- *      switch vpu memory power down by specified vmod
- *
- *  Parameters:
- *      vmod - unsigned int, must be the following constants:
- *                 VPU_MOD, supported by vpu_mod_e
- *      flag - int, on/off switch flag, must be one of the following constants:
- *                 VPU_MEM_POWER_ON
- *                 VPU_MEM_POWER_DOWN
- *
- *  Example:
- *      switch_vpu_mem_pd_vmod(VPU_VENCP, VPU_MEM_POWER_ON);
- *      switch_vpu_mem_pd_vmod(VPU_VIU_OSD1, VPU_MEM_POWER_DOWN);
- *
-*/
-void switch_vpu_mem_pd_vmod(unsigned int vmod, int flag)
-{
-	unsigned vpu_mod;
-	unsigned long flags = 0;
-	unsigned int _reg0, _reg1, _reg2;
-	unsigned int val;
-	int ret = 0;
-
-	ret = vpu_chip_valid_check();
-	if (ret)
-		return;
-
-	spin_lock_irqsave(&vpu_mem_lock, flags);
-
-	val = (flag == VPU_MEM_POWER_ON) ? 0 : 3;
-	switch (vpu_chip_type) {
-	case VPU_CHIP_M8:
-	case VPU_CHIP_M8B:
-	case VPU_CHIP_M8M2:
-	case VPU_CHIP_G9TV:
-	case VPU_CHIP_G9BB:
-		_reg0 = HHI_VPU_MEM_PD_REG0;
-		_reg1 = HHI_VPU_MEM_PD_REG1;
-		_reg2 = 0;
-		break;
-	default:
-		_reg0 = HHI_VPU_MEM_PD_REG0_GX;
-		_reg1 = HHI_VPU_MEM_PD_REG1_GX;
-		_reg2 = HHI_VPU_MEM_PD_REG2_GX;
-		break;
-	}
-
-	vpu_mod = get_vpu_mod(vmod);
-	switch (vpu_mod) {
-	case VPU_VIU_OSD1:
-		vpu_hiu_setb(_reg0, val, 0, 2);
-		break;
-	case VPU_VIU_OSD2:
-		vpu_hiu_setb(_reg0, val, 2, 2);
-		break;
-	case VPU_VIU_VD1:
-		vpu_hiu_setb(_reg0, val, 4, 2);
-		break;
-	case VPU_VIU_VD2:
-		vpu_hiu_setb(_reg0, val, 6, 2);
-		break;
-	case VPU_VIU_CHROMA:
-		vpu_hiu_setb(_reg0, val, 8, 2);
-		break;
-	case VPU_VIU_OFIFO:
-		vpu_hiu_setb(_reg0, val, 10, 2);
-		break;
-	case VPU_VIU_SCALE:
-		vpu_hiu_setb(_reg0, val, 12, 2);
-		break;
-	case VPU_VIU_OSD_SCALE:
-		vpu_hiu_setb(_reg0, val, 14, 2);
-		break;
-	case VPU_VIU_VDIN0:
-		vpu_hiu_setb(_reg0, val, 16, 2);
-		break;
-	case VPU_VIU_VDIN1:
-		vpu_hiu_setb(_reg0, val, 18, 2);
-		break;
-	case VPU_PIC_ROT1:
-	case VPU_VIU_SRSCL:
-		vpu_hiu_setb(_reg0, val, 20, 2);
-		break;
-	case VPU_PIC_ROT2:
-	case VPU_VIU_OSDSR:
-	case VPU_AFBC_DEC1:
-		vpu_hiu_setb(_reg0, val, 22, 2);
-		break;
-	case VPU_PIC_ROT3:
-		vpu_hiu_setb(_reg0, val, 24, 2);
-		break;
-	case VPU_DI_PRE:
-		vpu_hiu_setb(_reg0, val, 26, 2);
-		break;
-	case VPU_DI_POST:
-		vpu_hiu_setb(_reg0, val, 28, 2);
-		break;
-	case VPU_SHARP:
-		vpu_hiu_setb(_reg0, val, 30, 2);
-		break;
-	case VPU_VIU2_OSD1:
-		vpu_hiu_setb(_reg1, val, 0, 2);
-		break;
-	case VPU_VIU2_OSD2:
-		vpu_hiu_setb(_reg1, val, 2, 2);
-		break;
-	case VPU_D2D3:
-		if (vpu_chip_type == VPU_CHIP_G9TV)
-			vpu_hiu_setb(_reg1, ((val << 2) | val), 0, 4);
-		break;
-	case VPU_VIU2_VD1:
-		vpu_hiu_setb(_reg1, val, 4, 2);
-		break;
-	case VPU_VIU2_CHROMA:
-		vpu_hiu_setb(_reg1, val, 6, 2);
-		break;
-	case VPU_VIU2_OFIFO:
-		vpu_hiu_setb(_reg1, val, 8, 2);
-		break;
-	case VPU_VIU2_SCALE:
-		vpu_hiu_setb(_reg1, val, 10, 2);
-		break;
-	case VPU_VIU2_OSD_SCALE:
-		vpu_hiu_setb(_reg1, val, 12, 2);
-		break;
-	case VPU_VDIN_AM_ASYNC:
-	case VPU_VPU_ARB:
-		vpu_hiu_setb(_reg1, val, 14, 2);
-		break;
-	case VPU_VDISP_AM_ASYNC:
-	case VPU_AFBC_DEC:
-	case VPU_OSD1_AFBCD:
-	case VPU_AFBC_DEC0:
-		vpu_hiu_setb(_reg1, val, 16, 2);
-		break;
-	case VPU_VPUARB2_AM_ASYNC:
-		if (vpu_chip_type == VPU_CHIP_G9TV)
-			vpu_hiu_setb(_reg1, val, 18, 2);
-		break;
-	case VPU_VENCP:
-		vpu_hiu_setb(_reg1, val, 20, 2);
-		break;
-	case VPU_VENCL:
-		vpu_hiu_setb(_reg1, val, 22, 2);
-		break;
-	case VPU_VENCI:
-		vpu_hiu_setb(_reg1, val, 24, 2);
-		break;
-	case VPU_ISP:
-		vpu_hiu_setb(_reg1, val, 26, 2);
-		break;
-	case VPU_CVD2:
-	case VPU_LDIM_STTS:
-		vpu_hiu_setb(_reg1, val, 28, 2);
-		break;
-	case VPU_ATV_DMD:
-	case VPU_XVYCC_LUT:
-		vpu_hiu_setb(_reg1, val, 30, 2);
-		break;
-	case VPU_VIU1_WM:
-		if ((vpu_chip_type == VPU_CHIP_GXL) ||
-			(vpu_chip_type == VPU_CHIP_GXM) ||
-			(vpu_chip_type == VPU_CHIP_TXL)) {
-			vpu_hiu_setb(_reg2, val, 0, 2);
-		}
-		break;
-	default:
-		VPUPR("switch_vpu_mem_pd: unsupport vpu mod\n");
-		break;
-	}
-
-	if (vpu_debug_print_flag) {
-		VPUPR("switch_vpu_mem_pd: %s %s\n",
-			vpu_mod_table[vpu_mod], ((flag > 0) ? "OFF" : "ON"));
-		dump_stack();
-	}
-	spin_unlock_irqrestore(&vpu_mem_lock, flags);
-}
-
-/*
- *  Function: get_vpu_mem_pd_vmod
- *      switch vpu memory power down by specified vmod
- *
- *  Parameters:
- *      vmod - unsigned int, must be the following constants:
- *                 VPU_MOD, supported by vpu_mod_e
- *
- *  Returns:
- *      int, 0 for power on, 1 for power down, -1 for error
- *
- *  Example:
- *      ret = get_vpu_mem_pd_vmod(VPU_VENCP);
- *      ret = get_vpu_mem_pd_vmod(VPU_VIU_OSD1);
- *
-*/
-#define VPU_MEM_PD_ERR        0xffff
-int get_vpu_mem_pd_vmod(unsigned int vmod)
-{
-	unsigned int vpu_mod;
-	unsigned int _reg0, _reg1, _reg2;
-	unsigned int val;
-	int ret = 0;
-
-	ret = vpu_chip_valid_check();
-	if (ret)
-		return -1;
-
-	switch (vpu_chip_type) {
-	case VPU_CHIP_M8:
-	case VPU_CHIP_M8B:
-	case VPU_CHIP_M8M2:
-	case VPU_CHIP_G9TV:
-	case VPU_CHIP_G9BB:
-		_reg0 = HHI_VPU_MEM_PD_REG0;
-		_reg1 = HHI_VPU_MEM_PD_REG1;
-		_reg2 = 0;
-		break;
-	default:
-		_reg0 = HHI_VPU_MEM_PD_REG0_GX;
-		_reg1 = HHI_VPU_MEM_PD_REG1_GX;
-		_reg2 = HHI_VPU_MEM_PD_REG2_GX;
-		break;
-	}
-
-	vpu_mod = get_vpu_mod(vmod);
-	switch (vpu_mod) {
-	case VPU_VIU_OSD1:
-		val = vpu_hiu_getb(_reg0, 0, 2);
-		break;
-	case VPU_VIU_OSD2:
-		val = vpu_hiu_getb(_reg0, 2, 2);
-		break;
-	case VPU_VIU_VD1:
-		val = vpu_hiu_getb(_reg0, 4, 2);
-		break;
-	case VPU_VIU_VD2:
-		val = vpu_hiu_getb(_reg0, 6, 2);
-		break;
-	case VPU_VIU_CHROMA:
-		val = vpu_hiu_getb(_reg0, 8, 2);
-		break;
-	case VPU_VIU_OFIFO:
-		val = vpu_hiu_getb(_reg0, 10, 2);
-		break;
-	case VPU_VIU_SCALE:
-		val = vpu_hiu_getb(_reg0, 12, 2);
-		break;
-	case VPU_VIU_OSD_SCALE:
-		val = vpu_hiu_getb(_reg0, 14, 2);
-		break;
-	case VPU_VIU_VDIN0:
-		val = vpu_hiu_getb(_reg0, 16, 2);
-		break;
-	case VPU_VIU_VDIN1:
-		val = vpu_hiu_getb(_reg0, 18, 2);
-		break;
-	case VPU_PIC_ROT1:
-	case VPU_VIU_SRSCL:
-		val = vpu_hiu_getb(_reg0, 20, 2);
-		break;
-	case VPU_PIC_ROT2:
-	case VPU_VIU_OSDSR:
-	case VPU_AFBC_DEC1:
-		val = vpu_hiu_getb(_reg0, 22, 2);
-		break;
-	case VPU_PIC_ROT3:
-		val = vpu_hiu_getb(_reg0, 24, 2);
-		break;
-	case VPU_DI_PRE:
-		val = vpu_hiu_getb(_reg0, 26, 2);
-		break;
-	case VPU_DI_POST:
-		val = vpu_hiu_getb(_reg0, 28, 2);
-		break;
-	case VPU_SHARP:
-		val = vpu_hiu_getb(_reg0, 30, 2);
-		break;
-	case VPU_VIU2_OSD1:
-		val = vpu_hiu_getb(_reg1, 0, 2);
-		break;
-	case VPU_VIU2_OSD2:
-		val = vpu_hiu_getb(_reg1, 2, 2);
-		break;
-	case VPU_D2D3:
-		if (vpu_chip_type == VPU_CHIP_G9TV)
-			val = vpu_hiu_getb(_reg1, 0, 4);
-		else
-			val = VPU_MEM_PD_ERR;
-		break;
-	case VPU_VIU2_VD1:
-		val = vpu_hiu_getb(_reg1, 4, 2);
-		break;
-	case VPU_VIU2_CHROMA:
-		val = vpu_hiu_getb(_reg1, 6, 2);
-		break;
-	case VPU_VIU2_OFIFO:
-		val = vpu_hiu_getb(_reg1, 8, 2);
-		break;
-	case VPU_VIU2_SCALE:
-		val = vpu_hiu_getb(_reg1, 10, 2);
-		break;
-	case VPU_VIU2_OSD_SCALE:
-		val = vpu_hiu_getb(_reg1, 12, 2);
-		break;
-	case VPU_VDIN_AM_ASYNC:
-	case VPU_VPU_ARB:
-		val = vpu_hiu_getb(_reg1, 14, 2);
-		break;
-	case VPU_VDISP_AM_ASYNC:
-	case VPU_AFBC_DEC:
-	case VPU_OSD1_AFBCD:
-	case VPU_AFBC_DEC0:
-		val = vpu_hiu_getb(_reg1, 16, 2);
-		break;
-	case VPU_VPUARB2_AM_ASYNC:
-		if (vpu_chip_type == VPU_CHIP_G9TV)
-			val = vpu_hiu_getb(_reg0, 18, 2);
-		else
-			val = VPU_MEM_PD_ERR;
-		break;
-	case VPU_VENCP:
-		val = vpu_hiu_getb(_reg1, 20, 2);
-		break;
-	case VPU_VENCL:
-		val = vpu_hiu_getb(_reg1, 22, 2);
-		break;
-	case VPU_VENCI:
-		val = vpu_hiu_getb(_reg1, 24, 2);
-		break;
-	case VPU_ISP:
-		val = vpu_hiu_getb(_reg1, 26, 2);
-		break;
-	case VPU_CVD2:
-	case VPU_LDIM_STTS:
-		val = vpu_hiu_getb(_reg1, 28, 2);
-		break;
-	case VPU_ATV_DMD:
-	case VPU_XVYCC_LUT:
-		val = vpu_hiu_getb(_reg1, 30, 2);
-		break;
-	case VPU_VIU1_WM:
-		if ((vpu_chip_type == VPU_CHIP_GXL) ||
-			(vpu_chip_type == VPU_CHIP_GXM) ||
-			(vpu_chip_type == VPU_CHIP_TXL)) {
-			val = vpu_hiu_getb(_reg2, 0, 2);
-		} else {
-			val = VPU_MEM_PD_ERR;
-		}
-		break;
-	default:
-		val = VPU_MEM_PD_ERR;
-		break;
-	}
-
-	if (val == 0)
-		return VPU_MEM_POWER_ON;
-	else if ((val == 0x3) || (val == 0xf))
-		return VPU_MEM_POWER_DOWN;
-	else
-		return -1;
-}
-/* *********************************************** */
 
 /* *********************************************** */
 /* VPU sysfs function */
@@ -1014,8 +652,12 @@ int get_vpu_mem_pd_vmod(unsigned int vmod)
 static const char *vpu_usage_str = {
 "Usage:\n"
 "	echo r > mem ; read vpu memory power down status\n"
-"	echo w <vmod> <mpd> > mem ; write vpu memory power down\n"
-"	<mpd>: 0=power up, 1=power down\n"
+"	echo w <vmod> <flag> > mem ; write vpu memory power down\n"
+"	<flag>: 0=power up, 1=power down\n"
+"\n"
+"	echo r > gate ; read vpu clk gate status\n"
+"	echo w <vmod> <flag> > gate ; write vpu clk gate\n"
+"	<flag>: 0=gate off, 1=gate on\n"
 "\n"
 "	echo 1 > test ; run vcbus access test\n"
 "\n"
@@ -1105,7 +747,7 @@ static ssize_t vpu_mem_debug(struct class *class, struct class_attribute *attr,
 				const char *buf, size_t count)
 {
 	unsigned int ret;
-	unsigned int tmp[2], temp;
+	unsigned int tmp[2];
 	unsigned int _reg0, _reg1, _reg2;
 
 	switch (vpu_chip_type) {
@@ -1136,8 +778,11 @@ static ssize_t vpu_mem_debug(struct class *class, struct class_attribute *attr,
 		break;
 	case 'w':
 		ret = sscanf(buf, "w %u %u", &tmp[0], &tmp[1]);
-		temp = (tmp[1] > 0) ? VPU_MEM_POWER_DOWN : VPU_MEM_POWER_ON;
-		switch_vpu_mem_pd_vmod(tmp[0], temp);
+		tmp[0] = (tmp[0] > VPU_MAX) ? VPU_MAX : tmp[0];
+		tmp[1] = (tmp[1] == VPU_MEM_POWER_ON) ? 0 : 1;
+		VPUPR("switch_vpu_mem_pd: %s %s\n",
+			vpu_mod_table[tmp[0]], (tmp[1] ? "DOWN" : "ON"));
+		switch_vpu_mem_pd_vmod(tmp[0], tmp[1]);
 		break;
 	default:
 		VPUERR("wrong mem_pd command\n");
@@ -1151,6 +796,61 @@ static ssize_t vpu_mem_debug(struct class *class, struct class_attribute *attr,
 	/* return 0; */
 }
 
+static ssize_t vpu_clk_gate_debug(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret;
+	unsigned int tmp[2];
+
+	switch (buf[0]) {
+	case 'r':
+		VPUPR("HHI_GCLK_OTHER: 0x%08x\n", vpu_hiu_read(HHI_GCLK_OTHER));
+		VPUPR("VPU_CLK_GATE: 0x%08x\n", vpu_vcbus_read(VPU_CLK_GATE));
+		VPUPR("VDIN0_COM_GCLK_CTRL: 0x%08x\n",
+			vpu_vcbus_read(VDIN0_COM_GCLK_CTRL));
+		VPUPR("VDIN0_COM_GCLK_CTRL2: 0x%08x\n",
+			vpu_vcbus_read(VDIN0_COM_GCLK_CTRL2));
+		VPUPR("VDIN1_COM_GCLK_CTRL: 0x%08x\n",
+			vpu_vcbus_read(VDIN1_COM_GCLK_CTRL));
+		VPUPR("VDIN1_COM_GCLK_CTRL2: 0x%08x\n",
+			vpu_vcbus_read(VDIN1_COM_GCLK_CTRL2));
+		VPUPR("DI_CLKG_CTRL: 0x%08x\n",
+			vpu_vcbus_read(DI_CLKG_CTRL));
+		VPUPR("VPP_GCLK_CTRL0: 0x%08x\n",
+			vpu_vcbus_read(VPP_GCLK_CTRL0));
+		VPUPR("VPP_GCLK_CTRL1: 0x%08x\n",
+			vpu_vcbus_read(VPP_GCLK_CTRL1));
+		VPUPR("VPP_SC_GCLK_CTRL: 0x%08x\n",
+			vpu_vcbus_read(VPP_SC_GCLK_CTRL));
+		if (vpu_chip_type == VPU_CHIP_G9TV) {
+			VPUPR("VPP_SRSCL_GCLK_CTRL: 0x%08x\n",
+				vpu_vcbus_read(VPP_SRSCL_GCLK_CTRL));
+			VPUPR("VPP_OSDSR_GCLK_CTRL: 0x%08x\n",
+				vpu_vcbus_read(VPP_OSDSR_GCLK_CTRL));
+		}
+		VPUPR("VPP_XVYCC_GCLK_CTRL: 0x%08x\n",
+			vpu_vcbus_read(VPP_XVYCC_GCLK_CTRL));
+		break;
+	case 'w':
+		ret = sscanf(buf, "w %u %u", &tmp[0], &tmp[1]);
+		tmp[0] = (tmp[0] > VPU_MAX) ? VPU_MAX : tmp[0];
+		tmp[1] = (tmp[1] == VPU_CLK_GATE_ON) ? 1 : 0;
+		VPUPR("switch_vpu_clk_gate: %s %s\n",
+			vpu_mod_table[tmp[0]], (tmp[1] ? "ON" : "OFF"));
+		switch_vpu_clk_gate_vmod(tmp[0], tmp[1]);
+		break;
+	default:
+		VPUERR("wrong clk_gate command\n");
+		break;
+	}
+
+	if (ret != 1 || ret != 2)
+		return -EINVAL;
+
+	return count;
+	/* return 0; */
+}
+
 static unsigned int vcbus_reg[] = {
 	0x1d00, /* VPP_DUMMY_DATA */
 	0x1702, /* DI_POST_SIZE */
@@ -1225,6 +925,7 @@ static ssize_t vpu_print_debug(struct class *class,
 static struct class_attribute vpu_debug_class_attrs[] = {
 	__ATTR(clk, S_IRUGO | S_IWUSR, vpu_debug_help, vpu_clk_debug),
 	__ATTR(mem, S_IRUGO | S_IWUSR, vpu_debug_help, vpu_mem_debug),
+	__ATTR(gate, S_IRUGO | S_IWUSR, vpu_debug_help, vpu_clk_gate_debug),
 	__ATTR(test, S_IRUGO | S_IWUSR, vpu_debug_help, vpu_test_debug),
 	__ATTR(print, S_IRUGO | S_IWUSR, vpu_debug_help, vpu_print_debug),
 	__ATTR(help, S_IRUGO | S_IWUSR, vpu_debug_help, NULL),
@@ -1321,7 +1022,6 @@ static int vpu_probe(struct platform_device *pdev)
 	vpu_debug_print_flag = 0;
 #endif
 	spin_lock_init(&vpu_lock);
-	spin_lock_init(&vpu_mem_lock);
 
 	VPUPR("driver version: %s\n", VPU_VERION);
 	memset(clk_vmod, 0, sizeof(clk_vmod));
@@ -1332,6 +1032,8 @@ static int vpu_probe(struct platform_device *pdev)
 
 	vpu_ioremap();
 	get_vpu_config(pdev);
+	vpu_ctrl_probe();
+
 	set_vpu_clk(vpu_conf.clk_level);
 
 	creat_vpu_debug_class();
diff --git a/drivers/amlogic/vpu/vpu.h b/drivers/amlogic/vpu/vpu.h
index 9f4bd75..1365e76 100644
--- a/drivers/amlogic/vpu/vpu.h
+++ b/drivers/amlogic/vpu/vpu.h
@@ -18,7 +18,7 @@
 #ifndef __VPU_PARA_H__
 #define __VPU_PARA_H__
 
-/* #define VPU_DEBUG_PRINT */
+/*#define VPU_DEBUG_PRINT*/
 
 #define VPUPR(fmt, args...)     pr_info("vpu: "fmt"", ## args)
 #define VPUERR(fmt, args...)    pr_info("vpu: error: "fmt"", ## args)
@@ -57,174 +57,15 @@ struct vpu_conf_s {
 	unsigned int     mem_pd1;
 };
 
-/* #define LIMIT_VPU_CLK_LOW */
-
-/* ************************************************ */
-/* VPU frequency table, important. DO NOT modify!! */
-/* ************************************************ */
-/* fixed pll frequency */
-enum fclk_type_e {
-	FCLK_2550M = 0,
-	FCLK_2000M,
-	FCLK_MAX,
-};
-static unsigned int fclk_table[] = { /* unit: MHz */
-	2550,
-	2000,
-};
-
-/* M8: */
-/* freq Max=364M, default=255M */
-#define CLK_LEVEL_DFT_M8       3
-#define CLK_LEVEL_MAX_M8       5
-#define FCLK_TYPE_M8           FCLK_2550M
-/* M8M2: */
-/* freq Max=364M, default=255M */
-#define CLK_LEVEL_DFT_M8M2     3
-#define CLK_LEVEL_MAX_M8M2     5
-#define FCLK_TYPE_M8M2         FCLK_2550M
-/* M8baby */
-/* freq max=212MHz, default=212MHz. */
-#define CLK_LEVEL_DFT_M8B      2
-#define CLK_LEVEL_MAX_M8B      3
-#define FCLK_TYPE_M8B          FCLK_2550M
-/* G9TV */
-/* freq max=696M, default=637M */
-#define CLK_LEVEL_DFT_G9TV     7
-#define CLK_LEVEL_MAX_G9TV     9
-#define FCLK_TYPE_G9TV         FCLK_2550M
-/* G9BB */
-/* freq max=212M, default=212M */
-#define CLK_LEVEL_DFT_G9BB     2
-#define CLK_LEVEL_MAX_G9BB     3
-#define FCLK_TYPE_G9BB         FCLK_2550M
-/* GXBB */
-/* freq max=666M, default=666M */
-#define CLK_LEVEL_DFT_GXBB     3
-#define CLK_LEVEL_MAX_GXBB     8
-#define FCLK_TYPE_GXBB         FCLK_2000M
-/* GXTVBB */
-/* freq max=666M, default=666M */
-#define CLK_LEVEL_DFT_GXTVBB     3
-#define CLK_LEVEL_MAX_GXTVBB     8
-#define FCLK_TYPE_GXTVBB         FCLK_2000M
-/* GXL */
-/* freq max=666M, default=666M */
-#define CLK_LEVEL_DFT_GXL     3
-#define CLK_LEVEL_MAX_GXL     8
-#define FCLK_TYPE_GXL         FCLK_2000M
-/* GXM */
-/* freq max=666M, default=666M */
-#define CLK_LEVEL_DFT_GXM     3
-#define CLK_LEVEL_MAX_GXM     8
-#define FCLK_TYPE_GXM         FCLK_2000M
-/* TXL */
-/* freq max=666M, default=666M */
-#define CLK_LEVEL_DFT_TXL     3
-#define CLK_LEVEL_MAX_TXL     8
-#define FCLK_TYPE_TXL         FCLK_2000M
-
-/* vpu clk setting */
-enum vpu_mux_e {
-	FCLK_DIV4 = 0,
-	FCLK_DIV3,
-	FCLK_DIV5,
-	FCLK_DIV7,
-	MPLL_CLK1,
-	VID_PLL_CLK,
-	VID2_PLL_CLK,
-	GPLL_CLK,
-};
-
-static unsigned int fclk_div_table[] = {
-	4, /* mux 0 */
-	3, /* mux 1 */
-	5, /* mux 2 */
-	7, /* mux 3 */
-	2, /* invalid */
-};
-
-static unsigned int vpu_clk_table[2][12][3] = {/* compatible for all chip */
-	{ /* m8, m8m2, g9tv, g9bb, fpll=2550M */
-		/* frequency   clk_mux       div */
-		{106250000,    FCLK_DIV3,    7}, /* 0 */
-		{159375000,    FCLK_DIV4,    3}, /* 1 */
-		{212500000,    FCLK_DIV3,    3}, /* 2 */
-		{255000000,    FCLK_DIV5,    1}, /* 3 */
-		{364300000,    FCLK_DIV7,    0}, /* 4 */ /* M8M2 use gp_pll */
-		{425000000,    FCLK_DIV3,    1}, /* 5 */
-		{510000000,    FCLK_DIV5,    0}, /* 6 */
-		{637500000,    FCLK_DIV4,    0}, /* 7 */
-		{696000000,    GPLL_CLK,     0}, /* 8 */ /* G9TV use gp1_pll */
-		{850000000,    FCLK_DIV3,    0}, /* 9 */
-	},
-	{ /* gxbb, gxtvbb, gxl, txl, fpll=2000M */
-		/* frequency   clk_mux       div */
-		{100000000,    FCLK_DIV5,    3}, /* 0 */
-		{166667000,    FCLK_DIV3,    3}, /* 1 */
-		{200000000,    FCLK_DIV5,    1}, /* 2 */
-		{250000000,    FCLK_DIV4,    1}, /* 3 */
-		{333333000,    FCLK_DIV3,    1}, /* 4 */
-		{400000000,    FCLK_DIV5,    0}, /* 5 */
-		{500000000,    FCLK_DIV4,    0}, /* 6 */
-		{666667000,    FCLK_DIV3,    0}, /* 7 */
-		{696000000,    GPLL_CLK,     0}, /* 8 */ /* invalid */
-		{850000000,    GPLL_CLK,     0}, /* 9 */ /* invalid */
-	},
-};
-
 /* ************************************************ */
 
-/* ************************************************ */
-/* VPU module name table */
-/* ************************************************ */
-static char *vpu_mod_table[] = {
-	"viu_osd1",
-	"viu_osd2",
-	"viu_vd1",
-	"viu_vd2",
-	"viu_chroma",
-	"viu_ofifo",
-	"viu_scaler",
-	"viu_osd_scaler",
-	"viu_vdin0",
-	"viu_vdin1",
-	"pic_rot1",
-	"pic_rot2",
-	"pic_rot3",
-	"viu_super_scaler",
-	"viu_osd_super_scaler",
-	"afbc_dec",
-	"di_pre",
-	"di_post",
-	"viu_sharpness_line_buffer",
 
-	"viu2_osd1",
-	"viu2_osd2",
-	"d2d3",
-	"viu2_vd1",
-	"viu2_chroma",
-	"viu2_ofifo",
-	"viu2_scaler",
-	"viu2_osd_scaler",
-	"vdin_arbitor_am_async",
-	"vpu_arb",
-	"display_arbitor_am_async",
-	"osd1_afbcd",
-	"afbc_dec0",
-	"afbc_dec",
-	"vpu_arbitor2_am_async",
-	"vencp",
-	"vencl",
-	"venci",
-	"isp",
-	"cvd2",
-	"atv_dmd",
-	"ldim_stts",
-	"xvycc_lut",
+extern enum vpu_chip_e vpu_chip_type;
+extern int vpu_debug_print_flag;
 
-	"viu1_water_mark",
-	"none",
-};
+extern int vpu_ioremap(void);
+extern int vpu_chip_valid_check(void);
+extern enum vpu_mod_e get_vpu_mod(unsigned int vmod);
+extern void vpu_ctrl_probe(void);
 
 #endif
diff --git a/drivers/amlogic/vpu/vpu_clk.h b/drivers/amlogic/vpu/vpu_clk.h
new file mode 100644
index 0000000..aad3813
--- /dev/null
+++ b/drivers/amlogic/vpu/vpu_clk.h
@@ -0,0 +1,139 @@
+/*
+ * drivers/amlogic/vpu/vpu_clk.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef __VPU_CLK_H__
+#define __VPU_CLK_H__
+
+/* #define LIMIT_VPU_CLK_LOW */
+
+/* ************************************************ */
+/* VPU frequency table, important. DO NOT modify!! */
+/* ************************************************ */
+/* fixed pll frequency */
+enum fclk_type_e {
+	FCLK_2550M = 0,
+	FCLK_2000M,
+	FCLK_MAX,
+};
+static unsigned int fclk_table[] = { /* unit: MHz */
+	2550,
+	2000,
+};
+
+/* M8: */
+/* freq Max=364M, default=255M */
+#define CLK_LEVEL_DFT_M8       3
+#define CLK_LEVEL_MAX_M8       5
+#define FCLK_TYPE_M8           FCLK_2550M
+/* M8M2: */
+/* freq Max=364M, default=255M */
+#define CLK_LEVEL_DFT_M8M2     3
+#define CLK_LEVEL_MAX_M8M2     5
+#define FCLK_TYPE_M8M2         FCLK_2550M
+/* M8baby */
+/* freq max=212MHz, default=212MHz. */
+#define CLK_LEVEL_DFT_M8B      2
+#define CLK_LEVEL_MAX_M8B      3
+#define FCLK_TYPE_M8B          FCLK_2550M
+/* G9TV */
+/* freq max=696M, default=637M */
+#define CLK_LEVEL_DFT_G9TV     7
+#define CLK_LEVEL_MAX_G9TV     9
+#define FCLK_TYPE_G9TV         FCLK_2550M
+/* G9BB */
+/* freq max=212M, default=212M */
+#define CLK_LEVEL_DFT_G9BB     2
+#define CLK_LEVEL_MAX_G9BB     3
+#define FCLK_TYPE_G9BB         FCLK_2550M
+/* GXBB */
+/* freq max=666M, default=666M */
+#define CLK_LEVEL_DFT_GXBB     3
+#define CLK_LEVEL_MAX_GXBB     8
+#define FCLK_TYPE_GXBB         FCLK_2000M
+/* GXTVBB */
+/* freq max=666M, default=666M */
+#define CLK_LEVEL_DFT_GXTVBB     3
+#define CLK_LEVEL_MAX_GXTVBB     8
+#define FCLK_TYPE_GXTVBB         FCLK_2000M
+/* GXL */
+/* freq max=666M, default=666M */
+#define CLK_LEVEL_DFT_GXL     3
+#define CLK_LEVEL_MAX_GXL     8
+#define FCLK_TYPE_GXL         FCLK_2000M
+/* GXM */
+/* freq max=666M, default=666M */
+#define CLK_LEVEL_DFT_GXM     3
+#define CLK_LEVEL_MAX_GXM     8
+#define FCLK_TYPE_GXM         FCLK_2000M
+/* TXL */
+/* freq max=666M, default=666M */
+#define CLK_LEVEL_DFT_TXL     3
+#define CLK_LEVEL_MAX_TXL     8
+#define FCLK_TYPE_TXL         FCLK_2000M
+
+/* vpu clk setting */
+enum vpu_mux_e {
+	FCLK_DIV4 = 0,
+	FCLK_DIV3,
+	FCLK_DIV5,
+	FCLK_DIV7,
+	MPLL_CLK1,
+	VID_PLL_CLK,
+	VID2_PLL_CLK,
+	GPLL_CLK,
+};
+
+static unsigned int fclk_div_table[] = {
+	4, /* mux 0 */
+	3, /* mux 1 */
+	5, /* mux 2 */
+	7, /* mux 3 */
+	2, /* invalid */
+};
+
+static unsigned int vpu_clk_table[2][12][3] = {/* compatible for all chip */
+	{ /* m8, m8m2, g9tv, g9bb, fpll=2550M */
+		/* frequency   clk_mux       div */
+		{106250000,    FCLK_DIV3,    7}, /* 0 */
+		{159375000,    FCLK_DIV4,    3}, /* 1 */
+		{212500000,    FCLK_DIV3,    3}, /* 2 */
+		{255000000,    FCLK_DIV5,    1}, /* 3 */
+		{364300000,    FCLK_DIV7,    0}, /* 4 */ /* M8M2 use gp_pll */
+		{425000000,    FCLK_DIV3,    1}, /* 5 */
+		{510000000,    FCLK_DIV5,    0}, /* 6 */
+		{637500000,    FCLK_DIV4,    0}, /* 7 */
+		{696000000,    GPLL_CLK,     0}, /* 8 */ /* G9TV use gp1_pll */
+		{850000000,    FCLK_DIV3,    0}, /* 9 */
+	},
+	{ /* gxbb, gxtvbb, gxl, gxm, txl, fpll=2000M */
+		/* frequency   clk_mux       div */
+		{100000000,    FCLK_DIV5,    3}, /* 0 */
+		{166667000,    FCLK_DIV3,    3}, /* 1 */
+		{200000000,    FCLK_DIV5,    1}, /* 2 */
+		{250000000,    FCLK_DIV4,    1}, /* 3 */
+		{333333000,    FCLK_DIV3,    1}, /* 4 */
+		{400000000,    FCLK_DIV5,    0}, /* 5 */
+		{500000000,    FCLK_DIV4,    0}, /* 6 */
+		{666667000,    FCLK_DIV3,    0}, /* 7 */
+		{696000000,    GPLL_CLK,     0}, /* 8 */ /* invalid */
+		{850000000,    GPLL_CLK,     0}, /* 9 */ /* invalid */
+	},
+};
+
+/* ************************************************ */
+
+#endif
diff --git a/drivers/amlogic/vpu/vpu_ctrl.c b/drivers/amlogic/vpu/vpu_ctrl.c
new file mode 100644
index 0000000..2a24fba
--- /dev/null
+++ b/drivers/amlogic/vpu/vpu_ctrl.c
@@ -0,0 +1,611 @@
+/*
+ * drivers/amlogic/vpu/vpu_ctrl.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/delay.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/amlogic/vpu.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include "vpu_reg.h"
+#include "vpu.h"
+#include "vpu_module.h"
+
+static spinlock_t vpu_mem_lock;
+static spinlock_t vpu_clk_gate_lock;
+
+/* *********************************************** */
+/* VPU_MEM_PD control */
+/* *********************************************** */
+/*
+ *  Function: switch_vpu_mem_pd_vmod
+ *      switch vpu memory power down by specified vmod
+ *
+ *  Parameters:
+ *      vmod - unsigned int, must be the following constants:
+ *                 VPU_MOD, supported by vpu_mod_e
+ *      flag - int, on/off switch flag, must be one of the following constants:
+ *                 VPU_MEM_POWER_ON
+ *                 VPU_MEM_POWER_DOWN
+ *
+ *  Example:
+ *      switch_vpu_mem_pd_vmod(VPU_VENCP, VPU_MEM_POWER_ON);
+ *      switch_vpu_mem_pd_vmod(VPU_VIU_OSD1, VPU_MEM_POWER_DOWN);
+ *
+*/
+void switch_vpu_mem_pd_vmod(unsigned int vmod, int flag)
+{
+	unsigned int vpu_mod;
+	unsigned long flags = 0;
+	unsigned int _reg0, _reg1, _reg2;
+	unsigned int val;
+	int ret = 0;
+
+	ret = vpu_chip_valid_check();
+	if (ret)
+		return;
+
+	spin_lock_irqsave(&vpu_mem_lock, flags);
+
+	val = (flag == VPU_MEM_POWER_ON) ? 0 : 3;
+	switch (vpu_chip_type) {
+	case VPU_CHIP_M8:
+	case VPU_CHIP_M8B:
+	case VPU_CHIP_M8M2:
+	case VPU_CHIP_G9TV:
+	case VPU_CHIP_G9BB:
+		_reg0 = HHI_VPU_MEM_PD_REG0;
+		_reg1 = HHI_VPU_MEM_PD_REG1;
+		_reg2 = 0;
+		break;
+	default:
+		_reg0 = HHI_VPU_MEM_PD_REG0_GX;
+		_reg1 = HHI_VPU_MEM_PD_REG1_GX;
+		_reg2 = HHI_VPU_MEM_PD_REG2_GX;
+		break;
+	}
+
+	vpu_mod = get_vpu_mod(vmod);
+	switch (vpu_mod) {
+	case VPU_VIU_OSD1:
+		vpu_hiu_setb(_reg0, val, 0, 2);
+		break;
+	case VPU_VIU_OSD2:
+		vpu_hiu_setb(_reg0, val, 2, 2);
+		break;
+	case VPU_VIU_VD1:
+		vpu_hiu_setb(_reg0, val, 4, 2);
+		break;
+	case VPU_VIU_VD2:
+		vpu_hiu_setb(_reg0, val, 6, 2);
+		break;
+	case VPU_VIU_CHROMA:
+		vpu_hiu_setb(_reg0, val, 8, 2);
+		break;
+	case VPU_VIU_OFIFO:
+		vpu_hiu_setb(_reg0, val, 10, 2);
+		break;
+	case VPU_VIU_SCALE:
+		vpu_hiu_setb(_reg0, val, 12, 2);
+		break;
+	case VPU_VIU_OSD_SCALE:
+		vpu_hiu_setb(_reg0, val, 14, 2);
+		break;
+	case VPU_VIU_VDIN0:
+		vpu_hiu_setb(_reg0, val, 16, 2);
+		break;
+	case VPU_VIU_VDIN1:
+		vpu_hiu_setb(_reg0, val, 18, 2);
+		break;
+	case VPU_PIC_ROT1:
+	case VPU_VIU_SRSCL:
+		vpu_hiu_setb(_reg0, val, 20, 2);
+		break;
+	case VPU_PIC_ROT2:
+	case VPU_VIU_OSDSR:
+	case VPU_AFBC_DEC1:
+		vpu_hiu_setb(_reg0, val, 22, 2);
+		break;
+	case VPU_PIC_ROT3:
+		vpu_hiu_setb(_reg0, val, 24, 2);
+		break;
+	case VPU_DI_PRE:
+		vpu_hiu_setb(_reg0, val, 26, 2);
+		break;
+	case VPU_DI_POST:
+		vpu_hiu_setb(_reg0, val, 28, 2);
+		break;
+	case VPU_SHARP:
+		vpu_hiu_setb(_reg0, val, 30, 2);
+		break;
+	case VPU_VIU2_OSD1:
+		vpu_hiu_setb(_reg1, val, 0, 2);
+		break;
+	case VPU_VIU2_OSD2:
+		vpu_hiu_setb(_reg1, val, 2, 2);
+		break;
+	case VPU_D2D3:
+		if (vpu_chip_type == VPU_CHIP_G9TV)
+			vpu_hiu_setb(_reg1, ((val << 2) | val), 0, 4);
+		break;
+	case VPU_VIU2_VD1:
+		vpu_hiu_setb(_reg1, val, 4, 2);
+		break;
+	case VPU_VIU2_CHROMA:
+		vpu_hiu_setb(_reg1, val, 6, 2);
+		break;
+	case VPU_VIU2_OFIFO:
+		vpu_hiu_setb(_reg1, val, 8, 2);
+		break;
+	case VPU_VIU2_SCALE:
+		vpu_hiu_setb(_reg1, val, 10, 2);
+		break;
+	case VPU_VIU2_OSD_SCALE:
+		vpu_hiu_setb(_reg1, val, 12, 2);
+		break;
+	case VPU_VDIN_AM_ASYNC:
+	case VPU_VPU_ARB:
+		vpu_hiu_setb(_reg1, val, 14, 2);
+		break;
+	case VPU_VDISP_AM_ASYNC:
+	case VPU_AFBC_DEC:
+	case VPU_OSD1_AFBCD:
+	case VPU_AFBC_DEC0:
+		vpu_hiu_setb(_reg1, val, 16, 2);
+		break;
+	case VPU_VPUARB2_AM_ASYNC:
+		if (vpu_chip_type == VPU_CHIP_G9TV)
+			vpu_hiu_setb(_reg1, val, 18, 2);
+		break;
+	case VPU_VENCP:
+		vpu_hiu_setb(_reg1, val, 20, 2);
+		break;
+	case VPU_VENCL:
+		vpu_hiu_setb(_reg1, val, 22, 2);
+		break;
+	case VPU_VENCI:
+		vpu_hiu_setb(_reg1, val, 24, 2);
+		break;
+	case VPU_ISP:
+		vpu_hiu_setb(_reg1, val, 26, 2);
+		break;
+	case VPU_CVD2:
+	case VPU_LDIM_STTS:
+		vpu_hiu_setb(_reg1, val, 28, 2);
+		break;
+	case VPU_ATV_DMD:
+	case VPU_XVYCC_LUT:
+		vpu_hiu_setb(_reg1, val, 30, 2);
+		break;
+	case VPU_VIU1_WM:
+		if ((vpu_chip_type == VPU_CHIP_GXL) ||
+			(vpu_chip_type == VPU_CHIP_GXM) ||
+			(vpu_chip_type == VPU_CHIP_TXL)) {
+			vpu_hiu_setb(_reg2, val, 0, 2);
+		}
+		break;
+	default:
+		VPUPR("switch_vpu_mem_pd: unsupport vpu mod\n");
+		break;
+	}
+
+	spin_unlock_irqrestore(&vpu_mem_lock, flags);
+
+	if (vpu_debug_print_flag) {
+		VPUPR("switch_vpu_mem_pd: %s %s\n",
+			vpu_mod_table[vpu_mod],
+			((flag == VPU_MEM_POWER_ON) ? "ON" : "OFF"));
+		dump_stack();
+	}
+}
+
+/*
+ *  Function: get_vpu_mem_pd_vmod
+ *      switch vpu memory power down by specified vmod
+ *
+ *  Parameters:
+ *      vmod - unsigned int, must be the following constants:
+ *                 VPU_MOD, supported by vpu_mod_e
+ *
+ *  Returns:
+ *      int, 0 for power on, 1 for power down, -1 for error
+ *
+ *  Example:
+ *      ret = get_vpu_mem_pd_vmod(VPU_VENCP);
+ *      ret = get_vpu_mem_pd_vmod(VPU_VIU_OSD1);
+ *
+*/
+#define VPU_MEM_PD_ERR        0xffff
+int get_vpu_mem_pd_vmod(unsigned int vmod)
+{
+	unsigned int vpu_mod;
+	unsigned int _reg0, _reg1, _reg2;
+	unsigned int val;
+	int ret = 0;
+
+	ret = vpu_chip_valid_check();
+	if (ret)
+		return -1;
+
+	switch (vpu_chip_type) {
+	case VPU_CHIP_M8:
+	case VPU_CHIP_M8B:
+	case VPU_CHIP_M8M2:
+	case VPU_CHIP_G9TV:
+	case VPU_CHIP_G9BB:
+		_reg0 = HHI_VPU_MEM_PD_REG0;
+		_reg1 = HHI_VPU_MEM_PD_REG1;
+		_reg2 = 0;
+		break;
+	default:
+		_reg0 = HHI_VPU_MEM_PD_REG0_GX;
+		_reg1 = HHI_VPU_MEM_PD_REG1_GX;
+		_reg2 = HHI_VPU_MEM_PD_REG2_GX;
+		break;
+	}
+
+	vpu_mod = get_vpu_mod(vmod);
+	switch (vpu_mod) {
+	case VPU_VIU_OSD1:
+		val = vpu_hiu_getb(_reg0, 0, 2);
+		break;
+	case VPU_VIU_OSD2:
+		val = vpu_hiu_getb(_reg0, 2, 2);
+		break;
+	case VPU_VIU_VD1:
+		val = vpu_hiu_getb(_reg0, 4, 2);
+		break;
+	case VPU_VIU_VD2:
+		val = vpu_hiu_getb(_reg0, 6, 2);
+		break;
+	case VPU_VIU_CHROMA:
+		val = vpu_hiu_getb(_reg0, 8, 2);
+		break;
+	case VPU_VIU_OFIFO:
+		val = vpu_hiu_getb(_reg0, 10, 2);
+		break;
+	case VPU_VIU_SCALE:
+		val = vpu_hiu_getb(_reg0, 12, 2);
+		break;
+	case VPU_VIU_OSD_SCALE:
+		val = vpu_hiu_getb(_reg0, 14, 2);
+		break;
+	case VPU_VIU_VDIN0:
+		val = vpu_hiu_getb(_reg0, 16, 2);
+		break;
+	case VPU_VIU_VDIN1:
+		val = vpu_hiu_getb(_reg0, 18, 2);
+		break;
+	case VPU_PIC_ROT1:
+	case VPU_VIU_SRSCL:
+		val = vpu_hiu_getb(_reg0, 20, 2);
+		break;
+	case VPU_PIC_ROT2:
+	case VPU_VIU_OSDSR:
+	case VPU_AFBC_DEC1:
+		val = vpu_hiu_getb(_reg0, 22, 2);
+		break;
+	case VPU_PIC_ROT3:
+		val = vpu_hiu_getb(_reg0, 24, 2);
+		break;
+	case VPU_DI_PRE:
+		val = vpu_hiu_getb(_reg0, 26, 2);
+		break;
+	case VPU_DI_POST:
+		val = vpu_hiu_getb(_reg0, 28, 2);
+		break;
+	case VPU_SHARP:
+		val = vpu_hiu_getb(_reg0, 30, 2);
+		break;
+	case VPU_VIU2_OSD1:
+		val = vpu_hiu_getb(_reg1, 0, 2);
+		break;
+	case VPU_VIU2_OSD2:
+		val = vpu_hiu_getb(_reg1, 2, 2);
+		break;
+	case VPU_D2D3:
+		if (vpu_chip_type == VPU_CHIP_G9TV)
+			val = vpu_hiu_getb(_reg1, 0, 4);
+		else
+			val = VPU_MEM_PD_ERR;
+		break;
+	case VPU_VIU2_VD1:
+		val = vpu_hiu_getb(_reg1, 4, 2);
+		break;
+	case VPU_VIU2_CHROMA:
+		val = vpu_hiu_getb(_reg1, 6, 2);
+		break;
+	case VPU_VIU2_OFIFO:
+		val = vpu_hiu_getb(_reg1, 8, 2);
+		break;
+	case VPU_VIU2_SCALE:
+		val = vpu_hiu_getb(_reg1, 10, 2);
+		break;
+	case VPU_VIU2_OSD_SCALE:
+		val = vpu_hiu_getb(_reg1, 12, 2);
+		break;
+	case VPU_VDIN_AM_ASYNC:
+	case VPU_VPU_ARB:
+		val = vpu_hiu_getb(_reg1, 14, 2);
+		break;
+	case VPU_VDISP_AM_ASYNC:
+	case VPU_AFBC_DEC:
+	case VPU_OSD1_AFBCD:
+	case VPU_AFBC_DEC0:
+		val = vpu_hiu_getb(_reg1, 16, 2);
+		break;
+	case VPU_VPUARB2_AM_ASYNC:
+		if (vpu_chip_type == VPU_CHIP_G9TV)
+			val = vpu_hiu_getb(_reg0, 18, 2);
+		else
+			val = VPU_MEM_PD_ERR;
+		break;
+	case VPU_VENCP:
+		val = vpu_hiu_getb(_reg1, 20, 2);
+		break;
+	case VPU_VENCL:
+		val = vpu_hiu_getb(_reg1, 22, 2);
+		break;
+	case VPU_VENCI:
+		val = vpu_hiu_getb(_reg1, 24, 2);
+		break;
+	case VPU_ISP:
+		val = vpu_hiu_getb(_reg1, 26, 2);
+		break;
+	case VPU_CVD2:
+	case VPU_LDIM_STTS:
+		val = vpu_hiu_getb(_reg1, 28, 2);
+		break;
+	case VPU_ATV_DMD:
+	case VPU_XVYCC_LUT:
+		val = vpu_hiu_getb(_reg1, 30, 2);
+		break;
+	case VPU_VIU1_WM:
+		if ((vpu_chip_type == VPU_CHIP_GXL) ||
+			(vpu_chip_type == VPU_CHIP_GXM) ||
+			(vpu_chip_type == VPU_CHIP_TXL)) {
+			val = vpu_hiu_getb(_reg2, 0, 2);
+		} else {
+			val = VPU_MEM_PD_ERR;
+		}
+		break;
+	default:
+		val = VPU_MEM_PD_ERR;
+		break;
+	}
+
+	if (val == 0)
+		return VPU_MEM_POWER_ON;
+	else if ((val == 0x3) || (val == 0xf))
+		return VPU_MEM_POWER_DOWN;
+	else
+		return -1;
+}
+
+/* *********************************************** */
+/* VPU_CLK_GATE control */
+/* *********************************************** */
+/*
+ *  Function: switch_vpu_clk_gate_vmod
+ *      switch vpu clk gate by specified vmod
+ *
+ *  Parameters:
+ *      vmod - unsigned int, must be the following constants:
+ *                 VPU_MOD, supported by vpu_mod_e
+ *      flag - int, on/off switch flag, must be one of the following constants:
+ *                 VPU_CLK_GATE_ON
+ *                 VPU_CLK_GATE_OFF
+ *
+ *  Example:
+ *      switch_vpu_clk_gate_vmod(VPU_VENCP, VPU_CLK_GATE_ON);
+ *      switch_vpu_clk_gate_vmod(VPU_VPP, VPU_CLK_GATE_OFF);
+ *
+*/
+void switch_vpu_clk_gate_vmod(unsigned int vmod, int flag)
+{
+	unsigned vpu_mod;
+	unsigned long flags = 0;
+	unsigned int val;
+	int ret = 0;
+
+	ret = vpu_chip_valid_check();
+	if (ret)
+		return;
+
+	spin_lock_irqsave(&vpu_clk_gate_lock, flags);
+
+	val = (flag == VPU_CLK_GATE_ON) ? 1 : 0;
+
+	vpu_mod = get_vpu_mod(vmod);
+	switch (vpu_mod) {
+	case VPU_VPU_TOP:
+		vpu_vcbus_setb(VPU_CLK_GATE, val, 1, 1); /* vpu_system_clk */
+		break;
+	case VPU_VPU_CLKB:
+		if ((vpu_chip_type == VPU_CHIP_GXTVBB) ||
+			(vpu_chip_type == VPU_CHIP_GXL) ||
+			(vpu_chip_type == VPU_CHIP_GXM) ||
+			(vpu_chip_type == VPU_CHIP_TXL)) {
+			vpu_vcbus_setb(VPU_CLK_GATE, val, 8, 1); /* clkb_gen */
+			vpu_vcbus_setb(VPU_CLK_GATE, val, 9, 1); /* clkb_gen */
+			/* clkb_gen_en */
+			vpu_vcbus_setb(VPU_CLK_GATE, val, 17, 1);
+		}
+		if ((vpu_chip_type == VPU_CHIP_GXBB) ||
+			(vpu_chip_type == VPU_CHIP_GXTVBB) ||
+			(vpu_chip_type == VPU_CHIP_GXL) ||
+			(vpu_chip_type == VPU_CHIP_GXM) ||
+			(vpu_chip_type == VPU_CHIP_TXL)) {
+			/* clkb_gate */
+			vpu_vcbus_setb(VPU_CLK_GATE, val, 16, 1);
+		}
+		break;
+	case VPU_RDMA:
+		if ((vpu_chip_type == VPU_CHIP_GXBB) ||
+			(vpu_chip_type == VPU_CHIP_GXTVBB) ||
+			(vpu_chip_type == VPU_CHIP_GXL) ||
+			(vpu_chip_type == VPU_CHIP_GXM) ||
+			(vpu_chip_type == VPU_CHIP_TXL)) {
+			vpu_vcbus_setb(VPU_CLK_GATE, val, 15, 1); /* rdma_clk */
+		}
+		break;
+	case VPU_VLOCK:
+		vpu_vcbus_setb(VPU_CLK_GATE, val, 14, 1);
+		break;
+	case VPU_MISC:
+		vpu_vcbus_setb(VPU_CLK_GATE, val, 6, 1); /* hs,vs,interrupt */
+		break;
+	case VPU_VENC_DAC:
+		/* clk for dac(r/w reg) */
+		/*vpu_vcbus_setb(VPU_CLK_GATE, val, 12, 1);*/
+		vpu_hiu_setb(HHI_GCLK_OTHER, val, 10, 1);
+		/* dac top clk */
+		break;
+	case VPU_VENCP:
+		if (flag == VPU_CLK_GATE_ON) {
+			vpu_vcbus_set_mask(VPU_CLK_GATE,
+				((1 << 3) || (1 << 0)));
+			vpu_hiu_set_mask(HHI_GCLK_OTHER,
+				((1 << 9) || (0x3 << 3)));
+		} else {
+			vpu_vcbus_clr_mask(VPU_CLK_GATE,
+				((1 << 3) || (1 << 0)));
+			vpu_hiu_clr_mask(HHI_GCLK_OTHER,
+				((1 << 9) || (0x3 << 3)));
+		}
+		break;
+	case VPU_VENCL:
+		if (flag == VPU_CLK_GATE_ON) {
+			vpu_vcbus_set_mask(VPU_CLK_GATE, (0x3 << 4));
+			vpu_hiu_set_mask(HHI_GCLK_OTHER, (0x7 << 23));
+		} else {
+			vpu_vcbus_clr_mask(VPU_CLK_GATE, (0x3 << 4));
+			vpu_hiu_clr_mask(HHI_GCLK_OTHER, (0x7 << 23));
+		}
+		break;
+	case VPU_VENCI:
+		if (flag == VPU_CLK_GATE_ON) {
+			vpu_vcbus_set_mask(VPU_CLK_GATE, (0x3 << 10));
+			vpu_hiu_set_mask(HHI_GCLK_OTHER,
+				((1 << 8) | (0x3 << 1)));
+		} else {
+			vpu_vcbus_clr_mask(VPU_CLK_GATE, (0x3 << 10));
+			vpu_hiu_clr_mask(HHI_GCLK_OTHER,
+				((1 << 8) | (0x3 << 1)));
+		}
+		break;
+	case VPU_VIU_VDIN0:
+		if (flag == VPU_CLK_GATE_ON) {
+			vpu_vcbus_set_mask(VDIN0_COM_GCLK_CTRL, 0x3f3ffff2);
+			vpu_vcbus_set_mask(VDIN0_COM_GCLK_CTRL2, 0xf);
+		} else {
+			vpu_vcbus_clr_mask(VDIN0_COM_GCLK_CTRL, 0x3f3ffff0);
+			vpu_vcbus_clr_mask(VDIN0_COM_GCLK_CTRL2, 0xf);
+		}
+		break;
+	case VPU_VIU_VDIN1:
+		if (flag == VPU_CLK_GATE_ON) {
+			vpu_vcbus_set_mask(VDIN1_COM_GCLK_CTRL, 0x3f3ffff2);
+			vpu_vcbus_set_mask(VDIN1_COM_GCLK_CTRL2, 0xf);
+		} else {
+			vpu_vcbus_clr_mask(VDIN1_COM_GCLK_CTRL, 0x3f3ffff0);
+			vpu_vcbus_clr_mask(VDIN1_COM_GCLK_CTRL2, 0xf);
+		}
+		break;
+	case VPU_DI:
+		if (flag == VPU_CLK_GATE_ON) {
+			vpu_vcbus_set_mask(DI_CLKG_CTRL, 0x1d1e0003);
+			if ((vpu_chip_type == VPU_CHIP_GXTVBB) ||
+				(vpu_chip_type == VPU_CHIP_GXL) ||
+				(vpu_chip_type == VPU_CHIP_GXM) ||
+				(vpu_chip_type == VPU_CHIP_TXL)) {
+				vpu_vcbus_set_mask(DI_CLKG_CTRL, 0x60200000);
+			}
+		} else {
+			vpu_vcbus_clr_mask(DI_CLKG_CTRL, 0x1d1e0003);
+			if ((vpu_chip_type == VPU_CHIP_GXTVBB) ||
+				(vpu_chip_type == VPU_CHIP_GXL) ||
+				(vpu_chip_type == VPU_CHIP_GXM) ||
+				(vpu_chip_type == VPU_CHIP_TXL)) {
+				vpu_vcbus_clr_mask(DI_CLKG_CTRL, 0x60200000);
+			}
+		}
+		break;
+	case VPU_VPP:
+		if (flag == VPU_CLK_GATE_ON) {
+			vpu_vcbus_set_mask(VPP_GCLK_CTRL0, 0xffff3fcc);
+			if ((vpu_chip_type == VPU_CHIP_GXTVBB) ||
+				(vpu_chip_type == VPU_CHIP_GXL) ||
+				(vpu_chip_type == VPU_CHIP_GXM) ||
+				(vpu_chip_type == VPU_CHIP_TXL)) {
+				vpu_vcbus_set_mask(VPP_GCLK_CTRL0, 0xc030);
+			}
+			vpu_vcbus_set_mask(VPP_GCLK_CTRL1, 0xfff);
+			vpu_vcbus_set_mask(VPP_SC_GCLK_CTRL, 0x03fc0ffc);
+			if (vpu_chip_type == VPU_CHIP_G9TV) {
+				vpu_vcbus_set_mask(VPP_SRSCL_GCLK_CTRL,
+					0x0ffffffc);
+				vpu_vcbus_set_mask(VPP_OSDSR_GCLK_CTRL, 0xfffc);
+			}
+			vpu_vcbus_set_mask(VPP_XVYCC_GCLK_CTRL, 0x3ffff);
+		} else {
+			vpu_vcbus_clr_mask(VPP_GCLK_CTRL0, 0xffff3fcc);
+			if ((vpu_chip_type == VPU_CHIP_GXTVBB) ||
+				(vpu_chip_type == VPU_CHIP_GXL) ||
+				(vpu_chip_type == VPU_CHIP_GXM) ||
+				(vpu_chip_type == VPU_CHIP_TXL)) {
+				vpu_vcbus_clr_mask(VPP_GCLK_CTRL0, 0xc030);
+			}
+			vpu_vcbus_clr_mask(VPP_GCLK_CTRL1, 0xfff);
+			vpu_vcbus_clr_mask(VPP_SC_GCLK_CTRL, 0x03fc0ffc);
+			if (vpu_chip_type == VPU_CHIP_G9TV) {
+				vpu_vcbus_clr_mask(VPP_SRSCL_GCLK_CTRL,
+					0x0ffffffc);
+				vpu_vcbus_clr_mask(VPP_OSDSR_GCLK_CTRL, 0xfffc);
+			}
+			vpu_vcbus_clr_mask(VPP_XVYCC_GCLK_CTRL, 0x3ffff);
+		}
+		break;
+	default:
+		VPUPR("switch_vpu_clk_gate: unsupport vpu mod\n");
+		break;
+	}
+
+	spin_unlock_irqrestore(&vpu_clk_gate_lock, flags);
+
+	if (vpu_debug_print_flag) {
+		VPUPR("switch_vpu_clk_gate: %s %s\n",
+			vpu_mod_table[vpu_mod],
+			((flag == VPU_CLK_GATE_ON) ? "ON" : "OFF"));
+		dump_stack();
+	}
+}
+
+/* *********************************************** */
+
+void vpu_ctrl_probe(void)
+{
+	spin_lock_init(&vpu_mem_lock);
+	spin_lock_init(&vpu_clk_gate_lock);
+}
+
diff --git a/drivers/amlogic/vpu/vpu_module.h b/drivers/amlogic/vpu/vpu_module.h
new file mode 100644
index 0000000..f572046
--- /dev/null
+++ b/drivers/amlogic/vpu/vpu_module.h
@@ -0,0 +1,84 @@
+/*
+ * drivers/amlogic/vpu/vpu_module.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef __VPU_MODULE_H__
+#define __VPU_MODULE_H__
+
+/* ************************************************ */
+/* VPU module name table */
+/* ************************************************ */
+static char *vpu_mod_table[] = {
+	"viu_osd1",
+	"viu_osd2",
+	"viu_vd1",
+	"viu_vd2",
+	"viu_chroma",
+	"viu_ofifo",
+	"viu_scaler",
+	"viu_osd_scaler",
+	"viu_vdin0",
+	"viu_vdin1",
+	"pic_rot1",
+	"pic_rot2",
+	"pic_rot3",
+	"viu_super_scaler",
+	"viu_osd_super_scaler",
+	"afbc_dec",
+	"di_pre",
+	"di_post",
+	"viu_sharpness_line_buffer",
+
+	"viu2_osd1",
+	"viu2_osd2",
+	"d2d3",
+	"viu2_vd1",
+	"viu2_chroma",
+	"viu2_ofifo",
+	"viu2_scaler",
+	"viu2_osd_scaler",
+	"vdin_arbitor_am_async",
+	"vpu_arb",
+	"display_arbitor_am_async",
+	"osd1_afbcd",
+	"afbc_dec0",
+	"afbc_dec",
+	"vpu_arbitor2_am_async",
+	"vencp",
+	"vencl",
+	"venci",
+	"isp",
+	"cvd2",
+	"atv_dmd",
+	"ldim_stts",
+	"xvycc_lut",
+
+	"viu1_water_mark",
+
+	/* for clk_gate */
+	"vpu_top",
+	"vpu_clkb",
+	"vpu_rdma",
+	"vpu_misc",
+	"venc_dac",
+	"vlock",
+	"di",
+	"vpp",
+
+	"none",
+};
+
+#endif
diff --git a/drivers/amlogic/vpu/vpu_reg.c b/drivers/amlogic/vpu/vpu_reg.c
new file mode 100644
index 0000000..a25c5b8
--- /dev/null
+++ b/drivers/amlogic/vpu/vpu_reg.c
@@ -0,0 +1,208 @@
+/*
+ * drivers/amlogic/vpu/vpu_reg.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/delay.h>
+#include <linux/amlogic/cpu_version.h>
+#include "vpu_reg.h"
+#include "vpu.h"
+
+/* ********************************
+ * register access api
+ * ********************************* */
+
+struct reg_map_s {
+	unsigned int base_addr;
+	unsigned int size;
+	void __iomem *p;
+	int flag;
+};
+
+static struct reg_map_s vpu_reg_maps[] = {
+	{ /* CBUS */
+		.base_addr = 0xc1100000,
+		.size = 0x10000,
+	},
+	{ /* HIU */
+		.base_addr = 0xc883c000,
+		.size = 0x400,
+	},
+	{ /* VCBUS */
+		.base_addr = 0xd0100000,
+		.size = 0xa000,
+	},
+};
+
+int vpu_ioremap(void)
+{
+	int i;
+	int ret = 0;
+
+	for (i = 0; i < ARRAY_SIZE(vpu_reg_maps); i++) {
+		vpu_reg_maps[i].p = ioremap(vpu_reg_maps[i].base_addr,
+					vpu_reg_maps[i].size);
+		if (vpu_reg_maps[i].p == NULL) {
+			vpu_reg_maps[i].flag = 0;
+			VPUERR("VPU reg map failed: 0x%x\n",
+				vpu_reg_maps[i].base_addr);
+			ret = -1;
+		} else {
+			vpu_reg_maps[i].flag = 1;
+			/* VPUPR("VPU reg mapped: 0x%x -> %p\n",
+				vpu_reg_maps[i].base_addr,
+				vpu_reg_maps[i].p); */
+		}
+	}
+	return ret;
+}
+
+unsigned int vpu_hiu_read(unsigned int _reg)
+{
+	void __iomem *p;
+
+	if (vpu_chip_type >= VPU_CHIP_GXBB)
+		p = vpu_reg_maps[1].p + REG_OFFSET_HIU(_reg);
+	else
+		p = vpu_reg_maps[0].p + REG_OFFSET_CBUS(_reg);
+
+	return readl(p);
+};
+
+void vpu_hiu_write(unsigned int _reg, unsigned int _value)
+{
+	void __iomem *p;
+
+	if (vpu_chip_type >= VPU_CHIP_GXBB)
+		p = vpu_reg_maps[1].p + REG_OFFSET_HIU(_reg);
+	else
+		p = vpu_reg_maps[0].p + REG_OFFSET_CBUS(_reg);
+
+	writel(_value, p);
+};
+
+void vpu_hiu_setb(unsigned int _reg, unsigned int _value,
+		unsigned int _start, unsigned int _len)
+{
+	vpu_hiu_write(_reg, ((vpu_hiu_read(_reg) &
+			~(((1L << (_len))-1) << (_start))) |
+			(((_value)&((1L<<(_len))-1)) << (_start))));
+}
+
+unsigned int vpu_hiu_getb(unsigned int _reg,
+		unsigned int _start, unsigned int _len)
+{
+	return (vpu_hiu_read(_reg) >> (_start)) & ((1L << (_len)) - 1);
+}
+
+void vpu_hiu_set_mask(unsigned int _reg, unsigned int _mask)
+{
+	vpu_hiu_write(_reg, (vpu_hiu_read(_reg) | (_mask)));
+}
+
+void vpu_hiu_clr_mask(unsigned int _reg, unsigned int _mask)
+{
+	vpu_hiu_write(_reg, (vpu_hiu_read(_reg) & (~(_mask))));
+}
+
+unsigned int vpu_cbus_read(unsigned int _reg)
+{
+	void __iomem *p;
+
+	p = vpu_reg_maps[0].p + REG_OFFSET_CBUS(_reg);
+	return readl(p);
+};
+
+void vpu_cbus_write(unsigned int _reg, unsigned int _value)
+{
+	void __iomem *p;
+
+	p = vpu_reg_maps[0].p + REG_OFFSET_CBUS(_reg);
+	writel(_value, p);
+};
+
+void vpu_cbus_setb(unsigned int _reg, unsigned int _value,
+		unsigned int _start, unsigned int _len)
+{
+	vpu_cbus_write(_reg, ((vpu_cbus_read(_reg) &
+			~(((1L << (_len))-1) << (_start))) |
+			(((_value)&((1L<<(_len))-1)) << (_start))));
+}
+
+unsigned int vpu_cbus_getb(unsigned int _reg,
+		unsigned int _start, unsigned int _len)
+{
+	return (vpu_cbus_read(_reg) >> (_start)) & ((1L << (_len)) - 1);
+}
+
+void vpu_cbus_set_mask(unsigned int _reg, unsigned int _mask)
+{
+	vpu_cbus_write(_reg, (vpu_cbus_read(_reg) | (_mask)));
+}
+
+void vpu_cbus_clr_mask(unsigned int _reg, unsigned int _mask)
+{
+	vpu_cbus_write(_reg, (vpu_cbus_read(_reg) & (~(_mask))));
+}
+
+unsigned int vpu_vcbus_read(unsigned int _reg)
+{
+	void __iomem *p;
+
+	p = vpu_reg_maps[2].p + REG_OFFSET_VCBUS(_reg);
+	return readl(p);
+};
+
+void vpu_vcbus_write(unsigned int _reg, unsigned int _value)
+{
+	void __iomem *p;
+
+	p = vpu_reg_maps[2].p + REG_OFFSET_VCBUS(_reg);
+	writel(_value, p);
+};
+
+void vpu_vcbus_setb(unsigned int _reg, unsigned int _value,
+		unsigned int _start, unsigned int _len)
+{
+	vpu_vcbus_write(_reg, ((vpu_vcbus_read(_reg) &
+			~(((1L << (_len))-1) << (_start))) |
+			(((_value)&((1L<<(_len))-1)) << (_start))));
+}
+
+unsigned int vpu_vcbus_getb(unsigned int _reg,
+		unsigned int _start, unsigned int _len)
+{
+	return (vpu_vcbus_read(_reg) >> (_start)) & ((1L << (_len)) - 1);
+}
+
+void vpu_vcbus_set_mask(unsigned int _reg, unsigned int _mask)
+{
+	vpu_vcbus_write(_reg, (vpu_vcbus_read(_reg) | (_mask)));
+}
+
+void vpu_vcbus_clr_mask(unsigned int _reg, unsigned int _mask)
+{
+	vpu_vcbus_write(_reg, (vpu_vcbus_read(_reg) & (~(_mask))));
+}
+
diff --git a/drivers/amlogic/vpu/vpu_reg.h b/drivers/amlogic/vpu/vpu_reg.h
index 0150fb5f..d989faa 100644
--- a/drivers/amlogic/vpu/vpu_reg.h
+++ b/drivers/amlogic/vpu/vpu_reg.h
@@ -20,8 +20,8 @@
 #include <linux/amlogic/iomap.h>
 #include "vpu.h"
 
-extern void __iomem *reg_base_aobus;
-extern void __iomem *reg_base_cbus;
+/*extern void __iomem *reg_base_aobus;
+extern void __iomem *reg_base_cbus;*/
 
 /* ********************************
  * register define
@@ -33,7 +33,7 @@ extern void __iomem *reg_base_cbus;
 #define REG_BASE_VCBUS                  (0xd0100000L)
 #define REG_OFFSET_AOBUS(reg)           ((reg))
 #define REG_OFFSET_CBUS(reg)            ((reg << 2))
-#define REG_OFFSET_HIU(reg)             ((reg << 2))
+#define REG_OFFSET_HIU(reg)             (((reg & 0xff) << 2))
 #define REG_OFFSET_VCBUS(reg)           ((reg << 2))
 /* memory mapping */
 #define REG_ADDR_AOBUS(reg)             (REG_BASE_AOBUS + REG_OFFSET_AOBUS(reg))
@@ -92,158 +92,55 @@ extern void __iomem *reg_base_cbus;
 #define RESET6_LEVEL                    0x1126
 #define RESET7_LEVEL                    0x1127
 
-/* ********************************
- * register access api
- * ********************************* */
-enum vpu_chip_e vpu_chip_type;
-
-struct reg_map_s {
-	unsigned int base_addr;
-	unsigned int size;
-	void __iomem *p;
-	int flag;
-};
-
-static struct reg_map_s vpu_reg_maps[] = {
-	{ /* CBUS */
-		.base_addr = 0xc1100000,
-		.size = 0x10000,
-	},
-	{ /* HIU */
-		.base_addr = 0xc883c000,
-		.size = 0x400,
-	},
-	{ /* VCBUS */
-		.base_addr = 0xd0100000,
-		.size = 0x8000,
-	},
-};
-
-static inline int vpu_ioremap(void)
-{
-	int i;
-	int ret = 0;
-
-	for (i = 0; i < ARRAY_SIZE(vpu_reg_maps); i++) {
-		vpu_reg_maps[i].p = ioremap(vpu_reg_maps[i].base_addr,
-					vpu_reg_maps[i].size);
-		if (vpu_reg_maps[i].p == NULL) {
-			vpu_reg_maps[i].flag = 0;
-			VPUERR("VPU reg map failed: 0x%x\n",
-				vpu_reg_maps[i].base_addr);
-			ret = -1;
-		} else {
-			vpu_reg_maps[i].flag = 1;
-			/* VPUPR("VPU reg mapped: 0x%x -> %p\n",
-				vpu_reg_maps[i].base_addr,
-				vpu_reg_maps[i].p); */
-		}
-	}
-	return ret;
-}
-
-static inline unsigned int vpu_hiu_read(unsigned int _reg)
-{
-	void __iomem *p;
-
-	if (vpu_chip_type >= VPU_CHIP_GXBB)
-		p = vpu_reg_maps[1].p + REG_OFFSET_HIU(_reg);
-	else
-		p = vpu_reg_maps[0].p + REG_OFFSET_CBUS(_reg);
-
-	return readl(p);
-};
-
-static inline void vpu_hiu_write(unsigned int _reg, unsigned int _value)
-{
-	void __iomem *p;
-
-	if (vpu_chip_type >= VPU_CHIP_GXBB)
-		p = vpu_reg_maps[1].p + REG_OFFSET_HIU(_reg);
-	else
-		p = vpu_reg_maps[0].p + REG_OFFSET_CBUS(_reg);
-
-	writel(_value, p);
-};
-
-static inline void vpu_hiu_setb(unsigned int _reg, unsigned int _value,
-		unsigned int _start, unsigned int _len)
-{
-	vpu_hiu_write(_reg, ((vpu_hiu_read(_reg) &
-			~(((1L << (_len))-1) << (_start))) |
-			(((_value)&((1L<<(_len))-1)) << (_start))));
-}
-
-static inline unsigned int vpu_hiu_getb(unsigned int _reg,
-		unsigned int _start, unsigned int _len)
-{
-	return (vpu_hiu_read(_reg) >> (_start)) & ((1L << (_len)) - 1);
-}
-
-static inline void vpu_hiu_set_mask(unsigned int _reg, unsigned int _mask)
-{
-	vpu_hiu_write(_reg, (vpu_hiu_read(_reg) | (_mask)));
-}
-
-static inline void vpu_hiu_clr_mask(unsigned int _reg, unsigned int _mask)
-{
-	vpu_hiu_write(_reg, (vpu_hiu_read(_reg) & (~(_mask))));
-}
-
-static inline unsigned int vpu_cbus_read(unsigned int _reg)
-{
-	void __iomem *p;
-
-	p = vpu_reg_maps[0].p + REG_OFFSET_CBUS(_reg);
-	return readl(p);
-};
-
-static inline void vpu_cbus_write(unsigned int _reg, unsigned int _value)
-{
-	void __iomem *p;
-
-	p = vpu_reg_maps[0].p + REG_OFFSET_CBUS(_reg);
-	writel(_value, p);
-};
-
-static inline void vpu_cbus_setb(unsigned int _reg, unsigned int _value,
-		unsigned int _start, unsigned int _len)
-{
-	vpu_cbus_write(_reg, ((vpu_cbus_read(_reg) &
-			~(((1L << (_len))-1) << (_start))) |
-			(((_value)&((1L<<(_len))-1)) << (_start))));
-}
-
-static inline unsigned int vpu_cbus_getb(unsigned int _reg,
-		unsigned int _start, unsigned int _len)
-{
-	return (vpu_cbus_read(_reg) >> (_start)) & ((1L << (_len)) - 1);
-}
-
-static inline void vpu_cbus_set_mask(unsigned int _reg, unsigned int _mask)
-{
-	vpu_cbus_write(_reg, (vpu_cbus_read(_reg) | (_mask)));
-}
-
-static inline void vpu_cbus_clr_mask(unsigned int _reg, unsigned int _mask)
-{
-	vpu_cbus_write(_reg, (vpu_cbus_read(_reg) & (~(_mask))));
-}
-
-static inline unsigned int vpu_vcbus_read(unsigned int _reg)
-{
-	void __iomem *p;
-
-	p = vpu_reg_maps[2].p + REG_OFFSET_VCBUS(_reg);
-	return readl(p);
-};
-
-static inline void vpu_vcbus_write(unsigned int _reg, unsigned int _value)
-{
-	void __iomem *p;
-
-	p = vpu_reg_maps[2].p + REG_OFFSET_VCBUS(_reg);
-	writel(_value, p);
-};
+/* vpu clk gate */
+/* hiu_bus */
+#define HHI_GCLK_OTHER                  0x54
+/* vcbus */
+#define VPU_CLK_GATE                    0x2723
+
+#define VDIN0_OFFSET                    0x00
+#define VDIN1_OFFSET                    0x80
+#define VDIN_COM_GCLK_CTRL              0x121b
+#define VDIN_COM_GCLK_CTRL2             0x1270
+#define VDIN0_COM_GCLK_CTRL          ((VDIN0_OFFSET << 2) + VDIN_COM_GCLK_CTRL)
+#define VDIN0_COM_GCLK_CTRL2         ((VDIN0_OFFSET << 2) + VDIN_COM_GCLK_CTRL2)
+#define VDIN1_COM_GCLK_CTRL          ((VDIN1_OFFSET << 2) + VDIN_COM_GCLK_CTRL)
+#define VDIN1_COM_GCLK_CTRL2         ((VDIN1_OFFSET << 2) + VDIN_COM_GCLK_CTRL2)
+
+#define DI_CLKG_CTRL                               0x1718
+
+#define VPP_GCLK_CTRL0                             0x1d72
+#define VPP_GCLK_CTRL1                             0x1d73
+#define VPP_SC_GCLK_CTRL                           0x1d74
+#define VPP_SRSCL_GCLK_CTRL                        0x1d77
+#define VPP_OSDSR_GCLK_CTRL                        0x1d78
+#define VPP_XVYCC_GCLK_CTRL                        0x1d79
+
+extern unsigned int vpu_hiu_read(unsigned int _reg);
+extern void vpu_hiu_write(unsigned int _reg, unsigned int _value);
+extern void vpu_hiu_setb(unsigned int _reg, unsigned int _value,
+		unsigned int _start, unsigned int _len);
+extern unsigned int vpu_hiu_getb(unsigned int _reg,
+		unsigned int _start, unsigned int _len);
+extern void vpu_hiu_set_mask(unsigned int _reg, unsigned int _mask);
+extern void vpu_hiu_clr_mask(unsigned int _reg, unsigned int _mask);
+
+extern unsigned int vpu_cbus_read(unsigned int _reg);
+extern void vpu_cbus_write(unsigned int _reg, unsigned int _value);
+extern void vpu_cbus_setb(unsigned int _reg, unsigned int _value,
+		unsigned int _start, unsigned int _len);
+extern unsigned int vpu_cbus_getb(unsigned int _reg,
+		unsigned int _start, unsigned int _len);
+extern void vpu_cbus_set_mask(unsigned int _reg, unsigned int _mask);
+extern void vpu_cbus_clr_mask(unsigned int _reg, unsigned int _mask);
+
+extern unsigned int vpu_vcbus_read(unsigned int _reg);
+extern void vpu_vcbus_write(unsigned int _reg, unsigned int _value);
+extern void vpu_vcbus_setb(unsigned int _reg, unsigned int _value,
+		unsigned int _start, unsigned int _len);
+extern unsigned int vpu_vcbus_getb(unsigned int _reg,
+		unsigned int _start, unsigned int _len);
+extern void vpu_vcbus_set_mask(unsigned int _reg, unsigned int _mask);
+extern void vpu_vcbus_clr_mask(unsigned int _reg, unsigned int _mask);
 
 #endif
diff --git a/include/linux/amlogic/amports/amstream.h b/include/linux/amlogic/amports/amstream.h
index be43930..8e1aa0c 100644
--- a/include/linux/amlogic/amports/amstream.h
+++ b/include/linux/amlogic/amports/amstream.h
@@ -30,21 +30,25 @@
 #define PORT_FLAG_VID       0x0008
 #define PORT_FLAG_AID       0x0010
 #define PORT_FLAG_SID       0x0020
-#define PORT_FLAG_UD       0x0040
+#define PORT_FLAG_UD        0x0040
 #define PORT_FLAG_DRM       0x0080
 #define PORT_FLAG_ID        (PORT_FLAG_VID | \
 		PORT_FLAG_AID | PORT_FLAG_SID | PORT_FLAG_UD)
 #define PORT_FLAG_INITED    0x100
-#define PORT_TYPE_VIDEO     0x01
-#define PORT_TYPE_AUDIO     0x02
-#define PORT_TYPE_MPTS      0x04
-#define PORT_TYPE_MPPS      0x08
-#define PORT_TYPE_ES        0x10
-#define PORT_TYPE_RM        0x20
-#define PORT_TYPE_SUB       0x40
-#define PORT_TYPE_SUB_RD    0x80
-#define PORT_TYPE_HEVC      0x100
-#define PORT_TYPE_USERDATA	0x200
+
+#define PORT_TYPE_VIDEO         0x01
+#define PORT_TYPE_AUDIO         0x02
+#define PORT_TYPE_MPTS          0x04
+#define PORT_TYPE_MPPS          0x08
+#define PORT_TYPE_ES            0x10
+#define PORT_TYPE_RM            0x20
+#define PORT_TYPE_SUB           0x40
+#define PORT_TYPE_SUB_RD        0x80
+#define PORT_TYPE_HEVC          0x100
+#define PORT_TYPE_USERDATA      0x200
+#define PORT_TYPE_FRAME         0x400
+#define PORT_TYPE_DECODER_SCHED 0x800
+#define PORT_TYPE_DUALDEC       0x1000
 #endif				/*
  */
 #define _A_M  'S'
@@ -155,6 +159,9 @@
 #define AMSTREAM_IOC_GET_TRICK_VPTS _IOR((_A_M), 0xf0, int)
 #define AMSTREAM_IOC_DISABLE_SLOW_SYNC _IOW((_A_M), 0xf1, int)
 
+#define AMSTREAM_IOC_GET_AUDIO_CHECKIN_BITRATE_BPS _IOR((_A_M), 0xf2, int)
+#define AMSTREAM_IOC_GET_VIDEO_CHECKIN_BITRATE_BPS _IOR((_A_M), 0xf3, int)
+#define AMSTREAM_IOC_VDEC_RESET _IO((_A_M), 0xf4)
 #define AMSTREAM_IOC_GET_VERSION _IOR((_A_M), 0xc0, int)
 #define AMSTREAM_IOC_GET _IOWR((_A_M), 0xc1, struct am_ioctl_parm)
 #define AMSTREAM_IOC_SET _IOW((_A_M), 0xc2, struct am_ioctl_parm)
@@ -197,6 +204,16 @@ enum VIDEO_DEC_TYPE {
 	VIDEO_DEC_FORMAT_MAX
 };
 
+enum FRAME_BASE_VIDEO_PATH {
+	FRAME_BASE_PATH_IONVIDEO = 0,
+	FRAME_BASE_PATH_AMLVIDEO_AMVIDEO,
+	FRAME_BASE_PATH_AMLVIDEO1_AMVIDEO2,
+	FRAME_BASE_PATH_DI_AMVIDEO,
+	FRAME_BASE_PATH_AMVIDEO,
+	FRAME_BASE_PATH_AMVIDEO2,
+	FRAME_BASE_PATH_MAX
+};
+
 struct buf_status {
 
 	int size;
@@ -390,11 +407,13 @@ struct userdata_poc_info_t {
 #define AMSTREAM_SET_3D_TYPE 0x171
 #define AMSTREAM_SET_VSYNC_UPINT 0x172
 #define AMSTREAM_SET_VSYNC_SLOW_FACTOR 0x173
+#define AMSTREAM_SET_FRAME_BASE_PATH 0x174
 /*  video set ex cmd */
 #define AMSTREAM_SET_EX_VIDEO_AXIS 0x260
 #define AMSTREAM_SET_EX_VIDEO_CROP 0x261
 /*  amstream set ptr cmd */
 #define AMSTREAM_SET_PTR_AUDIO_INFO 0x300
+#define AMSTREAM_SET_PTR_CONFIGS 0x301
 
 /*  amstream get cmd */
 #define AMSTREAM_GET_SUB_LENGTH 0x800
@@ -415,6 +434,7 @@ struct userdata_poc_info_t {
 #define AMSTREAM_GET_VIDEO_CUR_DELAY_MS 0x80F
 #define AMSTREAM_GET_AUDIO_AVG_BITRATE_BPS 0x810
 #define AMSTREAM_GET_VIDEO_AVG_BITRATE_BPS 0x811
+#define AMSTREAM_GET_ION_ID 0x812
 /*  video get cmd */
 #define AMSTREAM_GET_OMX_VPTS 0x860
 #define AMSTREAM_GET_TRICK_STAT 0x861
@@ -452,6 +472,7 @@ struct am_ioctl_parm {
 		u64 data_64;
 		enum vformat_e data_vformat;
 		enum aformat_e data_aformat;
+		enum FRAME_BASE_VIDEO_PATH frame_base_video_path;
 		char data[8];
 	};
 	u32 cmd;
@@ -480,7 +501,7 @@ struct am_ioctl_parm_ptr {
 		char data[8];
 	};
 	u32 cmd;
-	char reserved[4];
+	u32 len; /*char reserved[4]; */
 };
 
 
@@ -489,7 +510,7 @@ int vcodec_profile_register(const struct codec_profile_t *vdec_profile);
 ssize_t vcodec_profile_read(char *buf);
 
 #ifdef __KERNEL__
-#ifdef ENABLE_DEMUX_DRIVER
+#include <linux/interrupt.h>
 /*TS demux operation interface*/
 struct tsdemux_ops {
 
@@ -517,10 +538,7 @@ struct tsdemux_ops {
 void tsdemux_set_ops(struct tsdemux_ops *ops);
 int tsdemux_set_reset_flag(void);
 
-#endif				/*ENABLE_DEMUX_DRIVER */
-void set_vdec_func(int (*vdec_func)(struct vdec_status *));
 void set_adec_func(int (*adec_func)(struct adec_status *));
-void set_trickmode_func(int (*trickmode_func)(unsigned long trickmode));
 void wakeup_sub_poll(void);
 void set_userdata_poc(struct userdata_poc_info_t poc);
 void init_userdata_fifo(void);
diff --git a/include/linux/amlogic/amports/ionvideo_ext.h b/include/linux/amlogic/amports/ionvideo_ext.h
new file mode 100644
index 0000000..852579e
--- /dev/null
+++ b/include/linux/amlogic/amports/ionvideo_ext.h
@@ -0,0 +1,10 @@
+#ifndef IONVIDEO_EXT_H
+#define IONVIDEO_EXT_H
+
+extern int ionvideo_assign_map(char **receiver_name, int *inst);
+
+extern int ionvideo_alloc_map(char **receiver_name, int *inst);
+
+extern void ionvideo_release_map(int inst);
+
+#endif /* IONVIDEO_EXT_H */
diff --git a/include/linux/amlogic/amports/vfm_ext.h b/include/linux/amlogic/amports/vfm_ext.h
new file mode 100644
index 0000000..48426f1
--- /dev/null
+++ b/include/linux/amlogic/amports/vfm_ext.h
@@ -0,0 +1,9 @@
+#ifndef VFM_EXT_H
+#define VFM_EXT_H
+
+extern int vfm_map_add(char *id, char *name_chain);
+
+extern int vfm_map_remove(char *id);
+
+#endif /* VFM_EXT_H */
+
diff --git a/include/linux/amlogic/amports/vframe.h b/include/linux/amlogic/amports/vframe.h
index af69132..077d7ba 100644
--- a/include/linux/amlogic/amports/vframe.h
+++ b/include/linux/amlogic/amports/vframe.h
@@ -20,6 +20,7 @@
 
 #include <linux/types.h>
 #include <linux/amlogic/tvin/tvin.h>
+#include <linux/amlogic/canvas/canvas.h>
 #include <linux/atomic.h>
 #include <linux/amlogic/iomap.h>
 
@@ -41,7 +42,9 @@
 #define VIDTYPE_PRE_INTERLACE           0x40000
 #define VIDTYPE_HIGHRUN                 0x80000
 #define VIDTYPE_COMPRESS                0x100000
-#define VIDTYPE_PIC		                0x200000
+#define VIDTYPE_PIC		        0x200000
+#define VIDTYPE_SCATTER                 0x400000
+#define VIDTYPE_VD2						0x800000
 
 #define DISP_RATIO_FORCECONFIG          0x80000000
 #define DISP_RATIO_FORCE_NORMALWIDE     0x40000000
@@ -55,8 +58,18 @@
 #define DISP_RATIO_ASPECT_RATIO_BIT     8
 #define DISP_RATIO_ASPECT_RATIO_MAX     0x3ff
 
+#define TB_DETECT_MASK    0x00000040
+#define TB_DETECT_MASK_BIT     6
+#define TB_DETECT_NONE          0
+#define TB_DETECT_INVERT       1
+#define TB_DETECT_NC               0
+#define TB_DETECT_TFF             1
+#define TB_DETECT_BFF             2
+#define TB_DETECT_TBF             3
+
 #define VFRAME_FLAG_NO_DISCONTINUE      1
 #define VFRAME_FLAG_SWITCHING_FENSE     2
+#define VFRAME_FLAG_HIGH_BANDWITH	4
 
 enum pixel_aspect_ratio_e {
 	PIXEL_ASPECT_RATIO_1_1,
@@ -122,11 +135,21 @@ struct vframe_view_s {
 	unsigned int height;
 } /*vframe_view_t */;
 
+#define SEI_ContentLightLevel 144
+struct vframe_content_light_level_s {
+	u32 present_flag;
+	u32 max_content;
+	u32 max_pic_average;
+}; /* content_light_level from SEI */
+
+#define SEI_MasteringDisplayColorVolume 137
 struct vframe_master_display_colour_s {
 	u32 present_flag;
 	u32 primaries[3][2];
 	u32 white_point[2];
 	u32 luminance[2];
+	struct vframe_content_light_level_s
+		content_light_level;
 }; /* master_display_colour_info_volume from SEI */
 
 /* vframe properties */
@@ -215,6 +238,10 @@ struct vframe_s {
 	u32 compHeadAddr;
 	u32 compBodyAddr;
 
+	u32 plane_num;
+	struct canvas_config_s canvas0_config[3];
+	struct canvas_config_s canvas1_config[3];
+
 	u32 bufWidth;
 	u32 width;
 	u32 height;
@@ -279,6 +306,11 @@ struct vframe_s {
 	 *1: process p from decoder as filed;
 	 *0: process p from decoder as frame*/
 	u32 prog_proc_config;
+	/* used for indicate current video is motion or static */
+	int combing_cur_lev;
+	/*for vframe's memory,
+	used by memory owner.*/
+	void *mem_handle;
 } /*vframe_t */;
 
 #if 0
diff --git a/include/linux/amlogic/amports/vframe_provider.h b/include/linux/amlogic/amports/vframe_provider.h
index dc623a6..bfa65c5 100644
--- a/include/linux/amlogic/amports/vframe_provider.h
+++ b/include/linux/amlogic/amports/vframe_provider.h
@@ -37,6 +37,18 @@ struct vframe_states {
 #define VFRAME_EVENT_RECEIVER_PARAM_SET	0x10
 #define VFRAME_EVENT_RECEIVER_RESET				0x20
 #define VFRAME_EVENT_RECEIVER_FORCE_UNREG			0x40
+#define VFRAME_EVENT_RECEIVER_GET_AUX_DATA			0x80
+
+	/* for VFRAME_EVENT_RECEIVER_GET_AUX_DATA*/
+struct provider_aux_req_s {
+	/*input*/
+	struct vframe_s *vf;
+	unsigned char bot_flag;
+	/*output*/
+	char *aux_buf;
+	int aux_size;
+	int dv_enhance_exist;
+};
 
 struct vframe_operations_s {
 	struct vframe_s * (*peek)(void *op_arg);
@@ -66,6 +78,8 @@ extern int vf_reg_provider(struct vframe_provider_s *prov);
 extern void vf_unreg_provider(struct vframe_provider_s *prov);
 extern int vf_notify_provider(const char *receiver_name, int event_type,
 			      void *data);
+extern int vf_notify_provider_by_name(const char *provider_name,
+				int event_type, void *data);
 
 void vf_light_unreg_provider(struct vframe_provider_s *prov);
 void vf_ext_light_unreg_provider(struct vframe_provider_s *prov);
@@ -76,8 +90,8 @@ struct vframe_s *vf_get(const char *receiver);
 void vf_put(struct vframe_s *vf, const char *receiver);
 
 unsigned int get_post_canvas(void);
-unsigned int vf_keep_current(void);
-void get_video_keep_buffer(unsigned long *addr, unsigned long *phys_addr);
+
+
 struct vframe_s *get_cur_dispbuf(void);
 int query_video_status(int type, int *value);
 
diff --git a/include/linux/amlogic/amports/video.h b/include/linux/amlogic/amports/video.h
index 3d91272..5384d87 100644
--- a/include/linux/amlogic/amports/video.h
+++ b/include/linux/amlogic/amports/video.h
@@ -19,18 +19,27 @@
 
 int VSYNC_WR_MPEG_REG(u32 adr, u32 val);
 int VSYNC_WR_MPEG_REG_BITS(u32 adr, u32 val,
-			   u32 start, u32 len);
+	u32 start, u32 len);
 u32 VSYNC_RD_MPEG_REG(u32 adr);
 u32 RDMA_READ_REG(u32 adr);
 int RDMA_SET_READ(u32 adr);
 #endif
 
-void try_free_keep_video(void);
+void try_free_keep_video(int flags);
 void vh265_free_cmabuf(void);
 void vh264_4k_free_cmabuf(void);
 void vdec_free_cmabuf(void);
 
+#define AMVIDEO_UPDATE_OSD_MODE	0x00000001
 
+#ifdef CONFIG_AM_VIDEO
+int amvideo_notifier_call_chain(unsigned long val, void *v);
+#else
+static inline int amvideo_notifier_call_chain(unsigned long val, void *v)
+{
+	return 0;
+}
+#endif
 #endif
 
 
diff --git a/include/linux/amlogic/amvecm/amvecm.h b/include/linux/amlogic/amvecm/amvecm.h
index eee4e9f..42141e7 100644
--- a/include/linux/amlogic/amvecm/amvecm.h
+++ b/include/linux/amlogic/amvecm/amvecm.h
@@ -27,7 +27,7 @@
 /* struct ve_dnlp_s          video_ve_dnlp; */
 
 #define FLAG_RSV31              (1 << 31)
-#define FLAG_RSV30              (1 << 30)
+#define FLAG_VADJ1_COLOR        (1 << 30)
 #define FLAG_VE_DNLP            (1 << 29)
 #define FLAG_VE_NEW_DNLP        (1 << 28)
 #define FLAG_RSV27              (1 << 27)
@@ -64,6 +64,11 @@
 #define VPP_VADJ1_BLMINUS_EN        (1 << 1)
 #define VPP_VADJ1_EN                (1 << 0)
 
+#define VPP_DEMO_DNLP_DIS           (1 << 3)
+#define VPP_DEMO_DNLP_EN            (1 << 2)
+#define VPP_DEMO_CM_DIS             (1 << 1)
+#define VPP_DEMO_CM_EN              (1 << 0)
+
 #define _VE_CM  'C'
 
 #define AMVECM_IOC_VE_DNLP      _IOW(_VE_CM, 0x21, struct ve_dnlp_s)
@@ -72,6 +77,7 @@
 #define AMVECM_IOC_VE_DNLP_DIS  _IO(_VE_CM, 0x24)
 #define AMVECM_IOC_VE_NEW_DNLP  _IOW(_VE_CM, 0x25, struct ve_dnlp_table_s)
 #define AMVECM_IOC_G_HIST_BIN   _IOW(_VE_CM, 0x26, struct vpp_hist_param_s)
+#define AMVECM_IOC_G_HDR_METADATA _IOW(_VE_CM, 0x27, struct hdr_metadata_info_s)
 
 
 /* VPP.CM IOCTL command list */
@@ -87,6 +93,14 @@
 #define AMVECM_IOC_S_RGB_OGO   _IOW(_VE_CM, 0x45, struct tcon_rgb_ogo_s)
 #define AMVECM_IOC_G_RGB_OGO  _IOR(_VE_CM, 0x46, struct tcon_rgb_ogo_s)
 
+/*VPP.VLOCK IOCTL command list*/
+#define AMVECM_IOC_VLOCK_EN  _IO(_VE_CM, 0x47)
+#define AMVECM_IOC_VLOCK_DIS _IO(_VE_CM, 0x48)
+
+/*VPP.3D-SYNC IOCTL command list*/
+#define AMVECM_IOC_3D_SYNC_EN  _IO(_VE_CM, 0x49)
+#define AMVECM_IOC_3D_SYNC_DIS _IO(_VE_CM, 0x50)
+
 /* #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8) */
 /* #define WRITE_VPP_REG(x,val)
  * WRITE_VCBUS_REG(x,val) */
@@ -146,5 +160,33 @@ extern void amvecm_on_vs(struct vframe_s *vf);
 extern void refresh_on_vs(struct vframe_s *vf);
 extern void pc_mode_process(void);
 
+/* master_display_info for display device */
+struct hdr_metadata_info_s {
+	u32 primaries[3][2];		/* normalized 50000 in G,B,R order */
+	u32 white_point[2];		/* normalized 50000 */
+	u32 luminance[2];		/* max/min lumin, normalized 10000 */
+};
+
+extern void vpp_vd_adj1_saturation_hue(signed int sat_val,
+	signed int hue_val, struct vframe_s *vf);
+
+extern int metadata_read_u32(uint32_t *value);
+extern int metadata_wait(struct vframe_s *vf);
+extern int metadata_sync(uint32_t frame_id, uint64_t pts);
+
+extern void enable_dolby_vision(int enable);
+extern bool is_dolby_vision_enable(void);
+extern bool is_dolby_vision_on(void);
+extern void set_dolby_vision_mode(int mode);
+extern int get_dolby_vision_mode(void);
+extern void dolby_vision_set_toggle_flag(int flag);
+extern int dolby_vision_wait_metadata(struct vframe_s *vf);
+extern int dolby_vision_pop_metadata(void);
+extern int dolby_vision_update_metadata(struct vframe_s *vf);
+extern int dolby_vision_process(struct vframe_s *vf);
+extern void dolby_vision_init_receiver(void);
+extern void dolby_vision_vf_put(struct vframe_s *vf);
+struct vframe_s *dolby_vision_vf_peek_el(struct vframe_s *vf);
+
 #endif /* AMVECM_H */
 
diff --git a/include/linux/amlogic/amvecm/ve.h b/include/linux/amlogic/amvecm/ve.h
index dfee37c..6a4111b 100644
--- a/include/linux/amlogic/amvecm/ve.h
+++ b/include/linux/amlogic/amvecm/ve.h
@@ -280,6 +280,9 @@ struct ve_regmap_s {
 	unsigned long reg[43];
 };
 
+#define EOTF_LUT_SIZE 33
+#define OSD_OETF_LUT_SIZE 41
+
 /********************OSD HDR registers backup********************************/
 struct hdr_osd_lut_s {
 	uint32_t r_map[33];
diff --git a/include/linux/amlogic/canvas/canvas.h b/include/linux/amlogic/canvas/canvas.h
index 9d8a6db..5d42358 100644
--- a/include/linux/amlogic/canvas/canvas.h
+++ b/include/linux/amlogic/canvas/canvas.h
@@ -35,6 +35,14 @@ struct canvas_s {
 	u32 dataH;
 };
 
+struct canvas_config_s {
+	u32 phy_addr;
+	u32 width;
+	u32 height;
+	u32 block_mode;
+	u32 endian;
+};
+
 #define CANVAS_ADDR_NOWRAP      0x00
 #define CANVAS_ADDR_WRAPX       0x01
 #define CANVAS_ADDR_WRAPY       0x02
@@ -53,6 +61,16 @@ struct canvas_s {
 #define PPMGR2_MAX_CANVAS 8
 #define PPMGR2_CANVAS_INDEX 0x70    /* 0x70-0x7f for PPMGR2 (IONVIDEO)/ */
 
+/* the following reserved canvas index value
+ * should match the configurations defined
+ * in canvas_mgr.c canvas_pool_config().
+ */
+#define AMVDEC_CANVAS_MAX1        0xbf
+#define AMVDEC_CANVAS_MAX2        0x25
+#define AMVDEC_CANVAS_START_INDEX 0x78
+
+extern void canvas_config_config(u32 index, struct canvas_config_s *cfg);
+
 extern void canvas_config(u32 index, ulong addr, u32 width, u32 height,
 			  u32 wrap, u32 blkmode);
 
diff --git a/include/linux/amlogic/codec_mm/codec_mm.h b/include/linux/amlogic/codec_mm/codec_mm.h
index 8401da9..56e282a 100644
--- a/include/linux/amlogic/codec_mm/codec_mm.h
+++ b/include/linux/amlogic/codec_mm/codec_mm.h
@@ -19,6 +19,9 @@
 #ifndef CODEC_MM_API_HEADER
 #define CODEC_MM_API_HEADER
 #include <linux/dma-direction.h>
+#include <linux/atomic.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
 
 /*
 memflags
@@ -51,7 +54,10 @@ clear thie buffer cache.
 /*used in codec_mm owner.
 don't not set on others.
 */
-#define CODEC_MM_FLAGS_FOR_TVP_POOL 0x8000000
+#define CODEC_MM_FLAGS_FOR_LOCAL_MGR  0x8000000
+/*used scatter manager
+*/
+#define CODEC_MM_FLAGS_FOR_SCATTER  0x10000000
 
 #define CODEC_MM_FLAGS_FROM_MASK \
 	(CODEC_MM_FLAGS_DMA |\
@@ -61,9 +67,55 @@ don't not set on others.
 #define CODEC_MM_FLAGS_DMA_CPU  (CODEC_MM_FLAGS_DMA | CODEC_MM_FLAGS_CPU)
 #define CODEC_MM_FLAGS_ANY	CODEC_MM_FLAGS_DMA_CPU
 
-
-
-
+/*--------------------------------------------------*/
+struct codec_mm_s {
+	/*can be shared by many user */
+	const char *owner[8];
+	/*virtual buffer of this memory */
+	char *vbuffer;
+	void *mem_handle;	/*used for top level.alloc/free */
+	void *from_ext;		/*alloced from pool*/
+	ulong phy_addr;		/*if phy continue or one page only */
+	int buffer_size;
+	int page_count;
+	int align2n;
+	/*if vbuffer is no cache set
+	   AMPORTS_MEM_FLAGS_NOCACHED  to flags */
+#define AMPORTS_MEM_FLAGS_NOCACHED (1<<0)
+	/*phy continue,need dma
+	 */
+#define AMPORTS_MEM_FLAGS_DMA (1<<1)
+	int flags;
+#define AMPORTS_MEM_FLAGS_FROM_SYS 1
+#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_PAGES 2
+#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED 3
+#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA 4
+#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_TVP 5
+#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA_RES 6
+	int from_flags;
+	/*may can be shared on many user..
+	   decoder/di/ppmgr,
+	 */
+	atomic_t use_cnt;
+	spinlock_t lock;
+	char *pagemap;
+	int pagemap_size;
+	int alloced_page_num;
+	int mem_id;
+	int next_bit;
+	struct list_head list;
+};
+
+struct codec_mm_s *codec_mm_alloc(const char *owner, int size,
+		int align2n, int memflags);
+void codec_mm_release(struct codec_mm_s *mem, const char *owner);
+int codec_mm_request_shared_mem(struct codec_mm_s *mem, const char *owner);
+/*call if not make sure valid data.*/
+void codec_mm_release_with_check(struct codec_mm_s *mem, const char *owner);
+
+
+
+/*---------------------------------------------------------------*/
 
 unsigned long codec_mm_alloc_for_dma(const char *owner, int page_cnt,
 	int align2n, int memflags);
@@ -82,7 +134,7 @@ void codec_mm_dma_flush(void *vaddr,
 int codec_mm_get_total_size(void);
 int codec_mm_get_free_size(void);
 int codec_mm_get_reserved_size(void);
-int codec_mm_enough_for_size(int size);
+int codec_mm_enough_for_size(int size, int with_wait);
 int codec_mm_video_tvp_enabled(void);
 
 
diff --git a/include/linux/amlogic/codec_mm/codec_mm_keeper.h b/include/linux/amlogic/codec_mm/codec_mm_keeper.h
new file mode 100644
index 0000000..843fa2a
--- /dev/null
+++ b/include/linux/amlogic/codec_mm/codec_mm_keeper.h
@@ -0,0 +1,34 @@
+/*
+ * include/linux/amlogic/codec_mm/codec_mm_keeper.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+#ifndef CODEC_MM_KEEPER_HEADER
+#define CODEC_MM_KEEPER_HEADER
+
+#define MEM_TYPE_CODEC_MM			111
+#define MEM_TYPE_CODEC_MM_SCATTER	222
+
+/*
+don't call in interrupt;
+*/
+int codec_mm_keeper_mask_keep_mem(void *mem_handle, int type);
+
+/*
+can call in irq
+*/
+int codec_mm_keeper_unmask_keeper(int keep_id, int delayms);
+
+#endif				/*
+				 */
diff --git a/include/linux/amlogic/codec_mm/codec_mm_scatter.h b/include/linux/amlogic/codec_mm/codec_mm_scatter.h
new file mode 100644
index 0000000..ac44590
--- /dev/null
+++ b/include/linux/amlogic/codec_mm/codec_mm_scatter.h
@@ -0,0 +1,73 @@
+
+/*
+ * include/linux/amlogic/codec_mm/codec_mm_scatter.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+
+#ifndef CODEC_MM_SCATTER_HEADER
+#define CODEC_MM_SCATTER_HEADER
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+
+
+/*#define PHY_ADDR_NEED_64BITS*/
+#ifdef PHY_ADDR_NEED_64BITS
+#define phy_addr_type u64
+#else				/* */
+#define phy_addr_type u32
+#endif
+#define page_sid_type u16
+
+#define PAGE_INDEX(page) (page >> PAGE_SHIFT)
+
+struct codec_mm_scatter {
+	phy_addr_type *pages_list;
+	int page_max_cnt;
+	int page_cnt;		/*page num */
+	int page_tail;		/*last page in list */
+	int page_used;
+	spinlock_t lock;
+	atomic_t user_cnt;
+	unsigned long tofree_jiffies;
+	struct mutex mutex;
+	struct list_head list;/*hold list.*/
+};
+
+
+
+int codec_mm_scatter_free_all_pages(struct codec_mm_scatter *mms);
+
+int codec_mm_scatter_free_tail_pages(struct codec_mm_scatter *mms,
+		int start_free_id);
+int codec_mm_scatter_free_tail_pages_fast(struct codec_mm_scatter *mms,
+		int start_free_id);
+int codec_mm_scatter_free_tail_pages_fast(struct codec_mm_scatter *mms,
+				int start_free_id);
+
+struct codec_mm_scatter *codec_mm_scatter_alloc(int max_page, int page_num);
+int codec_mm_scatter_alloc_want_pages(struct codec_mm_scatter *mms,
+			int want_pages);
+int codec_mm_scatter_mgt_delay_free_swith(int on, int delay_ms,
+	int wait_size_M);
+int codec_mm_dump_scatter(struct codec_mm_scatter *mms, void *buf, int size);
+int codec_mm_scatter_dec_owner_user(void *sc_mm, int delay_ms);
+
+
+#endif
+
diff --git a/include/linux/amlogic/ge2d/ge2d.h b/include/linux/amlogic/ge2d/ge2d.h
index 76be3af..974bd02 100644
--- a/include/linux/amlogic/ge2d/ge2d.h
+++ b/include/linux/amlogic/ge2d/ge2d.h
@@ -117,10 +117,14 @@
 #define FILTER_TYPE_BICUBIC     1
 #define FILTER_TYPE_BILINEAR    2
 #define FILTER_TYPE_TRIANGLE    3
+#define FILTER_TYPE_GAU0    4
+#define FILTER_TYPE_GAU0_BOT    5
+#define FILTER_TYPE_GAU1    6
 
 #define MATRIX_YCC_TO_RGB               1
 #define MATRIX_RGB_TO_YCC               2
 #define MATRIX_FULL_RANGE_YCC_TO_RGB    3
+#define MATRIX_RGB_TO_FULL_RANGE_YCC    4
 
 
 #define GE2D_ENDIAN_SHIFT	24
@@ -133,6 +137,15 @@
 /* nv12 &nv21, only works on m6*/
 #define GE2D_COLOR_MAP_NV12		(15 << GE2D_COLOR_MAP_SHIFT)
 #define GE2D_COLOR_MAP_NV21		(14 << GE2D_COLOR_MAP_SHIFT)
+
+/* deep color, only works after TXL */
+#define GE2D_COLOR_MAP_10BIT_YUV444		(0 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_10BIT_VUY444		(5 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_10BIT_YUV422		(0 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_10BIT_YVU422		(1 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_12BIT_YUV422		(8 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_12BIT_YVU422		(9 << GE2D_COLOR_MAP_SHIFT)
+
 /* 16 bit */
 #define GE2D_COLOR_MAP_YUV422		(0 << GE2D_COLOR_MAP_SHIFT)
 #define GE2D_COLOR_MAP_RGB655		(1 << GE2D_COLOR_MAP_SHIFT)
@@ -175,8 +188,9 @@
 #define GE2D_COLOR_MAP_VUYA8888     (3 << GE2D_COLOR_MAP_SHIFT)
 
 /* format code is defined as:
-[11] : 1-YUV color space, 0-RGB color space
-[10] : compress_range
+[18] : 1-deep color mode(10/12 bit), 0-8bit mode
+[17] : 1-YUV color space, 0-RGB color space
+[16] : compress_range
 [9:8]: format
 [7:6]: 8bit_mode_sel
 [5]  : LUT_EN
@@ -190,8 +204,11 @@
 #define GE2D_BPP_16BIT                  0x00100
 #define GE2D_BPP_24BIT                  0x00200
 #define GE2D_BPP_32BIT                  0x00300
+#define GE2D_FORMAT_DEEP_COLOR   0x40000
 #define GE2D_FORMAT_YUV                 0x20000
 #define GE2D_FORMAT_COMP_RANGE          0x10000
+
+
 /*bit8(2)  format   bi6(2) mode_8b_sel  bit5(1)lut_en   bit2 sep_en*/
 /*M  seperate block S one block.*/
 
@@ -227,6 +244,20 @@
 #define GE2D_FMT_S24_YUV444T	0x20210 /* 10_00_0_10_0_00 */
 #define GE2D_FMT_S24_YUV444B	0x20218 /* 10_00_0_11_0_00 */
 
+/* only works after TXL and for src1. */
+#define GE2D_FMT_S24_10BIT_YUV444		0x60200
+#define GE2D_FMT_S24_10BIT_YUV444T		0x60210
+#define GE2D_FMT_S24_10BIT_YUV444B		0x60218
+
+#define GE2D_FMT_S16_10BIT_YUV422		0x60102
+#define GE2D_FMT_S16_10BIT_YUV422T		0x60112
+#define GE2D_FMT_S16_10BIT_YUV422B		0x6011a
+
+#define GE2D_FMT_S16_12BIT_YUV422		0x60102
+#define GE2D_FMT_S16_12BIT_YUV422T		0x60112
+#define GE2D_FMT_S16_12BIT_YUV422B		0x6011a
+
+
 /* back compatible defines */
 #define GE2D_FORMAT_S8_Y            (GE2D_FORMAT_YUV|GE2D_FMT_S8_Y)
 #define GE2D_FORMAT_S8_CB          (GE2D_FORMAT_YUV|GE2D_FMT_S8_CB)
@@ -282,6 +313,25 @@
 #define GE2D_FORMAT_S32_ABGR (GE2D_FMT_S32_RGBA | GE2D_COLOR_MAP_ABGR8888)
 #define GE2D_FORMAT_S32_BGRA (GE2D_FMT_S32_RGBA | GE2D_COLOR_MAP_BGRA8888)
 
+/* format added in TXL */
+#define GE2D_FORMAT_S24_10BIT_YUV444 \
+	(GE2D_FMT_S24_10BIT_YUV444 | GE2D_COLOR_MAP_10BIT_YUV444)
+
+#define GE2D_FORMAT_S24_10BIT_VUY444 \
+	(GE2D_FMT_S24_10BIT_YUV444 | GE2D_COLOR_MAP_10BIT_VUY444)
+
+#define GE2D_FORMAT_S16_10BIT_YUV422 \
+	(GE2D_FMT_S16_10BIT_YUV422 | GE2D_COLOR_MAP_10BIT_YUV422)
+
+#define GE2D_FORMAT_S16_10BIT_YVU422 \
+	(GE2D_FMT_S16_10BIT_YUV422 | GE2D_COLOR_MAP_10BIT_YVU422)
+
+#define GE2D_FORMAT_S16_12BIT_YUV422 \
+	(GE2D_FMT_S16_12BIT_YUV422 | GE2D_COLOR_MAP_12BIT_YUV422)
+
+#define GE2D_FORMAT_S16_12BIT_YVU422 \
+	(GE2D_FMT_S16_12BIT_YUV422 | GE2D_COLOR_MAP_12BIT_YVU422)
+
 
 #define	UPDATE_SRC_DATA     0x01
 #define	UPDATE_SRC_GEN      0x02
@@ -331,6 +381,7 @@ struct ge2d_src1_data_s {
 
 	unsigned char     mode_8b_sel;
 	unsigned char     lut_en;
+	unsigned char     deep_color;
 	unsigned int      def_color;
 	unsigned int      format_all;
 };
@@ -572,6 +623,7 @@ struct ge2d_context_s {
 	wait_queue_head_t	cmd_complete;
 	int				queue_dirty;
 	int				queue_need_recycle;
+	int				ge2d_request_exit;
 	spinlock_t		lock;	/* for get and release item. */
 };
 
@@ -752,6 +804,102 @@ struct compat_config_para_ex_s {
 };
 #endif
 
+struct config_planes_ion_s {
+	unsigned long addr;
+	unsigned int w;
+	unsigned int h;
+	int shared_fd;
+};
+
+#ifdef CONFIG_COMPAT
+struct compat_config_planes_ion_s {
+	compat_uptr_t addr;
+	unsigned int w;
+	unsigned int h;
+	int shared_fd;
+};
+#endif
+
+struct config_para_ex_ion_s {
+	struct src_dst_para_ex_s src_para;
+	struct src_dst_para_ex_s src2_para;
+	struct src_dst_para_ex_s dst_para;
+
+	/* key mask */
+	struct src_key_ctrl_s  src_key;
+	struct src_key_ctrl_s  src2_key;
+
+	int alu_const_color;
+	unsigned src1_gb_alpha;
+	unsigned op_mode;
+	unsigned char bitmask_en;
+	unsigned char bytemask_only;
+	unsigned int  bitmask;
+	unsigned char dst_xy_swap;
+
+	/* scaler and phase releated */
+	unsigned hf_init_phase;
+	int hf_rpt_num;
+	unsigned hsc_start_phase_step;
+	int hsc_phase_slope;
+	unsigned vf_init_phase;
+	int vf_rpt_num;
+	unsigned vsc_start_phase_step;
+	int vsc_phase_slope;
+	unsigned char src1_vsc_phase0_always_en;
+	unsigned char src1_hsc_phase0_always_en;
+	/* 1bit, 0: using minus, 1: using repeat data */
+	unsigned char src1_hsc_rpt_ctrl;
+	/* 1bit, 0: using minus  1: using repeat data */
+	unsigned char src1_vsc_rpt_ctrl;
+
+	/* canvas info */
+	struct config_planes_ion_s src_planes[4];
+	struct config_planes_ion_s src2_planes[4];
+	struct config_planes_ion_s dst_planes[4];
+};
+
+#ifdef CONFIG_COMPAT
+struct compat_config_para_ex_ion_s {
+	struct src_dst_para_ex_s src_para;
+	struct src_dst_para_ex_s src2_para;
+	struct src_dst_para_ex_s dst_para;
+
+	/* key mask */
+	struct src_key_ctrl_s  src_key;
+	struct src_key_ctrl_s  src2_key;
+
+	int alu_const_color;
+	unsigned src1_gb_alpha;
+	unsigned op_mode;
+	unsigned char bitmask_en;
+	unsigned char bytemask_only;
+	unsigned int  bitmask;
+	unsigned char dst_xy_swap;
+
+	/* scaler and phase releated */
+	unsigned hf_init_phase;
+	int hf_rpt_num;
+	unsigned hsc_start_phase_step;
+	int hsc_phase_slope;
+	unsigned vf_init_phase;
+	int vf_rpt_num;
+	unsigned vsc_start_phase_step;
+	int vsc_phase_slope;
+	unsigned char src1_vsc_phase0_always_en;
+	unsigned char src1_hsc_phase0_always_en;
+	/* 1bit, 0: using minus, 1: using repeat data */
+	unsigned char src1_hsc_rpt_ctrl;
+	/* 1bit, 0: using minus  1: using repeat data */
+	unsigned char src1_vsc_rpt_ctrl;
+
+	/* canvas info */
+	struct compat_config_planes_ion_s src_planes[4];
+	struct compat_config_planes_ion_s src2_planes[4];
+	struct compat_config_planes_ion_s dst_planes[4];
+};
+#endif
+
 #define GE2D_IOC_MAGIC  'G'
 
 #define GE2D_CONFIG		_IOW(GE2D_IOC_MAGIC, 0x00, struct config_para_s)
@@ -767,6 +915,23 @@ struct compat_config_para_ex_s {
 	_IOW(GE2D_IOC_MAGIC, 0x01,  struct compat_config_para_ex_s)
 #endif
 
+
+#define	GE2D_SRCCOLORKEY     _IOW(GE2D_IOC_MAGIC, 0x02, struct config_para_s)
+
+#ifdef CONFIG_COMPAT
+#define	GE2D_SRCCOLORKEY32   \
+	_IOW(GE2D_IOC_MAGIC, 0x02, struct compat_config_para_s)
+#endif
+
+
+#define GE2D_CONFIG_EX_ION	 \
+	_IOW(GE2D_IOC_MAGIC, 0x03,  struct config_para_ex_ion_s)
+
+#ifdef CONFIG_COMPAT
+#define GE2D_CONFIG_EX32_ION  \
+	_IOW(GE2D_IOC_MAGIC, 0x03,  struct compat_config_para_ex_ion_s)
+#endif
+
 extern void ge2d_set_src1_data(struct ge2d_src1_data_s *cfg);
 extern void ge2d_set_src1_gen(struct ge2d_src1_gen_s *cfg);
 extern void ge2d_set_src2_dst_data(struct ge2d_src2_dst_data_s *cfg);
@@ -785,6 +950,8 @@ extern int ge2d_context_config(struct ge2d_context_s *context,
 			       struct config_para_s *ge2d_config);
 extern int ge2d_context_config_ex(struct ge2d_context_s *context,
 				  struct config_para_ex_s *ge2d_config);
+extern int ge2d_context_config_ex_ion(struct ge2d_context_s *context,
+			   struct config_para_ex_ion_s *ge2d_config);
 extern struct ge2d_context_s *create_ge2d_work_queue(void);
 extern int destroy_ge2d_work_queue(struct ge2d_context_s *);
 extern int ge2d_wq_remove_config(struct ge2d_context_s *wq);
diff --git a/include/linux/amlogic/ge2d/ge2d_cmd.h b/include/linux/amlogic/ge2d/ge2d_cmd.h
index 671d2cc..df1f87c 100644
--- a/include/linux/amlogic/ge2d/ge2d_cmd.h
+++ b/include/linux/amlogic/ge2d/ge2d_cmd.h
@@ -20,6 +20,8 @@
 #ifndef _GE2D_CMD_H_
 #define _GE2D_CMD_H_
 
+#define GE2D_BLEND_NOALPHA_NOBLOCK          0x470a
+#define GE2D_BLEND_NOALPHA                  0x4709
 #define	GE2D_STRETCHBLIT_NOALPHA_NOBLOCK    0x4708
 #define	GE2D_BLIT_NOALPHA_NOBLOCK           0x4707
 #define	GE2D_BLEND_NOBLOCK                  0x4706
@@ -34,10 +36,10 @@
 #define	GE2D_BLIT                           0x46ff
 #define	GE2D_STRETCHBLIT                    0x46fe
 #define	GE2D_FILLRECTANGLE                  0x46fd
-#define	GE2D_SRCCOLORKEY                    0x46fc
+#define	GE2D_SRCCOLORKEY_OLD                0x46fc
 #define	GE2D_SET_COEF                       0x46fb
-/* #define	GE2D_CONFIG_EX                      0x46fa */
-/* #define	GE2D_CONFIG                         0x46f9 */
+#define	GE2D_CONFIG_EX_OLD                  0x46fa
+#define	GE2D_CONFIG_OLD                     0x46f9
 #define	GE2D_ANTIFLICKER_ENABLE             0x46f8
 
 #endif
diff --git a/include/linux/amlogic/ge2d/ge2d_func.h b/include/linux/amlogic/ge2d/ge2d_func.h
index b350792..e1870e6 100644
--- a/include/linux/amlogic/ge2d/ge2d_func.h
+++ b/include/linux/amlogic/ge2d/ge2d_func.h
@@ -112,4 +112,16 @@ void blend_noblk(struct ge2d_context_s *wq,
 		 int dst_x, int dst_y, int dst_w, int dst_h,
 		 int op);
 
+void blend_noalpha(struct ge2d_context_s *wq,
+	   int src_x, int src_y, int src_w, int src_h,
+	   int src2_x, int src2_y, int src2_w, int src2_h,
+	   int dst_x, int dst_y, int dst_w, int dst_h,
+	   int op);
+
+void blend_noalpha_noblk(struct ge2d_context_s *wq,
+	   int src_x, int src_y, int src_w, int src_h,
+	   int src2_x, int src2_y, int src2_w, int src2_h,
+	   int dst_x, int dst_y, int dst_w, int dst_h,
+	   int op);
+
 #endif
diff --git a/include/linux/amlogic/hdmi_tx/hdmi_common.h b/include/linux/amlogic/hdmi_tx/hdmi_common.h
index dcb4e0c..dbc32e4 100644
--- a/include/linux/amlogic/hdmi_tx/hdmi_common.h
+++ b/include/linux/amlogic/hdmi_tx/hdmi_common.h
@@ -214,6 +214,7 @@ enum hdmi_audio_fs;
 /* CEA TIMING STRUCT DEFINITION */
 struct hdmi_cea_timing {
 	unsigned int pixel_freq; /* Unit: 1000 */
+	unsigned int frac_freq; /* 1.001 shift */
 	unsigned int h_freq; /* Unit: Hz */
 	unsigned int v_freq; /* Unit: 0.001 Hz */
 	unsigned int vsync_polarity:1;
@@ -253,6 +254,19 @@ enum hdmi_color_range {
 	COLORRANGE_FUL,
 };
 
+enum hdmi_3d_type {
+	T3D_FRAME_PACKING = 0,
+	T3D_FIELD_ALTER = 1,
+	T3D_LINE_ALTER = 2,
+	T3D_SBS_FULL = 3,
+	T3D_L_DEPTH = 4,
+	T3D_L_DEPTH_GRAPHICS = 5,
+	T3D_TAB = 6, /* Top and Buttom */
+	T3D_RSVD = 7,
+	T3D_SBS_HALF = 8,
+	T3D_DISABLE,
+};
+
 /* get hdmi cea timing */
 /* t: struct hdmi_cea_timing * */
 #define GET_TIMING(name)      (t->name)
@@ -332,7 +346,10 @@ unsigned int hdmi_get_csc_coef(
 	unsigned int input_format, unsigned int output_format,
 	unsigned int color_depth, unsigned int color_format,
 	unsigned char **coef_array, unsigned int *coef_length);
-struct hdmi_format_para *hdmi_get_fmt_name(char const *name);
+struct hdmi_format_para *hdmi_get_fmt_name(char const *name, char const *attr);
+const char *hdmi_get_str_cd(struct hdmi_format_para *para);
+const char *hdmi_get_str_cs(struct hdmi_format_para *para);
+const char *hdmi_get_str_cr(struct hdmi_format_para *para);
 unsigned int hdmi_get_aud_n_paras(enum hdmi_audio_fs fs,
 	enum hdmi_color_depth cd, unsigned int tmds_clk);
 
@@ -503,7 +520,7 @@ struct hdmi_rx_audioinfo {
 	unsigned CTS;
 };
 
-#define AUDIO_PARA_MAX_NUM       13
+#define AUDIO_PARA_MAX_NUM       14
 struct hdmi_audio_fs_ncts {
 	struct {
 		unsigned int tmds_clk;
diff --git a/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h b/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h
index 7b2bb2c..5ef19e2 100644
--- a/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h
+++ b/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h
@@ -25,6 +25,7 @@
 #include <linux/clk-private.h>
 #include <linux/clk-provider.h>
 #include <linux/device.h>
+#include <linux/amlogic/vout/vinfo.h>
 /* #include <linux/amlogic/aml_gpio_consumer.h> */
 
 /*****************************
@@ -63,7 +64,9 @@ struct rx_cap {
 	unsigned char RxSpeakerAllocation;
 	/*vendor*/
 	unsigned int IEEEOUI;
+	unsigned int Max_TMDS_Clock1; /* HDMI1.4b TMDS_CLK */
 	unsigned int HF_IEEEOUI;	/* For HDMI Forum */
+	unsigned int Max_TMDS_Clock2; /* HDMI2.0 TMDS_CLK */
 	/* CEA861-F, Table 56, Colorimetry Data Block */
 	unsigned int colorimetry_data;
 	unsigned int scdc_present:1;
@@ -91,7 +94,6 @@ struct rx_cap {
 	unsigned char edid_version;
 	unsigned char edid_revision;
 	unsigned int ColorDeepSupport;
-	unsigned int Max_TMDS_Clock;
 	unsigned int Video_Latency;
 	unsigned int Audio_Latency;
 	unsigned int Interlaced_Video_Latency;
@@ -107,6 +109,7 @@ struct rx_cap {
 		unsigned char top_and_bottom;
 		unsigned char side_by_side;
 	} support_3d_format[VIC_MAX_NUM];
+	struct dv_info dv_info;
 	/*blk0 check sum*/
 	unsigned char blk0_chksum;
 };
@@ -140,6 +143,14 @@ struct audcts_log {
 	unsigned int stable:1;
 };
 
+struct frac_rate_table {
+	char *hz;
+	u32 sync_num_int;
+	u32 sync_den_int;
+	u32 sync_num_dec;
+	u32 sync_den_dec;
+};
+
 #define EDID_MAX_BLOCK              4
 #define HDMI_TMP_BUF_SIZE           1024
 struct hdmitx_dev {
@@ -155,6 +166,7 @@ struct hdmitx_dev {
 	struct delayed_work work_hpd_plugin;
 	struct delayed_work work_hpd_plugout;
 	struct work_struct work_internal_intr;
+	struct work_struct work_hdr;
 #ifdef CONFIG_AML_HDMI_TX_14
 	struct delayed_work cec_work;
 #endif
@@ -210,6 +222,7 @@ struct hdmitx_dev {
 	unsigned cur_phy_block_ptr;
 	unsigned char EDID_buf[EDID_MAX_BLOCK * 128];
 	unsigned char EDID_buf1[EDID_MAX_BLOCK*128]; /* for second read */
+	unsigned char *edid_ptr;
 	unsigned char EDID_hash[20];
 	struct rx_cap RXCap;
 	struct hdmitx_vidpara *cur_video_param;
@@ -242,10 +255,6 @@ struct hdmitx_dev {
 	unsigned int tv_no_edid;
 	unsigned int hpd_lock;
 	struct hdmi_format_para *para;
-	/* 0: RGB444  1: Y444  2: Y422  3: Y420 */
-	enum hdmi_color_space colorspace;
-	/* 4: 24bit  5: 30bit  6: 36bit  7: 48bit */
-	enum hdmi_color_depth colordepth;
 	/* if equals to 1, means current video & audio output are blank */
 	unsigned int output_blank_flag;
 	unsigned int audio_notify_flag;
@@ -257,10 +266,15 @@ struct hdmitx_dev {
 	struct clk *clk_phy;
 	struct clk *clk_vid;
 	unsigned int gpio_i2c_enable;
+	/* 0.1% clock shift, 1080p60hz->59.94hz */
+	unsigned int frac_rate_policy;
 	/* configure for I2S: 8ch in, 2ch out */
 	/* 0: default setting  1:ch0/1  2:ch2/3  3:ch4/5  4:ch6/7 */
 	unsigned int aud_output_ch;
 	unsigned int hdr_src_feature;
+	unsigned int flag_3dfp:1;
+	unsigned int flag_3dtb:1;
+	unsigned int flag_3dss:1;
 };
 
 #define CMD_DDC_OFFSET          (0x10 << 24)
@@ -321,6 +335,17 @@ struct hdmitx_dev {
 #define CONF_AVI_BT2020		(CMD_CONF_OFFSET + 0X2000 + 0x00)
 	#define CLR_AVI_BT2020	0x0
 	#define SET_AVI_BT2020	0x1
+/* set value as COLORSPACE_RGB444, YUV422, YUV444, YUV420 */
+#define CONF_AVI_RGBYCC_INDIC	(CMD_CONF_OFFSET + 0X2000 + 0x01)
+#define CONF_AVI_Q01		(CMD_CONF_OFFSET + 0X2000 + 0x02)
+	#define RGB_RANGE_DEFAULT	0
+	#define RGB_RANGE_LIM		1
+	#define RGB_RANGE_FUL		2
+	#define RGB_RANGE_RSVD		3
+#define CONF_AVI_YQ01		(CMD_CONF_OFFSET + 0X2000 + 0x03)
+	#define YCC_RANGE_LIM		0
+	#define YCC_RANGE_FUL		1
+	#define YCC_RANGE_RSVD		2
 
 /***********************************************************************
  *             MISC control, hpd, hpll //CntlMisc
@@ -387,6 +412,7 @@ extern void hdmitx_init_parameters(struct hdmitx_info *info);
 extern enum hdmi_vic hdmitx_edid_vic_tab_map_vic(const char *disp_mode);
 
 extern int hdmitx_edid_parse(struct hdmitx_dev *hdmitx_device);
+extern int check_dvi_hdmi_edid_valid(unsigned char *buf);
 
 enum hdmi_vic hdmitx_edid_get_VIC(struct hdmitx_dev *hdmitx_device,
 	const char *disp_mode, char force_flag);
@@ -396,6 +422,9 @@ extern int hdmitx_edid_VIC_support(enum hdmi_vic vic);
 extern int hdmitx_edid_dump(struct hdmitx_dev *hdmitx_device, char *buffer,
 	int buffer_len);
 
+bool hdmitx_edid_check_valid_mode(struct hdmitx_dev *hdev,
+	struct hdmi_format_para *para);
+
 extern void hdmitx_edid_clear(struct hdmitx_dev *hdmitx_device);
 
 extern void hdmitx_edid_ram_buffer_clear(struct hdmitx_dev *hdmitx_device);
@@ -468,13 +497,8 @@ extern void hdmitx_output_rgb(void);
 
 extern int get_cur_vout_index(void);
 extern struct vinfo_s *hdmi_get_current_vinfo(void);
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-extern enum fine_tune_mode_e get_hpll_tune_mode(void);
-extern void register_hdmi_edid_supported_func(int (*pfunc)(char *mode_name));
-#endif
 void phy_pll_off(void);
 
-
 extern int get_hpd_state(void);
 
 
diff --git a/include/linux/amlogic/rdma/rdma_mgr.h b/include/linux/amlogic/rdma/rdma_mgr.h
index 3db8557..f6bfca9 100644
--- a/include/linux/amlogic/rdma/rdma_mgr.h
+++ b/include/linux/amlogic/rdma/rdma_mgr.h
@@ -7,9 +7,11 @@ struct rdma_op_s {
 	void *arg;
 };
 
-#define RDMA_TRIGGER_MANUAL	0x100
+#define RDMA_TRIGGER_VSYNC_INPUT 0x1
+#define RDMA_TRIGGER_MANUAL 0x100
 #define RDMA_TRIGGER_DEBUG1 0x101
 #define RDMA_TRIGGER_DEBUG2 0x102
+#define RDMA_AUTO_START_MASK 0x80000
 
 /*
 	rdma_read_reg(), rdma_write_reg(), rdma_clear() can only be called
diff --git a/include/linux/amlogic/vout/lcd_extern.h b/include/linux/amlogic/vout/lcd_extern.h
index 6731fac..4badb6c 100644
--- a/include/linux/amlogic/vout/lcd_extern.h
+++ b/include/linux/amlogic/vout/lcd_extern.h
@@ -45,6 +45,10 @@ enum lcd_extern_i2c_bus_e {
 #define LCD_EXTERN_INIT_NONE         0xf0
 #define LCD_EXTERN_INIT_END          0xff
 
+
+#define LCD_EXTERN_DYNAMIC_LEN		0xff
+
+
 #define LCD_EXTERN_GPIO_NUM_MAX      6
 #define LCD_EXTERN_INDEX_INVALID     0xff
 #define LCD_EXTERN_NAME_LEN_MAX      30
diff --git a/include/linux/amlogic/vout/lcd_notify.h b/include/linux/amlogic/vout/lcd_notify.h
index 73cb524..dfbda15 100644
--- a/include/linux/amlogic/vout/lcd_notify.h
+++ b/include/linux/amlogic/vout/lcd_notify.h
@@ -39,6 +39,8 @@
 /* lcd backlight pwm_vs vfreq change occurred */
 #define LCD_EVENT_BACKLIGHT_UPDATE  (1 << 5)
 
+#define LCD_EVENT_GAMMA_UPDATE  (1 << 6)
+
 /* lcd frame rate change occurred */
 #define LCD_EVENT_FRAME_RATE_ADJUST (1 << 8)
 /* lcd config change occurred */
diff --git a/include/linux/amlogic/vout/lcd_vout.h b/include/linux/amlogic/vout/lcd_vout.h
index c59a23c..5986398 100644
--- a/include/linux/amlogic/vout/lcd_vout.h
+++ b/include/linux/amlogic/vout/lcd_vout.h
@@ -29,7 +29,7 @@
  * ********************************** */
 /* #define LCD_DEBUG_INFO */
 
-extern unsigned int lcd_debug_print_flag;
+extern unsigned char lcd_debug_print_flag;
 #define LCDPR(fmt, args...)     pr_info("lcd: "fmt"", ## args)
 #define LCDERR(fmt, args...)    pr_info("lcd: error: "fmt"", ## args)
 
@@ -195,6 +195,25 @@ struct lcd_effect_s {
 */
 };
 
+/* **********************************
+ * HDR info define
+ * ********************************** */
+struct lcd_hdr_info_s {
+	unsigned int hdr_support;
+	unsigned int features;
+	unsigned int primaries_r_x;
+	unsigned int primaries_r_y;
+	unsigned int primaries_g_x;
+	unsigned int primaries_g_y;
+	unsigned int primaries_b_x;
+	unsigned int primaries_b_y;
+	unsigned int white_point_x;
+	unsigned int white_point_y;
+	unsigned int luma_max;
+	unsigned int luma_min;
+	unsigned int luma_avg;
+};
+
 struct ttl_config_s {
 	unsigned int clk_pol;
 	unsigned int sync_valid; /* [1]DE, [0]hvsync */
@@ -211,6 +230,7 @@ struct lvds_config_s {
 	unsigned int dual_port;
 	unsigned int pn_swap;
 	unsigned int port_swap;
+	unsigned int lane_reverse;
 	unsigned int port_sel;
 	unsigned int phy_vswing;
 	unsigned int phy_preem;
@@ -229,6 +249,8 @@ struct vbyone_config_s {
 	unsigned int bit_rate;
 	unsigned int phy_vswing;
 	unsigned int phy_preem;
+	unsigned int intr_en;
+	unsigned int vsync_intr_en;
 };
 
 /* mipi-dsi config */
@@ -339,6 +361,8 @@ struct lcd_power_ctrl_s {
 	struct lcd_pmu_gpio_s pmu_gpio[LCD_PMU_GPIO_NUM_MAX];
 	struct lcd_power_step_s power_on_step[LCD_PWR_STEP_MAX];
 	struct lcd_power_step_s power_off_step[LCD_PWR_STEP_MAX];
+	int power_on_step_max; /*  internal use for debug */
+	int power_off_step_max; /* internal use for debug */
 };
 
 struct lcd_clk_gate_ctrl_s {
@@ -356,6 +380,7 @@ struct lcd_config_s {
 	struct lcd_basic_s lcd_basic;
 	struct lcd_timing_s lcd_timing;
 	struct lcd_effect_s lcd_effect;
+	struct lcd_hdr_info_s hdr_info;
 	struct lcd_control_config_s lcd_control;
 	struct lcd_power_ctrl_s *lcd_power;
 	struct pinctrl *pin;
@@ -376,18 +401,26 @@ struct aml_lcd_drv_s {
 	unsigned char lcd_key_valid;
 	unsigned char lcd_config_load;
 	unsigned char vpp_sel; /*0:vpp, 1:vpp2 */
+	unsigned char lcd_test_flag;
 
 	struct device *dev;
 	struct lcd_config_s *lcd_config;
 	struct vinfo_s *lcd_info;
-	unsigned char fr_auto_policy;
+	struct class *lcd_debug_class;
+	int fr_auto_policy;
 	struct lcd_duration_s std_duration;
 
 	void (*vout_server_init)(void);
 	void (*driver_init_pre)(void);
 	int (*driver_init)(void);
 	void (*driver_disable)(void);
+	int (*driver_change)(void);
 	void (*module_reset)(void);
+	void (*power_tiny_ctrl)(int status);
+	void (*driver_tiny_enable)(void);
+	void (*driver_tiny_disable)(void);
+	void (*module_tiny_reset)(void);
+	void (*lcd_test_check)(void);
 	/*void (*module_enable)(void);
 	void (*module_disable)(void);
 	void (*set_gamma_table)(unsigned int gamma_en);
@@ -404,13 +437,24 @@ struct aml_lcd_drv_s {
 	void (*power_ctrl)(int status);
 
 	struct workqueue_struct *workqueue;
-	struct delayed_work     lcd_delayed_work;
+	struct delayed_work     lcd_probe_delayed_work;
+	struct delayed_work     lcd_vx1_delayed_work;
+	struct work_struct      lcd_resume_work;
 };
 
 extern struct aml_lcd_drv_s *aml_lcd_get_driver(void);
 
+
 /* **********************************
- * global control
+ * IOCTL define
  * ********************************** */
+#define LCD_IOC_TYPE               'C'
+#define LCD_IOC_NR_GET_HDR_INFO    0x0
+#define LCD_IOC_NR_SET_HDR_INFO    0x1
+
+#define LCD_IOC_CMD_GET_HDR_INFO   \
+	_IOR(LCD_IOC_TYPE, LCD_IOC_NR_GET_HDR_INFO, struct lcd_hdr_info_s)
+#define LCD_IOC_CMD_SET_HDR_INFO   \
+	_IOW(LCD_IOC_TYPE, LCD_IOC_NR_SET_HDR_INFO, struct lcd_hdr_info_s)
 
 #endif
diff --git a/include/linux/amlogic/vout/vinfo.h b/include/linux/amlogic/vout/vinfo.h
index 3f6cf9a..15216a9 100644
--- a/include/linux/amlogic/vout/vinfo.h
+++ b/include/linux/amlogic/vout/vinfo.h
@@ -56,13 +56,6 @@ enum vmode_e {
 	VMODE_4K2K_SMPTE_50HZ_Y420,
 	VMODE_4K2K_SMPTE_60HZ,
 	VMODE_4K2K_SMPTE_60HZ_Y420,
-	VMODE_4K2K_50HZ_Y420_10BIT,
-	VMODE_4K2K_60HZ_Y420_10BIT,
-	VMODE_4K2K_50HZ_Y422_10BIT,
-	VMODE_4K2K_60HZ_Y422_10BIT,
-	VMODE_4K2K_24HZ_Y444_10BIT,
-	VMODE_4K2K_25HZ_Y444_10BIT,
-	VMODE_4K2K_30HZ_Y444_10BIT,
 	VMODE_4K2K_FAKE_5G,
 	VMODE_4K2K_60HZ,
 	VMODE_4K2K_60HZ_Y420,
@@ -83,7 +76,15 @@ enum vmode_e {
 	VMODE_SXGA,
 	VMODE_WSXGA,
 	VMODE_FHDVGA,
+	VMODE_720FP50HZ, /* Extra VMODE for 3D Frame Packing */
+	VMODE_720FP60HZ,
+	VMODE_1080FP24HZ,
+	VMODE_1080FP25HZ,
+	VMODE_1080FP30HZ,
+	VMODE_1080FP50HZ,
+	VMODE_1080FP60HZ,
 	VMODE_LCD,
+	VMODE_NULL, /* null mode is used as temporary witch mode state */
 	VMODE_MAX,
 	VMODE_INIT_NULL,
 	VMODE_MASK = 0xFF,
@@ -121,13 +122,6 @@ enum tvmode_e {
 	TVMODE_4K2K_SMPTE_50HZ_Y420,
 	TVMODE_4K2K_SMPTE_60HZ,
 	TVMODE_4K2K_SMPTE_60HZ_Y420,
-	TVMODE_4K2K_50HZ_Y420_10BIT,
-	TVMODE_4K2K_60HZ_Y420_10BIT,
-	TVMODE_4K2K_50HZ_Y422_10BIT,
-	TVMODE_4K2K_60HZ_Y422_10BIT,
-	TVMODE_4K2K_24HZ_Y444_10BIT,
-	TVMODE_4K2K_25HZ_Y444_10BIT,
-	TVMODE_4K2K_30HZ_Y444_10BIT,
 	TVMODE_4K2K_FAKE_5G,
 	TVMODE_4K2K_60HZ,
 	TVMODE_4K2K_60HZ_Y420,
@@ -148,7 +142,15 @@ enum tvmode_e {
 	TVMODE_SXGA,
 	TVMODE_WSXGA,
 	TVMODE_FHDVGA,
-	TVMODE_MAX
+	TVMODE_720FP50HZ, /* Extra TVMODE for 3D Frame Packing */
+	TVMODE_720FP60HZ,
+	TVMODE_1080FP24HZ,
+	TVMODE_1080FP25HZ,
+	TVMODE_1080FP30HZ,
+	TVMODE_1080FP50HZ,
+	TVMODE_1080FP60HZ,
+	TVMODE_NULL, /* null mode is used as temporary witch mode state */
+	TVMODE_MAX,
 };
 
 #define SUPPORT_2020	0x01
@@ -160,6 +162,8 @@ struct master_display_info_s {
 	u32 primaries[3][2];		/* normalized 50000 in G,B,R order */
 	u32 white_point[2];		/* normalized 50000 */
 	u32 luminance[2];		/* max/min lumin, normalized 10000 */
+	u32 max_content;		/* Maximum Content Light Level */
+	u32 max_frame_average;	/* Maximum Frame-average Light Level */
 };
 
 struct hdr_info {
@@ -167,12 +171,61 @@ struct hdr_info {
 	u32 lumi_max; /* RX EDID Lumi Max value */
 	u32 lumi_avg; /* RX EDID Lumi Avg value */
 	u32 lumi_min; /* RX EDID Lumi Min value */
+	u8 sink_flag; /*0 = hdmi, 1 = panel*/
+};
+
+/* Refer ot DolbyVision 2.6, Page 35
+ * For Explicit Switch Signaling Methods using.
+ */
+enum eotf_type {
+	EOTF_T_NULL = 0,
+	EOTF_T_DOLBYVISION,
+	EOTF_T_HDR10,
+	EOTF_T_SDR,
+	EOTF_T_MAX,
+};
+
+/* Dolby Version support information */
+/* Refer to DV Spec issue 2.6 Page 11 and 14 */
+struct dv_info {
+	uint32_t ieeeoui;
+	uint8_t ver; /* 0 or 1 */
+	uint8_t sup_yuv422_12bit:1; /* if as 0, then support RGB tunnel mode */
+	uint8_t sup_2160p60hz:1; /* if as 0, then support 2160p30hz */
+	uint8_t sup_global_dimming:1;
+	uint8_t colorimetry:1;
+	union {
+		struct {
+			uint16_t chrom_red_primary_x;
+			uint16_t chrom_red_primary_y;
+			uint16_t chrom_green_primary_x;
+			uint16_t chrom_green_primary_y;
+			uint16_t chrom_blue_primary_x;
+			uint16_t chrom_blue_primary_y;
+			uint16_t chrom_white_primary_x;
+			uint16_t chrom_white_primary_y;
+			uint16_t target_min_pq;
+			uint16_t target_max_pq;
+			uint8_t dm_major_ver;
+			uint8_t dm_minor_ver;
+		} ver0;
+		struct {
+			uint8_t dm_version;
+			uint8_t target_max_lum;
+			uint8_t target_min_lum;
+			uint8_t chrom_red_primary_x;
+			uint8_t chrom_red_primary_y;
+			uint8_t chrom_green_primary_x;
+			uint8_t chrom_green_primary_y;
+			uint8_t chrom_blue_primary_x;
+			uint8_t chrom_blue_primary_y;
+		} ver1;
+	} vers;
 };
 
 struct vinfo_s {
 	char *name;
 	enum vmode_e mode;
-	char ext_name[32];
 	u32 width;
 	u32 height;
 	u32 field_height;
@@ -187,8 +240,11 @@ struct vinfo_s {
 	struct hdr_info hdr_info;
 	struct master_display_info_s
 		master_display_info;
+	const struct dv_info *dv_info;
 	/* update hdmitx hdr packet, if data is NULL, disalbe packet */
 	void (*fresh_tx_hdr_pkt)(struct master_display_info_s *data);
+	/* tunnel_mode: 1: tunneling mode, RGB 8bit  0: YCbCr422 12bit mode */
+	void (*fresh_tx_vsif_pkt)(enum eotf_type type, uint8_t tunnel_mode);
 };
 
 struct disp_rect_s {
diff --git a/include/linux/amlogic/vout/vout_notify.h b/include/linux/amlogic/vout/vout_notify.h
index 2e4922a..92235eb 100644
--- a/include/linux/amlogic/vout/vout_notify.h
+++ b/include/linux/amlogic/vout/vout_notify.h
@@ -35,6 +35,8 @@ struct vout_op_s {
 	int (*disable)(enum vmode_e);
 	int (*set_vframe_rate_hint)(int);
 	int (*set_vframe_rate_end_hint)(void);
+	int (*set_vframe_rate_policy)(int);
+	int (*get_vframe_rate_policy)(void);
 	int (*vout_suspend)(void);
 	int (*vout_resume)(void);
 };
@@ -63,6 +65,8 @@ extern enum vmode_e validate_vmode(char *);
 extern int get_vsource_fps(int duration);
 extern int set_vframe_rate_hint(int);
 extern int set_vframe_rate_end_hint(void);
+extern int set_vframe_rate_policy(int);
+extern int get_vframe_rate_policy(void);
 
 /* vdac ctrl,adc/dac ref signal,cvbs out signal
  * module index: atv demod:0x01; dtv demod:0x02; tvafe:0x4; dac:0x8
diff --git a/include/linux/amlogic/vpu.h b/include/linux/amlogic/vpu.h
index 0618efe..e76416b 100644
--- a/include/linux/amlogic/vpu.h
+++ b/include/linux/amlogic/vpu.h
@@ -65,6 +65,16 @@ enum vpu_mod_e {
 
 	VPU_VIU1_WM,          /* reg2[1:0]  //GXL, TXL */
 
+	/* for clk_gate */
+	VPU_VPU_TOP,
+	VPU_VPU_CLKB,
+	VPU_RDMA,
+	VPU_MISC,      /* hs,vs,interrupt */
+	VPU_VENC_DAC,
+	VPU_VLOCK,
+	VPU_DI,
+	VPU_VPP,
+
 	VPU_MAX,
 };
 
@@ -72,6 +82,9 @@ enum vpu_mod_e {
 #define VPU_MEM_POWER_ON		0
 #define VPU_MEM_POWER_DOWN		1
 
+#define VPU_CLK_GATE_ON			1
+#define VPU_CLK_GATE_OFF		0
+
 extern unsigned int get_vpu_clk(void);
 extern unsigned int get_vpu_clk_vmod(unsigned int vmod);
 extern int request_vpu_clk_vmod(unsigned int vclk, unsigned int vmod);
@@ -79,4 +92,6 @@ extern int release_vpu_clk_vmod(unsigned int vmod);
 
 extern void switch_vpu_mem_pd_vmod(unsigned int vmod, int flag);
 extern int get_vpu_mem_pd_vmod(unsigned int vmod);
+
+extern void switch_vpu_clk_gate_vmod(unsigned int vmod, int flag);
 #endif
