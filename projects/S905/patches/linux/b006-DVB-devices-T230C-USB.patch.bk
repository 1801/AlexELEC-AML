diff -Naurp linux-d7e124d/drivers/media/dvb-core/dvb-usb-ids.h linux-d7e124d-patch/drivers/media/dvb-core/dvb-usb-ids.h
--- linux-d7e124d/drivers/media/dvb-core/dvb-usb-ids.h	2016-12-08 09:43:55.000000000 +0200
+++ linux-d7e124d-patch/drivers/media/dvb-core/dvb-usb-ids.h	2016-12-08 10:39:08.000000000 +0200
@@ -357,6 +357,7 @@
 #define USB_PID_SONY_PLAYTV				0x0003
 #define USB_PID_MYGICA_D689				0xd811
 #define USB_PID_MYGICA_T230				0xc688
+#define USB_PID_MYGICA_T230C				0xc689
 #define USB_PID_ELGATO_EYETV_DIVERSITY			0x0011
 #define USB_PID_ELGATO_EYETV_DTT			0x0021
 #define USB_PID_ELGATO_EYETV_DTT_2			0x003f
diff -Naurp linux-d7e124d/drivers/media/dvb-frontends/si2168.c linux-d7e124d-patch/drivers/media/dvb-frontends/si2168.c
--- linux-d7e124d/drivers/media/dvb-frontends/si2168.c	2016-12-08 09:43:55.000000000 +0200
+++ linux-d7e124d-patch/drivers/media/dvb-frontends/si2168.c	2016-12-08 09:51:09.000000000 +0200
@@ -407,6 +407,7 @@ static int si2168_init(struct dvb_fronte
 	#define SI2168_A20 ('A' << 24 | 68 << 16 | '2' << 8 | '0' << 0)
 	#define SI2168_A30 ('A' << 24 | 68 << 16 | '3' << 8 | '0' << 0)
 	#define SI2168_B40 ('B' << 24 | 68 << 16 | '4' << 8 | '0' << 0)
+	#define SI2168_D60 ('D' << 24 | 68 << 16 | '6' << 8 | '0' << 0)
 
 	switch (chip_id) {
 	case SI2168_A20:
@@ -418,6 +419,9 @@ static int si2168_init(struct dvb_fronte
 	case SI2168_B40:
 		fw_name = SI2168_B40_FIRMWARE;
 		break;
+	case SI2168_D60:
+		fw_name = SI2168_D60_FIRMWARE;
+		break;
 	default:
 		dev_err(&client->dev, "unknown chip version Si21%d-%c%c%c\n",
 				cmd.args[2], cmd.args[1],
diff -Naurp linux-d7e124d/drivers/media/dvb-frontends/si2168_priv.h linux-d7e124d-patch/drivers/media/dvb-frontends/si2168_priv.h
--- linux-d7e124d/drivers/media/dvb-frontends/si2168_priv.h	2016-12-08 09:43:55.000000000 +0200
+++ linux-d7e124d-patch/drivers/media/dvb-frontends/si2168_priv.h	2016-12-08 09:50:06.000000000 +0200
@@ -25,6 +25,7 @@
 #define SI2168_A20_FIRMWARE "dvb-demod-si2168-a20-01.fw"
 #define SI2168_A30_FIRMWARE "dvb-demod-si2168-a30-01.fw"
 #define SI2168_B40_FIRMWARE "dvb-demod-si2168-b40-01.fw"
+#define SI2168_D60_FIRMWARE "dvb-demod-si2168-d60-01.fw"
 #define SI2168_B40_FIRMWARE_FALLBACK "dvb-demod-si2168-02.fw"
 
 /* state struct */
diff -Naurp linux-d7e124d/drivers/media/tuners/si2157.c linux-d7e124d-patch/drivers/media/tuners/si2157.c
--- linux-d7e124d/drivers/media/tuners/si2157.c	2016-12-08 09:43:55.000000000 +0200
+++ linux-d7e124d-patch/drivers/media/tuners/si2157.c	2016-12-08 10:22:09.000000000 +0200
@@ -83,18 +83,50 @@ static int si2157_init(struct dvb_fronte
 	struct si2157_cmd cmd;
 	const struct firmware *fw;
 	const char *fw_name;
-	unsigned int chip_id;
+	unsigned int chip_id, count;
 
 	dev_dbg(&client->dev, "\n");
 
 	if (dev->fw_loaded)
 		goto warm;
 
+	if (dev->chiptype == SI2157_CHIPTYPE_SI2141) {
+		count =0;
+		do {
+			if (count > 10)
+				 goto err;
+
+			/* reset */
+			memcpy(cmd.args, "\xc0\x05\x00\x00", 4);
+			cmd.wlen = 4;
+			cmd.rlen = 1;
+			ret = si2157_cmd_execute(client, &cmd);
+			if (ret)
+				goto err;
+
+			memcpy(cmd.args, "\xc0\x00\x0d\x0e\x00\x01\x01\x01\x01\x03", 10);
+			cmd.wlen = 10;
+			cmd.rlen = 1;
+			ret = si2157_cmd_execute(client, &cmd);
+			if (ret)
+				goto err;
+			count ++;
+		} while(cmd.args[0]== 0xfe);
+		dev_info(&client->dev, "Si2141/2151 reset attempts %d\n", count);
+	}
+
 	/* power up */
-	if (dev->chiptype == SI2157_CHIPTYPE_SI2146) {
+	switch (dev->chiptype)
+	{
+	case SI2157_CHIPTYPE_SI2146:
 		memcpy(cmd.args, "\xc0\x05\x01\x00\x00\x0b\x00\x00\x01", 9);
 		cmd.wlen = 9;
-	} else {
+		break;
+	case SI2157_CHIPTYPE_SI2141:
+  		memcpy(cmd.args, "\xc0\x08\x01\x02\x00\x08\x01", 7);
+		cmd.wlen = 7;
+		break;
+	default:
 		memcpy(cmd.args, "\xc0\x00\x0c\x00\x00\x01\x01\x01\x01\x01\x01\x02\x00\x00\x01", 15);
 		cmd.wlen = 15;
 	}
@@ -119,6 +151,8 @@ static int si2157_init(struct dvb_fronte
 	#define SI2157_A30 ('A' << 24 | 57 << 16 | '3' << 8 | '0' << 0)
 	#define SI2147_A30 ('A' << 24 | 47 << 16 | '3' << 8 | '0' << 0)
 	#define SI2146_A10 ('A' << 24 | 46 << 16 | '1' << 8 | '0' << 0)
+	#define SI2141_A10 ('A' << 24 | 41 << 16 | '1' << 8 | '0' << 0)
+	#define SI2151_A10 ('A' << 24 | 51 << 16 | '1' << 8 | '0' << 0)
 
 	switch (chip_id) {
 	case SI2158_A20:
@@ -130,6 +164,10 @@ static int si2157_init(struct dvb_fronte
 	case SI2146_A10:
 		fw_name = NULL;
 		break;
+	case SI2141_A10:
+	case SI2151_A10:
+		fw_name = SI2141_A10_FIRMWARE;
+		break;
 	default:
 		dev_err(&client->dev, "unknown chip version Si21%d-%c%c%c\n",
 				cmd.args[2], cmd.args[1],
@@ -197,6 +235,24 @@ skip_fw_download:
 
 	dev_info(&client->dev, "firmware version: %c.%c.%d\n",
 			cmd.args[6], cmd.args[7], cmd.args[8]);
+	
+	if (dev->chiptype == SI2157_CHIPTYPE_SI2141) {
+		/* set clock */
+		memcpy(cmd.args, "\xc0\x00\x0d", 3);
+		cmd.wlen = 3;
+		cmd.rlen = 1;
+		ret = si2157_cmd_execute(client, &cmd);
+		if (ret)
+			goto err;
+		/* setup PIN */
+ 		memcpy(cmd.args, "\x12\x80\x80\x85\x00\x81\x00", 7);
+		cmd.wlen = 7;
+		cmd.rlen = 7;
+		ret = si2157_cmd_execute(client, &cmd);
+		if (ret)
+			goto err;
+	  
+	}
 
 	dev->fw_loaded = true;
 
@@ -295,6 +351,7 @@ static int si2157_set_params(struct dvb_
 	if (ret)
 		goto err;
 
+	/* set IF port */
 	if (dev->chiptype == SI2157_CHIPTYPE_SI2146)
 		memcpy(cmd.args, "\x14\x00\x02\x07\x00\x01", 6);
 	else
@@ -305,6 +362,15 @@ static int si2157_set_params(struct dvb_
 	if (ret)
 		goto err;
 
+	/* set LIF out amp */
+	memcpy(cmd.args, "\x14\x00\x07\x07\x94\x20", 6);
+	cmd.args[5] = delivery_system == 0x30 ? 0x2B : 0x20;
+	cmd.wlen = 6;
+	cmd.rlen = 4;
+	ret = si2157_cmd_execute(client, &cmd);
+	if (ret)
+		goto err;
+
 	/* set if frequency if needed */
 	if (if_frequency != dev->if_frequency) {
 		memcpy(cmd.args, "\x14\x00\x06\x07", 4);
@@ -384,7 +450,22 @@ static int si2157_probe(struct i2c_clien
 	mutex_init(&dev->i2c_mutex);
 
 	/* check if the tuner is there */
-	cmd.wlen = 0;
+        /* wake tuner */
+	switch (dev->chiptype)
+	{
+	case SI2157_CHIPTYPE_SI2146:
+		memcpy(cmd.args, "\xc0\x05\x01\x00\x00\x0b\x00\x00\x01", 9);
+		cmd.wlen = 9;
+		break;
+	case SI2157_CHIPTYPE_SI2141:
+		memcpy(cmd.args, "\xc0\x05\x00\x00", 4);
+		cmd.wlen = 4;
+		break;
+	default:
+		memcpy(cmd.args, "\xc0\x00\x0c\x00\x00\x01\x01\x01\x01\x01\x01\x02\x00\x00\x01", 15);
+		cmd.wlen = 15;
+	}
+
 	cmd.rlen = 1;
 	ret = si2157_cmd_execute(client, &cmd);
 	if (ret)
@@ -394,8 +475,8 @@ static int si2157_probe(struct i2c_clien
 	fe->tuner_priv = client;
 
 	dev_info(&client->dev, "Silicon Labs %s successfully attached\n",
-			dev->chiptype == SI2157_CHIPTYPE_SI2146 ?
-			"Si2146" : "Si2147/2148/2157/2158");
+			dev->chiptype == SI2157_CHIPTYPE_SI2141 ?
+			"Si2141/2151" : dev->chiptype == SI2157_CHIPTYPE_SI2146 ? "Si2146" : "Si2147/2148/2157/2158");
 
 	return 0;
 
@@ -423,6 +504,7 @@ static int si2157_remove(struct i2c_clie
 static const struct i2c_device_id si2157_id_table[] = {
 	{"si2157", SI2157_CHIPTYPE_SI2157},
 	{"si2146", SI2157_CHIPTYPE_SI2146},
+	{"si2141", SI2157_CHIPTYPE_SI2141},
 	{}
 };
 MODULE_DEVICE_TABLE(i2c, si2157_id_table);
@@ -443,3 +525,4 @@ MODULE_DESCRIPTION("Silicon Labs Si2146/
 MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
 MODULE_LICENSE("GPL");
 MODULE_FIRMWARE(SI2158_A20_FIRMWARE);
+MODULE_FIRMWARE(SI2141_A10_FIRMWARE);
diff -Naurp linux-d7e124d/drivers/media/tuners/si2157_priv.h linux-d7e124d-patch/drivers/media/tuners/si2157_priv.h
--- linux-d7e124d/drivers/media/tuners/si2157_priv.h	2016-12-08 09:43:55.000000000 +0200
+++ linux-d7e124d-patch/drivers/media/tuners/si2157_priv.h	2016-12-08 10:23:33.000000000 +0200
@@ -33,6 +33,7 @@ struct si2157_dev {
 
 #define SI2157_CHIPTYPE_SI2157 0
 #define SI2157_CHIPTYPE_SI2146 1
+#define SI2157_CHIPTYPE_SI2141 2
 
 /* firmware command struct */
 #define SI2157_ARGLEN      30
@@ -43,5 +44,6 @@ struct si2157_cmd {
 };
 
 #define SI2158_A20_FIRMWARE "dvb-tuner-si2158-a20-01.fw"
+#define SI2141_A10_FIRMWARE "dvb-tuner-si2141-a10-01.fw"
 
 #endif
diff -Naurp linux-d7e124d/drivers/media/usb/dvb-usb/cxusb.c linux-d7e124d-patch/drivers/media/usb/dvb-usb/cxusb.c
--- linux-d7e124d/drivers/media/usb/dvb-usb/cxusb.c	2016-12-08 09:43:55.000000000 +0200
+++ linux-d7e124d-patch/drivers/media/usb/dvb-usb/cxusb.c	2016-12-08 10:43:27.000000000 +0200
@@ -1359,6 +1359,76 @@ static int cxusb_mygica_t230_frontend_at
 	return 0;
 }
 
+static int cxusb_mygica_t230c_frontend_attach(struct dvb_usb_adapter *adap)
+{
+	struct dvb_usb_device *d = adap->dev;
+	struct cxusb_state *st = d->priv;
+	struct i2c_adapter *adapter;
+	struct i2c_client *client_demod;
+	struct i2c_client *client_tuner;
+	struct i2c_board_info info;
+	struct si2168_config si2168_config;
+	struct si2157_config si2157_config;
+
+	/* Select required USB configuration */
+	if (usb_set_interface(d->udev, 0, 0) < 0)
+		err("set interface failed");
+
+	/* Unblock all USB pipes */
+	usb_clear_halt(d->udev,
+		usb_sndbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));
+	usb_clear_halt(d->udev,
+		usb_rcvbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));
+	usb_clear_halt(d->udev,
+		usb_rcvbulkpipe(d->udev, d->props.adapter[0].fe[0].stream.endpoint));
+
+	/* attach frontend */
+	si2168_config.i2c_adapter = &adapter;
+	si2168_config.fe = &adap->fe_adap[0].fe;
+	si2168_config.ts_mode = SI2168_TS_PARALLEL;
+	si2168_config.ts_clock_inv = 1;
+	memset(&info, 0, sizeof(struct i2c_board_info));
+	strlcpy(info.type, "si2168", I2C_NAME_SIZE);
+	info.addr = 0x64;
+	info.platform_data = &si2168_config;
+	request_module(info.type);
+	client_demod = i2c_new_device(&d->i2c_adap, &info);
+	if (client_demod == NULL || client_demod->dev.driver == NULL)
+		return -ENODEV;
+
+	if (!try_module_get(client_demod->dev.driver->owner)) {
+		i2c_unregister_device(client_demod);
+		return -ENODEV;
+	}
+
+	st->i2c_client_demod = client_demod;
+
+	/* attach tuner */
+	memset(&si2157_config, 0, sizeof(si2157_config));
+	si2157_config.fe = adap->fe_adap[0].fe;
+	memset(&info, 0, sizeof(struct i2c_board_info));
+	strlcpy(info.type, "si2141", I2C_NAME_SIZE);
+	info.addr = 0x60;
+	info.platform_data = &si2157_config;
+	request_module("si2157");
+	client_tuner = i2c_new_device(adapter, &info);
+	if (client_tuner == NULL || client_tuner->dev.driver == NULL) {
+		module_put(client_demod->dev.driver->owner);
+		i2c_unregister_device(client_demod);
+		return -ENODEV;
+	}
+	if (!try_module_get(client_tuner->dev.driver->owner)) {
+		i2c_unregister_device(client_tuner);
+		module_put(client_demod->dev.driver->owner);
+		i2c_unregister_device(client_demod);
+		return -ENODEV;
+	}
+
+	st->i2c_client_tuner = client_tuner;
+
+	return 0;
+}
+
 /*
  * DViCO has shipped two devices with the same USB ID, but only one of them
  * needs a firmware download.  Check the device class details to see if they
@@ -1441,6 +1511,7 @@ static struct dvb_usb_device_properties
 static struct dvb_usb_device_properties cxusb_d680_dmb_properties;
 static struct dvb_usb_device_properties cxusb_mygica_d689_properties;
 static struct dvb_usb_device_properties cxusb_mygica_t230_properties;
+static struct dvb_usb_device_properties cxusb_mygica_t230c_properties;
 
 static int cxusb_probe(struct usb_interface *intf,
 		       const struct usb_device_id *id)
@@ -1473,6 +1544,8 @@ static int cxusb_probe(struct usb_interf
 				     THIS_MODULE, NULL, adapter_nr) ||
 	    0 == dvb_usb_device_init(intf, &cxusb_mygica_t230_properties,
 				     THIS_MODULE, NULL, adapter_nr) ||
+	    0 == dvb_usb_device_init(intf, &cxusb_mygica_t230c_properties,
+				     THIS_MODULE, NULL, adapter_nr) ||
 	    0)
 		return 0;
 
@@ -1501,6 +1574,7 @@ static struct usb_device_id cxusb_table
 	{ USB_DEVICE(USB_VID_CONEXANT, USB_PID_CONEXANT_D680_DMB) },
 	{ USB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_D689) },
 	{ USB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_T230) },
+	{ USB_DEVICE(USB_VID_CONEXANT, USB_PID_MYGICA_T230C) },
 	{}		/* Terminating entry */
 };
 MODULE_DEVICE_TABLE (usb, cxusb_table);
@@ -2199,6 +2273,59 @@ static struct dvb_usb_device_properties
 		},
 	}
 };
+
+static struct dvb_usb_device_properties cxusb_mygica_t230c_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+
+	.usb_ctrl         = CYPRESS_FX2,
+
+	.size_of_priv     = sizeof(struct cxusb_state),
+
+	.num_adapters = 1,
+	.adapter = {
+		{
+		.num_frontends = 1,
+		.fe = {{
+			.streaming_ctrl   = cxusb_streaming_ctrl,
+			.frontend_attach  = cxusb_mygica_t230c_frontend_attach,
+
+			/* parameter for the MPEG2-data transfer */
+			.stream = {
+				.type = USB_BULK,
+				.count = 5,
+				.endpoint = 0x02,
+				.u = {
+					.bulk = {
+						.buffersize = 8192,
+					}
+				}
+			},
+		} },
+		},
+	},
+
+	.power_ctrl       = cxusb_d680_dmb_power_ctrl,
+
+	.i2c_algo         = &cxusb_i2c_algo,
+
+	.generic_bulk_ctrl_endpoint = 0x01,
+
+	.rc.legacy = {
+		.rc_interval      = 100,
+		.rc_map_table     = rc_map_d680_dmb_table,
+		.rc_map_size      = ARRAY_SIZE(rc_map_d680_dmb_table),
+		.rc_query         = cxusb_d680_dmb_rc_query,
+	},
+
+	.num_device_descs = 1,
+	.devices = {
+		{
+			"Mygica T230C DVB-T/T2/C",
+			{ NULL },
+			{ &cxusb_table[21], NULL },
+		},
+	}
+};
 
 static struct usb_driver cxusb_driver = {
 	.name		= "dvb_usb_cxusb",
