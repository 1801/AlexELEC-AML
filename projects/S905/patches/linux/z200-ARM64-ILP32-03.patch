diff -Naurp linux-d7e124d/arch/arm64/include/asm/unistd.h linux-d7e124d-patch/arch/arm64/include/asm/unistd.h
--- linux-d7e124d/arch/arm64/include/asm/unistd.h	2016-11-30 16:43:57.000000000 +0200
+++ linux-d7e124d-patch/arch/arm64/include/asm/unistd.h	2016-12-04 12:32:38.000000000 +0200
@@ -13,7 +13,11 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
-#ifdef CONFIG_COMPAT
+#ifdef CONFIG_ARM64_ILP32
+#define __ARCH_WANT_COMPAT_SYS_PREADV64
+#define __ARCH_WANT_COMPAT_SYS_PWRITEV64
+#endif
+#ifdef CONFIG_AARCH32_EL0
 #define __ARCH_WANT_COMPAT_STAT64
 #define __ARCH_WANT_SYS_GETHOSTNAME
 #define __ARCH_WANT_SYS_PAUSE
diff -Naurp linux-d7e124d/arch/arm64/include/uapi/asm/bitsperlong.h linux-d7e124d-patch/arch/arm64/include/uapi/asm/bitsperlong.h
--- linux-d7e124d/arch/arm64/include/uapi/asm/bitsperlong.h	2016-11-30 16:43:57.000000000 +0200
+++ linux-d7e124d-patch/arch/arm64/include/uapi/asm/bitsperlong.h	2016-12-04 12:34:20.000000000 +0200
@@ -16,7 +16,12 @@
 #ifndef __ASM_BITSPERLONG_H
 #define __ASM_BITSPERLONG_H
 
-#define __BITS_PER_LONG 64
+/* Assuming __LP64__ will be defined for native ELF64's and not for ILP32. */
+#ifdef __LP64__
+# define __BITS_PER_LONG 64
+#else
+# define __BITS_PER_LONG 32
+#endif
 
 #include <asm-generic/bitsperlong.h>
 
diff -Naurp linux-d7e124d/arch/arm64/include/uapi/asm/posix_types.h linux-d7e124d-patch/arch/arm64/include/uapi/asm/posix_types.h
--- linux-d7e124d/arch/arm64/include/uapi/asm/posix_types.h	1970-01-01 03:00:00.000000000 +0300
+++ linux-d7e124d-patch/arch/arm64/include/uapi/asm/posix_types.h	2016-12-04 12:36:37.000000000 +0200
@@ -0,0 +1,16 @@
+#ifndef __ASM_POSIX_TYPES_H
+#define __ASM_POSIX_TYPES_H
+
+typedef unsigned short __kernel_old_uid_t;
+typedef unsigned short __kernel_old_gid_t;
+#define __kernel_old_uid_t __kernel_old_uid_t
+
+#ifndef __LP64__	/* ILP32 */
+typedef long long __kernel_long_t;
+typedef unsigned long long __kernel_ulong_t;
+#define __kernel_long_t __kernel_long_t
+#endif
+
+#include <asm-generic/posix_types.h>
+
+#endif /*  __ASM_POSIX_TYPES_H */
diff -Naurp linux-d7e124d/arch/arm64/kernel/Makefile linux-d7e124d-patch/arch/arm64/kernel/Makefile
--- linux-d7e124d/arch/arm64/kernel/Makefile	2016-11-30 16:43:57.000000000 +0200
+++ linux-d7e124d-patch/arch/arm64/kernel/Makefile	2016-12-04 12:40:01.000000000 +0200
@@ -16,8 +16,9 @@ arm64-obj-y		:= cputable.o debug-monitor
 			   hyp-stub.o psci.o cpu_ops.o insn.o return_address.o	\
 			   opcodes.o psci-call.o
 
-arm64-obj-$(CONFIG_COMPAT)		+= sys32.o kuser32.o signal32.o	\
+arm64-obj-$(CONFIG_AARCH32_EL0)		+= sys32.o kuser32.o signal32.o 	\
 					   sys_compat.o
+arm64-obj-$(CONFIG_ARM64_ILP32)		+= sys_ilp32.o
 arm64-obj-$(CONFIG_FUNCTION_TRACER)	+= ftrace.o entry-ftrace.o
 arm64-obj-$(CONFIG_MODULES)		+= arm64ksyms.o module.o
 arm64-obj-$(CONFIG_SMP)			+= smp.o smp_spin_table.o topology.o
@@ -41,6 +42,7 @@ arm64-obj-$(CONFIG_KEXEC)		+= machine_ke
 arm64-obj-$(CONFIG_CRASH_DUMP)		+= crash_dump.o
 
 obj-y					+= $(arm64-obj-y) vdso/
+obj-$(CONFIG_ARM64_ILP32)		+= vdso-ilp32/
 obj-m					+= $(arm64-obj-m)
 head-y					:= head.o
 extra-y					:= $(head-y) vmlinux.lds
@@ -48,3 +50,7 @@ extra-y					:= $(head-y) vmlinux.lds
 # vDSO - this must be built first to generate the symbol offsets
 $(call objectify,$(arm64-obj-y)): $(obj)/vdso/vdso-offsets.h
 $(obj)/vdso/vdso-offsets.h: $(obj)/vdso
+
+# vDSO - this must be built first to generate the symbol offsets
+$(call objectify,$(arm64-obj-y)): $(obj)/vdso-ilp32/vdso-ilp32-offsets.h
+$(obj)/vdso-ilp32/vdso-ilp32-offsets.h: $(obj)/vdso-ilp32
diff -Naurp linux-d7e124d/arch/arm64/kernel/sys_ilp32.c linux-d7e124d-patch/arch/arm64/kernel/sys_ilp32.c
--- linux-d7e124d/arch/arm64/kernel/sys_ilp32.c	2016-12-04 12:27:46.000000000 +0200
+++ linux-d7e124d-patch/arch/arm64/kernel/sys_ilp32.c	2016-12-04 13:13:19.000000000 +0200
@@ -38,8 +38,6 @@
 /* iovec */
 #define sys_readv		compat_sys_readv
 #define sys_writev		compat_sys_writev
-#define sys_preadv		compat_sys_preadv64
-#define sys_pwritev		compat_sys_pwritev64
 #define sys_vmsplice		compat_sys_vmsplice
 /* robust_list_head */
 #define sys_set_robust_list	compat_sys_set_robust_list
diff -Naurp linux-d7e124d/arch/arm64/kernel/vdso.c linux-d7e124d-patch/arch/arm64/kernel/vdso.c
--- linux-d7e124d/arch/arm64/kernel/vdso.c	2016-11-30 16:43:57.000000000 +0200
+++ linux-d7e124d-patch/arch/arm64/kernel/vdso.c	2016-12-04 12:49:54.000000000 +0200
@@ -40,6 +40,12 @@ extern char vdso_start, vdso_end;
 static unsigned long vdso_pages;
 static struct page **vdso_pagelist;
 
+#ifdef CONFIG_ARM64_ILP32
+extern char vdso_ilp32_start, vdso_ilp32_end;
+static unsigned long vdso_ilp32_pages;
+static struct page **vdso_ilp32_pagelist;
+#endif
+
 /*
  * The vDSO data page.
  */
@@ -49,7 +55,7 @@ static union {
 } vdso_data_store __page_aligned_data;
 struct vdso_data *vdso_data = &vdso_data_store.data;
 
-#ifdef CONFIG_COMPAT
+#ifdef CONFIG_AARCH32_EL0
 /*
  * Create and map the vectors page for AArch32 tasks.
  */
@@ -102,66 +108,80 @@ int aarch32_setup_vectors_page(struct li
 
 	return ret;
 }
-#endif /* CONFIG_COMPAT */
+#endif /* CONFIG_AARCH32_EL0 */
 
-static int __init vdso_init(void)
+static inline int __init vdso_init_common(char *vdso_start, char *vdso_end,
+					  unsigned long *vdso_pagesp,
+					  struct page ***vdso_pagelistp)
 {
-	struct page *pg;
-	char *vbase;
-	int i, ret = 0;
+	int i;
+	unsigned long vdso_pages;
+	struct page **vdso_pagelist;
+
+	if (memcmp(vdso_start, "\177ELF", 4)) {
+		pr_err("vDSO is not a valid ELF object!\n");
+		return -EINVAL;
+	}
 
-	vdso_pages = (&vdso_end - &vdso_start) >> PAGE_SHIFT;
+	vdso_pages = (vdso_end - vdso_start) >> PAGE_SHIFT;
+	*vdso_pagesp = vdso_pages;
 	pr_info("vdso: %ld pages (%ld code, %ld data) at base %p\n",
-		vdso_pages + 1, vdso_pages, 1L, &vdso_start);
+		vdso_pages + 1, vdso_pages, 1L, vdso_start);
 
 	/* Allocate the vDSO pagelist, plus a page for the data. */
-	vdso_pagelist = kzalloc(sizeof(struct page *) * (vdso_pages + 1),
+	vdso_pagelist = kcalloc(vdso_pages + 1, sizeof(struct page *),
 				GFP_KERNEL);
-	if (vdso_pagelist == NULL) {
-		pr_err("Failed to allocate vDSO pagelist!\n");
+	*vdso_pagelistp = vdso_pagelist;
+	if (vdso_pagelist == NULL)
 		return -ENOMEM;
-	}
 
 	/* Grab the vDSO code pages. */
-	for (i = 0; i < vdso_pages; i++) {
-		pg = virt_to_page(&vdso_start + i*PAGE_SIZE);
-		ClearPageReserved(pg);
-		get_page(pg);
-		vdso_pagelist[i] = pg;
-	}
-
-	/* Sanity check the shared object header. */
-	vbase = vmap(vdso_pagelist, 1, 0, PAGE_KERNEL);
-	if (vbase == NULL) {
-		pr_err("Failed to map vDSO pagelist!\n");
-		return -ENOMEM;
-	} else if (memcmp(vbase, "\177ELF", 4)) {
-		pr_err("vDSO is not a valid ELF object!\n");
-		ret = -EINVAL;
-		goto unmap;
-	}
+	for (i = 0; i < vdso_pages; i++)
+		vdso_pagelist[i] = virt_to_page(vdso_start + i * PAGE_SIZE);
 
 	/* Grab the vDSO data page. */
-	pg = virt_to_page(vdso_data);
-	get_page(pg);
-	vdso_pagelist[i] = pg;
+	vdso_pagelist[i] = virt_to_page(vdso_data);
 
-unmap:
-	vunmap(vbase);
-	return ret;
+	return 0;
+}
+
+static int __init vdso_init(void)
+{
+	return vdso_init_common(&vdso_start, &vdso_end,
+				&vdso_pages, &vdso_pagelist);
 }
 arch_initcall(vdso_init);
 
+#ifdef CONFIG_ARM64_ILP32
+static int __init vdso_ilp32_init(void)
+{
+	return vdso_init_common(&vdso_ilp32_start, &vdso_ilp32_end,
+				&vdso_ilp32_pages, &vdso_ilp32_pagelist);
+}
+arch_initcall(vdso_ilp32_init);
+#endif
+
 int arch_setup_additional_pages(struct linux_binprm *bprm,
 				int uses_interp)
 {
 	struct mm_struct *mm = current->mm;
-	unsigned long vdso_base, vdso_text_len, vdso_mapping_len;
+	unsigned long vdso_base, vdso_mapping_len;
 	int ret;
+	struct page **pagelist;
+	unsigned long pages;
 
-	vdso_text_len = vdso_pages << PAGE_SHIFT;
 	/* Be sure to map the data page */
-	vdso_mapping_len = vdso_text_len + PAGE_SIZE;
+#ifdef CONFIG_ARM64_ILP32
+	if (is_ilp32_compat_task()) {
+		pages = vdso_ilp32_pages;
+		pagelist = vdso_ilp32_pagelist;
+	} else
+#endif
+	{
+		pages = vdso_pages;
+		pagelist = vdso_pagelist;
+	}
+	vdso_mapping_len = (pages + 1) << PAGE_SHIFT;
 
 	down_write(&mm->mmap_sem);
 	vdso_base = get_unmapped_area(NULL, 0, vdso_mapping_len, 0, 0);
@@ -171,26 +191,18 @@ int arch_setup_additional_pages(struct l
 	}
 	mm->context.vdso = (void *)vdso_base;
 
-	ret = install_special_mapping(mm, vdso_base, vdso_text_len,
+	ret = install_special_mapping(mm, vdso_base, vdso_mapping_len,
 				      VM_READ|VM_EXEC|
 				      VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC,
-				      vdso_pagelist);
-	if (ret)
+				      pagelist);
+	if (ret) {
+		mm->context.vdso = NULL;
 		goto up_fail;
-
-	vdso_base += vdso_text_len;
-	ret = install_special_mapping(mm, vdso_base, PAGE_SIZE,
-				      VM_READ|VM_MAYREAD,
-				      vdso_pagelist + vdso_pages);
-	if (ret)
-		goto up_fail;
-
-	up_write(&mm->mmap_sem);
-	return 0;
+	}
 
 up_fail:
-	mm->context.vdso = NULL;
 	up_write(&mm->mmap_sem);
+
 	return ret;
 }
 
@@ -210,7 +222,7 @@ const char *arch_vma_name(struct vm_area
 	 * it conflicting with the vectors base.
 	 */
 	if (vma->vm_start == vdso_text) {
-#ifdef CONFIG_COMPAT
+#ifdef CONFIG_AARCH32_EL0
 		if (vma->vm_start == AARCH32_VECTORS_BASE)
 			return "[vectors]";
 #endif
diff -Naurp linux-d7e124d/arch/arm64/Makefile linux-d7e124d-patch/arch/arm64/Makefile
--- linux-d7e124d/arch/arm64/Makefile	2016-11-30 16:43:57.000000000 +0200
+++ linux-d7e124d-patch/arch/arm64/Makefile	2016-12-04 12:51:46.000000000 +0200
@@ -21,14 +21,18 @@ KBUILD_DEFCONFIG := defconfig
 
 KBUILD_CFLAGS	+= -mgeneral-regs-only
 KBUILD_CFLAGS	+= -fno-pic
+KBUILD_CFLAGS	+= $(call cc-option,-mabi=lp64)
+KBUILD_AFLAGS	+= $(call cc-option,-mabi=lp64)
 ifeq ($(CONFIG_CPU_BIG_ENDIAN), y)
 KBUILD_CPPFLAGS	+= -mbig-endian
 AS		+= -EB
 LD		+= -EB
+LDFLAGS		+= -maarch64linuxb
 else
 KBUILD_CPPFLAGS	+= -mlittle-endian
 AS		+= -EL
 LD		+= -EL
+LDFLAGS		+= -maarch64linux
 endif
 
 comma = ,
